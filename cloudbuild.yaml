# Google Cloud Build Configuration
# This file defines the CI/CD pipeline for building, testing, and deploying the application.
# Supports both staging and production environments via substitution variables.

steps:
  # 1. Build the backend Docker image
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Build Backend'
    args:
      - 'build'
      - '-t'
      - '${_LOCATION}-docker.pkg.dev/${PROJECT_ID}/${_REPO_NAME}/backend:latest'
      - '-f'
      - 'Dockerfile.backend'
      - '.'
    waitFor: ['-']

  # 2. Build the frontend Docker image
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Build Frontend'
    args:
      - 'build'
      - '-t'
      - '${_LOCATION}-docker.pkg.dev/${PROJECT_ID}/${_REPO_NAME}/frontend:latest'
      # Pass the public API URL as a build argument for the frontend
      - '--build-arg'
      - 'NEXT_PUBLIC_API_URL=${_NEXT_PUBLIC_API_URL}'
      - '-f'
      - 'Dockerfile.frontend'
      - '.'
    waitFor: ['-']

  # 3. Push the backend image to Artifact Registry
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Push Backend'
    args:
      - 'push'
      - '${_LOCATION}-docker.pkg.dev/${PROJECT_ID}/${_REPO_NAME}/backend:latest'
    waitFor: ['Build Backend']

  # 4. Push the frontend image to Artifact Registry
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Push Frontend'
    args:
      - 'push'
      - '${_LOCATION}-docker.pkg.dev/${PROJECT_ID}/${_REPO_NAME}/frontend:latest'
    waitFor: ['Build Frontend']

  # 5. Deploy Backend to Cloud Run (migration will run on startup)
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'Deploy Backend'
    entrypoint: bash
    args:
      - '-c'
      - |
          set -euo pipefail
          
          # Clear any default gcloud service account settings to ensure explicit specification is used
          echo "ðŸ”§ Clearing default gcloud service account configuration..."
          gcloud config unset run/service-account 2>/dev/null || true
          
          EXTRA_FLAGS=()
          if [[ -n "${_BACKEND_DEPLOY_FLAGS}" ]]; then
            # _BACKEND_DEPLOY_FLAGS may contain multiple flags separated by spaces.
            read -r -a EXTRA_FLAGS <<< "${_BACKEND_DEPLOY_FLAGS}"
          fi

          # Get service account email based on environment
          if [[ "${_ENVIRONMENT}" == "staging" ]]; then
            SERVICE_ACCOUNT_EMAIL="${_BACKEND_SERVICE_ACCOUNT_STAGING}"
          else
            SERVICE_ACCOUNT_EMAIL="${_BACKEND_SERVICE_ACCOUNT}"
          fi

          # Debug output to verify correct service account and secrets are being used
          echo "ðŸ“‹ Deployment Configuration:"
          echo "  Environment: ${_ENVIRONMENT}"
          echo "  Service Name: ${_BACKEND_SERVICE_NAME}"
          echo "  Service Account Email: ${SERVICE_ACCOUNT_EMAIL}"
          echo "  Cloud SQL Connection: ${_CLOUD_SQL_CONNECTION_NAME}"
          echo ""
          echo "ðŸ” Secrets Configuration:"
          echo "  DATABASE_URL: ${_DATABASE_URL_SECRET_NAME}:${_DATABASE_URL_SECRET_VERSION}"
          echo "  JWT_SECRET: ${_JWT_SECRET_NAME}:${_JWT_SECRET_VERSION}"
          echo "  JWT_REFRESH_SECRET: ${_JWT_REFRESH_SECRET_NAME}:${_JWT_REFRESH_SECRET_VERSION}"
          echo "  CSRF_TOKEN_SECRET: ${_CSRF_TOKEN_SECRET_NAME}:${_CSRF_TOKEN_SECRET_VERSION}"

          # Use the service account email directly (Cloud Run accepts email format)
          gcloud run deploy "${_BACKEND_SERVICE_NAME}" \
            --image "${_LOCATION}-docker.pkg.dev/${PROJECT_ID}/${_REPO_NAME}/backend:latest" \
            --region "${_LOCATION}" \
            --platform managed \
            --execution-environment=gen2 \
            --service-account "${SERVICE_ACCOUNT_EMAIL}" \
            --allow-unauthenticated \
            --set-secrets "DATABASE_URL=${_DATABASE_URL_SECRET_NAME}:${_DATABASE_URL_SECRET_VERSION},JWT_SECRET=${_JWT_SECRET_NAME}:${_JWT_SECRET_VERSION},JWT_REFRESH_SECRET=${_JWT_REFRESH_SECRET_NAME}:${_JWT_REFRESH_SECRET_VERSION},CSRF_TOKEN_SECRET=${_CSRF_TOKEN_SECRET_NAME}:${_CSRF_TOKEN_SECRET_VERSION}" \
            --set-env-vars "NODE_ENV=${_ENVIRONMENT},CORS_ORIGIN=${_CORS_ORIGIN},INSTANCE_CONNECTION_NAME=${_CLOUD_SQL_CONNECTION_NAME}" \
            --add-cloudsql-instances "${_CLOUD_SQL_CONNECTION_NAME}" \
            --concurrency 20 \
            --max-instances 3 \
            --min-instances 0 \
            --memory 512Mi \
            --cpu 1 \
            --cpu-boost \
            --timeout 300 \
            --port 8080 \
            --startup-probe=failureThreshold=10,timeoutSeconds=240,periodSeconds=240,httpGet.port=8080,httpGet.path=/health \
            "${EXTRA_FLAGS[@]}"
    waitFor: ['Push Backend']

  # 6. Deploy Frontend to Cloud Run
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'Deploy Frontend'
    entrypoint: bash
    args:
      - '-c'
      - |
          set -euo pipefail
          
          # Clear any default gcloud service account settings to ensure explicit specification is used
          echo "ðŸ”§ Clearing default gcloud service account configuration..."
          gcloud config unset run/service-account 2>/dev/null || true
          
          EXTRA_FLAGS=()
          if [[ -n "${_FRONTEND_DEPLOY_FLAGS}" ]]; then
            read -r -a EXTRA_FLAGS <<< "${_FRONTEND_DEPLOY_FLAGS}"
          fi

          # Get service account email based on environment
          if [[ "${_ENVIRONMENT}" == "staging" ]]; then
            SERVICE_ACCOUNT_EMAIL="${_FRONTEND_SERVICE_ACCOUNT_STAGING}"
          else
            SERVICE_ACCOUNT_EMAIL="${_FRONTEND_SERVICE_ACCOUNT}"
          fi

          # Debug output to verify correct service account is being used
          echo "ðŸ“‹ Deployment Configuration:"
          echo "  Environment: ${_ENVIRONMENT}"
          echo "  Service Name: ${_FRONTEND_SERVICE_NAME}"
          echo "  Service Account Email: ${SERVICE_ACCOUNT_EMAIL}"
          echo "  API URL: ${_NEXT_PUBLIC_API_URL}"

          # Use the service account email directly (Cloud Run accepts email format)
          gcloud run deploy "${_FRONTEND_SERVICE_NAME}" \
            --image "${_LOCATION}-docker.pkg.dev/${PROJECT_ID}/${_REPO_NAME}/frontend:latest" \
            --region "${_LOCATION}" \
            --platform managed \
            --allow-unauthenticated \
            --set-env-vars "NODE_ENV=${_ENVIRONMENT},NEXT_PUBLIC_API_URL=${_NEXT_PUBLIC_API_URL}" \
            --execution-environment=gen2 \
            --service-account "${SERVICE_ACCOUNT_EMAIL}" \
            --concurrency 50 \
            --cpu-boost \
            "${EXTRA_FLAGS[@]}"
    waitFor: ['Push Frontend']

# Define images to be pushed to Artifact Registry
images:
  - '${_LOCATION}-docker.pkg.dev/${PROJECT_ID}/${_REPO_NAME}/backend:latest'
  - '${_LOCATION}-docker.pkg.dev/${PROJECT_ID}/${_REPO_NAME}/frontend:latest'

# Define substitution variables that can be passed at build time
substitutions:
  _LOCATION: 'asia-northeast1' # Tokyo region
  _REPO_NAME: 'mycats-pro'
  _ENVIRONMENT: 'production' # Default environment (can be 'staging' or 'production')
  # Production environment settings (defaults)
  _BACKEND_SERVICE_NAME: 'mycats-pro-backend'
  _FRONTEND_SERVICE_NAME: 'mycats-pro-frontend'
  _NEXT_PUBLIC_API_URL: 'https://mycats-pro-backend-518939509282.asia-northeast1.run.app/api/v1'
  _CORS_ORIGIN: 'https://mycats-pro-frontend-518939509282.asia-northeast1.run.app'
  # Cloud SQL connection name (default: production instance)
  # Staging overrides this with: my-cats-pro:asia-northeast1:mycats-stg-db
  _CLOUD_SQL_CONNECTION_NAME: 'my-cats-pro:asia-northeast1:mycats-prod-db'
  _BACKEND_SERVICE_ACCOUNT: 'cloud-run-backend@my-cats-pro.iam.gserviceaccount.com'
  _FRONTEND_SERVICE_ACCOUNT: 'cloud-run-frontend@my-cats-pro.iam.gserviceaccount.com'
  # Staging environment service accounts
  _BACKEND_SERVICE_ACCOUNT_STAGING: 'cloud-run-backend-staging@my-cats-pro.iam.gserviceaccount.com'
  _FRONTEND_SERVICE_ACCOUNT_STAGING: 'cloud-run-frontend-staging@my-cats-pro.iam.gserviceaccount.com'
  # Secret names (defaults to production, override for staging)
  _DATABASE_URL_SECRET_NAME: 'DATABASE_URL'
  _JWT_SECRET_NAME: 'JWT_SECRET'
  _JWT_REFRESH_SECRET_NAME: 'JWT_REFRESH_SECRET'
  _CSRF_TOKEN_SECRET_NAME: 'CSRF_TOKEN_SECRET'
  # Secret versions (all using v1)
  _DATABASE_URL_SECRET_VERSION: '1'
  _JWT_SECRET_VERSION: '1'
  _JWT_REFRESH_SECRET_VERSION: '1'
  _CSRF_TOKEN_SECRET_VERSION: '1'
  _BACKEND_DEPLOY_FLAGS: ''
  _FRONTEND_DEPLOY_FLAGS: ''

options:
  logging: CLOUD_LOGGING_ONLY
