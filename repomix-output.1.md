This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

# File Summary

## Purpose
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/node_modules/**, **/dist/**, **/*.png, **/*.jpg
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
.cursor/
  commands/
    backendenv.md
  rules/
    ai-checklist/
      RULE.md
    backend/
      RULE.md
    docs/
      RULE.md
    frontend/
      RULE.md
    gemini-tips/
      RULE.md
    package-guard/
      RULE.md
    project-core/
      RULE.md
    request-templates/
      RULE.md
.github/
  agents/
    backend-agent.md
    docs-agent.md
    frontend-agent.md
    test-agent.md
    vertical_review_agent_specification.md
  guards/
    package-added-guard.md
  instructions/
    backend.instructions.md
    docs.instructions.md
    frontend.instructions.md
  ISSUE_TEMPLATE/
    critical-env-file-tracking.md
    high-auth-bypass.md
    medium-frontend-env-example.md
  workflows/
    ci-cd.yml
    deploy-only.yml
    trigger-deploy-from-ci.yml
  ai-checklist.md
  CICD_PRODUCTION_GUIDE.md
  COPILOT_INSTRUCTIONS_README.md
  copilot-instructions.md
  DEPLOYMENT_CHECKLIST.md
  DEPLOYMENT_SECRETS_SETUP.md
  staged-verification.md
  user-feedback-priority.md
backend/
  prisma/
    migrations/
      20251004195835_init/
        migration.sql
      20251004205546_sync_pedigree_schema/
        migration.sql
      20251005205115_add_password_reset_fields/
        migration.sql
      20251005212034_add_performance_indexes/
        migration.sql
      20251011063613_add_breeding_ng_rules/
        migration.sql
      20251011082000_add_care_type_to_schedules/
        migration.sql
      20251015090000_add_tag_category_automation/
        migration.sql
      20251015100000_add_tag_groups/
        migration.sql
      20251015110000_add_text_colors/
        migration.sql
      20251023131448_add_is_in_house_column/
        migration.sql
      20251023132517_rename_registration_id_to_registration_number/
        migration.sql
      20251023190628_add_breedingrecord/
        migration.sql
      20251023191845_update_pregnancy_birth_models/
        migration.sql
      20251023191932_update_enum_values/
        migration.sql
      20251028180807_add_schedule_cats_table/
        migration.sql
      20251101114041_add_father_and_mating_date_to_pregnancy_and_birth/
        migration.sql
      20251106161358_add_staff_shift_management/
        migration.sql
      20251108122748_add_kitten_disposition_and_birth_completion/
        migration.sql
      20251108135042_add_page_action_event_type/
        migration.sql
      20251109034116_add_medical_page/
        migration.sql
      20251110175612_add_visit_type_relation/
        migration.sql
      20251111105249_add_graduation_table/
        migration.sql
      20251112000000_enhance_performance_indexes/
        migration.sql
      20251117001521_add_pedigrees_api/
        migration.sql
      20251117090000_add_display_preferences/
        migration.sql
      20251117171013_add_remove_coat_color_name_unique/
        migration.sql
      20251118001209_add_performance_indexes/
        migration.sql
      20251126000000_add_multi_tenant_support/
        migration.sql
      20251129203404_add_staff_working_schedule/
        migration.sql
      20251206064624_add_gallery_models/
        migration.sql
      20251210203339_add_tenant_settings/
        migration.sql
      20251212231309_add_print_template_with_category_tenant/
        migration.sql
      20251219032719_add_weight_records/
        migration.sql
      20251219090000_add_pedigree_print_settings/
        migration.sql
      20251220010039_add_breeding_schedule_and_mating_check/
        migration.sql
      20251223003428_202512230930_add_tags_auto_new_style/
        migration.sql
      migration_lock.toml
    seed/
      convert_csv_header_to_snake_case.py
      current_data.sql
      import-breeds.ts
      import-coat-colors.ts
      import-direct.ts
      import-genders.ts
      import-pedigrees.ts
      seed-staff-shifts.ts
      verify-indexes.sql
    schema.prisma
    seed-admin.sql
    seed-cats-simple.sql
    seed-gallery-migration.ts
    seed.ts
  scripts/
    ensure-dev-build.mjs
    export-cats-seed.ts
    generate-secrets.mjs
  src/
    auth/
      dto/
        change-password.dto.ts
        login.dto.ts
        password-reset.dto.ts
        refresh-token.dto.ts
        request-password-reset.dto.ts
        reset-password.dto.ts
      auth.constants.spec.ts
      auth.constants.ts
      auth.controller.ts
      auth.module.ts
      auth.service.spec.ts
      auth.service.ts
      auth.types.ts
      get-user.decorator.ts
      jwt-auth.guard.ts
      jwt.strategy.ts
      login-attempt.service.ts
      password.service.ts
      role.guard.spec.ts
      role.guard.ts
      roles.decorator.ts
    breeding/
      dto/
        birth-plan.dto.ts
        breeding-query.dto.ts
        breeding-schedule.dto.ts
        create-breeding-ng-rule.dto.ts
        create-breeding.dto.ts
        index.ts
        kitten-disposition.dto.ts
        pregnancy-check.dto.ts
        update-breeding-ng-rule.dto.ts
        update-breeding.dto.ts
      types/
        breeding.types.ts
      breeding.controller.spec.ts
      breeding.controller.ts
      breeding.module.ts
      breeding.service.spec.ts
      breeding.service.ts
    breeds/
      dto/
        breed-query.dto.ts
        create-breed.dto.ts
        index.ts
        update-breed.dto.ts
      breed-master.data.ts
      breeds.controller.spec.ts
      breeds.controller.ts
      breeds.module.ts
      breeds.service.spec.ts
      breeds.service.ts
    care/
      dto/
        care-query.dto.ts
        care-schedule-response.dto.ts
        complete-care.dto.ts
        create-care-schedule.dto.ts
        create-medical-record.dto.ts
        index.ts
        medical-record-query.dto.ts
        medical-record-response.dto.ts
      care.controller.spec.ts
      care.controller.ts
      care.module.ts
      care.service.spec.ts
      care.service.ts
      json-value.utils.spec.ts
      json-value.utils.ts
      recurrence.utils.spec.ts
      recurrence.utils.ts
    cats/
      constants/
        gender.spec.ts
        gender.ts
      dto/
        cat-family.dto.ts
        cat-query.dto.ts
        cat-statistics.dto.ts
        create-cat.dto.ts
        index.ts
        kitten-query.dto.ts
        update-cat.dto.ts
        weight-record.dto.ts
      types/
        cat.types.ts
      cats.controller.spec.ts
      cats.controller.ts
      cats.module.ts
      cats.service.spec.ts
      cats.service.ts
    coat-colors/
      dto/
        coat-color-query.dto.ts
        create-coat-color.dto.ts
        index.ts
        update-coat-color.dto.ts
      coat-color-master.data.ts
      coat-colors.controller.spec.ts
      coat-colors.controller.ts
      coat-colors.module.ts
      coat-colors.service.spec.ts
      coat-colors.service.ts
    common/
      config/
        env.validation.ts
        rate-limit.config.ts
      controllers/
        master-data.controller.ts
      decorators/
        public.decorator.ts
        rate-limit.decorator.ts
      dto/
        api-response.dto.ts
      filters/
        enhanced-global-exception.filter.ts
        global-exception.filter.ts
      guards/
        enhanced-throttler.guard.ts
        tenant-scoped.guard.spec.ts
        tenant-scoped.guard.ts
      interceptors/
        performance-monitoring.interceptor.ts
        transform-response.interceptor.ts
      middleware/
        cookie-parser.middleware.ts
        request-id.middleware.ts
        security.middleware.ts
      types/
        express.d.ts
        shift.types.ts
        staff.types.ts
      environment.validation.ts
    display-preferences/
      dto/
        master-data-item.dto.ts
        update-display-preference.dto.ts
      display-preferences.controller.spec.ts
      display-preferences.controller.ts
      display-preferences.module.ts
      display-preferences.service.spec.ts
      display-preferences.service.ts
      display-preferences.types.ts
    email/
      email.module.ts
      email.service.spec.ts
      email.service.ts
    export/
      dto/
        export-request.dto.ts
      export.controller.ts
      export.module.ts
      export.service.ts
    gallery/
      dto/
        add-media.dto.ts
        create-gallery-entry.dto.ts
        gallery-query.dto.ts
        index.ts
        update-gallery-entry.dto.ts
      gallery.controller.ts
      gallery.module.ts
      gallery.service.ts
    gallery-upload/
      dto/
        confirm-upload.dto.ts
        generate-upload-url.dto.ts
        index.ts
      interfaces/
        upload-result.interface.ts
      gallery-upload.controller.ts
      gallery-upload.module.ts
      gallery-upload.service.ts
    graduation/
      dto/
        index.ts
        transfer-cat.dto.ts
      graduation.controller.spec.ts
      graduation.controller.ts
      graduation.module.ts
      graduation.service.spec.ts
      graduation.service.ts
    health/
      health.controller.spec.ts
      health.controller.ts
      health.module.ts
    import/
      dto/
        import-response.dto.ts
      import.controller.ts
      import.module.ts
      import.service.ts
    pedigree/
      dto/
        create-pedigree.dto.ts
        index.ts
        pedigree-query.dto.ts
        update-pedigree.dto.ts
      pdf/
        pedigree-pdf.service.ts
        positions.json
        print-settings.service.ts
      types/
        pedigree.types.ts
      pedigree.controller.spec.ts
      pedigree.controller.ts
      pedigree.module.ts
      pedigree.service.spec.ts
      pedigree.service.ts
    print-templates/
      dto/
        index.ts
        print-template.dto.ts
      index.ts
      print-templates.controller.ts
      print-templates.module.ts
      print-templates.service.ts
    prisma/
      prisma.module.ts
      prisma.service.ts
      seed.ts
    schedule/
      schedule.module.ts
    scripts/
      utils/
        prisma-batch.ts
      build-pedigree-relations.ts
      check-parent-pedigrees.ts
      create-admin.ts
      create-or-update-admin.ts
      create-views-and-preview.ts
      generate-swagger.ts
      import-csv-data.ts
      import-master-data.ts
      import-parent-pedigrees.ts
      import-pedigree-data.ts
      inspect-admin.ts
      inspect-schema.ts
      list-tag-categories.ts
      rename-pedigree-csv.ts
      selective-csv-import.ts
      sync-prisma.mjs
      test-auth-login.ts
    shift/
      dto/
        create-shift-template.dto.ts
        create-shift.dto.ts
        get-shifts-query.dto.ts
        update-shift.dto.ts
      shift.controller.spec.ts
      shift.controller.ts
      shift.module.ts
      shift.service.spec.ts
      shift.service.ts
    staff/
      dto/
        create-staff.dto.ts
        update-staff.dto.ts
      staff.controller.spec.ts
      staff.controller.ts
      staff.module.ts
      staff.service.spec.ts
      staff.service.ts
    tags/
      dto/
        assign-tag.dto.ts
        create-tag-automation-rule.dto.ts
        create-tag-category.dto.ts
        create-tag-group.dto.ts
        create-tag.dto.ts
        index.ts
        reorder-tag-category.dto.ts
        reorder-tag-group.dto.ts
        reorder-tag.dto.ts
        update-tag-automation-rule.dto.ts
        update-tag-category.dto.ts
        update-tag-group.dto.ts
        update-tag.dto.ts
      events/
        tag-automation.events.ts
      age-threshold-checker.service.ts
      tag-automation-execution.service.ts
      tag-automation.controller.ts
      tag-automation.service.spec.ts
      tag-automation.service.ts
      tag-categories.controller.ts
      tag-categories.service.ts
      tag-groups.controller.ts
      tag-groups.service.ts
      tags.controller.ts
      tags.module.ts
      tags.service.ts
    tenant-settings/
      dto/
        tag-color-defaults.dto.ts
      tenant-settings.controller.ts
      tenant-settings.module.ts
      tenant-settings.service.ts
    tenants/
      dto/
        create-tenant.dto.ts
        invitation.dto.ts
        update-tenant.dto.ts
      tenants.controller.ts
      tenants.module.ts
      tenants.service.spec.ts
      tenants.service.ts
    test-utils/
      test-module-setup.ts
    upload/
      upload.module.ts
    users/
      dto/
        invite-user.dto.ts
        update-profile.dto.ts
        update-user-role.dto.ts
      users.controller.ts
      users.module.ts
      users.service.spec.ts
      users.service.ts
    app.controller.spec.ts
    app.controller.ts
    app.module.ts
    main.ts
  test/
    utils/
      create-test-app.ts
    auth-breeding.e2e-spec.ts
    auth-jwt.e2e-spec.ts
    auth-password-reset.e2e-spec.ts
    auth-register.e2e-spec.ts
    auth-seed-user.e2e-spec.ts
    breeding-ng-rules.e2e-spec.ts
    breeds-coat-colors.e2e-spec.ts
    care-and-tags.e2e-spec.ts
    care-tags.e2e-spec.ts
    cats.e2e-spec.ts
    export.e2e-spec.ts
    import.e2e-spec.ts
    jest-e2e.json
    pedigree.e2e-spec.ts
    setup-e2e.ts
    tenants.e2e-spec.ts
    users-promote-superadmin.e2e-spec.ts
  .env.example
  .env.test
  AGENTS.md
  docker-entrypoint.sh
  eslint.config.mjs
  GEMINI.md
  nest-cli.json
  openapi.json
  package.json
  SEED_USER_GUIDE.md
  tsconfig.build.json
  tsconfig.eslint.json
  tsconfig.json
database/
  init/
    01-init.sh
    02-seed-cats.sql
docs/
  deployment/
    CUSTOM_DOMAIN_SETUP.md
    DOMAIN_AND_EMAIL_SETUP.md
    GCP_DEPLOYMENT_GUIDE.md
  diagrams/
    project-overview.md
    system-architecture.md
  api-specification.md
  CICD_DEPLOYMENT_FLOW.md
  DATABASE_DEPLOYMENT_GUIDE.md
  DATABASE_PRODUCTION_SCHEMA.md
  EMAIL_INTEGRATION_GUIDE.md
  mycats_pro_å†ç™ºé˜²æ­¢ã‚¬ãƒ¼ãƒ‰æ©Ÿæ§‹_å®Ÿè£…ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸.md
  naming_convention_guidelines_v2.md
  PEDIGREE_PDF_DESIGN.md
  production-deployment.md
  SUPER_ADMIN_SETUP.md
  system-design.md
  ui-button-design-guide.md
  Vertical_Review_Agent_Pronpt
  Vertical_Review_To_Copilot_Agent
frontend/
  scripts/
    generate-api-types.mjs
  src/
    __tests__/
      README.md
    app/
      __tests__/
        page.test.tsx
      accept-invitation/
        page.tsx
      breeding/
        components/
          BirthInfoModal.tsx
          BirthPlanTab.tsx
          BreedingScheduleTab.tsx
          CompleteConfirmModal.tsx
          FemaleSelectionModal.tsx
          index.ts
          MaleSelectionModal.tsx
          NewRuleModal.tsx
          NgRulesModal.tsx
          PregnancyCheckTab.tsx
          RaisingTab.tsx
          ShippingTab.tsx
          WeightTab.tsx
        hooks/
          index.ts
          useBreedingSchedule.ts
          useNgPairing.ts
        page.tsx
        page.tsx.backup
        types.ts
        utils.ts
      care/
        page.tsx
      cats/
        [id]/
          edit/
            client.tsx
            page.tsx
          pedigree/
            client.tsx
            page_new.tsx
            page.tsx
          client.tsx
          layout.tsx
          page.tsx
        new/
          page.tsx
        page.tsx
      demo/
        action-buttons/
          page.tsx
        unified-modal/
          page.tsx
      export/
        page.tsx
      forgot-password/
        page.tsx
      gallery/
        components/
          GalleryAddModal.tsx
          GalleryCatCard.tsx
          GalleryGrid.tsx
          GalleryTabs.tsx
          ImageUploader.tsx
          MediaCarousel.tsx
          MediaLightbox.tsx
          YouTubeInput.tsx
        hooks/
          useGalleryTab.ts
        page.tsx
      import/
        page.tsx
      kittens/
        page_new.tsx
        page.tsx
      login/
        page.tsx
      medical-records/
        page.tsx
      more/
        page.tsx
      pedigrees/
        _id_disabled/
          family-tree/
            client.tsx
            page.tsx
          client.tsx
          layout.tsx
          page.tsx
        new/
          page.tsx
        page.tsx
      print-templates/
        page.tsx
      register/
        page.tsx
      reset-password/
        page.tsx
      settings/
        page.tsx
      setup/
        first-superadmin/
          page.tsx
      staff/
        shifts/
          page.tsx
      tags/
        components/
          AutomationIndicator.tsx
          AutomationRuleModal.tsx
          AutomationTab.tsx
          CategoriesTab.tsx
          CategoryModal.tsx
          ExecuteRuleModal.tsx
          GroupModal.tsx
          index.ts
          SortableCategoryCard.tsx
          SortableGroupCard.tsx
          SortableTagItem.tsx
          TagModal.tsx
          TagsListTab.tsx
        hooks/
          index.ts
          useAutomationRulesData.ts
          useTagPageData.ts
        constants.ts
        page.tsx
        types.ts
        utils.ts
      tenants/
        _components/
          ActionMenu.tsx
          BottomNavSettings.tsx
          EditTenantModal.tsx
          InviteTenantAdminModal.tsx
          InviteUserModal.tsx
          TenantsList.tsx
          TenantsManagement.tsx
          UserProfileForm.tsx
          UsersList.tsx
        page.tsx
      CodeCitations.md
      favicon.ico
      globals.css
      layout.tsx
      manifest.ts
      page.module.css
      page.tsx
      providers.tsx
    components/
      __tests__/
        TagSelector.test.tsx
      badges/
        index.ts
      breeding/
        breeding-schedule-edit-modal.tsx
        kitten-disposition-modal.tsx
      buttons/
        IconActionButton.tsx
        index.ts
        PrimaryButton.tsx
      cards/
        CardSpreadDemo.module.css
        CardSpreadDemo.tsx
        CatTexturedCard.module.css
        CatTexturedCard.tsx
        index.ts
      cats/
        cat-edit-modal.tsx
        cat-quick-edit-modal.tsx
        PedigreeTab.tsx
      common/
        __tests__/
          UnifiedModal.test.tsx
        index.ts
        UNIFIED_MODAL_SECTIONS.md
        UnifiedModal.tsx
        UnifiedModalSectionsDemo.tsx
      context-menu/
        context-menu.tsx
        index.ts
        operation-modal-manager.tsx
        use-context-menu.ts
      dashboard/
        __tests__/
          DialNavigation.test.tsx
        DashboardCardSettings.tsx
        DialMenuSettings.tsx
        DialMenuV2.module.css
        DialNavigation.tsx
        DialNavigationExample.tsx
        DialWheel.module.css
        DialWheel.tsx
        DisplayModeToggle.tsx
        HexIconButton.module.css
        HexIconButton.tsx
      editable-field/
        editable-field.tsx
        field-edit-modal.tsx
      forms/
        ColorInputField.tsx
        DateInputField.tsx
        FormField.tsx
        MasterDataCombobox.tsx
      kittens/
        BulkWeightRecordModal.tsx
        KittenManagementModal.tsx
        WeightChart.tsx
        WeightRecordModal.tsx
        WeightRecordTable.tsx
      pedigrees/
        __tests__/
          PedigreeFamilyTree.test.tsx
          PedigreeList.test.tsx
          PedigreeRegistrationForm.callid.test.tsx
          PedigreeRegistrationForm.create.test.tsx
          PedigreeRegistrationForm.update.test.tsx
          PrintSettingsEditor.test.tsx
        PedigreeFamilyTree.tsx
        PedigreeList.tsx
        PedigreeRegistrationForm.tsx
        PrintSettingsEditor.tsx
      print-templates/
        index.ts
        PrintTemplateManager.tsx
      ui/
        InputWithFloatingLabel.module.css
        InputWithFloatingLabel.tsx
        SelectWithFloatingLabel.tsx
        TextareaWithFloatingLabel.tsx
      ActionButton.tsx
      AppLayout.tsx
      GenderBadge.tsx
      PageTitle.tsx
      README.md
      SectionTitle.tsx
      TabsSection.tsx
      TagSelector.tsx
    lib/
      api/
        generated/
          README.md
          schema.ts
        hooks/
          query-key-factory.ts
          use-breeding.ts
          use-breeds.ts
          use-care.ts
          use-cats.ts
          use-coat-colors.ts
          use-gallery-upload.ts
          use-gallery.ts
          use-graduation.ts
          use-master-data.ts
          use-pedigrees.ts
          use-tag-automation.ts
          use-tags.ts
          use-tenant-settings.ts
          use-weight-records.ts
        auth-store.ts
        client.ts
        index.ts
        public-api-base-url.ts
        query-client.tsx
        typesafe-client.ts
      auth/
        password-reset-store.ts
        routes.ts
        store.ts
        useBootstrapAuth.ts
      contexts/
        page-header-context.tsx
      hooks/
        use-bottom-nav-settings.ts
        use-selection-history.ts
      master-data/
        constants.ts
        master-options.ts
      schemas/
        cat.ts
        common.ts
        index.ts
      storage/
        dashboard-settings.ts
      store/
        theme-store.ts
      utils/
        image-resizer.ts
      api.ts
      invitation-utils.ts
    styles/
      page-header.css
    types/
      api.types.ts
    middleware.ts
  .gitignore
  AGENTS.md
  check-syntax.js
  eslint.config.mjs
  GEMINI.md
  jest.config.js
  jest.setup.js
  next.config.ts
  package.json
  postcss.config.mjs
  README.md
  sentry.client.config.ts
  sentry.server.config.ts
  tsconfig.json
nginx/
  conf.d/
    default.conf
  nginx.conf
scripts/
  build-production.sh
  check-memory.mjs
  diagnose.sh
  export-cats-seed.ps1
  export-cats-seed.sh
  generate-secrets.ts
  health-check.sh
  kill-backend.sh
  local-postgres.sh
  preflight-backend.sh
  prestart-migrate.sh
  quick-start.sh
  setup-custom-domain.sh
  setup-dev-docker.bat
  setup-dev-docker.sh
  setup-dev.sh
  setup-domain-and-email.sh
  start-all.bat
  start-all.sh
  start-dev-stable.mjs
  start-dev-stable.sh
  stop-dev.sh
  test-session-persistence.sh
  validate-deployment-config.sh
.dockerignore
.env.development.example
.env.docker.example
.env.production.example
.gitattributes
.gitignore
.trivyignore
AGENTS.md
cloudbuild.yaml
docker-compose.dev.yml
docker-compose.yml
Dockerfile.backend
Dockerfile.frontend
eslint.config.mjs
gcp_verification_results.md
IMPLEMENTATION_COMPLETE.md
init_database.sql
package.json
pnpm-workspace.yaml
README.md
seed_data.sql
SETUP_GUIDE.md
TROUBLESHOOTING.md
```

# Files

## File: .cursor/commands/backendenv.md
`````markdown

`````

## File: .cursor/rules/ai-checklist/RULE.md
`````markdown
---
description: "AI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒä½œæ¥­æ™‚ã«å¾“ã†ã¹ãè‡ªå·±æ¤œè¨¼ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ"
alwaysApply: true
---

# AI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ è‡ªå·±æ¤œè¨¼ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

## ğŸ“‹ ä½œæ¥­é–‹å§‹å‰ãƒã‚§ãƒƒã‚¯

- é–¢é€£ã™ã‚‹ CODE_GUIDE.md / AGENTS.md ã‚’èª­ã¿è¾¼ã¿æ¸ˆã¿
- æ—¢å­˜ã®é¡ä¼¼å®Ÿè£…ã‚’æ¤œç´¢æ¸ˆã¿ï¼ˆå†åˆ©ç”¨å¯èƒ½æ€§ã‚’ç¢ºèªï¼‰
- å½±éŸ¿ç¯„å›²ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¨ä¾å­˜é–¢ä¿‚ã‚’ç‰¹å®šæ¸ˆã¿

## ğŸ”§ å®Ÿè£…ä¸­ãƒã‚§ãƒƒã‚¯ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«å˜ä½ï¼‰

- æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆæ™‚: é…ç½®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒè²¬å‹™ã«é©åˆ
- å‹å®šç¾©: any/unknown ã‚’ä½¿ç”¨ã—ã¦ã„ãªã„ï¼ˆä¾‹å¤–æ™‚ã¯ç†ç”±ã‚³ãƒ¡ãƒ³ãƒˆ + ä»£æ›¿æ¡ˆæ¤œè¨æ¸ˆã¿ï¼‰
- é–¢æ•°: å¼•æ•°ãƒ»æˆ»ã‚Šå€¤ã®å‹ãŒå®Œå…¨ã«æ˜ç¤º
- Prisma: ã‚¹ã‚­ãƒ¼ãƒå¤‰æ›´æ™‚ã¯ `pnpm prisma:generate` å®Ÿè¡Œæ¸ˆã¿
- ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸è¿½åŠ æ™‚: `pnpm prisma:generate` å®Ÿè¡Œæ¸ˆã¿ï¼ˆPrisma Client å†ç”Ÿæˆï¼‰
- ã‚¨ãƒ©ãƒ¼å‡¦ç†: ç©º catch / console.error ã®ã¿ / void async ãŒãªã„

## âœ… æ©Ÿèƒ½å®Œæˆæ™‚ãƒã‚§ãƒƒã‚¯

- å½±éŸ¿ç¯„å›²ã®ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œ: `pnpm test`ï¼ˆè©²å½“ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼‰
- Lint ãƒã‚§ãƒƒã‚¯: `pnpm lint` ã§è­¦å‘Šãƒ»ã‚¨ãƒ©ãƒ¼ã‚¼ãƒ­
- ãƒ“ãƒ«ãƒ‰ç¢ºèª: `pnpm build`ï¼ˆbackend / frontendï¼‰æˆåŠŸ
- Prisma å¤‰æ›´æ™‚: `pnpm db:migrate` + `pnpm db:seed` ã§å‹•ä½œç¢ºèª

## ğŸš¨ ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯å„ªå…ˆåº¦

- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®èª¿æŸ»ç¤ºå”†ã¯å³åº§ã«æ–¹é‡ã¸åæ˜ 
- ã‚¨ãƒ©ãƒ¼ãƒ»è­¦å‘ŠæŒ‡æ‘˜æ™‚ã¯ä»–ä½œæ¥­ã‚’ä¸­æ–­
- AI åˆ¤æ–­ã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼æŒ‡ç¤ºãŒçŸ›ç›¾ã—ãŸå ´åˆã¯å¿…ãšãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å„ªå…ˆ

## ğŸ“ ä½œæ¥­å®Œäº†å‰ã®æœ€çµ‚ç¢ºèª

- ã™ã¹ã¦ã®å“è³ªã‚²ãƒ¼ãƒˆã‚’ PASSï¼ˆlint / build / testï¼‰
- æ—¥æœ¬èª UI è¦ä»¶ã‚’æº€ãŸã™ï¼ˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ»ã‚³ãƒ¡ãƒ³ãƒˆï¼‰
- å‹å®‰å…¨æ€§: any / unknown / é null ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ / äºŒæ®µã‚­ãƒ£ã‚¹ãƒˆãªã—
- ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°ï¼ˆREADME / è¨­è¨ˆè³‡æ–™ï¼‰
- å¤‰æ›´ç†ç”±ã¨å½±éŸ¿ç¯„å›²ã‚’èª¬æ˜å¯èƒ½

## ğŸ“ è¨¼è·¡æç¤ºï¼ˆå¿…é ˆï¼‰

- å®Ÿè¡Œã—ãŸã‚³ãƒãƒ³ãƒ‰ã¨çµæœãƒ­ã‚°ã€ã¾ãŸã¯ CI å®Ÿè¡Œ URL ã‚’æç¤º
`````

## File: .cursor/rules/backend/RULE.md
`````markdown
---
description: "NestJS 10 + Prisma 6 + PostgreSQL ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰é–‹ç™ºãƒ«ãƒ¼ãƒ«"
globs:
  - "backend/**/*.ts"
  - "backend/prisma/**"
  - "backend/test/**"
alwaysApply: false
---

# Backend é–‹ç™ºãƒ«ãƒ¼ãƒ«

## æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯

- NestJS 10
- Prisma 6.14.0
- PostgreSQL 15+
- TypeScript 5

## å¿…é ˆãƒ«ãƒ¼ãƒ«

### ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

```
Controller (HTTPå±¤)
  â†“ DTOã§ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
Service (ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯)
  â†“ Entityã‚„Prismaå‹ã§å‡¦ç†
Repository/PrismaService (ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹)
```

- Controller ã§ç›´æ¥ Prisma ã‚’å‘¼ã³å‡ºã•ãªã„
- Service ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…
- PrismaService ã‚’ä½¿ç”¨ã—ã¦ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹

### å‹å®‰å…¨

- `any` / `unknown` ã®ä½¿ç”¨ç¦æ­¢
- ã™ã¹ã¦ã®é–¢æ•°ã«æ˜ç¤ºçš„ãªå‹å®šç¾©
- DTO ã§å…¥åŠ›ã‚’ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³

### ã‚¨ãƒ©ãƒ¼å‡¦ç†

- `HttpException` ç³»ã‚’ä½¿ç”¨
- ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯æ—¥æœ¬èª
- é©åˆ‡ãªHTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’è¿”å´

### Prisma

- ã‚¹ã‚­ãƒ¼ãƒå¤‰æ›´å¾Œã¯å¿…ãš `prisma:generate` ã‚’å®Ÿè¡Œ
- ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ç”Ÿæˆã—ã¦é©ç”¨
- N+1 å•é¡Œã‚’é¿ã‘ã‚‹ï¼ˆselect/include ã§æœ€é©åŒ–ï¼‰

## ã‚³ãƒ¼ãƒ‰ä¾‹

### Service ã®æ¨™æº–å½¢

```typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { CreateCatDto } from './dto/create-cat.dto';

@Injectable()
export class CatsService {
  constructor(private prisma: PrismaService) {}

  async findOne(id: number) {
    const cat = await this.prisma.cat.findUnique({
      where: { id },
      select: {
        id: true,
        name: true,
        breed: true,
      },
    });

    if (!cat) {
      throw new NotFoundException('æŒ‡å®šã•ã‚ŒãŸçŒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    }

    return cat;
  }

  async create(dto: CreateCatDto) {
    return this.prisma.cat.create({
      data: {
        name: dto.name,
        breed: dto.breed,
      },
    });
  }
}
```

### DTO ã®æ¨™æº–å½¢

```typescript
import { IsString, IsNotEmpty, IsOptional, MaxLength } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class CreateCatDto {
  @ApiProperty({ description: 'çŒ«ã®åå‰', maxLength: 100 })
  @IsString()
  @IsNotEmpty({ message: 'åå‰ã¯å¿…é ˆã§ã™' })
  @MaxLength(100, { message: 'åå‰ã¯100æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„' })
  name: string;

  @ApiProperty({ description: 'å“ç¨®', required: false })
  @IsString()
  @IsOptional()
  breed?: string;
}
```

## ä½œæ¥­ãƒ•ãƒ­ãƒ¼

### æ–°è¦æ©Ÿèƒ½è¿½åŠ æ™‚

1. DTOã‚’å®šç¾©ï¼ˆå…¥åŠ›ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
2. Service ã«ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…
3. Controller ã«ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’è¿½åŠ 
4. Swagger ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ 
5. ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã‚’ä½œæˆ
6. E2E ãƒ†ã‚¹ãƒˆã§å®Ÿéš›ã®HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ãƒ†ã‚¹ãƒˆ

### Prisma ã‚¹ã‚­ãƒ¼ãƒå¤‰æ›´æ™‚

```bash
pnpm --filter backend run prisma:migrate  # ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç”Ÿæˆ
pnpm --filter backend run prisma:generate # TypeScript å‹ã‚’å†ç”Ÿæˆ
pnpm --filter backend run test            # ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
```

## å¤‰æ›´ã—ã¦ã¯ã„ã‘ãªã„ãƒ•ã‚¡ã‚¤ãƒ«

- `prisma/migrations/**` - ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã¯è‡ªå‹•ç”Ÿæˆã®ã¿
- `node_modules/**`
- `dist/**` - ãƒ“ãƒ«ãƒ‰æˆæœç‰©

## å“è³ªã‚²ãƒ¼ãƒˆ

å¤‰æ›´å¾Œã€å¿…ãšä»¥ä¸‹ã‚’å®Ÿè¡Œ:

```bash
pnpm --filter backend run lint
pnpm --filter backend run build
pnpm --filter backend run test
```

Prisma ã‚¹ã‚­ãƒ¼ãƒã‚’å¤‰æ›´ã—ãŸå ´åˆ:

```bash
pnpm --filter backend run prisma:generate
pnpm --filter backend run prisma:migrate
pnpm --filter backend run test
```

## å“è³ªãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

- ã™ã¹ã¦ã® public ãƒ¡ã‚½ãƒƒãƒ‰ã«å‹å®šç¾©ãŒã‚ã‚‹
- any/unknown ã‚’ä½¿ç”¨ã—ã¦ã„ãªã„
- ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒæ—¥æœ¬èªã§ã‚ã‚‹
- N+1 ã‚¯ã‚¨ãƒªãŒãªã„ï¼ˆselect/include ã§æœ€é©åŒ–ï¼‰
- DTO ã§ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãŒå®Œçµã—ã¦ã„ã‚‹
- Swagger ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãŒæ­£ç¢ºã§ã‚ã‚‹

## å‚è€ƒãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- [NestJS å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://docs.nestjs.com/)
- [Prisma ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹](https://www.prisma.io/docs/guides/performance-and-optimization)
`````

## File: .cursor/rules/docs/RULE.md
`````markdown
---
description: "ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆä½œæˆãƒ»ç·¨é›†æ™‚ã®ãƒ«ãƒ¼ãƒ«ï¼ˆæ—¥æœ¬èªã€ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆçµ±ä¸€ï¼‰"
globs:
  - "**/*.md"
  - "docs/**"
alwaysApply: false
---

# ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆä½œæˆãƒ«ãƒ¼ãƒ«

## å¿…é ˆãƒ«ãƒ¼ãƒ«

### è¨€èª

- **ã™ã¹ã¦ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯æ—¥æœ¬èªã§è¨˜è¿°**
- æŠ€è¡“ç”¨èªã¯è‹±èªã®ã¾ã¾ï¼ˆAPIã€HTTPã€JSON ãªã©ï¼‰
- ç°¡æ½”ã§å®Ÿå‹™çš„ãªè¡¨ç¾ã‚’ä½¿ç”¨
- æ©Ÿæ¢°ç¿»è¨³æ„Ÿã‚’é¿ã‘ã‚‹

### ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ

- è¦‹å‡ºã—ã®éšå±¤ã‚’é©åˆ‡ã«ä½¿ç”¨ï¼ˆh1, h2, h3ï¼‰
- ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã«ã¯è¨€èªã‚’æŒ‡å®š
- æ‰‹é †ã¯ç•ªå·ä»˜ããƒªã‚¹ãƒˆã§æ˜ç¤º
- é‡è¦ãªæƒ…å ±ã¯å¤ªå­—ã‚„ç®‡æ¡æ›¸ãã§å¼·èª¿

### ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯

````markdown
```typescript
// TypeScript ã‚³ãƒ¼ãƒ‰ä¾‹
interface Example {
  id: number;
  name: string;
}
```

```bash
# ã‚³ãƒãƒ³ãƒ‰ä¾‹
pnpm install
pnpm dev
```
````

## ç¦æ­¢äº‹é …

- ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å¤‰æ›´ã—ãªã„ï¼ˆãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°ã®ã¿ï¼‰
- å¤ã„æƒ…å ±ã‚’æ®‹ã•ãªã„

## ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®ç¨®é¡

### README.md

ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“ã®æ¦‚è¦ã¨ä½¿ã„æ–¹ã€‚

**å¿…é ˆã‚»ã‚¯ã‚·ãƒ§ãƒ³:**
- ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦
- æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯
- ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆ
- ä¸»è¦æ©Ÿèƒ½
- ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### SETUP_GUIDE.md

åˆå›ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã®è©³ç´°æ‰‹é †ã€‚

**å«ã‚€ã¹ãå†…å®¹:**
- å‰ææ¡ä»¶
- ç’°å¢ƒå¤‰æ•°ã®è¨­å®š
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
- é–‹ç™ºç’°å¢ƒã®èµ·å‹•
- å‹•ä½œç¢ºèª

### TROUBLESHOOTING.md

ã‚ˆãã‚ã‚‹å•é¡Œã¨è§£æ±ºæ–¹æ³•ã€‚

**æ§‹æˆ:**
- å•é¡Œã®èª¬æ˜
- åŸå› 
- è§£æ±ºæ–¹æ³•
- äºˆé˜²ç­–

## æ›´æ–°ã‚¿ã‚¤ãƒŸãƒ³ã‚°

- æ–°æ©Ÿèƒ½è¿½åŠ æ™‚
- API ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆè¿½åŠ /å¤‰æ›´æ™‚
- ç’°å¢ƒå¤‰æ•°è¿½åŠ æ™‚
- ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æ‰‹é †å¤‰æ›´æ™‚
- ãƒã‚°ä¿®æ­£æ™‚ï¼ˆãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã«è¿½åŠ ï¼‰

## ãƒ•ã‚¡ã‚¤ãƒ«é…ç½®

### ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª

- `README.md` - ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“
- `SETUP_GUIDE.md` - ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
- `TROUBLESHOOTING.md` - ãƒˆãƒ©ãƒ–ãƒ«å¯¾å¿œ
- `DEPLOYMENT_*.md` - ãƒ‡ãƒ—ãƒ­ã‚¤é–¢é€£

### docs/ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª

- ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆæ›¸
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆæ›¸
- è©³ç´°ãªæŠ€è¡“ä»•æ§˜æ›¸

## å“è³ªãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

- æ—¥æœ¬èªã§è¨˜è¿°ã•ã‚Œã¦ã„ã‚‹
- ç°¡æ½”ã§åˆ†ã‹ã‚Šã‚„ã™ã„
- ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã«è¨€èªãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹
- ãƒªãƒ³ã‚¯ãŒæ­£ã—ãæ©Ÿèƒ½ã™ã‚‹
- ã‚¿ã‚¤ãƒãŒãªã„
- ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãŒçµ±ä¸€ã•ã‚Œã¦ã„ã‚‹
`````

## File: .cursor/rules/frontend/RULE.md
`````markdown
---
description: "Next.js 15 + React 19 + Mantine ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰é–‹ç™ºãƒ«ãƒ¼ãƒ«"
globs:
  - "frontend/**/*.tsx"
  - "frontend/**/*.ts"
  - "frontend/**/*.css"
alwaysApply: false
---

# Frontend é–‹ç™ºãƒ«ãƒ¼ãƒ«

## æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯

- Next.js 15 (App Router + React Server Components)
- React 19
- TypeScript 5
- Mantine UI
- Tailwind CSS

## å¿…é ˆãƒ«ãƒ¼ãƒ«

### React/Next.js

- Server Component ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¨ã™ã‚‹
- `"use client"` ã¯å¿…è¦ãªå ´åˆã®ã¿ä½¿ç”¨ã—ã€ç†ç”±ã‚’ã‚³ãƒ¡ãƒ³ãƒˆ
- App Router ã®è¦ç´„ã«å¾“ã†ï¼ˆpage.tsx, layout.tsx ãªã©ï¼‰

### å‹å®‰å…¨

- `any` / `unknown` ã®ä½¿ç”¨ç¦æ­¢
- ã™ã¹ã¦ã® Props ã«å‹å®šç¾©
- API ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã¯ç”Ÿæˆå‹ã‚’ä½¿ç”¨

### UI/UX

- æ—¥æœ¬èªæ–‡è¨€ã‚’ä½¿ç”¨
- ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ã‚’è€ƒæ…®ï¼ˆARIAã€ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œï¼‰
- ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ‡ã‚¶ã‚¤ãƒ³
- ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒ»ã‚¨ãƒ©ãƒ¼çŠ¶æ…‹ã‚’è¡¨ç¤º

### ã‚¹ã‚¿ã‚¤ãƒªãƒ³ã‚°

- Mantine UI ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’å„ªå…ˆ
- Tailwind CSS ã§è£œå®Œ
- ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã‚¹ã‚¿ã‚¤ãƒ«ã¯é¿ã‘ã‚‹

## ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ 

```
src/
â”œâ”€â”€ app/              # App Router ãƒšãƒ¼ã‚¸
â”‚   â”œâ”€â”€ page.tsx      # ãƒˆãƒƒãƒ—ãƒšãƒ¼ã‚¸
â”‚   â”œâ”€â”€ layout.tsx    # ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
â”‚   â””â”€â”€ cats/
â”‚       â”œâ”€â”€ page.tsx
â”‚       â””â”€â”€ _components/  # ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”œâ”€â”€ components/       # å…±æœ‰ UI ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ api/         # API ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
â”‚   â””â”€â”€ hooks/       # ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯
â””â”€â”€ styles/          # ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚¿ã‚¤ãƒ«
```

## ã‚³ãƒ¼ãƒ‰ä¾‹

### Server Component

```typescript
// app/example/page.tsx
import { getItems } from '@/lib/api/items';

export default async function ExamplePage() {
  const items = await getItems();

  return (
    <div>
      <h1>ã‚µãƒ³ãƒ—ãƒ«ãƒšãƒ¼ã‚¸</h1>
      {items.map((item) => (
        <div key={item.id}>{item.name}</div>
      ))}
    </div>
  );
}
```

### Client Component

```typescript
// app/example/_components/InteractiveList.tsx
'use client'; // ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãªæ©Ÿèƒ½ãŒå¿…è¦ãªãŸã‚

import { useState } from 'react';
import { Button } from '@mantine/core';

interface Props {
  items: Item[];
}

export function InteractiveList({ items }: Props) {
  const [selected, setSelected] = useState<number | null>(null);

  return (
    <div>
      {items.map((item) => (
        <Button key={item.id} onClick={() => setSelected(item.id)}>
          {item.name}
        </Button>
      ))}
    </div>
  );
}
```

### Server Actions

```typescript
// app/example/_actions.ts
'use server';

import { revalidatePath } from 'next/cache';

export async function createItemAction(formData: FormData) {
  const name = formData.get('name') as string;

  if (!name) {
    return { error: 'åå‰ã¯å¿…é ˆã§ã™' };
  }

  try {
    await createItem({ name });
    revalidatePath('/example');
    return { success: true };
  } catch (error) {
    return { error: 'ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ' };
  }
}
```

## Mantine UI ã®ä½¿ç”¨

```typescript
import { Button, Stack, Text, Card } from '@mantine/core';

<Stack gap="md">
  <Text size="lg" fw={700}>è¦‹å‡ºã—</Text>
  <Card shadow="sm" padding="lg">
    <Text>ã‚«ãƒ¼ãƒ‰ã®å†…å®¹</Text>
  </Card>
  <Button color="blue">ãƒœã‚¿ãƒ³</Button>
</Stack>
```

## å¤‰æ›´ã—ã¦ã¯ã„ã‘ãªã„ãƒ•ã‚¡ã‚¤ãƒ«

- `node_modules/**`
- `.next/**` - ãƒ“ãƒ«ãƒ‰æˆæœç‰©
- `src/lib/api/generated/**` - OpenAPI ç”Ÿæˆãƒ•ã‚¡ã‚¤ãƒ«

## å“è³ªã‚²ãƒ¼ãƒˆ

å¤‰æ›´å¾Œã€å¿…ãšä»¥ä¸‹ã‚’å®Ÿè¡Œ:

```bash
pnpm --filter frontend run lint
pnpm --filter frontend run type-check
pnpm --filter frontend run build
```

UI å¤‰æ›´ã®å ´åˆ:
- ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ã‚’ç¢ºèª
- ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ã‚’ãƒã‚§ãƒƒã‚¯
- ã‚¨ãƒ©ãƒ¼ãƒ»ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ã‚’ç¢ºèª

## å‚è€ƒãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- [Next.js App Router](https://nextjs.org/docs/app)
- [Mantine UI](https://mantine.dev/)
- [React 19](https://react.dev/)
`````

## File: .cursor/rules/gemini-tips/RULE.md
`````markdown
---
description: "Gemini ãƒ¢ãƒ‡ãƒ«ä½¿ç”¨æ™‚ã®æœ€é©åŒ–ãƒ’ãƒ³ãƒˆ"
alwaysApply: false
---

# Gemini å›ºæœ‰ã®é‹ç”¨ãƒ’ãƒ³ãƒˆ

ã“ã®ãƒ«ãƒ¼ãƒ«ã¯ Gemini ãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ç”¨ã™ã‚‹éš›ã®æœ€é©åŒ–ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã§ã™ã€‚

## ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã¨ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®æ§‹é€ 

- `role/context/task/output` ãªã© **æ˜ç¤ºçš„ãªã‚»ã‚¯ã‚·ãƒ§ãƒ³** ã‚’ç”¨ã„ã¦ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ã‚¿ã‚°ä»˜ã‘
  - ä¾‹: `<context>â€¦</context>`, `## Instructions`
- é‡è¦ãªåˆ¶ç´„ãƒ»æ—¥æœ¬èª UI è¦ä»¶ãƒ»å‹å®‰å…¨ãƒãƒªã‚·ãƒ¼ã¯ã‚·ã‚¹ãƒ†ãƒ æŒ‡ç¤ºï¼ˆæœ€ä¸Šä½ãƒ–ãƒ­ãƒƒã‚¯ï¼‰ã«ã¾ã¨ã‚ã‚‹
- å°‘æ•°ã‚·ãƒ§ãƒƒãƒˆï¼ˆfew-shotï¼‰ä¾‹ã‚’ 1ã€œ3 ä»¶æ·»ãˆã€æˆåŠŸãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’å›ºå®š
- é•·æ–‡ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’æ¸¡ã™ã¨ãã¯ `[context] â†’ [æŒ‡ç¤º]` ã®é †ã«é…ç½®

## ãƒ¢ãƒ‡ãƒ«é¸å®šã¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿

- ã‚³ãƒ¼ãƒ‰ç”Ÿæˆã‚„å³å¯†ãªæ¨è«–ã¯ `gemini-2.5-pro` ã¾ãŸã¯ `gemini-3.0-pro` ã‚’æ—¢å®š
- è»½é‡å¿œç­”ã¯ `gemini-2.5-flash` ã‚’æ¤œè¨
- Gemini 3 ç³»ã§ã¯æ¸©åº¦ `1.0` ã‚’ä¿ã¤ã“ã¨ãŒå…¬å¼æ¨å¥¨
- ç¢ºå®šæ€§ã‚’ä¸Šã’ãŸã„å ´åˆã¯ `topK=1, topP<=0.6` ã‚’å„ªå…ˆçš„ã«èª¿æ•´

## ã‚»ãƒ¼ãƒ•ãƒ†ã‚£ã¨ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯

- é•åãƒªã‚¹ã‚¯ã®ã‚ã‚‹å…¥åŠ›ã‚’æ¤œçŸ¥ã—ãŸã‚‰ PR/Issue ã‚’å‚ç…§ã™ã‚‹æŒ‡ç¤ºã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
- Gemini ãŒå®‰å…¨ãƒ•ã‚£ãƒ«ã‚¿ã§åœæ­¢ã—ãŸå ´åˆã¯æ¸©åº¦ã‚’ä¸Šã’ã‚‹å‰ã«å…¥åŠ›ã‚’å†æ§‹æˆ
- ãƒ•ã‚¡ã‚¤ãƒ«ï¼URL å‚ç…§ã‚’è¡Œã†ã¨ãã¯ `files API` ã‚„ `URL context` ã®åˆ©ç”¨ã‚’æ˜ç¤º

## ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ¤œè¨¼

- `Plan â†’ Execute â†’ Validate â†’ Format` ã® 4 ã‚¹ãƒ†ãƒƒãƒ—ã§æ€è€ƒã‚’æ•´ç†
- æœ€çµ‚ãƒ¬ã‚¹ãƒãƒ³ã‚¹å‰ã«ã€Œä¾é ¼ã®æ„å›³ã€ã€Œæ—¥æœ¬èª UIã€ã€Œå“è³ªã‚²ãƒ¼ãƒˆã€ã® 3 ç‚¹ãƒã‚§ãƒƒã‚¯
- å‡ºåŠ›å½¢å¼ï¼ˆMarkdown è¦‹å‡ºã—ã€è¡¨ã€JSON ç­‰ï¼‰ã¯ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã§æŒ‡å®š

## å‚è€ƒãƒªãƒ³ã‚¯

- [Gemini API ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://ai.google.dev/gemini-api/docs)
- [ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆè¨­è¨ˆæˆ¦ç•¥](https://ai.google.dev/gemini-api/docs/prompting-strategies)
`````

## File: .cursor/rules/package-guard/RULE.md
`````markdown
---
description: "ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸è¿½åŠ ãƒ»æ›´æ–°æ™‚ã®å¿…é ˆæ‰‹é †ã‚’å¼·åˆ¶ã™ã‚‹ãƒ«ãƒ¼ãƒ«"
globs:
  - "**/package.json"
  - "**/pnpm-lock.yaml"
alwaysApply: false
---

# ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸è¿½åŠ æ™‚ã®å¿…é ˆæ‰‹é †

## 1. ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ç›´å¾Œ

```bash
pnpm install
pnpm prisma:generate
```

**ç†ç”±**: node_modules æ›´æ–°ã«ã‚ˆã‚Š Prisma Client ã®ä¾å­˜é–¢ä¿‚ãŒå¤‰åŒ–ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚

## 2. å‹ãƒã‚§ãƒƒã‚¯

```bash
pnpm --filter backend run build
pnpm --filter frontend run build
```

## 3. Lint ãƒã‚§ãƒƒã‚¯

```bash
pnpm lint
```

## 4. ä¾å­˜é–¢ä¿‚ã®ç¢ºèª

- package.json ã® diff ç¢ºèª
- pnpm-lock.yaml æ›´æ–°ç¢ºèª
- `pnpm audit` ã«ã‚ˆã‚‹è„†å¼±æ€§ãƒã‚§ãƒƒã‚¯

## ãƒ«ãƒ¼ãƒ«

- **ã„ãšã‚Œã‹ã§å¤±æ•—ã—ãŸå ´åˆã€æ¬¡å·¥ç¨‹ã¸é€²ã¾ãªã„**
- **åŸå› è§£æ±ºã‚’æœ€å„ªå…ˆã¨ã™ã‚‹**
- ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸è¿½åŠ ã®ç†ç”±ã¨å½±éŸ¿ç¯„å›²ã‚’èª¬æ˜ã§ãã‚‹ã“ã¨
`````

## File: .cursor/rules/project-core/RULE.md
`````markdown
---
description: "mycats-pro ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“ã®å…±é€šãƒ«ãƒ¼ãƒ«ï¼ˆè¨€èªã€å‹å®‰å…¨ã€å“è³ªã‚²ãƒ¼ãƒˆï¼‰"
alwaysApply: true
---

# mycats-pro ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå…±é€šãƒ«ãƒ¼ãƒ«

## è¨€èªè¨­å®šã¨ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³

- æœ¬ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯ **æ—¥æœ¬èª UI / ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ** ã‚’å‰æã¨ã—ã€ã‚„ã‚Šå–ã‚Šã‚‚æ—¥æœ¬èªã§çµ±ä¸€
  - ãƒãƒ£ãƒƒãƒˆã€ãƒ¬ãƒ“ãƒ¥ãƒ¼ã€PR èª¬æ˜: ã™ã¹ã¦æ—¥æœ¬èªã§å›ç­”
  - ã‚³ãƒ¼ãƒ‰ã‚³ãƒ¡ãƒ³ãƒˆ / README / è¨­è¨ˆè³‡æ–™: æ—¥æœ¬èªã§è¨˜è¿°
  - ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: å¯èƒ½ãªé™ã‚Šæ—¥æœ¬èªã§è¡¨ç¤º
- å¤‰æ•°å / é–¢æ•°å / å‹åã¯å›½éš›æ…£ç¿’ã«å¾“ã„è‹±èªã§çµ±ä¸€
- æ©Ÿæ¢°ç¿»è¨³æ„Ÿã‚’é¿ã‘ã€ç°¡æ½”ã§å®Ÿå‹™çš„ãªæ—¥æœ¬èªã‚’å¿ƒæ›ã‘ã‚‹

## æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯

- **ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰**: Next.js 15 (App Router + RSC) / React 19 / TypeScript 5 / Mantine / Tailwind CSS
- **ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰**: NestJS 10 / Prisma 6.14.0 / PostgreSQL 15+
- **é–‹ç™ºç’°å¢ƒ**: Node.js 20.x / pnpm 9.x

## å‹å®‰å…¨ãƒãƒªã‚·ãƒ¼ï¼ˆå³æ ¼ç‰ˆï¼‰

### ç¦æ­¢äº‹é …

- `any` / `unknown` ã®ä½¿ç”¨ç¦æ­¢ï¼ˆä¾‹å¤–ã¯ç†ç”±ã‚³ãƒ¡ãƒ³ãƒˆå¿…é ˆï¼‰
- é null ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆ`!`ï¼‰ç¦æ­¢ â†’ ã‚¬ãƒ¼ãƒ‰ã§å®‰å…¨ã«æ‰±ã†
- äºŒæ®µã‚­ãƒ£ã‚¹ãƒˆï¼ˆ`value as unknown as X`ï¼‰ç¦æ­¢
- `// eslint-disable` / `@ts-ignore` åŸå‰‡ç¦æ­¢

### any/unknown ä¾‹å¤–æ¡ä»¶ï¼ˆã™ã¹ã¦å¿…é ˆï¼‰

1. å¤–éƒ¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å‹å®šç¾©ãŒå®Ÿæ…‹ã¨ç•°ãªã‚Šä¿®æ­£ä¸èƒ½
2. ä»¥ä¸‹ã®ä»£æ›¿æ¡ˆã‚’ã™ã¹ã¦è©¦è¡Œã—å¤±æ•—:
   - å‹ã‚¬ãƒ¼ãƒ‰ / Partial / Pick / Omit / ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ / å‹ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³
3. è©²å½“è¡Œã«è¨˜è¼‰å¿…é ˆ:
   - è©¦è¡Œã—ãŸä»£æ›¿æ¡ˆã¨çµæœ
   - any ä½¿ç”¨ç†ç”±
   - å½±éŸ¿ç¯„å›²æœ€å°åŒ–æ–¹æ³•

### å¿…é ˆäº‹é …

- ã™ã¹ã¦ã®å…¬é–‹é–¢æ•°ãƒ»ã‚¯ãƒ©ã‚¹ã¯å¼•æ•°ãƒ»æˆ»ã‚Šå€¤ã‚’å®Œå…¨ã«å‹å®šç¾©
- `Promise` é–¢æ•°ã¯ `Promise<ResultType>` ã‚’æ˜ç¤º
- åˆ†å²ã¯å¯èƒ½ãªé™ã‚Š exhaustiveness check ã‚’å®Ÿæ–½ï¼ˆ`switch` + `never`ï¼‰
- API å…¥å‡ºåŠ›ã¯æ—¢å­˜ DTO / Prisma å‹ / å…±é€š `types/` ã‚’å†åˆ©ç”¨

## ã‚¨ãƒ©ãƒ¼å‡¦ç†ã¨ãƒ­ã‚®ãƒ³ã‚°

- ç©ºã® `catch`ã€`console.error` ã®ã¿ã§çµ‚äº†ã€`void someAsync()` ã®æ”¾ç½®ã¯ç¦æ­¢
- ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰: NestJS ã®ä¾‹å¤–ãƒ•ã‚£ãƒ«ã‚¿ï¼ˆHttpException ç³»ï¼‰ã¨ãƒ­ã‚¬ãƒ¼ã‚’ä½¿ç”¨
- ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰: ãƒ¦ãƒ¼ã‚¶ãƒ¼å‘ã‘ã«æ—¥æœ¬èªã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º

## å¤‰æ›´ã‚¹ã‚³ãƒ¼ãƒ—ã¨å†åˆ©ç”¨

- ä¾é ¼ç¯„å›²ä»¥å¤–ã®å¤§è¦æ¨¡ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã¯ç¦æ­¢
- æ—¢å­˜ã® API / DTO / UI ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ / ã‚µãƒ¼ãƒ“ã‚¹ã‚’ã¾ãšæ¢ç´¢ã—ã€å†åˆ©ç”¨
- åŒã˜ãƒ­ã‚¸ãƒƒã‚¯ã‚’è¤‡è£½ã›ãšã€æŠ½è±¡åŒ–ã¾ãŸã¯å…±é€šåŒ–ã‚’æ¤œè¨

## ã‚¯ã‚¤ãƒƒã‚¯ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹

### ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— & èµ·å‹•

```bash
pnpm install          # ä¾å­˜é–¢ä¿‚ã‚’åŒæœŸ
pnpm dev              # é–‹ç™ºã‚µãƒ¼ãƒãƒ¼èµ·å‹•ï¼ˆbackend:3004, frontend:3000ï¼‰
pnpm dev:stop         # åœæ­¢
```

### å“è³ªã‚²ãƒ¼ãƒˆï¼ˆPR å‰å¿…é ˆï¼‰

```bash
pnpm lint             # root + frontend + backend ã® Lint
pnpm backend:build    # ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒ“ãƒ«ãƒ‰
pnpm frontend:build   # ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒ“ãƒ«ãƒ‰
```

### DB æ“ä½œ

```bash
pnpm db:migrate       # ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é©ç”¨
pnpm db:seed          # ã‚·ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿æŠ•å…¥
pnpm prisma:studio    # Prisma Studio èµ·å‹•
```

## å¤‰æ›´ã—ã¦ã¯ã„ã‘ãªã„ã‚‚ã®

### è‡ªå‹•ç”Ÿæˆãƒ•ã‚¡ã‚¤ãƒ«

- `node_modules/**`
- `dist/**`, `.next/**`
- `backend/prisma/migrations/**`ï¼ˆæ‰‹å‹•ç·¨é›†ç¦æ­¢ï¼‰
- `frontend/src/lib/api/generated/**`

### è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆæ…é‡ã«å¤‰æ›´ï¼‰

- `.env`, `.env.production`
- `pnpm-lock.yaml`
- `docker-compose.yml`

### CI/CDï¼ˆæ˜ç¤ºçš„æŒ‡ç¤ºãŒãªã„é™ã‚Šå¤‰æ›´ç¦æ­¢ï¼‰

- `.github/workflows/**`
- `cloudbuild.yaml`
- `Dockerfile.*`

## ä½œæ¥­ãƒ•ãƒ­ãƒ¼

1. **èª¿æŸ»**: é–¢é€£ãƒ•ã‚¡ã‚¤ãƒ«ãƒ»æ—¢å­˜å®Ÿè£…ãƒ»CODE_GUIDE.md ã‚’ç¢ºèª
2. **ã‚¿ã‚¤ãƒ—ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆ**: å‹å®šç¾© â†’ å®Ÿè£… â†’ ãƒ†ã‚¹ãƒˆã®é †ã§ä½œæ¥­
3. **è‡ªå‹•åŒ–ãƒã‚§ãƒƒã‚¯**: å¤‰æ›´ã«å½±éŸ¿ã™ã‚‹ãƒ†ã‚¹ãƒˆ / Lint / å‹ãƒã‚§ãƒƒã‚¯ã‚’å³æ™‚å®Ÿè¡Œ
4. **è‡ªå·±ãƒ¬ãƒ“ãƒ¥ãƒ¼**: å½±éŸ¿ç¯„å›²ã€ä¾‹å¤–å‡¦ç†ã€ç¿»è¨³ã®æ•´åˆæ€§ã‚’ç¢ºèª

## æœŸå¾…ã™ã‚‹å›ç­”ã‚¹ã‚¿ã‚¤ãƒ«

- æ—¥æœ¬èªã§ç°¡æ½”ã‹ã¤æƒ…å ±å¯†åº¦ã®é«˜ã„èª¬æ˜
- mycats-pro å›ºæœ‰ã®æ–‡è„ˆã«ç´ã¥ã‘ã¦èª¬æ˜
- ã‚³ãƒ¼ãƒ‰ã¯å¿…è¦æœ€å°é™ã®æŠœç²‹ã€ãƒ‘ã‚¹ãƒ»é–¢æ•°åã‚’æ˜ç¤º
- ãƒ†ã‚¹ãƒˆæˆ¦ç•¥ã¨å®Ÿè¡Œã‚³ãƒãƒ³ãƒ‰ã‚’ä½µè¨˜
`````

## File: .cursor/rules/request-templates/RULE.md
`````markdown
---
description: "AI ã¸ã®ä¾é ¼ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆï¼ˆæ©Ÿèƒ½è¿½åŠ ãƒ»ãƒã‚°ä¿®æ­£ï¼‰"
alwaysApply: false
---

# AI ã¸ã®ä¾é ¼ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ

## æ©Ÿèƒ½è¿½åŠ ãƒªã‚¯ã‚¨ã‚¹ãƒˆ

```
ã‚ãªãŸã¯ mycats-pro ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå°‚ä»»ã® AI ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§ã™ã€‚
Next.js 15ï¼ˆApp Routerï¼‰+ React 19 + NestJS 10 + Prisma 6 + PostgreSQL 15 ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã¨ã€
ãƒªãƒã‚¸ãƒˆãƒªç›´ä¸‹ã® AGENTS.md / è©²å½“ãƒ•ã‚©ãƒ«ãƒ€ã® CODE_GUIDE.md ã«å¾“ã£ã¦ãã ã•ã„ã€‚

ã€ã‚„ã‚ŠãŸã„ã“ã¨ã€‘
- æ©Ÿèƒ½æ¦‚è¦: ï¼ˆã“ã“ã«æ¦‚è¦ã‚’æ›¸ãï¼‰
- å¯¾è±¡ç”»é¢ / API: ï¼ˆä¾‹: frontend/src/app/cats, backend/src/cats ãªã©ï¼‰

ã€å¿…ãšå®ˆã£ã¦ã»ã—ã„ã“ã¨ã€‘
- any/unknown / é null ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã¯ç¦æ­¢ã€‚å‹å®šç¾© â†’ å®Ÿè£… â†’ ãƒ†ã‚¹ãƒˆã®é †ã§æ›´æ–°ã€‚
- ã‚¨ãƒ©ãƒ¼å‡¦ç†ã¯ Next.js / NestJS ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã«å¾“ã„ã€æ—¥æœ¬èªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿”ã™ã€‚
- ç„¡é–¢ä¿‚ãªãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã‚’é¿ã‘ã€æ—¢å­˜ã®ä¼¼ãŸå®Ÿè£…ã‚’å†åˆ©ç”¨ã€‚

ã€å‡ºåŠ›ã—ã¦ã»ã—ã„ã“ã¨ã€‘
1. å¤‰æ›´ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ï¼ˆå½¹å‰²ä»˜ãï¼‰
2. ä¸»è¦ãªã‚³ãƒ¼ãƒ‰å¤‰æ›´ç‚¹ + å‹å®‰å…¨æ€§ã®ãƒã‚¤ãƒ³ãƒˆ
3. è¿½åŠ  / æ›´æ–°ã—ãŸãƒ†ã‚¹ãƒˆã¨æ„å›³
4. å®Ÿè¡Œã—ãŸã‚³ãƒãƒ³ãƒ‰ã¨å†ç¾æ‰‹é †ï¼ˆpnpm ãƒ™ãƒ¼ã‚¹ï¼‰
```

## ãƒã‚°ä¿®æ­£ãƒªã‚¯ã‚¨ã‚¹ãƒˆ

```
ã‚ãªãŸã¯ mycats-pro ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå°‚ä»»ã® AI ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§ã™ã€‚
Next.js / NestJS / Prisma ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã¨ AGENTS.md ã«å¾“ã£ã¦ã€ä»¥ä¸‹ã®ãƒã‚°ã‚’ä¿®æ­£ã—ã¦ãã ã•ã„ã€‚

ã€ãƒã‚°å†…å®¹ã€‘
- ç¾è±¡: ï¼ˆä½•ãŒã©ã†ãŠã‹ã—ã„ã‹ï¼‰
- å†ç¾æ‰‹é †: ï¼ˆURL, æ“ä½œæ‰‹é †ãªã©ï¼‰
- æœŸå¾…ã™ã‚‹æŒ™å‹•: ï¼ˆã©ã†ãªã£ã¦ã„ã¦ã»ã—ã„ã‹ï¼‰

ã€åˆ¶ç´„ã€‘
- ä¿®æ­£ç¯„å›²ã‚’åŸå› ç®‡æ‰€å‘¨è¾ºã«é™å®šã—ã€any/unknown ã‚’ä½¿ã‚ãšã«è§£æ±ºã€‚
- `@ts-ignore` ã‚„ `eslint-disable` ã‚’ä½¿ã‚ãªã„ã€‚ã©ã†ã—ã¦ã‚‚å¿…è¦ãªã‚‰ç†ç”±ã¨æ’¤å»ãƒ¡ãƒ¢ã‚’æ®‹ã™ã€‚
- å†ç™ºé˜²æ­¢ãƒ†ã‚¹ãƒˆã‚’è¿½åŠ ï¼ˆãƒ¦ãƒ‹ãƒƒãƒˆ or e2eï¼‰ã€‚

ã€å‡ºåŠ›ã—ã¦ã»ã—ã„ã“ã¨ã€‘
1. æƒ³å®šåŸå› ã¨æ ¹æ‹ 
2. ä¿®æ­£ãƒ•ã‚¡ã‚¤ãƒ«ã¨å¤‰æ›´æ¦‚è¦
3. è¿½åŠ  / æ›´æ–°ã—ãŸãƒ†ã‚¹ãƒˆå†…å®¹
4. å†ç¾ç¢ºèªã¨å›å¸°ç¢ºèªã«ä½¿ç”¨ã—ãŸã‚³ãƒãƒ³ãƒ‰
```

## ä½¿ã„æ–¹

1. ä¸Šè¨˜ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ã‚³ãƒ”ãƒ¼
2. ã€ã€‘å†…ã‚’å…·ä½“çš„ãªå†…å®¹ã«ç½®ãæ›ãˆ
3. ãƒãƒ£ãƒƒãƒˆã«è²¼ã‚Šä»˜ã‘ã¦é€ä¿¡

## ãƒã‚¤ãƒ³ãƒˆ

- **å…·ä½“çš„ã«æ›¸ã**: æ›–æ˜§ãªæŒ‡ç¤ºã¯æ›–æ˜§ãªçµæœã‚’ç”Ÿã‚€
- **åˆ¶ç´„ã‚’æ˜ç¤º**: å®ˆã£ã¦ã»ã—ã„ã“ã¨ã¯æ˜ç¢ºã«
- **å‡ºåŠ›å½¢å¼ã‚’æŒ‡å®š**: æ¬²ã—ã„æƒ…å ±ã‚’åˆ—æŒ™ã™ã‚‹
`````

## File: .dockerignore
`````
# Git
.git
.github
.gitignore

# Node
node_modules
*/node_modules
npm-debug.log
pnpm-debug.log

# Docker
.dockerignore
Dockerfile*

# OS
.DS_Store
Thumbs.db

# IDE
.vscode
.idea

# Build artifacts
*/dist
*/.next

# Env files
.env
.env.*
!/.env.example
!/.env.*.example

# Logs
*.log
logs/
`````

## File: .env.development.example
`````
# é–‹ç™ºç’°å¢ƒç”¨ã‚µãƒ³ãƒ—ãƒ« .env.development
# `cp .env.development.example backend/.env` ã§ã‚‚OK (backendé…ä¸‹ã ã‘ä½¿ã†å ´åˆ)
# quick-start / scripts/local-postgres.sh ã§è‡ªå‹•ç”Ÿæˆã•ã‚Œã‚‹å†…å®¹ã¨æ•´åˆæ€§ã‚’ä¿ã¤

# === Database ===
# ãƒ­ãƒ¼ã‚«ãƒ«å°‚ç”¨Postgresã‚¯ãƒ©ã‚¹ã‚¿ (.dev/postgres) ã‚’ 55432 ãƒãƒ¼ãƒˆã§å‹•ã‹ã™ã‚±ãƒ¼ã‚¹ä¾‹
# scripts/local-postgres.sh start ã§èµ·å‹•ã™ã‚‹æƒ³å®š
DATABASE_URL="postgresql://runner:password@localhost:55432/mycats_development"

# === JWT / Auth ===
JWT_SECRET="development-jwt-secret-at-least-32-characters-long-for-security"
JWT_REFRESH_SECRET="development-refresh-secret-at-least-32-characters-long-different-from-jwt-secret"
JWT_EXPIRES_IN="1h"

# === Server ===
NODE_ENV="development"
PORT=3004
CORS_ORIGIN="http://localhost:3000"

# === Security ===
# Argon2ã¸ç§»è¡Œæ¸ˆã¿ (BCRYPT_ROUNDS ã¯ä¸è¦ã®ãŸã‚å‰Šé™¤)

# CSRF Token Secret (æœ€ä½32æ–‡å­—ã®ãƒ©ãƒ³ãƒ€ãƒ æ–‡å­—åˆ—)
CSRF_TOKEN_SECRET="development-csrf-secret-at-least-32-characters-long-replace-in-prod"
CSRF_TOKEN_TTL_SECONDS=600

# === Rate Limiting ===
THROTTLE_TTL=60000
THROTTLE_LIMIT=100

# === Logging ===
LOG_LEVEL=debug

# === Health Check ===
HEALTH_CHECK_DATABASE=true
HEALTH_CHECK_MEMORY_THRESHOLD=0.9

# === Session ===
# SESSION_SECRET (æ—§Cookieã‚»ãƒƒã‚·ãƒ§ãƒ³ç”¨é€”) -> JWT/Refreshæˆ¦ç•¥ç§»è¡Œæ¸ˆã¿ã§æœªä½¿ç”¨

# === Prisma ===
PRISMA_CLIENT_ENGINE_TYPE="library"

# === Optional Future Services (ã‚³ãƒ¡ãƒ³ãƒˆè§£é™¤ã§åˆ©ç”¨) ===
# REDIS_URL="redis://localhost:6379"
# MAIL_HOST=smtp.example.com
# MAIL_PORT=587
# MAIL_USER=your-email@example.com
# MAIL_PASS=your-password
# AWS_ACCESS_KEY_ID=your-aws-access-key
# AWS_SECRET_ACCESS_KEY=your-aws-secret-key
# AWS_REGION=ap-northeast-1
# AWS_S3_BUCKET=your-bucket-name
`````

## File: .env.production.example
`````
# æœ¬ç•ªç’°å¢ƒè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ä¾‹
# ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ .env.production ã«ã‚³ãƒ”ãƒ¼ã—ã¦å®Ÿéš›ã®å€¤ã‚’è¨­å®šã—ã¦ãã ã•ã„

# ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­å®š
DATABASE_URL="postgresql://username:password@localhost:5432/mycats_production"

# JWTè¨­å®š
JWT_SECRET="your-production-jwt-secret-256-bit-minimum"
JWT_EXPIRES_IN="1h"

# APIè¨­å®š
NODE_ENV=production
PORT=3004

# CORSè¨­å®š
CORS_ORIGIN="https://yourdomain.com,https://www.yourdomain.com"

# ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®š
# Argon2 ã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚ BCRYPT_ROUNDS ã¯ä¸è¦

# ãƒ¬ãƒ¼ãƒˆåˆ¶é™
THROTTLE_TTL=60000
THROTTLE_LIMIT=100

# ãƒ­ã‚°è¨­å®š
LOG_LEVEL=warn

# ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
HEALTH_CHECK_DATABASE=true
HEALTH_CHECK_MEMORY_THRESHOLD=0.9

# SESSION_SECRET (æ—§ã‚»ãƒƒã‚·ãƒ§ãƒ³Cookieç”¨é€”) -> æœªä½¿ç”¨

# Redisè¨­å®šï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥/ã‚»ãƒƒã‚·ãƒ§ãƒ³ä½¿ç”¨æ™‚ï¼‰
# REDIS_URL="redis://localhost:6379"

# ãƒ¡ãƒ¼ãƒ«è¨­å®šï¼ˆé€šçŸ¥æ©Ÿèƒ½ä½¿ç”¨æ™‚ï¼‰
# MAIL_HOST=smtp.example.com
# MAIL_PORT=587
# MAIL_USER=your-email@example.com
# MAIL_PASS=your-password

# ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ä½¿ç”¨æ™‚ï¼‰
# AWS_ACCESS_KEY_ID=your-aws-access-key
# AWS_SECRET_ACCESS_KEY=your-aws-secret-key
# AWS_REGION=us-east-1
# AWS_S3_BUCKET=your-bucket-name
`````

## File: .gitattributes
`````
# Auto detect text files and perform LF normalization
* text=auto

# Force LF for shell scripts
*.sh text eol=lf

# Force LF for scripts
*.js text eol=lf
*.ts text eol=lf
*.tsx text eol=lf
*.jsx text eol=lf
*.json text eol=lf
*.yml text eol=lf
*.yaml text eol=lf

# Force CRLF for Windows batch files
*.bat text eol=crlf
*.cmd text eol=crlf
*.ps1 text eol=crlf

# Binary files
*.png binary
*.jpg binary
*.jpeg binary
*.gif binary
*.ico binary
*.svg binary
*.woff binary
*.woff2 binary
*.ttf binary
*.eot binary
`````

## File: .github/agents/backend-agent.md
`````markdown
---
name: backend_agent
description: NestJS + Prisma + PostgreSQL ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰é–‹ç™ºå°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
techStack: [NestJS 10, Prisma 6.14.0, PostgreSQL 15+, TypeScript 5]
commands:
  - pnpm --filter backend run lint
  - pnpm --filter backend run build
  - pnpm --filter backend run test
  - pnpm --filter backend run test:e2e
  - pnpm --filter backend run prisma:generate
boundaries:
  - Controller ã§ç›´æ¥ Prisma ã‚’å‘¼ã³å‡ºã•ãªã„ï¼ˆService ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’çµŒç”±ï¼‰
  - any/unknown ã®ä½¿ç”¨ç¦æ­¢ï¼ˆå‹å®‰å…¨ã‚’ç¶­æŒï¼‰
  - ç’°å¢ƒå¤‰æ•°ã¯ @nestjs/config + Zod ã§æ¤œè¨¼
  - æ—¥æœ¬èªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿”å´
---

# Backend Agent - NestJS/Prisma å°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ

## å½¹å‰²
ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ APIã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒã€ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã®é–‹ç™ºãƒ»ä¿å®ˆã‚’æ‹…å½“ã™ã‚‹å°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§ã™ã€‚

## å°‚é–€é ˜åŸŸ
- **NestJS**: ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«è¨­è¨ˆã€DI ã‚³ãƒ³ãƒ†ãƒŠã€ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã€ã‚¬ãƒ¼ãƒ‰ã€ã‚¤ãƒ³ã‚¿ãƒ¼ã‚»ãƒ—ã‚¿ãƒ¼
- **Prisma**: ã‚¹ã‚­ãƒ¼ãƒè¨­è¨ˆã€ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã€ã‚¯ã‚¨ãƒªæœ€é©åŒ–ã€N+1 å•é¡Œè§£æ±º
- **API è¨­è¨ˆ**: RESTfulã€DTO/Entity åˆ†é›¢ã€ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã€ã‚¨ãƒ©ãƒ¼å‡¦ç†
- **èªè¨¼**: JWTã€Passportã€ãƒ­ãƒ¼ãƒ«ç®¡ç†

## ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£åŸå‰‡

### ãƒ¬ã‚¤ãƒ¤ãƒªãƒ³ã‚°
```
Controller (HTTPå±¤)
  â†“ DTOã§ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
Service (ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯)
  â†“ Entityã‚„Prismaå‹ã§å‡¦ç†
Repository/PrismaService (ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹)
```

### å¿…é ˆãƒ‘ã‚¿ãƒ¼ãƒ³
1. **DTO + class-validator**: ã™ã¹ã¦ã®å…¥åŠ›ã‚’ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
2. **DI**: ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ã‚’ä½¿ç”¨
3. **ä¾‹å¤–å‡¦ç†**: HttpException ç³»ã§çµ±ä¸€ã€æ—¥æœ¬èªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
4. **ãƒ­ã‚®ãƒ³ã‚°**: nestjs-pino ã§æ§‹é€ åŒ–ãƒ­ã‚°

## ã‚³ãƒ¼ãƒ‰ä¾‹

### Service ã®æ¨™æº–å½¢
```typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { CreateCatDto } from './dto/create-cat.dto';

@Injectable()
export class CatsService {
  constructor(private prisma: PrismaService) {}

  async findOne(id: number) {
    const cat = await this.prisma.cat.findUnique({
      where: { id },
      select: {
        id: true,
        name: true,
        breed: true,
        // å¿…è¦ãªãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ã¿é¸æŠ
      },
    });

    if (!cat) {
      throw new NotFoundException('æŒ‡å®šã•ã‚ŒãŸçŒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    }

    return cat;
  }

  async create(dto: CreateCatDto) {
    return this.prisma.cat.create({
      data: {
        name: dto.name,
        breed: dto.breed,
        // DTO ã‹ã‚‰å¿…è¦ãªãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æ˜ç¤ºçš„ã«ãƒãƒƒãƒ”ãƒ³ã‚°
      },
    });
  }
}
```

### DTO ã®æ¨™æº–å½¢
```typescript
import { IsString, IsNotEmpty, IsOptional, MaxLength } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class CreateCatDto {
  @ApiProperty({ description: 'çŒ«ã®åå‰', maxLength: 100 })
  @IsString()
  @IsNotEmpty({ message: 'åå‰ã¯å¿…é ˆã§ã™' })
  @MaxLength(100, { message: 'åå‰ã¯100æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„' })
  name: string;

  @ApiProperty({ description: 'å“ç¨®', required: false })
  @IsString()
  @IsOptional()
  breed?: string;
}
```

## ä½œæ¥­ãƒ•ãƒ­ãƒ¼

### æ–°è¦æ©Ÿèƒ½è¿½åŠ æ™‚
1. DTOã‚’å®šç¾©ï¼ˆå…¥åŠ›ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
2. Service ã«ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…
3. Controller ã«ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’è¿½åŠ 
4. Swagger ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ 
5. ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã‚’ä½œæˆ
6. E2E ãƒ†ã‚¹ãƒˆã§å®Ÿéš›ã®HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ãƒ†ã‚¹ãƒˆ

### Prisma ã‚¹ã‚­ãƒ¼ãƒå¤‰æ›´æ™‚
```bash
# ã‚¹ã‚­ãƒ¼ãƒç·¨é›†å¾Œ
pnpm --filter backend run prisma:migrate  # ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç”Ÿæˆ
pnpm --filter backend run prisma:generate # TypeScript å‹ã‚’å†ç”Ÿæˆ
pnpm --filter backend run test            # ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
```

## å“è³ªãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
- [ ] ã™ã¹ã¦ã® public ãƒ¡ã‚½ãƒƒãƒ‰ã«å‹å®šç¾©ãŒã‚ã‚‹
- [ ] any/unknown ã‚’ä½¿ç”¨ã—ã¦ã„ãªã„
- [ ] ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒæ—¥æœ¬èªã§ã‚ã‚‹
- [ ] N+1 ã‚¯ã‚¨ãƒªãŒãªã„ï¼ˆselect/include ã§æœ€é©åŒ–ï¼‰
- [ ] DTO ã§ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãŒå®Œçµã—ã¦ã„ã‚‹
- [ ] Swagger ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãŒæ­£ç¢ºã§ã‚ã‚‹
- [ ] ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆãŒã‚ã‚‹
- [ ] E2E ãƒ†ã‚¹ãƒˆã§ä¸»è¦ãƒ•ãƒ­ãƒ¼ã‚’ã‚«ãƒãƒ¼ã—ã¦ã„ã‚‹

## å‚è€ƒãƒªãƒ³ã‚¯
- [NestJS å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://docs.nestjs.com/)
- [Prisma ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹](https://www.prisma.io/docs/guides/performance-and-optimization)
- [backend/AGENTS.md](../../backend/AGENTS.md) - è©³ç´°ãªã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³
`````

## File: .github/agents/docs-agent.md
`````markdown
---
name: docs_agent
description: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãƒ»READMEãƒ»æŠ€è¡“è³‡æ–™ã®ä½œæˆãƒ»ä¿å®ˆå°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
boundaries:
  - ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’å¤‰æ›´ã—ãªã„
  - ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®ã¿ã‚’ç·¨é›†
  - æ—¥æœ¬èªã§è¨˜è¿°
  - æ—¢å­˜ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ç¶­æŒ
---

# Documentation Agent - ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆå°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ

## å½¹å‰²
ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã€READMEã€API ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã€æŠ€è¡“è³‡æ–™ã®ä½œæˆãƒ»æ›´æ–°ãƒ»ä¿å®ˆã‚’æ‹…å½“ã—ã¾ã™ã€‚

## å°‚é–€é ˜åŸŸ
- ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ README ã®ä½œæˆãƒ»æ›´æ–°
- API ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®æ•´å‚™
- ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚¬ã‚¤ãƒ‰ã®ä½œæˆ
- ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
- ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆæ›¸

## ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆåŸå‰‡

### è¨€èªã¨ã‚¹ã‚¿ã‚¤ãƒ«
- ã™ã¹ã¦ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ **æ—¥æœ¬èª** ã§è¨˜è¿°
- ç°¡æ½”ã§å®Ÿå‹™çš„ãªè¡¨ç¾ã‚’ä½¿ç”¨
- æ©Ÿæ¢°ç¿»è¨³æ„Ÿã‚’é¿ã‘ã‚‹
- æŠ€è¡“ç”¨èªã¯è‹±èªã®ã¾ã¾ä½¿ç”¨ï¼ˆä¾‹: APIã€HTTPã€JSONï¼‰

### æ§‹é€ åŒ–
- è¦‹å‡ºã—ã®éšå±¤ã‚’é©åˆ‡ã«ä½¿ç”¨
- ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã«ã¯è¨€èªã‚’æŒ‡å®š
- æ‰‹é †ã¯ç•ªå·ä»˜ããƒªã‚¹ãƒˆã§æ˜ç¤º
- é‡è¦ãªæƒ…å ±ã¯å¤ªå­—ã‚„ç®‡æ¡æ›¸ãã§å¼·èª¿

## ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®ç¨®é¡

### README.md
ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æ¦‚è¦ã€æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯ã€ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æ‰‹é †ã€ä¸»è¦æ©Ÿèƒ½ã‚’èª¬æ˜ã€‚

**å¿…é ˆã‚»ã‚¯ã‚·ãƒ§ãƒ³:**
- ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦
- æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯
- ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆ
- ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ 
- é–‹ç™ºã‚³ãƒãƒ³ãƒ‰
- ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### SETUP_GUIDE.md
åˆå›ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã®è©³ç´°æ‰‹é †ã€‚

**å«ã‚€ã¹ãå†…å®¹:**
- å¿…è¦ãªä¾å­˜é–¢ä¿‚
- ç’°å¢ƒå¤‰æ•°ã®è¨­å®š
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
- é–‹ç™ºç’°å¢ƒã®èµ·å‹•
- å‹•ä½œç¢ºèª

### TROUBLESHOOTING.md
ã‚ˆãã‚ã‚‹å•é¡Œã¨è§£æ±ºæ–¹æ³•ã€‚

**æ§‹æˆ:**
- å•é¡Œã®èª¬æ˜
- åŸå› 
- è§£æ±ºæ–¹æ³•
- äºˆé˜²ç­–

### API ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
Swagger/OpenAPI ã§è‡ªå‹•ç”Ÿæˆã•ã‚Œã‚‹ãŒã€è£œè¶³èª¬æ˜ã‚’è¿½åŠ ã€‚

**è¿½åŠ ã™ã¹ãæƒ…å ±:**
- ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®ä½¿ç”¨ä¾‹
- ã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®è©³ç´°
- èªè¨¼ã®ä»•çµ„ã¿
- ãƒ¬ãƒ¼ãƒˆåˆ¶é™

## ã‚³ãƒ¼ãƒ‰ä¾‹ã®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³

### ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯
```typescript
// è¨€èªã‚’æ˜ç¤ºã—ã€å®Œå…¨ãªä¾‹ã‚’æä¾›
interface Cat {
  id: number;
  name: string;
  breed?: string;
}
```

### ã‚³ãƒãƒ³ãƒ‰ä¾‹
```bash
# ã‚³ãƒ¡ãƒ³ãƒˆã§èª¬æ˜ã‚’è¿½åŠ 
pnpm install

# é–‹ç™ºã‚µãƒ¼ãƒãƒ¼èµ·å‹•
pnpm dev
```

## ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°

### å¿…é ˆæ›´æ–°
- æ–°æ©Ÿèƒ½è¿½åŠ æ™‚
- API ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆè¿½åŠ /å¤‰æ›´æ™‚
- ç’°å¢ƒå¤‰æ•°è¿½åŠ æ™‚
- ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ å¤‰æ›´æ™‚
- ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æ‰‹é †å¤‰æ›´æ™‚

### æ¨å¥¨æ›´æ–°
- ãƒã‚°ä¿®æ­£æ™‚ï¼ˆãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã«è¿½åŠ ï¼‰
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ”¹å–„æ™‚
- ä¾å­˜é–¢ä¿‚ã®æ›´æ–°æ™‚

## å“è³ªãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
- [ ] æ—¥æœ¬èªã§è¨˜è¿°ã•ã‚Œã¦ã„ã‚‹
- [ ] ç°¡æ½”ã§åˆ†ã‹ã‚Šã‚„ã™ã„
- [ ] ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã«è¨€èªãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹
- [ ] æ‰‹é †ãŒç•ªå·ä»˜ããƒªã‚¹ãƒˆã§æ˜ç¢º
- [ ] ãƒªãƒ³ã‚¯ãŒæ­£ã—ãæ©Ÿèƒ½ã™ã‚‹
- [ ] æœ€æ–°ã®æƒ…å ±ã‚’åæ˜ ã—ã¦ã„ã‚‹
- [ ] ã‚¿ã‚¤ãƒãŒãªã„
- [ ] ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãŒçµ±ä¸€ã•ã‚Œã¦ã„ã‚‹

## ãƒ•ã‚¡ã‚¤ãƒ«é…ç½®ãƒ«ãƒ¼ãƒ«

### ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
- `README.md` - ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“ã®èª¬æ˜
- `SETUP_GUIDE.md` - ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æ‰‹é †
- `TROUBLESHOOTING.md` - ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°
- `DEPLOYMENT_*.md` - ãƒ‡ãƒ—ãƒ­ã‚¤é–¢é€£

### docs/ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
- ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆæ›¸
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆæ›¸
- è©³ç´°ãªæŠ€è¡“ä»•æ§˜æ›¸

### .github/ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
- `DEPLOYMENT_CHECKLIST.md` - ãƒ‡ãƒ—ãƒ­ã‚¤ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
- `CICD_PRODUCTION_GUIDE.md` - CI/CD ã‚¬ã‚¤ãƒ‰

## æ›´æ–°ãƒ•ãƒ­ãƒ¼

1. å¤‰æ›´å†…å®¹ã‚’ç¢ºèª
2. å½±éŸ¿ã™ã‚‹ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’ç‰¹å®š
3. æ—¢å­˜ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«å¾“ã£ã¦æ›´æ–°
4. ãƒªãƒ³ã‚¯ã®æ•´åˆæ€§ã‚’ç¢ºèª
5. ã‚¿ã‚¤ãƒã‚’ãƒã‚§ãƒƒã‚¯
6. ã‚³ãƒ¼ãƒ‰ã‚µãƒ³ãƒ—ãƒ«ã‚’æ¤œè¨¼

## æ³¨æ„äº‹é …
- **ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã¯å¤‰æ›´ã—ãªã„**
- ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®æ›´æ–°ã®ã¿ã«é›†ä¸­
- æ—¢å­˜ã®ã‚¹ã‚¿ã‚¤ãƒ«ã¨ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ç¶­æŒ
- å¤ã„æƒ…å ±ã‚’å‰Šé™¤ã¾ãŸã¯æ›´æ–°ãƒãƒ¼ã‚¯ã‚’ä»˜ã‘ã‚‹

## å‚è€ƒãƒªãƒ³ã‚¯
- [docs/](../../docs/) - è©³ç´°ãªãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
- [README.md](../../README.md) - ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ README
- [SETUP_GUIDE.md](../../SETUP_GUIDE.md) - ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚¬ã‚¤ãƒ‰
`````

## File: .github/agents/frontend-agent.md
`````markdown
---
name: frontend_agent
description: Next.js 15 + React 19 + Mantine ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰é–‹ç™ºå°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
techStack: [Next.js 15, React 19, TypeScript 5, Mantine UI 8, Tailwind CSS 4]
commands:
  - pnpm --filter frontend run lint
  - pnpm --filter frontend run build
  - pnpm --filter frontend run test
  - pnpm --filter frontend run type-check
boundaries:
  - Server Component ã‚’å„ªå…ˆã€"use client" ã¯æœ€å°é™
  - any/unknown ã®ä½¿ç”¨ç¦æ­¢
  - æ—¥æœ¬èª UI æ–‡è¨€ã‚’ä½¿ç”¨
  - ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ã‚’è€ƒæ…®
---

# Frontend Agent - Next.js/React å°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ

## å½¹å‰²
ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ­ã‚¸ãƒƒã‚¯ã€ãƒšãƒ¼ã‚¸ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®é–‹ç™ºãƒ»ä¿å®ˆã‚’æ‹…å½“ã™ã‚‹å°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§ã™ã€‚

## å°‚é–€é ˜åŸŸ
- **Next.js App Router**: ãƒ•ã‚¡ã‚¤ãƒ«ãƒ™ãƒ¼ã‚¹ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã€Server Componentsã€Server Actions
- **React 19**: æ–°æ©Ÿèƒ½ï¼ˆActionsã€useOptimistic ãªã©ï¼‰ã®æ´»ç”¨
- **Mantine UI**: ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®åŠ¹æœçš„ãªä½¿ç”¨
- **çŠ¶æ…‹ç®¡ç†**: TanStack Queryï¼ˆã‚µãƒ¼ãƒãƒ¼çŠ¶æ…‹ï¼‰ã€Zustandï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆçŠ¶æ…‹ï¼‰

## ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£åŸå‰‡

### Server Component ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆ
```
Server Component (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)
  â†“ ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚§ãƒƒãƒ
API Layer (lib/api/)
  â†“
Client Component ("use client" å¿…è¦æ™‚ã®ã¿)
```

### ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ 
```
src/
â”œâ”€â”€ app/              # App Router ãƒšãƒ¼ã‚¸
â”‚   â”œâ”€â”€ cats/
â”‚   â”‚   â”œâ”€â”€ page.tsx       # Server Component
â”‚   â”‚   â”œâ”€â”€ [id]/
â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
â”‚   â”‚   â””â”€â”€ _components/   # ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”‚   â””â”€â”€ layout.tsx
â”œâ”€â”€ components/       # å…±æœ‰ UI ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”‚   â”œâ”€â”€ AppLayout/
â”‚   â””â”€â”€ TagSelector/
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ api/         # API ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
â”‚   â””â”€â”€ hooks/       # ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯
â””â”€â”€ styles/          # ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚¿ã‚¤ãƒ«
```

## ã‚³ãƒ¼ãƒ‰ä¾‹

### Server Componentï¼ˆæ¨å¥¨ï¼‰
```typescript
// app/cats/page.tsx
import { getCats } from '@/lib/api/cats';
import { CatList } from './_components/CatList';

export default async function CatsPage() {
  // Server Component ã§ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚§ãƒƒãƒ
  const cats = await getCats();

  return (
    <div>
      <h1>çŒ«ä¸€è¦§</h1>
      <CatList cats={cats} />
    </div>
  );
}
```

### Client Componentï¼ˆå¿…è¦æ™‚ã®ã¿ï¼‰
```typescript
// app/cats/_components/CatList.tsx
'use client'; // ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãªæ©Ÿèƒ½ãŒå¿…è¦ãªå ´åˆã®ã¿

import { useState } from 'react';
import { Button, Card } from '@mantine/core';

interface CatListProps {
  cats: Cat[];
}

export function CatList({ cats }: CatListProps) {
  const [selectedCat, setSelectedCat] = useState<Cat | null>(null);

  return (
    <div>
      {cats.map((cat) => (
        <Card key={cat.id} onClick={() => setSelectedCat(cat)}>
          <h3>{cat.name}</h3>
          <p>{cat.breed}</p>
        </Card>
      ))}
    </div>
  );
}
```

### Server Actions
```typescript
// app/cats/_actions.ts
'use server';

import { revalidatePath } from 'next/cache';
import { createCat } from '@/lib/api/cats';

export async function createCatAction(formData: FormData) {
  const name = formData.get('name') as string;
  const breed = formData.get('breed') as string;

  if (!name) {
    return { error: 'åå‰ã¯å¿…é ˆã§ã™' };
  }

  try {
    await createCat({ name, breed });
    revalidatePath('/cats');
    return { success: true };
  } catch (error) {
    return { error: 'çŒ«ã®ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ' };
  }
}
```

## Mantine UI ã®ä½¿ã„æ–¹

### ãƒ†ãƒ¼ãƒã¨ã‚¹ã‚¿ã‚¤ãƒªãƒ³ã‚°
```typescript
// åŸºæœ¬çš„ãªä½¿ã„æ–¹
import { Button, Stack, Text } from '@mantine/core';

<Stack gap="md">
  <Text size="lg" fw={700}>è¦‹å‡ºã—</Text>
  <Button color="blue" size="md">
    ãƒœã‚¿ãƒ³
  </Button>
</Stack>

// Tailwind CSS ã¨ã®ä½µç”¨
<div className="flex items-center gap-4">
  <Button>Mantine Button</Button>
</div>
```

## ä½œæ¥­ãƒ•ãƒ­ãƒ¼

### æ–°è¦ãƒšãƒ¼ã‚¸è¿½åŠ æ™‚
1. `app/` é…ä¸‹ã«é©åˆ‡ãªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆ
2. Server Component ã¨ã—ã¦ãƒšãƒ¼ã‚¸ã‚’å®Ÿè£…
3. å¿…è¦ã«å¿œã˜ã¦ Client Component ã‚’åˆ†é›¢
4. API å‘¼ã³å‡ºã—ã¯ `lib/api/` çµŒç”±
5. å‹å®šç¾©ã‚’ç¢ºèªï¼ˆOpenAPI ç”Ÿæˆå‹ã‚’ä½¿ç”¨ï¼‰
6. ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆARIAã€ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œï¼‰

### UI ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆä½œæˆæ™‚
1. `components/` ã«é…ç½®ï¼ˆè¤‡æ•°ãƒšãƒ¼ã‚¸ã§å†åˆ©ç”¨ã™ã‚‹å ´åˆï¼‰
2. Props ã®å‹ã‚’æ˜ç¤ºçš„ã«å®šç¾©
3. Mantine ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’æ´»ç”¨
4. ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œã‚’ç¢ºèª
5. æ—¥æœ¬èªæ–‡è¨€ã‚’ä½¿ç”¨

## å“è³ªãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
- [ ] Server Component ã‚’å„ªå…ˆã—ã¦ã„ã‚‹
- [ ] "use client" ä½¿ç”¨æ™‚ã«ç†ç”±ãŒã‚³ãƒ¡ãƒ³ãƒˆã•ã‚Œã¦ã„ã‚‹
- [ ] ã™ã¹ã¦ã® Props ã«å‹å®šç¾©ãŒã‚ã‚‹
- [ ] any/unknown ã‚’ä½¿ç”¨ã—ã¦ã„ãªã„
- [ ] UI æ–‡è¨€ãŒæ—¥æœ¬èªã§ã‚ã‚‹
- [ ] ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ã‚’è€ƒæ…®ã—ã¦ã„ã‚‹ï¼ˆARIAã€focusï¼‰
- [ ] ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ‡ã‚¶ã‚¤ãƒ³ã§ã‚ã‚‹
- [ ] ã‚¨ãƒ©ãƒ¼çŠ¶æ…‹ãŒé©åˆ‡ã«è¡¨ç¤ºã•ã‚Œã‚‹
- [ ] ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ãŒè¡¨ç¤ºã•ã‚Œã‚‹

## ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
- ç”»åƒã¯ `next/image` ã‚’ä½¿ç”¨
- å‹•çš„ã‚¤ãƒ³ãƒãƒ¼ãƒˆã§åˆæœŸãƒãƒ³ãƒ‰ãƒ«ã‚µã‚¤ã‚ºã‚’å‰Šæ¸›
- `React.memo` ã¯å¿…è¦ãªå ´åˆã®ã¿ä½¿ç”¨
- TanStack Query ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥ã‚’æ´»ç”¨

## å‚è€ƒãƒªãƒ³ã‚¯
- [Next.js App Router ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://nextjs.org/docs/app)
- [Mantine UI ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://mantine.dev/)
- [React 19 æ–°æ©Ÿèƒ½](https://react.dev/blog/2024/04/25/react-19)
- [frontend/AGENTS.md](../../frontend/AGENTS.md) - è©³ç´°ãªã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³
`````

## File: .github/agents/test-agent.md
`````markdown
---
name: test_agent
description: ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ä½œæˆãƒ»ä¿å®ˆå°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
techStack: [Jest, Supertest, Testing Library, E2E]
commands:
  - pnpm --filter backend run test
  - pnpm --filter backend run test:e2e
  - pnpm --filter frontend run test
boundaries:
  - ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿ã‚’ä½œæˆãƒ»ç·¨é›†
  - ãƒ†ã‚¹ãƒˆå¯¾è±¡ã®ã‚³ãƒ¼ãƒ‰ã¯æœ€å°é™ã®å¤‰æ›´ã®ã¿
  - ã‚«ãƒãƒ¬ãƒƒã‚¸å‘ä¸Šã‚’ç›®æŒ‡ã™
---

# Test Agent - ãƒ†ã‚¹ãƒˆå°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ

## å½¹å‰²
ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã€çµ±åˆãƒ†ã‚¹ãƒˆã€E2E ãƒ†ã‚¹ãƒˆã®ä½œæˆãƒ»ä¿å®ˆã‚’æ‹…å½“ã—ã€ã‚³ãƒ¼ãƒ‰å“è³ªã¨ã‚«ãƒãƒ¬ãƒƒã‚¸ã‚’å‘ä¸Šã•ã›ã¾ã™ã€‚

## å°‚é–€é ˜åŸŸ
- **ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰**: Jest + Supertest ã«ã‚ˆã‚‹ API ãƒ†ã‚¹ãƒˆ
- **ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰**: Jest + Testing Library ã«ã‚ˆã‚‹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãƒ†ã‚¹ãƒˆ
- **E2E ãƒ†ã‚¹ãƒˆ**: å®Ÿéš›ã®HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆã«ã‚ˆã‚‹ãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆ
- **ãƒ¢ãƒƒã‚¯**: NestJS Testingã€Jest Mock ã®æ´»ç”¨

## ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

### ãƒ†ã‚¹ãƒˆãƒ”ãƒ©ãƒŸãƒƒãƒ‰
```
      E2E (å°‘)
       /\
      /  \
     /çµ±åˆ \
    /  ãƒ†ã‚¹ãƒˆ\
   /__________\
  /  ãƒ¦ãƒ‹ãƒƒãƒˆ  \
 /    ãƒ†ã‚¹ãƒˆ    \
/______________\
```

- **ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ**: é–¢æ•°ãƒ»ãƒ¡ã‚½ãƒƒãƒ‰å˜ä½ï¼ˆæœ€å¤šï¼‰
- **çµ±åˆãƒ†ã‚¹ãƒˆ**: ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«é–“ã®é€£æº
- **E2E ãƒ†ã‚¹ãƒˆ**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ãƒ­ãƒ¼ã®æ¤œè¨¼ï¼ˆæœ€å°‘ï¼‰

## ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒ†ã‚¹ãƒˆ

### Service ã®ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ
```typescript
// cats.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { CatsService } from './cats.service';
import { PrismaService } from '../prisma/prisma.service';
import { NotFoundException } from '@nestjs/common';

describe('CatsService', () => {
  let service: CatsService;
  let prisma: PrismaService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        CatsService,
        {
          provide: PrismaService,
          useValue: {
            cat: {
              findUnique: jest.fn(),
              create: jest.fn(),
            },
          },
        },
      ],
    }).compile();

    service = module.get<CatsService>(CatsService);
    prisma = module.get<PrismaService>(PrismaService);
  });

  describe('findOne', () => {
    it('çŒ«ãŒè¦‹ã¤ã‹ã£ãŸå ´åˆã€çŒ«ã®ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™', async () => {
      const mockCat = { id: 1, name: 'ãŸã¾', breed: 'ãƒŸãƒƒã‚¯ã‚¹' };
      jest.spyOn(prisma.cat, 'findUnique').mockResolvedValue(mockCat);

      const result = await service.findOne(1);

      expect(result).toEqual(mockCat);
      expect(prisma.cat.findUnique).toHaveBeenCalledWith({
        where: { id: 1 },
        select: expect.any(Object),
      });
    });

    it('çŒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã€NotFoundException ã‚’ã‚¹ãƒ­ãƒ¼ã™ã‚‹', async () => {
      jest.spyOn(prisma.cat, 'findUnique').mockResolvedValue(null);

      await expect(service.findOne(999)).rejects.toThrow(NotFoundException);
      await expect(service.findOne(999)).rejects.toThrow(
        'æŒ‡å®šã•ã‚ŒãŸçŒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'
      );
    });
  });
});
```

### E2E ãƒ†ã‚¹ãƒˆ
```typescript
// cats.e2e-spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

describe('Cats API (e2e)', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  describe('GET /api/v1/cats', () => {
    it('çŒ«ä¸€è¦§ã‚’å–å¾—ã§ãã‚‹', () => {
      return request(app.getHttpServer())
        .get('/api/v1/cats')
        .expect(200)
        .expect((res) => {
          expect(Array.isArray(res.body)).toBe(true);
        });
    });
  });

  describe('POST /api/v1/cats', () => {
    it('æ–°ã—ã„çŒ«ã‚’ä½œæˆã§ãã‚‹', () => {
      return request(app.getHttpServer())
        .post('/api/v1/cats')
        .send({
          name: 'ãƒ†ã‚¹ãƒˆçŒ«',
          breed: 'ãƒŸãƒƒã‚¯ã‚¹',
        })
        .expect(201)
        .expect((res) => {
          expect(res.body).toHaveProperty('id');
          expect(res.body.name).toBe('ãƒ†ã‚¹ãƒˆçŒ«');
        });
    });

    it('åå‰ãŒç©ºã®å ´åˆã€400ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™', () => {
      return request(app.getHttpServer())
        .post('/api/v1/cats')
        .send({
          breed: 'ãƒŸãƒƒã‚¯ã‚¹',
        })
        .expect(400);
    });
  });
});
```

## ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒ†ã‚¹ãƒˆ

### ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãƒ†ã‚¹ãƒˆ
```typescript
// CatList.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { CatList } from './CatList';

describe('CatList', () => {
  const mockCats = [
    { id: 1, name: 'ãŸã¾', breed: 'ãƒŸãƒƒã‚¯ã‚¹' },
    { id: 2, name: 'ãƒŸã‚±', breed: 'ä¸‰æ¯›çŒ«' },
  ];

  it('çŒ«ã®ãƒªã‚¹ãƒˆãŒè¡¨ç¤ºã•ã‚Œã‚‹', () => {
    render(<CatList cats={mockCats} />);

    expect(screen.getByText('ãŸã¾')).toBeInTheDocument();
    expect(screen.getByText('ãƒŸã‚±')).toBeInTheDocument();
  });

  it('çŒ«ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨é¸æŠã•ã‚Œã‚‹', () => {
    render(<CatList cats={mockCats} />);

    const firstCat = screen.getByText('ãŸã¾');
    fireEvent.click(firstCat);

    // é¸æŠçŠ¶æ…‹ã®ç¢ºèªãƒ­ã‚¸ãƒƒã‚¯
  });

  it('çŒ«ãŒç©ºã®å ´åˆã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒè¡¨ç¤ºã•ã‚Œã‚‹', () => {
    render(<CatList cats={[]} />);

    expect(screen.getByText('çŒ«ãŒã„ã¾ã›ã‚“')).toBeInTheDocument();
  });
});
```

## ãƒ†ã‚¹ãƒˆå‘½åè¦å‰‡

### æ—¥æœ¬èªèª¬æ˜ + æœŸå¾…çµæœ
```typescript
describe('CatsService', () => {
  describe('findOne', () => {
    it('çŒ«ãŒè¦‹ã¤ã‹ã£ãŸå ´åˆã€çŒ«ã®ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™', () => {});
    it('çŒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã€NotFoundException ã‚’ã‚¹ãƒ­ãƒ¼ã™ã‚‹', () => {});
  });
});
```

## ãƒ†ã‚¹ãƒˆã®æ›¸ãæ–¹åŸå‰‡

### AAA ãƒ‘ã‚¿ãƒ¼ãƒ³
```typescript
it('ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹', () => {
  // Arrangeï¼ˆæº–å‚™ï¼‰
  const mockData = { id: 1, name: 'test' };

  // Actï¼ˆå®Ÿè¡Œï¼‰
  const result = service.process(mockData);

  // Assertï¼ˆæ¤œè¨¼ï¼‰
  expect(result).toBe(expected);
});
```

### ãƒ¢ãƒƒã‚¯ã®ä½¿ã„æ–¹
- å¤–éƒ¨ä¾å­˜ï¼ˆAPIã€DBï¼‰ã¯ãƒ¢ãƒƒã‚¯
- æ—¥ä»˜ãƒ»æ™‚åˆ»ã¯å›ºå®šå€¤ã‚’ä½¿ç”¨
- ãƒ©ãƒ³ãƒ€ãƒ å€¤ã¯é¿ã‘ã‚‹

### ã‚«ãƒãƒ¬ãƒƒã‚¸ç›®æ¨™
- ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ: 80%ä»¥ä¸Š
- é‡è¦ãªãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯: 100%
- E2E: ä¸»è¦ãƒ•ãƒ­ãƒ¼å…¨ä½“

## ã‚³ãƒãƒ³ãƒ‰

### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰
```bash
# ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ
pnpm --filter backend run test

# ã‚«ãƒãƒ¬ãƒƒã‚¸ä»˜ã
pnpm --filter backend run test:cov

# E2E ãƒ†ã‚¹ãƒˆ
pnpm --filter backend run test:e2e

# ã‚¦ã‚©ãƒƒãƒãƒ¢ãƒ¼ãƒ‰
pnpm --filter backend run test:watch
```

### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰
```bash
# ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ
pnpm --filter frontend run test

# ã‚¦ã‚©ãƒƒãƒãƒ¢ãƒ¼ãƒ‰
pnpm --filter frontend run test:watch
```

## å“è³ªãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
- [ ] ã™ã¹ã¦ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ãŒæ—¥æœ¬èªã§èª¬æ˜ã•ã‚Œã¦ã„ã‚‹
- [ ] æ­£å¸¸ç³»ã¨ç•°å¸¸ç³»ã®ä¸¡æ–¹ã‚’ãƒ†ã‚¹ãƒˆã—ã¦ã„ã‚‹
- [ ] ãƒ¢ãƒƒã‚¯ãŒé©åˆ‡ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹
- [ ] ãƒ†ã‚¹ãƒˆãŒç‹¬ç«‹ã—ã¦ã„ã‚‹ï¼ˆå®Ÿè¡Œé †åºã«ä¾å­˜ã—ãªã„ï¼‰
- [ ] ãƒ†ã‚¹ãƒˆãŒé«˜é€Ÿã§ã‚ã‚‹
- [ ] ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒæ˜ç¢ºã§ã‚ã‚‹
- [ ] ã‚«ãƒãƒ¬ãƒƒã‚¸ãŒå‘ä¸Šã—ã¦ã„ã‚‹

## ãƒ†ã‚¹ãƒˆè¿½åŠ ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°
- æ–°æ©Ÿèƒ½è¿½åŠ æ™‚ï¼ˆå¿…é ˆï¼‰
- ãƒã‚°ä¿®æ­£æ™‚ï¼ˆå›å¸°é˜²æ­¢ï¼‰
- ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°å‰ï¼ˆå®‰å…¨æ€§ç¢ºä¿ï¼‰
- è¤‡é›‘ãªãƒ­ã‚¸ãƒƒã‚¯è¿½åŠ æ™‚

## å‚è€ƒãƒªãƒ³ã‚¯
- [Jest ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://jestjs.io/ja/)
- [Testing Library](https://testing-library.com/)
- [NestJS Testing](https://docs.nestjs.com/fundamentals/testing)
`````

## File: .github/agents/vertical_review_agent_specification.md
`````markdown
---
name: vertical_review_agent
description: UI â†’ API â†’ DB ã®ç¸¦å‰²ã‚Šæ•´åˆæ€§ã‚’å°‚é–€ã«æ¤œæŸ»ã™ã‚‹ãƒ¬ãƒ“ãƒ¥ãƒ¼å°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
type: reviewer
scope: read-only
---

# Vertical Review Agentï¼ˆç¸¦å‰²ã‚Šãƒ¬ãƒ“ãƒ¥ãƒ¼å°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼‰

## å½¹å‰²

æœ¬ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯ã€mycats-pro ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ãŠã„ã¦ **1ã¤ã®æ©Ÿèƒ½ãŒ UI â†’ API â†’ DB ã®ç¸¦æ–¹å‘ã«æ­£ã—ãæ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã‹** ã‚’æ¤œæŸ»ã™ã‚‹ãŸã‚ã®ã€**ãƒ¬ãƒ“ãƒ¥ãƒ¼å°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ**ã§ã™ã€‚

- å®Ÿè£…ã¯è¡Œã‚ãªã„
- è¨­è¨ˆå¤‰æ›´ã‚„æ”¹å–„ææ¡ˆã¯è¡Œã‚ãªã„
- ã‚³ãƒ¼ãƒ‰ã®ä¿®æ­£ãƒ»ç”Ÿæˆã¯è¡Œã‚ãªã„

æœ¬ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ç›®çš„ã¯ã€

> **ã€Œã“ã®æ©Ÿèƒ½ã¯ã€UI ã‹ã‚‰ DB ã¾ã§ä¸€æœ¬ã®ç·šã§æˆç«‹ã—ã¦ã„ã‚‹ã‹ã€**

ã‚’å³å¯†ã«ç¢ºèªã™ã‚‹ã“ã¨ã§ã™ã€‚

---

## æ€è€ƒç¯„å›²ã¨åˆ¶é™ï¼ˆé‡è¦ï¼‰

### è¡Œã†ã“ã¨
- UI æ“ä½œã¨ API å‘¼ã³å‡ºã—ã®å¯¾å¿œé–¢ä¿‚ã®ç¢ºèª
- API å…¥åŠ›ã¨ DTO / Service å‡¦ç†ã®æ•´åˆæ€§ç¢ºèª
- Service å‡¦ç†ã¨ Prisma / DB æ°¸ç¶šåŒ–ã®æ¥ç¶šç¢ºèª
- UI / API / DB é–“ã®å‘½åãƒ»æ„å‘³ã®ä¸€è‡´ç¢ºèª

### è¡Œã£ã¦ã¯ã„ã‘ãªã„ã“ã¨ï¼ˆå³å®ˆï¼‰

ä»¥ä¸‹ã¯ **çµ¶å¯¾ã«ç¦æ­¢** ã§ã™ã€‚

- æ¨æ¸¬ã«ã‚ˆã‚‹è£œå®Œ
- ã€ŒãŸã¶ã‚“ã€ã€ŒãŠãã‚‰ãã€ãªã©ã®æ›–æ˜§è¡¨ç¾
- è¨­è¨ˆæ”¹å–„ãƒ»ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ææ¡ˆ
- ã‚³ãƒ¼ãƒ‰ä¾‹ãƒ»ä¿®æ­£æ¡ˆã®æç¤º
- å®Ÿè£…æ–¹é‡ã¸ã®è¨€åŠ

åˆ¤æ–­ã§ããªã„å ´åˆã¯ã€**å¿…ãšã€Œä¸æ˜ã€** ã¨è¨˜è¼‰ã—ã¦ãã ã•ã„ã€‚

---

## ãƒ¬ãƒ“ãƒ¥ãƒ¼è¦³ç‚¹ï¼ˆå›ºå®šï¼‰

### 1. UI èµ·ç‚¹
- ã“ã® UI æ“ä½œã¯ã©ã“ã‹ã‚‰ç™ºç”Ÿã™ã‚‹ã‹
- ã©ã® API ãŒå‘¼ã°ã‚Œã¦ã„ã‚‹ã‹
- UI ã®å…¥åŠ›é …ç›®ã¯ API ã«ã™ã¹ã¦æ¸¡ã£ã¦ã„ã‚‹ã‹

### 2. API èµ·ç‚¹
- ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¯ã©ã® Controller / Service ã‚’é€šã‚‹ã‹
- DTO ã¨ Service å†…å‡¦ç†ã®æ„å‘³ã¯ä¸€è‡´ã—ã¦ã„ã‚‹ã‹

### 3. DB èµ·ç‚¹
- ãƒ‡ãƒ¼ã‚¿ã¯ã©ã®ãƒ†ãƒ¼ãƒ–ãƒ«ãƒ»ã‚«ãƒ©ãƒ ã«ä¿å­˜ã•ã‚Œã‚‹ã‹
- ä¿å­˜ã•ã‚Œã¦ã„ãªã„å…¥åŠ›é …ç›®ãŒå­˜åœ¨ã—ãªã„ã‹

---

## å‡ºåŠ›å½¢å¼ï¼ˆå¿…é ˆï¼‰

### 1. å…¨ä½“ãƒ•ãƒ­ãƒ¼å›³ï¼ˆASCIIï¼‰

```
UIï¼ˆãƒšãƒ¼ã‚¸ / ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆï¼‰
  â†“
APIï¼ˆã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆï¼‰
  â†“
Service / Prisma
  â†“
Databaseï¼ˆãƒ†ãƒ¼ãƒ–ãƒ« / ã‚«ãƒ©ãƒ ï¼‰
```

---

### 2. UI â†’ API â†’ DB é€£æºç¢ºèªè¡¨ï¼ˆå¿…é ˆï¼‰

| UIæ“ä½œ | API | DB | çŠ¶æ…‹ |
|------|-----|----|----|
| ã€‡ã€‡å…¥åŠ› | POST /xxx | table.column | âœ… / âš ï¸ / âŒ |

- âœ… : æ˜ç¢ºã«æ¥ç¶šã•ã‚Œã¦ã„ã‚‹
- âš ï¸ : ä¸€éƒ¨æœªæ¥ç¶šã€ã¾ãŸã¯æ„å‘³ã®ä¸ä¸€è‡´
- âŒ : æ¥ç¶šã•ã‚Œã¦ã„ãªã„

---

### 3. ç¸¦å‰²ã‚Šãƒ¬ãƒ“ãƒ¥ãƒ¼åˆ°é”åº¦ï¼ˆè‡ªå·±è©•ä¾¡ãƒ»å¿…é ˆï¼‰

```
- UI â†’ API æ¥ç¶šç¢ºèªç‡: XX%
- API â†’ DB æ°¸ç¶šåŒ–ç¢ºèªç‡: XX%
- UI â†’ DB å®Œå…¨åˆ°é”ç‡: XX%

ç·åˆåˆ°é”åº¦: XX%
```

- å„æ•°å€¤ã«ã¯ **å¿…ãšç†ç”±** ã‚’è¨˜è¼‰ã™ã‚‹ã“ã¨
- æ¨æ¸¬ã§ã®é«˜è©•ä¾¡ã¯ç¦æ­¢

---

### 4. æœªæ¥ç¶š / ä¸æ˜ç‚¹ä¸€è¦§

| å†…å®¹ | å±¤ | ç†ç”± |
|---|---|---|
| ã€‡ã€‡ | UI â†’ API | å¯¾å¿œã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆä¸æ˜ |
| â–³â–³ | API â†’ DB | æ°¸ç¶šåŒ–å‡¦ç†ãŒè¦‹å½“ãŸã‚‰ãªã„ |

---

### 5. çµè«–ï¼ˆç°¡æ½”ï¼‰

```
ç¸¦å‰²ã‚Šæ•´åˆæ€§: âœ… / âš ï¸ / âŒ
æœ€ã‚‚å¤§ããªæ–­çµ¶ãƒã‚¤ãƒ³ãƒˆ: UI / API / DB
```

---

## èª¿æŸ»å¯¾è±¡ç¯„å›²

ä»¥ä¸‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ»ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ã¿ã‚’èª¿æŸ»å¯¾è±¡ã¨ã—ã¦ãã ã•ã„ã€‚

- `frontend/src/app/**`
- `frontend/src/components/**`
- `frontend/src/lib/**`
- `backend/src/**`
- `backend/prisma/schema.prisma`

---

## å„ªå…ˆãƒ«ãƒ¼ãƒ«

1. ãƒ«ãƒ¼ãƒˆ `AGENTS.md`
2. è©²å½“ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã® `AGENTS.md`
3. æœ¬ãƒ•ã‚¡ã‚¤ãƒ«

ã“ã‚Œã‚‰ã«çŸ›ç›¾ãŒã‚ã‚‹å ´åˆã¯ã€**ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ä¸­æ–­ã—ã€çŸ›ç›¾ç‚¹ã‚’å ±å‘Š**ã—ã¦ãã ã•ã„ã€‚

---

## é‹ç”¨ä¸Šã®æ³¨æ„

- æœ¬ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯ **å®Ÿè£… Agent ã¨åˆ†é›¢** ã—ã¦ä½¿ç”¨ã™ã‚‹ã“ã¨
- å®Ÿè£…é€”ä¸­ãƒ»å®Ÿè£…å¾Œã®ä¸¡æ–¹ã§ç¹°ã‚Šè¿”ã—ä½¿ç”¨ã—ã¦ã‚ˆã„
- å‡ºåŠ›ã¯ãƒ¬ãƒ“ãƒ¥ãƒ¼è¨˜éŒ²ã¨ã—ã¦ãã®ã¾ã¾ä¿å­˜ãƒ»è²¼ã‚Šä»˜ã‘å¯èƒ½ãªå½¢å¼ã‚’ç¶­æŒã™ã‚‹ã“ã¨
`````

## File: .github/guards/package-added-guard.md
`````markdown
# ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸è¿½åŠ æ™‚ã®å¿…é ˆæ‰‹é †

## 1. ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ç›´å¾Œ

```bash
pnpm install
pnpm prisma:generate
```

ç†ç”±: node_modules æ›´æ–°ã«ã‚ˆã‚Š Prisma Client ã®ä¾å­˜é–¢ä¿‚ãŒå¤‰åŒ–ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚

## 2. å‹ãƒã‚§ãƒƒã‚¯

```bash
pnpm --filter backend run build
pnpm --filter frontend run build
```

## 3. Lint ãƒã‚§ãƒƒã‚¯

```bash
pnpm lint
```

## 4. ä¾å­˜é–¢ä¿‚ã®ç¢ºèª

- package.json ã® diff ç¢ºèª
- pnpm-lock.yaml æ›´æ–°ç¢ºèª
- `pnpm audit` ã«ã‚ˆã‚‹è„†å¼±æ€§ãƒã‚§ãƒƒã‚¯

## ãƒ«ãƒ¼ãƒ«

- ã„ãšã‚Œã‹ã§å¤±æ•—ã—ãŸå ´åˆã€æ¬¡å·¥ç¨‹ã¸é€²ã¾ãªã„
- åŸå› è§£æ±ºã‚’æœ€å„ªå…ˆã¨ã™ã‚‹
`````

## File: .github/instructions/backend.instructions.md
`````markdown
---
applyTo: "backend/**"
excludeAgent: ""
---

# Backend ãƒ‘ã‚¹å›ºæœ‰ã®æŒ‡ç¤º

ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ `backend/` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«å¯¾ã™ã‚‹ Copilot ã®å‹•ä½œã‚’åˆ¶å¾¡ã—ã¾ã™ã€‚

## é©ç”¨ç¯„å›²
- `backend/**/*.ts`
- `backend/prisma/**`
- `backend/test/**`

## å¿…é ˆãƒ«ãƒ¼ãƒ«

### ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£
- Controller ã§ç›´æ¥ Prisma ã‚’å‘¼ã³å‡ºã•ãªã„
- Service ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…
- PrismaService ã‚’ä½¿ç”¨ã—ã¦ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹

### å‹å®‰å…¨
- `any` / `unknown` ã®ä½¿ç”¨ç¦æ­¢
- ã™ã¹ã¦ã®é–¢æ•°ã«æ˜ç¤ºçš„ãªå‹å®šç¾©
- DTO ã§å…¥åŠ›ã‚’ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³

### ã‚¨ãƒ©ãƒ¼å‡¦ç†
- `HttpException` ç³»ã‚’ä½¿ç”¨
- ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯æ—¥æœ¬èª
- é©åˆ‡ãªHTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’è¿”å´

### Prisma
- ã‚¹ã‚­ãƒ¼ãƒå¤‰æ›´å¾Œã¯å¿…ãš `prisma:generate` ã‚’å®Ÿè¡Œ
- ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ç”Ÿæˆã—ã¦é©ç”¨
- N+1 å•é¡Œã‚’é¿ã‘ã‚‹ï¼ˆselect/include ã§æœ€é©åŒ–ï¼‰

## ãƒ“ãƒ«ãƒ‰ãƒ»ãƒ†ã‚¹ãƒˆã‚³ãƒãƒ³ãƒ‰

```bash
# Lint
pnpm --filter backend run lint

# å‹ãƒã‚§ãƒƒã‚¯
pnpm --filter backend run type-check

# ãƒ“ãƒ«ãƒ‰
pnpm --filter backend run build

# ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ
pnpm --filter backend run test

# E2E ãƒ†ã‚¹ãƒˆ
pnpm --filter backend run test:e2e

# Prisma é–¢é€£
pnpm --filter backend run prisma:generate
pnpm --filter backend run prisma:migrate
pnpm --filter backend run prisma:deploy
```

## å¤‰æ›´ã—ã¦ã¯ã„ã‘ãªã„ãƒ•ã‚¡ã‚¤ãƒ«
- `prisma/migrations/**` - ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã¯è‡ªå‹•ç”Ÿæˆã®ã¿
- `node_modules/**`
- `dist/**` - ãƒ“ãƒ«ãƒ‰æˆæœç‰©

## ã‚³ãƒ¼ãƒ‰ä¾‹

### Service ã®åŸºæœ¬æ§‹é€ 
```typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class ExampleService {
  constructor(private prisma: PrismaService) {}

  async findOne(id: number) {
    const item = await this.prisma.example.findUnique({
      where: { id },
    });

    if (!item) {
      throw new NotFoundException('ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    }

    return item;
  }
}
```

### DTO ã®åŸºæœ¬æ§‹é€ 
```typescript
import { IsString, IsNotEmpty } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class CreateExampleDto {
  @ApiProperty({ description: 'åå‰' })
  @IsString()
  @IsNotEmpty({ message: 'åå‰ã¯å¿…é ˆã§ã™' })
  name: string;
}
```

## å“è³ªã‚²ãƒ¼ãƒˆ
å¤‰æ›´å¾Œã€å¿…ãšä»¥ä¸‹ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„:
1. `pnpm --filter backend run lint`
2. `pnpm --filter backend run build`
3. `pnpm --filter backend run test`

Prisma ã‚¹ã‚­ãƒ¼ãƒã‚’å¤‰æ›´ã—ãŸå ´åˆ:
1. `pnpm --filter backend run prisma:generate`
2. `pnpm --filter backend run prisma:migrate`
3. ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ

## å‚è€ƒãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
- [backend/AGENTS.md](../backend/AGENTS.md) - è©³ç´°ãªã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³
- [NestJS ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://docs.nestjs.com/)
- [Prisma ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://www.prisma.io/docs)
`````

## File: .github/instructions/docs.instructions.md
`````markdown
---
applyTo: "**.md"
excludeAgent: "coding-agent"
---

# ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãƒ‘ã‚¹å›ºæœ‰ã®æŒ‡ç¤º

ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã™ã¹ã¦ã®ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã«å¯¾ã™ã‚‹ Copilot ã®å‹•ä½œã‚’åˆ¶å¾¡ã—ã¾ã™ã€‚

## é©ç”¨ç¯„å›²
- `**/*.md`
- `docs/**`
- `README.md`
- `SETUP_GUIDE.md`
- ãã®ä»–ã™ã¹ã¦ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

## å¿…é ˆãƒ«ãƒ¼ãƒ«

### è¨€èª
- **ã™ã¹ã¦ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯æ—¥æœ¬èªã§è¨˜è¿°**
- æŠ€è¡“ç”¨èªã¯è‹±èªã®ã¾ã¾ï¼ˆAPIã€HTTPã€JSON ãªã©ï¼‰
- ç°¡æ½”ã§å®Ÿå‹™çš„ãªè¡¨ç¾ã‚’ä½¿ç”¨
- æ©Ÿæ¢°ç¿»è¨³æ„Ÿã‚’é¿ã‘ã‚‹

### ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
- è¦‹å‡ºã—ã®éšå±¤ã‚’é©åˆ‡ã«ä½¿ç”¨ï¼ˆh1, h2, h3ï¼‰
- ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã«ã¯è¨€èªã‚’æŒ‡å®š
- æ‰‹é †ã¯ç•ªå·ä»˜ããƒªã‚¹ãƒˆã§æ˜ç¤º
- é‡è¦ãªæƒ…å ±ã¯å¤ªå­—ã‚„ç®‡æ¡æ›¸ãã§å¼·èª¿

### ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯
````markdown
```typescript
// TypeScript ã‚³ãƒ¼ãƒ‰ä¾‹
interface Example {
  id: number;
  name: string;
}
```

```bash
# ã‚³ãƒãƒ³ãƒ‰ä¾‹
pnpm install
pnpm dev
```
````

## ç¦æ­¢äº‹é …
- ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å¤‰æ›´ã—ãªã„
- ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®æ›´æ–°ã®ã¿ã«é›†ä¸­
- å¤ã„æƒ…å ±ã‚’æ®‹ã•ãªã„

## ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®ç¨®é¡

### README.md
ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“ã®æ¦‚è¦ã¨ä½¿ã„æ–¹ã€‚

**å¿…é ˆã‚»ã‚¯ã‚·ãƒ§ãƒ³:**
- ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦
- æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯
- ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆ
- ä¸»è¦æ©Ÿèƒ½
- ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### SETUP_GUIDE.md
åˆå›ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã®è©³ç´°æ‰‹é †ã€‚

**å«ã‚€ã¹ãå†…å®¹:**
- å‰ææ¡ä»¶
- ç’°å¢ƒå¤‰æ•°ã®è¨­å®š
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
- é–‹ç™ºç’°å¢ƒã®èµ·å‹•
- å‹•ä½œç¢ºèª

### TROUBLESHOOTING.md
ã‚ˆãã‚ã‚‹å•é¡Œã¨è§£æ±ºæ–¹æ³•ã€‚

**æ§‹æˆ:**
- å•é¡Œã®èª¬æ˜
- åŸå› 
- è§£æ±ºæ–¹æ³•
- äºˆé˜²ç­–

## æ›´æ–°ã‚¿ã‚¤ãƒŸãƒ³ã‚°
- æ–°æ©Ÿèƒ½è¿½åŠ æ™‚
- API ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆè¿½åŠ /å¤‰æ›´æ™‚
- ç’°å¢ƒå¤‰æ•°è¿½åŠ æ™‚
- ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æ‰‹é †å¤‰æ›´æ™‚
- ãƒã‚°ä¿®æ­£æ™‚ï¼ˆãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã«è¿½åŠ ï¼‰

## å“è³ªãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
- [ ] æ—¥æœ¬èªã§è¨˜è¿°ã•ã‚Œã¦ã„ã‚‹
- [ ] ç°¡æ½”ã§åˆ†ã‹ã‚Šã‚„ã™ã„
- [ ] ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã«è¨€èªãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹
- [ ] ãƒªãƒ³ã‚¯ãŒæ­£ã—ãæ©Ÿèƒ½ã™ã‚‹
- [ ] ã‚¿ã‚¤ãƒãŒãªã„
- [ ] ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãŒçµ±ä¸€ã•ã‚Œã¦ã„ã‚‹

## ãƒ•ã‚¡ã‚¤ãƒ«é…ç½®

### ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
- `README.md` - ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“
- `SETUP_GUIDE.md` - ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
- `TROUBLESHOOTING.md` - ãƒˆãƒ©ãƒ–ãƒ«å¯¾å¿œ
- `DEPLOYMENT_*.md` - ãƒ‡ãƒ—ãƒ­ã‚¤é–¢é€£

### docs/ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
- ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆæ›¸
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆæ›¸
- è©³ç´°ãªæŠ€è¡“ä»•æ§˜æ›¸

### .github/ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
- ãƒ‡ãƒ—ãƒ­ã‚¤ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
- CI/CD ã‚¬ã‚¤ãƒ‰

## ä¾‹: README ã‚»ã‚¯ã‚·ãƒ§ãƒ³

```markdown
## ğŸš€ ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆ

### å‰ææ¡ä»¶
- Node.js 20.x
- pnpm 9.x
- PostgreSQL 15+

### ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

1. ãƒªãƒã‚¸ãƒˆãƒªã‚’ã‚¯ãƒ­ãƒ¼ãƒ³
   ```bash
   git clone https://github.com/username/repo.git
   cd repo
   ```

2. ä¾å­˜é–¢ä¿‚ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
   ```bash
   pnpm install
   ```

3. ç’°å¢ƒå¤‰æ•°ã‚’è¨­å®š
   ```bash
   cp .env.example .env
   # .env ã‚’ç·¨é›†
   ```

4. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
   ```bash
   pnpm db:migrate
   pnpm db:seed
   ```

5. é–‹ç™ºã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•
   ```bash
   pnpm dev
   ```

6. ãƒ–ãƒ©ã‚¦ã‚¶ã§ http://localhost:3000 ã‚’é–‹ã
```

## å‚è€ƒãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
- [docs/](../docs/) - è©³ç´°ãªãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
- [README.md](../README.md) - ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ README
`````

## File: .github/instructions/frontend.instructions.md
`````markdown
---
applyTo: "frontend/**"
excludeAgent: ""
---

# Frontend ãƒ‘ã‚¹å›ºæœ‰ã®æŒ‡ç¤º

ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ `frontend/` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«å¯¾ã™ã‚‹ Copilot ã®å‹•ä½œã‚’åˆ¶å¾¡ã—ã¾ã™ã€‚

## é©ç”¨ç¯„å›²
- `frontend/src/**/*.tsx`
- `frontend/src/**/*.ts`

## å¿…é ˆãƒ«ãƒ¼ãƒ«

### React/Next.js
- Server Component ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¨ã™ã‚‹
- `"use client"` ã¯å¿…è¦ãªå ´åˆã®ã¿ä½¿ç”¨ã—ã€ç†ç”±ã‚’ã‚³ãƒ¡ãƒ³ãƒˆ
- App Router ã®è¦ç´„ã«å¾“ã†ï¼ˆpage.tsx, layout.tsx ãªã©ï¼‰

### å‹å®‰å…¨
- `any` / `unknown` ã®ä½¿ç”¨ç¦æ­¢
- ã™ã¹ã¦ã® Props ã«å‹å®šç¾©
- API ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã¯ç”Ÿæˆå‹ã‚’ä½¿ç”¨

### UI/UX
- æ—¥æœ¬èªæ–‡è¨€ã‚’ä½¿ç”¨
- ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ã‚’è€ƒæ…®ï¼ˆARIAã€ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œï¼‰
- ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ‡ã‚¶ã‚¤ãƒ³
- ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒ»ã‚¨ãƒ©ãƒ¼çŠ¶æ…‹ã‚’è¡¨ç¤º

### ã‚¹ã‚¿ã‚¤ãƒªãƒ³ã‚°
- Mantine UI ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’å„ªå…ˆ
- Tailwind CSS ã§è£œå®Œ
- ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã‚¹ã‚¿ã‚¤ãƒ«ã¯é¿ã‘ã‚‹

## ãƒ“ãƒ«ãƒ‰ãƒ»ãƒ†ã‚¹ãƒˆã‚³ãƒãƒ³ãƒ‰

```bash
# Lint
pnpm --filter frontend run lint

# å‹ãƒã‚§ãƒƒã‚¯
pnpm --filter frontend run type-check

# ãƒ“ãƒ«ãƒ‰
pnpm --filter frontend run build

# ãƒ†ã‚¹ãƒˆ
pnpm --filter frontend run test

# é–‹ç™ºã‚µãƒ¼ãƒãƒ¼
pnpm --filter frontend run dev
```

## å¤‰æ›´ã—ã¦ã¯ã„ã‘ãªã„ãƒ•ã‚¡ã‚¤ãƒ«
- `node_modules/**`
- `.next/**` - ãƒ“ãƒ«ãƒ‰æˆæœç‰©
- `src/lib/api/generated/**` - OpenAPI ç”Ÿæˆãƒ•ã‚¡ã‚¤ãƒ«

## ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ 

```
src/
â”œâ”€â”€ app/              # App Router ãƒšãƒ¼ã‚¸
â”‚   â”œâ”€â”€ page.tsx      # ãƒˆãƒƒãƒ—ãƒšãƒ¼ã‚¸
â”‚   â”œâ”€â”€ layout.tsx    # ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
â”‚   â””â”€â”€ cats/
â”‚       â”œâ”€â”€ page.tsx
â”‚       â””â”€â”€ _components/  # ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”œâ”€â”€ components/       # å…±æœ‰ UI ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ api/         # API ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
â”‚   â””â”€â”€ hooks/       # ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯
â””â”€â”€ styles/          # ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚¿ã‚¤ãƒ«
```

## ã‚³ãƒ¼ãƒ‰ä¾‹

### Server Component
```typescript
// app/example/page.tsx
import { getItems } from '@/lib/api/items';

export default async function ExamplePage() {
  const items = await getItems();

  return (
    <div>
      <h1>ã‚µãƒ³ãƒ—ãƒ«ãƒšãƒ¼ã‚¸</h1>
      {items.map((item) => (
        <div key={item.id}>{item.name}</div>
      ))}
    </div>
  );
}
```

### Client Component
```typescript
// app/example/_components/InteractiveList.tsx
'use client'; // ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãªæ©Ÿèƒ½ãŒå¿…è¦ãªãŸã‚

import { useState } from 'react';
import { Button } from '@mantine/core';

interface Props {
  items: Item[];
}

export function InteractiveList({ items }: Props) {
  const [selected, setSelected] = useState<number | null>(null);

  return (
    <div>
      {items.map((item) => (
        <Button key={item.id} onClick={() => setSelected(item.id)}>
          {item.name}
        </Button>
      ))}
    </div>
  );
}
```

### Server Actions
```typescript
// app/example/_actions.ts
'use server';

import { revalidatePath } from 'next/cache';

export async function createItemAction(formData: FormData) {
  const name = formData.get('name') as string;

  if (!name) {
    return { error: 'åå‰ã¯å¿…é ˆã§ã™' };
  }

  try {
    // API å‘¼ã³å‡ºã—
    await createItem({ name });
    revalidatePath('/example');
    return { success: true };
  } catch (error) {
    return { error: 'ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ' };
  }
}
```

## Mantine UI ã®ä½¿ç”¨

```typescript
import { Button, Stack, Text, Card } from '@mantine/core';

<Stack gap="md">
  <Text size="lg" fw={700}>è¦‹å‡ºã—</Text>
  <Card shadow="sm" padding="lg">
    <Text>ã‚«ãƒ¼ãƒ‰ã®å†…å®¹</Text>
  </Card>
  <Button color="blue">ãƒœã‚¿ãƒ³</Button>
</Stack>
```

## å“è³ªã‚²ãƒ¼ãƒˆ
å¤‰æ›´å¾Œã€å¿…ãšä»¥ä¸‹ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„:
1. `pnpm --filter frontend run lint`
2. `pnpm --filter frontend run type-check`
3. `pnpm --filter frontend run build`

UI å¤‰æ›´ã®å ´åˆ:
- ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ã‚’ç¢ºèª
- ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ã‚’ãƒã‚§ãƒƒã‚¯
- ã‚¨ãƒ©ãƒ¼ãƒ»ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ã‚’ç¢ºèª

## å‚è€ƒãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
- [frontend/AGENTS.md](../frontend/AGENTS.md) - è©³ç´°ãªã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³
- [Next.js App Router](https://nextjs.org/docs/app)
- [Mantine UI](https://mantine.dev/)
- [React 19](https://react.dev/)
`````

## File: .github/ISSUE_TEMPLATE/high-auth-bypass.md
`````markdown
---
name: ğŸŸ  High - AUTH_DISABLED ãƒã‚¤ãƒ‘ã‚¹æ©Ÿæ§‹ãŒæœ¬ç•ªã‚³ãƒ¼ãƒ‰ã«æ®‹å­˜
about: èªè¨¼ãƒã‚¤ãƒ‘ã‚¹æ©Ÿèƒ½ãŒæœ¬ç•ªç’°å¢ƒã§èª¤ã£ã¦æœ‰åŠ¹åŒ–ã•ã‚Œã‚‹ãƒªã‚¹ã‚¯
title: '[HIGH] Remove or strengthen AUTH_DISABLED bypass mechanism'
labels: 'security, high, authentication'
assignees: ''
---

## ğŸš¨ å•é¡Œã®æ¦‚è¦

é–‹ç™ºç”¨ã®èªè¨¼ãƒã‚¤ãƒ‘ã‚¹æ©Ÿæ§‹ï¼ˆAUTH_DISABLEDï¼‰ãŒæœ¬ç•ªã‚³ãƒ¼ãƒ‰ã«æ®‹å­˜ã—ã¦ãŠã‚Šã€è¨­å®šãƒŸã‚¹ã«ã‚ˆã‚Šæœ¬ç•ªç’°å¢ƒã§èªè¨¼ãŒå®Œå…¨ã«ãƒã‚¤ãƒ‘ã‚¹ã•ã‚Œã‚‹ãƒªã‚¹ã‚¯ãŒã‚ã‚‹ã€‚

## ğŸ” å½±éŸ¿ã‚’å—ã‘ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«

- `backend/src/auth/jwt-auth.guard.ts`
- `frontend/src/middleware.ts`

## ğŸ¯ å½±éŸ¿ç¯„å›²

- **é‡è¦åº¦**: ğŸŸ  High
- **ã‚«ãƒ†ã‚´ãƒª**: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ / èªè¨¼
- **å½±éŸ¿**: 
  - ç’°å¢ƒå¤‰æ•°ã®è¨­å®šãƒŸã‚¹ã§å…¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆãŒä¿è­·ãªã—ã«ãªã‚‹
  - ãƒ‡ãƒ—ãƒ­ã‚¤æ™‚ã«èª¤ã£ã¦ `AUTH_DISABLED=1` ã‚’è¨­å®šã—ã¦ã—ã¾ã†å¯èƒ½æ€§
  - äººçš„ã‚¨ãƒ©ãƒ¼ã«ã‚ˆã‚‹é‡å¤§ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¾µå®³

## ğŸ“‹ ç¾åœ¨ã®å®Ÿè£…

**ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ (jwt-auth.guard.ts)**:
```typescript
async canActivate(context: ExecutionContext): Promise<boolean> {
    if (process.env.AUTH_DISABLED === "1") {
        const req = context.switchToHttp().getRequest();
        if (!req.user) {
            req.user = {
                userId: "dev-admin",
                email: "dev-admin@example.com",
                role: "ADMIN",
            };
        }
        return true;
    }
    // ... é€šå¸¸ã®èªè¨¼å‡¦ç†
}
```

**ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ (middleware.ts)**:
ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã«ã¯æœ¬ç•ªç’°å¢ƒãƒã‚§ãƒƒã‚¯ãŒã‚ã‚‹ãŒã€ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«ã¯ç„¡ã„ã€‚

## âœ… å¯¾å¿œã‚¿ã‚¹ã‚¯

### ã‚ªãƒ—ã‚·ãƒ§ãƒ³1: å®Œå…¨å‰Šé™¤ï¼ˆæ¨å¥¨ï¼‰

- [ ] `jwt-auth.guard.ts` ã‹ã‚‰ AUTH_DISABLED ãƒã‚§ãƒƒã‚¯ã‚’å®Œå…¨ã«å‰Šé™¤
- [ ] `frontend/src/middleware.ts` ã‹ã‚‰ AUTH_DISABLED ãƒã‚§ãƒƒã‚¯ã‚’å®Œå…¨ã«å‰Šé™¤
- [ ] é–‹ç™ºç’°å¢ƒã§ã‚‚æ­£è¦ã®èªè¨¼ãƒ•ãƒ­ãƒ¼ã‚’ä½¿ç”¨
- [ ] ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦é–‹ç™ºç”¨ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ç”¨æ„

### ã‚ªãƒ—ã‚·ãƒ§ãƒ³2: å³æ ¼åŒ–ï¼ˆæ¬¡å–„ç­–ï¼‰

- [ ] ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®ç’°å¢ƒæ¤œè¨¼ã« AUTH_DISABLED ãƒã‚§ãƒƒã‚¯ã‚’è¿½åŠ 
  ```typescript
  // backend/src/common/environment.validation.ts
  if (process.env.NODE_ENV === 'production' && process.env.AUTH_DISABLED === "1") {
    throw new Error("AUTH_DISABLED cannot be enabled in production environment");
  }
  ```

- [ ] CI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã§ AUTH_DISABLED ãƒã‚§ãƒƒã‚¯ã‚’è¿½åŠ 
  ```yaml
  - name: Verify AUTH_DISABLED is not set
    run: |
      if [ "$AUTH_DISABLED" = "1" ]; then
        echo "âŒ AUTH_DISABLED is enabled - not allowed"
        exit 1
      fi
  ```

- [ ] èµ·å‹•æ™‚ã«è­¦å‘Šãƒ­ã‚°ã‚’å‡ºåŠ›
  ```typescript
  if (process.env.AUTH_DISABLED === "1") {
    logger.warn("âš ï¸  AUTH_DISABLED is enabled - authentication bypass is active");
    logger.warn("âš ï¸  This should NEVER be used in production");
  }
  ```

### å…±é€šã‚¿ã‚¹ã‚¯

- [ ] README ã¨ç’°å¢ƒå¤‰æ•°ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’æ›´æ–°
- [ ] é–‹ç™ºè€…ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã«æ³¨æ„äº‹é …ã‚’è¿½åŠ 
- [ ] `.env.example` ãƒ•ã‚¡ã‚¤ãƒ«ã«è­¦å‘Šã‚³ãƒ¡ãƒ³ãƒˆã‚’è¿½åŠ 

## ğŸ“š å‚è€ƒè³‡æ–™

- OWASP: [Broken Authentication](https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication)
- èª¿æŸ»ãƒ¬ãƒãƒ¼ãƒˆ: `PRODUCTION_DEPLOYMENT_ISSUES.md` - Issue #2

## âš ï¸ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã®æ³¨æ„

ã“ã®ãƒ•ãƒ©ã‚°ãŒæœ‰åŠ¹ãªçŠ¶æ…‹ã§ãƒ‡ãƒ—ãƒ­ã‚¤ã•ã‚Œã‚‹ã¨ï¼š
- å…¨ã¦ã®APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆãŒèªè¨¼ãªã—ã§ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
- ä»»æ„ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒç®¡ç†è€…æ¨©é™ã§æ“ä½œå¯èƒ½
- ãƒ‡ãƒ¼ã‚¿ã®ä¸æ­£ã‚¢ã‚¯ã‚»ã‚¹ãƒ»æ”¹ã–ã‚“ãƒ»å‰Šé™¤ãŒå¯èƒ½
`````

## File: .github/ISSUE_TEMPLATE/medium-frontend-env-example.md
`````markdown
---
name: ğŸŸ¡ Medium - ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ç’°å¢ƒå¤‰æ•°ã®ä¾‹ç¤ºãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„
about: ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®ãƒ‡ãƒ—ãƒ­ã‚¤æ™‚ã«å¿…è¦ãªç’°å¢ƒå¤‰æ•°è¨­å®šãŒä¸æ˜ç¢º
title: '[MEDIUM] Create frontend/.env.example file'
labels: 'documentation, medium, config'
assignees: ''
---

## ğŸš¨ å•é¡Œã®æ¦‚è¦

ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã« `.env.example` ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã›ãšã€å¿…è¦ãªç’°å¢ƒå¤‰æ•°ã®è¨­å®šãŒä¸æ˜ç¢ºã€‚

## ğŸ” ç¾çŠ¶

```bash
$ ls -la frontend/.env*
# ä½•ã‚‚è¡¨ç¤ºã•ã‚Œãªã„ - .env.example ãŒå­˜åœ¨ã—ãªã„
```

ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«ã¯ `.env.example` ãŒå­˜åœ¨ã™ã‚‹ãŒã€ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã«ã¯å­˜åœ¨ã—ãªã„ã€‚

## ğŸ¯ å½±éŸ¿ç¯„å›²

- **é‡è¦åº¦**: ğŸŸ¡ Medium
- **ã‚«ãƒ†ã‚´ãƒª**: ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ / ãƒ‡ãƒ—ãƒ­ã‚¤
- **å½±éŸ¿**: 
  - æ–°è¦é–‹ç™ºè€…ã®ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãŒå›°é›£
  - ãƒ‡ãƒ—ãƒ­ã‚¤æ™‚ã«å¿…è¦ãªç’°å¢ƒå¤‰æ•°ãŒä¸æ˜ç¢º
  - è¨­å®šãƒŸã‚¹ã«ã‚ˆã‚‹ãƒ‡ãƒ—ãƒ­ã‚¤å¤±æ•—ã®ãƒªã‚¹ã‚¯

## âœ… å¯¾å¿œã‚¿ã‚¹ã‚¯

### ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ

- [ ] `frontend/.env.example` ã‚’ä½œæˆ
  ```env
  # Frontend Environment Variables Example
  
  # API ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆï¼ˆå¿…é ˆï¼‰
  # æœ¬ç•ªç’°å¢ƒ: å®Ÿéš›ã®APIãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’è¨­å®š
  # é–‹ç™ºç’°å¢ƒ: http://localhost:3004/api/v1
  NEXT_PUBLIC_API_URL=http://localhost:3004/api/v1
  
  # ç’°å¢ƒè­˜åˆ¥å­ï¼ˆå¿…é ˆï¼‰
  # development | production | test
  NEXT_PUBLIC_ENV=development
  
  # èªè¨¼ãƒã‚¤ãƒ‘ã‚¹ï¼ˆé–‹ç™ºå°‚ç”¨ - æœ¬ç•ªã§ã¯çµ¶å¯¾ã«è¨­å®šã—ãªã„ã“ã¨ï¼‰
  # NEXT_PUBLIC_AUTH_DISABLED=0
  
  # Sentry DSNï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ - ã‚¨ãƒ©ãƒ¼è¿½è·¡ï¼‰
  # NEXT_PUBLIC_SENTRY_DSN=
  
  # Feature Flagsï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
  # NEXT_PUBLIC_ENABLE_ANALYTICS=false
  # NEXT_PUBLIC_ENABLE_DEBUG_MODE=false
  ```

### ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°

- [ ] README.md ã®ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆ ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’æ›´æ–°
  ```markdown
  ### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ç’°å¢ƒå¤‰æ•°ã®è¨­å®š
  
  \`\`\`bash
  cd frontend
  cp .env.example .env.local
  # å¿…è¦ã«å¿œã˜ã¦ .env.local ã‚’ç·¨é›†
  \`\`\`
  ```

- [ ] ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚¹ã‚¯ãƒªãƒ—ãƒˆã«è¿½åŠ 
  ```bash
  # scripts/setup-dev.sh ã«è¿½åŠ 
  if [ ! -f frontend/.env.local ]; then
    echo "ğŸ“ Creating frontend/.env.local from example..."
    cp frontend/.env.example frontend/.env.local
  fi
  ```

### æ¤œè¨¼

- [ ] æ–°è¦ã‚¯ãƒ­ãƒ¼ãƒ³ã—ãŸç’°å¢ƒã§ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æ‰‹é †ãŒå‹•ä½œã™ã‚‹ã“ã¨ã‚’ç¢ºèª
- [ ] ã™ã¹ã¦ã®å¿…è¦ãªç’°å¢ƒå¤‰æ•°ãŒ `.env.example` ã«å«ã¾ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
- [ ] ã‚³ãƒ¡ãƒ³ãƒˆãŒåˆ†ã‹ã‚Šã‚„ã™ãã€å„å¤‰æ•°ã®ç”¨é€”ãŒæ˜ç¢ºã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª

## ğŸ“š å‚è€ƒè³‡æ–™

- Next.js ç’°å¢ƒå¤‰æ•°: https://nextjs.org/docs/app/building-your-application/configuring/environment-variables
- èª¿æŸ»ãƒ¬ãƒãƒ¼ãƒˆ: `PRODUCTION_DEPLOYMENT_ISSUES.md` - Issue #4

## ğŸ”— é–¢é€£ãƒ•ã‚¡ã‚¤ãƒ«

- `backend/.env.example` - å‚è€ƒã¨ã—ã¦
- `.env.development.example` - ãƒ«ãƒ¼ãƒˆãƒ¬ãƒ™ãƒ«ã®ä¾‹ç¤ºãƒ•ã‚¡ã‚¤ãƒ«
- `.env.production.example` - æœ¬ç•ªç’°å¢ƒã®ä¾‹ç¤ºãƒ•ã‚¡ã‚¤ãƒ«
`````

## File: .github/workflows/trigger-deploy-from-ci.yml
`````yaml
# Trigger deploy-only reusable workflow after ci-cd finishes successfully
# æ³¨æ„: workflows: ã«æŒ‡å®šã™ã‚‹ "CI/CD Pipeline" ã¯ ci-cd.yml ã® top-level name: ã¨å®Œå…¨ä¸€è‡´ã•ã›ã¦ãã ã•ã„ã€‚
# ãƒ•ã‚¡ã‚¤ãƒ«é…ç½®: .github/workflows/trigger-deploy-from-ci.yml
name: trigger-deploy-from-ci

on:
  workflow_run:
    workflows: ["CI/CD Pipeline"]
    types:
      - completed
    branches:
      - main

permissions:
  contents: read

jobs:
  call-deploy:
    name: Call Deploy Workflow for Production
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    uses: ./.github/workflows/deploy-only.yml
    with:
      environment: "production"
    secrets:
      # Production secrets only (staging is deployed from separate project)
      GCP_SA_KEY: ${{ secrets.GCP_SA_KEY }}
      GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
      GCP_SQL_INSTANCE_NAME: ${{ secrets.GCP_SQL_INSTANCE_NAME }}
      GCP_RUN_SA_BACKEND: ${{ secrets.GCP_RUN_SA_BACKEND }}
      GCP_RUN_SA_FRONTEND: ${{ secrets.GCP_RUN_SA_FRONTEND }}
`````

## File: .github/ai-checklist.md
`````markdown
# AI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ è‡ªå·±æ¤œè¨¼ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

## ğŸ“‹ ä½œæ¥­é–‹å§‹å‰ãƒã‚§ãƒƒã‚¯

- [ ] é–¢é€£ã™ã‚‹ CODE_GUIDE.md / AGENTS.md ã‚’èª­ã¿è¾¼ã¿æ¸ˆã¿
- [ ] æ—¢å­˜ã®é¡ä¼¼å®Ÿè£…ã‚’æ¤œç´¢æ¸ˆã¿ï¼ˆå†åˆ©ç”¨å¯èƒ½æ€§ã‚’ç¢ºèªï¼‰
- [ ] å½±éŸ¿ç¯„å›²ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¨ä¾å­˜é–¢ä¿‚ã‚’ç‰¹å®šæ¸ˆã¿

## ğŸ”§ å®Ÿè£…ä¸­ãƒã‚§ãƒƒã‚¯ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«å˜ä½ï¼‰

- [ ] æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆæ™‚: é…ç½®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒè²¬å‹™ã«é©åˆ
- [ ] å‹å®šç¾©: any/unknown ã‚’ä½¿ç”¨ã—ã¦ã„ãªã„ï¼ˆä¾‹å¤–æ™‚ã¯ç†ç”±ã‚³ãƒ¡ãƒ³ãƒˆ + ä»£æ›¿æ¡ˆæ¤œè¨æ¸ˆã¿ï¼‰
- [ ] é–¢æ•°: å¼•æ•°ãƒ»æˆ»ã‚Šå€¤ã®å‹ãŒå®Œå…¨ã«æ˜ç¤º
- [ ] Prisma: ã‚¹ã‚­ãƒ¼ãƒå¤‰æ›´æ™‚ã¯ `pnpm prisma:generate` å®Ÿè¡Œæ¸ˆã¿
- [ ] ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸è¿½åŠ æ™‚: `pnpm prisma:generate` å®Ÿè¡Œæ¸ˆã¿ï¼ˆPrisma Client å†ç”Ÿæˆï¼‰
- [ ] ã‚¨ãƒ©ãƒ¼å‡¦ç†: ç©º catch / console.error ã®ã¿ / void async ãŒãªã„

## âœ… æ©Ÿèƒ½å®Œæˆæ™‚ãƒã‚§ãƒƒã‚¯

- [ ] å½±éŸ¿ç¯„å›²ã®ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œ: `pnpm test`ï¼ˆè©²å½“ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼‰
- [ ] Lint ãƒã‚§ãƒƒã‚¯: `pnpm lint` ã§è­¦å‘Šãƒ»ã‚¨ãƒ©ãƒ¼ã‚¼ãƒ­
- [ ] ãƒ“ãƒ«ãƒ‰ç¢ºèª: `pnpm build`ï¼ˆbackend / frontendï¼‰æˆåŠŸ
- [ ] Prisma å¤‰æ›´æ™‚: `pnpm db:migrate` + `pnpm db:seed` ã§å‹•ä½œç¢ºèª

## ğŸš¨ ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯å„ªå…ˆåº¦

- [ ] ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®èª¿æŸ»ç¤ºå”†ã¯å³åº§ã«æ–¹é‡ã¸åæ˜ 
- [ ] ã‚¨ãƒ©ãƒ¼ãƒ»è­¦å‘ŠæŒ‡æ‘˜æ™‚ã¯ä»–ä½œæ¥­ã‚’ä¸­æ–­
- [ ] AI åˆ¤æ–­ã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼æŒ‡ç¤ºãŒçŸ›ç›¾ã—ãŸå ´åˆã¯å¿…ãšãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å„ªå…ˆ

## ğŸ“ ä½œæ¥­å®Œäº†å‰ã®æœ€çµ‚ç¢ºèª

- [ ] ã™ã¹ã¦ã®å“è³ªã‚²ãƒ¼ãƒˆã‚’ PASSï¼ˆlint / build / testï¼‰
- [ ] æ—¥æœ¬èª UI è¦ä»¶ã‚’æº€ãŸã™ï¼ˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ»ã‚³ãƒ¡ãƒ³ãƒˆï¼‰
- [ ] å‹å®‰å…¨æ€§: any / unknown / é null ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ / äºŒæ®µã‚­ãƒ£ã‚¹ãƒˆãªã—
- [ ] ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°ï¼ˆREADME / è¨­è¨ˆè³‡æ–™ï¼‰
- [ ] å¤‰æ›´ç†ç”±ã¨å½±éŸ¿ç¯„å›²ã‚’èª¬æ˜å¯èƒ½

## ğŸ“ è¨¼è·¡æç¤ºï¼ˆå¿…é ˆï¼‰

- [ ] å®Ÿè¡Œã—ãŸã‚³ãƒãƒ³ãƒ‰ã¨çµæœãƒ­ã‚°ã€ã¾ãŸã¯ CI å®Ÿè¡Œ URL ã‚’æç¤º
`````

## File: .github/CICD_PRODUCTION_GUIDE.md
`````markdown
# CI/CD Production Deployment Guide for Cloud Run

ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§ã¯ã€Google Cloud Run ã¸ã®ãƒ‡ãƒ—ãƒ­ã‚¤ã«æœ€é©åŒ–ã•ã‚ŒãŸ CI/CD ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚

## ğŸ“‹ æ¦‚è¦

æœ¬ç•ªç’°å¢ƒã¸ã®å®‰å…¨ãªãƒ‡ãƒ—ãƒ­ã‚¤ã‚’ä¿è¨¼ã™ã‚‹ãŸã‚ã€ä»¥ä¸‹ã® Cloud Run ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ï¼š

- âœ… Dockerã‚³ãƒ³ãƒ†ãƒŠã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³
- âœ… Dockerfile ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹æ¤œè¨¼
- âœ… ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®æ¤œè¨¼
- âœ… Cloud Run äº’æ›æ€§ãƒã‚§ãƒƒã‚¯
- âœ… æœ¬ç•ªç’°å¢ƒãƒ‡ãƒ—ãƒ­ã‚¤ã®æº–å‚™å®Œäº†ãƒã‚§ãƒƒã‚¯

## ğŸ”„ CI/CD ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ãƒ•ãƒ­ãƒ¼

### 1. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³ (Security Scan)
**ç›®çš„**: ä¾å­˜é–¢ä¿‚ã¨ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®è„†å¼±æ€§æ¤œå‡º

- Trivy ã«ã‚ˆã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚¹ã‚­ãƒ£ãƒ³
- CRITICAL ãŠã‚ˆã³ HIGH ã®è„†å¼±æ€§ã§ãƒ“ãƒ«ãƒ‰å¤±æ•—
- pnpm audit ã«ã‚ˆã‚‹ä¾å­˜é–¢ä¿‚ã®ç›£æŸ»
- GitHub Security ã‚¿ãƒ–ã¸ã®çµæœã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰

**å¿…é ˆæ¡ä»¶**: 
- CRITICAL/HIGH ã®è„†å¼±æ€§ãŒå­˜åœ¨ã—ãªã„ã“ã¨
- æœ¬ç•ªä¾å­˜é–¢ä¿‚ã«é«˜ãƒ¬ãƒ™ãƒ«ã®è„†å¼±æ€§ãŒãªã„ã“ã¨

### 2. Lint & Type Check
**ç›®çš„**: ã‚³ãƒ¼ãƒ‰å“è³ªã¨ã‚¿ã‚¤ãƒ—ã‚»ãƒ¼ãƒ•ãƒ†ã‚£ã®ä¿è¨¼

- ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰: **ã‚¼ãƒ­è­¦å‘Šãƒãƒªã‚·ãƒ¼** (`--max-warnings=0`)
- ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰: Lint ãƒã‚§ãƒƒã‚¯
- TypeScript å‹ãƒã‚§ãƒƒã‚¯ (backend/frontend)

**å¤‰æ›´ç‚¹**: 
- æœ¬ç•ªç’°å¢ƒã§ã¯è­¦å‘Šã‚’è¨±å¯ã—ãªã„å³æ ¼ãªãƒãƒªã‚·ãƒ¼ã«å¤‰æ›´ï¼ˆä»¥å‰ã¯300ä»¶ã¾ã§è¨±å¯ï¼‰

### 3. ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ (Unit Tests)
**ç›®çš„**: ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã®æ¤œè¨¼

- PostgreSQL 15 ã‚µãƒ¼ãƒ“ã‚¹ã‚³ãƒ³ãƒ†ãƒŠã‚’ä½¿ç”¨
- Prisma ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®å®Ÿè¡Œ
- Backend/Frontend ã®ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ

### 4. E2Eãƒ†ã‚¹ãƒˆ (E2E Tests)
**ç›®çš„**: ã‚¨ãƒ³ãƒ‰ãƒ„ãƒ¼ã‚¨ãƒ³ãƒ‰ã®å‹•ä½œæ¤œè¨¼

- å®Œå…¨ãªçµ±åˆãƒ†ã‚¹ãƒˆç’°å¢ƒ
- Prisma Client (Node-API) ã«ã‚ˆã‚‹äº’æ›æ€§ãƒ†ã‚¹ãƒˆ

### 5. ãƒ“ãƒ«ãƒ‰ (Build)
**ç›®çš„**: æœ¬ç•ªç”¨ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆã®ä½œæˆ

- Backend: `dist/` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ç”Ÿæˆ
- Frontend: `.next/` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ç”Ÿæˆ
- ãƒ“ãƒ«ãƒ‰å‡ºåŠ›ã®æ¤œè¨¼
- ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ï¼ˆ7æ—¥é–“ä¿æŒï¼‰

### 6. Dockerfile Validation (NEW)
**ç›®çš„**: Dockerfile ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹æ¤œè¨¼

#### Hadolint ã«ã‚ˆã‚‹ãƒã‚§ãƒƒã‚¯
- Dockerfile ã®æ§‹æ–‡ã¨æ¨å¥¨äº‹é …ã®æ¤œè¨¼
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã¨ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®æœ€é©åŒ–

#### Cloud Run è¦ä»¶ã®æ¤œè¨¼
- âœ… Port 8080 ã®å…¬é–‹ï¼ˆCloud Run å¿…é ˆï¼‰
- âœ… ãƒãƒ«ãƒã‚¹ãƒ†ãƒ¼ã‚¸ãƒ“ãƒ«ãƒ‰ã®ä½¿ç”¨
- âœ… .dockerignore ã®å­˜åœ¨ç¢ºèª
- âš ï¸ érootãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ¨å¥¨

**å¤±æ•—æ¡ä»¶**:
- Port 8080 ãŒå…¬é–‹ã•ã‚Œã¦ã„ãªã„å ´åˆ

### 7. Docker Build & Container Image Scan (NEW)
**ç›®çš„**: Dockerã‚¤ãƒ¡ãƒ¼ã‚¸ã®ãƒ“ãƒ«ãƒ‰ã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ¤œè¨¼

#### ãƒ“ãƒ«ãƒ‰ãƒ—ãƒ­ã‚»ã‚¹
- Docker Buildx ã‚’ä½¿ç”¨ã—ãŸæœ€é©åŒ–ãƒ“ãƒ«ãƒ‰
- GitHub Actions ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®æ´»ç”¨
- Backend/Frontend ã‚’ä¸¦åˆ—ãƒ“ãƒ«ãƒ‰ï¼ˆãƒãƒˆãƒªãƒƒã‚¯ã‚¹æˆ¦ç•¥ï¼‰

#### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³
- Trivy ã«ã‚ˆã‚‹ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚¹ã‚­ãƒ£ãƒ³
- CRITICAL/HIGH ã®è„†å¼±æ€§ã‚’æ¤œå‡º
- GitHub Security ã‚¿ãƒ–ã¸ã®çµæœã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰

#### ã‚³ãƒ³ãƒ†ãƒŠãƒ†ã‚¹ãƒˆ
- ã‚³ãƒ³ãƒ†ãƒŠã®èµ·å‹•ãƒ†ã‚¹ãƒˆï¼ˆ2åˆ†ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼‰
- Backend: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šãªã—ã§ã®èµ·å‹•æ¤œè¨¼
- Frontend: ç’°å¢ƒå¤‰æ•°è¨­å®šã§ã®èµ·å‹•æ¤œè¨¼
- ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚µã‚¤ã‚ºã¨ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ¤œæŸ»

**å¤±æ•—æ¡ä»¶**:
- ã‚¤ãƒ¡ãƒ¼ã‚¸ãƒ“ãƒ«ãƒ‰ã®å¤±æ•—
- CRITICAL/HIGH ã®è„†å¼±æ€§æ¤œå‡º
- ã‚³ãƒ³ãƒ†ãƒŠèµ·å‹•å¤±æ•—

### 8. Cloud Run Compatibility Check (NEW)
**ç›®çš„**: Cloud Run ç’°å¢ƒã§ã®å‹•ä½œä¿è¨¼

#### ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯æ¤œè¨¼
```bash
GET /health
Expected: 200 OK
Response: {
  "success": true,
  "data": {
    "status": "ok",
    "service": "Cat Management System API",
    "timestamp": "2024-01-01T00:00:00.000Z",
    "uptime": 123.456,
    "environment": "production"
  }
}
```

#### æ¤œè¨¼é …ç›®
- âœ… `/health` ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆãŒ 200 OK ã‚’è¿”ã™
- âœ… API ã®æº–å‚™å®Œäº†ï¼ˆãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½ä»˜ãï¼‰
- âœ… Port 8080 ã§ãƒªãƒƒã‚¹ãƒ³
- âœ… ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚¿ã‚¤ãƒ  < 1ç§’ï¼ˆã‚³ãƒ¼ãƒ«ãƒ‰ã‚¹ã‚¿ãƒ¼ãƒˆå¯¾å¿œï¼‰
- âœ… CORS è¨­å®šã®æ¤œè¨¼
- âœ… ç’°å¢ƒå¤‰æ•°ã®é©åˆ‡ãªå‡¦ç†

#### å®Ÿè¡Œç’°å¢ƒ
- PostgreSQL 15 ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹
- æœ¬ç•ªç’°å¢ƒè¨­å®šã§ã®å®Ÿè¡Œ
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ

**å¤±æ•—æ¡ä»¶**:
- ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ãŒå¤±æ•—
- API ãŒ30å›ã®ãƒªãƒˆãƒ©ã‚¤å¾Œã‚‚æº–å‚™å®Œäº†ã—ãªã„
- Port 8080 ã§ãƒªãƒƒã‚¹ãƒ³ã—ã¦ã„ãªã„

### 9. Production Deployment Readiness (NEW)
**ç›®çš„**: æœ¬ç•ªãƒ‡ãƒ—ãƒ­ã‚¤ã®æœ€çµ‚ç¢ºèª

#### æ¤œè¨¼é …ç›®
- âœ… `cloudbuild.yaml` ã®å­˜åœ¨ç¢ºèª
- âœ… Cloud Build è¨­å®šã®å¦¥å½“æ€§æ¤œè¨¼
- âœ… ã™ã¹ã¦ã®å‰æ®µéšãƒã‚§ãƒƒã‚¯ã®æˆåŠŸç¢ºèª

## ğŸš€ Cloud Run ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

### 1. ã‚³ãƒ³ãƒ†ãƒŠã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
- **è„†å¼±æ€§ã‚¹ã‚­ãƒ£ãƒ³**: ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã¨Dockerã‚¤ãƒ¡ãƒ¼ã‚¸ã®ä¸¡æ–¹
- **è‡ªå‹•ãƒ–ãƒ­ãƒƒã‚¯**: CRITICAL/HIGH ã®è„†å¼±æ€§æ¤œå‡ºæ™‚
- **ç¶™ç¶šçš„ç›£è¦–**: GitHub Security ã‚¿ãƒ–ã§ã®è¿½è·¡

### 2. Dockerfile æœ€é©åŒ–
```dockerfile
# âœ… æ¨å¥¨: ãƒãƒ«ãƒã‚¹ãƒ†ãƒ¼ã‚¸ãƒ“ãƒ«ãƒ‰
FROM node:20-alpine AS base
FROM base AS deps
FROM base AS build
FROM node:20-alpine AS production

# âœ… æ¨å¥¨: Port 8080 (Cloud Run ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)
EXPOSE 8080

# âš ï¸ æ¨å¥¨: érootãƒ¦ãƒ¼ã‚¶ãƒ¼
USER node

# âœ… æ¨å¥¨: æœ€å°é™ã®ãƒ™ãƒ¼ã‚¹ã‚¤ãƒ¡ãƒ¼ã‚¸
FROM node:20-alpine
```

### 3. ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
Cloud Run ã¯ä»¥ä¸‹ã®ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã‚¿ã‚¤ãƒ—ã‚’ã‚µãƒãƒ¼ãƒˆï¼š

- **Startup Probe**: ã‚³ãƒ³ãƒ†ãƒŠã®åˆæœŸåŒ–å®Œäº†ã‚’ç¢ºèª
- **Liveness Probe**: ç¶™ç¶šçš„ãªç¨¼åƒçŠ¶æ…‹ã‚’ç›£è¦–

```typescript
// Backend: /health ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
@Get('health')
check() {
  return {
    success: true,
    data: {
      status: 'ok',
      timestamp: new Date().toISOString(),
      uptime: process.uptime()
    }
  };
}
```

### 4. èµ·å‹•ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹
- **ã‚³ãƒ¼ãƒ«ãƒ‰ã‚¹ã‚¿ãƒ¼ãƒˆæœ€é©åŒ–**: ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚¿ã‚¤ãƒ  < 1ç§’
- **èµ·å‹•ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ**: ã‚³ãƒ³ãƒ†ãƒŠèµ·å‹• < 2åˆ†
- **ãƒªã‚½ãƒ¼ã‚¹åŠ¹ç‡**: é©åˆ‡ãªãƒ¡ãƒ¢ãƒªã¨ CPU è¨­å®š

### 5. ç’°å¢ƒè¨­å®š
```yaml
# Cloud Run æ¨å¥¨è¨­å®š (cloudbuild.yaml å‚ç…§)
--port=8080                    # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒãƒ¼ãƒˆ
--memory=512Mi                 # ãƒ¡ãƒ¢ãƒªåˆ¶é™
--cpu=1                        # CPUåˆ¶é™
--max-instances=3              # æœ€å¤§ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ•°
--min-instances=0              # æœ€å°ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ•°ï¼ˆã‚³ã‚¹ãƒˆæœ€é©åŒ–ï¼‰
--timeout=300                  # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆç§’ï¼‰
--set-secrets=...              # Secret Manager çµ±åˆ
--add-cloudsql-instances=...   # Cloud SQL çµ±åˆ
```

## ğŸ“Š ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œæ™‚é–“ã®ç›®å®‰

| ã‚¸ãƒ§ãƒ– | å®Ÿè¡Œæ™‚é–“ | ä¸¦åˆ—å®Ÿè¡Œ |
|-------|---------|---------|
| Security Scan | 3-5åˆ† | - |
| Lint & Type Check | 2-3åˆ† | - |
| Unit Tests | 3-4åˆ† | - |
| E2E Tests | 4-6åˆ† | - |
| Build | 5-7åˆ† | - |
| Dockerfile Validation | 1-2åˆ† | - |
| Docker Build & Scan | 5-10åˆ† | âœ… (2ä¸¦åˆ—) |
| Cloud Run Validation | 3-5åˆ† | - |
| Deployment Readiness | 1åˆ†æœªæº€ | - |

**åˆè¨ˆå®Ÿè¡Œæ™‚é–“**: ç´„ 30-40åˆ†

## âŒ ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å¤±æ•—ã®ä¸»ãªåŸå› 

### 1. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³å¤±æ•—
```
âŒ Critical or high severity vulnerabilities detected!
```
**å¯¾å‡¦æ³•**:
- ä¾å­˜é–¢ä¿‚ã‚’æœ€æ–°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆ
- `pnpm update` ã§ä¿®æ­£ã•ã‚ŒãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
- ä¸€æ™‚çš„ãªé™¤å¤–ãŒå¿…è¦ãªå ´åˆã¯ `.trivyignore` ã‚’ä½¿ç”¨

### 2. Lint è­¦å‘Š
```
âŒ Lint failed with warnings (max-warnings=0)
```
**å¯¾å‡¦æ³•**:
- ã™ã¹ã¦ã® lint è­¦å‘Šã‚’ä¿®æ­£
- ESLint ã® `--fix` ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§è‡ªå‹•ä¿®æ­£
- å¿…è¦ã«å¿œã˜ã¦ ESLint ãƒ«ãƒ¼ãƒ«ã‚’èª¿æ•´

### 3. Dockerfile æ¤œè¨¼å¤±æ•—
```
âŒ Backend: Port 8080 not exposed
```
**å¯¾å‡¦æ³•**:
- Dockerfile ã« `EXPOSE 8080` ã‚’è¿½åŠ 
- Cloud Run ã¯ Port 8080 ã‚’å¿…é ˆã¨ã—ã¾ã™

### 4. Docker ã‚¤ãƒ¡ãƒ¼ã‚¸è„†å¼±æ€§
```
âŒ Critical or high vulnerabilities found in backend image!
```
**å¯¾å‡¦æ³•**:
- ãƒ™ãƒ¼ã‚¹ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’æœ€æ–°ç‰ˆã«ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆ
- `node:20-alpine` ãªã©è»½é‡ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’ä½¿ç”¨
- ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢

### 5. ã‚³ãƒ³ãƒ†ãƒŠèµ·å‹•å¤±æ•—
```
âŒ Container failed to start
```
**å¯¾å‡¦æ³•**:
- Docker ãƒ­ã‚°ã‚’ç¢ºèª: `docker logs test-backend`
- ç’°å¢ƒå¤‰æ•°ãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šè¨­å®šã‚’ç¢ºèª

### 6. ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯å¤±æ•—
```
âŒ Health check endpoint failed with status: 500
```
**å¯¾å‡¦æ³•**:
- `/health` ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®å®Ÿè£…ã‚’ç¢ºèª
- ä¾å­˜ã‚µãƒ¼ãƒ“ã‚¹ã®èµ·å‹•ã‚’ç¢ºèª
- ãƒ­ã‚°ã§ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç¢ºèª

## ğŸ”§ ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### GitHub Actions ãƒ­ã‚°ã®ç¢ºèª
1. GitHub ãƒªãƒã‚¸ãƒˆãƒªã® **Actions** ã‚¿ãƒ–ã‚’é–‹ã
2. å¤±æ•—ã—ãŸãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’ã‚¯ãƒªãƒƒã‚¯
3. å¤±æ•—ã—ãŸã‚¸ãƒ§ãƒ–ã®è©³ç´°ãƒ­ã‚°ã‚’ç¢ºèª

### ãƒ­ãƒ¼ã‚«ãƒ«ã§ã®æ¤œè¨¼

#### Dockerfile ã®ãƒ“ãƒ«ãƒ‰ãƒ†ã‚¹ãƒˆ
```bash
# Backend
docker build -f Dockerfile.backend -t mycats-backend:test .

# Frontend
docker build -f Dockerfile.frontend -t mycats-frontend:test .
```

#### ã‚³ãƒ³ãƒ†ãƒŠã®èµ·å‹•ãƒ†ã‚¹ãƒˆ
```bash
# Backend
docker run -d --name test-backend \
  -e DATABASE_URL="postgresql://user:pass@localhost:5432/db" \
  -e JWT_SECRET="test-secret-minimum-32-chars-long" \
  -e NODE_ENV="production" \
  -e PORT=8080 \
  -p 8080:8080 \
  mycats-backend:test

# ãƒ­ã‚°ç¢ºèª
docker logs test-backend

# åœæ­¢
docker stop test-backend
docker rm test-backend
```

#### ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã®ãƒ†ã‚¹ãƒˆ
```bash
curl http://localhost:8080/health
```

#### Hadolint ã«ã‚ˆã‚‹ãƒã‚§ãƒƒã‚¯
```bash
# Hadolint ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
wget -O hadolint https://github.com/hadolint/hadolint/releases/download/v2.12.0/hadolint-Linux-x86_64
chmod +x hadolint

# ãƒã‚§ãƒƒã‚¯å®Ÿè¡Œ
./hadolint Dockerfile.backend
./hadolint Dockerfile.frontend
```

## ğŸ“š å‚è€ƒãƒªãƒ³ã‚¯

### Google Cloud å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
- [Cloud Run ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹](https://cloud.google.com/run/docs/best-practices)
- [Cloud Run ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯](https://cloud.google.com/run/docs/configuring/healthchecks)
- [Cloud Build CI/CD](https://cloud.google.com/build/docs/ci-cd)
- [Artifact Registry](https://cloud.google.com/artifact-registry/docs)
- [Secret Manager](https://cloud.google.com/secret-manager/docs)

### Docker ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹
- [Docker å…¬å¼ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹](https://docs.docker.com/build/building/best-practices/)
- [Hadolint - Dockerfile Linter](https://github.com/hadolint/hadolint)
- [Trivy - è„†å¼±æ€§ã‚¹ã‚­ãƒ£ãƒŠãƒ¼](https://github.com/aquasecurity/trivy)

### CI/CD ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹
- [GitHub Actions ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://docs.github.com/en/actions)
- [Google Cloud CI/CD ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹](https://cloud.google.com/architecture/devops/devops-tech-ci-cd)

## ğŸ¯ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—

1. **åˆå›ãƒ‡ãƒ—ãƒ­ã‚¤**
   - cloudbuild.yaml ã®è¨­å®šå€¤ã‚’ç’°å¢ƒã«åˆã‚ã›ã¦èª¿æ•´
   - GCP ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¨ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã‚’è¨­å®š
   - Cloud Build ãƒˆãƒªã‚¬ãƒ¼ã‚’è¨­å®š

2. **ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°è¨­å®š**
   - Cloud Monitoring ã§ã‚¢ãƒ©ãƒ¼ãƒˆè¨­å®š
   - Cloud Logging ã§ãƒ­ã‚°ç›£è¦–
   - ã‚¨ãƒ©ãƒ¼ç‡ã¨ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ã®è¿½è·¡

3. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–**
   - ã‚³ãƒ¼ãƒ«ãƒ‰ã‚¹ã‚¿ãƒ¼ãƒˆæ™‚é–“ã®æ¸¬å®š
   - ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚µã‚¤ã‚ºã®æœ€é©åŒ–
   - ãƒªã‚½ãƒ¼ã‚¹ä½¿ç”¨é‡ã®èª¿æ•´

4. **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–**
   - å®šæœŸçš„ãªä¾å­˜é–¢ä¿‚ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆ
   - ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³ã®è‡ªå‹•åŒ–
   - Secret ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³

---

**æœ€çµ‚æ›´æ–°**: 2024-11-13
**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 1.0.0
`````

## File: .github/COPILOT_INSTRUCTIONS_README.md
`````markdown
# GitHub Copilot Instructions æ§‹é€ ã‚¬ã‚¤ãƒ‰

ã“ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ã¯ã€GitHub Copilot Coding Agent ã®å‹•ä½œã‚’åˆ¶å¾¡ã™ã‚‹æŒ‡ç¤ºãƒ•ã‚¡ã‚¤ãƒ«ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚

## ãƒ•ã‚¡ã‚¤ãƒ«æ§‹é€ 

```
.github/
â”œâ”€â”€ copilot-instructions.md          # ãƒ¡ã‚¤ãƒ³æŒ‡ç¤ºãƒ•ã‚¡ã‚¤ãƒ«
â”œâ”€â”€ agents/                           # å°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå®šç¾©
â”‚   â”œâ”€â”€ backend-agent.md             # NestJS/Prisma å°‚é–€
â”‚   â”œâ”€â”€ frontend-agent.md            # Next.js/React å°‚é–€
â”‚   â”œâ”€â”€ docs-agent.md                # ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆå°‚é–€
â”‚   â””â”€â”€ test-agent.md                # ãƒ†ã‚¹ãƒˆå°‚é–€
â””â”€â”€ instructions/                     # ãƒ‘ã‚¹å›ºæœ‰ã®æŒ‡ç¤º
    â”œâ”€â”€ backend.instructions.md      # backend/** ç”¨
    â”œâ”€â”€ frontend.instructions.md     # frontend/** ç”¨
    â””â”€â”€ docs.instructions.md         # **/*.md ç”¨
```

## ä¸»è¦ãƒ•ã‚¡ã‚¤ãƒ«

### copilot-instructions.md
ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“ã®å…±é€šæŒ‡ç¤ºã€‚ã™ã¹ã¦ã® AI ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒæœ€åˆã«å‚ç…§ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã€‚

**å«ã¾ã‚Œã‚‹å†…å®¹:**
- æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯æ¦‚è¦
- è¨€èªè¨­å®šï¼ˆæ—¥æœ¬èªå„ªå…ˆï¼‰
- å‹å®‰å…¨ãƒãƒªã‚·ãƒ¼
- ä½œæ¥­ãƒ•ãƒ­ãƒ¼
- å“è³ªã‚²ãƒ¼ãƒˆ

### agents/
ã‚¿ã‚¹ã‚¯ã«ç‰¹åŒ–ã—ãŸå°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå®šç¾©ã€‚

#### backend-agent.md
- **å¯¾è±¡**: NestJSã€Prismaã€PostgreSQL
- **å°‚é–€é ˜åŸŸ**: API è¨­è¨ˆã€ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã€DB ã‚¹ã‚­ãƒ¼ãƒ
- **ä¸»è¦åŸå‰‡**: ãƒ¬ã‚¤ãƒ¤ãƒªãƒ³ã‚°ã€DTO ãƒ‘ã‚¿ãƒ¼ãƒ³ã€å‹å®‰å…¨

#### frontend-agent.md
- **å¯¾è±¡**: Next.jsã€Reactã€Mantine UI
- **å°‚é–€é ˜åŸŸ**: UI/UXã€Server Componentsã€çŠ¶æ…‹ç®¡ç†
- **ä¸»è¦åŸå‰‡**: Server Component ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆã€ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£

#### docs-agent.md
- **å¯¾è±¡**: ã™ã¹ã¦ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
- **å°‚é–€é ˜åŸŸ**: READMEã€ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚¬ã‚¤ãƒ‰ã€æŠ€è¡“è³‡æ–™
- **å¢ƒç•Œ**: ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã¯å¤‰æ›´ã—ãªã„

#### test-agent.md
- **å¯¾è±¡**: ãƒ¦ãƒ‹ãƒƒãƒˆã€çµ±åˆã€E2E ãƒ†ã‚¹ãƒˆ
- **å°‚é–€é ˜åŸŸ**: Jestã€Supertestã€Testing Library
- **ç›®æ¨™**: ã‚«ãƒãƒ¬ãƒƒã‚¸ 80%ä»¥ä¸Š

### instructions/
ãƒ‘ã‚¹å›ºæœ‰ã®ãƒ«ãƒ¼ãƒ«ã‚’å®šç¾©ã€‚ç‰¹å®šã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ä½œæ¥­ã™ã‚‹éš›ã«è‡ªå‹•é©ç”¨ã€‚

#### backend.instructions.md
```yaml
applyTo: "backend/**"
```
ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰å°‚ç”¨ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã€å‹å®‰å…¨ã€Prisma ãƒ«ãƒ¼ãƒ«ã€‚

#### frontend.instructions.md
```yaml
applyTo: "frontend/**"
```
ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰å°‚ç”¨ã® React/Next.jsã€UI/UXã€ã‚¹ã‚¿ã‚¤ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ«ã€‚

#### docs.instructions.md
```yaml
applyTo: "**.md"
excludeAgent: "coding-agent"
```
ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆå°‚ç”¨ã€‚ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’é™¤å¤–ã—ã€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ã¿é©ç”¨ã€‚

## ä½¿ã„æ–¹

### Copilot ã¸ã®æŒ‡ç¤ºä¾‹

```markdown
@backend-agent
çŒ«ã®æ–°ã—ã„ API ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚
GET /api/v1/cats/:id/relatives ã§è¦ªå­é–¢ä¿‚ã‚’å–å¾—ã—ã¾ã™ã€‚
```

```markdown
@frontend-agent
çŒ«ä¸€è¦§ãƒšãƒ¼ã‚¸ã«ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼æ©Ÿèƒ½ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚
å“ç¨®ã€è‰²ã€å¹´é½¢ã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚
```

```markdown
@docs-agent
æ–°ã—ã„ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æ‰‹é †ã‚’ SETUP_GUIDE.md ã«è¿½åŠ ã—ã¦ãã ã•ã„ã€‚
Redis ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã¨è¨­å®šã«ã¤ã„ã¦è¨˜è¿°ã—ã¾ã™ã€‚
```

```markdown
@test-agent
CatsService ã®æ–°ã—ã„ãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ†ã‚¹ãƒˆã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚
æ­£å¸¸ç³»ã¨ç•°å¸¸ç³»ã®ä¸¡æ–¹ã‚’ã‚«ãƒãƒ¼ã—ã¾ã™ã€‚
```

### ãƒ‘ã‚¹å›ºæœ‰ã®è‡ªå‹•é©ç”¨

`backend/` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ä½œæ¥­ã™ã‚‹ã¨ã€è‡ªå‹•çš„ã« `backend.instructions.md` ã®ãƒ«ãƒ¼ãƒ«ãŒé©ç”¨ã•ã‚Œã¾ã™ã€‚

```typescript
// backend/src/cats/cats.service.ts
// ã“ã®å ´æ‰€ã§ã¯ backend.instructions.md ã®ãƒ«ãƒ¼ãƒ«ãŒé©ç”¨ã•ã‚Œã‚‹
// - Controller ã§ç›´æ¥ Prisma ã‚’å‘¼ã°ãªã„
// - any/unknown ç¦æ­¢
// - æ—¥æœ¬èªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
```

## ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

### 1. ã‚¿ã‚¹ã‚¯ã‚’æ˜ç¢ºã«å®šç¾©
```markdown
æ‚ªã„ä¾‹: çŒ«æ©Ÿèƒ½ã‚’æ”¹å–„ã—ã¦
è‰¯ã„ä¾‹: çŒ«ä¸€è¦§ãƒšãƒ¼ã‚¸ã«å“ç¨®ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ï¼ˆãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ï¼‰ã‚’è¿½åŠ ã—ã€
       é¸æŠæ™‚ã« API ã‚’å‘¼ã³å‡ºã—ã¦ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã•ã‚ŒãŸçµæœã‚’è¡¨ç¤º
```

### 2. é©åˆ‡ãªã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’é¸æŠ
- ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ API â†’ `@backend-agent`
- ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ UI â†’ `@frontend-agent`
- ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ â†’ `@docs-agent`
- ãƒ†ã‚¹ãƒˆè¿½åŠ  â†’ `@test-agent`

### 3. å¢ƒç•Œã‚’æ˜ç¢ºã«
å„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯ç‰¹å®šã®é ˜åŸŸã®ã¿ã‚’å¤‰æ›´ã—ã¾ã™ï¼š
- Backend Agent: `backend/src/**`
- Frontend Agent: `frontend/src/**`
- Documentation Agent: `**/*.md` ã®ã¿
- Test Agent: `**/*.spec.ts`, `**/*.test.tsx`

### 4. å“è³ªã‚²ãƒ¼ãƒˆã‚’å¿…ãšé€šã™
å¤‰æ›´å¾Œã¯å¿…ãšå®Ÿè¡Œï¼š
```bash
pnpm lint
pnpm backend:build
pnpm frontend:build
pnpm test:e2e
```

## æ›´æ–°ã‚¬ã‚¤ãƒ‰

### ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå®šç¾©ã‚’æ›´æ–°ã™ã‚‹å ´åˆ
1. è©²å½“ã™ã‚‹ `agents/*.md` ã‚’ç·¨é›†
2. YAML ãƒ•ãƒ­ãƒ³ãƒˆãƒã‚¿ãƒ¼ï¼ˆname, description, commands, boundariesï¼‰ã‚’æ›´æ–°
3. ã‚³ãƒ¼ãƒ‰ä¾‹ã‚’è¿½åŠ ãƒ»æ›´æ–°
4. å“è³ªãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã‚’è¦‹ç›´ã—

### ãƒ‘ã‚¹å›ºæœ‰æŒ‡ç¤ºã‚’æ›´æ–°ã™ã‚‹å ´åˆ
1. è©²å½“ã™ã‚‹ `instructions/*.instructions.md` ã‚’ç·¨é›†
2. YAML ãƒ•ãƒ­ãƒ³ãƒˆãƒã‚¿ãƒ¼ï¼ˆapplyTo, excludeAgentï¼‰ã‚’ç¢ºèª
3. å¿…é ˆãƒ«ãƒ¼ãƒ«ã€ã‚³ãƒãƒ³ãƒ‰ã€ã‚³ãƒ¼ãƒ‰ä¾‹ã‚’æ›´æ–°
4. å¤‰æ›´ã—ã¦ã¯ã„ã‘ãªã„ãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆã‚’è¦‹ç›´ã—

### ãƒ¡ã‚¤ãƒ³æŒ‡ç¤ºã‚’æ›´æ–°ã™ã‚‹å ´åˆ
1. `copilot-instructions.md` ã‚’ç·¨é›†
2. å°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ»ãƒ‘ã‚¹å›ºæœ‰æŒ‡ç¤ºã¨ã®æ•´åˆæ€§ã‚’ç¢ºèª
3. ãƒ«ãƒ¼ãƒˆ `AGENTS.md` ã¨ã®åŒæœŸã‚’ç¢ºèª

## å‚è€ƒè³‡æ–™

- [GitHub Copilot Coding Agent ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹](https://docs.github.com/en/copilot/tutorials/coding-agent/get-the-best-results)
- [ã‚«ã‚¹ã‚¿ãƒ æŒ‡ç¤ºã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://github.blog/changelog/2025-07-23-github-copilot-coding-agent-now-supports-instructions-md-custom-instructions/)
- [åŠ¹æœçš„ãª agents.md ã®æ›¸ãæ–¹](https://github.blog/ai-and-ml/github-copilot/how-to-write-a-great-agents-md-lessons-from-over-2500-repositories/)

## ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### Copilot ãŒæŒ‡ç¤ºã‚’èªè­˜ã—ãªã„
- `copilot-instructions.md` ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ç¢ºèª
- YAML ãƒ•ãƒ­ãƒ³ãƒˆãƒã‚¿ãƒ¼ã®æ§‹æ–‡ã‚¨ãƒ©ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯
- ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ãŒæ­£ã—ã„ã‹ç¢ºèª

### ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒé©åˆ‡ã«å‹•ä½œã—ãªã„
- ã‚¿ã‚¹ã‚¯ãŒæ˜ç¢ºã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
- é©åˆ‡ãªã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’æŒ‡å®šã—ã¦ã„ã‚‹ã‹ç¢ºèª
- å¢ƒç•Œã‚’è¶…ãˆãŸä½œæ¥­ã‚’ä¾é ¼ã—ã¦ã„ãªã„ã‹ç¢ºèª

### ãƒ‘ã‚¹å›ºæœ‰æŒ‡ç¤ºãŒé©ç”¨ã•ã‚Œãªã„
- `applyTo` ã®ãƒ‘ã‚¹ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç¢ºèª
- ã‚°ãƒ­ãƒ–ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒæ­£ã—ã„ã‹ç¢ºèª
- `excludeAgent` ã®è¨­å®šã‚’ç¢ºèª

## ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯

æŒ‡ç¤ºãƒ•ã‚¡ã‚¤ãƒ«ã®æ”¹å–„ææ¡ˆã¯ Issue ã¾ãŸã¯ PR ã§ãŠé¡˜ã„ã—ã¾ã™ã€‚
`````

## File: .github/copilot-instructions.md
`````markdown
# mycats-pro Copilot Instructions

## ã‚¬ã‚¤ãƒ‰æ¦‚è¦

- æœ¬æ›¸ã¯ãƒ«ãƒ¼ãƒˆ `AGENTS.md` ã¨ `GEMINI.md` ã®å†…å®¹ã‚’çµ±åˆã—ãŸã€mycats-pro å°‚ç”¨ã® AI ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå‘ã‘åŒ…æ‹¬ã‚¬ã‚¤ãƒ‰ã§ã™ã€‚Copilot / Gemini / ãã®ã»ã‹ã® LLM ã¯æœ¬ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å”¯ä¸€ã®å‚ç…§ã¨ã—ã¦åˆ©ç”¨ã—ã¦ãã ã•ã„ã€‚
- å…ƒã® `AGENTS.md` ãŒå®šç¾©ã™ã‚‹ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¦ç´„ãŒä¾ç„¶ã¨ã—ã¦å”¯ä¸€ã®ã‚½ãƒ¼ã‚¹ã§ã™ã€‚æœ¬æ›¸ã¯é‡è¤‡ã—ã¦ã„ãŸæŒ‡ç¤ºã‚’æ•´ç†ã—ã¤ã¤ã€Gemini å›ºæœ‰ã®é‹ç”¨ãƒ’ãƒ³ãƒˆã‚‚åŒã˜å ´æ‰€ã§ç¢ºèªã§ãã‚‹ã‚ˆã†å†ç·¨ã—ã¦ã„ã¾ã™ã€‚
- å‚ç…§ã—ãŸå…¬å¼æƒ…å ±ï¼š
  - æœ€çµ‚æ›´æ–° 2025-11-18 UTC: [Gemini API ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://ai.google.dev/gemini-api/docs) â€” ãƒ¢ãƒ‡ãƒ«ä¸€è¦§ã€åˆ©ç”¨å¯èƒ½ãªãƒ„ãƒ¼ãƒ«ã€ãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒãƒªã‚·ãƒ¼ã€‚
  - [ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆè¨­è¨ˆæˆ¦ç•¥](https://ai.google.dev/gemini-api/docs/prompting-strategies) â€” æŒ‡ç¤ºã®æ§‹é€ åŒ–ã€å°‘æ•°ã‚·ãƒ§ãƒƒãƒˆä¾‹ã€é•·æ–‡ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆåˆ¶å¾¡ã€Gemini 3 ã§ã®æ¨å¥¨æ¸©åº¦è¨­å®šãªã©ã€‚
  - æœ€çµ‚æ›´æ–° 2025-11-26 UTC: [GitHub Copilot Coding Agent Best Practices](https://docs.github.com/en/copilot/tutorials/coding-agent/get-the-best-results) â€” ã‚¿ã‚¹ã‚¯è¨­è¨ˆã€ã‚«ã‚¹ã‚¿ãƒ æŒ‡ç¤ºã€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæ´»ç”¨ã€‚
- å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚ˆã‚Šæ–°ã—ã„æŒ‡é‡ã‚’é©ç”¨ã™ã‚‹å ´åˆã¯ã€æ ¹æ‹  URL ã¨æœ€çµ‚æ›´æ–°æ—¥ã‚’æœ¬æ›¸ã«è¿½è¨˜ã—ã€`AGENTS.md` / `GEMINI.md` ã¨å†…å®¹ã‚’åŒæœŸã•ã›ã¦ãã ã•ã„ã€‚

## å°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ

ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ã€ã‚¿ã‚¹ã‚¯ã«å¿œã˜ã¦å°‚é–€åŒ–ã•ã‚ŒãŸã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’æ´»ç”¨ã§ãã¾ã™ï¼š

- **Backend Agent** (`.github/agents/backend-agent.md`) - NestJS + Prisma + PostgreSQL ã®å°‚é–€å®¶
- **Frontend Agent** (`.github/agents/frontend-agent.md`) - Next.js + React + Mantine ã®å°‚é–€å®¶
- **Documentation Agent** (`.github/agents/docs-agent.md`) - ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆä½œæˆãƒ»ä¿å®ˆã®å°‚é–€å®¶
- **Test Agent** (`.github/agents/test-agent.md`) - ãƒ†ã‚¹ãƒˆä½œæˆãƒ»ã‚«ãƒãƒ¬ãƒƒã‚¸å‘ä¸Šã®å°‚é–€å®¶

å„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯ç‰¹å®šã®ãƒ‰ãƒ¡ã‚¤ãƒ³ã«ç‰¹åŒ–ã—ã¦ãŠã‚Šã€ã‚ˆã‚Šçš„ç¢ºãªã‚µãƒãƒ¼ãƒˆã‚’æä¾›ã—ã¾ã™ã€‚ã‚¿ã‚¹ã‚¯ã«å¿œã˜ã¦é©åˆ‡ãªã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

## ãƒ‘ã‚¹å›ºæœ‰ã®æŒ‡ç¤º

ä»¥ä¸‹ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ã¯å°‚ç”¨ã®æŒ‡ç¤ºãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Šã¾ã™ï¼š

- `backend/**` â†’ `.github/instructions/backend.instructions.md`
- `frontend/**` â†’ `.github/instructions/frontend.instructions.md`
- `**/*.md` â†’ `.github/instructions/docs.instructions.md`

## Gemini å›ºæœ‰ã®é‹ç”¨ãƒ’ãƒ³ãƒˆ

### 1-1. ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã¨ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®æ§‹é€ 
- `role/context/task/output` ãªã© **æ˜ç¤ºçš„ãªã‚»ã‚¯ã‚·ãƒ§ãƒ³** ã‚’ç”¨ã„ã¦ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ã‚¿ã‚°ä»˜ã‘ã—ã¾ã™ã€‚ä¾‹: `<context>â€¦</context>`, `## Instructions`ã€‚
- é‡è¦ãªåˆ¶ç´„ãƒ»æ—¥æœ¬èª UI è¦ä»¶ãƒ»å‹å®‰å…¨ãƒãƒªã‚·ãƒ¼ã¯ã‚·ã‚¹ãƒ†ãƒ æŒ‡ç¤ºï¼ˆæœ€ä¸Šä½ãƒ–ãƒ­ãƒƒã‚¯ï¼‰ã«ã¾ã¨ã‚ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ã®å¾Œã§ã¯ä¸Šæ›¸ãã—ãªã„ã€‚
- å°‘æ•°ã‚·ãƒ§ãƒƒãƒˆï¼ˆfew-shotï¼‰ä¾‹ã‚’ 1ã€œ3 ä»¶æ·»ãˆã€æˆåŠŸãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’å›ºå®šã€‚Gemini ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§ã¯ä¸€è²«ã—ãŸä¾‹æ§‹é€ ãŒæ¨å¥¨ã•ã‚Œã¦ã„ã¾ã™ã€‚
- é•·æ–‡ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’æ¸¡ã™ã¨ãã¯ `[context] â†’ [æŒ‡ç¤º]` ã®é †ã«é…ç½®ã—ã€ã€Œä¸Šè¨˜ã®æƒ…å ±ã«åŸºã¥ã„ã¦â€¦ã€ã®ã‚ˆã†ãªã‚¢ãƒ³ã‚«ãƒ¼ãƒ•ãƒ¬ãƒ¼ã‚ºã‚’æŒ¿å…¥ã€‚

### 1-2. ãƒ¢ãƒ‡ãƒ«é¸å®šã¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
- ã‚³ãƒ¼ãƒ‰ç”Ÿæˆã‚„å³å¯†ãªæ¨è«–ã¯ `gemini-2.5-pro` ã¾ãŸã¯ `gemini-3.0-pro`ï¼ˆåˆ©ç”¨å¯èƒ½ãªå ´åˆï¼‰ã‚’æ—¢å®šã¨ã—ã€è»½é‡å¿œç­”ã¯ `gemini-2.5-flash` ã‚’æ¤œè¨ã€‚
- Gemini 3 ç³»ã§ã¯æ¸©åº¦ `1.0` ã‚’ä¿ã¤ã“ã¨ãŒå…¬å¼ã§æ¨å¥¨ã•ã‚Œã¦ã„ã¾ã™ã€‚ç¢ºå®šæ€§ã‚’ä¸Šã’ãŸã„å ´åˆã¯ `topK=1, topP<=0.6` ã‚’å„ªå…ˆçš„ã«èª¿æ•´ã—ã€æ¸©åº¦æ“ä½œã¯æœ€çµ‚æ‰‹æ®µã¨ã™ã‚‹ã€‚
- `max_output_tokens` ã¯æœŸå¾…ã™ã‚‹ãƒ¬ã‚¹ãƒãƒ³ã‚¹é•·ã«å¿œã˜ã¦æ˜ç¤ºè¨­å®šï¼ˆä¾‹: è¨­è¨ˆæ›¸è¦ç´„ã¯ 1024ã€ãƒ­ã‚°è¦ç´„ã¯ 512ï¼‰ã€‚

### 1-3. ã‚»ãƒ¼ãƒ•ãƒ†ã‚£ã¨ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
- å…¬å¼ Usage Policies ã‚’æº€ãŸã™ã‚ˆã†ã€é•åãƒªã‚¹ã‚¯ã®ã‚ã‚‹å…¥åŠ›ã‚’æ¤œçŸ¥ã—ãŸã‚‰ PR/Issue ã‚’å‚ç…§ã™ã‚‹æŒ‡ç¤ºã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã€‚Gemini ãŒå®‰å…¨ãƒ•ã‚£ãƒ«ã‚¿ã§åœæ­¢ã—ãŸå ´åˆã¯æ¸©åº¦ã‚’ä¸Šã’ã‚‹å‰ã«å…¥åŠ›ã‚’å†æ§‹æˆã€‚
- ãƒ•ã‚¡ã‚¤ãƒ«ï¼URL å‚ç…§ã‚’è¡Œã†ã¨ãã¯ `files API` ã‚„ `URL context` ã®åˆ©ç”¨ã‚’æ˜ç¤ºã—ã€ç¤¾å†…æ©Ÿå¯†ã¯ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‘ã‚¹çµŒç”±ã§æ‰±ã†ã€‚

### 1-4. ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ¤œè¨¼
- å…¬å¼ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã«å€£ã„ã€`Plan â†’ Execute â†’ Validate â†’ Format` ã® 4 ã‚¹ãƒ†ãƒƒãƒ—ã§æ€è€ƒã‚’æ•´ç†ã€‚æœ€çµ‚ãƒ¬ã‚¹ãƒãƒ³ã‚¹å‰ã«ã€Œä¾é ¼ã®æ„å›³ã€ã€Œæ—¥æœ¬èª UIã€ã€Œå“è³ªã‚²ãƒ¼ãƒˆã€ã® 3 ç‚¹ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã†ã€‚
- å‡ºåŠ›å½¢å¼ï¼ˆMarkdown è¦‹å‡ºã—ã€è¡¨ã€JSON ç­‰ï¼‰ã¯ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã§æŒ‡å®šã—ã€`stop_sequences` ãŒå¿…è¦ãªå ´åˆã¯ PRD é€šã‚Šã«è¨­å®šã€‚

---

## 0. ã‚¯ã‚¤ãƒƒã‚¯ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹

### 0-1. ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— & èµ·å‹•

- `pnpm install` / `pnpm install:all`: ãƒ«ãƒ¼ãƒˆã§ä¾å­˜é–¢ä¿‚ã‚’åŒæœŸã€‚Node.js 20.x + pnpm 9.x ã‚’ä½¿ç”¨ã€‚
- `pnpm setup`: `scripts/setup-dev.sh` ã‚’å‘¼ã³å‡ºã—ã€åˆå›ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã¨ç’°å¢ƒå¤‰æ•°ãƒã‚§ãƒƒã‚¯ã‚’å®Ÿæ–½ã€‚
- `pnpm dev` / `pnpm dev:stable`: `backend:dev` (PORT=3004) â†’ `frontend:dev` (PORT=3000) â†’ `prisma:sync` ã®é †ã§ç«‹ã¡ä¸Šã’ã€‚åœæ­¢ã¯ `pnpm dev:stop`ã€‚
- DB æ“ä½œ: `pnpm db:migrate`, `pnpm db:seed`, `pnpm prisma:studio`ã€‚PostgreSQL 15+ ã‚’å‰æã€‚

### 0-2. ãƒ†ã‚¹ãƒˆ / é™çš„è§£æ

- ãƒ«ãƒ¼ãƒˆå“è³ªã‚²ãƒ¼ãƒˆ: `pnpm lint`ï¼ˆ`lint:root`, `lint:backend`, `lint:frontend` ã‚’ä¸¦åˆ—å®Ÿè¡Œï¼‰ã€‚
- ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰: `pnpm --filter backend run test:e2e -- --passWithNoTests`ã€`pnpm backend:build`ã€‚
- ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰: `pnpm frontend:lint`, `pnpm frontend:build`ã€‚
- è»½é‡ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯: `pnpm dev:health`ã€API ç…™ãƒ†ã‚¹ãƒˆ `pnpm api:smoke`ã€‚

### 0-3. PR å‰ã‚»ãƒ«ãƒ•ãƒã‚§ãƒƒã‚¯

1. `pnpm lint` â†’ `pnpm backend:build` â†’ `pnpm frontend:build`ã€‚
2. `pnpm db:migrate` + `pnpm db:seed` ã§ã‚¹ã‚­ãƒ¼ãƒå·®åˆ†ã‚’æ¤œè¨¼ï¼ˆPrisma å¤‰æ›´æ™‚ï¼‰ã€‚
3. å¿…è¦ã«å¿œã˜ã¦ `pnpm test:e2e`ã€`pnpm frontend:test`ï¼ˆå­˜åœ¨æ™‚ï¼‰ã‚’è¿½åŠ å®Ÿè¡Œã€‚
4. `pnpm dev:health` ãŒ 200 ã‚’è¿”ã™ã“ã¨ã‚’ç¢ºèªã€‚

è¨˜è¼‰ã•ã‚ŒãŸã‚³ãƒãƒ³ãƒ‰ã¯ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒè‡ªå‹•ã§å®Ÿè¡Œã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚å¤±æ•—æ™‚ã¯åŸå› èª¿æŸ»ã¨å†å®Ÿè¡Œã‚’è¡Œã£ã¦ãã ã•ã„ã€‚

---

## 1. è¨€èªè¨­å®šã¨ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³

- æœ¬ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯ **æ—¥æœ¬èª UI / ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ** ã‚’å‰æã¨ã—ã€ã‚„ã‚Šå–ã‚Šã‚‚æ—¥æœ¬èªã§çµ±ä¸€ã€‚
  - ãƒãƒ£ãƒƒãƒˆã€ãƒ¬ãƒ“ãƒ¥ãƒ¼ã€PR èª¬æ˜: ã™ã¹ã¦æ—¥æœ¬èªã§å›ç­”ã€‚
  - ã‚³ãƒ¼ãƒ‰ã‚³ãƒ¡ãƒ³ãƒˆ / README / è¨­è¨ˆè³‡æ–™: æ—¥æœ¬èªã§è¨˜è¿°ã€‚
  - ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: å¯èƒ½ãªé™ã‚Šæ—¥æœ¬èªã§è¡¨ç¤ºã—ã€é–‹ç™ºè€…å‘ã‘ãƒ­ã‚°ã‚‚æ—¥æœ¬èªã‚³ãƒ¡ãƒ³ãƒˆã‚’æ·»ä»˜ã€‚
- å¤‰æ•°å / é–¢æ•°å / å‹åã¯å›½éš›æ…£ç¿’ã«å¾“ã„è‹±èªã§çµ±ä¸€ã€‚
- æ©Ÿæ¢°ç¿»è¨³æ„Ÿã‚’é¿ã‘ã€ç°¡æ½”ã§å®Ÿå‹™çš„ãªæ—¥æœ¬èªã‚’å¿ƒæ›ã‘ã‚‹ã€‚

---

## 2. ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ç›®çš„

- mycats-pro ã§å‹•ã **AI ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå°‚ç”¨ã®è¡Œå‹•è¦ç¯„ + ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ**ã€‚
- ç›®æ¨™:
  1. ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒæœ€çŸ­ã§ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆèƒŒæ™¯ã¨é–‹ç™ºãƒ•ãƒ­ãƒ¼ã‚’ç†è§£ã™ã‚‹ã“ã¨ã€‚
  2. Next.js / NestJS / Prisma å…¬å¼ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã«æ²¿ã£ãŸã€å®‰å…¨ã§ä¸€è²«æ€§ã®ã‚ã‚‹å¤‰æ›´ã‚’è¡Œã†ã“ã¨ã€‚
  3. å‹å®‰å…¨ãƒ»æœ€å°å·®åˆ†ãƒ»å†åˆ©ç”¨å„ªå…ˆã§ã€ä¸è¦ãªç ´å£Šçš„å¤‰æ›´ã‚„ãƒã‚¤ã‚ºã‚’é˜²ãã“ã¨ã€‚

---

## 3. æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯ã¨å‰æ

- ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰: Next.js 15 (App Router + React Server Components) / React 19 / TypeScript 5 / Mantine / Tailwind CSSã€‚
- ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰: NestJS 10 / Prisma 6.14.0 / PostgreSQL 15+ã€‚
- é–‹ç™ºç’°å¢ƒ: Node.js 20.x / pnpm 9.x / macOS + Docker Composeï¼ˆãƒ­ãƒ¼ã‚«ãƒ« DBï¼‰ã€‚
- å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¨æœ¬ãƒ•ã‚¡ã‚¤ãƒ«ãŒçŸ›ç›¾ã—ãŸå ´åˆã¯ **å…¬å¼ä»•æ§˜ã‚’å„ªå…ˆ** ã—ã€å·®åˆ†ç†ç”±ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã§å…±æœ‰ã—ã¦ãã ã•ã„ã€‚

---

## 4. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ ã¨å‚ç…§ã‚¬ã‚¤ãƒ‰

- `frontend/`: App Router é…ä¸‹ã®ãƒšãƒ¼ã‚¸ã¯ `src/app/**/page.tsx`ã€‚å…±æœ‰ UI ã¯ `src/components/` ã«é›†ç´„ã€‚
- `backend/`: NestJS ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒ `src/**` ã«ç¸¦å‰²ã‚Šã§é…ç½®ã€‚Prisma ã‚¹ã‚­ãƒ¼ãƒã¯ `prisma/schema.prisma`ã€ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¯ `prisma/migrations/`ã€‚
- `docs/`, `DATABASE_*.md`: ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆãƒ»ER å›³ãƒ»é‹ç”¨ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã€‚
- å‘½åè¦ç´„: `docs/naming_convention_guidelines_v2.md` ã‚’å¸¸ã«å‚ç…§ã—ã€å‘½åæ–¹é‡ã®æ›´æ–°ãŒã‚ã‚Œã°æœ¬ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã‚»ãƒƒãƒˆã§åæ˜ ã€‚
- `scripts/`, `nginx/`, `docker-compose.yml`: é–‹ç™ºãƒ»é…å¸ƒã‚¹ã‚¯ãƒªãƒ—ãƒˆã¨ã‚¤ãƒ³ãƒ•ãƒ©å®šç¾©ã€‚
- **é…ç½®ãƒ«ãƒ¼ãƒ«**: æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«ã¯è²¬å‹™ãŒæœ€ã‚‚è¿‘ã„ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¸ç½®ãã€æ—¢å­˜å‘½åè¦å‰‡ã«å¾“ã†ã“ã¨ã€‚

### 4-1. ãƒ•ã‚©ãƒ«ãƒ€å°‚ç”¨ã‚¬ã‚¤ãƒ‰ (`CODE_GUIDE.md`)

- ä¸»è¦ãƒ•ã‚©ãƒ«ãƒ€ã«ã¯ãƒ­ãƒ¼ã‚«ãƒ«ãƒ«ãƒ¼ãƒ«ã‚’ã¾ã¨ã‚ãŸ `CODE_GUIDE.md` ã‚’è¨­ç½®æ¸ˆã€‚
- å¤‰æ›´å¯¾è±¡ã®ç›´ä¸‹ã«è©²å½“ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚‹å ´åˆã¯ **å¿…èª­**ã€‚ã“ã“ã§å®šç¾©ã•ã‚ŒãŸãƒ­ãƒ¼ã‚«ãƒ«è¦ç´„ã¯æœ¬ãƒ•ã‚¡ã‚¤ãƒ«ã‚ˆã‚Šå„ªå…ˆã•ã‚Œã‚‹ã€‚

### 4-2. å¢ƒç•Œ - å¤‰æ›´ã—ã¦ã¯ã„ã‘ãªã„ã‚‚ã®

ä»¥ä¸‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ»ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¯ **çµ¶å¯¾ã«å¤‰æ›´ãƒ»å‰Šé™¤ã—ã¦ã¯ã„ã‘ã¾ã›ã‚“**ï¼š

- **è‡ªå‹•ç”Ÿæˆãƒ•ã‚¡ã‚¤ãƒ«**:
  - `node_modules/**` - ä¾å­˜é–¢ä¿‚
  - `dist/**`, `.next/**` - ãƒ“ãƒ«ãƒ‰æˆæœç‰©
  - `backend/prisma/migrations/**` - ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆæ‰‹å‹•ç·¨é›†ç¦æ­¢ï¼‰
  - `frontend/src/lib/api/generated/**` - OpenAPI è‡ªå‹•ç”Ÿæˆå‹

- **è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«** (å¿…è¦ãªå ´åˆã®ã¿æ…é‡ã«å¤‰æ›´):
  - `.env`, `.env.production` - æ©Ÿå¯†æƒ…å ±
  - `pnpm-lock.yaml` - ãƒ­ãƒƒã‚¯ãƒ•ã‚¡ã‚¤ãƒ«
  - `docker-compose.yml` - ã‚¤ãƒ³ãƒ•ãƒ©è¨­å®š
  - `nginx/nginx.conf` - Web ã‚µãƒ¼ãƒãƒ¼è¨­å®š

- **CI/CD ã¨ãƒ‡ãƒ—ãƒ­ã‚¤** (æ˜ç¤ºçš„ãªæŒ‡ç¤ºãŒãªã„é™ã‚Šå¤‰æ›´ç¦æ­¢):
  - `.github/workflows/**` - GitHub Actions
  - `cloudbuild.yaml` - GCP ãƒ“ãƒ«ãƒ‰è¨­å®š
  - `Dockerfile.*` - ã‚³ãƒ³ãƒ†ãƒŠè¨­å®š

- **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹**:
  - æ—¢å­˜ã®ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã¯ç·¨é›†ä¸å¯
  - ã‚¹ã‚­ãƒ¼ãƒå¤‰æ›´ã¯æ–°è¦ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã§å¯¾å¿œ

ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ã€ä¸Šè¨˜ã®å¢ƒç•Œã‚’å®ˆã‚‹ã“ã¨ã§ã‚·ã‚¹ãƒ†ãƒ ã®å®‰å®šæ€§ã¨å†ç¾æ€§ã‚’ä¿è¨¼ã—ã¦ã„ã¾ã™ã€‚

---

## 5. AGENTS.md ã®èª­ã¿æ–¹ / é‹ç”¨

- ãƒ«ãƒ¼ãƒˆ `AGENTS.md` ã¯å…±é€šãƒ«ãƒ¼ãƒ«ã€‚å¿…è¦ã«å¿œã˜ã¦ã‚µãƒ–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«è¿½åŠ ã® `AGENTS.md` ã‚’é…ç½®ã—ã¦ã‚‚ã‚ˆã„ï¼ˆæœ€ã‚‚è¿‘ã„ãƒ•ã‚¡ã‚¤ãƒ«ãŒå„ªå…ˆã•ã‚Œã‚‹ï¼‰ã€‚
- å¤‰æ›´ã‚’åŠ ãˆãŸã‚‰å¿…ãšæœ¬ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æœ€æ–°ã®çŠ¶æ…‹ã«ä¿ã¡ã€PR èª¬æ˜ã«ã‚‚æ›´æ–°å†…å®¹ã‚’è¨˜è¼‰ã€‚
- ä»–ãƒ„ãƒ¼ãƒ«ï¼ˆAider / Gemini CLI ç­‰ï¼‰ã¨ä½µç”¨ã™ã‚‹å ´åˆã‚‚ãƒ•ã‚¡ã‚¤ãƒ«åã¯ `AGENTS.md` ã«çµ±ä¸€ã™ã‚‹ã€‚
- ãƒ«ãƒ¼ãƒ«ã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼æŒ‡ç¤ºã«çŸ›ç›¾ãŒç™ºç”Ÿã—ãŸå ´åˆã¯ã€ä½œæ¥­ã‚’ä¸­æ–­ã—ã¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«å„ªå…ˆé †ä½ï¼ˆã©ã¡ã‚‰ã‚’æ¡ç”¨ã™ã‚‹ã‹ï¼‰ã‚’ç¢ºèªã—ã€åˆ¤æ–­ã‚’å¾—ã¦ã‹ã‚‰å†é–‹ã™ã‚‹ã€‚

---

## 6. ä½œæ¥­ãƒ•ãƒ­ãƒ¼ã¨å“è³ªã‚²ãƒ¼ãƒˆ

1. **èª¿æŸ»**: é–¢é€£ãƒ•ã‚¡ã‚¤ãƒ«ãƒ»æ—¢å­˜å®Ÿè£…ãƒ»`CODE_GUIDE.md` ã‚’ç¢ºèªã€‚æ—¢å­˜ãƒ†ã‚¹ãƒˆã‚„å‹å®šç¾©ã‚’å…ˆã«æŠŠæ¡ã™ã‚‹ã€‚
2. **ã‚¿ã‚¤ãƒ—ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆ**: å¤‰æ›´å†…å®¹ã«å¯¾ã™ã‚‹å‹ (`interface / type / DTO / Zod schema`) ã‚’æ›´æ–° â†’ å®Ÿè£… â†’ ãƒ†ã‚¹ãƒˆã®é †ã§ä½œæ¥­ã€‚
3. **è‡ªå‹•åŒ–ãƒã‚§ãƒƒã‚¯**: å¤‰æ›´ã«å½±éŸ¿ã™ã‚‹ãƒ†ã‚¹ãƒˆ / Lint / å‹ãƒã‚§ãƒƒã‚¯ã‚’å³æ™‚å®Ÿè¡Œã—ã€å¤±æ•—ã‚’è§£æ¶ˆã€‚
4. **è‡ªå·±ãƒ¬ãƒ“ãƒ¥ãƒ¼**: å½±éŸ¿ç¯„å›²ã€ä¾‹å¤–å‡¦ç†ã€ç¿»è¨³ã®æ•´åˆæ€§ã€doc æ›´æ–°ã‚’ç¢ºèªã€‚

è£œè¶³ï¼ˆãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã®å†ç™ºé˜²æ­¢ï¼‰:
- Controller ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ä¾å­˜ï¼ˆæ³¨å…¥ã™ã‚‹ Serviceï¼‰ã‚’è¿½åŠ ãƒ»å¤‰æ›´ã—ãŸå ´åˆã€å¯¾å¿œã™ã‚‹ `*.controller.spec.ts` ã® `Test.createTestingModule` ã® `providers`ï¼ˆã¾ãŸã¯ `overrideProvider`ï¼‰ã‚‚å¿…ãšè¿½éšã•ã›ã‚‹ã€‚

æœ€ä½é™ã€ä»¥ä¸‹ã®å“è³ªã‚²ãƒ¼ãƒˆã‚’ PASS ã•ã›ã¦ã‹ã‚‰ä½œæ¥­å®Œäº†ã¨ã™ã‚‹:

- `pnpm lint`ï¼ˆroot + frontend + backendï¼‰ã€‚
- å½±éŸ¿ã—ãŸãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã® `pnpm build` / `pnpm test`ã€‚
- Prisma å¤‰æ›´æ™‚ã¯ `pnpm db:migrate` + `pnpm db:seed` ã§å†ç¾ç¢ºèªã€‚

---

## 7. å‹å®‰å…¨ãƒãƒªã‚·ãƒ¼ï¼ˆå³æ ¼ç‰ˆï¼‰

- `any` / `unknown` ã®ä½¿ç”¨ã¯ç¦æ­¢ã€‚ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®åˆ¶ç´„ã§ä¸å¯é¿ãªå ´åˆã®ã¿ã€**è©²å½“è¡Œã«ç†ç”±ã‚³ãƒ¡ãƒ³ãƒˆã‚’è¨˜è¼‰**ã—ã€å‹ã‚¬ãƒ¼ãƒ‰ã‚„ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã§éœ²å‡ºã‚’å±€æ‰€åŒ–ã™ã‚‹ã€‚

### 7-1. any / unknown ä¾‹å¤–æ¡ä»¶ï¼ˆã™ã¹ã¦å¿…é ˆï¼‰

1. å¤–éƒ¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å‹å®šç¾©ãŒå®Ÿæ…‹ã¨ç•°ãªã‚Šä¿®æ­£ä¸èƒ½
2. ä»¥ä¸‹ã®ä»£æ›¿æ¡ˆã‚’ã™ã¹ã¦è©¦è¡Œã—å¤±æ•—:
   - å‹ã‚¬ãƒ¼ãƒ‰
   - Partial / Pick / Omit
   - ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹
   - å‹ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³
   - ãƒ©ã‚¤ãƒ–ãƒ©ãƒªæ›´æ–°ãƒ»ä»£æ›¿æ¤œè¨
3. è©²å½“è¡Œã«ä»¥ä¸‹ã‚’å¿…ãšè¨˜è¼‰:
   - è©¦è¡Œã—ãŸä»£æ›¿æ¡ˆã¨çµæœ
   - any ä½¿ç”¨ç†ç”±
   - å½±éŸ¿ç¯„å›²æœ€å°åŒ–æ–¹æ³•

- é null ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆ`!`ï¼‰ã¯ç¦æ­¢ã€‚nullable ã‚’æ‰±ã†éš›ã¯ã‚¬ãƒ¼ãƒ‰ã‚„ `if (!value) return` ã§å®‰å…¨ã«æ‰±ã†ã€‚
- ä¹±æš´ãªäºŒæ®µã‚­ãƒ£ã‚¹ãƒˆï¼ˆ`value as unknown as X`, `as any`ï¼‰ã¯ç¦æ­¢ã€‚å¿…è¦ãªå ´åˆã¯å‹ã‚¬ãƒ¼ãƒ‰ãƒ»åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…ã€‚
- `// eslint-disable` / `@ts-ignore` ã¯åŸå‰‡ç¦æ­¢ã€‚ã‚„ã‚€ã‚’å¾—ãªã„å ´åˆã¯ 1 è¡Œé™å®š + ç†ç”±ã‚³ãƒ¡ãƒ³ãƒˆã€‚
- ESLint / tsconfig ã®è¨­å®šã§å‹ã‚¨ãƒ©ãƒ¼ã‚’é»™æ®ºã™ã‚‹ã“ã¨ã¯ç¦æ­¢ã€‚ã‚¨ãƒ©ãƒ¼åŸå› ã‚’ã‚³ãƒ¼ãƒ‰ã§è§£æ±ºã™ã‚‹ã€‚
- ã™ã¹ã¦ã®å…¬é–‹é–¢æ•°ãƒ»ã‚¯ãƒ©ã‚¹ã¯å¼•æ•°ãƒ»æˆ»ã‚Šå€¤ã‚’å®Œå…¨ã«å‹å®šç¾©ã€‚`Promise` é–¢æ•°ã¯ `Promise<ResultType>` ã‚’æ˜ç¤ºã€‚
- åˆ†å²ã¯å¯èƒ½ãªé™ã‚Š **exhaustiveness check** ã‚’å®Ÿæ–½ï¼ˆ`switch` + `never`ï¼‰ã€‚
- API å…¥å‡ºåŠ›ã¯æ—¢å­˜ DTO / Prisma å‹ / å…±é€š `types/` ã‚’å†åˆ©ç”¨ã€‚é‡è¤‡å®šç¾©ã‚’é¿ã‘ã€å‹ãŒè¶³ã‚Šãªã„å ´åˆã¯å…±é€šå ´æ‰€ã«è¿½åŠ ã—ã¦ã‹ã‚‰ä½¿ç”¨ã™ã‚‹ã€‚

---

## 8. ã‚¨ãƒ©ãƒ¼å‡¦ç†ã¨ãƒ­ã‚®ãƒ³ã‚°

- ç©ºã® `catch`ã€`console.error` ã®ã¿ã§çµ‚äº†ã€`void someAsync()` ã®æ”¾ç½®ã¯ç¦æ­¢ã€‚
- ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰: NestJS ã®ä¾‹å¤–ãƒ•ã‚£ãƒ«ã‚¿ (`HttpException`, `BadRequestException`, ã‚«ã‚¹ã‚¿ãƒ ä¾‹å¤–) ã¨ãƒ­ã‚¬ãƒ¼ã‚’ä½¿ç”¨ã€‚
- ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰: ãƒ¦ãƒ¼ã‚¶ãƒ¼å‘ã‘ã«æ—¥æœ¬èªã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã—ã€å¿…è¦ã«å¿œã˜ã¦ãƒˆãƒ¼ã‚¹ãƒˆ/ãƒãƒŠãƒ¼ãªã©ã§çŠ¶æ…‹ç®¡ç†ã€‚
- `unknown` ãªã‚¨ãƒ©ãƒ¼ã¯å‹ã‚¬ãƒ¼ãƒ‰ã§åˆ†é¡ã—ã€å¿…è¦ãªã‚‰ `instanceof` åˆ¤å®šã‚„ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ã§åˆ†å²ã€‚

---

## 9. å¤‰æ›´ã‚¹ã‚³ãƒ¼ãƒ—ã¨å†åˆ©ç”¨

- ä¾é ¼ç¯„å›²ä»¥å¤–ã®å¤§è¦æ¨¡ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã¯ç¦æ­¢ã€‚è§¦ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«å†…ã®æ˜ã‚‰ã‹ãªä¸å…·åˆã®ã¿å‰¯æ¬¡çš„ã«ä¿®æ­£å¯ã€‚
- æ—¢å­˜ã® API / DTO / UI ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ / ã‚µãƒ¼ãƒ“ã‚¹ã‚’ã¾ãšæ¢ç´¢ã—ã€å†åˆ©ç”¨ã§ããªã„ã‹ç¢ºèªã™ã‚‹ã€‚
- åŒã˜ãƒ­ã‚¸ãƒƒã‚¯ã‚’è¤‡è£½ã›ãšã€æŠ½è±¡åŒ–ã¾ãŸã¯å…±é€šåŒ–ã‚’æ¤œè¨ã€‚é‡è¤‡ãŒå¿…è¦ãã†ãªå ´åˆã¯æ ¹æ‹ ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã§èª¬æ˜ã€‚

---

## 10. Next.jsï¼ˆApp Routerï¼‰ã‚¬ã‚¤ãƒ‰

1. `frontend/src/app` é…ä¸‹ã§ App Router è¦ç´„ï¼ˆ`page.tsx`, `layout.tsx`, `loading.tsx`, `error.tsx` ç­‰ï¼‰ã‚’éµå®ˆã€‚
2. ã‚µãƒ¼ãƒãƒ¼ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå„ªå…ˆã€‚`use client` ã¯æœ€å°é™ã«ã—ã€`client` ã‚’ä»˜ã‘ã‚‹ç†ç”±ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã§å…±æœ‰ã€‚
3. ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚§ãƒƒãƒã¯ã‚µãƒ¼ãƒãƒ¼å´ã§å®Ÿè¡Œã—ã€`fetch` ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥ï¼ˆ`revalidate` ç­‰ï¼‰ã‚’æ˜ç¤ºã€‚
4. ãƒ•ã‚©ãƒ¼ãƒ /ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã‚µãƒ¼ãƒãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ or API Route ã‚’æ´»ç”¨ã—ã€CSRFãƒ»ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è€ƒæ…®ã€‚

---

## 11. NestJS + Prisma ã‚¬ã‚¤ãƒ‰

1. Controller â†’ Service â†’ Repository/Prisma ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å®ˆã‚Šã€Controller ã§ç›´æ¥ Prisma ã‚’å‘¼ã°ãªã„ã€‚
2. DTO + `class-validator` ã§å…¥å‡ºåŠ›ã‚’å®šç¾©ã€‚ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ•´å½¢ç”¨ã® Presenter / Serializer ã‚’å°å…¥ã—ã¦ã‚‚ã‚ˆã„ã€‚
3. Prisma ã‚¯ã‚¨ãƒªã¯ `select` / `include` ã§å¿…è¦ãªãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«é™å®šã—ã€N+1 ã‚’é¿ã‘ã‚‹ã€‚
4. `schema.prisma` å¤‰æ›´æ™‚ã¯ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ç”Ÿæˆã—ã€å½±éŸ¿ç¯„å›²ï¼ˆç ´å£Šçš„ã‹å¦ã‹ï¼‰ã‚’ PR ã§èª¬æ˜ã€‚

---

## 12. Dev Environment Tips

- `pnpm help` ã§åˆ©ç”¨å¯èƒ½ãªä¸»è¦ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ä¸€è¦§ç¢ºèªã§ãã‚‹ã€‚
- `scripts/` é…ä¸‹ã®ã‚·ã‚§ãƒ«ã‚¹ã‚¯ãƒªãƒ—ãƒˆï¼ˆä¾‹: `start-dev-stable.sh`, `preflight-backend.sh`ï¼‰ã¯ macOS + zsh å‰æã€‚å¿…è¦ã«å¿œã˜ã¦ `chmod +x` æ¸ˆã‹ç¢ºèªã€‚
- ãƒ­ãƒ¼ã‚«ãƒ« DB åˆæœŸåŒ–ã¯ `init_database.sql` / `seed_data.sql` ã‚’å‚ç…§ã€‚Docker Compose ã§ `database/init` ãŒè‡ªå‹•é©ç”¨ã•ã‚Œã‚‹ã€‚

---

## 13. AI ã¸ã®ä¾é ¼ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ

### 13-1. æ©Ÿèƒ½è¿½åŠ ãƒªã‚¯ã‚¨ã‚¹ãƒˆ

```
ã‚ãªãŸã¯ mycats-pro ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå°‚ä»»ã® AI ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§ã™ã€‚
Next.js 15ï¼ˆApp Routerï¼‰+ React 19 + NestJS 10 + Prisma 6 + PostgreSQL 15 ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã¨ã€
ãƒªãƒã‚¸ãƒˆãƒªç›´ä¸‹ã® AGENTS.md / è©²å½“ãƒ•ã‚©ãƒ«ãƒ€ã® CODE_GUIDE.md ã«å¾“ã£ã¦ãã ã•ã„ã€‚

ã€ã‚„ã‚ŠãŸã„ã“ã¨ã€‘
- æ©Ÿèƒ½æ¦‚è¦: ï¼ˆã“ã“ã«æ¦‚è¦ã‚’æ›¸ãï¼‰
- å¯¾è±¡ç”»é¢ / API: ï¼ˆä¾‹: frontend/src/app/cats, backend/src/cats ãªã©ï¼‰

ã€å¿…ãšå®ˆã£ã¦ã»ã—ã„ã“ã¨ã€‘
- any/unknown / é null ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã¯ç¦æ­¢ã€‚å‹å®šç¾© â†’ å®Ÿè£… â†’ ãƒ†ã‚¹ãƒˆã®é †ã§æ›´æ–°ã€‚
- ã‚¨ãƒ©ãƒ¼å‡¦ç†ã¯ Next.js / NestJS ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã«å¾“ã„ã€æ—¥æœ¬èªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿”ã™ã€‚
- ç„¡é–¢ä¿‚ãªãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã‚’é¿ã‘ã€æ—¢å­˜ã®ä¼¼ãŸå®Ÿè£…ã‚’å†åˆ©ç”¨ã€‚

ã€å‡ºåŠ›ã—ã¦ã»ã—ã„ã“ã¨ã€‘
1. å¤‰æ›´ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ï¼ˆå½¹å‰²ä»˜ãï¼‰
2. ä¸»è¦ãªã‚³ãƒ¼ãƒ‰å¤‰æ›´ç‚¹ + å‹å®‰å…¨æ€§ã®ãƒã‚¤ãƒ³ãƒˆ
3. è¿½åŠ  / æ›´æ–°ã—ãŸãƒ†ã‚¹ãƒˆã¨æ„å›³
4. å®Ÿè¡Œã—ãŸã‚³ãƒãƒ³ãƒ‰ã¨å†ç¾æ‰‹é †ï¼ˆpnpm ãƒ™ãƒ¼ã‚¹ï¼‰
```

### 13-2. ãƒã‚°ä¿®æ­£ãƒªã‚¯ã‚¨ã‚¹ãƒˆ

```
ã‚ãªãŸã¯ mycats-pro ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå°‚ä»»ã® AI ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§ã™ã€‚
Next.js / NestJS / Prisma ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã¨ AGENTS.md ã«å¾“ã£ã¦ã€ä»¥ä¸‹ã®ãƒã‚°ã‚’ä¿®æ­£ã—ã¦ãã ã•ã„ã€‚

ã€ãƒã‚°å†…å®¹ã€‘
- ç¾è±¡: ï¼ˆä½•ãŒã©ã†ãŠã‹ã—ã„ã‹ï¼‰
- å†ç¾æ‰‹é †: ï¼ˆURL, æ“ä½œæ‰‹é †ãªã©ï¼‰
- æœŸå¾…ã™ã‚‹æŒ™å‹•: ï¼ˆã©ã†ãªã£ã¦ã„ã¦ã»ã—ã„ã‹ï¼‰

ã€åˆ¶ç´„ã€‘
- ä¿®æ­£ç¯„å›²ã‚’åŸå› ç®‡æ‰€å‘¨è¾ºã«é™å®šã—ã€any/unknown ã‚’ä½¿ã‚ãšã«è§£æ±ºã€‚
- `@ts-ignore` ã‚„ `eslint-disable` ã‚’ä½¿ã‚ãªã„ã€‚ã©ã†ã—ã¦ã‚‚å¿…è¦ãªã‚‰ç†ç”±ã¨æ’¤å»ãƒ¡ãƒ¢ã‚’æ®‹ã™ã€‚
- å†ç™ºé˜²æ­¢ãƒ†ã‚¹ãƒˆã‚’è¿½åŠ ï¼ˆãƒ¦ãƒ‹ãƒƒãƒˆ or e2eï¼‰ã€‚

ã€å‡ºåŠ›ã—ã¦ã»ã—ã„ã“ã¨ã€‘
1. æƒ³å®šåŸå› ã¨æ ¹æ‹ 
2. ä¿®æ­£ãƒ•ã‚¡ã‚¤ãƒ«ã¨å¤‰æ›´æ¦‚è¦
3. è¿½åŠ  / æ›´æ–°ã—ãŸãƒ†ã‚¹ãƒˆå†…å®¹
4. å†ç¾ç¢ºèªã¨å›å¸°ç¢ºèªã«ä½¿ç”¨ã—ãŸã‚³ãƒãƒ³ãƒ‰
```

---

## 14. æœŸå¾…ã™ã‚‹å›ç­”ã‚¹ã‚¿ã‚¤ãƒ«

- æ—¥æœ¬èªã§ç°¡æ½”ã‹ã¤æƒ…å ±å¯†åº¦ã®é«˜ã„èª¬æ˜ã‚’è¡Œã†ã€‚ç„¡é§„ãªå‰ç½®ãã‚„æ„Ÿæƒ³ã‚’çœãã€äº‹å®Ÿã¨æ‰‹é †ã‚’å„ªå…ˆã€‚
- mycats-pro å›ºæœ‰ã®æ–‡è„ˆã«ç´ã¥ã‘ã¦èª¬æ˜ã—ã€ä¸€èˆ¬è«–ã ã‘ã§çµ‚ã‚ã‚‰ã›ãªã„ã€‚
- ã‚³ãƒ¼ãƒ‰ã¯å¿…è¦æœ€å°é™ã®æŠœç²‹ã«ç•™ã‚ã€ãƒ‘ã‚¹ãƒ»é–¢æ•°åã‚’æ˜ç¤ºã€‚
- å¯èƒ½ãªé™ã‚Šãƒ†ã‚¹ãƒˆæˆ¦ç•¥ã¨å®Ÿè¡Œã‚³ãƒãƒ³ãƒ‰ã‚’ä½µè¨˜ã—ã€å“è³ªã‚²ãƒ¼ãƒˆã‚’æ˜æ–‡åŒ–ã€‚
`````

## File: .github/DEPLOYMENT_SECRETS_SETUP.md
`````markdown
# GitHub Secretsè¨­å®šã‚¬ã‚¤ãƒ‰ - ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆç”¨

ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§ã¯ã€CI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã§ã®ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆã«å¿…è¦ãªGitHub Secretsã®è¨­å®šæ–¹æ³•ã‚’èª¬æ˜ã—ã¾ã™ã€‚

## ğŸ”‘ å¿…é ˆã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆ

### 1. GCP_SA_KEY
**èª¬æ˜**: Google Cloud ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®JSONã‚­ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ã®å…¨å†…å®¹

**è¨­å®šæ–¹æ³•**:
1. Google Cloud Consoleã§ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚­ãƒ¼ã‚’ç”Ÿæˆ
   - [IAM & Admin > Service Accounts](https://console.cloud.google.com/iam-admin/serviceaccounts)
   - ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’é¸æŠ â†’ "Keys" ã‚¿ãƒ– â†’ "Add Key" â†’ "Create new key"
   - JSONå½¢å¼ã‚’é¸æŠã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰

2. GitHubãƒªãƒã‚¸ãƒˆãƒªã®Secretsã«è¿½åŠ 
   - ãƒªãƒã‚¸ãƒˆãƒªã® Settings > Secrets and variables > Actions
   - "New repository secret" ã‚’ã‚¯ãƒªãƒƒã‚¯
   - Name: `GCP_SA_KEY`
   - Value: ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ãŸJSONãƒ•ã‚¡ã‚¤ãƒ«ã®**å…¨å†…å®¹**ã‚’ã‚³ãƒ”ãƒ¼&ãƒšãƒ¼ã‚¹ãƒˆ

**JSONã®ä¾‹**:
```json
{
  "type": "service_account",
  "project_id": "my-cats-pro",
  "private_key_id": "abc123...",
  "private_key": "-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----\n",
  "client_email": "cloud-run-deployer@my-cats-pro.iam.gserviceaccount.com",
  "client_id": "123456789...",
  "auth_uri": "https://accounts.google.com/o/oauth2/auth",
  "token_uri": "https://oauth2.googleapis.com/token",
  "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
  "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/..."
}
```

**å¿…è¦ãªæ¨©é™**:
- Cloud Build Editor
- Cloud Run Admin
- Service Account User
- Artifact Registry Writer

### 2. GCP_PROJECT_ID
**èª¬æ˜**: Google Cloud ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ID

**è¨­å®šæ–¹æ³•**:
1. GitHubãƒªãƒã‚¸ãƒˆãƒªã®Secretsã«è¿½åŠ 
   - Name: `GCP_PROJECT_ID`
   - Value: `my-cats-pro` (ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆIDã«å¿œã˜ã¦å¤‰æ›´)

## ğŸ” è¨­å®šã®ç¢ºèªæ–¹æ³•

### GitHub Actionsãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã§ã®æ¤œè¨¼

ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆã‚¸ãƒ§ãƒ–ï¼ˆ`deploy-staging`, `deploy-production`ï¼‰ã¯ã€å®Ÿè¡Œå‰ã«è‡ªå‹•çš„ã«ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã®å­˜åœ¨ã‚’ç¢ºèªã—ã¾ã™ã€‚

ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã€ä»¥ä¸‹ã®ã‚ˆã†ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒè¡¨ç¤ºã•ã‚Œã¾ã™:

```
âŒ Error: GCP_SA_KEY secret is not set
Please configure the GCP_SA_KEY secret in repository settings:
  Settings > Secrets and variables > Actions > New repository secret
  Name: GCP_SA_KEY
  Value: <Full JSON content of GCP service account key>
```

### ãƒ­ãƒ¼ã‚«ãƒ«ã§ã®ç¢ºèª

GitHub CLIã‚’ä½¿ç”¨ã—ã¦ã€ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã§ãã¾ã™:

```bash
gh secret list
```

## âš ï¸ ã‚ˆãã‚ã‚‹ã‚¨ãƒ©ãƒ¼ã¨è§£æ±ºæ–¹æ³•

### ã‚¨ãƒ©ãƒ¼: "must specify exactly one of 'workload_identity_provider' or 'credentials_json'"

**åŸå› **: `GCP_SA_KEY` ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆãŒç©ºã€ã¾ãŸã¯è¨­å®šã•ã‚Œã¦ã„ãªã„

**è§£æ±ºæ–¹æ³•**:
1. GitHubãƒªãƒã‚¸ãƒˆãƒªã® Settings > Secrets and variables > Actions ã§ `GCP_SA_KEY` ãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã‚’ç¢ºèª
2. ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã®å€¤ãŒç©ºã§ãªã„ã“ã¨ã‚’ç¢ºèªï¼ˆå†è¨­å®šãŒå¿…è¦ãªå ´åˆãŒã‚ã‚Šã¾ã™ï¼‰
3. JSONãƒ•ã‚¡ã‚¤ãƒ«ã®å…¨å†…å®¹ãŒæ­£ã—ãã‚³ãƒ”ãƒ¼ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªï¼ˆæ”¹è¡Œã‚„ã‚¹ãƒšãƒ¼ã‚¹ã‚‚å«ã‚€ï¼‰

### ã‚¨ãƒ©ãƒ¼: "Invalid credentials"

**åŸå› **: ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚­ãƒ¼ã®JSONå½¢å¼ãŒä¸æ­£ã€ã¾ãŸã¯æ¨©é™ä¸è¶³

**è§£æ±ºæ–¹æ³•**:
1. JSONãƒ•ã‚¡ã‚¤ãƒ«ãŒæ­£ã—ã„å½¢å¼ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
2. ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«å¿…è¦ãªæ¨©é™ãŒä»˜ä¸ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
3. æ–°ã—ã„ã‚­ãƒ¼ã‚’ç”Ÿæˆã—ã¦å†è¨­å®š

### ã‚¨ãƒ©ãƒ¼: "Project not found"

**åŸå› **: `GCP_PROJECT_ID` ãŒé–“é•ã£ã¦ã„ã‚‹

**è§£æ±ºæ–¹æ³•**:
1. Google Cloud Consoleã§ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆIDã‚’ç¢ºèª
2. `GCP_PROJECT_ID` ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã®å€¤ã‚’æ­£ã—ã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆIDã«æ›´æ–°

## ğŸ“š é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- [GitHub Actions Secretsè¨­å®šã‚¬ã‚¤ãƒ‰](./GITHUB_ACTIONS_SETUP.md)
- [CI/CD ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆãƒ•ãƒ­ãƒ¼](../docs/CICD_DEPLOYMENT_FLOW.md)
- [æœ¬ç•ªç’°å¢ƒãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆã‚¬ã‚¤ãƒ‰](./CICD_PRODUCTION_GUIDE.md)

## ğŸ”’ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

1. **æœ€å°æ¨©é™ã®åŸå‰‡**: ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«ã¯å¿…è¦æœ€å°é™ã®æ¨©é™ã®ã¿ã‚’ä»˜ä¸
2. **ã‚­ãƒ¼ã®ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³**: å®šæœŸçš„ã«ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚­ãƒ¼ã‚’æ›´æ–°
3. **ç›£æŸ»ãƒ­ã‚°ã®ç¢ºèª**: Cloud Audit Logsã§ä¸å¯©ãªã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ã‚’ç›£è¦–
4. **ç’°å¢ƒã”ã¨ã®åˆ†é›¢**: staging ã¨ production ã§ç•°ãªã‚‹ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’æ¨å¥¨
`````

## File: .github/staged-verification.md
`````markdown
# æ®µéšçš„æ¤œè¨¼ãƒã‚¤ãƒ³ãƒˆ

## Stage 1: ãƒ•ã‚¡ã‚¤ãƒ«å¤‰æ›´æ™‚

```bash
pnpm lint
```

## Stage 2: æ©Ÿèƒ½å˜ä½å®Œæˆæ™‚

```bash
pnpm --filter <package> run test
pnpm --filter <package> run build
```

## Stage 3: PR å‰æœ€çµ‚æ¤œè¨¼

```bash
pnpm lint
pnpm backend:build
pnpm frontend:build
pnpm db:migrate
pnpm db:seed
pnpm dev:health
```

## ç¦æ­¢äº‹é …

- ã‚¨ãƒ©ãƒ¼ã‚’æ®‹ã—ãŸã¾ã¾æ¬¡å·¥ç¨‹ã¸é€²ã‚€
- å¾Œå›ã—å‰æã®ã‚³ãƒŸãƒƒãƒˆ
`````

## File: .github/user-feedback-priority.md
`````markdown
# ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯å„ªå…ˆåº¦ãƒãƒˆãƒªã‚¯ã‚¹

## ğŸ”´ Critical

- ã‚¨ãƒ©ãƒ¼ãƒ»è­¦å‘Šå ±å‘Š
- èª¿æŸ»ç¤ºå”†
- CI/CD å¤±æ•—

å¯¾å¿œ: ä½œæ¥­ä¸­æ–­ â†’ èª¿æŸ»æ–¹é‡å¤‰æ›´ â†’ å ±å‘Š

## ğŸŸ¡ High

- æ©Ÿèƒ½å¤‰æ›´è¦æœ›
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ»ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ‡¸å¿µ

## ğŸŸ¢ Normal

- ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ”¹å–„
- UI/UX ææ¡ˆ

## NG ãƒ‘ã‚¿ãƒ¼ãƒ³

ãƒ¦ãƒ¼ã‚¶ãƒ¼ç¤ºå”†ã‚’ç‹¬è‡ªåˆ¤æ–­ã§ç„¡è¦–ã™ã‚‹ã“ã¨
`````

## File: .gitignore
`````
# Local development database (PostgreSQL)
.dev/
.dev/postgres/
.dev/postgres/data/
# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.npm/
.nvm/

# Build outputs
dist/
build/
.next/
.nuxt/
out/

# Environment variables
.env
.env.local
.env.development
.env.development.local
.env.test.local
.env.production.local

# IDE and editor files
.vscode/
.idea/
*.swp
*.swo
*~

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs
logs/
*.log

# Runtime data
pids/
# Runtime artifacts (should not be committed)
backend.log
backend.out
backend.pid
cookies.txt
*.pid
*.log
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/
.nyc_output/

# Prisma
prisma/dev.db
prisma/dev.db-journal
# Auto-generated Prisma schema documentation
backend/prisma/schema_prisma.txt

# TypeScript
*.tsbuildinfo

# Test results
test-results/
playwright-report/

# Temporary files
*.tmp
*.temp
tmp/

# Database files
*.db
*.sqlite
*.sqlite3

# Cache
.cache/
.parcel-cache/

# Lock files (keep only one type)
package-lock.json
yarn.lock

# Data files that should not be in version control
*.csv
*.xlsx
*.xls
*.accdb
*.mdb
*.ini
RegsyDatabase.ini

# Sample/test data directories
**/NewPedigree/**/*.csv
**/NewPedigree/**/*.xlsx
**/data/**/*.csv
**/database/**/*.csv

# Dockerç’°å¢ƒå¤‰æ•°ï¼ˆæ©Ÿå¯†æƒ…å ±ã‚’å«ã‚€ï¼‰
.env.docker

# Shell files (personal configs)
.zsh_history
.zsh_sessions/
.zcompdump*
.zprofile
.zshrc

# Personal/temp files
Applications/
Desktop/
Documents/
Downloads/
Library/
Movies/
Music/
OneDrive*/
Pictures/
Public/
.Trash/
`````

## File: .trivyignore
`````
# Trivy ignore file for security scanning
# This file contains vulnerabilities that are intentionally ignored

# Development-specific vulnerabilities that don't affect production
CVE-2024-28849  # Development-only dependency issue in @next/eslint-plugin-next

# Node.js vulnerabilities that are handled by environment constraints
# (We enforce Node.js >=20 in package.json)

# Frontend static build vulnerabilities that don't apply to backend API

# Example JWT tokens in API documentation (not real secrets)
# These are truncated example strings like "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
# which only decode to the JWT header and are used for API documentation purposes
# in backend/openapi.json and generated frontend API schema
secret:jwt
secret:generic-api-key

# pnpm path collision vulnerability (CVE-2024-49766)
# This is a theoretical attack that requires specific conditions:
# - Attacker must have write access to the package registry
# - Hash collision must occur for package paths
# - Not exploitable in our controlled environment
# We use pnpm 9.x which has mitigations in place
CVE-2024-49766

# js-yaml schema loading vulnerability
# Our usage of js-yaml is limited to build-time configuration parsing
# with trusted input only (no user-provided YAML)
CVE-2024-56300

# path-to-regexp ReDoS vulnerabilities (CVE-2024-45296, CVE-2024-52798)
# These affect path-to-regexp versions prior to specific patches:
# - CVE-2024-45296: Affects <0.1.10, <1.9.0, <3.3.0, <6.3.0, <8.0.0
# - CVE-2024-52798: Affects <0.1.12
# Our installed versions are patched:
# - path-to-regexp@0.1.12 (patched for CVE-2024-52798)
# - path-to-regexp@3.3.0 (patched for CVE-2024-45296)
# Express 4.21.2 uses the patched 0.1.12 version internally
# Trivy may not recognize these as patched due to database lag
CVE-2024-45296
CVE-2024-52798

# cookie package XSS vulnerability (CVE-2024-47764)
# Affects cookie package <0.7.0
# Our installed version is cookie@1.0.2 which includes the fix
# This is used by cookie-parser and Express
# Trivy may not recognize this as patched due to database lag
CVE-2024-47764

# Express vulnerabilities that are either patched or false positives
# CVE-2024-10491: Express 3.x Link header injection (we use Express 4.21.2)
# This CVE only affects Express 3.x which is EOL
# Scanning tools may incorrectly flag Express 4.x as vulnerable
CVE-2024-10491

# CVE-2024-29041: Express Open Redirect vulnerability
# Fixed in Express 4.19.2+
# Our installed version is Express 4.21.2 which includes the fix
CVE-2024-29041
`````

## File: AGENTS.md
`````markdown
# mycats-pro AGENTS ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³

## 0. ã‚¯ã‚¤ãƒƒã‚¯ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹

### 0-1. ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— & èµ·å‹•

- `pnpm install` / `pnpm install:all`: ãƒ«ãƒ¼ãƒˆã§ä¾å­˜é–¢ä¿‚ã‚’åŒæœŸã€‚Node.js 20.x + pnpm 9.x ã‚’ä½¿ç”¨ã€‚
- `pnpm setup`: `scripts/setup-dev.sh` ã‚’å‘¼ã³å‡ºã—ã€åˆå›ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã¨ç’°å¢ƒå¤‰æ•°ãƒã‚§ãƒƒã‚¯ã‚’å®Ÿæ–½ã€‚
- `pnpm dev` / `pnpm dev:stable`: `backend:dev` (PORT=3004) â†’ `frontend:dev` (PORT=3000) â†’ `prisma:sync` ã®é †ã§ç«‹ã¡ä¸Šã’ã€‚åœæ­¢ã¯ `pnpm dev:stop`ã€‚
- DB æ“ä½œ: `pnpm db:migrate`, `pnpm db:seed`, `pnpm prisma:studio`ã€‚PostgreSQL 15+ ã‚’å‰æã€‚

### 0-2. ãƒ†ã‚¹ãƒˆ / é™çš„è§£æ

- ãƒ«ãƒ¼ãƒˆå“è³ªã‚²ãƒ¼ãƒˆ: `pnpm lint`ï¼ˆ`lint:root`, `lint:backend`, `lint:frontend` ã‚’ä¸¦åˆ—å®Ÿè¡Œï¼‰ã€‚
- ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰: `pnpm --filter backend run test:e2e -- --passWithNoTests`ã€`pnpm backend:build`ã€‚
- ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰: `pnpm frontend:lint`, `pnpm frontend:build`ã€‚
- è»½é‡ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯: `pnpm dev:health`ã€API ç…™ãƒ†ã‚¹ãƒˆ `pnpm api:smoke`ã€‚

### 0-3. PR å‰ã‚»ãƒ«ãƒ•ãƒã‚§ãƒƒã‚¯

1. `pnpm lint` â†’ `pnpm backend:build` â†’ `pnpm frontend:build`ã€‚
2. `pnpm db:migrate` + `pnpm db:seed` ã§ã‚¹ã‚­ãƒ¼ãƒå·®åˆ†ã‚’æ¤œè¨¼ï¼ˆPrisma å¤‰æ›´æ™‚ï¼‰ã€‚
3. å¿…è¦ã«å¿œã˜ã¦ `pnpm test:e2e`ã€`pnpm frontend:test`ï¼ˆå­˜åœ¨æ™‚ï¼‰ã‚’è¿½åŠ å®Ÿè¡Œã€‚
4. `pnpm dev:health` ãŒ 200 ã‚’è¿”ã™ã“ã¨ã‚’ç¢ºèªã€‚

è¨˜è¼‰ã•ã‚ŒãŸã‚³ãƒãƒ³ãƒ‰ã¯ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒè‡ªå‹•ã§å®Ÿè¡Œã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚å¤±æ•—æ™‚ã¯åŸå› èª¿æŸ»ã¨å†å®Ÿè¡Œã‚’è¡Œã£ã¦ãã ã•ã„ã€‚

---

## 1. è¨€èªè¨­å®šã¨ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³

- æœ¬ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯ **æ—¥æœ¬èª UI / ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ** ã‚’å‰æã¨ã—ã€ã‚„ã‚Šå–ã‚Šã‚‚æ—¥æœ¬èªã§çµ±ä¸€ã€‚
  - ãƒãƒ£ãƒƒãƒˆã€ãƒ¬ãƒ“ãƒ¥ãƒ¼ã€PR èª¬æ˜: ã™ã¹ã¦æ—¥æœ¬èªã§å›ç­”ã€‚
  - ã‚³ãƒ¼ãƒ‰ã‚³ãƒ¡ãƒ³ãƒˆ / README / è¨­è¨ˆè³‡æ–™: æ—¥æœ¬èªã§è¨˜è¿°ã€‚
  - ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: å¯èƒ½ãªé™ã‚Šæ—¥æœ¬èªã§è¡¨ç¤ºã—ã€é–‹ç™ºè€…å‘ã‘ãƒ­ã‚°ã‚‚æ—¥æœ¬èªã‚³ãƒ¡ãƒ³ãƒˆã‚’æ·»ä»˜ã€‚
- å¤‰æ•°å / é–¢æ•°å / å‹åã¯å›½éš›æ…£ç¿’ã«å¾“ã„è‹±èªã§çµ±ä¸€ã€‚
- æ©Ÿæ¢°ç¿»è¨³æ„Ÿã‚’é¿ã‘ã€ç°¡æ½”ã§å®Ÿå‹™çš„ãªæ—¥æœ¬èªã‚’å¿ƒæ›ã‘ã‚‹ã€‚

---

## 2. ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ç›®çš„

- mycats-pro ã§å‹•ã **AI ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå°‚ç”¨ã®è¡Œå‹•è¦ç¯„ + ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ**ã€‚
- ç›®æ¨™:
  1. ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒæœ€çŸ­ã§ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆèƒŒæ™¯ã¨é–‹ç™ºãƒ•ãƒ­ãƒ¼ã‚’ç†è§£ã™ã‚‹ã“ã¨ã€‚
  2. Next.js / NestJS / Prisma å…¬å¼ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã«æ²¿ã£ãŸã€å®‰å…¨ã§ä¸€è²«æ€§ã®ã‚ã‚‹å¤‰æ›´ã‚’è¡Œã†ã“ã¨ã€‚
  3. å‹å®‰å…¨ãƒ»æœ€å°å·®åˆ†ãƒ»å†åˆ©ç”¨å„ªå…ˆã§ã€ä¸è¦ãªç ´å£Šçš„å¤‰æ›´ã‚„ãƒã‚¤ã‚ºã‚’é˜²ãã“ã¨ã€‚

---

## 3. æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯ã¨å‰æ

- ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰: Next.js 15 (App Router + React Server Components) / React 19 / TypeScript 5 / Mantine / Tailwind CSSã€‚
- ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰: NestJS 10 / Prisma 6.14.0 / PostgreSQL 15+ã€‚
- é–‹ç™ºç’°å¢ƒ: Node.js 20.x / pnpm 9.x / macOS + Docker Composeï¼ˆãƒ­ãƒ¼ã‚«ãƒ« DBï¼‰ã€‚
- å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¨æœ¬ãƒ•ã‚¡ã‚¤ãƒ«ãŒçŸ›ç›¾ã—ãŸå ´åˆã¯ **å…¬å¼ä»•æ§˜ã‚’å„ªå…ˆ** ã—ã€å·®åˆ†ç†ç”±ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã§å…±æœ‰ã—ã¦ãã ã•ã„ã€‚

---

## 4. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ ã¨å‚ç…§ã‚¬ã‚¤ãƒ‰

- `frontend/`: App Router é…ä¸‹ã®ãƒšãƒ¼ã‚¸ã¯ `src/app/**/page.tsx`ã€‚å…±æœ‰ UI ã¯ `src/components/` ã«é›†ç´„ã€‚
- `backend/`: NestJS ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒ `src/**` ã«ç¸¦å‰²ã‚Šã§é…ç½®ã€‚Prisma ã‚¹ã‚­ãƒ¼ãƒã¯ `prisma/schema.prisma`ã€ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¯ `prisma/migrations/`ã€‚
- `docs/`, `DATABASE_*.md`: ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆãƒ»ER å›³ãƒ»é‹ç”¨ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã€‚
- å‘½åè¦ç´„: `docs/naming_convention_guidelines_v2.md` ã‚’å¸¸ã«å‚ç…§ã—ã€å‘½åæ–¹é‡ã®æ›´æ–°ãŒã‚ã‚Œã°æœ¬ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã‚»ãƒƒãƒˆã§åæ˜ ã€‚
- `scripts/`, `nginx/`, `docker-compose.yml`: é–‹ç™ºãƒ»é…å¸ƒã‚¹ã‚¯ãƒªãƒ—ãƒˆã¨ã‚¤ãƒ³ãƒ•ãƒ©å®šç¾©ã€‚
- **é…ç½®ãƒ«ãƒ¼ãƒ«**: æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«ã¯è²¬å‹™ãŒæœ€ã‚‚è¿‘ã„ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¸ç½®ãã€æ—¢å­˜å‘½åè¦å‰‡ã«å¾“ã†ã“ã¨ã€‚

### 4-1. ãƒ•ã‚©ãƒ«ãƒ€å°‚ç”¨ã‚¬ã‚¤ãƒ‰ (`CODE_GUIDE.md`)

- ä¸»è¦ãƒ•ã‚©ãƒ«ãƒ€ã«ã¯ãƒ­ãƒ¼ã‚«ãƒ«ãƒ«ãƒ¼ãƒ«ã‚’ã¾ã¨ã‚ãŸ `CODE_GUIDE.md` ã‚’è¨­ç½®æ¸ˆã€‚
- å¤‰æ›´å¯¾è±¡ã®ç›´ä¸‹ã«è©²å½“ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚‹å ´åˆã¯ **å¿…èª­**ã€‚ã“ã“ã§å®šç¾©ã•ã‚ŒãŸãƒ­ãƒ¼ã‚«ãƒ«è¦ç´„ã¯æœ¬ãƒ•ã‚¡ã‚¤ãƒ«ã‚ˆã‚Šå„ªå…ˆã€‚

---

## 5. AGENTS.md ã®èª­ã¿æ–¹ / é‹ç”¨

- ãƒ«ãƒ¼ãƒˆ `AGENTS.md` ã¯å…±é€šãƒ«ãƒ¼ãƒ«ã€‚å¿…è¦ã«å¿œã˜ã¦ã‚µãƒ–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«è¿½åŠ ã® `AGENTS.md` ã‚’é…ç½®ã—ã¦ã‚‚ã‚ˆã„ï¼ˆæœ€ã‚‚è¿‘ã„ãƒ•ã‚¡ã‚¤ãƒ«ãŒå„ªå…ˆã•ã‚Œã‚‹ï¼‰ã€‚
- å¤‰æ›´ã‚’åŠ ãˆãŸã‚‰å¿…ãšæœ¬ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æœ€æ–°ã®çŠ¶æ…‹ã«ä¿ã¡ã€PR èª¬æ˜ã«ã‚‚æ›´æ–°å†…å®¹ã‚’è¨˜è¼‰ã€‚
- ä»–ãƒ„ãƒ¼ãƒ«ï¼ˆAider / Gemini CLI ç­‰ï¼‰ã¨ä½µç”¨ã™ã‚‹å ´åˆã‚‚ãƒ•ã‚¡ã‚¤ãƒ«åã¯ `AGENTS.md` ã«çµ±ä¸€ã™ã‚‹ã€‚
- ãƒ«ãƒ¼ãƒ«ã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼æŒ‡ç¤ºã«çŸ›ç›¾ãŒç™ºç”Ÿã—ãŸå ´åˆã¯ã€ä½œæ¥­ã‚’ä¸­æ–­ã—ã¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«å„ªå…ˆé †ä½ï¼ˆã©ã¡ã‚‰ã‚’æ¡ç”¨ã™ã‚‹ã‹ï¼‰ã‚’ç¢ºèªã—ã€åˆ¤æ–­ã‚’å¾—ã¦ã‹ã‚‰å†é–‹ã™ã‚‹ã€‚

---

## 6. ä½œæ¥­ãƒ•ãƒ­ãƒ¼ã¨å“è³ªã‚²ãƒ¼ãƒˆ

1. **èª¿æŸ»**: é–¢é€£ãƒ•ã‚¡ã‚¤ãƒ«ãƒ»æ—¢å­˜å®Ÿè£…ãƒ»`CODE_GUIDE.md` ã‚’ç¢ºèªã€‚æ—¢å­˜ãƒ†ã‚¹ãƒˆã‚„å‹å®šç¾©ã‚’å…ˆã«æŠŠæ¡ã™ã‚‹ã€‚
2. **ã‚¿ã‚¤ãƒ—ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆ**: å¤‰æ›´å†…å®¹ã«å¯¾ã™ã‚‹å‹ (`interface / type / DTO / Zod schema`) ã‚’æ›´æ–° â†’ å®Ÿè£… â†’ ãƒ†ã‚¹ãƒˆã®é †ã§ä½œæ¥­ã€‚
3. **è‡ªå‹•åŒ–ãƒã‚§ãƒƒã‚¯**: å¤‰æ›´ã«å½±éŸ¿ã™ã‚‹ãƒ†ã‚¹ãƒˆ / Lint / å‹ãƒã‚§ãƒƒã‚¯ã‚’å³æ™‚å®Ÿè¡Œã—ã€å¤±æ•—ã‚’è§£æ¶ˆã€‚
4. **è‡ªå·±ãƒ¬ãƒ“ãƒ¥ãƒ¼**: å½±éŸ¿ç¯„å›²ã€ä¾‹å¤–å‡¦ç†ã€ç¿»è¨³ã®æ•´åˆæ€§ã€doc æ›´æ–°ã‚’ç¢ºèªã€‚

è£œè¶³ï¼ˆãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã®å†ç™ºé˜²æ­¢ï¼‰:

- Controller ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ä¾å­˜ï¼ˆæ³¨å…¥ã™ã‚‹ Serviceï¼‰ã‚’è¿½åŠ ãƒ»å¤‰æ›´ã—ãŸå ´åˆã€å¯¾å¿œã™ã‚‹ `*.controller.spec.ts` ã® `Test.createTestingModule` ã® `providers`ï¼ˆã¾ãŸã¯ `overrideProvider`ï¼‰ã‚‚å¿…ãšè¿½éšã•ã›ã‚‹ã€‚


æœ€ä½é™ã€ä»¥ä¸‹ã®å“è³ªã‚²ãƒ¼ãƒˆã‚’ PASS ã•ã›ã¦ã‹ã‚‰ä½œæ¥­å®Œäº†ã¨ã™ã‚‹:

- `pnpm lint`ï¼ˆroot + frontend + backendï¼‰ã€‚
- å½±éŸ¿ã—ãŸãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã® `pnpm build` / `pnpm test`ã€‚
- Prisma å¤‰æ›´æ™‚ã¯ `pnpm db:migrate` + `pnpm db:seed` ã§å†ç¾ç¢ºèªã€‚

---

## 7. å‹å®‰å…¨ãƒãƒªã‚·ãƒ¼ï¼ˆå³æ ¼ç‰ˆï¼‰

- `any` / `unknown` ã®ä½¿ç”¨ã¯ç¦æ­¢ã€‚ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®åˆ¶ç´„ã§ä¸å¯é¿ãªå ´åˆã®ã¿ã€**è©²å½“è¡Œã«ç†ç”±ã‚³ãƒ¡ãƒ³ãƒˆã‚’è¨˜è¼‰**ã—ã€å‹ã‚¬ãƒ¼ãƒ‰ã‚„ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã§éœ²å‡ºã‚’å±€æ‰€åŒ–ã™ã‚‹ã€‚

### 7-1. any / unknown ä¾‹å¤–æ¡ä»¶ï¼ˆã™ã¹ã¦å¿…é ˆï¼‰

1. å¤–éƒ¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å‹å®šç¾©ãŒå®Ÿæ…‹ã¨ç•°ãªã‚Šä¿®æ­£ä¸èƒ½
2. ä»¥ä¸‹ã®ä»£æ›¿æ¡ˆã‚’ã™ã¹ã¦è©¦è¡Œã—å¤±æ•—:
   - å‹ã‚¬ãƒ¼ãƒ‰
   - Partial / Pick / Omit
   - ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹
   - å‹ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³
   - ãƒ©ã‚¤ãƒ–ãƒ©ãƒªæ›´æ–°ãƒ»ä»£æ›¿æ¤œè¨
3. è©²å½“è¡Œã«ä»¥ä¸‹ã‚’å¿…ãšè¨˜è¼‰:
   - è©¦è¡Œã—ãŸä»£æ›¿æ¡ˆã¨çµæœ
   - any ä½¿ç”¨ç†ç”±
   - å½±éŸ¿ç¯„å›²æœ€å°åŒ–æ–¹æ³•

- é null ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆ`!`ï¼‰ã¯ç¦æ­¢ã€‚nullable ã‚’æ‰±ã†éš›ã¯ã‚¬ãƒ¼ãƒ‰ã‚„ `if (!value) return` ã§å®‰å…¨ã«æ‰±ã†ã€‚
- ä¹±æš´ãªäºŒæ®µã‚­ãƒ£ã‚¹ãƒˆï¼ˆ`value as unknown as X`, `as any`ï¼‰ã¯ç¦æ­¢ã€‚å¿…è¦ãªå ´åˆã¯å‹ã‚¬ãƒ¼ãƒ‰ãƒ»åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…ã€‚
- `// eslint-disable` / `@ts-ignore` ã¯åŸå‰‡ç¦æ­¢ã€‚ã‚„ã‚€ã‚’å¾—ãªã„å ´åˆã¯ 1 è¡Œé™å®š + ç†ç”±ã‚³ãƒ¡ãƒ³ãƒˆã€‚
- ESLint / tsconfig ã®è¨­å®šã§å‹ã‚¨ãƒ©ãƒ¼ã‚’é»™æ®ºã™ã‚‹ã“ã¨ã¯ç¦æ­¢ã€‚ã‚¨ãƒ©ãƒ¼åŸå› ã‚’ã‚³ãƒ¼ãƒ‰ã§è§£æ±ºã™ã‚‹ã€‚
- ã™ã¹ã¦ã®å…¬é–‹é–¢æ•°ãƒ»ã‚¯ãƒ©ã‚¹ã¯å¼•æ•°ãƒ»æˆ»ã‚Šå€¤ã‚’å®Œå…¨ã«å‹å®šç¾©ã€‚`Promise` é–¢æ•°ã¯ `Promise<ResultType>` ã‚’æ˜ç¤ºã€‚
- åˆ†å²ã¯å¯èƒ½ãªé™ã‚Š **exhaustiveness check** ã‚’å®Ÿæ–½ï¼ˆ`switch` + `never`ï¼‰ã€‚
- API å…¥å‡ºåŠ›ã¯æ—¢å­˜ DTO / Prisma å‹ / å…±é€š `types/` ã‚’å†åˆ©ç”¨ã€‚é‡è¤‡å®šç¾©ã‚’é¿ã‘ã€å‹ãŒè¶³ã‚Šãªã„å ´åˆã¯å…±é€šå ´æ‰€ã«è¿½åŠ ã—ã¦ã‹ã‚‰ä½¿ç”¨ã™ã‚‹ã€‚

---

## 8. ã‚¨ãƒ©ãƒ¼å‡¦ç†ã¨ãƒ­ã‚®ãƒ³ã‚°

- ç©ºã® `catch`ã€`console.error` ã®ã¿ã§çµ‚äº†ã€`void someAsync()` ã®æ”¾ç½®ã¯ç¦æ­¢ã€‚
- ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰: NestJS ã®ä¾‹å¤–ãƒ•ã‚£ãƒ«ã‚¿ (`HttpException`, `BadRequestException`, ã‚«ã‚¹ã‚¿ãƒ ä¾‹å¤–) ã¨ãƒ­ã‚¬ãƒ¼ã‚’ä½¿ç”¨ã€‚
- ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰: ãƒ¦ãƒ¼ã‚¶ãƒ¼å‘ã‘ã«æ—¥æœ¬èªã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã—ã€å¿…è¦ã«å¿œã˜ã¦ãƒˆãƒ¼ã‚¹ãƒˆ/ãƒãƒŠãƒ¼ãªã©ã§çŠ¶æ…‹ç®¡ç†ã€‚
- `unknown` ãªã‚¨ãƒ©ãƒ¼ã¯å‹ã‚¬ãƒ¼ãƒ‰ã§åˆ†é¡ã—ã€å¿…è¦ãªã‚‰ `instanceof` åˆ¤å®šã‚„ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ã§åˆ†å²ã€‚

---

## 9. å¤‰æ›´ã‚¹ã‚³ãƒ¼ãƒ—ã¨å†åˆ©ç”¨

- ä¾é ¼ç¯„å›²ä»¥å¤–ã®å¤§è¦æ¨¡ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã¯ç¦æ­¢ã€‚è§¦ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«å†…ã®æ˜ã‚‰ã‹ãªä¸å…·åˆã®ã¿å‰¯æ¬¡çš„ã«ä¿®æ­£å¯ã€‚
- æ—¢å­˜ã® API / DTO / UI ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ / ã‚µãƒ¼ãƒ“ã‚¹ã‚’ã¾ãšæ¢ç´¢ã—ã€å†åˆ©ç”¨ã§ããªã„ã‹ç¢ºèªã™ã‚‹ã€‚
- åŒã˜ãƒ­ã‚¸ãƒƒã‚¯ã‚’è¤‡è£½ã›ãšã€æŠ½è±¡åŒ–ã¾ãŸã¯å…±é€šåŒ–ã‚’æ¤œè¨ã€‚é‡è¤‡ãŒå¿…è¦ãã†ãªå ´åˆã¯æ ¹æ‹ ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã§èª¬æ˜ã€‚

---

## 10. Next.jsï¼ˆApp Routerï¼‰ã‚¬ã‚¤ãƒ‰

1. `frontend/src/app` é…ä¸‹ã§ App Router è¦ç´„ï¼ˆ`page.tsx`, `layout.tsx`, `loading.tsx`, `error.tsx` ç­‰ï¼‰ã‚’éµå®ˆã€‚
2. ã‚µãƒ¼ãƒãƒ¼ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå„ªå…ˆã€‚`use client` ã¯æœ€å°é™ã«ã—ã€`client` ã‚’ä»˜ã‘ã‚‹ç†ç”±ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã§å…±æœ‰ã€‚
3. ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚§ãƒƒãƒã¯ã‚µãƒ¼ãƒãƒ¼å´ã§å®Ÿè¡Œã—ã€`fetch` ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥ï¼ˆ`revalidate` ç­‰ï¼‰ã‚’æ˜ç¤ºã€‚
4. ãƒ•ã‚©ãƒ¼ãƒ /ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã‚µãƒ¼ãƒãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ or API Route ã‚’æ´»ç”¨ã—ã€CSRFãƒ»ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è€ƒæ…®ã€‚

---

## 11. NestJS + Prisma ã‚¬ã‚¤ãƒ‰

1. Controller â†’ Service â†’ Repository/Prisma ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å®ˆã‚Šã€Controller ã§ç›´æ¥ Prisma ã‚’å‘¼ã°ãªã„ã€‚
2. DTO + `class-validator` ã§å…¥å‡ºåŠ›ã‚’å®šç¾©ã€‚ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ•´å½¢ç”¨ã® Presenter / Serializer ã‚’å°å…¥ã—ã¦ã‚‚ã‚ˆã„ã€‚
3. Prisma ã‚¯ã‚¨ãƒªã¯ `select` / `include` ã§å¿…è¦ãªãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«é™å®šã—ã€N+1 ã‚’é¿ã‘ã‚‹ã€‚
4. `schema.prisma` å¤‰æ›´æ™‚ã¯ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ç”Ÿæˆã—ã€å½±éŸ¿ç¯„å›²ï¼ˆç ´å£Šçš„ã‹å¦ã‹ï¼‰ã‚’ PR ã§èª¬æ˜ã€‚

---

## 12. Dev Environment Tips

- `pnpm help` ã§åˆ©ç”¨å¯èƒ½ãªä¸»è¦ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ä¸€è¦§ç¢ºèªã§ãã‚‹ã€‚
- `scripts/` é…ä¸‹ã®ã‚·ã‚§ãƒ«ã‚¹ã‚¯ãƒªãƒ—ãƒˆï¼ˆä¾‹: `start-dev-stable.sh`, `preflight-backend.sh`ï¼‰ã¯ macOS + zsh å‰æã€‚å¿…è¦ã«å¿œã˜ã¦ `chmod +x` æ¸ˆã‹ç¢ºèªã€‚
- ãƒ­ãƒ¼ã‚«ãƒ« DB åˆæœŸåŒ–ã¯ `init_database.sql` / `seed_data.sql` ã‚’å‚ç…§ã€‚Docker Compose ã§ `database/init` ãŒè‡ªå‹•é©ç”¨ã•ã‚Œã‚‹ã€‚

---

## 13. AI ã¸ã®ä¾é ¼ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ

### 13-1. æ©Ÿèƒ½è¿½åŠ ãƒªã‚¯ã‚¨ã‚¹ãƒˆ

```text
ã‚ãªãŸã¯ mycats-pro ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå°‚ä»»ã® AI ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§ã™ã€‚
Next.js 15ï¼ˆApp Routerï¼‰+ React 19 + NestJS 10 + Prisma 6 + PostgreSQL 15 ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã¨ã€
ãƒªãƒã‚¸ãƒˆãƒªç›´ä¸‹ã® AGENTS.md / è©²å½“ãƒ•ã‚©ãƒ«ãƒ€ã® CODE_GUIDE.md ã«å¾“ã£ã¦ãã ã•ã„ã€‚

ã€ã‚„ã‚ŠãŸã„ã“ã¨ã€‘
- æ©Ÿèƒ½æ¦‚è¦: ï¼ˆã“ã“ã«æ¦‚è¦ã‚’æ›¸ãï¼‰
- å¯¾è±¡ç”»é¢ / API: ï¼ˆä¾‹: frontend/src/app/cats, backend/src/cats ãªã©ï¼‰

ã€å¿…ãšå®ˆã£ã¦ã»ã—ã„ã“ã¨ã€‘
- any/unknown / é null ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã¯ç¦æ­¢ã€‚å‹å®šç¾© â†’ å®Ÿè£… â†’ ãƒ†ã‚¹ãƒˆã®é †ã§æ›´æ–°ã€‚
- ã‚¨ãƒ©ãƒ¼å‡¦ç†ã¯ Next.js / NestJS ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã«å¾“ã„ã€æ—¥æœ¬èªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿”ã™ã€‚
- ç„¡é–¢ä¿‚ãªãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã‚’é¿ã‘ã€æ—¢å­˜ã®ä¼¼ãŸå®Ÿè£…ã‚’å†åˆ©ç”¨ã€‚

ã€å‡ºåŠ›ã—ã¦ã»ã—ã„ã“ã¨ã€‘
1. å¤‰æ›´ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ï¼ˆå½¹å‰²ä»˜ãï¼‰
2. ä¸»è¦ãªã‚³ãƒ¼ãƒ‰å¤‰æ›´ç‚¹ + å‹å®‰å…¨æ€§ã®ãƒã‚¤ãƒ³ãƒˆ
3. è¿½åŠ  / æ›´æ–°ã—ãŸãƒ†ã‚¹ãƒˆã¨æ„å›³
4. å®Ÿè¡Œã—ãŸã‚³ãƒãƒ³ãƒ‰ã¨å†ç¾æ‰‹é †ï¼ˆpnpm ãƒ™ãƒ¼ã‚¹ï¼‰
```

### 13-2. ãƒã‚°ä¿®æ­£ãƒªã‚¯ã‚¨ã‚¹ãƒˆ

```text
ã‚ãªãŸã¯ mycats-pro ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå°‚ä»»ã® AI ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§ã™ã€‚
Next.js / NestJS / Prisma ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã¨ AGENTS.md ã«å¾“ã£ã¦ã€ä»¥ä¸‹ã®ãƒã‚°ã‚’ä¿®æ­£ã—ã¦ãã ã•ã„ã€‚

ã€ãƒã‚°å†…å®¹ã€‘
- ç¾è±¡: ï¼ˆä½•ãŒã©ã†ãŠã‹ã—ã„ã‹ï¼‰
- å†ç¾æ‰‹é †: ï¼ˆURL, æ“ä½œæ‰‹é †ãªã©ï¼‰
- æœŸå¾…ã™ã‚‹æŒ™å‹•: ï¼ˆã©ã†ãªã£ã¦ã„ã¦ã»ã—ã„ã‹ï¼‰

ã€åˆ¶ç´„ã€‘
- ä¿®æ­£ç¯„å›²ã‚’åŸå› ç®‡æ‰€å‘¨è¾ºã«é™å®šã—ã€any/unknown ã‚’ä½¿ã‚ãšã«è§£æ±ºã€‚
- `@ts-ignore` ã‚„ `eslint-disable` ã‚’ä½¿ã‚ãªã„ã€‚ã©ã†ã—ã¦ã‚‚å¿…è¦ãªã‚‰ç†ç”±ã¨æ’¤å»ãƒ¡ãƒ¢ã‚’æ®‹ã™ã€‚
- å†ç™ºé˜²æ­¢ãƒ†ã‚¹ãƒˆã‚’è¿½åŠ ï¼ˆãƒ¦ãƒ‹ãƒƒãƒˆ or e2eï¼‰ã€‚

ã€å‡ºåŠ›ã—ã¦ã»ã—ã„ã“ã¨ã€‘
1. æƒ³å®šåŸå› ã¨æ ¹æ‹ 
2. ä¿®æ­£ãƒ•ã‚¡ã‚¤ãƒ«ã¨å¤‰æ›´æ¦‚è¦
3. è¿½åŠ  / æ›´æ–°ã—ãŸãƒ†ã‚¹ãƒˆå†…å®¹
4. å†ç¾ç¢ºèªã¨å›å¸°ç¢ºèªã«ä½¿ç”¨ã—ãŸã‚³ãƒãƒ³ãƒ‰
```

---

## 14. æœŸå¾…ã™ã‚‹å›ç­”ã‚¹ã‚¿ã‚¤ãƒ«

- æ—¥æœ¬èªã§ç°¡æ½”ã‹ã¤æƒ…å ±å¯†åº¦ã®é«˜ã„èª¬æ˜ã‚’è¡Œã†ã€‚ç„¡é§„ãªå‰ç½®ãã‚„æ„Ÿæƒ³ã‚’çœãã€äº‹å®Ÿã¨æ‰‹é †ã‚’å„ªå…ˆã€‚
- mycats-pro å›ºæœ‰ã®æ–‡è„ˆã«ç´ã¥ã‘ã¦èª¬æ˜ã—ã€ä¸€èˆ¬è«–ã ã‘ã§çµ‚ã‚ã‚‰ã›ãªã„ã€‚
- ã‚³ãƒ¼ãƒ‰ã¯å¿…è¦æœ€å°é™ã®æŠœç²‹ã«ç•™ã‚ã€ãƒ‘ã‚¹ãƒ»é–¢æ•°åã‚’æ˜ç¤ºã€‚
- å¯èƒ½ãªé™ã‚Šãƒ†ã‚¹ãƒˆæˆ¦ç•¥ã¨å®Ÿè¡Œã‚³ãƒãƒ³ãƒ‰ã‚’ä½µè¨˜ã—ã€å“è³ªã‚²ãƒ¼ãƒˆã‚’æ˜æ–‡åŒ–ã€‚

---
`````

## File: backend/prisma/migrations/20251004195835_init/migration.sql
`````sql
-- CreateEnum
CREATE TYPE "UserRole" AS ENUM ('USER', 'ADMIN', 'SUPER_ADMIN');

-- CreateEnum
CREATE TYPE "Gender" AS ENUM ('MALE', 'FEMALE');

-- CreateEnum
CREATE TYPE "BreedingStatus" AS ENUM ('PLANNED', 'IN_PROGRESS', 'COMPLETED', 'FAILED');

-- CreateEnum
CREATE TYPE "CareType" AS ENUM ('VACCINATION', 'HEALTH_CHECK', 'GROOMING', 'DENTAL_CARE', 'MEDICATION', 'SURGERY', 'OTHER');

-- CreateEnum
CREATE TYPE "ScheduleType" AS ENUM ('BREEDING', 'CARE', 'APPOINTMENT', 'REMINDER', 'MAINTENANCE');

-- CreateEnum
CREATE TYPE "ScheduleStatus" AS ENUM ('PENDING', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED');

-- CreateEnum
CREATE TYPE "Priority" AS ENUM ('LOW', 'MEDIUM', 'HIGH', 'URGENT');

-- CreateTable
CREATE TABLE "users" (
    "id" TEXT NOT NULL,
    "clerk_id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "first_name" TEXT,
    "last_name" TEXT,
    "role" "UserRole" NOT NULL DEFAULT 'USER',
    "is_active" BOOLEAN NOT NULL DEFAULT true,
    "password_hash" TEXT,
    "refresh_token" TEXT,
    "failed_login_attempts" INTEGER NOT NULL DEFAULT 0,
    "locked_until" TIMESTAMP(3),
    "last_login_at" TIMESTAMP(3),
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "users_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "login_attempts" (
    "id" TEXT NOT NULL,
    "user_id" TEXT,
    "email" TEXT NOT NULL,
    "ip_address" TEXT,
    "user_agent" TEXT,
    "success" BOOLEAN NOT NULL,
    "reason" TEXT,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "login_attempts_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "breeds" (
    "id" TEXT NOT NULL,
    "code" INTEGER NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "is_active" BOOLEAN NOT NULL DEFAULT true,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "breeds_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "coat_colors" (
    "id" TEXT NOT NULL,
    "code" INTEGER NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "is_active" BOOLEAN NOT NULL DEFAULT true,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "coat_colors_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "cats" (
    "id" TEXT NOT NULL,
    "registration_id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "breed_id" TEXT,
    "color_id" TEXT,
    "legacy_breed" TEXT,
    "legacy_color" TEXT,
    "pattern" TEXT,
    "gender" "Gender" NOT NULL,
    "birth_date" TIMESTAMP(3) NOT NULL,
    "weight" DOUBLE PRECISION,
    "microchip_id" TEXT,
    "is_active" BOOLEAN NOT NULL DEFAULT true,
    "notes" TEXT,
    "image_url" TEXT,
    "father_id" TEXT,
    "mother_id" TEXT,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,
    "pedigree_id" TEXT,

    CONSTRAINT "cats_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "breeding_records" (
    "id" TEXT NOT NULL,
    "male_id" TEXT NOT NULL,
    "female_id" TEXT NOT NULL,
    "breeding_date" TIMESTAMP(3) NOT NULL,
    "expected_due_date" TIMESTAMP(3),
    "actual_due_date" TIMESTAMP(3),
    "number_of_kittens" INTEGER,
    "notes" TEXT,
    "status" "BreedingStatus" NOT NULL DEFAULT 'PLANNED',
    "recorded_by" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "breeding_records_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "care_records" (
    "id" TEXT NOT NULL,
    "cat_id" TEXT NOT NULL,
    "care_type" "CareType" NOT NULL,
    "description" TEXT NOT NULL,
    "care_date" TIMESTAMP(3) NOT NULL,
    "next_due_date" TIMESTAMP(3),
    "cost" DOUBLE PRECISION,
    "veterinarian" TEXT,
    "notes" TEXT,
    "recorded_by" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "care_records_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "schedules" (
    "id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT,
    "schedule_date" TIMESTAMP(3) NOT NULL,
    "schedule_type" "ScheduleType" NOT NULL,
    "status" "ScheduleStatus" NOT NULL DEFAULT 'PENDING',
    "priority" "Priority" NOT NULL DEFAULT 'MEDIUM',
    "cat_id" TEXT,
    "assigned_to" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "schedules_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "tags" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "color" TEXT NOT NULL DEFAULT '#3B82F6',
    "description" TEXT,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "tags_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "pedigrees" (
    "id" TEXT NOT NULL,
    "pedigree_id" TEXT NOT NULL,
    "title" TEXT,
    "cat_name" TEXT,
    "cat_name2" TEXT,
    "breed_code" INTEGER,
    "gender_code" INTEGER,
    "eye_color" TEXT,
    "coat_color_code" INTEGER,
    "birth_date" TEXT,
    "breeder_name" TEXT,
    "owner_name" TEXT,
    "registration_date" TEXT,
    "brother_count" INTEGER,
    "sister_count" INTEGER,
    "notes" TEXT,
    "notes2" TEXT,
    "other_no" TEXT,
    "father_title" TEXT,
    "father_cat_name" TEXT,
    "father_cat_name2" TEXT,
    "father_coat_color" TEXT,
    "father_eye_color" TEXT,
    "father_jcu" TEXT,
    "father_other_code" TEXT,
    "mother_title" TEXT,
    "mother_cat_name" TEXT,
    "mother_cat_name2" TEXT,
    "mother_coat_color" TEXT,
    "mother_eye_color" TEXT,
    "mother_jcu" TEXT,
    "mother_other_code" TEXT,
    "ff_title" TEXT,
    "ff_cat_name" TEXT,
    "ff_cat_color" TEXT,
    "ff_jcu" TEXT,
    "fm_title" TEXT,
    "fm_cat_name" TEXT,
    "fm_cat_color" TEXT,
    "fm_jcu" TEXT,
    "mf_title" TEXT,
    "mf_cat_name" TEXT,
    "mf_cat_color" TEXT,
    "mf_jcu" TEXT,
    "mm_title" TEXT,
    "mm_cat_name" TEXT,
    "mm_cat_color" TEXT,
    "mm_jcu" TEXT,
    "fff_title" TEXT,
    "fff_cat_name" TEXT,
    "fff_cat_color" TEXT,
    "fff_jcu" TEXT,
    "ffm_title" TEXT,
    "ffm_cat_name" TEXT,
    "ffm_cat_color" TEXT,
    "ffm_jcu" TEXT,
    "fmf_title" TEXT,
    "fmf_cat_name" TEXT,
    "fmf_cat_color" TEXT,
    "fmf_jcu" TEXT,
    "fmm_title" TEXT,
    "fmm_cat_name" TEXT,
    "fmm_cat_color" TEXT,
    "fmm_jcu" TEXT,
    "mff_title" TEXT,
    "mff_cat_name" TEXT,
    "mff_cat_color" TEXT,
    "mff_jcu" TEXT,
    "mfm_title" TEXT,
    "mfm_cat_name" TEXT,
    "mfm_cat_color" TEXT,
    "mfm_jcu" TEXT,
    "mmf_title" TEXT,
    "mmf_cat_name" TEXT,
    "mmf_cat_color" TEXT,
    "mmf_jcu" TEXT,
    "mmm_title" TEXT,
    "mmm_cat_name" TEXT,
    "mmm_cat_color" TEXT,
    "mmm_jcu" TEXT,
    "old_code" TEXT,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "pedigrees_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "cat_tags" (
    "cat_id" TEXT NOT NULL,
    "tag_id" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "cat_tags_pkey" PRIMARY KEY ("cat_id","tag_id")
);

-- CreateIndex
CREATE UNIQUE INDEX "users_clerk_id_key" ON "users"("clerk_id");

-- CreateIndex
CREATE UNIQUE INDEX "users_email_key" ON "users"("email");

-- CreateIndex
CREATE UNIQUE INDEX "breeds_code_key" ON "breeds"("code");

-- CreateIndex
CREATE UNIQUE INDEX "breeds_name_key" ON "breeds"("name");

-- CreateIndex
CREATE UNIQUE INDEX "coat_colors_code_key" ON "coat_colors"("code");

-- CreateIndex
CREATE UNIQUE INDEX "coat_colors_name_key" ON "coat_colors"("name");

-- CreateIndex
CREATE UNIQUE INDEX "cats_registration_id_key" ON "cats"("registration_id");

-- CreateIndex
CREATE UNIQUE INDEX "cats_microchip_id_key" ON "cats"("microchip_id");

-- CreateIndex
CREATE UNIQUE INDEX "tags_name_key" ON "tags"("name");

-- CreateIndex
CREATE UNIQUE INDEX "pedigrees_pedigree_id_key" ON "pedigrees"("pedigree_id");

-- AddForeignKey
ALTER TABLE "login_attempts" ADD CONSTRAINT "login_attempts_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "cats" ADD CONSTRAINT "cats_breed_id_fkey" FOREIGN KEY ("breed_id") REFERENCES "breeds"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "cats" ADD CONSTRAINT "cats_color_id_fkey" FOREIGN KEY ("color_id") REFERENCES "coat_colors"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "cats" ADD CONSTRAINT "cats_father_id_fkey" FOREIGN KEY ("father_id") REFERENCES "cats"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "cats" ADD CONSTRAINT "cats_mother_id_fkey" FOREIGN KEY ("mother_id") REFERENCES "cats"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "breeding_records" ADD CONSTRAINT "breeding_records_male_id_fkey" FOREIGN KEY ("male_id") REFERENCES "cats"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "breeding_records" ADD CONSTRAINT "breeding_records_female_id_fkey" FOREIGN KEY ("female_id") REFERENCES "cats"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "breeding_records" ADD CONSTRAINT "breeding_records_recorded_by_fkey" FOREIGN KEY ("recorded_by") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "care_records" ADD CONSTRAINT "care_records_cat_id_fkey" FOREIGN KEY ("cat_id") REFERENCES "cats"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "care_records" ADD CONSTRAINT "care_records_recorded_by_fkey" FOREIGN KEY ("recorded_by") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "schedules" ADD CONSTRAINT "schedules_cat_id_fkey" FOREIGN KEY ("cat_id") REFERENCES "cats"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "schedules" ADD CONSTRAINT "schedules_assigned_to_fkey" FOREIGN KEY ("assigned_to") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "cat_tags" ADD CONSTRAINT "cat_tags_cat_id_fkey" FOREIGN KEY ("cat_id") REFERENCES "cats"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "cat_tags" ADD CONSTRAINT "cat_tags_tag_id_fkey" FOREIGN KEY ("tag_id") REFERENCES "tags"("id") ON DELETE CASCADE ON UPDATE CASCADE;
`````

## File: backend/prisma/migrations/20251004205546_sync_pedigree_schema/migration.sql
`````sql
/*
  Warnings:

  - You are about to drop the column `ff_jcu` on the `pedigrees` table. All the data in the column will be lost.
  - You are about to drop the column `fff_jcu` on the `pedigrees` table. All the data in the column will be lost.
  - You are about to drop the column `ffm_jcu` on the `pedigrees` table. All the data in the column will be lost.
  - You are about to drop the column `fm_jcu` on the `pedigrees` table. All the data in the column will be lost.
  - You are about to drop the column `fmf_jcu` on the `pedigrees` table. All the data in the column will be lost.
  - You are about to drop the column `fmm_jcu` on the `pedigrees` table. All the data in the column will be lost.
  - You are about to drop the column `mf_jcu` on the `pedigrees` table. All the data in the column will be lost.
  - You are about to drop the column `mff_jcu` on the `pedigrees` table. All the data in the column will be lost.
  - You are about to drop the column `mfm_jcu` on the `pedigrees` table. All the data in the column will be lost.
  - You are about to drop the column `mm_jcu` on the `pedigrees` table. All the data in the column will be lost.
  - You are about to drop the column `mmf_jcu` on the `pedigrees` table. All the data in the column will be lost.
  - You are about to drop the column `mmm_jcu` on the `pedigrees` table. All the data in the column will be lost.

*/
-- AlterTable
ALTER TABLE "pedigrees" DROP COLUMN "ff_jcu",
DROP COLUMN "fff_jcu",
DROP COLUMN "ffm_jcu",
DROP COLUMN "fm_jcu",
DROP COLUMN "fmf_jcu",
DROP COLUMN "fmm_jcu",
DROP COLUMN "mf_jcu",
DROP COLUMN "mff_jcu",
DROP COLUMN "mfm_jcu",
DROP COLUMN "mm_jcu",
DROP COLUMN "mmf_jcu",
DROP COLUMN "mmm_jcu",
ADD COLUMN     "fffjcu" TEXT,
ADD COLUMN     "ffjcu" TEXT,
ADD COLUMN     "ffmjcu" TEXT,
ADD COLUMN     "fmfjcu" TEXT,
ADD COLUMN     "fmjcu" TEXT,
ADD COLUMN     "fmmjcu" TEXT,
ADD COLUMN     "mffjcu" TEXT,
ADD COLUMN     "mfjcu" TEXT,
ADD COLUMN     "mfmjcu" TEXT,
ADD COLUMN     "mmfjcu" TEXT,
ADD COLUMN     "mmjcu" TEXT,
ADD COLUMN     "mmmjcu" TEXT;
`````

## File: backend/prisma/migrations/20251005205115_add_password_reset_fields/migration.sql
`````sql
/*
  Warnings:

  - Changed the type of `gender` on the `cats` table. No cast exists, the column would be dropped and recreated, which cannot be done if there is data, since the column is required.

*/
-- AlterTable
ALTER TABLE "public"."cats" DROP COLUMN "gender",
ADD COLUMN     "gender" TEXT NOT NULL;

-- AlterTable
ALTER TABLE "public"."users" ADD COLUMN     "reset_password_expires" TIMESTAMP(3),
ADD COLUMN     "reset_password_token" TEXT;

-- DropEnum
DROP TYPE "public"."Gender";

-- CreateTable
CREATE TABLE "public"."genders" (
    "id" TEXT NOT NULL,
    "code" INTEGER NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "is_active" BOOLEAN NOT NULL DEFAULT true,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "genders_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "genders_code_key" ON "public"."genders"("code");

-- CreateIndex
CREATE UNIQUE INDEX "genders_name_key" ON "public"."genders"("name");

-- AddForeignKey
ALTER TABLE "public"."pedigrees" ADD CONSTRAINT "pedigrees_breed_code_fkey" FOREIGN KEY ("breed_code") REFERENCES "public"."breeds"("code") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."pedigrees" ADD CONSTRAINT "pedigrees_coat_color_code_fkey" FOREIGN KEY ("coat_color_code") REFERENCES "public"."coat_colors"("code") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."pedigrees" ADD CONSTRAINT "pedigrees_gender_code_fkey" FOREIGN KEY ("gender_code") REFERENCES "public"."genders"("code") ON DELETE SET NULL ON UPDATE CASCADE;
`````

## File: backend/prisma/migrations/20251005212034_add_performance_indexes/migration.sql
`````sql
-- CreateIndex
CREATE INDEX "breeding_records_male_id_idx" ON "public"."breeding_records"("male_id");

-- CreateIndex
CREATE INDEX "breeding_records_female_id_idx" ON "public"."breeding_records"("female_id");

-- CreateIndex
CREATE INDEX "breeding_records_breeding_date_idx" ON "public"."breeding_records"("breeding_date");

-- CreateIndex
CREATE INDEX "breeding_records_status_idx" ON "public"."breeding_records"("status");

-- CreateIndex
CREATE INDEX "care_records_cat_id_idx" ON "public"."care_records"("cat_id");

-- CreateIndex
CREATE INDEX "care_records_care_date_idx" ON "public"."care_records"("care_date");

-- CreateIndex
CREATE INDEX "care_records_care_type_idx" ON "public"."care_records"("care_type");

-- CreateIndex
CREATE INDEX "cats_breed_id_idx" ON "public"."cats"("breed_id");

-- CreateIndex
CREATE INDEX "cats_father_id_idx" ON "public"."cats"("father_id");

-- CreateIndex
CREATE INDEX "cats_mother_id_idx" ON "public"."cats"("mother_id");

-- CreateIndex
CREATE INDEX "cats_birth_date_idx" ON "public"."cats"("birth_date");

-- CreateIndex
CREATE INDEX "pedigrees_breed_code_idx" ON "public"."pedigrees"("breed_code");

-- CreateIndex
CREATE INDEX "pedigrees_gender_code_idx" ON "public"."pedigrees"("gender_code");

-- CreateIndex
CREATE INDEX "pedigrees_coat_color_code_idx" ON "public"."pedigrees"("coat_color_code");

-- CreateIndex
CREATE INDEX "pedigrees_cat_name_idx" ON "public"."pedigrees"("cat_name");

-- CreateIndex
CREATE INDEX "schedules_schedule_date_idx" ON "public"."schedules"("schedule_date");

-- CreateIndex
CREATE INDEX "schedules_status_idx" ON "public"."schedules"("status");

-- CreateIndex
CREATE INDEX "schedules_cat_id_idx" ON "public"."schedules"("cat_id");

-- CreateIndex
CREATE INDEX "schedules_assigned_to_idx" ON "public"."schedules"("assigned_to");
`````

## File: backend/prisma/migrations/20251011063613_add_breeding_ng_rules/migration.sql
`````sql
-- CreateEnum
CREATE TYPE "public"."BreedingNgRuleType" AS ENUM ('TAG_COMBINATION', 'INDIVIDUAL_PROHIBITION', 'GENERATION_LIMIT');

-- CreateTable
CREATE TABLE "public"."breeding_ng_rules" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "type" "public"."BreedingNgRuleType" NOT NULL DEFAULT 'TAG_COMBINATION',
    "male_conditions" TEXT[] DEFAULT ARRAY[]::TEXT[],
    "female_conditions" TEXT[] DEFAULT ARRAY[]::TEXT[],
    "male_names" TEXT[] DEFAULT ARRAY[]::TEXT[],
    "female_names" TEXT[] DEFAULT ARRAY[]::TEXT[],
    "generation_limit" INTEGER,
    "active" BOOLEAN NOT NULL DEFAULT true,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "breeding_ng_rules_pkey" PRIMARY KEY ("id")
);
`````

## File: backend/prisma/migrations/20251011082000_add_care_type_to_schedules/migration.sql
`````sql
-- AlterTable
ALTER TABLE "schedules"
ADD COLUMN "care_type" "CareType";

-- CreateIndex
CREATE INDEX "schedules_care_type_idx" ON "public"."schedules"("care_type");
`````

## File: backend/prisma/migrations/20251015090000_add_tag_category_automation/migration.sql
`````sql
-- CreateEnum
CREATE TYPE "TagAssignmentAction" AS ENUM ('ASSIGNED', 'UNASSIGNED');

-- CreateEnum
CREATE TYPE "TagAssignmentSource" AS ENUM ('MANUAL', 'AUTOMATION', 'SYSTEM');

-- CreateEnum
CREATE TYPE "TagAutomationTriggerType" AS ENUM ('EVENT', 'SCHEDULE', 'MANUAL');

-- CreateEnum
CREATE TYPE "TagAutomationEventType" AS ENUM (
    'BREEDING_PLANNED',
    'BREEDING_CONFIRMED',
    'PREGNANCY_CONFIRMED',
    'KITTEN_REGISTERED',
    'AGE_THRESHOLD',
    'CUSTOM'
);

-- CreateEnum
CREATE TYPE "TagAutomationRunStatus" AS ENUM ('PENDING', 'COMPLETED', 'FAILED');

-- CreateTable
CREATE TABLE "tag_categories" (
    "id" TEXT NOT NULL,
    "key" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "color" TEXT DEFAULT '#3B82F6',
    "display_order" INTEGER NOT NULL DEFAULT 0,
    "scopes" TEXT[] NOT NULL DEFAULT ARRAY[]::TEXT[],
    "is_active" BOOLEAN NOT NULL DEFAULT true,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "tag_categories_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "tag_automation_rules" (
    "id" TEXT NOT NULL,
    "key" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "trigger_type" "TagAutomationTriggerType" NOT NULL,
    "event_type" "TagAutomationEventType" NOT NULL,
    "scope" TEXT,
    "is_active" BOOLEAN NOT NULL DEFAULT true,
    "priority" INTEGER NOT NULL DEFAULT 0,
    "config" JSONB,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "tag_automation_rules_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "tag_automation_runs" (
    "id" TEXT NOT NULL,
    "rule_id" TEXT NOT NULL,
    "event_payload" JSONB,
    "status" "TagAutomationRunStatus" NOT NULL DEFAULT 'PENDING',
    "started_at" TIMESTAMP(3),
    "completed_at" TIMESTAMP(3),
    "error_message" TEXT,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "tag_automation_runs_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "tag_assignment_history" (
    "id" TEXT NOT NULL,
    "cat_id" TEXT NOT NULL,
    "tag_id" TEXT NOT NULL,
    "rule_id" TEXT,
    "automation_run_id" TEXT,
    "action" "TagAssignmentAction" NOT NULL DEFAULT 'ASSIGNED',
    "source" "TagAssignmentSource" NOT NULL DEFAULT 'MANUAL',
    "reason" TEXT,
    "metadata" JSONB,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "tag_assignment_history_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "tag_categories_key_key" ON "tag_categories"("key");

-- CreateIndex
CREATE UNIQUE INDEX "tag_automation_rules_key_key" ON "tag_automation_rules"("key");

-- AlterTable
ALTER TABLE "tags"
    ADD COLUMN "category_id" TEXT,
    ADD COLUMN "display_order" INTEGER NOT NULL DEFAULT 0,
    ADD COLUMN "allows_manual" BOOLEAN NOT NULL DEFAULT true,
    ADD COLUMN "allows_automation" BOOLEAN NOT NULL DEFAULT true,
    ADD COLUMN "metadata" JSONB,
    ADD COLUMN "is_active" BOOLEAN NOT NULL DEFAULT true;

-- Insert default category for legacy tags
INSERT INTO "tag_categories" (
    "id", "key", "name", "description", "color", "display_order", "scopes", "is_active"
) VALUES (
    'tag-cat-legacy-default',
    'legacy_default',
    'æ—¢å­˜ã‚¿ã‚°',
    'ã‚«ãƒ†ã‚´ãƒªå°å…¥å‰ã«å­˜åœ¨ã—ã¦ã„ãŸã‚¿ã‚°ã®è‡ªå‹•åˆ†é¡ç”¨ã‚«ãƒ†ã‚´ãƒª',
    '#3B82F6',
    0,
    ARRAY['cats'],
    true
)
ON CONFLICT ("key") DO NOTHING;

-- Assign all existing tags to the default category
UPDATE "tags"
SET "category_id" = 'tag-cat-legacy-default'
WHERE "category_id" IS NULL;

-- Populate display order for legacy tags based on name ordering
WITH ordered_tags AS (
    SELECT "id", ROW_NUMBER() OVER (ORDER BY "name") - 1 AS rn
    FROM "tags"
)
UPDATE "tags" AS t
SET "display_order" = o.rn
FROM ordered_tags AS o
WHERE t."id" = o."id";

-- After data backfill enforce NOT NULL and constraints
ALTER TABLE "tags"
    ALTER COLUMN "category_id" SET NOT NULL;

-- Drop legacy unique constraint and add scoped unique constraint
DROP INDEX IF EXISTS "tags_name_key";
CREATE UNIQUE INDEX "tags_category_id_name_key" ON "tags"("category_id", "name");

-- AddForeignKey
ALTER TABLE "tags"
    ADD CONSTRAINT "tags_category_id_fkey" FOREIGN KEY ("category_id") REFERENCES "tag_categories"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "tag_automation_runs"
    ADD CONSTRAINT "tag_automation_runs_rule_id_fkey" FOREIGN KEY ("rule_id") REFERENCES "tag_automation_rules"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "tag_assignment_history"
    ADD CONSTRAINT "tag_assignment_history_cat_id_fkey" FOREIGN KEY ("cat_id") REFERENCES "cats"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "tag_assignment_history"
    ADD CONSTRAINT "tag_assignment_history_tag_id_fkey" FOREIGN KEY ("tag_id") REFERENCES "tags"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "tag_assignment_history"
    ADD CONSTRAINT "tag_assignment_history_rule_id_fkey" FOREIGN KEY ("rule_id") REFERENCES "tag_automation_rules"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "tag_assignment_history"
    ADD CONSTRAINT "tag_assignment_history_automation_run_id_fkey" FOREIGN KEY ("automation_run_id") REFERENCES "tag_automation_runs"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddIndex
CREATE INDEX "tag_automation_runs_rule_id_idx" ON "tag_automation_runs"("rule_id");
CREATE INDEX "tag_assignment_history_cat_id_idx" ON "tag_assignment_history"("cat_id");
CREATE INDEX "tag_assignment_history_tag_id_idx" ON "tag_assignment_history"("tag_id");
CREATE INDEX "tag_assignment_history_rule_id_idx" ON "tag_assignment_history"("rule_id");
CREATE INDEX "tag_assignment_history_automation_run_id_idx" ON "tag_assignment_history"("automation_run_id");
`````

## File: backend/prisma/migrations/20251015100000_add_tag_groups/migration.sql
`````sql
-- Enable uuid-ossp extension for UUID generation
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Create table for tag groups
CREATE TABLE "tag_groups" (
    "id" TEXT NOT NULL,
    "category_id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "display_order" INTEGER NOT NULL DEFAULT 0,
    "is_active" BOOLEAN NOT NULL DEFAULT TRUE,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT "tag_groups_pkey" PRIMARY KEY ("id"),
    CONSTRAINT "tag_groups_category_id_fkey" FOREIGN KEY ("category_id") REFERENCES "tag_categories"("id") ON DELETE CASCADE ON UPDATE CASCADE
);

-- Create a default group for each existing category
INSERT INTO "tag_groups" (
    "id",
    "category_id",
    "name",
    "description",
    "display_order",
    "is_active"
)
SELECT
    uuid_generate_v4(),
    c.id,
    'default',
    c.description,
    c.display_order,
    c.is_active
FROM "tag_categories" c
WHERE NOT EXISTS (
    SELECT 1 FROM "tag_groups" g WHERE g.category_id = c.id
);

-- Add group_id column to tags
ALTER TABLE "tags" ADD COLUMN "group_id" TEXT;

-- Assign existing tags to the default group of their category
UPDATE "tags" t
SET "group_id" = g.id
FROM "tag_groups" g
WHERE g.category_id = t."category_id" AND g."name" = 'default';

-- Ensure all tags were assigned
ALTER TABLE "tags" ALTER COLUMN "group_id" SET NOT NULL;

-- Drop old constraints/indexes based on category
ALTER TABLE "tags" DROP CONSTRAINT "tags_category_id_fkey";
DROP INDEX IF EXISTS "tags_category_id_name_key";

-- Drop category_id column now that group_id is in place
ALTER TABLE "tags" DROP COLUMN "category_id";

-- Create new constraints/indexes based on group
ALTER TABLE "tags"
    ADD CONSTRAINT "tags_group_id_fkey" FOREIGN KEY ("group_id") REFERENCES "tag_groups"("id") ON DELETE CASCADE ON UPDATE CASCADE;
CREATE UNIQUE INDEX "tags_group_id_name_key" ON "tags" ("group_id", "name");
CREATE INDEX "tags_group_id_idx" ON "tags" ("group_id");

-- Ensure updated_at auto update compatibility
CREATE OR REPLACE FUNCTION set_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW."updated_at" = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_updated_at_tag_groups
BEFORE UPDATE ON "tag_groups"
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();
`````

## File: backend/prisma/migrations/20251015110000_add_text_colors/migration.sql
`````sql
-- Add text and border color support to tags domain
ALTER TABLE "tag_categories" ADD COLUMN IF NOT EXISTS "text_color" TEXT DEFAULT '#111827';

ALTER TABLE "tag_groups" ADD COLUMN IF NOT EXISTS "color" TEXT DEFAULT '#3B82F6';
ALTER TABLE "tag_groups" ADD COLUMN IF NOT EXISTS "text_color" TEXT DEFAULT '#111827';

ALTER TABLE "tags" ADD COLUMN IF NOT EXISTS "text_color" TEXT NOT NULL DEFAULT '#FFFFFF';

-- Backfill existing rows to ensure no NULL values
UPDATE "tag_categories" SET "text_color" = COALESCE("text_color", '#111827');
UPDATE "tag_groups" SET "color" = COALESCE("color", '#3B82F6');
UPDATE "tag_groups" SET "text_color" = COALESCE("text_color", '#111827');
UPDATE "tags" SET "text_color" = '#FFFFFF' WHERE "text_color" IS NULL;
`````

## File: backend/prisma/migrations/20251023131448_add_is_in_house_column/migration.sql
`````sql
/*
  Warnings:

  - You are about to drop the column `color_id` on the `cats` table. All the data in the column will be lost.
  - You are about to drop the column `image_url` on the `cats` table. All the data in the column will be lost.
  - You are about to drop the column `is_active` on the `cats` table. All the data in the column will be lost.
  - You are about to drop the column `legacy_breed` on the `cats` table. All the data in the column will be lost.
  - You are about to drop the column `legacy_color` on the `cats` table. All the data in the column will be lost.
  - You are about to drop the column `microchip_id` on the `cats` table. All the data in the column will be lost.
  - You are about to drop the column `pattern` on the `cats` table. All the data in the column will be lost.
  - You are about to drop the column `weight` on the `cats` table. All the data in the column will be lost.
  - A unique constraint covering the columns `[microchip_number]` on the table `cats` will be added. If there are existing duplicate values, this will fail.
  - A unique constraint covering the columns `[category_id,name]` on the table `tag_groups` will be added. If there are existing duplicate values, this will fail.
  - Added the required column `name` to the `schedules` table without a default value. This is not possible if the table is not empty.

*/
-- CreateEnum
CREATE TYPE "public"."ReminderTimingType" AS ENUM ('ABSOLUTE', 'RELATIVE');

-- CreateEnum
CREATE TYPE "public"."ReminderOffsetUnit" AS ENUM ('MINUTE', 'HOUR', 'DAY', 'WEEK', 'MONTH');

-- CreateEnum
CREATE TYPE "public"."ReminderRelativeTo" AS ENUM ('START_DATE', 'END_DATE', 'CUSTOM_DATE');

-- CreateEnum
CREATE TYPE "public"."ReminderChannel" AS ENUM ('IN_APP', 'EMAIL', 'SMS', 'PUSH');

-- CreateEnum
CREATE TYPE "public"."ReminderRepeatFrequency" AS ENUM ('NONE', 'DAILY', 'WEEKLY', 'MONTHLY', 'YEARLY', 'CUSTOM');

-- CreateEnum
CREATE TYPE "public"."MedicalVisitType" AS ENUM ('CHECKUP', 'EMERGENCY', 'SURGERY', 'FOLLOW_UP', 'VACCINATION', 'OTHER');

-- CreateEnum
CREATE TYPE "public"."MedicalRecordStatus" AS ENUM ('ACTIVE', 'RESOLVED', 'CANCELLED');

-- DropForeignKey
ALTER TABLE "public"."cats" DROP CONSTRAINT "cats_color_id_fkey";

-- DropIndex
DROP INDEX "public"."cats_microchip_id_key";

-- AlterTable
ALTER TABLE "public"."cats" DROP COLUMN "color_id",
DROP COLUMN "image_url",
DROP COLUMN "is_active",
DROP COLUMN "legacy_breed",
DROP COLUMN "legacy_color",
DROP COLUMN "microchip_id",
DROP COLUMN "pattern",
DROP COLUMN "weight",
ADD COLUMN     "coat_color_id" TEXT,
ADD COLUMN     "is_in_house" BOOLEAN NOT NULL DEFAULT true,
ADD COLUMN     "microchip_number" TEXT,
ALTER COLUMN "registration_id" DROP NOT NULL;

-- AlterTable
ALTER TABLE "public"."schedules" ADD COLUMN     "end_date" TIMESTAMP(3),
ADD COLUMN     "name" TEXT NOT NULL,
ADD COLUMN     "recurrence_rule" TEXT,
ADD COLUMN     "timezone" TEXT;

-- AlterTable
ALTER TABLE "public"."tag_automation_rules" ALTER COLUMN "updated_at" DROP DEFAULT;

-- AlterTable
ALTER TABLE "public"."tag_automation_runs" ALTER COLUMN "updated_at" DROP DEFAULT;

-- AlterTable
ALTER TABLE "public"."tag_categories" ALTER COLUMN "updated_at" DROP DEFAULT;

-- AlterTable
ALTER TABLE "public"."tag_groups" ALTER COLUMN "updated_at" DROP DEFAULT;

-- CreateTable
CREATE TABLE "public"."schedule_reminders" (
    "id" TEXT NOT NULL,
    "schedule_id" TEXT NOT NULL,
    "timing_type" "public"."ReminderTimingType" NOT NULL,
    "remind_at" TIMESTAMP(3),
    "offset_value" INTEGER,
    "offset_unit" "public"."ReminderOffsetUnit",
    "relative_to" "public"."ReminderRelativeTo",
    "channel" "public"."ReminderChannel" NOT NULL,
    "repeat_frequency" "public"."ReminderRepeatFrequency",
    "repeat_interval" INTEGER,
    "repeat_count" INTEGER,
    "repeat_until" TIMESTAMP(3),
    "notes" TEXT,
    "is_active" BOOLEAN NOT NULL DEFAULT true,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "schedule_reminders_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."care_tags" (
    "id" TEXT NOT NULL,
    "slug" TEXT NOT NULL,
    "label" TEXT NOT NULL,
    "level" INTEGER NOT NULL DEFAULT 1,
    "parent_id" TEXT,
    "description" TEXT,
    "is_active" BOOLEAN NOT NULL DEFAULT true,
    "priority" INTEGER,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "care_tags_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."schedule_tags" (
    "schedule_id" TEXT NOT NULL,
    "care_tag_id" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "schedule_tags_pkey" PRIMARY KEY ("schedule_id","care_tag_id")
);

-- CreateTable
CREATE TABLE "public"."medical_records" (
    "id" TEXT NOT NULL,
    "cat_id" TEXT NOT NULL,
    "schedule_id" TEXT,
    "recorded_by" TEXT NOT NULL,
    "visit_date" TIMESTAMP(3) NOT NULL,
    "visit_type" "public"."MedicalVisitType",
    "clinic_name" TEXT,
    "veterinarian_name" TEXT,
    "symptom_summary" TEXT,
    "symptom_details" JSONB,
    "diagnosis" TEXT,
    "treatment_plan" TEXT,
    "medications" JSONB,
    "follow_up_action" TEXT,
    "follow_up_date" TIMESTAMP(3),
    "status" "public"."MedicalRecordStatus" NOT NULL DEFAULT 'ACTIVE',
    "notes" TEXT,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "medical_records_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."medical_record_attachments" (
    "id" TEXT NOT NULL,
    "medical_record_id" TEXT NOT NULL,
    "url" TEXT NOT NULL,
    "file_name" TEXT,
    "file_type" TEXT,
    "file_size" INTEGER,
    "captured_at" TIMESTAMP(3),
    "description" TEXT,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "medical_record_attachments_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."medical_record_tags" (
    "medical_record_id" TEXT NOT NULL,
    "care_tag_id" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "medical_record_tags_pkey" PRIMARY KEY ("medical_record_id","care_tag_id")
);

-- CreateIndex
CREATE INDEX "schedule_reminders_schedule_id_idx" ON "public"."schedule_reminders"("schedule_id");

-- CreateIndex
CREATE UNIQUE INDEX "care_tags_slug_key" ON "public"."care_tags"("slug");

-- CreateIndex
CREATE INDEX "care_tags_parent_id_idx" ON "public"."care_tags"("parent_id");

-- CreateIndex
CREATE INDEX "care_tags_level_idx" ON "public"."care_tags"("level");

-- CreateIndex
CREATE INDEX "medical_records_cat_id_idx" ON "public"."medical_records"("cat_id");

-- CreateIndex
CREATE INDEX "medical_records_visit_date_idx" ON "public"."medical_records"("visit_date");

-- CreateIndex
CREATE INDEX "medical_records_schedule_id_idx" ON "public"."medical_records"("schedule_id");

-- CreateIndex
CREATE INDEX "medical_record_attachments_medical_record_id_idx" ON "public"."medical_record_attachments"("medical_record_id");

-- CreateIndex
CREATE UNIQUE INDEX "cats_microchip_number_key" ON "public"."cats"("microchip_number");

-- CreateIndex
CREATE INDEX "cats_coat_color_id_idx" ON "public"."cats"("coat_color_id");

-- CreateIndex
CREATE INDEX "schedules_end_date_idx" ON "public"."schedules"("end_date");

-- CreateIndex
CREATE UNIQUE INDEX "tag_groups_category_id_name_key" ON "public"."tag_groups"("category_id", "name");

-- AddForeignKey
ALTER TABLE "public"."cats" ADD CONSTRAINT "cats_coat_color_id_fkey" FOREIGN KEY ("coat_color_id") REFERENCES "public"."coat_colors"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."schedule_reminders" ADD CONSTRAINT "schedule_reminders_schedule_id_fkey" FOREIGN KEY ("schedule_id") REFERENCES "public"."schedules"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."care_tags" ADD CONSTRAINT "care_tags_parent_id_fkey" FOREIGN KEY ("parent_id") REFERENCES "public"."care_tags"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."schedule_tags" ADD CONSTRAINT "schedule_tags_schedule_id_fkey" FOREIGN KEY ("schedule_id") REFERENCES "public"."schedules"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."schedule_tags" ADD CONSTRAINT "schedule_tags_care_tag_id_fkey" FOREIGN KEY ("care_tag_id") REFERENCES "public"."care_tags"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."medical_records" ADD CONSTRAINT "medical_records_cat_id_fkey" FOREIGN KEY ("cat_id") REFERENCES "public"."cats"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."medical_records" ADD CONSTRAINT "medical_records_schedule_id_fkey" FOREIGN KEY ("schedule_id") REFERENCES "public"."schedules"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."medical_records" ADD CONSTRAINT "medical_records_recorded_by_fkey" FOREIGN KEY ("recorded_by") REFERENCES "public"."users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."medical_record_attachments" ADD CONSTRAINT "medical_record_attachments_medical_record_id_fkey" FOREIGN KEY ("medical_record_id") REFERENCES "public"."medical_records"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."medical_record_tags" ADD CONSTRAINT "medical_record_tags_medical_record_id_fkey" FOREIGN KEY ("medical_record_id") REFERENCES "public"."medical_records"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."medical_record_tags" ADD CONSTRAINT "medical_record_tags_care_tag_id_fkey" FOREIGN KEY ("care_tag_id") REFERENCES "public"."care_tags"("id") ON DELETE CASCADE ON UPDATE CASCADE;
`````

## File: backend/prisma/migrations/20251023132517_rename_registration_id_to_registration_number/migration.sql
`````sql
/*
  Warnings:

  - You are about to rename the column `registration_id` to `registration_number` on the `cats` table.

*/
-- DropIndex
DROP INDEX "public"."cats_registration_id_key";

-- AlterTable
ALTER TABLE "public"."cats" RENAME COLUMN "registration_id" TO "registration_number";

-- CreateIndex
CREATE UNIQUE INDEX "cats_registration_number_key" ON "public"."cats"("registration_number");
`````

## File: backend/prisma/migrations/20251023190628_add_breedingrecord/migration.sql
`````sql
-- CreateEnum
CREATE TYPE "public"."PregnancyStatus" AS ENUM ('PENDING', 'CONFIRMED', 'NEGATIVE', 'CANCELLED');

-- CreateEnum
CREATE TYPE "public"."BirthStatus" AS ENUM ('EXPECTED', 'COMPLETED', 'CANCELLED');

-- CreateTable
CREATE TABLE "public"."pregnancy_checks" (
    "id" TEXT NOT NULL,
    "male_id" TEXT NOT NULL,
    "female_id" TEXT NOT NULL,
    "male_name" TEXT NOT NULL,
    "female_name" TEXT NOT NULL,
    "mating_date" TIMESTAMP(3) NOT NULL,
    "check_date" TIMESTAMP(3) NOT NULL,
    "status" "public"."PregnancyStatus" NOT NULL DEFAULT 'PENDING',
    "notes" TEXT,
    "recorded_by" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "pregnancy_checks_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."birth_plans" (
    "id" TEXT NOT NULL,
    "male_id" TEXT NOT NULL,
    "female_id" TEXT NOT NULL,
    "male_name" TEXT NOT NULL,
    "female_name" TEXT NOT NULL,
    "mating_date" TIMESTAMP(3) NOT NULL,
    "expected_date" TIMESTAMP(3) NOT NULL,
    "actual_date" TIMESTAMP(3),
    "status" "public"."BirthStatus" NOT NULL DEFAULT 'EXPECTED',
    "number_of_kittens" INTEGER,
    "notes" TEXT,
    "recorded_by" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "birth_plans_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "pregnancy_checks_male_id_idx" ON "public"."pregnancy_checks"("male_id");

-- CreateIndex
CREATE INDEX "pregnancy_checks_female_id_idx" ON "public"."pregnancy_checks"("female_id");

-- CreateIndex
CREATE INDEX "pregnancy_checks_check_date_idx" ON "public"."pregnancy_checks"("check_date");

-- CreateIndex
CREATE INDEX "birth_plans_male_id_idx" ON "public"."birth_plans"("male_id");

-- CreateIndex
CREATE INDEX "birth_plans_female_id_idx" ON "public"."birth_plans"("female_id");

-- CreateIndex
CREATE INDEX "birth_plans_expected_date_idx" ON "public"."birth_plans"("expected_date");

-- AddForeignKey
ALTER TABLE "public"."pregnancy_checks" ADD CONSTRAINT "pregnancy_checks_male_id_fkey" FOREIGN KEY ("male_id") REFERENCES "public"."cats"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."pregnancy_checks" ADD CONSTRAINT "pregnancy_checks_female_id_fkey" FOREIGN KEY ("female_id") REFERENCES "public"."cats"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."pregnancy_checks" ADD CONSTRAINT "pregnancy_checks_recorded_by_fkey" FOREIGN KEY ("recorded_by") REFERENCES "public"."users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."birth_plans" ADD CONSTRAINT "birth_plans_male_id_fkey" FOREIGN KEY ("male_id") REFERENCES "public"."cats"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."birth_plans" ADD CONSTRAINT "birth_plans_female_id_fkey" FOREIGN KEY ("female_id") REFERENCES "public"."cats"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."birth_plans" ADD CONSTRAINT "birth_plans_recorded_by_fkey" FOREIGN KEY ("recorded_by") REFERENCES "public"."users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
`````

## File: backend/prisma/migrations/20251023191845_update_pregnancy_birth_models/migration.sql
`````sql
/*
  Warnings:

  - You are about to drop the column `actual_date` on the `birth_plans` table. All the data in the column will be lost.
  - You are about to drop the column `expected_date` on the `birth_plans` table. All the data in the column will be lost.
  - You are about to drop the column `female_id` on the `birth_plans` table. All the data in the column will be lost.
  - You are about to drop the column `female_name` on the `birth_plans` table. All the data in the column will be lost.
  - You are about to drop the column `male_id` on the `birth_plans` table. All the data in the column will be lost.
  - You are about to drop the column `male_name` on the `birth_plans` table. All the data in the column will be lost.
  - You are about to drop the column `mating_date` on the `birth_plans` table. All the data in the column will be lost.
  - You are about to drop the column `number_of_kittens` on the `birth_plans` table. All the data in the column will be lost.
  - You are about to drop the column `female_id` on the `pregnancy_checks` table. All the data in the column will be lost.
  - You are about to drop the column `female_name` on the `pregnancy_checks` table. All the data in the column will be lost.
  - You are about to drop the column `male_id` on the `pregnancy_checks` table. All the data in the column will be lost.
  - You are about to drop the column `male_name` on the `pregnancy_checks` table. All the data in the column will be lost.
  - You are about to drop the column `mating_date` on the `pregnancy_checks` table. All the data in the column will be lost.
  - Added the required column `expected_birth_date` to the `birth_plans` table without a default value. This is not possible if the table is not empty.
  - Added the required column `mother_id` to the `birth_plans` table without a default value. This is not possible if the table is not empty.
  - Added the required column `mother_id` to the `pregnancy_checks` table without a default value. This is not possible if the table is not empty.

*/
-- DropForeignKey
ALTER TABLE "public"."birth_plans" DROP CONSTRAINT "birth_plans_female_id_fkey";

-- DropForeignKey
ALTER TABLE "public"."birth_plans" DROP CONSTRAINT "birth_plans_male_id_fkey";

-- DropForeignKey
ALTER TABLE "public"."pregnancy_checks" DROP CONSTRAINT "pregnancy_checks_female_id_fkey";

-- DropForeignKey
ALTER TABLE "public"."pregnancy_checks" DROP CONSTRAINT "pregnancy_checks_male_id_fkey";

-- DropIndex
DROP INDEX "public"."birth_plans_expected_date_idx";

-- DropIndex
DROP INDEX "public"."birth_plans_female_id_idx";

-- DropIndex
DROP INDEX "public"."birth_plans_male_id_idx";

-- DropIndex
DROP INDEX "public"."pregnancy_checks_female_id_idx";

-- DropIndex
DROP INDEX "public"."pregnancy_checks_male_id_idx";

-- AlterTable
ALTER TABLE "public"."birth_plans" DROP COLUMN "actual_date",
DROP COLUMN "expected_date",
DROP COLUMN "female_id",
DROP COLUMN "female_name",
DROP COLUMN "male_id",
DROP COLUMN "male_name",
DROP COLUMN "mating_date",
DROP COLUMN "number_of_kittens",
ADD COLUMN     "actual_birth_date" TIMESTAMP(3),
ADD COLUMN     "actual_kittens" INTEGER,
ADD COLUMN     "expected_birth_date" TIMESTAMP(3) NOT NULL,
ADD COLUMN     "expected_kittens" INTEGER,
ADD COLUMN     "mother_id" TEXT NOT NULL;

-- AlterTable
ALTER TABLE "public"."pregnancy_checks" DROP COLUMN "female_id",
DROP COLUMN "female_name",
DROP COLUMN "male_id",
DROP COLUMN "male_name",
DROP COLUMN "mating_date",
ADD COLUMN     "mother_id" TEXT NOT NULL;

-- CreateIndex
CREATE INDEX "birth_plans_mother_id_idx" ON "public"."birth_plans"("mother_id");

-- CreateIndex
CREATE INDEX "birth_plans_expected_birth_date_idx" ON "public"."birth_plans"("expected_birth_date");

-- CreateIndex
CREATE INDEX "pregnancy_checks_mother_id_idx" ON "public"."pregnancy_checks"("mother_id");

-- AddForeignKey
ALTER TABLE "public"."pregnancy_checks" ADD CONSTRAINT "pregnancy_checks_mother_id_fkey" FOREIGN KEY ("mother_id") REFERENCES "public"."cats"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."birth_plans" ADD CONSTRAINT "birth_plans_mother_id_fkey" FOREIGN KEY ("mother_id") REFERENCES "public"."cats"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
`````

## File: backend/prisma/migrations/20251023191932_update_enum_values/migration.sql
`````sql
/*
  Warnings:

  - The values [COMPLETED,CANCELLED] on the enum `BirthStatus` will be removed. If these variants are still used in the database, this will fail.
  - The values [PENDING,CANCELLED] on the enum `PregnancyStatus` will be removed. If these variants are still used in the database, this will fail.

*/
-- AlterEnum
BEGIN;
CREATE TYPE "public"."BirthStatus_new" AS ENUM ('EXPECTED', 'BORN', 'ABORTED', 'STILLBORN');
ALTER TABLE "public"."birth_plans" ALTER COLUMN "status" DROP DEFAULT;
ALTER TABLE "public"."birth_plans" ALTER COLUMN "status" TYPE "public"."BirthStatus_new" USING ("status"::text::"public"."BirthStatus_new");
ALTER TYPE "public"."BirthStatus" RENAME TO "BirthStatus_old";
ALTER TYPE "public"."BirthStatus_new" RENAME TO "BirthStatus";
DROP TYPE "public"."BirthStatus_old";
ALTER TABLE "public"."birth_plans" ALTER COLUMN "status" SET DEFAULT 'EXPECTED';
COMMIT;

-- AlterEnum
BEGIN;
CREATE TYPE "public"."PregnancyStatus_new" AS ENUM ('CONFIRMED', 'SUSPECTED', 'NEGATIVE', 'ABORTED');
ALTER TABLE "public"."pregnancy_checks" ALTER COLUMN "status" DROP DEFAULT;
ALTER TABLE "public"."pregnancy_checks" ALTER COLUMN "status" TYPE "public"."PregnancyStatus_new" USING ("status"::text::"public"."PregnancyStatus_new");
ALTER TYPE "public"."PregnancyStatus" RENAME TO "PregnancyStatus_old";
ALTER TYPE "public"."PregnancyStatus_new" RENAME TO "PregnancyStatus";
DROP TYPE "public"."PregnancyStatus_old";
ALTER TABLE "public"."pregnancy_checks" ALTER COLUMN "status" SET DEFAULT 'SUSPECTED';
COMMIT;

-- AlterTable
ALTER TABLE "public"."pregnancy_checks" ALTER COLUMN "status" SET DEFAULT 'SUSPECTED';
`````

## File: backend/prisma/migrations/20251028180807_add_schedule_cats_table/migration.sql
`````sql
-- CreateTable
CREATE TABLE "public"."schedule_cats" (
    "schedule_id" TEXT NOT NULL,
    "cat_id" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "schedule_cats_pkey" PRIMARY KEY ("schedule_id","cat_id")
);

-- AddForeignKey
ALTER TABLE "public"."schedule_cats" ADD CONSTRAINT "schedule_cats_schedule_id_fkey" FOREIGN KEY ("schedule_id") REFERENCES "public"."schedules"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."schedule_cats" ADD CONSTRAINT "schedule_cats_cat_id_fkey" FOREIGN KEY ("cat_id") REFERENCES "public"."cats"("id") ON DELETE CASCADE ON UPDATE CASCADE;
`````

## File: backend/prisma/migrations/20251101114041_add_father_and_mating_date_to_pregnancy_and_birth/migration.sql
`````sql
-- AlterTable
ALTER TABLE "public"."birth_plans" ADD COLUMN     "father_id" TEXT,
ADD COLUMN     "mating_date" TIMESTAMP(3);

-- AlterTable
ALTER TABLE "public"."pregnancy_checks" ADD COLUMN     "father_id" TEXT,
ADD COLUMN     "mating_date" TIMESTAMP(3);

-- CreateIndex
CREATE INDEX "birth_plans_father_id_idx" ON "public"."birth_plans"("father_id");

-- CreateIndex
CREATE INDEX "pregnancy_checks_father_id_idx" ON "public"."pregnancy_checks"("father_id");
`````

## File: backend/prisma/migrations/20251106161358_add_staff_shift_management/migration.sql
`````sql
-- CreateEnum
CREATE TYPE "public"."ShiftMode" AS ENUM ('SIMPLE', 'DETAILED', 'CUSTOM');

-- CreateEnum
CREATE TYPE "public"."ShiftStatus" AS ENUM ('SCHEDULED', 'CONFIRMED', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED', 'ABSENT');

-- CreateEnum
CREATE TYPE "public"."TaskStatus" AS ENUM ('PENDING', 'IN_PROGRESS', 'COMPLETED', 'SKIPPED');

-- CreateTable
CREATE TABLE "public"."staff" (
    "id" TEXT NOT NULL,
    "user_id" TEXT,
    "name" TEXT NOT NULL,
    "email" TEXT,
    "role" TEXT NOT NULL DEFAULT 'ã‚¹ã‚¿ãƒƒãƒ•',
    "color" TEXT NOT NULL DEFAULT '#4dabf7',
    "is_active" BOOLEAN NOT NULL DEFAULT true,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "staff_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."shift_templates" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "start_time" TEXT NOT NULL,
    "end_time" TEXT NOT NULL,
    "duration" INTEGER NOT NULL,
    "color" TEXT NOT NULL DEFAULT '#4dabf7',
    "break_time" INTEGER NOT NULL DEFAULT 0,
    "is_active" BOOLEAN NOT NULL DEFAULT true,
    "display_order" INTEGER NOT NULL DEFAULT 0,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "shift_templates_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."shifts" (
    "id" TEXT NOT NULL,
    "staff_id" TEXT NOT NULL,
    "shift_date" TIMESTAMP(3) NOT NULL,
    "display_name" TEXT,
    "template_id" TEXT,
    "start_time" TIMESTAMP(3),
    "end_time" TIMESTAMP(3),
    "break_duration" INTEGER,
    "status" "public"."ShiftStatus" NOT NULL DEFAULT 'SCHEDULED',
    "notes" TEXT,
    "actual_start_time" TIMESTAMP(3),
    "actual_end_time" TIMESTAMP(3),
    "metadata" JSONB,
    "mode" "public"."ShiftMode" NOT NULL DEFAULT 'SIMPLE',
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "shifts_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."shift_tasks" (
    "id" TEXT NOT NULL,
    "shift_id" TEXT NOT NULL,
    "task_type" TEXT NOT NULL,
    "description" TEXT NOT NULL,
    "priority" "public"."Priority" NOT NULL DEFAULT 'MEDIUM',
    "status" "public"."TaskStatus" NOT NULL DEFAULT 'PENDING',
    "start_time" TIMESTAMP(3),
    "end_time" TIMESTAMP(3),
    "notes" TEXT,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "shift_tasks_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."staff_availabilities" (
    "id" TEXT NOT NULL,
    "staff_id" TEXT NOT NULL,
    "day_of_week" INTEGER NOT NULL,
    "start_time" TEXT NOT NULL,
    "end_time" TEXT NOT NULL,
    "is_available" BOOLEAN NOT NULL DEFAULT true,
    "notes" TEXT,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "staff_availabilities_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."shift_settings" (
    "id" TEXT NOT NULL,
    "organization_id" TEXT,
    "default_mode" "public"."ShiftMode" NOT NULL DEFAULT 'SIMPLE',
    "enabled_modes" TEXT[] DEFAULT ARRAY['SIMPLE', 'DETAILED']::TEXT[],
    "simple_require_display_name" BOOLEAN NOT NULL DEFAULT false,
    "detailed_require_time" BOOLEAN NOT NULL DEFAULT true,
    "detailed_require_template" BOOLEAN NOT NULL DEFAULT false,
    "detailed_enable_tasks" BOOLEAN NOT NULL DEFAULT true,
    "detailed_enable_actual" BOOLEAN NOT NULL DEFAULT true,
    "custom_fields" JSONB,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "shift_settings_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "staff_user_id_key" ON "public"."staff"("user_id");

-- CreateIndex
CREATE UNIQUE INDEX "staff_email_key" ON "public"."staff"("email");

-- CreateIndex
CREATE INDEX "staff_user_id_idx" ON "public"."staff"("user_id");

-- CreateIndex
CREATE INDEX "shifts_staff_id_idx" ON "public"."shifts"("staff_id");

-- CreateIndex
CREATE INDEX "shifts_template_id_idx" ON "public"."shifts"("template_id");

-- CreateIndex
CREATE INDEX "shifts_shift_date_idx" ON "public"."shifts"("shift_date");

-- CreateIndex
CREATE INDEX "shifts_status_idx" ON "public"."shifts"("status");

-- CreateIndex
CREATE INDEX "shifts_mode_idx" ON "public"."shifts"("mode");

-- CreateIndex
CREATE INDEX "shift_tasks_shift_id_idx" ON "public"."shift_tasks"("shift_id");

-- CreateIndex
CREATE INDEX "shift_tasks_status_idx" ON "public"."shift_tasks"("status");

-- CreateIndex
CREATE INDEX "staff_availabilities_staff_id_idx" ON "public"."staff_availabilities"("staff_id");

-- AddForeignKey
ALTER TABLE "public"."staff" ADD CONSTRAINT "staff_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."shifts" ADD CONSTRAINT "shifts_staff_id_fkey" FOREIGN KEY ("staff_id") REFERENCES "public"."staff"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."shifts" ADD CONSTRAINT "shifts_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."shift_templates"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."shift_tasks" ADD CONSTRAINT "shift_tasks_shift_id_fkey" FOREIGN KEY ("shift_id") REFERENCES "public"."shifts"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."staff_availabilities" ADD CONSTRAINT "staff_availabilities_staff_id_fkey" FOREIGN KEY ("staff_id") REFERENCES "public"."staff"("id") ON DELETE CASCADE ON UPDATE CASCADE;
`````

## File: backend/prisma/migrations/20251108122748_add_kitten_disposition_and_birth_completion/migration.sql
`````sql
-- CreateEnum
CREATE TYPE "public"."DispositionType" AS ENUM ('TRAINING', 'SALE', 'DECEASED');

-- AlterTable
ALTER TABLE "public"."birth_plans" ADD COLUMN     "completed_at" TIMESTAMP(3);

-- CreateTable
CREATE TABLE "public"."kitten_dispositions" (
    "id" TEXT NOT NULL,
    "birth_record_id" TEXT NOT NULL,
    "kitten_id" TEXT,
    "name" TEXT NOT NULL,
    "gender" TEXT NOT NULL,
    "disposition" "public"."DispositionType" NOT NULL,
    "training_start_date" TIMESTAMP(3),
    "sale_info" JSONB,
    "death_date" TIMESTAMP(3),
    "death_reason" TEXT,
    "notes" TEXT,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "kitten_dispositions_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "kitten_dispositions_birth_record_id_idx" ON "public"."kitten_dispositions"("birth_record_id");

-- CreateIndex
CREATE INDEX "kitten_dispositions_kitten_id_idx" ON "public"."kitten_dispositions"("kitten_id");

-- AddForeignKey
ALTER TABLE "public"."kitten_dispositions" ADD CONSTRAINT "kitten_dispositions_birth_record_id_fkey" FOREIGN KEY ("birth_record_id") REFERENCES "public"."birth_plans"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."kitten_dispositions" ADD CONSTRAINT "kitten_dispositions_kitten_id_fkey" FOREIGN KEY ("kitten_id") REFERENCES "public"."cats"("id") ON DELETE SET NULL ON UPDATE CASCADE;
`````

## File: backend/prisma/migrations/20251108135042_add_page_action_event_type/migration.sql
`````sql
-- AlterEnum
ALTER TYPE "public"."TagAutomationEventType" ADD VALUE 'PAGE_ACTION';
`````

## File: backend/prisma/migrations/20251109034116_add_medical_page/migration.sql
`````sql
/*
  Warnings:

  - The values [ACTIVE,RESOLVED,CANCELLED] on the enum `MedicalRecordStatus` will be removed. If these variants are still used in the database, this will fail.
  - You are about to drop the column `follow_up_action` on the `medical_records` table. All the data in the column will be lost.
  - You are about to drop the column `symptom_summary` on the `medical_records` table. All the data in the column will be lost.

*/
-- AlterEnum
BEGIN;
CREATE TYPE "public"."MedicalRecordStatus_new" AS ENUM ('TREATING', 'COMPLETED');
ALTER TABLE "public"."medical_records" ALTER COLUMN "status" DROP DEFAULT;
ALTER TABLE "public"."medical_records" ALTER COLUMN "status" TYPE "public"."MedicalRecordStatus_new" USING ("status"::text::"public"."MedicalRecordStatus_new");
ALTER TYPE "public"."MedicalRecordStatus" RENAME TO "MedicalRecordStatus_old";
ALTER TYPE "public"."MedicalRecordStatus_new" RENAME TO "MedicalRecordStatus";
DROP TYPE "public"."MedicalRecordStatus_old";
ALTER TABLE "public"."medical_records" ALTER COLUMN "status" SET DEFAULT 'TREATING';
COMMIT;

-- AlterTable
ALTER TABLE "public"."medical_records" DROP COLUMN "follow_up_action",
DROP COLUMN "symptom_summary",
ADD COLUMN     "disease_name" TEXT,
ADD COLUMN     "symptom" TEXT,
ALTER COLUMN "status" SET DEFAULT 'TREATING';
`````

## File: backend/prisma/migrations/20251110175612_add_visit_type_relation/migration.sql
`````sql
/*
  Warnings:

  - The primary key for the `medical_record_tags` table will be changed. If it partially fails, the table could be left without primary key constraint.
  - You are about to drop the column `care_tag_id` on the `medical_record_tags` table. All the data in the column will be lost.
  - You are about to drop the column `clinic_name` on the `medical_records` table. All the data in the column will be lost.
  - You are about to drop the column `veterinarian_name` on the `medical_records` table. All the data in the column will be lost.
  - You are about to drop the column `visit_type` on the `medical_records` table. All the data in the column will be lost.
  - Added the required column `tag_id` to the `medical_record_tags` table without a default value. This is not possible if the table is not empty.

*/
-- DropForeignKey
ALTER TABLE "public"."medical_record_tags" DROP CONSTRAINT "medical_record_tags_care_tag_id_fkey";

-- AlterTable
ALTER TABLE "public"."medical_record_tags" DROP CONSTRAINT "medical_record_tags_pkey",
DROP COLUMN "care_tag_id",
ADD COLUMN     "tag_id" TEXT NOT NULL,
ADD CONSTRAINT "medical_record_tags_pkey" PRIMARY KEY ("medical_record_id", "tag_id");

-- AlterTable
ALTER TABLE "public"."medical_records" DROP COLUMN "clinic_name",
DROP COLUMN "veterinarian_name",
DROP COLUMN "visit_type",
ADD COLUMN     "hospital_name" TEXT,
ADD COLUMN     "visit_type_id" TEXT;

-- DropEnum
DROP TYPE "public"."MedicalVisitType";

-- CreateTable
CREATE TABLE "public"."medical_visit_types" (
    "id" TEXT NOT NULL,
    "key" TEXT,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "display_order" INTEGER NOT NULL DEFAULT 0,
    "is_active" BOOLEAN NOT NULL DEFAULT true,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "medical_visit_types_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "medical_visit_types_key_key" ON "public"."medical_visit_types"("key");

-- CreateIndex
CREATE INDEX "medical_visit_types_display_order_idx" ON "public"."medical_visit_types"("display_order");

-- CreateIndex
CREATE INDEX "medical_records_visit_type_id_idx" ON "public"."medical_records"("visit_type_id");

-- AddForeignKey
ALTER TABLE "public"."medical_records" ADD CONSTRAINT "medical_records_visit_type_id_fkey" FOREIGN KEY ("visit_type_id") REFERENCES "public"."medical_visit_types"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."medical_record_tags" ADD CONSTRAINT "medical_record_tags_tag_id_fkey" FOREIGN KEY ("tag_id") REFERENCES "public"."tags"("id") ON DELETE CASCADE ON UPDATE CASCADE;
`````

## File: backend/prisma/migrations/20251111105249_add_graduation_table/migration.sql
`````sql
-- AlterTable
ALTER TABLE "public"."cats" ADD COLUMN     "is_graduated" BOOLEAN NOT NULL DEFAULT false;

-- CreateTable
CREATE TABLE "public"."graduations" (
    "id" TEXT NOT NULL,
    "cat_id" TEXT NOT NULL,
    "transfer_date" TIMESTAMP(3) NOT NULL,
    "destination" TEXT NOT NULL,
    "notes" TEXT,
    "cat_snapshot" JSONB NOT NULL,
    "transferred_by" TEXT,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "graduations_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "graduations_cat_id_key" ON "public"."graduations"("cat_id");

-- CreateIndex
CREATE INDEX "graduations_transfer_date_idx" ON "public"."graduations"("transfer_date");

-- CreateIndex
CREATE INDEX "graduations_cat_id_idx" ON "public"."graduations"("cat_id");

-- AddForeignKey
ALTER TABLE "public"."graduations" ADD CONSTRAINT "graduations_cat_id_fkey" FOREIGN KEY ("cat_id") REFERENCES "public"."cats"("id") ON DELETE CASCADE ON UPDATE CASCADE;
`````

## File: backend/prisma/migrations/20251112000000_enhance_performance_indexes/migration.sql
`````sql
-- H2: Database Index Optimization
-- ä¸»è¦ãƒ†ãƒ¼ãƒ–ãƒ«ã¸ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¿½åŠ 

-- ==========================================
-- User ãƒ†ãƒ¼ãƒ–ãƒ«
-- ==========================================
CREATE INDEX IF NOT EXISTS "users_email_idx" ON "public"."users"("email");
CREATE INDEX IF NOT EXISTS "users_role_idx" ON "public"."users"("role");
CREATE INDEX IF NOT EXISTS "users_is_active_idx" ON "public"."users"("is_active");
CREATE INDEX IF NOT EXISTS "users_last_login_at_idx" ON "public"."users"("last_login_at");
CREATE INDEX IF NOT EXISTS "users_role_is_active_idx" ON "public"."users"("role", "is_active");
CREATE INDEX IF NOT EXISTS "users_is_active_last_login_at_idx" ON "public"."users"("is_active", "last_login_at");

-- ==========================================
-- LoginAttempt ãƒ†ãƒ¼ãƒ–ãƒ«
-- ==========================================
CREATE INDEX IF NOT EXISTS "login_attempts_user_id_idx" ON "public"."login_attempts"("user_id");
CREATE INDEX IF NOT EXISTS "login_attempts_email_idx" ON "public"."login_attempts"("email");
CREATE INDEX IF NOT EXISTS "login_attempts_success_idx" ON "public"."login_attempts"("success");
CREATE INDEX IF NOT EXISTS "login_attempts_created_at_idx" ON "public"."login_attempts"("created_at");
CREATE INDEX IF NOT EXISTS "login_attempts_email_created_at_idx" ON "public"."login_attempts"("email", "created_at");
CREATE INDEX IF NOT EXISTS "login_attempts_user_id_created_at_idx" ON "public"."login_attempts"("user_id", "created_at");
CREATE INDEX IF NOT EXISTS "login_attempts_success_created_at_idx" ON "public"."login_attempts"("success", "created_at");

-- ==========================================
-- Breed ãƒ†ãƒ¼ãƒ–ãƒ«
-- ==========================================
CREATE INDEX IF NOT EXISTS "breeds_code_idx" ON "public"."breeds"("code");
CREATE INDEX IF NOT EXISTS "breeds_name_idx" ON "public"."breeds"("name");
CREATE INDEX IF NOT EXISTS "breeds_is_active_idx" ON "public"."breeds"("is_active");

-- ==========================================
-- CoatColor ãƒ†ãƒ¼ãƒ–ãƒ«
-- ==========================================
CREATE INDEX IF NOT EXISTS "coat_colors_code_idx" ON "public"."coat_colors"("code");
CREATE INDEX IF NOT EXISTS "coat_colors_name_idx" ON "public"."coat_colors"("name");
CREATE INDEX IF NOT EXISTS "coat_colors_is_active_idx" ON "public"."coat_colors"("is_active");

-- ==========================================
-- Gender ãƒ†ãƒ¼ãƒ–ãƒ«
-- ==========================================
CREATE INDEX IF NOT EXISTS "genders_code_idx" ON "public"."genders"("code");
CREATE INDEX IF NOT EXISTS "genders_name_idx" ON "public"."genders"("name");

-- ==========================================
-- Cat ãƒ†ãƒ¼ãƒ–ãƒ«
-- ==========================================
CREATE INDEX IF NOT EXISTS "cats_name_idx" ON "public"."cats"("name");
CREATE INDEX IF NOT EXISTS "cats_gender_idx" ON "public"."cats"("gender");
CREATE INDEX IF NOT EXISTS "cats_is_in_house_idx" ON "public"."cats"("is_in_house");
CREATE INDEX IF NOT EXISTS "cats_is_graduated_idx" ON "public"."cats"("is_graduated");
CREATE INDEX IF NOT EXISTS "cats_registration_number_idx" ON "public"."cats"("registration_number");
CREATE INDEX IF NOT EXISTS "cats_coat_color_id_idx" ON "public"."cats"("coat_color_id");
-- Removed: cats_birth_place_idx (column does not exist in schema)
-- Removed: cats_chip_number_idx (column name is microchip_number, not chip_number)
CREATE INDEX IF NOT EXISTS "cats_breed_id_birth_date_idx" ON "public"."cats"("breed_id", "birth_date");
CREATE INDEX IF NOT EXISTS "cats_gender_birth_date_idx" ON "public"."cats"("gender", "birth_date");
CREATE INDEX IF NOT EXISTS "cats_is_in_house_is_graduated_idx" ON "public"."cats"("is_in_house", "is_graduated");

-- ==========================================
-- Pedigree ãƒ†ãƒ¼ãƒ–ãƒ«
-- ==========================================
CREATE INDEX IF NOT EXISTS "pedigrees_pedigree_id_idx" ON "public"."pedigrees"("pedigree_id");
-- Fixed: Use correct column names (breed_code, coat_color_code, gender_code instead of breed_id, coat_color_id, gender_id)
CREATE INDEX IF NOT EXISTS "pedigrees_breed_code_idx" ON "public"."pedigrees"("breed_code");
CREATE INDEX IF NOT EXISTS "pedigrees_coat_color_code_idx" ON "public"."pedigrees"("coat_color_code");
CREATE INDEX IF NOT EXISTS "pedigrees_gender_code_idx" ON "public"."pedigrees"("gender_code");
CREATE INDEX IF NOT EXISTS "pedigrees_birth_date_idx" ON "public"."pedigrees"("birth_date");
CREATE INDEX IF NOT EXISTS "pedigrees_pedigree_id_birth_date_idx" ON "public"."pedigrees"("pedigree_id", "birth_date");

-- ==========================================
-- BreedingRecord ãƒ†ãƒ¼ãƒ–ãƒ«
-- ==========================================
CREATE INDEX IF NOT EXISTS "breeding_records_recorded_by_idx" ON "public"."breeding_records"("recorded_by");
-- Removed: breeding_records_pregnancy_status_idx (column does not exist in schema)
CREATE INDEX IF NOT EXISTS "breeding_records_male_id_breeding_date_idx" ON "public"."breeding_records"("male_id", "breeding_date");
CREATE INDEX IF NOT EXISTS "breeding_records_female_id_breeding_date_idx" ON "public"."breeding_records"("female_id", "breeding_date");
CREATE INDEX IF NOT EXISTS "breeding_records_status_breeding_date_idx" ON "public"."breeding_records"("status", "breeding_date");
-- Removed: breeding_records_pregnancy_status_breeding_date_idx (column does not exist in schema)

-- ==========================================
-- CareRecord ãƒ†ãƒ¼ãƒ–ãƒ«
-- ==========================================
CREATE INDEX IF NOT EXISTS "care_records_recorded_by_idx" ON "public"."care_records"("recorded_by");
CREATE INDEX IF NOT EXISTS "care_records_next_due_date_idx" ON "public"."care_records"("next_due_date");
CREATE INDEX IF NOT EXISTS "care_records_cat_id_care_date_idx" ON "public"."care_records"("cat_id", "care_date");
CREATE INDEX IF NOT EXISTS "care_records_care_type_care_date_idx" ON "public"."care_records"("care_type", "care_date");
CREATE INDEX IF NOT EXISTS "care_records_recorded_by_care_date_idx" ON "public"."care_records"("recorded_by", "care_date");
CREATE INDEX IF NOT EXISTS "care_records_next_due_date_care_type_idx" ON "public"."care_records"("next_due_date", "care_type");

-- ==========================================
-- Schedule ãƒ†ãƒ¼ãƒ–ãƒ«
-- ==========================================
CREATE INDEX IF NOT EXISTS "schedules_schedule_type_idx" ON "public"."schedules"("schedule_type");
CREATE INDEX IF NOT EXISTS "schedules_priority_idx" ON "public"."schedules"("priority");
-- Removed: schedules_is_recurring_idx (column does not exist in schema)
-- Removed: schedules_recurrence_pattern_idx (column does not exist in schema)
-- Removed: schedules_is_completed_idx (column does not exist in schema)
-- Removed: schedules_completed_at_idx (column does not exist in schema)
CREATE INDEX IF NOT EXISTS "schedules_schedule_date_status_idx" ON "public"."schedules"("schedule_date", "status");
CREATE INDEX IF NOT EXISTS "schedules_assigned_to_schedule_date_idx" ON "public"."schedules"("assigned_to", "schedule_date");
CREATE INDEX IF NOT EXISTS "schedules_status_priority_idx" ON "public"."schedules"("status", "priority");
CREATE INDEX IF NOT EXISTS "schedules_schedule_type_schedule_date_idx" ON "public"."schedules"("schedule_type", "schedule_date");
-- Removed: schedules_is_completed_schedule_date_idx (column does not exist in schema)

-- ==========================================
-- PregnancyCheck ãƒ†ãƒ¼ãƒ–ãƒ«
-- ==========================================
CREATE INDEX IF NOT EXISTS "pregnancy_checks_status_idx" ON "public"."pregnancy_checks"("status");
CREATE INDEX IF NOT EXISTS "pregnancy_checks_recorded_by_idx" ON "public"."pregnancy_checks"("recorded_by");
-- Removed: pregnancy_checks_breeding_record_id_check_date_idx (breeding_record_id column does not exist)
-- Fixed: Use mother_id instead
CREATE INDEX IF NOT EXISTS "pregnancy_checks_mother_id_check_date_idx" ON "public"."pregnancy_checks"("mother_id", "check_date");
CREATE INDEX IF NOT EXISTS "pregnancy_checks_status_check_date_idx" ON "public"."pregnancy_checks"("status", "check_date");

-- ==========================================
-- BirthPlan ãƒ†ãƒ¼ãƒ–ãƒ«
-- ==========================================
CREATE INDEX IF NOT EXISTS "birth_plans_status_idx" ON "public"."birth_plans"("status");
CREATE INDEX IF NOT EXISTS "birth_plans_recorded_by_idx" ON "public"."birth_plans"("recorded_by");
CREATE INDEX IF NOT EXISTS "birth_plans_actual_birth_date_idx" ON "public"."birth_plans"("actual_birth_date");
-- Removed: birth_plans_breeding_record_id_expected_birth_date_idx (breeding_record_id column does not exist)
-- Fixed: Use mother_id instead
CREATE INDEX IF NOT EXISTS "birth_plans_mother_id_expected_birth_date_idx" ON "public"."birth_plans"("mother_id", "expected_birth_date");
CREATE INDEX IF NOT EXISTS "birth_plans_status_expected_birth_date_idx" ON "public"."birth_plans"("status", "expected_birth_date");
CREATE INDEX IF NOT EXISTS "birth_plans_actual_birth_date_status_idx" ON "public"."birth_plans"("actual_birth_date", "status");

-- ==========================================
-- MedicalRecord ãƒ†ãƒ¼ãƒ–ãƒ«
-- ==========================================
CREATE INDEX IF NOT EXISTS "medical_records_status_idx" ON "public"."medical_records"("status");
CREATE INDEX IF NOT EXISTS "medical_records_recorded_by_idx" ON "public"."medical_records"("recorded_by");
CREATE INDEX IF NOT EXISTS "medical_records_cat_id_visit_date_idx" ON "public"."medical_records"("cat_id", "visit_date");
CREATE INDEX IF NOT EXISTS "medical_records_visit_type_id_visit_date_idx" ON "public"."medical_records"("visit_type_id", "visit_date");
CREATE INDEX IF NOT EXISTS "medical_records_status_visit_date_idx" ON "public"."medical_records"("status", "visit_date");

-- ==========================================
-- Shift ãƒ†ãƒ¼ãƒ–ãƒ«
-- ==========================================
CREATE INDEX IF NOT EXISTS "shifts_staff_id_shift_date_idx" ON "public"."shifts"("staff_id", "shift_date");
CREATE INDEX IF NOT EXISTS "shifts_shift_date_status_idx" ON "public"."shifts"("shift_date", "status");
CREATE INDEX IF NOT EXISTS "shifts_status_shift_date_idx" ON "public"."shifts"("status", "shift_date");

-- ==========================================
-- Staff ãƒ†ãƒ¼ãƒ–ãƒ«
-- ==========================================
CREATE INDEX IF NOT EXISTS "staff_name_idx" ON "public"."staff"("name");
CREATE INDEX IF NOT EXISTS "staff_email_idx" ON "public"."staff"("email");
CREATE INDEX IF NOT EXISTS "staff_is_active_idx" ON "public"."staff"("is_active");
CREATE INDEX IF NOT EXISTS "staff_is_active_role_idx" ON "public"."staff"("is_active", "role");

-- ==========================================
-- StaffAvailability ãƒ†ãƒ¼ãƒ–ãƒ«
-- ==========================================
CREATE INDEX IF NOT EXISTS "staff_availabilities_day_of_week_idx" ON "public"."staff_availabilities"("day_of_week");
CREATE INDEX IF NOT EXISTS "staff_availabilities_is_available_idx" ON "public"."staff_availabilities"("is_available");
CREATE INDEX IF NOT EXISTS "staff_availabilities_staff_id_day_of_week_idx" ON "public"."staff_availabilities"("staff_id", "day_of_week");
CREATE INDEX IF NOT EXISTS "staff_availabilities_day_of_week_is_available_idx" ON "public"."staff_availabilities"("day_of_week", "is_available");
`````

## File: backend/prisma/migrations/20251117001521_add_pedigrees_api/migration.sql
`````sql
-- DropIndex
DROP INDEX "birth_plans_actual_birth_date_status_idx";

-- DropIndex
DROP INDEX "breeding_records_status_breeding_date_idx";

-- DropIndex
DROP INDEX "care_records_recorded_by_care_date_idx";

-- DropIndex
DROP INDEX "cats_breed_id_birth_date_idx";

-- DropIndex
DROP INDEX "cats_gender_birth_date_idx";

-- DropIndex
DROP INDEX "pedigrees_birth_date_idx";

-- DropIndex
DROP INDEX "pedigrees_pedigree_id_birth_date_idx";

-- CreateIndex
CREATE INDEX "birth_plans_expected_birth_date_status_idx" ON "birth_plans"("expected_birth_date", "status");

-- CreateIndex
CREATE INDEX "breeding_records_male_id_female_id_idx" ON "breeding_records"("male_id", "female_id");

-- CreateIndex
CREATE INDEX "breeding_records_breeding_date_status_idx" ON "breeding_records"("breeding_date", "status");

-- CreateIndex
CREATE INDEX "care_records_cat_id_care_type_idx" ON "care_records"("cat_id", "care_type");

-- CreateIndex
CREATE INDEX "cats_breed_id_name_idx" ON "cats"("breed_id", "name");

-- CreateIndex
CREATE INDEX "cats_birth_date_gender_idx" ON "cats"("birth_date", "gender");

-- CreateIndex
CREATE INDEX "pedigrees_breed_code_cat_name_idx" ON "pedigrees"("breed_code", "cat_name");

-- CreateIndex
CREATE INDEX "schedules_cat_id_schedule_date_idx" ON "schedules"("cat_id", "schedule_date");

-- CreateIndex
CREATE INDEX "shift_templates_name_idx" ON "shift_templates"("name");

-- CreateIndex
CREATE INDEX "shift_templates_display_order_idx" ON "shift_templates"("display_order");
`````

## File: backend/prisma/migrations/20251117090000_add_display_preferences/migration.sql
`````sql
-- DisplayPreference model introduction
-- Adds user-specific display name configuration for master data

-- CreateEnum
CREATE TYPE "DisplayNameMode" AS ENUM ('CANONICAL', 'CODE_AND_NAME', 'CUSTOM');

-- CreateTable
CREATE TABLE "display_preferences" (
    "id" TEXT NOT NULL,
    "user_id" TEXT NOT NULL,
    "breed_name_mode" "DisplayNameMode" NOT NULL DEFAULT 'CANONICAL',
    "coat_color_name_mode" "DisplayNameMode" NOT NULL DEFAULT 'CANONICAL',
    "breed_name_overrides" JSONB,
    "coat_color_name_overrides" JSONB,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "display_preferences_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "display_preferences_user_id_key" ON "display_preferences"("user_id");

-- AddForeignKey
ALTER TABLE "display_preferences"
ADD CONSTRAINT "display_preferences_user_id_fkey"
FOREIGN KEY ("user_id") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;
`````

## File: backend/prisma/migrations/20251117171013_add_remove_coat_color_name_unique/migration.sql
`````sql
-- DropIndex
DROP INDEX "coat_colors_name_key";
`````

## File: backend/prisma/migrations/20251118001209_add_performance_indexes/migration.sql
`````sql
-- CreateIndex
CREATE INDEX "cats_created_at_idx" ON "cats"("created_at");

-- CreateIndex
CREATE INDEX "cats_updated_at_idx" ON "cats"("updated_at");

-- CreateIndex
CREATE INDEX "pedigrees_cat_name2_idx" ON "pedigrees"("cat_name2");

-- CreateIndex
CREATE INDEX "pedigrees_eye_color_idx" ON "pedigrees"("eye_color");

-- CreateIndex
CREATE INDEX "pedigrees_breeder_name_idx" ON "pedigrees"("breeder_name");

-- CreateIndex
CREATE INDEX "pedigrees_owner_name_idx" ON "pedigrees"("owner_name");

-- CreateIndex
CREATE INDEX "pedigrees_birth_date_idx" ON "pedigrees"("birth_date");

-- CreateIndex
CREATE INDEX "pedigrees_registration_date_idx" ON "pedigrees"("registration_date");

-- CreateIndex
CREATE INDEX "pedigrees_created_at_idx" ON "pedigrees"("created_at");

-- CreateIndex
CREATE INDEX "pedigrees_updated_at_idx" ON "pedigrees"("updated_at");

-- AddForeignKey
ALTER TABLE "cats" ADD CONSTRAINT "cats_pedigree_id_fkey" FOREIGN KEY ("pedigree_id") REFERENCES "pedigrees"("pedigree_id") ON DELETE SET NULL ON UPDATE CASCADE;
`````

## File: backend/prisma/migrations/20251126000000_add_multi_tenant_support/migration.sql
`````sql
-- CreateEnum
ALTER TYPE "UserRole" ADD VALUE 'TENANT_ADMIN';

-- CreateTable
CREATE TABLE "tenants" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "slug" TEXT NOT NULL,
    "is_active" BOOLEAN NOT NULL DEFAULT true,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "tenants_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "invitation_tokens" (
    "id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "token" TEXT NOT NULL,
    "role" "UserRole" NOT NULL,
    "tenant_id" TEXT NOT NULL,
    "expires_at" TIMESTAMP(3) NOT NULL,
    "used_at" TIMESTAMP(3),
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "invitation_tokens_pkey" PRIMARY KEY ("id")
);

-- AlterTable
ALTER TABLE "users" ADD COLUMN "tenant_id" TEXT;

-- CreateIndex
CREATE UNIQUE INDEX "tenants_slug_key" ON "tenants"("slug");

-- CreateIndex
CREATE INDEX "tenants_slug_idx" ON "tenants"("slug");

-- CreateIndex
CREATE INDEX "tenants_is_active_idx" ON "tenants"("is_active");

-- CreateIndex
CREATE UNIQUE INDEX "invitation_tokens_token_key" ON "invitation_tokens"("token");

-- CreateIndex
CREATE INDEX "invitation_tokens_email_idx" ON "invitation_tokens"("email");

-- CreateIndex
CREATE INDEX "invitation_tokens_token_idx" ON "invitation_tokens"("token");

-- CreateIndex
CREATE INDEX "invitation_tokens_tenant_id_idx" ON "invitation_tokens"("tenant_id");

-- CreateIndex
CREATE INDEX "invitation_tokens_expires_at_idx" ON "invitation_tokens"("expires_at");

-- CreateIndex
CREATE INDEX "users_tenant_id_idx" ON "users"("tenant_id");

-- CreateIndex
CREATE INDEX "users_tenant_id_role_idx" ON "users"("tenant_id", "role");

-- AddForeignKey
ALTER TABLE "invitation_tokens" ADD CONSTRAINT "invitation_tokens_tenant_id_fkey" FOREIGN KEY ("tenant_id") REFERENCES "tenants"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "users" ADD CONSTRAINT "users_tenant_id_fkey" FOREIGN KEY ("tenant_id") REFERENCES "tenants"("id") ON DELETE SET NULL ON UPDATE CASCADE;
`````

## File: backend/prisma/migrations/20251129203404_add_staff_working_schedule/migration.sql
`````sql
-- AlterTable
ALTER TABLE "staff" ADD COLUMN     "work_time_template" JSONB,
ADD COLUMN     "working_days" JSONB;
`````

## File: backend/prisma/migrations/20251206064624_add_gallery_models/migration.sql
`````sql
-- CreateEnum
CREATE TYPE "GalleryCategory" AS ENUM ('KITTEN', 'FATHER', 'MOTHER', 'GRADUATION');

-- CreateEnum
CREATE TYPE "MediaType" AS ENUM ('IMAGE', 'YOUTUBE');

-- CreateTable
CREATE TABLE "gallery_entries" (
    "id" TEXT NOT NULL,
    "category" "GalleryCategory" NOT NULL,
    "name" TEXT NOT NULL,
    "gender" TEXT NOT NULL,
    "coat_color" TEXT,
    "breed" TEXT,
    "cat_id" TEXT,
    "transfer_date" TIMESTAMP(3),
    "destination" TEXT,
    "external_link" TEXT,
    "transferred_by" TEXT,
    "cat_snapshot" JSONB,
    "notes" TEXT,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "gallery_entries_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "gallery_media" (
    "id" TEXT NOT NULL,
    "gallery_entry_id" TEXT NOT NULL,
    "type" "MediaType" NOT NULL,
    "url" TEXT NOT NULL,
    "thumbnail_url" TEXT,
    "order" INTEGER NOT NULL DEFAULT 0,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "gallery_media_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "gallery_entries_category_idx" ON "gallery_entries"("category");

-- CreateIndex
CREATE INDEX "gallery_entries_cat_id_idx" ON "gallery_entries"("cat_id");

-- CreateIndex
CREATE INDEX "gallery_entries_created_at_idx" ON "gallery_entries"("created_at");

-- CreateIndex
CREATE INDEX "gallery_entries_category_created_at_idx" ON "gallery_entries"("category", "created_at");

-- CreateIndex
CREATE INDEX "gallery_media_gallery_entry_id_idx" ON "gallery_media"("gallery_entry_id");

-- CreateIndex
CREATE INDEX "gallery_media_order_idx" ON "gallery_media"("order");

-- AddForeignKey
ALTER TABLE "gallery_entries" ADD CONSTRAINT "gallery_entries_cat_id_fkey" FOREIGN KEY ("cat_id") REFERENCES "cats"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "gallery_media" ADD CONSTRAINT "gallery_media_gallery_entry_id_fkey" FOREIGN KEY ("gallery_entry_id") REFERENCES "gallery_entries"("id") ON DELETE CASCADE ON UPDATE CASCADE;
`````

## File: backend/prisma/migrations/20251210203339_add_tenant_settings/migration.sql
`````sql
-- CreateTable
CREATE TABLE "tenant_settings" (
    "id" TEXT NOT NULL,
    "tenant_id" TEXT NOT NULL,
    "tag_color_defaults" JSONB,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "tenant_settings_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "tenant_settings_tenant_id_key" ON "tenant_settings"("tenant_id");

-- AddForeignKey
ALTER TABLE "tenant_settings" ADD CONSTRAINT "tenant_settings_tenant_id_fkey" FOREIGN KEY ("tenant_id") REFERENCES "tenants"("id") ON DELETE CASCADE ON UPDATE CASCADE;
`````

## File: backend/prisma/migrations/20251212231309_add_print_template_with_category_tenant/migration.sql
`````sql
-- CreateEnum
CREATE TYPE "PrintTemplateCategory" AS ENUM ('PEDIGREE', 'KITTEN_TRANSFER', 'HEALTH_CERTIFICATE', 'VACCINATION_RECORD', 'BREEDING_RECORD', 'CONTRACT', 'INVOICE', 'CUSTOM');

-- CreateTable
CREATE TABLE "print_templates" (
    "id" TEXT NOT NULL,
    "tenant_id" TEXT,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "category" "PrintTemplateCategory" NOT NULL DEFAULT 'PEDIGREE',
    "paper_width" INTEGER NOT NULL,
    "paper_height" INTEGER NOT NULL,
    "background_url" TEXT,
    "background_opacity" INTEGER NOT NULL DEFAULT 100,
    "positions" JSONB NOT NULL,
    "font_sizes" JSONB,
    "is_active" BOOLEAN NOT NULL DEFAULT true,
    "is_default" BOOLEAN NOT NULL DEFAULT false,
    "display_order" INTEGER NOT NULL DEFAULT 0,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "print_templates_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "print_templates_tenant_id_idx" ON "print_templates"("tenant_id");

-- CreateIndex
CREATE INDEX "print_templates_category_idx" ON "print_templates"("category");

-- CreateIndex
CREATE INDEX "print_templates_is_active_idx" ON "print_templates"("is_active");

-- CreateIndex
CREATE INDEX "print_templates_name_idx" ON "print_templates"("name");

-- CreateIndex
CREATE INDEX "print_templates_tenant_id_category_is_active_idx" ON "print_templates"("tenant_id", "category", "is_active");
`````

## File: backend/prisma/migrations/20251219032719_add_weight_records/migration.sql
`````sql
-- CreateTable
CREATE TABLE "weight_records" (
    "id" TEXT NOT NULL,
    "cat_id" TEXT NOT NULL,
    "weight" DOUBLE PRECISION NOT NULL,
    "recorded_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "notes" TEXT,
    "recorded_by" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "weight_records_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "weight_records_cat_id_idx" ON "weight_records"("cat_id");

-- CreateIndex
CREATE INDEX "weight_records_recorded_at_idx" ON "weight_records"("recorded_at");

-- CreateIndex
CREATE INDEX "weight_records_cat_id_recorded_at_idx" ON "weight_records"("cat_id", "recorded_at");

-- AddForeignKey
ALTER TABLE "weight_records" ADD CONSTRAINT "weight_records_cat_id_fkey" FOREIGN KEY ("cat_id") REFERENCES "cats"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "weight_records" ADD CONSTRAINT "weight_records_recorded_by_fkey" FOREIGN KEY ("recorded_by") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
`````

## File: backend/prisma/migrations/20251219090000_add_pedigree_print_settings/migration.sql
`````sql
-- CreateTable
CREATE TABLE "pedigree_print_settings" (
    "id" TEXT NOT NULL,
    "tenant_id" TEXT,
    "global_key" TEXT,
    "settings" JSONB NOT NULL,
    "version" INTEGER NOT NULL DEFAULT 1,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "pedigree_print_settings_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "pedigree_print_settings_global_key_key" ON "pedigree_print_settings"("global_key");

-- CreateIndex
CREATE UNIQUE INDEX "pedigree_print_settings_tenant_id_key" ON "pedigree_print_settings"("tenant_id");

-- AddForeignKey
ALTER TABLE "pedigree_print_settings" ADD CONSTRAINT "pedigree_print_settings_tenant_id_fkey" FOREIGN KEY ("tenant_id") REFERENCES "tenants"("id") ON DELETE CASCADE ON UPDATE CASCADE;
`````

## File: backend/prisma/migrations/20251220010039_add_breeding_schedule_and_mating_check/migration.sql
`````sql
-- CreateEnum
CREATE TYPE "BreedingScheduleStatus" AS ENUM ('SCHEDULED', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED');

-- CreateTable
CREATE TABLE "breeding_schedules" (
    "id" TEXT NOT NULL,
    "male_id" TEXT NOT NULL,
    "female_id" TEXT NOT NULL,
    "start_date" TIMESTAMP(3) NOT NULL,
    "duration" INTEGER NOT NULL,
    "status" "BreedingScheduleStatus" NOT NULL DEFAULT 'SCHEDULED',
    "notes" TEXT,
    "recorded_by" TEXT NOT NULL,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "breeding_schedules_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "mating_checks" (
    "id" TEXT NOT NULL,
    "schedule_id" TEXT NOT NULL,
    "check_date" TIMESTAMP(3) NOT NULL,
    "count" INTEGER NOT NULL DEFAULT 1,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "mating_checks_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "breeding_schedules_male_id_idx" ON "breeding_schedules"("male_id");

-- CreateIndex
CREATE INDEX "breeding_schedules_female_id_idx" ON "breeding_schedules"("female_id");

-- CreateIndex
CREATE INDEX "breeding_schedules_start_date_idx" ON "breeding_schedules"("start_date");

-- CreateIndex
CREATE INDEX "breeding_schedules_status_idx" ON "breeding_schedules"("status");

-- CreateIndex
CREATE INDEX "breeding_schedules_male_id_start_date_idx" ON "breeding_schedules"("male_id", "start_date");

-- CreateIndex
CREATE INDEX "breeding_schedules_female_id_start_date_idx" ON "breeding_schedules"("female_id", "start_date");

-- CreateIndex
CREATE INDEX "mating_checks_schedule_id_idx" ON "mating_checks"("schedule_id");

-- CreateIndex
CREATE INDEX "mating_checks_check_date_idx" ON "mating_checks"("check_date");

-- AddForeignKey
ALTER TABLE "breeding_schedules" ADD CONSTRAINT "breeding_schedules_male_id_fkey" FOREIGN KEY ("male_id") REFERENCES "cats"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "breeding_schedules" ADD CONSTRAINT "breeding_schedules_female_id_fkey" FOREIGN KEY ("female_id") REFERENCES "cats"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "breeding_schedules" ADD CONSTRAINT "breeding_schedules_recorded_by_fkey" FOREIGN KEY ("recorded_by") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "mating_checks" ADD CONSTRAINT "mating_checks_schedule_id_fkey" FOREIGN KEY ("schedule_id") REFERENCES "breeding_schedules"("id") ON DELETE CASCADE ON UPDATE CASCADE;
`````

## File: backend/prisma/migrations/20251223003428_202512230930_add_tags_auto_new_style/migration.sql
`````sql
-- AlterEnum
ALTER TYPE "TagAutomationEventType" ADD VALUE 'TAG_ASSIGNED';
`````

## File: backend/prisma/migrations/migration_lock.toml
`````toml
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
`````

## File: backend/prisma/seed/convert_csv_header_to_snake_case.py
`````python
import csv
import re

# å¤‰æ›å¯¾è±¡CSV
INPUT = "/Users/nekoya/mycats/backend/prisma/seed/testdatepedigrees100.csv"
OUTPUT = "/Users/nekoya/mycats/backend/prisma/seed/testdatepedigrees100_snake.csv"

# CamelCaseâ†’snake_caseå¤‰æ›é–¢æ•°
# ä¾‹: CatName â†’ cat_name
#     PedigreeID â†’ pedigree_id
#     FFJCU â†’ ff_jcu

def camel_to_snake(name):
    s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
    s2 = re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1)
    # å…ˆé ­ã®ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã‚’å‰Šé™¤ï¼ˆä¾‹: _pedigree_id â†’ pedigree_idï¼‰
    return s2.lower().lstrip('_')

# BOMã‚’é™¤å»ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€
with open(INPUT, encoding="utf-8-sig") as fin, open(OUTPUT, "w", encoding="utf-8", newline="") as fout:
    reader = csv.reader(fin)
    writer = csv.writer(fout)
    header = next(reader)
    snake_header = [camel_to_snake(h.strip()) for h in header]
    writer.writerow(snake_header)
    for row in reader:
        writer.writerow(row)

print(f"å¤‰æ›å®Œäº†: {OUTPUT}")
`````

## File: backend/prisma/seed/current_data.sql
`````sql
pg_dump: warning: there are circular foreign-key constraints on this table:
pg_dump: detail: cats
pg_dump: hint: You might not be able to restore the dump without using --disable-triggers or temporarily dropping the constraints.
pg_dump: hint: Consider using a full dump instead of a --data-only dump to avoid this problem.
--
-- PostgreSQL database dump
--

\restrict beg15tobo1hQN1tadNy5zpqWHmzPuKPEAnFHYadnd9f6aE92dtH3JEiiSqYJFSa

-- Dumped from database version 15.14
-- Dumped by pg_dump version 15.14

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Data for Name: breeds; Type: TABLE DATA; Schema: public; Owner: mycats
--



--
-- Data for Name: coat_colors; Type: TABLE DATA; Schema: public; Owner: mycats
--



--
-- Data for Name: cats; Type: TABLE DATA; Schema: public; Owner: mycats
--



--
-- Data for Name: tags; Type: TABLE DATA; Schema: public; Owner: mycats
--



--
-- Data for Name: cat_tags; Type: TABLE DATA; Schema: public; Owner: mycats
--



--
-- Data for Name: users; Type: TABLE DATA; Schema: public; Owner: mycats
--



--
-- PostgreSQL database dump complete
--

\unrestrict beg15tobo1hQN1tadNy5zpqWHmzPuKPEAnFHYadnd9f6aE92dtH3JEiiSqYJFSa
`````

## File: backend/prisma/seed/import-breeds.ts
`````typescript
/**
 * Breed Data Import Script
 * çŒ«ç¨®ãƒ‡ãƒ¼ã‚¿UTF8Ver.csv ã‹ã‚‰ Breed ãƒ†ãƒ¼ãƒ–ãƒ«ã«ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
 */

import { PrismaClient } from '@prisma/client';
import * as fs from 'fs';
import * as path from 'path';
import { parse } from 'csv-parse/sync';

const prisma = new PrismaClient();

interface BreedCsvRow {
  ã‚­ãƒ¼: string;
  ç¨®é¡åç§°: string;
}

async function importBreeds() {
  try {
    console.log('ğŸš€ Starting Breed data import...\n');

    // CSV ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
    const csvPath = path.join(__dirname, 'çŒ«ç¨®ãƒ‡ãƒ¼ã‚¿UTF8Ver.csv');
    const fileContent = fs.readFileSync(csvPath, 'utf-8');

    console.log(`ğŸ“ Reading from: ${csvPath}`);

    // CSV ã‚’ãƒ‘ãƒ¼ã‚¹
    const records: BreedCsvRow[] = parse(fileContent, {
      columns: true,
      skip_empty_lines: true,
      trim: true,
      bom: true, // UTF-8 BOMå¯¾å¿œ
    });

    console.log(`ğŸ“Š Found ${records.length} breed records in CSV\n`);

    // æ—¢å­˜ã®Breedãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤
    const deleteResult = await prisma.breed.deleteMany({});
    console.log(`ğŸ—‘ï¸  Deleted ${deleteResult.count} existing breed records\n`);

    let successCount = 0;
    let errorCount = 0;

    // å„ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
    for (const record of records) {
      try {
        const code = parseInt(record.ã‚­ãƒ¼.trim(), 10);
        const name = record.ç¨®é¡åç§°.trim();

        // code=0 ã®å ´åˆã¯ç©ºæ–‡å­—ã€ãã‚Œä»¥å¤–ã¯nameã‚’ãã®ã¾ã¾ä½¿ç”¨
        const breedName = code === 0 ? 'Unknown' : name;

        await prisma.breed.create({
          data: {
            id: `breed-${code}`, // code-based ID for consistency
            code: code,
            name: breedName,
            description: code === 0 ? 'Unknown/Unspecified breed' : name,
            isActive: true,
          },
        });

        console.log(`âœ… Imported: code=${code}, name="${breedName}"`);
        successCount++;
      } catch (error: any) {
        console.error(`âŒ Error importing record:`, record, error.message);
        errorCount++;
      }
    }

    console.log('\n' + '='.repeat(60));
    console.log('ğŸ“ˆ Import Summary:');
    console.log(`   âœ… Success: ${successCount}`);
    console.log(`   âŒ Errors:  ${errorCount}`);
    console.log(`   ğŸ“Š Total:   ${records.length}`);
    console.log('='.repeat(60) + '\n');

    // ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¾Œã®ç¢ºèª
    const totalBreeds = await prisma.breed.count();
    console.log(`ğŸ” Verification: ${totalBreeds} breeds in database\n`);

    // æœ€åˆã®10ä»¶ã‚’è¡¨ç¤º
    const sampleBreeds = await prisma.breed.findMany({
      take: 10,
      orderBy: { code: 'asc' },
    });

    console.log('ğŸ“‹ Sample Breed Records:');
    sampleBreeds.forEach((breed) => {
      console.log(`   code=${breed.code}: "${breed.name}"`);
    });

  } catch (error: any) {
    console.error('ğŸ’¥ Fatal error during import:', error.message);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

// ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œ
importBreeds()
  .then(() => {
    console.log('\nâœ¨ Breed import completed successfully!');
    process.exit(0);
  })
  .catch((error) => {
    console.error('\nğŸ’€ Breed import failed:', error);
    process.exit(1);
  });
`````

## File: backend/prisma/seed/import-coat-colors.ts
`````typescript
/**
 * CoatColor Data Import Script
 * è‰²æŸ„ãƒ‡ãƒ¼ã‚¿UTF8Ver.csv ã‹ã‚‰ CoatColor ãƒ†ãƒ¼ãƒ–ãƒ«ã«ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
 */

import { PrismaClient } from '@prisma/client';
import * as fs from 'fs';
import * as path from 'path';
import { parse } from 'csv-parse/sync';

const prisma = new PrismaClient();

interface CoatColorCsvRow {
  ã‚­ãƒ¼: string;
  æ¯›è‰²åç§°: string;
}

async function importCoatColors() {
  try {
    console.log('ğŸš€ Starting CoatColor data import...\n');

    // CSV ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
    const csvPath = path.join(__dirname, 'è‰²æŸ„ãƒ‡ãƒ¼ã‚¿UTF8Ver.csv');
    const fileContent = fs.readFileSync(csvPath, 'utf-8');

    console.log(`ğŸ“ Reading from: ${csvPath}`);

    // CSV ã‚’ãƒ‘ãƒ¼ã‚¹
    const records: CoatColorCsvRow[] = parse(fileContent, {
      columns: true,
      skip_empty_lines: true,
      trim: true,
      bom: true, // UTF-8 BOMå¯¾å¿œ
    });

    console.log(`ğŸ“Š Found ${records.length} coat color records in CSV\n`);

    // æ—¢å­˜ã®CoatColorãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤
    const deleteResult = await prisma.coatColor.deleteMany({});
    console.log(`ğŸ—‘ï¸  Deleted ${deleteResult.count} existing coat color records\n`);

    let successCount = 0;
    let errorCount = 0;

    // å„ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
    for (const record of records) {
      try {
        const code = parseInt(record.ã‚­ãƒ¼.trim(), 10);
        const name = record.æ¯›è‰²åç§°.trim();

        // code=0 ã®å ´åˆã¯ç©ºæ–‡å­—ã€ãã‚Œä»¥å¤–ã¯nameã‚’ãã®ã¾ã¾ä½¿ç”¨
        const colorName = code === 0 ? 'Unknown' : name;

        await prisma.coatColor.create({
          data: {
            id: `coat-color-${code}`, // code-based ID for consistency
            code: code,
            name: colorName,
            description: code === 0 ? 'Unknown/Unspecified color' : name,
            isActive: true,
          },
        });

        console.log(`âœ… Imported: code=${code}, name="${colorName}"`);
        successCount++;
      } catch (error: any) {
        console.error(`âŒ Error importing record:`, record, error.message);
        errorCount++;
      }
    }

    console.log('\n' + '='.repeat(60));
    console.log('ğŸ“ˆ Import Summary:');
    console.log(`   âœ… Success: ${successCount}`);
    console.log(`   âŒ Errors:  ${errorCount}`);
    console.log(`   ğŸ“Š Total:   ${records.length}`);
    console.log('='.repeat(60) + '\n');

    // ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¾Œã®ç¢ºèª
    const totalColors = await prisma.coatColor.count();
    console.log(`ğŸ” Verification: ${totalColors} coat colors in database\n`);

    // æœ€åˆã®10ä»¶ã‚’è¡¨ç¤º
    const sampleColors = await prisma.coatColor.findMany({
      take: 10,
      orderBy: { code: 'asc' },
    });

    console.log('ğŸ“‹ Sample CoatColor Records:');
    sampleColors.forEach((color) => {
      console.log(`   code=${color.code}: "${color.name}"`);
    });

  } catch (error: any) {
    console.error('ğŸ’¥ Fatal error during import:', error.message);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

// ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œ
importCoatColors()
  .then(() => {
    console.log('\nâœ¨ CoatColor import completed successfully!');
    process.exit(0);
  })
  .catch((error) => {
    console.error('\nğŸ’€ CoatColor import failed:', error);
    process.exit(1);
  });
`````

## File: backend/prisma/seed/import-direct.ts
`````typescript
import { Client } from 'pg';
import * as fs from 'fs';
import * as path from 'path';
import { parse } from 'csv-parse/sync';
import { randomUUID } from 'crypto';

/**
 * CSV record type definition for pedigree data
 */
interface PedigreeCSVRecord {
  pedigree_id: string;
  cat_name?: string;
  breed_code?: string;
  gender_code?: string;
  eye_color?: string;
  coat_color_code?: string;
  birth_date?: string;
  breeder_name?: string;
  registration_date?: string;
  brother_count?: string;
  sister_count?: string;
}

const client = new Client({
  host: 'localhost',
  port: 55432,
  user: 'runner',
  password: 'password',
  database: 'mycats_development',
});

async function main() {
  await client.connect();
  
  const csvFilePath = path.join(__dirname, 'testdatepedigrees100_snake.csv');
  const fileContent = fs.readFileSync(csvFilePath, 'utf-8');

  const records = parse(fileContent, {
    columns: true,
    skip_empty_lines: true,
    trim: true,
  }) as PedigreeCSVRecord[];

  console.log(`Found ${records.length} records to import`);

  let successCount = 0;
  let errorCount = 0;

  for (const record of records) {
    try {
      const id = randomUUID();
      const now = new Date();
      
      const pedigreeId = record.pedigree_id;
      
      if (!pedigreeId) {
        console.error('Skipping record with missing pedigree_id');
        errorCount++;
        continue;
      }

      const query = `
        INSERT INTO pedigrees (
          id, pedigree_id, cat_name, breed_code, gender_code, 
          eye_color, coat_color_code, birth_date, breeder_name,
          registration_date, brother_count, sister_count,
          created_at, updated_at
        ) VALUES (
          $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
        )
      `;
      
      await client.query(query, [
        id,
        pedigreeId,
        record.cat_name || null,
        record.breed_code ? parseInt(record.breed_code, 10) : null,
        record.gender_code ? parseInt(record.gender_code, 10) : null,
        record.eye_color || null,
        record.coat_color_code ? parseInt(record.coat_color_code, 10) : null,
        record.birth_date || null,
        record.breeder_name || null,
        record.registration_date || null,
        record.brother_count ? parseInt(record.brother_count, 10) : null,
        record.sister_count ? parseInt(record.sister_count, 10) : null,
        now,
        now,
      ]);
      
      successCount++;
      if (successCount % 10 === 0) {
        console.log(`Imported ${successCount} records...`);
      }
    } catch (error: unknown) {
      errorCount++;
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      console.error(`Error importing record ${record.pedigree_id}:`, errorMessage);
    }
  }

  console.log(`\nImport completed!`);
  console.log(`Success: ${successCount}`);
  console.log(`Errors: ${errorCount}`);
  
  await client.end();
}

main()
  .catch((e) => {
    console.error('Fatal error:', e);
    process.exit(1);
  });
`````

## File: backend/prisma/seed/import-genders.ts
`````typescript
/**
 * Gender Data Import Script
 * æ€§åˆ¥ãƒ‡ãƒ¼ã‚¿UTF8Ver.csv ã‹ã‚‰ Gender ãƒ†ãƒ¼ãƒ–ãƒ«ã«ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
 */

import { PrismaClient } from '@prisma/client';
import * as fs from 'fs';
import * as path from 'path';
import { parse } from 'csv-parse/sync';

const prisma = new PrismaClient();

interface GenderCsvRow {
  ã‚­ãƒ¼: string;
  æ€§åˆ¥åç§°: string;
}

async function importGenders() {
  try {
    console.log('ğŸš€ Starting Gender data import...\n');

    // CSV ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
    const csvPath = path.join(__dirname, 'æ€§åˆ¥ãƒ‡ãƒ¼ã‚¿UTF8Ver.csv');
    const fileContent = fs.readFileSync(csvPath, 'utf-8');

    console.log(`ğŸ“ Reading from: ${csvPath}`);

    // CSV ã‚’ãƒ‘ãƒ¼ã‚¹
    const records: GenderCsvRow[] = parse(fileContent, {
      columns: true,
      skip_empty_lines: true,
      trim: true,
      bom: true, // UTF-8 BOMå¯¾å¿œ
    });

    console.log(`ğŸ“Š Found ${records.length} gender records in CSV\n`);

    // æ—¢å­˜ã®Genderãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤
    const deleteResult = await prisma.gender.deleteMany({});
    console.log(`ğŸ—‘ï¸  Deleted ${deleteResult.count} existing gender records\n`);

    let successCount = 0;
    let errorCount = 0;

    // å„ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
    for (const record of records) {
      try {
        const code = parseInt(record.ã‚­ãƒ¼.trim(), 10);
        const name = record.æ€§åˆ¥åç§°.trim();

        // code=0 ã®å ´åˆã¯ç©ºæ–‡å­—ã€ãã‚Œä»¥å¤–ã¯nameã‚’ãã®ã¾ã¾ä½¿ç”¨
        const genderName = code === 0 ? '' : name;

        await prisma.gender.create({
          data: {
            id: `gender-${code}`, // code-based ID for consistency
            code: code,
            name: genderName,
            description: code === 0 ? 'Unknown/Unspecified' : name,
            isActive: true,
          },
        });

        console.log(`âœ… Imported: code=${code}, name="${genderName || '(empty)'}"`);
        successCount++;
      } catch (error: any) {
        console.error(`âŒ Error importing record:`, record, error.message);
        errorCount++;
      }
    }

    console.log('\n' + '='.repeat(60));
    console.log('ğŸ“ˆ Import Summary:');
    console.log(`   âœ… Success: ${successCount}`);
    console.log(`   âŒ Errors:  ${errorCount}`);
    console.log(`   ğŸ“Š Total:   ${records.length}`);
    console.log('='.repeat(60) + '\n');

    // ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¾Œã®ç¢ºèª
    const totalGenders = await prisma.gender.count();
    console.log(`ğŸ” Verification: ${totalGenders} genders in database\n`);

    // å…¨Genderãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤º
    const allGenders = await prisma.gender.findMany({
      orderBy: { code: 'asc' },
    });

    console.log('ğŸ“‹ All Gender Records:');
    allGenders.forEach((gender) => {
      console.log(`   code=${gender.code}: "${gender.name}" (${gender.description})`);
    });

  } catch (error: any) {
    console.error('ğŸ’¥ Fatal error during import:', error.message);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

// ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œ
importGenders()
  .then(() => {
    console.log('\nâœ¨ Gender import completed successfully!');
    process.exit(0);
  })
  .catch((error) => {
    console.error('\nğŸ’€ Gender import failed:', error);
    process.exit(1);
  });
`````

## File: backend/prisma/seed/import-pedigrees.ts
`````typescript
import { PrismaClient } from '@prisma/client';
import * as fs from 'fs';
import * as path from 'path';
import { parse } from 'csv-parse/sync';

const prisma = new PrismaClient();

interface PedigreeRecord {
  pedigree_id: string;
  title: string;
  cat_name: string;
  cat_name2: string;
  breed_code: string;
  gender_code: string;
  eye_color: string;
  coat_color_code: string;
  birth_date: string;
  breeder_name: string;
  owner_name: string;
  registration_date: string;
  brother_count: string;
  sister_count: string;
  notes: string;
  notes2: string;
  other_no: string;
  father_title: string;
  father_cat_name: string;
  father_cat_name2: string;
  father_coat_color: string;
  father_eye_color: string;
  father_jcu: string;
  father_other_code: string;
  mother_title: string;
  mother_cat_name: string;
  mother_cat_name2: string;
  mother_coat_color: string;
  mother_eye_color: string;
  mother_jcu: string;
  mother_other_code: string;
  ff_title: string;
  ff_cat_name: string;
  ff_cat_color: string;
  ffjcu: string;
  fm_title: string;
  fm_cat_name: string;
  fm_cat_color: string;
  fmjcu: string;
  mf_title: string;
  mf_cat_name: string;
  mf_cat_color: string;
  mfjcu: string;
  mm_title: string;
  mm_cat_name: string;
  mm_cat_color: string;
  mmjcu: string;
  fff_title: string;
  fff_cat_name: string;
  fff_cat_color: string;
  fffjcu: string;
  ffm_title: string;
  ffm_cat_name: string;
  ffm_cat_color: string;
  ffmjcu: string;
  fmf_title: string;
  fmf_cat_name: string;
  fmf_cat_color: string;
  fmfjcu: string;
  fmm_title: string;
  fmm_cat_name: string;
  fmm_cat_color: string;
  fmmjcu: string;
  mff_title: string;
  mff_cat_name: string;
  mff_cat_color: string;
  mffjcu: string;
  mfm_title: string;
  mfm_cat_name: string;
  mfm_cat_color: string;
  mfmjcu: string;
  mmf_title: string;
  mmf_cat_name: string;
  mmf_cat_color: string;
  mmfjcu: string;
  mmm_title: string;
  mmm_cat_name: string;
  mmm_cat_color: string;
  mmmjcu: string;
  old_code: string;
}

// æ•°å€¤ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å¤‰æ›ï¼ˆç©ºæ–‡å­—åˆ—ã¯nullã«ï¼‰
const parseIntOrNull = (value: string) => {
  if (!value || value.trim() === '') return null;
  const parsed = parseInt(value, 10);
  return isNaN(parsed) ? null : parsed;
};

// æ–‡å­—åˆ—ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å¤‰æ›ï¼ˆç©ºæ–‡å­—åˆ—ã¯undefinedã«ï¼‰
const parseStringOrUndefined = (value: string) => {
  if (!value || value.trim() === '') return undefined;
  return value;
};

async function main() {
  const csvFilePath = path.join(__dirname, 'testdatepedigrees100_snake.csv');
  const fileContent = fs.readFileSync(csvFilePath, 'utf-8');

  // CSVã‚’ãƒ‘ãƒ¼ã‚¹
  const records = parse(fileContent, {
    columns: true,
    skip_empty_lines: true,
    trim: true,
  }) as PedigreeRecord[];

  console.log(`Found ${records.length} records to import`);
  
  // ãƒ‡ãƒãƒƒã‚°: æœ€åˆã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’ç¢ºèª
  if (records.length > 0) {
    const firstRecord = records[0] as any;
    console.log('First record keys:', Object.keys(firstRecord));
    console.log('First record pedigree_id:', firstRecord['pedigree_id']);
  }

  let successCount = 0;
  let errorCount = 0;

  for (const record of records) {
    try {
      // pedigree_idã‚’å–å¾—
      const recordAny = record as any;
      const pedigreeIdValue = recordAny.pedigree_id || recordAny['pedigree_id'];
      
      if (!pedigreeIdValue) {
        console.error('Skipping record with missing pedigree_id');
        errorCount++;
        continue;
      }

      console.log(`About to insert: pedigreeId="${pedigreeIdValue}", type=${typeof pedigreeIdValue}, length=${pedigreeIdValue.length}`);

      await prisma.pedigree.create({
        data: {
          pedigreeId: pedigreeIdValue,
          title: parseStringOrUndefined(recordAny.title),
          catName: parseStringOrUndefined(recordAny.cat_name),
          catName2: parseStringOrUndefined(recordAny.cat_name2),
          breedCode: parseIntOrNull(recordAny.breed_code) ?? undefined,
          genderCode: parseIntOrNull(recordAny.gender_code) ?? undefined,
          eyeColor: parseStringOrUndefined(recordAny.eye_color),
          coatColorCode: parseIntOrNull(recordAny.coat_color_code) ?? undefined,
          birthDate: parseStringOrUndefined(recordAny.birth_date),
          breederName: parseStringOrUndefined(recordAny.breeder_name),
          ownerName: parseStringOrUndefined(recordAny.owner_name),
          registrationDate: parseStringOrUndefined(recordAny.registration_date),
          brotherCount: parseIntOrNull(recordAny.brother_count) ?? undefined,
          sisterCount: parseIntOrNull(recordAny.sister_count) ?? undefined,
          notes: parseStringOrUndefined(recordAny.notes),
          notes2: parseStringOrUndefined(recordAny.notes2),
          otherNo: parseStringOrUndefined(recordAny.other_no),
          fatherTitle: parseStringOrUndefined(recordAny.father_title),
          fatherCatName: parseStringOrUndefined(recordAny.father_cat_name),
          fatherCatName2: parseStringOrUndefined(recordAny.father_cat_name2),
          fatherCoatColor: parseStringOrUndefined(recordAny.father_coat_color),
          fatherEyeColor: parseStringOrUndefined(recordAny.father_eye_color),
          fatherJCU: parseStringOrUndefined(recordAny.father_jcu),
          fatherOtherCode: parseStringOrUndefined(recordAny.father_other_code),
          motherTitle: parseStringOrUndefined(recordAny.mother_title),
          motherCatName: parseStringOrUndefined(recordAny.mother_cat_name),
          motherCatName2: parseStringOrUndefined(recordAny.mother_cat_name2),
          motherCoatColor: parseStringOrUndefined(recordAny.mother_coat_color),
          motherEyeColor: parseStringOrUndefined(recordAny.mother_eye_color),
          motherJCU: parseStringOrUndefined(recordAny.mother_jcu),
          motherOtherCode: parseStringOrUndefined(recordAny.mother_other_code),
          ffTitle: parseStringOrUndefined(recordAny.ff_title),
          ffCatName: parseStringOrUndefined(recordAny.ff_cat_name),
          ffCatColor: parseStringOrUndefined(recordAny.ff_cat_color),
          ffjcu: parseStringOrUndefined(recordAny.ffjcu),
          fmTitle: parseStringOrUndefined(recordAny.fm_title),
          fmCatName: parseStringOrUndefined(recordAny.fm_cat_name),
          fmCatColor: parseStringOrUndefined(recordAny.fm_cat_color),
          fmjcu: parseStringOrUndefined(recordAny.fmjcu),
          mfTitle: parseStringOrUndefined(recordAny.mf_title),
          mfCatName: parseStringOrUndefined(recordAny.mf_cat_name),
          mfCatColor: parseStringOrUndefined(recordAny.mf_cat_color),
          mfjcu: parseStringOrUndefined(recordAny.mfjcu),
          mmTitle: parseStringOrUndefined(recordAny.mm_title),
          mmCatName: parseStringOrUndefined(recordAny.mm_cat_name),
          mmCatColor: parseStringOrUndefined(recordAny.mm_cat_color),
          mmjcu: parseStringOrUndefined(recordAny.mmjcu),
          fffTitle: parseStringOrUndefined(recordAny.fff_title),
          fffCatName: parseStringOrUndefined(recordAny.fff_cat_name),
          fffCatColor: parseStringOrUndefined(recordAny.fff_cat_color),
          fffjcu: parseStringOrUndefined(recordAny.fffjcu),
          ffmTitle: parseStringOrUndefined(recordAny.ffm_title),
          ffmCatName: parseStringOrUndefined(recordAny.ffm_cat_name),
          ffmCatColor: parseStringOrUndefined(recordAny.ffm_cat_color),
          ffmjcu: parseStringOrUndefined(recordAny.ffmjcu),
          fmfTitle: parseStringOrUndefined(recordAny.fmf_title),
          fmfCatName: parseStringOrUndefined(recordAny.fmf_cat_name),
          fmfCatColor: parseStringOrUndefined(recordAny.fmf_cat_color),
          fmfjcu: parseStringOrUndefined(recordAny.fmfjcu),
          fmmTitle: parseStringOrUndefined(recordAny.fmm_title),
          fmmCatName: parseStringOrUndefined(recordAny.fmm_cat_name),
          fmmCatColor: parseStringOrUndefined(recordAny.fmm_cat_color),
          fmmjcu: parseStringOrUndefined(recordAny.fmmjcu),
          mffTitle: parseStringOrUndefined(recordAny.mff_title),
          mffCatName: parseStringOrUndefined(recordAny.mff_cat_name),
          mffCatColor: parseStringOrUndefined(recordAny.mff_cat_color),
          mffjcu: parseStringOrUndefined(recordAny.mffjcu),
          mfmTitle: parseStringOrUndefined(recordAny.mfm_title),
          mfmCatName: parseStringOrUndefined(recordAny.mfm_cat_name),
          mfmCatColor: parseStringOrUndefined(recordAny.mfm_cat_color),
          mfmjcu: parseStringOrUndefined(recordAny.mfmjcu),
          mmfTitle: parseStringOrUndefined(recordAny.mmf_title),
          mmfCatName: parseStringOrUndefined(recordAny.mmf_cat_name),
          mmfCatColor: parseStringOrUndefined(recordAny.mmf_cat_color),
          mmfjcu: parseStringOrUndefined(recordAny.mmfjcu),
          mmmTitle: parseStringOrUndefined(recordAny.mmm_title),
          mmmCatName: parseStringOrUndefined(recordAny.mmm_cat_name),
          mmmCatColor: parseStringOrUndefined(recordAny.mmm_cat_color),
          mmmjcu: parseStringOrUndefined(recordAny.mmmjcu),
          oldCode: parseStringOrUndefined(recordAny.old_code),
        },
      });
      successCount++;
      if (successCount % 10 === 0) {
        console.log(`Imported ${successCount} records...`);
      }
    } catch (error) {
      errorCount++;
      console.error(`Error importing record ${record.pedigree_id}:`, error);
    }
  }

  console.log(`\nImport completed!`);
  console.log(`Success: ${successCount}`);
  console.log(`Errors: ${errorCount}`);
}

main()
  .catch((e) => {
    console.error('Fatal error:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
`````

## File: backend/prisma/seed/seed-staff-shifts.ts
`````typescript
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function seedStaffShifts() {
  console.log('ğŸŒ± Seeding Staff & Shift data...');

  // Create Staff
  const staff1 = await prisma.staff.upsert({
    where: { email: 'tanaka@example.com' },
    update: {},
    create: {
      name: 'ç”°ä¸­ å¤ªéƒ',
      email: 'tanaka@example.com',
      role: 'ä¸»ä»»',
      color: '#fd7e14',
    },
  });

  const staff2 = await prisma.staff.upsert({
    where: { email: 'suzuki@example.com' },
    update: {},
    create: {
      name: 'éˆ´æœ¨ èŠ±å­',
      email: 'suzuki@example.com',
      role: 'ã‚¹ã‚¿ãƒƒãƒ•',
      color: '#74c0fc',
    },
  });

  const staff3 = await prisma.staff.upsert({
    where: { email: 'yamada@example.com' },
    update: {},
    create: {
      name: 'å±±ç”° æ¬¡éƒ',
      email: 'yamada@example.com',
      role: 'ã‚¹ã‚¿ãƒƒãƒ•',
      color: '#51cf66',
    },
  });

  const staff4 = await prisma.staff.upsert({
    where: { email: 'sato@example.com' },
    update: {},
    create: {
      name: 'ä½è—¤ ç¾å’²',
      email: 'sato@example.com',
      role: 'ã‚¹ã‚¿ãƒƒãƒ•',
      color: '#ff6b6b',
    },
  });

  console.log('âœ… Created 4 staff members');

  // Create Shift Templates
  const morningTemplate =
    (await prisma.shiftTemplate.findFirst({ where: { name: 'åˆå‰' } })) ||
    (await prisma.shiftTemplate.create({
      data: {
        name: 'åˆå‰',
        startTime: '09:00',
        endTime: '13:00',
        duration: 240,
        color: '#ffd43b',
        breakTime: 0,
        displayOrder: 1,
      },
    }));

  const afternoonTemplate =
    (await prisma.shiftTemplate.findFirst({ where: { name: 'åˆå¾Œ' } })) ||
    (await prisma.shiftTemplate.create({
      data: {
        name: 'åˆå¾Œ',
        startTime: '14:00',
        endTime: '18:00',
        duration: 240,
        color: '#74c0fc',
        breakTime: 0,
        displayOrder: 2,
      },
    }));

  const fulldayTemplate =
    (await prisma.shiftTemplate.findFirst({ where: { name: 'çµ‚æ—¥' } })) ||
    (await prisma.shiftTemplate.create({
      data: {
        name: 'çµ‚æ—¥',
        startTime: '09:00',
        endTime: '18:00',
        duration: 540,
        color: '#51cf66',
        breakTime: 60,
        displayOrder: 3,
      },
    }));

  const nightTemplate =
    (await prisma.shiftTemplate.findFirst({ where: { name: 'å¤œé–“' } })) ||
    (await prisma.shiftTemplate.create({
      data: {
        name: 'å¤œé–“',
        startTime: '18:00',
        endTime: '22:00',
        duration: 240,
        color: '#be4bdb',
        breakTime: 0,
        displayOrder: 4,
      },
    }));

  console.log('âœ… Created 4 shift templates');

  // Create default ShiftSettings
  const settings = await prisma.shiftSettings.upsert({
    where: { id: 'default' },
    update: {},
    create: {
      id: 'default',
      defaultMode: 'SIMPLE',
      enabledModes: ['SIMPLE', 'DETAILED'],
      simpleRequireDisplayName: false,
      detailedRequireTime: true,
      detailedRequireTemplate: false,
      detailedEnableTasks: true,
      detailedEnableActual: true,
    },
  });

  console.log('âœ… Created shift settings');

  // Create sample shifts for current month
  const today = new Date();
  const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
  const endOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0);

  const shifts = [];
  for (let i = 0; i < 10; i++) {
    const randomDate = new Date(
      startOfMonth.getTime() +
        Math.random() * (endOfMonth.getTime() - startOfMonth.getTime()),
    );

    const staffList = [staff1, staff2, staff3, staff4];
    const randomStaff = staffList[Math.floor(Math.random() * staffList.length)];
    const templateList = [
      morningTemplate,
      afternoonTemplate,
      fulldayTemplate,
      nightTemplate,
    ];
    const randomTemplate =
      templateList[Math.floor(Math.random() * templateList.length)];

    shifts.push({
      staffId: randomStaff.id,
      shiftDate: randomDate,
      templateId: randomTemplate.id,
      mode: 'SIMPLE',
      status: 'SCHEDULED',
      displayName: randomTemplate.name,
    });
  }

  await prisma.shift.createMany({
    data: shifts,
    skipDuplicates: true,
  });

  console.log('âœ… Created sample shifts');

  console.log('ğŸ‰ Staff & Shift seeding completed!');
}

seedStaffShifts()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
`````

## File: backend/prisma/seed/verify-indexes.sql
`````sql
\pset pager off
\timing on

\echo 'Collecting sample filter values for pedigree queries'
WITH samples AS (
  SELECT
    COALESCE((SELECT breed_code FROM pedigrees WHERE breed_code IS NOT NULL LIMIT 1), 0) AS breed_code,
    COALESCE((SELECT coat_color_code FROM pedigrees WHERE coat_color_code IS NOT NULL LIMIT 1), 0) AS coat_color_code,
    COALESCE((SELECT gender_code FROM pedigrees WHERE gender_code IS NOT NULL LIMIT 1), 0) AS gender_code,
    COALESCE((SELECT eye_color FROM pedigrees WHERE eye_color IS NOT NULL LIMIT 1), '') AS eye_color,
    COALESCE((SELECT owner_name FROM pedigrees WHERE owner_name IS NOT NULL LIMIT 1), '') AS owner_name
)
SELECT * FROM samples;
\gset ped_

\echo '1) Cats pagination query (created_at index)'
EXPLAIN (ANALYZE, BUFFERS)
SELECT id, name, created_at
FROM cats
WHERE is_in_house = true
  AND is_graduated = false
ORDER BY created_at DESC
LIMIT 50;

\echo '2) Cats incremental sync query (updated_at index)'
EXPLAIN (ANALYZE, BUFFERS)
SELECT id, updated_at
FROM cats
WHERE updated_at >= NOW() - INTERVAL '30 days'
ORDER BY updated_at DESC
LIMIT 50;

\echo '3) Pedigree equality filters with registration_date ordering'
EXPLAIN (ANALYZE, BUFFERS)
SELECT id, pedigree_id, registration_date
FROM pedigrees
WHERE breed_code = :ped_breed_code
  AND coat_color_code = :ped_coat_color_code
  AND gender_code = :ped_gender_code
ORDER BY registration_date DESC
LIMIT 50;

\echo '4) Pedigree eye color / owner filters with created_at ordering'
EXPLAIN (ANALYZE, BUFFERS)
SELECT id, pedigree_id, owner_name
FROM pedigrees
WHERE eye_color = :'ped_eye_color'
  OR owner_name = :'ped_owner_name'
ORDER BY created_at DESC
LIMIT 50;
`````

## File: backend/prisma/schema.prisma
`````prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Tenant {
  id          String            @id @default(uuid())
  name        String
  slug        String            @unique
  isActive    Boolean           @default(true) @map("is_active")
  createdAt   DateTime          @default(now()) @map("created_at")
  updatedAt   DateTime          @updatedAt @map("updated_at")
  invitations InvitationToken[]
  settings    TenantSettings?
  users       User[]
  pedigreePrintSetting PedigreePrintSetting?

  @@index([slug])
  @@index([isActive])
  @@map("tenants")
}

model TenantSettings {
  id               String   @id @default(uuid())
  tenantId         String   @unique @map("tenant_id")
  tagColorDefaults Json?    @map("tag_color_defaults")
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt @map("updated_at")
  tenant           Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@map("tenant_settings")
}

model InvitationToken {
  id        String    @id @default(uuid())
  email     String
  token     String    @unique
  role      UserRole
  tenantId  String    @map("tenant_id")
  expiresAt DateTime  @map("expires_at")
  usedAt    DateTime? @map("used_at")
  createdAt DateTime  @default(now()) @map("created_at")
  tenant    Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([email])
  @@index([token])
  @@index([tenantId])
  @@index([expiresAt])
  @@map("invitation_tokens")
}

model User {
  id                   String             @id @default(uuid())
  clerkId              String             @unique @map("clerk_id")
  email                String             @unique
  firstName            String?            @map("first_name")
  lastName             String?            @map("last_name")
  role                 UserRole           @default(USER)
  isActive             Boolean            @default(true) @map("is_active")
  passwordHash         String?            @map("password_hash")
  refreshToken         String?            @map("refresh_token")
  failedLoginAttempts  Int                @default(0) @map("failed_login_attempts")
  lockedUntil          DateTime?          @map("locked_until")
  lastLoginAt          DateTime?          @map("last_login_at")
  createdAt            DateTime           @default(now()) @map("created_at")
  updatedAt            DateTime           @updatedAt @map("updated_at")
  resetPasswordExpires DateTime?          @map("reset_password_expires")
  resetPasswordToken   String?            @map("reset_password_token")
  tenantId             String?            @map("tenant_id")
  birthPlans           BirthPlan[]
  breedingRecords      BreedingRecord[]
  breedingSchedules    BreedingSchedule[]
  careRecords          CareRecord[]
  displayPreference    DisplayPreference?
  loginAttempts        LoginAttempt[]
  medicalRecords       MedicalRecord[]
  pregnancyChecks      PregnancyCheck[]
  schedules            Schedule[]
  staff                Staff?
  tenant               Tenant?            @relation(fields: [tenantId], references: [id])
  weightRecords        WeightRecord[]

  @@index([email])
  @@index([role])
  @@index([isActive])
  @@index([lastLoginAt])
  @@index([tenantId])
  @@index([role, isActive])
  @@index([isActive, lastLoginAt])
  @@index([tenantId, role])
  @@map("users")
}

model DisplayPreference {
  id                     String          @id @default(uuid())
  userId                 String          @unique @map("user_id")
  breedNameMode          DisplayNameMode @default(CANONICAL) @map("breed_name_mode")
  coatColorNameMode      DisplayNameMode @default(CANONICAL) @map("coat_color_name_mode")
  breedNameOverrides     Json?           @map("breed_name_overrides")
  coatColorNameOverrides Json?           @map("coat_color_name_overrides")
  createdAt              DateTime        @default(now()) @map("created_at")
  updatedAt              DateTime        @updatedAt @map("updated_at")
  user                   User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("display_preferences")
}

model LoginAttempt {
  id        String   @id @default(uuid())
  userId    String?  @map("user_id")
  email     String
  ipAddress String?  @map("ip_address")
  userAgent String?  @map("user_agent")
  success   Boolean
  reason    String?
  createdAt DateTime @default(now()) @map("created_at")
  user      User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([email])
  @@index([success])
  @@index([createdAt])
  @@index([email, createdAt])
  @@index([userId, createdAt])
  @@index([success, createdAt])
  @@map("login_attempts")
}

model Breed {
  id          String     @id @default(uuid())
  code        Int        @unique
  name        String     @unique
  description String?
  isActive    Boolean    @default(true) @map("is_active")
  createdAt   DateTime   @default(now()) @map("created_at")
  updatedAt   DateTime   @updatedAt @map("updated_at")
  cats        Cat[]
  pedigrees   Pedigree[]

  @@index([code])
  @@index([name])
  @@index([isActive])
  @@map("breeds")
}

model CoatColor {
  id          String     @id @default(uuid())
  code        Int        @unique
  name        String
  description String?
  isActive    Boolean    @default(true) @map("is_active")
  createdAt   DateTime   @default(now()) @map("created_at")
  updatedAt   DateTime   @updatedAt @map("updated_at")
  cats        Cat[]
  pedigrees   Pedigree[]

  @@index([code])
  @@index([name])
  @@index([isActive])
  @@map("coat_colors")
}

model Gender {
  id          String     @id @default(uuid())
  code        Int        @unique
  name        String     @unique
  description String?
  isActive    Boolean    @default(true) @map("is_active")
  createdAt   DateTime   @default(now()) @map("created_at")
  updatedAt   DateTime   @updatedAt @map("updated_at")
  pedigrees   Pedigree[]

  @@index([code])
  @@index([name])
  @@map("genders")
}

model Cat {
  id                    String                 @id @default(uuid())
  registrationNumber    String?                @unique @map("registration_number")
  name                  String
  breedId               String?                @map("breed_id")
  birthDate             DateTime               @map("birth_date")
  description           String?                @map("notes")
  fatherId              String?                @map("father_id")
  motherId              String?                @map("mother_id")
  createdAt             DateTime               @default(now()) @map("created_at")
  updatedAt             DateTime               @updatedAt @map("updated_at")
  pedigreeId            String?                @map("pedigree_id")
  gender                String
  coatColorId           String?                @map("coat_color_id")
  isInHouse             Boolean                @default(true) @map("is_in_house")
  microchipNumber       String?                @unique @map("microchip_number")
  isGraduated           Boolean                @default(false) @map("is_graduated")
  birthPlans            BirthPlan[]            @relation("BirthPlanMother")
  femaleBreedingRecords BreedingRecord[]       @relation("FemaleBreeding")
  maleBreedingRecords   BreedingRecord[]       @relation("MaleBreeding")
  maleBreedingSchedules BreedingSchedule[]     @relation("BreedingScheduleMale")
  femaleBreedingSchedules BreedingSchedule[]   @relation("BreedingScheduleFemale")
  careRecords           CareRecord[]
  tags                  CatTag[]
  breed                 Breed?                 @relation(fields: [breedId], references: [id])
  coatColor             CoatColor?             @relation(fields: [coatColorId], references: [id])
  father                Cat?                   @relation("CatFather", fields: [fatherId], references: [id])
  fatherOf              Cat[]                  @relation("CatFather")
  mother                Cat?                   @relation("CatMother", fields: [motherId], references: [id])
  motherOf              Cat[]                  @relation("CatMother")
  pedigree              Pedigree?              @relation("CatPedigree", fields: [pedigreeId], references: [pedigreeId])
  galleryEntries        GalleryEntry[]         @relation("GalleryEntryCat")
  graduation            Graduation?
  kittenDispositions    KittenDisposition[]
  medicalRecords        MedicalRecord[]
  pregnancyChecks       PregnancyCheck[]       @relation("PregnancyCheckMother")
  scheduleCats          ScheduleCat[]
  schedules             Schedule[]
  tagHistory            TagAssignmentHistory[]
  weightRecords         WeightRecord[]

  @@index([breedId])
  @@index([coatColorId])
  @@index([fatherId])
  @@index([motherId])
  @@index([birthDate])
  @@index([name])
  @@index([gender])
  @@index([isInHouse])
  @@index([isGraduated])
  @@index([registrationNumber])
  @@index([createdAt])
  @@index([updatedAt])
  @@index([breedId, name])
  @@index([isInHouse, isGraduated])
  @@index([birthDate, gender])
  @@map("cats")
}

model BreedingRecord {
  id              String         @id @default(uuid())
  maleId          String         @map("male_id")
  femaleId        String         @map("female_id")
  breedingDate    DateTime       @map("breeding_date")
  expectedDueDate DateTime?      @map("expected_due_date")
  actualDueDate   DateTime?      @map("actual_due_date")
  numberOfKittens Int?           @map("number_of_kittens")
  notes           String?
  status          BreedingStatus @default(PLANNED)
  recordedBy      String         @map("recorded_by")
  createdAt       DateTime       @default(now()) @map("created_at")
  updatedAt       DateTime       @updatedAt @map("updated_at")
  female          Cat            @relation("FemaleBreeding", fields: [femaleId], references: [id])
  male            Cat            @relation("MaleBreeding", fields: [maleId], references: [id])
  recorder        User           @relation(fields: [recordedBy], references: [id])

  @@index([maleId])
  @@index([femaleId])
  @@index([breedingDate])
  @@index([status])
  @@index([recordedBy])
  @@index([maleId, femaleId])
  @@index([maleId, breedingDate])
  @@index([femaleId, breedingDate])
  @@index([breedingDate, status])
  @@map("breeding_records")
}

model BreedingNgRule {
  id               String             @id @default(uuid())
  name             String
  description      String?
  type             BreedingNgRuleType @default(TAG_COMBINATION)
  maleConditions   String[]           @default([]) @map("male_conditions")
  femaleConditions String[]           @default([]) @map("female_conditions")
  maleNames        String[]           @default([]) @map("male_names")
  femaleNames      String[]           @default([]) @map("female_names")
  generationLimit  Int?               @map("generation_limit")
  active           Boolean            @default(true)
  createdAt        DateTime           @default(now()) @map("created_at")
  updatedAt        DateTime           @updatedAt @map("updated_at")

  @@map("breeding_ng_rules")
}

// äº¤é…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ« - äº¤é…æœŸé–“ã®ç®¡ç†
model BreedingSchedule {
  id         String                  @id @default(uuid())
  maleId     String                  @map("male_id")
  femaleId   String                  @map("female_id")
  startDate  DateTime                @map("start_date")
  duration   Int                     // æ—¥æ•°
  status     BreedingScheduleStatus  @default(SCHEDULED)
  notes      String?
  recordedBy String                  @map("recorded_by")
  createdAt  DateTime                @default(now()) @map("created_at")
  updatedAt  DateTime                @updatedAt @map("updated_at")

  male       Cat                     @relation("BreedingScheduleMale", fields: [maleId], references: [id])
  female     Cat                     @relation("BreedingScheduleFemale", fields: [femaleId], references: [id])
  recorder   User                    @relation(fields: [recordedBy], references: [id])
  checks     MatingCheck[]

  @@index([maleId])
  @@index([femaleId])
  @@index([startDate])
  @@index([status])
  @@index([maleId, startDate])
  @@index([femaleId, startDate])
  @@map("breeding_schedules")
}

// äº¤é…ãƒã‚§ãƒƒã‚¯ - äº¤é…ç¢ºèªå›æ•°ã®è¨˜éŒ²
model MatingCheck {
  id         String           @id @default(uuid())
  scheduleId String           @map("schedule_id")
  checkDate  DateTime         @map("check_date")
  count      Int              @default(1)
  createdAt  DateTime         @default(now()) @map("created_at")

  schedule   BreedingSchedule @relation(fields: [scheduleId], references: [id], onDelete: Cascade)

  @@index([scheduleId])
  @@index([checkDate])
  @@map("mating_checks")
}

enum BreedingScheduleStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

model PregnancyCheck {
  id         String          @id @default(uuid())
  checkDate  DateTime        @map("check_date")
  status     PregnancyStatus @default(SUSPECTED)
  notes      String?
  recordedBy String          @map("recorded_by")
  createdAt  DateTime        @default(now()) @map("created_at")
  updatedAt  DateTime        @updatedAt @map("updated_at")
  motherId   String          @map("mother_id")
  fatherId   String?         @map("father_id")
  matingDate DateTime?       @map("mating_date")
  mother     Cat             @relation("PregnancyCheckMother", fields: [motherId], references: [id])
  recorder   User            @relation(fields: [recordedBy], references: [id])

  @@index([motherId])
  @@index([fatherId])
  @@index([checkDate])
  @@index([status])
  @@index([recordedBy])
  @@index([motherId, checkDate])
  @@index([status, checkDate])
  @@map("pregnancy_checks")
}

model BirthPlan {
  id                 String              @id @default(uuid())
  status             BirthStatus         @default(EXPECTED)
  notes              String?
  recordedBy         String              @map("recorded_by")
  createdAt          DateTime            @default(now()) @map("created_at")
  updatedAt          DateTime            @updatedAt @map("updated_at")
  actualBirthDate    DateTime?           @map("actual_birth_date")
  actualKittens      Int?                @map("actual_kittens")
  expectedBirthDate  DateTime            @map("expected_birth_date")
  expectedKittens    Int?                @map("expected_kittens")
  motherId           String              @map("mother_id")
  fatherId           String?             @map("father_id")
  matingDate         DateTime?           @map("mating_date")
  completedAt        DateTime?           @map("completed_at")
  mother             Cat                 @relation("BirthPlanMother", fields: [motherId], references: [id])
  recorder           User                @relation(fields: [recordedBy], references: [id])
  kittenDispositions KittenDisposition[]

  @@index([motherId])
  @@index([fatherId])
  @@index([expectedBirthDate])
  @@index([status])
  @@index([recordedBy])
  @@index([actualBirthDate])
  @@index([motherId, expectedBirthDate])
  @@index([status, expectedBirthDate])
  @@index([expectedBirthDate, status])
  @@map("birth_plans")
}

model KittenDisposition {
  id                String          @id @default(uuid())
  birthRecordId     String          @map("birth_record_id")
  kittenId          String?         @map("kitten_id")
  name              String
  gender            String
  disposition       DispositionType
  trainingStartDate DateTime?       @map("training_start_date")
  saleInfo          Json?           @map("sale_info")
  deathDate         DateTime?       @map("death_date")
  deathReason       String?         @map("death_reason")
  notes             String?
  createdAt         DateTime        @default(now()) @map("created_at")
  updatedAt         DateTime        @updatedAt @map("updated_at")
  birthRecord       BirthPlan       @relation(fields: [birthRecordId], references: [id], onDelete: Cascade)
  kitten            Cat?            @relation(fields: [kittenId], references: [id])

  @@index([birthRecordId])
  @@index([kittenId])
  @@map("kitten_dispositions")
}

model CareRecord {
  id           String    @id @default(uuid())
  catId        String    @map("cat_id")
  careType     CareType  @map("care_type")
  description  String
  careDate     DateTime  @map("care_date")
  nextDueDate  DateTime? @map("next_due_date")
  cost         Float?
  veterinarian String?
  notes        String?
  recordedBy   String    @map("recorded_by")
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")
  cat          Cat       @relation(fields: [catId], references: [id])
  recorder     User      @relation(fields: [recordedBy], references: [id])

  @@index([catId])
  @@index([careDate])
  @@index([careType])
  @@index([recordedBy])
  @@index([nextDueDate])
  @@index([catId, careDate])
  @@index([catId, careType])
  @@index([careType, careDate])
  @@index([nextDueDate, careType])
  @@map("care_records")
}

// ä½“é‡è¨˜éŒ²ãƒ¢ãƒ‡ãƒ« - å­çŒ«ã®ä½“é‡æ¨ç§»ã‚’è¿½è·¡
model WeightRecord {
  id         String   @id @default(uuid())
  catId      String   @map("cat_id")
  weight     Float    // ã‚°ãƒ©ãƒ å˜ä½
  recordedAt DateTime @default(now()) @map("recorded_at")
  notes      String?
  recordedBy String   @map("recorded_by")
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")
  cat        Cat      @relation(fields: [catId], references: [id], onDelete: Cascade)
  recorder   User     @relation(fields: [recordedBy], references: [id])

  @@index([catId])
  @@index([recordedAt])
  @@index([catId, recordedAt])
  @@map("weight_records")
}

model Schedule {
  id             String             @id @default(uuid())
  title          String
  description    String?
  scheduleDate   DateTime           @map("schedule_date")
  scheduleType   ScheduleType       @map("schedule_type")
  status         ScheduleStatus     @default(PENDING)
  priority       Priority           @default(MEDIUM)
  catId          String?            @map("cat_id")
  assignedTo     String             @map("assigned_to")
  createdAt      DateTime           @default(now()) @map("created_at")
  updatedAt      DateTime           @updatedAt @map("updated_at")
  careType       CareType?          @map("care_type")
  endDate        DateTime?          @map("end_date")
  name           String             @map("name")
  recurrenceRule String?            @map("recurrence_rule")
  timezone       String?            @map("timezone")
  medicalRecords MedicalRecord[]
  scheduleCats   ScheduleCat[]
  reminders      ScheduleReminder[]
  tags           ScheduleTag[]
  assignee       User               @relation(fields: [assignedTo], references: [id])
  cat            Cat?               @relation(fields: [catId], references: [id])

  @@index([scheduleDate])
  @@index([endDate])
  @@index([status])
  @@index([catId])
  @@index([assignedTo])
  @@index([careType])
  @@index([scheduleType])
  @@index([priority])
  @@index([scheduleDate, status])
  @@index([catId, scheduleDate])
  @@index([assignedTo, scheduleDate])
  @@index([scheduleType, scheduleDate])
  @@index([status, priority])
  @@map("schedules")
}

model ScheduleReminder {
  id              String                   @id @default(uuid())
  scheduleId      String                   @map("schedule_id")
  timingType      ReminderTimingType       @map("timing_type")
  remindAt        DateTime?                @map("remind_at")
  offsetValue     Int?                     @map("offset_value")
  offsetUnit      ReminderOffsetUnit?      @map("offset_unit")
  relativeTo      ReminderRelativeTo?      @map("relative_to")
  channel         ReminderChannel          @map("channel")
  repeatFrequency ReminderRepeatFrequency? @map("repeat_frequency")
  repeatInterval  Int?                     @map("repeat_interval")
  repeatCount     Int?                     @map("repeat_count")
  repeatUntil     DateTime?                @map("repeat_until")
  notes           String?
  isActive        Boolean                  @default(true) @map("is_active")
  createdAt       DateTime                 @default(now()) @map("created_at")
  updatedAt       DateTime                 @updatedAt @map("updated_at")
  schedule        Schedule                 @relation(fields: [scheduleId], references: [id], onDelete: Cascade)

  @@index([scheduleId])
  @@map("schedule_reminders")
}

model CareTag {
  id           String        @id @default(uuid())
  slug         String        @unique
  label        String
  level        Int           @default(1)
  parentId     String?       @map("parent_id")
  description  String?
  isActive     Boolean       @default(true) @map("is_active")
  priority     Int?
  createdAt    DateTime      @default(now()) @map("created_at")
  updatedAt    DateTime      @updatedAt @map("updated_at")
  parent       CareTag?      @relation("CareTagHierarchy", fields: [parentId], references: [id])
  children     CareTag[]     @relation("CareTagHierarchy")
  scheduleTags ScheduleTag[]

  @@index([parentId])
  @@index([level])
  @@map("care_tags")
}

model ScheduleTag {
  scheduleId String   @map("schedule_id")
  careTagId  String   @map("care_tag_id")
  createdAt  DateTime @default(now()) @map("created_at")
  careTag    CareTag  @relation(fields: [careTagId], references: [id], onDelete: Cascade)
  schedule   Schedule @relation(fields: [scheduleId], references: [id], onDelete: Cascade)

  @@id([scheduleId, careTagId])
  @@map("schedule_tags")
}

model ScheduleCat {
  scheduleId String   @map("schedule_id")
  catId      String   @map("cat_id")
  createdAt  DateTime @default(now()) @map("created_at")
  cat        Cat      @relation(fields: [catId], references: [id], onDelete: Cascade)
  schedule   Schedule @relation(fields: [scheduleId], references: [id], onDelete: Cascade)

  @@id([scheduleId, catId])
  @@map("schedule_cats")
}

model MedicalVisitType {
  id           String          @id @default(uuid())
  key          String?         @unique
  name         String
  description  String?
  displayOrder Int             @default(0) @map("display_order")
  isActive     Boolean         @default(true) @map("is_active")
  createdAt    DateTime        @default(now()) @map("created_at")
  updatedAt    DateTime        @updatedAt @map("updated_at")
  records      MedicalRecord[]

  @@index([displayOrder])
  @@map("medical_visit_types")
}

model MedicalRecord {
  id             String                    @id @default(uuid())
  catId          String                    @map("cat_id")
  scheduleId     String?                   @map("schedule_id")
  recordedBy     String                    @map("recorded_by")
  visitDate      DateTime                  @map("visit_date")
  symptomDetails Json?                     @map("symptom_details")
  diagnosis      String?                   @map("diagnosis")
  treatmentPlan  String?                   @map("treatment_plan")
  medications    Json?                     @map("medications")
  followUpDate   DateTime?                 @map("follow_up_date")
  status         MedicalRecordStatus       @default(TREATING)
  notes          String?
  createdAt      DateTime                  @default(now()) @map("created_at")
  updatedAt      DateTime                  @updatedAt @map("updated_at")
  diseaseName    String?                   @map("disease_name")
  symptom        String?                   @map("symptom")
  hospitalName   String?                   @map("hospital_name")
  visitTypeId    String?                   @map("visit_type_id")
  attachments    MedicalRecordAttachment[]
  tags           MedicalRecordTag[]
  cat            Cat                       @relation(fields: [catId], references: [id])
  recorder       User                      @relation(fields: [recordedBy], references: [id])
  schedule       Schedule?                 @relation(fields: [scheduleId], references: [id])
  visitType      MedicalVisitType?         @relation(fields: [visitTypeId], references: [id])

  @@index([catId])
  @@index([visitDate])
  @@index([scheduleId])
  @@index([visitTypeId])
  @@index([status])
  @@index([recordedBy])
  @@index([catId, visitDate])
  @@index([visitTypeId, visitDate])
  @@index([status, visitDate])
  @@map("medical_records")
}

model MedicalRecordAttachment {
  id              String        @id @default(uuid())
  medicalRecordId String        @map("medical_record_id")
  url             String
  fileName        String?       @map("file_name")
  fileType        String?       @map("file_type")
  fileSize        Int?          @map("file_size")
  capturedAt      DateTime?     @map("captured_at")
  description     String?
  createdAt       DateTime      @default(now()) @map("created_at")
  updatedAt       DateTime      @updatedAt @map("updated_at")
  medicalRecord   MedicalRecord @relation(fields: [medicalRecordId], references: [id], onDelete: Cascade)

  @@index([medicalRecordId])
  @@map("medical_record_attachments")
}

model MedicalRecordTag {
  medicalRecordId String        @map("medical_record_id")
  createdAt       DateTime      @default(now()) @map("created_at")
  tagId           String        @map("tag_id")
  medicalRecord   MedicalRecord @relation(fields: [medicalRecordId], references: [id], onDelete: Cascade)
  tag             Tag           @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([medicalRecordId, tagId])
  @@map("medical_record_tags")
}

model TagCategory {
  id           String     @id @default(uuid())
  key          String     @unique
  name         String
  description  String?
  color        String?    @default("#3B82F6")
  displayOrder Int        @default(0) @map("display_order")
  scopes       String[]   @default([])
  isActive     Boolean    @default(true) @map("is_active")
  createdAt    DateTime   @default(now()) @map("created_at")
  updatedAt    DateTime   @updatedAt @map("updated_at")
  textColor    String?    @default("#111827") @map("text_color")
  groups       TagGroup[]

  @@map("tag_categories")
}

model TagGroup {
  id           String      @id @default(uuid())
  categoryId   String      @map("category_id")
  name         String
  description  String?
  displayOrder Int         @default(0) @map("display_order")
  isActive     Boolean     @default(true) @map("is_active")
  createdAt    DateTime    @default(now()) @map("created_at")
  updatedAt    DateTime    @updatedAt @map("updated_at")
  color        String?     @default("#3B82F6")
  textColor    String?     @default("#111827") @map("text_color")
  category     TagCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  tags         Tag[]

  @@unique([categoryId, name])
  @@map("tag_groups")
}

model Tag {
  id                String                 @id @default(uuid())
  name              String
  color             String                 @default("#3B82F6")
  description       String?
  createdAt         DateTime               @default(now()) @map("created_at")
  updatedAt         DateTime               @updatedAt @map("updated_at")
  displayOrder      Int                    @default(0) @map("display_order")
  allowsManual      Boolean                @default(true) @map("allows_manual")
  allowsAutomation  Boolean                @default(true) @map("allows_automation")
  metadata          Json?
  isActive          Boolean                @default(true) @map("is_active")
  groupId           String                 @map("group_id")
  textColor         String                 @default("#FFFFFF") @map("text_color")
  cats              CatTag[]
  medicalRecordTags MedicalRecordTag[]
  history           TagAssignmentHistory[]
  group             TagGroup               @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([groupId, name])
  @@index([groupId])
  @@map("tags")
}

model Pedigree {
  id               String     @id @default(uuid())
  pedigreeId       String     @unique @map("pedigree_id")
  title            String?    @map("title")
  catName          String?    @map("cat_name")
  catName2         String?    @map("cat_name2")
  breedCode        Int?       @map("breed_code")
  genderCode       Int?       @map("gender_code")
  eyeColor         String?    @map("eye_color")
  coatColorCode    Int?       @map("coat_color_code")
  birthDate        String?    @map("birth_date")
  breederName      String?    @map("breeder_name")
  ownerName        String?    @map("owner_name")
  registrationDate String?    @map("registration_date")
  brotherCount     Int?       @map("brother_count")
  sisterCount      Int?       @map("sister_count")
  notes            String?    @map("notes")
  notes2           String?    @map("notes2")
  otherNo          String?    @map("other_no")
  fatherTitle      String?    @map("father_title")
  fatherCatName    String?    @map("father_cat_name")
  fatherCatName2   String?    @map("father_cat_name2")
  fatherCoatColor  String?    @map("father_coat_color")
  fatherEyeColor   String?    @map("father_eye_color")
  fatherJCU        String?    @map("father_jcu")
  fatherOtherCode  String?    @map("father_other_code")
  motherTitle      String?    @map("mother_title")
  motherCatName    String?    @map("mother_cat_name")
  motherCatName2   String?    @map("mother_cat_name2")
  motherCoatColor  String?    @map("mother_coat_color")
  motherEyeColor   String?    @map("mother_eye_color")
  motherJCU        String?    @map("mother_jcu")
  motherOtherCode  String?    @map("mother_other_code")
  ffTitle          String?    @map("ff_title")
  ffCatName        String?    @map("ff_cat_name")
  ffCatColor       String?    @map("ff_cat_color")
  fmTitle          String?    @map("fm_title")
  fmCatName        String?    @map("fm_cat_name")
  fmCatColor       String?    @map("fm_cat_color")
  mfTitle          String?    @map("mf_title")
  mfCatName        String?    @map("mf_cat_name")
  mfCatColor       String?    @map("mf_cat_color")
  mmTitle          String?    @map("mm_title")
  mmCatName        String?    @map("mm_cat_name")
  mmCatColor       String?    @map("mm_cat_color")
  fffTitle         String?    @map("fff_title")
  fffCatName       String?    @map("fff_cat_name")
  fffCatColor      String?    @map("fff_cat_color")
  ffmTitle         String?    @map("ffm_title")
  ffmCatName       String?    @map("ffm_cat_name")
  ffmCatColor      String?    @map("ffm_cat_color")
  fmfTitle         String?    @map("fmf_title")
  fmfCatName       String?    @map("fmf_cat_name")
  fmfCatColor      String?    @map("fmf_cat_color")
  fmmTitle         String?    @map("fmm_title")
  fmmCatName       String?    @map("fmm_cat_name")
  fmmCatColor      String?    @map("fmm_cat_color")
  mffTitle         String?    @map("mff_title")
  mffCatName       String?    @map("mff_cat_name")
  mffCatColor      String?    @map("mff_cat_color")
  mfmTitle         String?    @map("mfm_title")
  mfmCatName       String?    @map("mfm_cat_name")
  mfmCatColor      String?    @map("mfm_cat_color")
  mmfTitle         String?    @map("mmf_title")
  mmfCatName       String?    @map("mmf_cat_name")
  mmfCatColor      String?    @map("mmf_cat_color")
  mmmTitle         String?    @map("mmm_title")
  mmmCatName       String?    @map("mmm_cat_name")
  mmmCatColor      String?    @map("mmm_cat_color")
  oldCode          String?    @map("old_code")
  createdAt        DateTime   @default(now()) @map("created_at")
  updatedAt        DateTime   @updatedAt @map("updated_at")
  fffjcu           String?    @map("fffjcu")
  ffjcu            String?    @map("ffjcu")
  ffmjcu           String?    @map("ffmjcu")
  fmfjcu           String?    @map("fmfjcu")
  fmjcu            String?    @map("fmjcu")
  fmmjcu           String?    @map("fmmjcu")
  mffjcu           String?    @map("mffjcu")
  mfjcu            String?    @map("mfjcu")
  mfmjcu           String?    @map("mfmjcu")
  mmfjcu           String?    @map("mmfjcu")
  mmjcu            String?    @map("mmjcu")
  mmmjcu           String?    @map("mmmjcu")
  cats             Cat[]      @relation("CatPedigree")
  breed            Breed?     @relation(fields: [breedCode], references: [code])
  coatColor        CoatColor? @relation(fields: [coatColorCode], references: [code])
  gender           Gender?    @relation(fields: [genderCode], references: [code])

  @@index([breedCode])
  @@index([genderCode])
  @@index([coatColorCode])
  @@index([catName])
  @@index([pedigreeId])
  @@index([catName2])
  @@index([eyeColor])
  @@index([breederName])
  @@index([ownerName])
  @@index([birthDate])
  @@index([registrationDate])
  @@index([createdAt])
  @@index([updatedAt])
  @@index([breedCode, catName])
  @@map("pedigrees")
}

model CatTag {
  catId     String   @map("cat_id")
  tagId     String   @map("tag_id")
  createdAt DateTime @default(now()) @map("created_at")
  cat       Cat      @relation(fields: [catId], references: [id], onDelete: Cascade)
  tag       Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([catId, tagId])
  @@map("cat_tags")
}

model TagAutomationRule {
  id          String                   @id @default(uuid())
  key         String                   @unique
  name        String
  description String?
  triggerType TagAutomationTriggerType @map("trigger_type")
  eventType   TagAutomationEventType   @map("event_type")
  scope       String?                  @map("scope")
  isActive    Boolean                  @default(true) @map("is_active")
  priority    Int                      @default(0)
  config      Json?                    @map("config")
  createdAt   DateTime                 @default(now()) @map("created_at")
  updatedAt   DateTime                 @updatedAt @map("updated_at")
  history     TagAssignmentHistory[]
  runs        TagAutomationRun[]

  @@map("tag_automation_rules")
}

model TagAutomationRun {
  id           String                 @id @default(uuid())
  ruleId       String                 @map("rule_id")
  eventPayload Json?                  @map("event_payload")
  status       TagAutomationRunStatus @default(PENDING) @map("status")
  startedAt    DateTime?              @map("started_at")
  completedAt  DateTime?              @map("completed_at")
  errorMessage String?                @map("error_message")
  createdAt    DateTime               @default(now()) @map("created_at")
  updatedAt    DateTime               @updatedAt @map("updated_at")
  history      TagAssignmentHistory[]
  rule         TagAutomationRule      @relation(fields: [ruleId], references: [id], onDelete: Cascade)

  @@index([ruleId])
  @@map("tag_automation_runs")
}

model TagAssignmentHistory {
  id              String              @id @default(uuid())
  catId           String              @map("cat_id")
  tagId           String              @map("tag_id")
  ruleId          String?             @map("rule_id")
  automationRunId String?             @map("automation_run_id")
  action          TagAssignmentAction @default(ASSIGNED)
  source          TagAssignmentSource @default(MANUAL)
  reason          String?
  metadata        Json?
  createdAt       DateTime            @default(now()) @map("created_at")
  automationRun   TagAutomationRun?   @relation(fields: [automationRunId], references: [id])
  cat             Cat                 @relation(fields: [catId], references: [id], onDelete: Cascade)
  rule            TagAutomationRule?  @relation(fields: [ruleId], references: [id])
  tag             Tag                 @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@index([catId])
  @@index([tagId])
  @@index([ruleId])
  @@index([automationRunId])
  @@map("tag_assignment_history")
}

model Staff {
  id               String              @id @default(uuid())
  userId           String?             @unique @map("user_id")
  name             String
  email            String?             @unique
  role             String              @default("ã‚¹ã‚¿ãƒƒãƒ•")
  color            String              @default("#4dabf7")
  isActive         Boolean             @default(true) @map("is_active")
  createdAt        DateTime            @default(now()) @map("created_at")
  updatedAt        DateTime            @updatedAt @map("updated_at")
  workTimeTemplate Json?               @map("work_time_template")
  workingDays      Json?               @map("working_days")
  shifts           Shift[]
  user             User?               @relation(fields: [userId], references: [id])
  availabilities   StaffAvailability[]

  @@index([userId])
  @@index([name])
  @@index([email])
  @@index([isActive])
  @@index([isActive, role])
  @@map("staff")
}

model ShiftTemplate {
  id           String   @id @default(uuid())
  name         String
  startTime    String   @map("start_time")
  endTime      String   @map("end_time")
  duration     Int
  color        String   @default("#4dabf7")
  breakTime    Int      @default(0) @map("break_time")
  isActive     Boolean  @default(true) @map("is_active")
  displayOrder Int      @default(0) @map("display_order")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")
  shifts       Shift[]

  @@index([name])
  @@index([displayOrder])
  @@map("shift_templates")
}

model Shift {
  id              String         @id @default(uuid())
  staffId         String         @map("staff_id")
  shiftDate       DateTime       @map("shift_date")
  displayName     String?        @map("display_name")
  templateId      String?        @map("template_id")
  startTime       DateTime?      @map("start_time")
  endTime         DateTime?      @map("end_time")
  breakDuration   Int?           @map("break_duration")
  status          ShiftStatus    @default(SCHEDULED)
  notes           String?
  actualStartTime DateTime?      @map("actual_start_time")
  actualEndTime   DateTime?      @map("actual_end_time")
  metadata        Json?
  mode            ShiftMode      @default(SIMPLE)
  createdAt       DateTime       @default(now()) @map("created_at")
  updatedAt       DateTime       @updatedAt @map("updated_at")
  tasks           ShiftTask[]
  staff           Staff          @relation(fields: [staffId], references: [id], onDelete: Cascade)
  template        ShiftTemplate? @relation(fields: [templateId], references: [id])

  @@index([staffId])
  @@index([templateId])
  @@index([shiftDate])
  @@index([status])
  @@index([mode])
  @@index([staffId, shiftDate])
  @@index([shiftDate, status])
  @@index([status, shiftDate])
  @@map("shifts")
}

model ShiftTask {
  id          String     @id @default(uuid())
  shiftId     String     @map("shift_id")
  taskType    String     @map("task_type")
  description String
  priority    Priority   @default(MEDIUM)
  status      TaskStatus @default(PENDING)
  startTime   DateTime?  @map("start_time")
  endTime     DateTime?  @map("end_time")
  notes       String?
  createdAt   DateTime   @default(now()) @map("created_at")
  updatedAt   DateTime   @updatedAt @map("updated_at")
  shift       Shift      @relation(fields: [shiftId], references: [id], onDelete: Cascade)

  @@index([shiftId])
  @@index([status])
  @@map("shift_tasks")
}

model StaffAvailability {
  id          String   @id @default(uuid())
  staffId     String   @map("staff_id")
  dayOfWeek   Int      @map("day_of_week")
  startTime   String   @map("start_time")
  endTime     String   @map("end_time")
  isAvailable Boolean  @default(true) @map("is_available")
  notes       String?
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  staff       Staff    @relation(fields: [staffId], references: [id], onDelete: Cascade)

  @@index([staffId])
  @@index([dayOfWeek])
  @@index([isAvailable])
  @@index([staffId, dayOfWeek])
  @@index([dayOfWeek, isAvailable])
  @@map("staff_availabilities")
}

model ShiftSettings {
  id                       String    @id @default(uuid())
  organizationId           String?   @map("organization_id")
  defaultMode              ShiftMode @default(SIMPLE) @map("default_mode")
  enabledModes             String[]  @default(["SIMPLE", "DETAILED"]) @map("enabled_modes")
  simpleRequireDisplayName Boolean   @default(false) @map("simple_require_display_name")
  detailedRequireTime      Boolean   @default(true) @map("detailed_require_time")
  detailedRequireTemplate  Boolean   @default(false) @map("detailed_require_template")
  detailedEnableTasks      Boolean   @default(true) @map("detailed_enable_tasks")
  detailedEnableActual     Boolean   @default(true) @map("detailed_enable_actual")
  customFields             Json?     @map("custom_fields")
  createdAt                DateTime  @default(now()) @map("created_at")
  updatedAt                DateTime  @updatedAt @map("updated_at")

  @@map("shift_settings")
}

model Graduation {
  id            String   @id @default(uuid())
  catId         String   @unique @map("cat_id")
  transferDate  DateTime @map("transfer_date")
  destination   String
  notes         String?
  catSnapshot   Json     @map("cat_snapshot")
  transferredBy String?  @map("transferred_by")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")
  cat           Cat      @relation(fields: [catId], references: [id], onDelete: Cascade)

  @@index([transferDate])
  @@index([catId])
  @@map("graduations")
}

model GalleryEntry {
  id            String          @id @default(uuid())
  category      GalleryCategory
  name          String
  gender        String
  coatColor     String?         @map("coat_color")
  breed         String?
  catId         String?         @map("cat_id")
  transferDate  DateTime?       @map("transfer_date")
  destination   String?
  externalLink  String?         @map("external_link")
  transferredBy String?         @map("transferred_by")
  catSnapshot   Json?           @map("cat_snapshot")
  notes         String?
  createdAt     DateTime        @default(now()) @map("created_at")
  updatedAt     DateTime        @updatedAt @map("updated_at")
  cat           Cat?            @relation("GalleryEntryCat", fields: [catId], references: [id])
  media         GalleryMedia[]

  @@index([category])
  @@index([catId])
  @@index([createdAt])
  @@index([category, createdAt])
  @@map("gallery_entries")
}

model GalleryMedia {
  id             String       @id @default(uuid())
  galleryEntryId String       @map("gallery_entry_id")
  type           MediaType
  url            String
  thumbnailUrl   String?      @map("thumbnail_url")
  order          Int          @default(0)
  createdAt      DateTime     @default(now()) @map("created_at")
  galleryEntry   GalleryEntry @relation(fields: [galleryEntryId], references: [id], onDelete: Cascade)

  @@index([galleryEntryId])
  @@index([order])
  @@map("gallery_media")
}

// ==========================================
// Pedigree Print Settings
// ==========================================

model PedigreePrintSetting {
  id        String   @id @default(uuid())
  tenantId  String?  @map("tenant_id")
  globalKey String?  @unique @map("global_key")
  settings  Json
  version   Int      @default(1)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  tenant    Tenant?  @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId])
  @@map("pedigree_print_settings")
}

// ==========================================
// Print Template Management
// ==========================================

model PrintTemplate {
  id                String                @id @default(uuid())
  tenantId          String?               @map("tenant_id") // null = å…±é€šãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
  name              String
  description       String?
  category          PrintTemplateCategory @default(PEDIGREE)
  paperWidth        Int                   @map("paper_width")    // mmå˜ä½
  paperHeight       Int                   @map("paper_height")   // mmå˜ä½
  backgroundUrl     String?               @map("background_url")
  backgroundOpacity Int                   @default(100) @map("background_opacity") // 0-100%
  positions         Json                  // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åº§æ¨™è¨­å®š
  fontSizes         Json?                 @map("font_sizes")     // ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºè¨­å®š
  isActive          Boolean               @default(true) @map("is_active")
  isDefault         Boolean               @default(false) @map("is_default")
  displayOrder      Int                   @default(0) @map("display_order")
  createdAt         DateTime              @default(now()) @map("created_at")
  updatedAt         DateTime              @updatedAt @map("updated_at")

  @@index([tenantId])
  @@index([category])
  @@index([isActive])
  @@index([name])
  @@index([tenantId, category, isActive])
  @@map("print_templates")
}

enum PrintTemplateCategory {
  PEDIGREE           // è¡€çµ±æ›¸
  KITTEN_TRANSFER    // å­çŒ«è­²æ¸¡è¨¼æ˜æ›¸
  HEALTH_CERTIFICATE // å¥åº·è¨ºæ–­æ›¸
  VACCINATION_RECORD // ãƒ¯ã‚¯ãƒãƒ³æ¥ç¨®è¨˜éŒ²
  BREEDING_RECORD    // ç¹æ®–è¨˜éŒ²
  CONTRACT           // å¥‘ç´„æ›¸
  INVOICE            // è«‹æ±‚æ›¸/é ˜åæ›¸
  CUSTOM             // ã‚«ã‚¹ã‚¿ãƒ æ›¸é¡
}

enum DisplayNameMode {
  CANONICAL
  CODE_AND_NAME
  CUSTOM
}

enum UserRole {
  USER
  ADMIN
  SUPER_ADMIN
  TENANT_ADMIN
}

enum BreedingStatus {
  PLANNED
  IN_PROGRESS
  COMPLETED
  FAILED
}

enum PregnancyStatus {
  CONFIRMED
  SUSPECTED
  NEGATIVE
  ABORTED
}

enum BirthStatus {
  EXPECTED
  BORN
  ABORTED
  STILLBORN
}

enum DispositionType {
  TRAINING
  SALE
  DECEASED
}

enum BreedingNgRuleType {
  TAG_COMBINATION
  INDIVIDUAL_PROHIBITION
  GENERATION_LIMIT
}

enum CareType {
  VACCINATION
  HEALTH_CHECK
  GROOMING
  DENTAL_CARE
  MEDICATION
  SURGERY
  OTHER
}

enum ScheduleType {
  BREEDING
  CARE
  APPOINTMENT
  REMINDER
  MAINTENANCE
}

enum ScheduleStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum ReminderTimingType {
  ABSOLUTE
  RELATIVE
}

enum ReminderOffsetUnit {
  MINUTE
  HOUR
  DAY
  WEEK
  MONTH
}

enum ReminderRelativeTo {
  START_DATE
  END_DATE
  CUSTOM_DATE
}

enum ReminderChannel {
  IN_APP
  EMAIL
  SMS
  PUSH
}

enum ReminderRepeatFrequency {
  NONE
  DAILY
  WEEKLY
  MONTHLY
  YEARLY
  CUSTOM
}

enum MedicalRecordStatus {
  TREATING
  COMPLETED
}

enum TagAssignmentAction {
  ASSIGNED
  UNASSIGNED
}

enum TagAssignmentSource {
  MANUAL
  AUTOMATION
  SYSTEM
}

enum TagAutomationTriggerType {
  EVENT
  SCHEDULE
  MANUAL
}

enum TagAutomationEventType {
  BREEDING_PLANNED
  BREEDING_CONFIRMED
  PREGNANCY_CONFIRMED
  KITTEN_REGISTERED
  AGE_THRESHOLD
  CUSTOM
  PAGE_ACTION
  TAG_ASSIGNED
}

enum TagAutomationRunStatus {
  PENDING
  COMPLETED
  FAILED
}

enum ShiftMode {
  SIMPLE
  DETAILED
  CUSTOM
}

enum ShiftStatus {
  SCHEDULED
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  ABSENT
}

enum TaskStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  SKIPPED
}

enum GalleryCategory {
  KITTEN
  FATHER
  MOTHER
  GRADUATION
}

enum MediaType {
  IMAGE
  YOUTUBE
}
`````

## File: backend/prisma/seed-admin.sql
`````sql
-- ç®¡ç†è€…ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ä½œæˆï¼ˆPassw0rd!ï¼‰
INSERT INTO "users" (
  "id",
  "clerk_id",
  "email",
  "password_hash",
  "role",
  "first_name",
  "last_name",
  "created_at",
  "updated_at"
)
VALUES (
  '00000000-0000-0000-0000-000000000001',
  'local_admin_001',
  'admin@example.com',
  '$argon2id$v=19$m=65536,t=3,p=4$g7EcC8gFxc8iRStAz0GnQA$9B/pdSQ1lVCIVlww5X001ajQGOY4jFMxngLjMX4hbLw',
  'ADMIN',
  'Admin',
  'User',
  CURRENT_TIMESTAMP,
  CURRENT_TIMESTAMP
)
ON CONFLICT (email) DO UPDATE
SET
  password_hash = EXCLUDED.password_hash,
  role = EXCLUDED.role,
  updated_at = CURRENT_TIMESTAMP;
`````

## File: backend/prisma/seed-cats-simple.sql
`````sql
-- ã‚·ãƒ³ãƒ—ãƒ«ãªçŒ«ãƒ‡ãƒ¼ã‚¿ã®ã‚·ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿
-- Aï½Gã®é ­æ–‡å­—ã‚’æŒã¤MaleçŒ«7é ­ã¨FemaleçŒ«7é ­
-- ç”Ÿå¹´æœˆæ—¥: 2023-02-02 ï½ 2024-02-02ã®æœŸé–“ã§ãƒ©ãƒ³ãƒ€ãƒ ã«è¨­å®š
-- UUIDv4å½¢å¼ã«æº–æ‹ 

-- MaleçŒ« (7é ­)
INSERT INTO "cats" ("id", "name", "gender", "birth_date", "breed_id", "coat_color_id", "microchip_number", "registration_number", "notes", "is_in_house", "father_id", "mother_id", "created_at", "updated_at") VALUES 
('a1111111-1111-4111-8111-111111111111', 'Alpha', 'MALE', '2023-03-15T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, NULL, NULL, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
('b1111111-1111-4111-8111-111111111111', 'Bruno', 'MALE', '2023-04-22T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, NULL, NULL, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
('c1111111-1111-4111-8111-111111111111', 'Charlie', 'MALE', '2023-05-08T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, NULL, NULL, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
('d1111111-1111-4111-8111-111111111111', 'David', 'MALE', '2023-06-14T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, NULL, NULL, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
('e1111111-1111-4111-8111-111111111111', 'Ethan', 'MALE', '2023-09-03T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, NULL, NULL, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
('f1111111-1111-4111-8111-111111111111', 'Felix', 'MALE', '2023-11-28T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, NULL, NULL, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
('a1111111-1111-4111-9111-111111111111', 'Gabriel', 'MALE', '2024-01-05T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, NULL, NULL, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
ON CONFLICT (id) DO NOTHING;

-- FemaleçŒ« (7é ­)
INSERT INTO "cats" ("id", "name", "gender", "birth_date", "breed_id", "coat_color_id", "microchip_number", "registration_number", "notes", "is_in_house", "father_id", "mother_id", "created_at", "updated_at") VALUES 
('a2222222-2222-4222-8222-222222222222', 'Anna', 'FEMALE', '2023-02-18T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, NULL, NULL, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
('b2222222-2222-4222-8222-222222222222', 'Bella', 'FEMALE', '2023-03-27T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, NULL, NULL, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
('c2222222-2222-4222-8222-222222222222', 'Clara', 'FEMALE', '2023-05-11T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, NULL, NULL, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
('d2222222-2222-4222-8222-222222222222', 'Diana', 'FEMALE', '2023-07-19T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, NULL, NULL, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
('e2222222-2222-4222-8222-222222222222', 'Emma', 'FEMALE', '2023-08-25T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, NULL, NULL, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
('f2222222-2222-4222-8222-222222222222', 'Fiona', 'FEMALE', '2023-10-12T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, NULL, NULL, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
('a2222222-2222-4222-9222-222222222222', 'Grace', 'FEMALE', '2024-01-30T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, NULL, NULL, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
ON CONFLICT (id) DO NOTHING;
`````

## File: backend/prisma/seed-gallery-migration.ts
`````typescript
/**
 * Graduation â†’ GalleryEntry ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
 *
 * æ—¢å­˜ã® Graduation ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’ GalleryEntry ã«ç§»è¡Œã—ã¾ã™ã€‚
 *
 * å®Ÿè¡Œæ–¹æ³•:
 *   cd backend
 *   pnpm ts-node prisma/seed-gallery-migration.ts
 */
import { PrismaClient, GalleryCategory } from '@prisma/client';

const prisma = new PrismaClient();

interface CatSnapshot {
  name?: string;
  gender?: string;
  coatColor?: { name?: string };
  breed?: { name?: string };
}

async function migrateGraduationsToGallery(): Promise<void> {
  console.log('Graduation â†’ GalleryEntry ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹...');

  const graduations = await prisma.graduation.findMany({
    include: {
      cat: true,
    },
  });

  console.log(`${graduations.length}ä»¶ã®Graduationã‚’ç§»è¡Œã—ã¾ã™`);

  let migrated = 0;
  let skipped = 0;

  for (const grad of graduations) {
    // æ—¢å­˜ãƒã‚§ãƒƒã‚¯ï¼ˆåŒã˜ catId ã¨ category ã®çµ„ã¿åˆã‚ã›ï¼‰
    const existing = await prisma.galleryEntry.findFirst({
      where: {
        catId: grad.catId,
        category: GalleryCategory.GRADUATION,
      },
    });

    if (existing) {
      console.log(`ã‚¹ã‚­ãƒƒãƒ—: ${grad.id} (æ—¢ã«å­˜åœ¨)`);
      skipped++;
      continue;
    }

    const snapshot = grad.catSnapshot as CatSnapshot | null;

    await prisma.galleryEntry.create({
      data: {
        category: GalleryCategory.GRADUATION,
        name: snapshot?.name ?? grad.cat?.name ?? 'Unknown',
        gender: snapshot?.gender ?? grad.cat?.gender ?? 'MALE',
        coatColor: snapshot?.coatColor?.name ?? null,
        breed: snapshot?.breed?.name ?? null,
        catId: grad.catId,
        transferDate: grad.transferDate,
        destination: grad.destination,
        transferredBy: grad.transferredBy,
        catSnapshot: grad.catSnapshot,
        notes: grad.notes,
        createdAt: grad.createdAt,
        updatedAt: grad.updatedAt,
      },
    });

    console.log(`ç§»è¡Œå®Œäº†: ${grad.id} â†’ ${snapshot?.name ?? grad.cat?.name ?? 'Unknown'}`);
    migrated++;
  }

  console.log('');
  console.log('=== ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº† ===');
  console.log(`ç§»è¡Œ: ${migrated}ä»¶`);
  console.log(`ã‚¹ã‚­ãƒƒãƒ—: ${skipped}ä»¶`);
}

migrateGraduationsToGallery()
  .catch((error: unknown) => {
    console.error('ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼:', error);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
`````

## File: backend/prisma/seed.ts
`````typescript
import { PrismaClient, UserRole } from '@prisma/client';
import * as argon2 from 'argon2';

import { BREED_MASTER_DATA } from '../src/breeds/breed-master.data';
import { COAT_COLOR_MASTER_DATA } from '../src/coat-colors/coat-color-master.data';
import { GENDER_MASTER } from '../src/cats/constants/gender';

const prisma = new PrismaClient();

async function syncBreedMasterData() {
  console.log('â¡ï¸ Syncing breed master data...');
  for (const record of BREED_MASTER_DATA) {
    await prisma.breed.upsert({
      where: { code: record.code },
      update: {
        name: record.name ?? '',
        description: null,
        isActive: true,
      },
      create: {
        code: record.code,
        name: record.name ?? '',
        description: null,
        isActive: true,
      },
    });
  }
  console.log(`âœ… Synced ${BREED_MASTER_DATA.length} breed records`);
}

async function syncCoatColorMasterData() {
  console.log('â¡ï¸ Syncing coat color master data...');
  for (const record of COAT_COLOR_MASTER_DATA) {
    await prisma.coatColor.upsert({
      where: { code: record.code },
      update: {
        name: record.name ?? '',
        description: null,
        isActive: true,
      },
      create: {
        code: record.code,
        name: record.name ?? '',
        description: null,
        isActive: true,
      },
    });
  }
  console.log(`âœ… Synced ${COAT_COLOR_MASTER_DATA.length} coat color records`);
}

async function syncGenderMasterData() {
  console.log('â¡ï¸ Syncing gender master data...');
  for (const record of GENDER_MASTER) {
    const code = Number.parseInt(record.key, 10);
    if (Number.isNaN(code)) {
      continue;
    }

    await prisma.gender.upsert({
      where: { code },
      update: {
        name: record.name,
        description: record.canonical,
        isActive: true,
      },
      create: {
        code,
        name: record.name,
        description: record.canonical,
        isActive: true,
      },
    });
  }
  console.log(`âœ… Synced ${GENDER_MASTER.length} gender records`);
}

async function syncMasterData() {
  await syncBreedMasterData();
  await syncCoatColorMasterData();
  await syncGenderMasterData();
}

async function main() {
  console.log('ğŸŒ± Seeding database...');

  // Admin user
  // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰: Passw0rd! (æœ«å°¾ã« ! ã‚ã‚Š)
  const passwordHash = await argon2.hash('Passw0rd!');
  
  const admin = await prisma.user.upsert({
    where: { email: 'admin@example.com' },
    update: {
      passwordHash,
      role: UserRole.ADMIN,
    },
    create: {
      id: '00000000-0000-0000-4000-800000000001', // UUIDv4å½¢å¼
      clerkId: 'local_admin_001',
      email: 'admin@example.com',
      passwordHash,
      role: UserRole.ADMIN,
      firstName: 'Admin',
      lastName: 'User',
    },
  });

  console.log('âœ… Admin user created:', admin.email);

  // SuperAdmin userï¼ˆé–‹ç™ºç”¨æ¤œè¨¼ãƒ¦ãƒ¼ã‚¶ãƒ¼ï¼‰
  // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰: Passw0rd! (æœ«å°¾ã« ! ã‚ã‚Š)
  // ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†æ©Ÿèƒ½ã®æ¤œè¨¼ã«ä½¿ç”¨ã™ã‚‹ SUPER_ADMIN ãƒ­ãƒ¼ãƒ«ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼
  const superAdmin = await prisma.user.upsert({
    where: { email: 'superadmin@example.com' },
    update: {
      passwordHash,
      role: UserRole.SUPER_ADMIN,
    },
    create: {
      id: '00000000-0000-0000-4000-800000000002', // UUIDv4å½¢å¼
      clerkId: 'local_superadmin_001',
      email: 'superadmin@example.com',
      passwordHash,
      role: UserRole.SUPER_ADMIN,
      firstName: 'Super',
      lastName: 'Admin',
    },
  });

  console.log('âœ… SuperAdmin user created:', superAdmin.email);

  await syncMasterData();

  // Cats
  const cats = [
    // Males
    { id: 'a1111111-1111-4111-8111-111111111111', name: 'Alpha', gender: 'MALE', birthDate: new Date('2023-03-15') },
    { id: 'b1111111-1111-4111-8111-111111111111', name: 'Bruno', gender: 'MALE', birthDate: new Date('2023-04-22') },
    { id: 'c1111111-1111-4111-8111-111111111111', name: 'Charlie', gender: 'MALE', birthDate: new Date('2023-05-08') },
    { id: 'd1111111-1111-4111-8111-111111111111', name: 'David', gender: 'MALE', birthDate: new Date('2023-06-14') },
    { id: 'e1111111-1111-4111-8111-111111111111', name: 'Ethan', gender: 'MALE', birthDate: new Date('2023-09-03') },
    { id: 'f1111111-1111-4111-8111-111111111111', name: 'Felix', gender: 'MALE', birthDate: new Date('2023-11-28') },
    { id: 'a1111111-1111-4111-9111-111111111111', name: 'Gabriel', gender: 'MALE', birthDate: new Date('2024-01-05') },
    // Females
    { id: 'a2222222-2222-4222-8222-222222222222', name: 'Anna', gender: 'FEMALE', birthDate: new Date('2023-02-18') },
    { id: 'b2222222-2222-4222-8222-222222222222', name: 'Bella', gender: 'FEMALE', birthDate: new Date('2023-03-27') },
    { id: 'c2222222-2222-4222-8222-222222222222', name: 'Clara', gender: 'FEMALE', birthDate: new Date('2023-05-11') },
    { id: 'd2222222-2222-4222-8222-222222222222', name: 'Diana', gender: 'FEMALE', birthDate: new Date('2023-07-19') },
    { id: 'e2222222-2222-4222-8222-222222222222', name: 'Emma', gender: 'FEMALE', birthDate: new Date('2023-08-25') },
    { id: 'f2222222-2222-4222-8222-222222222222', name: 'Fiona', gender: 'FEMALE', birthDate: new Date('2023-10-12') },
    { id: 'a2222222-2222-4222-9222-222222222222', name: 'Grace', gender: 'FEMALE', birthDate: new Date('2024-01-30') },
  ];

  for (const cat of cats) {
    await prisma.cat.upsert({
      where: { id: cat.id },
      update: {},
      create: {
        ...cat,
        isInHouse: true,
      },
    });
  }

  console.log(`âœ… ${cats.length} cats created`);

  // --- Tag category / group / tags for testing ---
  // Create TagCategory 'Breeding' (key: 'breeding')
  const tagCategory = await prisma.tagCategory.upsert({
    where: { key: 'breeding' },
    update: { name: 'Breeding' },
    create: {
      key: 'breeding',
      name: 'Breeding',
      description: 'Breeding related tags',
      scopes: ['cats'],
    },
  });

  // Create TagGroup 'Body-Type' under the category
  let tagGroup = await prisma.tagGroup.findFirst({
    where: { categoryId: tagCategory.id, name: 'Body-Type' },
  });
  if (!tagGroup) {
    tagGroup = await prisma.tagGroup.create({
      data: {
        categoryId: tagCategory.id,
        name: 'Body-Type',
        description: 'Body type related tags (çŸ­è¶³/é•·è¶³)',
      },
    });
  }

  // Create Tags 'çŸ­è¶³' and 'é•·è¶³'
  let tagShort = await prisma.tag.findFirst({ where: { groupId: tagGroup.id, name: 'çŸ­è¶³' } });
  if (!tagShort) {
    tagShort = await prisma.tag.create({
      data: {
        groupId: tagGroup.id,
        name: 'çŸ­è¶³',
        color: '#F97316',
        textColor: '#FFFFFF',
      },
    });
  }

  let tagLong = await prisma.tag.findFirst({ where: { groupId: tagGroup.id, name: 'é•·è¶³' } });
  if (!tagLong) {
    tagLong = await prisma.tag.create({
      data: {
        groupId: tagGroup.id,
        name: 'é•·è¶³',
        color: '#06B6D4',
        textColor: '#FFFFFF',
      },
    });
  }

  console.log('âœ… Tag category/group/tags created:', tagCategory.key, tagGroup.name, tagShort.name, tagLong.name);

  // --- Assign tags to sample cats ---
  // Use Alpha (male) and Anna (female) created above
  const maleCatId = 'a1111111-1111-4111-8111-111111111111'; // Alpha
  const femaleCatId = 'a2222222-2222-4222-8222-222222222222'; // Anna

  await prisma.catTag.upsert({
    where: { catId_tagId: { catId: maleCatId, tagId: tagShort.id } },
    update: {},
    create: { catId: maleCatId, tagId: tagShort.id },
  });

  await prisma.catTag.upsert({
    where: { catId_tagId: { catId: femaleCatId, tagId: tagLong.id } },
    update: {},
    create: { catId: femaleCatId, tagId: tagLong.id },
  });

  console.log('âœ… Assigned tags to sample cats');

  // --- Create a Breeding NG rule (ã‚¿ã‚°çµ„åˆã›ç¦æ­¢) ---
  const existingRule = await prisma.breedingNgRule.findFirst({ where: { name: 'çŸ­è¶³Ã—é•·è¶³ç¦æ­¢' } });
  if (!existingRule) {
    await prisma.breedingNgRule.create({
      data: {
        name: 'çŸ­è¶³Ã—é•·è¶³ç¦æ­¢',
        description: 'çŸ­è¶³ï¼ˆã‚ªã‚¹ï¼‰ã¨é•·è¶³ï¼ˆãƒ¡ã‚¹ï¼‰ã®çµ„åˆã›ã‚’ç¦æ­¢ã—ã¾ã™ï¼ˆãƒ†ã‚¹ãƒˆï¼‰',
        type: 'TAG_COMBINATION',
        maleConditions: [tagShort.name],
        femaleConditions: [tagLong.name],
        active: true,
      },
    });
    console.log('âœ… Created Breeding NG rule: çŸ­è¶³Ã—é•·è¶³ç¦æ­¢');
  } else {
    console.log('â„¹ï¸ Breeding NG rule already exists:', existingRule.name);
  }
}

main()
  .catch((e) => {
    console.error('âŒ Seed failed:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
`````

## File: backend/scripts/ensure-dev-build.mjs
`````javascript
#!/usr/bin/env node
import { existsSync, rmSync } from 'fs';
import { spawnSync } from 'child_process';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const backendRoot = path.resolve(__dirname, '..');
const distDir = path.join(backendRoot, 'dist');
const requiredArtifacts = [
  path.join(distDir, 'auth', 'auth.module.js'),
  path.join(distDir, 'users', 'users.module.js'),
];

const missingArtifacts = requiredArtifacts.filter((artifact) => !existsSync(artifact));

if (missingArtifacts.length === 0) {
  process.exit(0);
}

console.log('[prestart:dev] Detected missing build artifacts:');
missingArtifacts.forEach((artifact) => {
  console.log(`  - ${path.relative(backendRoot, artifact)}`);
});

console.log('[prestart:dev] Removing stale build outputs...');
rmSync(distDir, { recursive: true, force: true });

const tsBuildInfo = path.resolve(backendRoot, '..', '.tmp', 'backend.tsbuildinfo');
rmSync(tsBuildInfo, { force: true });

console.log('[prestart:dev] Running fresh "pnpm run build" to regenerate dist...');
const buildResult = spawnSync('pnpm', ['run', 'build'], {
  cwd: backendRoot,
  stdio: 'inherit',
  shell: process.platform === 'win32',
});

if (buildResult.status !== 0) {
  console.error('[prestart:dev] Build failed. Aborting start.');
  process.exit(buildResult.status ?? 1);
}

console.log('[prestart:dev] Build artifacts regenerated. Continuing to start:dev...');
`````

## File: backend/scripts/export-cats-seed.ts
`````typescript
// åœ¨èˆçŒ«ãƒ‡ãƒ¼ã‚¿ã‚’ã‚·ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
import { PrismaClient } from '@prisma/client';
import * as fs from 'fs';
import * as path from 'path';

const prisma = new PrismaClient();

async function exportCatsData() {
  console.log('ğŸ”„ åœ¨èˆçŒ«ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆä¸­...');

  const outputFile = path.join(__dirname, '..', 'prisma', 'seed-cats-data.sql');
  const sqlStatements: string[] = [];

  // ãƒ˜ãƒƒãƒ€ãƒ¼
  sqlStatements.push(`-- åœ¨èˆçŒ«ãƒ‡ãƒ¼ã‚¿ã®ã‚·ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ (è‡ªå‹•ç”Ÿæˆ: ${new Date().toISOString()})`);
  sqlStatements.push(`-- ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ç¾åœ¨ã®åœ¨èˆçŒ«ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ç”Ÿæˆã•ã‚Œã¾ã—ãŸ`);
  sqlStatements.push('');

  // åœ¨èˆçŒ«ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
  const cats = await prisma.cat.findMany({
    where: { isInHouse: true },
    include: {
      breed: true,
      coatColor: true,
    },
    orderBy: { name: 'asc' },
  });

  console.log(`ğŸ“¦ ${cats.length}é ­ã®åœ¨èˆçŒ«ã‚’ç™ºè¦‹`);

  // å“ç¨®ãƒ‡ãƒ¼ã‚¿ã‚’åé›†
  const breeds = new Map();
  const coatColors = new Map();

  cats.forEach(cat => {
    if (cat.breed) breeds.set(cat.breed.id, cat.breed);
    if (cat.coatColor) coatColors.set(cat.coatColor.id, cat.coatColor);
  });

  // å“ç¨®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
  if (breeds.size > 0) {
    console.log(`ğŸ¨ ${breeds.size}å“ç¨®ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ`);
    sqlStatements.push('-- å“ç¨®ãƒ‡ãƒ¼ã‚¿');
    breeds.forEach(breed => {
      sqlStatements.push(
        `INSERT INTO "breeds" ("id", "name", "description", "createdAt", "updatedAt") VALUES (` +
        `'${breed.id}', '${escapeSql(breed.name)}', ` +
        `${breed.description ? `'${escapeSql(breed.description)}'` : 'NULL'}, ` +
        `'${breed.createdAt.toISOString()}', '${breed.updatedAt.toISOString()}') ` +
        `ON CONFLICT (id) DO NOTHING;`
      );
    });
    sqlStatements.push('');
  }

  // æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
  if (coatColors.size > 0) {
    console.log(`ğŸŒˆ ${coatColors.size}æ¯›è‰²ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ`);
    sqlStatements.push('-- æ¯›è‰²ãƒ‡ãƒ¼ã‚¿');
    coatColors.forEach(color => {
      sqlStatements.push(
        `INSERT INTO "coat_colors" ("id", "name", "description", "createdAt", "updatedAt") VALUES (` +
        `'${color.id}', '${escapeSql(color.name)}', ` +
        `${color.description ? `'${escapeSql(color.description)}'` : 'NULL'}, ` +
        `'${color.createdAt.toISOString()}', '${color.updatedAt.toISOString()}') ` +
        `ON CONFLICT (id) DO NOTHING;`
      );
    });
    sqlStatements.push('');
  }

  // åœ¨èˆçŒ«ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
  console.log(`ğŸ± ${cats.length}é ­ã®åœ¨èˆçŒ«ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ`);
  sqlStatements.push('-- åœ¨èˆçŒ«ãƒ‡ãƒ¼ã‚¿');
  cats.forEach(cat => {
    sqlStatements.push(
      `INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", ` +
      `"microchipNumber", "registrationNumber", "description", "isInHouse", ` +
      `"fatherId", "motherId", "createdAt", "updatedAt") VALUES (` +
      `'${cat.id}', '${escapeSql(cat.name)}', '${cat.gender}', '${cat.birthDate.toISOString()}', ` +
      `${cat.breedId ? `'${cat.breedId}'` : 'NULL'}, ` +
      `${cat.coatColorId ? `'${cat.coatColorId}'` : 'NULL'}, ` +
      `${cat.microchipNumber ? `'${escapeSql(cat.microchipNumber)}'` : 'NULL'}, ` +
      `${cat.registrationNumber ? `'${escapeSql(cat.registrationNumber)}'` : 'NULL'}, ` +
      `${cat.description ? `'${escapeSql(cat.description)}'` : 'NULL'}, ` +
      `${cat.isInHouse}, ` +
      `${cat.fatherId ? `'${cat.fatherId}'` : 'NULL'}, ` +
      `${cat.motherId ? `'${cat.motherId}'` : 'NULL'}, ` +
      `'${cat.createdAt.toISOString()}', '${cat.updatedAt.toISOString()}') ` +
      `ON CONFLICT (id) DO NOTHING;`
    );
  });

  // ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¿
  fs.writeFileSync(outputFile, sqlStatements.join('\n'), 'utf8');

  console.log('');
  console.log(`âœ… ã‚·ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãŒå®Œäº†ã—ã¾ã—ãŸ: ${outputFile}`);
  console.log('');
  console.log('ğŸ“ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—:');
  console.log('   1. backend/prisma/seed-cats-data.sql ã‚’ç¢ºèª');
  console.log('   2. database/init/02-seed-cats.sql ã«ã‚³ãƒ”ãƒ¼:');
  console.log('      Copy-Item backend\\prisma\\seed-cats-data.sql database\\init\\02-seed-cats.sql');
  console.log('   3. Gitã«ã‚³ãƒŸãƒƒãƒˆ&ãƒ—ãƒƒã‚·ãƒ¥');
}

function escapeSql(str: string): string {
  return str.replace(/'/g, "''");
}

exportCatsData()
  .catch(console.error)
  .finally(() => prisma.$disconnect());
`````

## File: backend/scripts/generate-secrets.mjs
`````javascript
#!/usr/bin/env node

import { spawnSync } from 'child_process';
import { dirname, resolve } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const repoRoot = resolve(__dirname, '..', '..');

const execution = spawnSync('pnpm', ['run', 'generate-secrets'], {
  cwd: repoRoot,
  stdio: 'inherit',
  shell: process.platform === 'win32',
});

if (execution.error) {
  console.error('âŒ ãƒ«ãƒ¼ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒˆã®å®Ÿè¡Œã«å¤±æ•—ã—ã¾ã—ãŸ:', execution.error);
  process.exit(1);
}

process.exit(execution.status ?? 0);
`````

## File: backend/src/auth/dto/change-password.dto.ts
`````typescript
import { ApiProperty } from "@nestjs/swagger";
import { IsString, MinLength, IsStrongPassword } from "class-validator";

export class ChangePasswordDto {
  @ApiProperty({
    description: "ç¾åœ¨ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰",
    example: "oldPassword123!",
  })
  @IsString()
  currentPassword: string;

  @ApiProperty({
    description:
      "æ–°ã—ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼ˆ8æ–‡å­—ä»¥ä¸Šã€å¤§æ–‡å­—ãƒ»å°æ–‡å­—ãƒ»æ•°å­—ãƒ»ç‰¹æ®Šæ–‡å­—ã‚’å«ã‚€ï¼‰",
    example: "NewSecurePassword123!",
    minLength: 8,
  })
  @IsString()
  @MinLength(8, { message: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯8æ–‡å­—ä»¥ä¸Šã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™" })
  @IsStrongPassword(
    {
      minLength: 8,
      minLowercase: 1,
      minUppercase: 1,
      minNumbers: 1,
      minSymbols: 1,
    },
    {
      message:
        "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã«ã¯å¤§æ–‡å­—ã€å°æ–‡å­—ã€æ•°å­—ã€ç‰¹æ®Šæ–‡å­—ã‚’å«ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™",
    },
  )
  newPassword: string;
}
`````

## File: backend/src/auth/dto/login.dto.ts
`````typescript
import { ApiProperty } from "@nestjs/swagger";
import { Transform } from "class-transformer";
import { IsEmail, IsString, MinLength } from "class-validator";

export class LoginDto {
  @ApiProperty({
    description: "ãƒ­ã‚°ã‚¤ãƒ³ã«ä½¿ç”¨ã™ã‚‹ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹",
    example: "user@example.com",
  })
  @IsEmail({}, { message: "æœ‰åŠ¹ãªãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„" })
  @Transform(({ value }: { value: unknown }) => (typeof value === "string" ? value.trim().toLowerCase() : value))
  email: string;

  @ApiProperty({
    description: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ (8æ–‡å­—ä»¥ä¸Šæ¨å¥¨)",
    example: "SecurePassword123!",
    minLength: 6,
  })
  @IsString()
  @MinLength(6, { message: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯6æ–‡å­—ä»¥ä¸Šã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™" })
  password: string;
}
`````

## File: backend/src/auth/dto/password-reset.dto.ts
`````typescript
import { ApiProperty } from "@nestjs/swagger";
import { Transform } from "class-transformer";
import { IsEmail } from "class-validator";

export class PasswordResetDto {
  @ApiProperty({
    description: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆã‚’è¡Œã†ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹",
    example: "user@example.com",
  })
  @IsEmail({}, { message: "æœ‰åŠ¹ãªãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„" })
  @Transform(({ value }: { value: unknown }) => (typeof value === "string" ? value.trim().toLowerCase() : value))
  email: string;
}
`````

## File: backend/src/auth/dto/refresh-token.dto.ts
`````typescript
import { ApiPropertyOptional } from '@nestjs/swagger';
import { IsOptional, IsString } from 'class-validator';

export class RefreshTokenDto {
  @ApiPropertyOptional({
    description: 'ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ (Cookieåˆ©ç”¨æ™‚ã¯çœç•¥å¯)',
    example: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...'
  })
  @IsOptional()
  @IsString({ message: 'ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã¯æ–‡å­—åˆ—ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™' })
  refreshToken?: string;
}
`````

## File: backend/src/auth/dto/request-password-reset.dto.ts
`````typescript
import { ApiProperty } from '@nestjs/swagger';
import { IsEmail, IsNotEmpty } from 'class-validator';

export class RequestPasswordResetDto {
  @ApiProperty({
    description: 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹',
    example: 'user@example.com',
  })
  @IsEmail({}, { message: 'æœ‰åŠ¹ãªãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„' })
  @IsNotEmpty({ message: 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯å¿…é ˆã§ã™' })
  email: string;
}
`````

## File: backend/src/auth/dto/reset-password.dto.ts
`````typescript
import { ApiProperty } from '@nestjs/swagger';
import { IsNotEmpty, IsString, MinLength } from 'class-validator';

export class ResetPasswordDto {
  @ApiProperty({
    description: 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆãƒˆãƒ¼ã‚¯ãƒ³',
    example: 'a1b2c3d4e5f6...',
  })
  @IsString({ message: 'ãƒˆãƒ¼ã‚¯ãƒ³ã¯æ–‡å­—åˆ—ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™' })
  @IsNotEmpty({ message: 'ãƒˆãƒ¼ã‚¯ãƒ³ã¯å¿…é ˆã§ã™' })
  token: string;

  @ApiProperty({
    description: 'æ–°ã—ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰',
    example: 'NewSecurePassword123!',
  })
  @IsString({ message: 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯æ–‡å­—åˆ—ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™' })
  @MinLength(8, { message: 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯8æ–‡å­—ä»¥ä¸Šã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™' })
  @IsNotEmpty({ message: 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯å¿…é ˆã§ã™' })
  newPassword: string;
}
`````

## File: backend/src/auth/auth.constants.spec.ts
`````typescript
import { isSecureEnv, getRefreshCookieSameSite } from './auth.constants';

describe('Auth Constants', () => {
  const originalEnv = process.env.NODE_ENV;

  afterEach(() => {
    // Restore original NODE_ENV after each test
    process.env.NODE_ENV = originalEnv;
  });

  describe('isSecureEnv', () => {
    it('should return true when NODE_ENV is production', () => {
      process.env.NODE_ENV = 'production';
      expect(isSecureEnv()).toBe(true);
    });

    it('should return false when NODE_ENV is development', () => {
      process.env.NODE_ENV = 'development';
      expect(isSecureEnv()).toBe(false);
    });

    it('should return false when NODE_ENV is test', () => {
      process.env.NODE_ENV = 'test';
      expect(isSecureEnv()).toBe(false);
    });

    it('should return false when NODE_ENV is undefined', () => {
      delete process.env.NODE_ENV;
      expect(isSecureEnv()).toBe(false);
    });
  });

  describe('getRefreshCookieSameSite', () => {
    it('should return "none" when NODE_ENV is production', () => {
      process.env.NODE_ENV = 'production';
      expect(getRefreshCookieSameSite()).toBe('none');
    });

    it('should return "lax" when NODE_ENV is development', () => {
      process.env.NODE_ENV = 'development';
      expect(getRefreshCookieSameSite()).toBe('lax');
    });

    it('should return "lax" when NODE_ENV is test', () => {
      process.env.NODE_ENV = 'test';
      expect(getRefreshCookieSameSite()).toBe('lax');
    });

    it('should return "lax" when NODE_ENV is undefined', () => {
      delete process.env.NODE_ENV;
      expect(getRefreshCookieSameSite()).toBe('lax');
    });
  });
});
`````

## File: backend/src/auth/auth.constants.ts
`````typescript
// Authentication related constants (cookie names, lifetimes, etc.)
export const REFRESH_COOKIE_NAME = 'rt';
export const REFRESH_COOKIE_MAX_AGE_MS = 7 * 24 * 60 * 60 * 1000; // 7 days

/**
 * æœ¬ç•ªç’°å¢ƒã‹ã©ã†ã‹ã‚’åˆ¤å®š
 */
export function isSecureEnv(): boolean {
  return process.env.NODE_ENV === 'production';
}

/**
 * Cookie ã® SameSite è¨­å®šã‚’å–å¾—
 * æœ¬ç•ªç’°å¢ƒã§ã¯ 'none' ã‚’ä½¿ç”¨ï¼ˆç•°ãªã‚‹ã‚µãƒ–ãƒ‰ãƒ¡ã‚¤ãƒ³é–“ã§ã®é€šä¿¡ã«å¿…è¦ï¼‰
 * é–‹ç™ºç’°å¢ƒã§ã¯ 'lax' ã‚’ä½¿ç”¨ï¼ˆHTTP ã§ã‚‚å‹•ä½œã™ã‚‹ï¼‰
 */
export function getRefreshCookieSameSite(): 'lax' | 'none' {
  return isSecureEnv() ? 'none' : 'lax';
}
`````

## File: backend/src/auth/auth.controller.ts
`````typescript
import {
  Body,
  Controller,
  HttpStatus,
  Post,
  UseGuards,
  Req,
  Ip,
  Res,
  UnauthorizedException,
} from "@nestjs/common";
import {
  ApiBearerAuth,
  ApiOperation,
  ApiResponse,
  ApiTags,
} from "@nestjs/swagger";
import { Request, Response } from "express";

import { RateLimitConfig } from "../common/config/rate-limit.config";
import { RateLimit } from "../common/decorators/rate-limit.decorator";

function toUserRole(val: string): RequestUser["role"] {
  // UserRole enumã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹ãƒ­ãƒ¼ãƒ«ã®ã¿èªè­˜ã™ã‚‹
  if (val === "SUPER_ADMIN" || val === "TENANT_ADMIN" || val === "ADMIN" || val === "USER") {
    return val as RequestUser["role"];
  }
  return "USER";
}


import { REFRESH_COOKIE_NAME, REFRESH_COOKIE_MAX_AGE_MS, getRefreshCookieSameSite, isSecureEnv } from './auth.constants';
import { AuthService } from "./auth.service";
import type { RequestUser } from "./auth.types";
import { ChangePasswordDto } from "./dto/change-password.dto";
import { LoginDto } from "./dto/login.dto";
import { RefreshTokenDto } from "./dto/refresh-token.dto";
import { RequestPasswordResetDto } from "./dto/request-password-reset.dto";
import { ResetPasswordDto } from "./dto/reset-password.dto";
import { GetUser } from "./get-user.decorator";
import { JwtAuthGuard } from "./jwt-auth.guard";

@ApiTags("Auth")
@Controller("auth")
export class AuthController {
  constructor(
    private readonly auth: AuthService,
  ) {}

  @Post("login")
  @RateLimit(RateLimitConfig.auth.login)
  @ApiOperation({ summary: "ãƒ­ã‚°ã‚¤ãƒ³ï¼ˆJWTç™ºè¡Œï¼‰" })
  @ApiResponse({ status: HttpStatus.OK })
  async login(
    @Body() dto: LoginDto,
    @Req() req: Request,
    @Ip() ip: string,
    @Res({ passthrough: true }) res: Response
  ): Promise<{ success: boolean; data: { access_token: string; user: RequestUser } }> {
    let userAgent: string = "";
    const ua = req.headers["user-agent"];
    if (typeof ua === "string") {
      userAgent = ua;
    } else if (Array.isArray(ua)) {
      userAgent = (ua as string[]).join(",");
    }
    const result = await this.auth.login(dto.email, dto.password, ip, userAgent);
    const userRaw = result.data.user;
    const requestUser: RequestUser = {
      userId: userRaw.id,
      email: userRaw.email,
      role: toUserRole(userRaw.role),
      firstName: userRaw.firstName ?? undefined,
      lastName: userRaw.lastName ?? undefined,
    };
    const storedRefreshToken = await this.auth.getStoredRefreshToken(userRaw.id);
    if (storedRefreshToken) {
      this.setRefreshCookie(res, storedRefreshToken);
    }
    return { success: result.success, data: { access_token: result.data.access_token, user: requestUser } };
  }

  @Post("register")
  @RateLimit(RateLimitConfig.auth.register)
  @ApiOperation({ summary: "ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²ï¼ˆãƒ¡ãƒ¼ãƒ«ï¼‹ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼‰" })
  @ApiResponse({ status: HttpStatus.OK })
  async register(
    @Body() dto: LoginDto,
    @Res({ passthrough: true }) res: Response,
  ) {
    const result = await this.auth.register(dto.email, dto.password);
    if (result.data.refresh_token) {
      this.setRefreshCookie(res, result.data.refresh_token);
    }
    return result;
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Post("set-password")
  @ApiOperation({ summary: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰è¨­å®š/å¤‰æ›´ï¼ˆè¦JWTï¼‰" })
  @ApiResponse({ status: HttpStatus.OK })
  setPassword(@GetUser() user: RequestUser | undefined, @Body() dto: LoginDto) {
    return this.auth.setPassword(user!.userId, dto.password);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Post("change-password")
  @ApiOperation({ summary: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¤‰æ›´ï¼ˆç¾åœ¨ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ç¢ºèªå¿…è¦ï¼‰" })
  @ApiResponse({ status: HttpStatus.OK })
  changePassword(
    @GetUser() user: RequestUser | undefined,
    @Body() dto: ChangePasswordDto,
  ) {
    return this.auth.changePassword(
      user!.userId,
      dto.currentPassword,
      dto.newPassword,
    );
  }

  @Post("request-password-reset")
  @RateLimit(RateLimitConfig.auth.requestReset)
  @ApiOperation({ summary: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆè¦æ±‚" })
  @ApiResponse({ status: HttpStatus.OK, description: 'ãƒªã‚»ãƒƒãƒˆæ‰‹é †ã‚’ãƒ¡ãƒ¼ãƒ«ã§é€ä¿¡' })
  requestPasswordReset(@Body() dto: RequestPasswordResetDto) {
    return this.auth.requestPasswordReset(dto.email);
  }

  @Post("reset-password")
  @RateLimit(RateLimitConfig.auth.resetPassword)
  @ApiOperation({ summary: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆå®Ÿè¡Œ" })
  @ApiResponse({ status: HttpStatus.OK, description: 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã—ãŸ' })
  @ApiResponse({ status: HttpStatus.BAD_REQUEST, description: 'ç„¡åŠ¹ã¾ãŸã¯æœŸé™åˆ‡ã‚Œã®ãƒˆãƒ¼ã‚¯ãƒ³' })
  resetPassword(@Body() dto: ResetPasswordDto) {
    return this.auth.resetPassword(dto.token, dto.newPassword);
  }

  @Post("refresh")
  @RateLimit(RateLimitConfig.auth.refresh)
  @ApiOperation({ summary: "ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã§ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³å†å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK })
  async refresh(@Body() dto: RefreshTokenDto, @Res({ passthrough: true }) res: Response): Promise<{ success: boolean; data: { access_token: string; user: RequestUser } }> {
    // DTO äº’æ›ãƒ¢ãƒ¼ãƒ‰: body ã«å…¥ã£ã¦ã„ã‚Œã°åˆ©ç”¨ã€ç„¡ã‘ã‚Œã° Cookie å‚ç…§ï¼ˆå°†æ¥çš„ã«ã¯å®Œå…¨CookieåŒ–ï¼‰
    const cookieToken = this.getCookieValue(res, REFRESH_COOKIE_NAME);
    const token = dto?.refreshToken ?? cookieToken;
    if (!token) {
      throw new UnauthorizedException('Missing refresh token');
    }

    const result = await this.auth.refreshUsingToken(token);
    const user = result.user;
    const requestUser: RequestUser = {
      userId: user.id,
      email: user.email,
      role: toUserRole(user.role),
      firstName: user.firstName ?? undefined,
      lastName: user.lastName ?? undefined,
    };
    this.setRefreshCookie(res, result.refresh_token);
    return { success: true, data: { access_token: result.access_token, user: requestUser } };
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Post("logout")
  @ApiOperation({ summary: "ãƒ­ã‚°ã‚¢ã‚¦ãƒˆï¼ˆãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³å‰Šé™¤ï¼‰" })
  @ApiResponse({ status: HttpStatus.OK })
  logout(@GetUser() user: RequestUser | undefined, @Res({ passthrough: true }) res: Response) {
    // Cookie ç„¡åŠ¹åŒ–
    res.cookie(REFRESH_COOKIE_NAME, '', { httpOnly: true, secure: isSecureEnv(), sameSite: getRefreshCookieSameSite(), path: '/', maxAge: 0 });
    return this.auth.logout(user!.userId);
  }

  private getCookieValue(res: Response, key: string): string | undefined {
    const reqLike = res.req as unknown;
    if (!reqLike || typeof reqLike !== 'object') {
      return undefined;
    }

    const cookies = (reqLike as { cookies?: unknown }).cookies;
    if (!cookies || typeof cookies !== 'object') {
      return undefined;
    }

    const value = (cookies as Record<string, unknown>)[key];
    return typeof value === 'string' ? value : undefined;
  }

  private setRefreshCookie(res: Response, token: string) {
    res.cookie(REFRESH_COOKIE_NAME, token, {
      httpOnly: true,
      secure: isSecureEnv(),
      sameSite: getRefreshCookieSameSite(),
      path: '/',
      maxAge: REFRESH_COOKIE_MAX_AGE_MS,
    });
  }

}
`````

## File: backend/src/auth/auth.module.ts
`````typescript
import { Module } from "@nestjs/common";
import { ConfigModule, ConfigService } from "@nestjs/config";
import { JwtModule } from "@nestjs/jwt";
import { PassportModule } from "@nestjs/passport";

import { PrismaModule } from "../prisma/prisma.module";

import { AuthController } from "./auth.controller";
import { AuthService } from "./auth.service";
import { JwtAuthGuard } from "./jwt-auth.guard";
import { JwtStrategy } from "./jwt.strategy";
import { LoginAttemptService } from "./login-attempt.service";
import { PasswordService } from "./password.service";

@Module({
  imports: [
    PrismaModule,
    ConfigModule,
    PassportModule,
    JwtModule.registerAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: async (configService: ConfigService) => {
        const secret = configService.get<string>("JWT_SECRET");
        if (!secret) {
          throw new Error(
            'JWT_SECRET environment variable is required. Please set it in your .env file.',
          );
        }
        return {
          secret,
          signOptions: {
            expiresIn: configService.get<string>("JWT_EXPIRES_IN") || "7d",
          },
        };
      },
    }),
  ],
  controllers: [AuthController],
  providers: [JwtStrategy, AuthService, PasswordService, LoginAttemptService, JwtAuthGuard],
  exports: [JwtModule, PassportModule, PasswordService, LoginAttemptService, JwtAuthGuard],
})
export class AuthModule {}
`````

## File: backend/src/auth/auth.service.spec.ts
`````typescript
import { ConfigService } from '@nestjs/config';
import { JwtService } from '@nestjs/jwt';
import { Test, TestingModule } from '@nestjs/testing';

import { PrismaService } from '../prisma/prisma.service';

import { AuthService } from './auth.service';
import { LoginAttemptService } from './login-attempt.service';
import { PasswordService } from './password.service';

describe('AuthService', () => {
  let service: AuthService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AuthService,
        {
          provide: PrismaService,
          useValue: {
            user: {
              findUnique: jest.fn(),
              create: jest.fn(),
            },
          },
        },
        {
          provide: JwtService,
          useValue: {
            sign: jest.fn(() => 'fake-jwt-token'),
          },
        },
        {
          provide: ConfigService,
          useValue: {
            get: jest.fn((key: string) => {
              const config: Record<string, string> = {
                JWT_SECRET: 'test-secret',
                ARGON2_MEMORY_COST: '65536',
                ARGON2_TIME_COST: '3',
                ARGON2_PARALLELISM: '4',
              };
              return config[key];
            }),
          },
        },
        {
          provide: PasswordService,
          useValue: {
            hash: jest.fn(() => Promise.resolve('hashed-password')),
            verify: jest.fn(() => Promise.resolve(true)),
          },
        },
        {
          provide: LoginAttemptService,
          useValue: {
            checkAndRecordAttempt: jest.fn(() => Promise.resolve({ allowed: true })),
            clearFailedAttempts: jest.fn(() => Promise.resolve()),
          },
        },
      ],
    }).compile();

    service = module.get<AuthService>(AuthService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
`````

## File: backend/src/auth/auth.service.ts
`````typescript
import { randomUUID, randomBytes } from "crypto";

import {
  BadRequestException,
  Injectable,
  UnauthorizedException,
  HttpException,
  HttpStatus,
  Logger,
} from "@nestjs/common";
import { ConfigService } from "@nestjs/config";
import { JwtService } from "@nestjs/jwt";
import { UserRole, User } from "@prisma/client";
import * as bcrypt from "bcryptjs";

import { PrismaService } from "../prisma/prisma.service";

import { LoginAttemptService, LoginAttemptData } from "./login-attempt.service";
import { PasswordService } from "./password.service";

type ValidatedUser = {
  id: string;
  email: string;
  role: UserRole;
  firstName: string | null;
  lastName: string | null;
  passwordHash: string | null;
  failedLoginAttempts: number;
  lockedUntil: Date | null;
};

export interface AuthUserView {
  id: string;
  email: string;
  role: UserRole;
  firstName: string | null;
  lastName: string | null;
}

export interface LoginResult {
  success: true;
  data: {
    access_token: string;
    user: AuthUserView;
  };
}

export interface RegisterResult {
  success: true;
  data: {
    id: string;
    email: string;
    access_token: string;
    refresh_token: string;
    user: AuthUserView;
  };
}

export interface RefreshTokenResult {
  access_token: string;
  refresh_token: string;
  user: AuthUserView;
}


@Injectable()
export class AuthService {
  private readonly logger = new Logger(AuthService.name);
  constructor(
    private readonly prisma: PrismaService,
    private readonly jwt: JwtService,
    private readonly configService: ConfigService,
    private readonly passwordService: PasswordService,
    private readonly loginAttemptService: LoginAttemptService,
  ) {}

  async validateUser(email: string, password: string): Promise<ValidatedUser | null> {
    const user = await this.prisma.user.findUnique({
      where: { email: email.trim().toLowerCase() },
      select: {
        id: true,
        email: true,
        role: true,
        firstName: true,
        lastName: true,
        passwordHash: true,
        failedLoginAttempts: true,
        lockedUntil: true,
      },
    });

    if (!user || !user.passwordHash) return null;

    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰æ¤œè¨¼ï¼ˆArgon2ã¾ãŸã¯bcryptï¼‰
    let isValidPassword = false;
    const isArgon2 = this.passwordService.isArgon2Hash(user.passwordHash);
    
    if (isArgon2) {
      isValidPassword = await this.passwordService.verifyPassword(
        password,
        user.passwordHash,
      );
    } else if (this.passwordService.needsMigration(user.passwordHash)) {
      // bcryptã‹ã‚‰ã®ç§»è¡Œ
      isValidPassword = await bcrypt.compare(password, user.passwordHash);
      if (isValidPassword) {
        // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒæ­£ã—ã„å ´åˆã€Argon2ã«ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰
        const newHash = await this.passwordService.hashPassword(password);
        await this.setPassword(user.id, newHash, true);
      }
    }

    if (!isValidPassword) return null;
    return user;
  }

  /**
   * ãƒ­ã‚°ã‚¤ãƒ³: ãƒ¦ãƒ¼ã‚¶æ¤œè¨¼â†’Access/Refreshãƒˆãƒ¼ã‚¯ãƒ³ç™ºè¡Œâ†’Refreshãƒˆãƒ¼ã‚¯ãƒ³ã‚’DBä¿å­˜ï¼ˆCookieã‚»ãƒƒãƒˆã¯Controllerå´ï¼‰
   */
  async login(
    email: string,
    password: string,
    ipAddress?: string,
    userAgent?: string,
  ): Promise<LoginResult> {
    email = email.trim().toLowerCase();
    // ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ­ãƒƒã‚¯çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯
    const isLocked = await this.loginAttemptService.isAccountLocked(email);
    if (isLocked) {
      const remainingMinutes =
        await this.loginAttemptService.getLockoutRemainingMinutes(email);

      // å¤±æ•—è©¦è¡Œã‚’è¨˜éŒ²
      await this.loginAttemptService.recordLoginAttempt({
        email,
        ipAddress,
        userAgent,
        success: false,
        reason: "Account locked",
      });

      throw new HttpException(
        `ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãŒãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã¾ã™ã€‚${remainingMinutes}åˆ†å¾Œã«å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚`,
        HttpStatus.TOO_MANY_REQUESTS,
      );
    }

    // ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼
    const user = await this.validateUser(email, password);

    const loginAttemptData: LoginAttemptData = {
      email,
      ipAddress,
      userAgent,
      success: !!user,
      reason: user ? undefined : "Invalid credentials",
    };

    // ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œã‚’è¨˜éŒ²
    await this.loginAttemptService.recordLoginAttempt(loginAttemptData);

    if (!user) {
      this.logger.warn({
        message: 'Login failed: Invalid credentials',
        email,
        ipAddress,
        timestamp: new Date().toISOString(),
      });
      throw new UnauthorizedException("èªè¨¼æƒ…å ±ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“");
    }

    // generateTokens ã«ãƒ•ãƒ«ãƒ¦ãƒ¼ã‚¶ãƒ¼å‹ãŒå¿…è¦ãªãŸã‚å†å–å¾—
    const fullUser = await this.prisma.user.findUnique({ where: { id: user.id } });
    if (!fullUser) {
      this.logger.error(`User ${user.id} disappeared during login flow`);
      throw new UnauthorizedException("ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
    }
    const tokens = await this.generateTokens(fullUser);

    // ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸãƒ­ã‚°
    this.logger.log({
      message: 'Login successful',
      userId: user.id,
      email: user.email,
      role: user.role,
      ipAddress,
      timestamp: new Date().toISOString(),
    });

    return {
      success: true,
      data: {
        access_token: tokens.access_token,
        user: {
          id: user.id,
          email: user.email,
          role: user.role,
          firstName: user.firstName,
          lastName: user.lastName,
        },
      },
    };
  }

  async setPassword(
    userId: string,
    password: string,
    isHashed: boolean = false,
  ): Promise<{ success: true }> {
    let hash: string;

    if (isHashed) {
      // ã™ã§ã«ãƒãƒƒã‚·ãƒ¥åŒ–ã•ã‚Œã¦ã„ã‚‹ï¼ˆå†…éƒ¨ã‹ã‚‰ã®å‘¼ã³å‡ºã—ï¼‰
      hash = password;
    } else {
      // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¼·åº¦ãƒã‚§ãƒƒã‚¯
      const validation =
        this.passwordService.validatePasswordStrength(password);
      if (!validation.isValid) {
        throw new BadRequestException({
          message: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒè¦ä»¶ã‚’æº€ãŸã—ã¦ã„ã¾ã›ã‚“",
          errors: validation.errors,
        });
      }

      // Argon2ã§ãƒãƒƒã‚·ãƒ¥åŒ–
      hash = await this.passwordService.hashPassword(password);
    }

    await this.prisma.user.update({
      where: { id: userId },
      data: { passwordHash: hash },
    });
    return { success: true };
  }

  async register(email: string, password: string): Promise<RegisterResult> {
    // email ã®æ­£è¦åŒ–ï¼ˆå‰å¾Œã‚¹ãƒšãƒ¼ã‚¹é™¤å»ï¼‹å°æ–‡å­—åŒ–ï¼‰
    email = email.trim().toLowerCase();
    // unique åˆ¶ç´„ã«å¾“ã„ findUnique ã‚’ä½¿ç”¨
    const existing = await this.prisma.user.findUnique({ where: { email } });
    if (existing)
      throw new BadRequestException("ã“ã®ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯æ—¢ã«ç™»éŒ²ã•ã‚Œã¦ã„ã¾ã™");

    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¼·åº¦ãƒã‚§ãƒƒã‚¯
    const validation = this.passwordService.validatePasswordStrength(password);
    if (!validation.isValid) {
      throw new BadRequestException({
        message: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒè¦ä»¶ã‚’æº€ãŸã—ã¦ã„ã¾ã›ã‚“",
        errors: validation.errors,
      });
    }
    // äº‹å‰ã«ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–ã—ã€ä½œæˆæ™‚ã«åŒæ™‚ä¿å­˜ï¼ˆUPDATEã‚’å›é¿ï¼‰
    const passwordHash = await this.passwordService.hashPassword(password);

    const user = await this.prisma.user.create({
      data: {
        email,
        role: UserRole.USER,
        isActive: true,
        // clerkId ã¯ nullableã€å¿…è¦æ™‚ã®ã¿è¨­å®š
        clerkId: `local_${randomUUID()}`,
        passwordHash,
        failedLoginAttempts: 0,
        lockedUntil: null,
        lastLoginAt: null,
      },
    });

    const tokens = await this.generateTokens(user);

    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²æˆåŠŸãƒ­ã‚°
    this.logger.log({
      message: 'User registered successfully',
      userId: user.id,
      email: user.email,
      timestamp: new Date().toISOString(),
    });

    return {
      success: true,
      data: {
        id: user.id,
        email: user.email,
        access_token: tokens.access_token,
        refresh_token: tokens.refresh_token,
        user: {
          id: user.id,
          email: user.email,
          role: user.role,
          firstName: user.firstName,
          lastName: user.lastName,
        },
      },
    };
  }

  async requestPasswordReset(email: string): Promise<{
    success: true;
    message: string;
    token?: string;
  }> {
    // email ã®æ­£è¦åŒ–
    email = email.trim().toLowerCase();
    const user = await this.prisma.user.findUnique({ where: { email } });
    if (!user) {
      // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®ãŸã‚ã€å­˜åœ¨ã—ãªã„ãƒ¡ãƒ¼ãƒ«ã§ã‚‚æˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã™
      return {
        success: true,
        message: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆæ‰‹é †ã‚’ãƒ¡ãƒ¼ãƒ«ã§é€ä¿¡ã—ã¾ã—ãŸ",
      };
    }

  // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆãƒˆãƒ¼ã‚¯ãƒ³ã®ç”Ÿæˆï¼ˆ32ãƒã‚¤ãƒˆã®ãƒ©ãƒ³ãƒ€ãƒ æ–‡å­—åˆ—ï¼‰
  const resetToken = randomBytes(32).toString('hex');
    const resetTokenHash = await this.passwordService.hashPassword(resetToken);
    
    // ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ‰åŠ¹æœŸé™ï¼ˆ1æ™‚é–“ï¼‰
    const resetPasswordExpires = new Date();
    resetPasswordExpires.setHours(resetPasswordExpires.getHours() + 1);

    // ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜
    await this.prisma.user.update({
      where: { id: user.id },
      data: {
        resetPasswordToken: resetTokenHash,
        resetPasswordExpires,
      },
    });

    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ­ã‚°
    this.logger.log({
      message: 'Password reset requested',
      email,
      userExists: !!user,
      timestamp: new Date().toISOString(),
    });

    // TODO: ãƒ¡ãƒ¼ãƒ«é€ä¿¡å®Ÿè£…
    // é–‹ç™ºç’°å¢ƒã§ã¯ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å‡ºåŠ›
    if (process.env.NODE_ENV !== 'production') {
      this.logger.log(`Password reset token for ${email}: ${resetToken}`);
      this.logger.log(`Reset URL: http://localhost:3000/reset-password?token=${resetToken}`);
    }

    // æœ¬ç•ªç’°å¢ƒã§ã¯ã€ã“ã“ã§ãƒ¡ãƒ¼ãƒ«é€ä¿¡ã‚µãƒ¼ãƒ“ã‚¹ã‚’å‘¼ã³å‡ºã™
    // await this.mailService.sendPasswordResetEmail(user.email, resetToken);

    return {
      success: true,
      message: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆæ‰‹é †ã‚’ãƒ¡ãƒ¼ãƒ«ã§é€ä¿¡ã—ã¾ã—ãŸ",
      // é–‹ç™ºç’°å¢ƒã®ã¿ãƒˆãƒ¼ã‚¯ãƒ³ã‚’è¿”ã™
      ...(process.env.NODE_ENV !== 'production' && { token: resetToken }),
    };
  }

  async resetPassword(token: string, newPassword: string): Promise<{ success: true; message: string }> {
    const candidates = await this.prisma.user.findMany({
      where: {
        resetPasswordToken: { not: null },
        resetPasswordExpires: { gte: new Date() },
      },
      select: {
        id: true,
        email: true,
        resetPasswordToken: true,
      },
    });

    if (!candidates.length) {
      throw new BadRequestException('ç„¡åŠ¹ã¾ãŸã¯æœŸé™åˆ‡ã‚Œã®ãƒˆãƒ¼ã‚¯ãƒ³ã§ã™');
    }

    let matchedUser: { id: string; email: string } | null = null;

    // Timing attack prevention: always check all candidates
    // to ensure constant-time operation regardless of token position
    for (const user of candidates) {
      if (!user.resetPasswordToken) continue;
      const isValidToken = await this.passwordService.verifyPassword(
        token,
        user.resetPasswordToken,
      );
      if (isValidToken && !matchedUser) {
        matchedUser = { id: user.id, email: user.email };
        // Continue checking remaining users to prevent timing attacks
      }
    }

    if (!matchedUser) {
      throw new BadRequestException('ç„¡åŠ¹ã¾ãŸã¯æœŸé™åˆ‡ã‚Œã®ãƒˆãƒ¼ã‚¯ãƒ³ã§ã™');
    }

    // æ–°ã—ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–
    const newPasswordHash = await this.passwordService.hashPassword(newPassword);

    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’æ›´æ–°ã—ã€ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ã‚¯ãƒªã‚¢
    await this.prisma.user.update({
      where: { id: matchedUser.id },
      data: {
        passwordHash: newPasswordHash,
        resetPasswordToken: null,
        resetPasswordExpires: null,
        failedLoginAttempts: 0,
        lockedUntil: null,
      },
    });

    this.logger.log(`Password reset successful for user: ${matchedUser.email}`);

    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆæˆåŠŸè©³ç´°ãƒ­ã‚°
    this.logger.log({
      message: 'Password reset completed',
      userId: matchedUser.id,
      email: matchedUser.email,
      timestamp: new Date().toISOString(),
    });

    return {
      success: true,
      message: 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒæ­£å¸¸ã«ãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã—ãŸ',
    };
  }

  async changePassword(
    userId: string,
    currentPassword: string,
    newPassword: string,
  ): Promise<{ success: true; message: string }> {
    const user = await this.prisma.user.findUnique({ where: { id: userId } });
    if (!user || !user.passwordHash) {
      throw new BadRequestException("ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
    }

    // ç¾åœ¨ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ç¢ºèª
    let isCurrentPasswordValid = false;
    if (this.passwordService.isArgon2Hash(user.passwordHash)) {
      isCurrentPasswordValid = await this.passwordService.verifyPassword(
        currentPassword,
        user.passwordHash,
      );
    } else if (this.passwordService.needsMigration(user.passwordHash)) {
      isCurrentPasswordValid = await bcrypt.compare(
        currentPassword,
        user.passwordHash,
      );
    }

    if (!isCurrentPasswordValid) {
      throw new UnauthorizedException("ç¾åœ¨ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“");
    }

    // æ–°ã—ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’è¨­å®š
    await this.setPassword(userId, newPassword);
    return { success: true, message: "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒæ­£å¸¸ã«å¤‰æ›´ã•ã‚Œã¾ã—ãŸ" };
  }

  /**
   * Cookie ãªã©ã§å—ã‘å–ã£ãŸ refreshToken ã‚’ç”¨ã„ã¦ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å†ç™ºè¡Œ
   * æˆåŠŸæ™‚ã¯ refreshToken ã‚’ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆæ–°ã—ã„ã‚‚ã®ã‚’è¿”ã™ï¼‰
   */
  async refreshUsingToken(refreshToken: string): Promise<RefreshTokenResult> {
    if (!refreshToken) {
      this.logger.warn('Refresh attempt without token');
      throw new UnauthorizedException('Missing refresh token');
    }
    try {
      const payload = this.jwt.verify(refreshToken, {
        secret: process.env.JWT_REFRESH_SECRET || process.env.JWT_SECRET,
      }) as { sub: string };

      const user = await this.prisma.user.findFirst({
        where: { id: payload.sub, refreshToken: refreshToken },
        select: {
          id: true,
          email: true,
          role: true,
          firstName: true,
          lastName: true,
          refreshToken: true,
        },
      });
      if (!user) {
        this.logger.warn(`Refresh token mismatch or user not found (sub=${payload.sub})`);
        throw new UnauthorizedException('Invalid refresh token');
      }

      // generateTokens ã®ãŸã‚ã«å®Œå…¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå¿…è¦ => id ã§å†å–å¾—
      const fullUser = await this.prisma.user.findUnique({ where: { id: user.id } });
      if (!fullUser) {
        this.logger.warn(`User ${user.id} missing during refresh flow`);
        throw new UnauthorizedException('Invalid refresh token');
      }
      const tokens = await this.generateTokens(fullUser); // ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³
      return {
        access_token: tokens.access_token,
        refresh_token: tokens.refresh_token,
        user: {
          id: user.id,
          email: user.email,
          role: user.role,
          firstName: user.firstName,
          lastName: user.lastName,
        },
      };
    } catch (e) {
      this.logger.warn(`Refresh verification failed: ${e instanceof Error ? e.message : e}`);
      throw new UnauthorizedException('Invalid refresh token');
    }
  }

  private async generateTokens(user: User): Promise<{ access_token: string; refresh_token: string }> {
    const accessPayload = {
      sub: user.id,
      email: user.email,
      role: user.role,
      tenantId: user.tenantId, // ãƒãƒ«ãƒãƒ†ãƒŠãƒ³ãƒˆå¯¾å¿œ
      jti: randomUUID(),
    };
    const access_token = await this.jwt.signAsync(accessPayload, {
      expiresIn: '15m',
      secret: process.env.JWT_SECRET,
    });
    const refresh_token = await this.jwt.signAsync(
      { sub: user.id, type: 'refresh', jti: randomUUID() },
      {
        expiresIn: '7d',
        secret: process.env.JWT_REFRESH_SECRET || process.env.JWT_SECRET,
      },
    );

    await this.prisma.user.update({
      where: { id: user.id },
      data: { refreshToken: refresh_token },
    });
    return { access_token, refresh_token };
  }

  async logout(userId: string): Promise<{ success: true; message: string }> {
    await this.prisma.user.update({
      where: { id: userId },
      data: { refreshToken: null },
    });
    return { success: true, message: 'ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ' };
  }

  async getStoredRefreshToken(userId: string): Promise<string | null> {
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
      select: { refreshToken: true },
    });
    return user?.refreshToken ?? null;
  }
}
`````

## File: backend/src/auth/auth.types.ts
`````typescript
import type { UserRole } from "@prisma/client";
export type { UserRole };

export interface JwtPayload {
  sub: string; // user id
  email?: string;
  role?: UserRole;
  tenantId?: string; // ãƒãƒ«ãƒãƒ†ãƒŠãƒ³ãƒˆå¯¾å¿œ
  jti?: string;
  iat?: number;
  exp?: number;
}

export interface RequestUser {
  userId: string;
  email?: string;
  role?: UserRole;
  tenantId?: string; // ãƒãƒ«ãƒãƒ†ãƒŠãƒ³ãƒˆå¯¾å¿œ
  firstName?: string;
  lastName?: string;
}
`````

## File: backend/src/auth/get-user.decorator.ts
`````typescript
import { createParamDecorator, ExecutionContext } from "@nestjs/common";

import type { RequestUser } from "./auth.types";

export const GetUser = createParamDecorator(
  (data: unknown, ctx: ExecutionContext) => {
  const request = ctx.switchToHttp().getRequest() as { user?: RequestUser };
  return request.user;
  },
);
`````

## File: backend/src/auth/jwt-auth.guard.ts
`````typescript
import { Injectable, ExecutionContext } from "@nestjs/common";
import { ConfigService } from "@nestjs/config";
import { Reflector } from "@nestjs/core";
import { AuthGuard } from "@nestjs/passport";
import type { Request } from "express";

import { IS_PUBLIC_KEY } from "../common/decorators/public.decorator";

@Injectable()
export class JwtAuthGuard extends AuthGuard("jwt") {
  constructor(
    private reflector: Reflector,
    private configService: ConfigService,
  ) {
    super();
  }

  canActivate(context: ExecutionContext) {
    // AUTH_DISABLED=1 ã®å ´åˆã¯èªè¨¼ã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼ˆé–‹ç™ºç’°å¢ƒå°‚ç”¨ï¼‰
    const authDisabled = this.configService.get<number>('AUTH_DISABLED', 0);
    if (authDisabled === 1) {
      return true;
    }

    // OPTIONS ãƒªã‚¯ã‚¨ã‚¹ãƒˆï¼ˆCORS ãƒ—ãƒªãƒ•ãƒ©ã‚¤ãƒˆï¼‰ã¯èªè¨¼ã‚’ã‚¹ã‚­ãƒƒãƒ—
    const request = context.switchToHttp().getRequest<Request>();
    if (request.method === 'OPTIONS') {
      return true;
    }

    // @Public() ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã¯èªè¨¼ã‚’ã‚¹ã‚­ãƒƒãƒ—
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    if (isPublic) {
      return true;
    }

    return super.canActivate(context);
  }
}
`````

## File: backend/src/auth/jwt.strategy.ts
`````typescript
import { Injectable } from "@nestjs/common";
import { PassportStrategy } from "@nestjs/passport";
import { ExtractJwt, Strategy } from "passport-jwt";

import type { JwtPayload, RequestUser } from "./auth.types";

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor() {
    const jwtSecret = process.env.JWT_SECRET;
    if (!jwtSecret) {
      throw new Error(
        'JWT_SECRET environment variable is required. Please set it in your .env file.',
      );
    }

    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: jwtSecret,
    });
  }

  async validate(payload: JwtPayload): Promise<RequestUser> {
    // payload ä¾‹: { sub: userId, email, role, tenantId }
    return { 
      userId: payload.sub, 
      email: payload.email, 
      role: payload.role,
      tenantId: payload.tenantId,
    };
  }
}
`````

## File: backend/src/auth/login-attempt.service.ts
`````typescript
import { randomUUID } from "crypto";

import { Injectable, Logger } from "@nestjs/common";
import { ConfigService } from "@nestjs/config";

import { PrismaService } from "../prisma/prisma.service";

export interface LoginAttemptData {
  email: string;
  ipAddress?: string;
  userAgent?: string;
  success: boolean;
  reason?: string;
}

@Injectable()
export class LoginAttemptService {
  private readonly logger = new Logger(LoginAttemptService.name);
  private readonly maxAttempts: number;
  private readonly lockoutDurationMinutes: number;

  constructor(
    private readonly prisma: PrismaService,
    private readonly configService: ConfigService,
  ) {
    this.maxAttempts = this.configService.get<number>("MAX_LOGIN_ATTEMPTS", 5);
    this.lockoutDurationMinutes = this.configService.get<number>(
      "LOGIN_LOCKOUT_DURATION_MINUTES",
      15,
    );

    this.logger.log(
      `LoginAttemptService initialized - Max attempts: ${this.maxAttempts}, Lockout: ${this.lockoutDurationMinutes}min`,
    );
  }

  /**
   * ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œã‚’è¨˜éŒ²
   */
  async recordLoginAttempt(data: LoginAttemptData): Promise<void> {
    try {
      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’æ¤œç´¢ï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’è¨­å®šï¼‰
      const user = await this.prisma.user.findUnique({
        where: { email: data.email },
        select: { id: true },
      });

      // ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œã‚’è¨˜éŒ²ï¼ˆrawã‚¯ã‚¨ãƒªä½¿ç”¨ï¼‰
      const id = randomUUID();
      await this.prisma.loginAttempt.create({
        data: {
          id,
          userId: user?.id ?? null,
          email: data.email,
          ipAddress: data.ipAddress ?? null,
          userAgent: data.userAgent ?? null,
          success: data.success,
          reason: data.reason ?? null,
          // createdAt defaults to now()
        },
      });

      // å¤±æ•—ã®å ´åˆã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å¤±æ•—ã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–°
      if (!data.success && user) {
        await this.updateFailedLoginCount(user.id, data.email);
      }

      // æˆåŠŸã®å ´åˆã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å¤±æ•—ã‚«ã‚¦ãƒ³ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
      if (data.success && user) {
        await this.resetFailedLoginCount(user.id);
      }

      this.logger.debug(
        `Login attempt recorded: ${data.email} - ${data.success ? "SUCCESS" : "FAILED"}`,
      );
    } catch (error) {
      this.logger.error("Failed to record login attempt:", error);
      // ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œã®è¨˜éŒ²å¤±æ•—ã¯ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†ã‚’å¦¨ã’ãªã„
    }
  }

  /**
   * ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãŒãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
   */
  async isAccountLocked(email: string): Promise<boolean> {
    try {
      const result = await this.prisma.user.findMany({
        where: { email },
        select: { id: true, failedLoginAttempts: true, lockedUntil: true },
        take: 1,
      });

      if (!result || result.length === 0) {
        return false; // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ãªã„
      }

      const user = result[0];

      // ãƒ­ãƒƒã‚¯æœŸé™ãŒè¨­å®šã•ã‚Œã¦ãŠã‚Šã€ã¾ã æœ‰åŠ¹ãªå ´åˆ
  if (user.lockedUntil && user.lockedUntil > new Date()) {
        return true;
      }

      // ãƒ­ãƒƒã‚¯æœŸé™ãŒéãã¦ã„ã‚‹å ´åˆã€ãƒ­ãƒƒã‚¯ã‚’è§£é™¤
      if (user.lockedUntil && user.lockedUntil <= new Date()) {
        await this.resetFailedLoginCount(user.id);
        return false;
      }

      // æœ€å¤§è©¦è¡Œå›æ•°ã«é”ã—ã¦ã„ã‚‹å ´åˆ
  return user.failedLoginAttempts >= this.maxAttempts;
    } catch (error) {
      this.logger.error("Failed to check account lock status:", error);
      return false; // ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ãªã„ã¨ã¿ãªã™
    }
  }

  /**
   * ãƒ­ãƒƒã‚¯è§£é™¤ã¾ã§ã®æ®‹ã‚Šæ™‚é–“ï¼ˆåˆ†ï¼‰ã‚’å–å¾—
   */
  async getLockoutRemainingMinutes(email: string): Promise<number> {
    try {
      const result = await this.prisma.user.findMany({
        where: { email },
        select: { lockedUntil: true },
        take: 1,
      });

  if (!result || result.length === 0 || !result[0].lockedUntil) {
        return 0;
      }

      const now = new Date();
  const lockoutEnd = result[0].lockedUntil;

      if (lockoutEnd <= now) {
        return 0;
      }

      return Math.ceil((lockoutEnd.getTime() - now.getTime()) / (1000 * 60));
    } catch (error) {
      this.logger.error("Failed to get lockout remaining time:", error);
      return 0;
    }
  }

  /**
   * å¤±æ•—ãƒ­ã‚°ã‚¤ãƒ³ã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–°
   */
  private async updateFailedLoginCount(
    userId: string,
    email: string,
  ): Promise<void> {
    try {
      const result = await this.prisma.user.findMany({
        where: { id: userId },
        select: { failedLoginAttempts: true },
        take: 1,
      });

      if (!result || result.length === 0) return;

  const newFailedAttempts = (result[0].failedLoginAttempts || 0) + 1;
      const shouldLock = newFailedAttempts >= this.maxAttempts;

      if (shouldLock) {
        const lockoutEnd = new Date();
        lockoutEnd.setMinutes(
          lockoutEnd.getMinutes() + this.lockoutDurationMinutes,
        );

        await this.prisma.user.update({
          where: { id: userId },
          data: { failedLoginAttempts: newFailedAttempts, lockedUntil: lockoutEnd },
        });

        this.logger.warn(
          `Account locked: ${email} - ${newFailedAttempts} failed attempts. Locked until: ${lockoutEnd.toISOString()}`,
        );
      } else {
        await this.prisma.user.update({
          where: { id: userId },
          data: { failedLoginAttempts: newFailedAttempts },
        });
      }
    } catch (error) {
      this.logger.error("Failed to update failed login count:", error);
    }
  }

  /**
   * å¤±æ•—ãƒ­ã‚°ã‚¤ãƒ³ã‚«ã‚¦ãƒ³ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
   */
  private async resetFailedLoginCount(userId: string): Promise<void> {
    try {
      await this.prisma.user.update({
        where: { id: userId },
        data: { failedLoginAttempts: 0, lockedUntil: null, lastLoginAt: new Date() },
      });
    } catch (error) {
      this.logger.error("Failed to reset failed login count:", error);
    }
  }

  /**
   * ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œå±¥æ­´ã‚’å–å¾—ï¼ˆç®¡ç†è€…ç”¨ï¼‰
   */
  async getLoginAttemptHistory(
    email?: string,
    limit: number = 50,
  ): Promise<Array<{
    id: string;
    userId?: string;
    email: string;
    ipAddress?: string;
    userAgent?: string;
    success: boolean;
    reason?: string;
    createdAt: Date;
    user_id?: string;
    user_email?: string;
    firstName?: string;
    lastName?: string;
  }>> {
    try {
      if (email) {
        const items = await this.prisma.loginAttempt.findMany({
          where: { email },
          orderBy: { createdAt: "desc" },
          take: limit,
          include: { user: { select: { id: true, email: true, firstName: true, lastName: true } } },
        });
        return items.map((la) => ({
          id: la.id,
          userId: la.userId ?? undefined,
          email: la.email,
          ipAddress: la.ipAddress ?? undefined,
          userAgent: la.userAgent ?? undefined,
          success: la.success,
          reason: la.reason ?? undefined,
          createdAt: la.createdAt,
          user_id: la.user?.id,
          user_email: la.user?.email,
          firstName: la.user?.firstName ?? undefined,
          lastName: la.user?.lastName ?? undefined,
        }));
      } else {
        const items = await this.prisma.loginAttempt.findMany({
          orderBy: { createdAt: "desc" },
          take: limit,
          include: { user: { select: { id: true, email: true, firstName: true, lastName: true } } },
        });
        return items.map((la) => ({
          id: la.id,
          userId: la.userId ?? undefined,
          email: la.email,
          ipAddress: la.ipAddress ?? undefined,
          userAgent: la.userAgent ?? undefined,
          success: la.success,
          reason: la.reason ?? undefined,
          createdAt: la.createdAt,
          user_id: la.user?.id,
          user_email: la.user?.email,
          firstName: la.user?.firstName ?? undefined,
          lastName: la.user?.lastName ?? undefined,
        }));
      }
    } catch (error) {
      this.logger.error("Failed to get login attempt history:", error);
      return [];
    }
  }

  /**
   * å¤ã„ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œè¨˜éŒ²ã‚’å‰Šé™¤ï¼ˆå®šæœŸå®Ÿè¡Œç”¨ï¼‰
   */
  async cleanupOldLoginAttempts(daysToKeep: number = 90): Promise<number> {
    try {
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);

      await this.prisma.loginAttempt.deleteMany({
        where: { createdAt: { lt: cutoffDate } },
      });

      this.logger.log(
        `Cleaned up old login attempt records (older than ${daysToKeep} days)`,
      );
      return 0; // rawã‚¯ã‚¨ãƒªã§ã¯æ­£ç¢ºãªå‰Šé™¤æ•°ã‚’å–å¾—ã§ããªã„ãŸã‚0ã‚’è¿”ã™
    } catch (error) {
      this.logger.error("Failed to cleanup old login attempts:", error);
      return 0;
    }
  }
}
`````

## File: backend/src/auth/password.service.ts
`````typescript
import { Injectable, Logger } from "@nestjs/common";
import { ConfigService } from "@nestjs/config";
import * as argon2 from "argon2";

export interface Argon2Config {
  memoryCost: number;
  timeCost: number;
  parallelism: number;
  hashLength: number;
  saltLength: number;
}

@Injectable()
export class PasswordService {
  private readonly logger = new Logger(PasswordService.name);
  private readonly argon2Config: Argon2Config;

  constructor(private readonly configService: ConfigService) {
    this.argon2Config = {
      memoryCost: this.configService.get<number>("ARGON2_MEMORY_COST", 65536),
      timeCost: this.configService.get<number>("ARGON2_TIME_COST", 3),
      parallelism: this.configService.get<number>("ARGON2_PARALLELISM", 4),
      hashLength: this.configService.get<number>("ARGON2_HASH_LENGTH", 64),
      saltLength: this.configService.get<number>("ARGON2_SALT_LENGTH", 32),
    };

    this.logger.log("PasswordService initialized with Argon2id configuration");
  }

  /**
   * ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’Argon2idã§ãƒãƒƒã‚·ãƒ¥åŒ–
   */
  async hashPassword(password: string): Promise<string> {
    try {
      const hash = await argon2.hash(password, {
        type: argon2.argon2id,
        memoryCost: this.argon2Config.memoryCost,
        timeCost: this.argon2Config.timeCost,
        parallelism: this.argon2Config.parallelism,
        hashLength: this.argon2Config.hashLength,
      });

      this.logger.debug("Password successfully hashed with Argon2id");
      return hash;
    } catch (error) {
      this.logger.error("Failed to hash password:", error);
      throw new Error("Password hashing failed");
    }
  }

  /**
   * ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’æ¤œè¨¼
   */
  async verifyPassword(password: string, hash: string): Promise<boolean> {
    try {
      const isValid = await argon2.verify(hash, password);
      this.logger.debug(
        `Password verification: ${isValid ? "success" : "failed"}`,
      );
      return isValid;
    } catch (error) {
      this.logger.error("Failed to verify password:", error);
      return false;
    }
  }

  /**
   * ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¼·åº¦ãƒã‚§ãƒƒã‚¯
   */
  validatePasswordStrength(password: string): {
    isValid: boolean;
    errors: string[];
  } {
    const errors: string[] = [];
    const minLength = this.configService.get<number>("PASSWORD_MIN_LENGTH", 8);

    if (password.length < minLength) {
      errors.push(`ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯${minLength}æ–‡å­—ä»¥ä¸Šã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™`);
    }

    if (!/[a-z]/.test(password)) {
      errors.push("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã«ã¯å°æ–‡å­—ã‚’å«ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™");
    }

    if (!/[A-Z]/.test(password)) {
      errors.push("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã«ã¯å¤§æ–‡å­—ã‚’å«ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™");
    }

    if (!/[0-9]/.test(password)) {
      errors.push("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã«ã¯æ•°å­—ã‚’å«ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™");
    }

    // ç‰¹æ®Šæ–‡å­—ãƒã‚§ãƒƒã‚¯ã¯å‰Šé™¤ï¼ˆè¦ä»¶ã‚’ç·©å’Œï¼‰
    // if (!/[!@#$%^&*()_+\-=[\]{};':"\\|,.<>/?]/.test(password)) {
    //   errors.push("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã«ã¯ç‰¹æ®Šæ–‡å­—ã‚’å«ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™");
    // }

    // é€£ç¶šã™ã‚‹æ–‡å­—ãƒã‚§ãƒƒã‚¯
    if (/(.)\1{2,}/.test(password)) {
      errors.push(
        "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã«åŒã˜æ–‡å­—ã‚’3å›ä»¥ä¸Šé€£ç¶šã§ä½¿ç”¨ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“",
      );
    }

    // ã‚ˆãã‚ã‚‹å¼±ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆé–‹ç™ºç”¨ã«ç·©å’Œï¼‰
    // const weakPatterns = [/123456/, /password/i, /qwerty/i, /admin/i, /guest/i];

    // if (weakPatterns.some((pattern) => pattern.test(password))) {
    //   errors.push("ã‚ˆãä½¿ã‚ã‚Œã‚‹ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ä½¿ç”¨ã§ãã¾ã›ã‚“");
    // }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }

  /**
   * ãƒãƒƒã‚·ãƒ¥ãŒArgon2ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
   */
  isArgon2Hash(hash: string): boolean {
    return hash.startsWith("$argon2");
  }

  /**
   * bcryptãƒãƒƒã‚·ãƒ¥ã‹ã‚‰Argon2ã¸ã®ç§»è¡Œãƒã‚§ãƒƒã‚¯
   */
  needsMigration(hash: string): boolean {
    return (
      hash.startsWith("$2a$") ||
      hash.startsWith("$2b$") ||
      hash.startsWith("$2y$")
    );
  }
}
`````

## File: backend/src/auth/role.guard.spec.ts
`````typescript
import { ExecutionContext, Logger } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Test, TestingModule } from '@nestjs/testing';
import { UserRole } from '@prisma/client';

import { RoleGuard } from './role.guard';

describe('RoleGuard', () => {
  let guard: RoleGuard;
  let reflector: Reflector;
  let loggerWarnSpy: jest.SpyInstance;
  let originalAuthDisabled: string | undefined;

  beforeEach(async () => {
    originalAuthDisabled = process.env.AUTH_DISABLED;
    delete process.env.AUTH_DISABLED;

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        RoleGuard,
        {
          provide: Reflector,
          useValue: {
            getAllAndOverride: jest.fn(),
          },
        },
      ],
    }).compile();

    guard = module.get<RoleGuard>(RoleGuard);
    reflector = module.get<Reflector>(Reflector);

    // Logger ã® warn ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ãƒ¢ãƒƒã‚¯
    loggerWarnSpy = jest.spyOn(Logger.prototype, 'warn').mockImplementation();
  });

  afterEach(() => {
    if (typeof originalAuthDisabled === 'string') {
      process.env.AUTH_DISABLED = originalAuthDisabled;
    } else {
      delete process.env.AUTH_DISABLED;
    }

    jest.restoreAllMocks();
  });

  const createMockExecutionContext = (
    user?: { userId: string; email?: string; role?: UserRole },
  ): ExecutionContext => {
    const context: Partial<ExecutionContext> = {
      switchToHttp: () => ({
        getRequest: <T = { user?: { userId: string; email?: string; role?: UserRole } }>() =>
          ({ user }) as T,
        getResponse: <T = Record<string, never>>() => ({}) as T,
        getNext: <T = Record<string, never>>() => ({}) as T,
      }),
      getHandler: () => jest.fn(),
      getClass: () => jest.fn(),
    };

    return context as ExecutionContext;
  };

  it('å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã“ã¨', () => {
    expect(guard).toBeDefined();
  });

  describe('canActivate', () => {
    it('ãƒ­ãƒ¼ãƒ«ãŒè¦æ±‚ã•ã‚Œã¦ã„ãªã„å ´åˆã¯ true ã‚’è¿”ã™', () => {
      jest
        .spyOn(reflector, 'getAllAndOverride')
        .mockReturnValueOnce(false)
        .mockReturnValueOnce(undefined);

      const context = createMockExecutionContext();
      const result = guard.canActivate(context);

      expect(result).toBe(true);
    });

    it('ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ false ã‚’è¿”ã™', () => {
      jest
        .spyOn(reflector, 'getAllAndOverride')
        .mockReturnValueOnce(false)
        .mockReturnValueOnce([UserRole.ADMIN]);

      const context = createMockExecutionContext(undefined);
      const result = guard.canActivate(context);

      expect(result).toBe(false);
    });

    it('ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒ ADMIN ãƒ­ãƒ¼ãƒ«ã‚’æŒã£ã¦ã„ã¦ ADMIN ãŒè¦æ±‚ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ true ã‚’è¿”ã™', () => {
      jest
        .spyOn(reflector, 'getAllAndOverride')
        .mockReturnValueOnce(false)
        .mockReturnValueOnce([UserRole.ADMIN, UserRole.SUPER_ADMIN]);

      const context = createMockExecutionContext({
        userId: 'user-1',
        email: 'admin@example.com',
        role: UserRole.ADMIN,
      });
      const result = guard.canActivate(context);

      expect(result).toBe(true);
    });

    it('ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒ SUPER_ADMIN ãƒ­ãƒ¼ãƒ«ã‚’æŒã£ã¦ã„ã¦ ADMIN ã¾ãŸã¯ SUPER_ADMIN ãŒè¦æ±‚ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ true ã‚’è¿”ã™', () => {
      jest
        .spyOn(reflector, 'getAllAndOverride')
        .mockReturnValueOnce(false)
        .mockReturnValueOnce([UserRole.ADMIN, UserRole.SUPER_ADMIN]);

      const context = createMockExecutionContext({
        userId: 'user-2',
        email: 'superadmin@example.com',
        role: UserRole.SUPER_ADMIN,
      });
      const result = guard.canActivate(context);

      expect(result).toBe(true);
    });

    it('ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒ USER ãƒ­ãƒ¼ãƒ«ã‚’æŒã£ã¦ã„ã¦ ADMIN ãŒè¦æ±‚ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ false ã‚’è¿”ã™', () => {
      jest
        .spyOn(reflector, 'getAllAndOverride')
        .mockReturnValueOnce(false)
        .mockReturnValueOnce([UserRole.ADMIN, UserRole.SUPER_ADMIN]);

      const context = createMockExecutionContext({
        userId: 'user-3',
        email: 'user@example.com',
        role: UserRole.USER,
      });
      const result = guard.canActivate(context);

      expect(result).toBe(false);
    });

    it('ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ãƒ­ãƒ¼ãƒ«ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ false ã‚’è¿”ã™', () => {
      jest
        .spyOn(reflector, 'getAllAndOverride')
        .mockReturnValueOnce(false)
        .mockReturnValueOnce([UserRole.ADMIN]);

      const context = createMockExecutionContext({
        userId: 'user-4',
        email: 'noRole@example.com',
        role: undefined,
      });
      const result = guard.canActivate(context);

      expect(result).toBe(false);
    });

    it('TENANT_ADMIN ãƒ­ãƒ¼ãƒ«ãŒè¦æ±‚ã•ã‚Œã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒ TENANT_ADMIN ã‚’æŒã£ã¦ã„ã‚‹å ´åˆã¯ true ã‚’è¿”ã™', () => {
      jest
        .spyOn(reflector, 'getAllAndOverride')
        .mockReturnValueOnce(false)
        .mockReturnValueOnce([UserRole.TENANT_ADMIN]);

      const context = createMockExecutionContext({
        userId: 'user-5',
        email: 'tenantadmin@example.com',
        role: UserRole.TENANT_ADMIN,
      });
      const result = guard.canActivate(context);

      expect(result).toBe(true);
    });
  });

  describe('ãƒ­ã‚°å‡ºåŠ›', () => {
    it('ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå­˜åœ¨ã—ãªã„å ´åˆã«ãƒ­ã‚°ã‚’å‡ºåŠ›ã™ã‚‹', () => {
      jest
        .spyOn(reflector, 'getAllAndOverride')
        .mockReturnValueOnce(false)
        .mockReturnValueOnce([UserRole.ADMIN]);

      const context = createMockExecutionContext(undefined);
      guard.canActivate(context);

      expect(loggerWarnSpy).toHaveBeenCalledWith(
        expect.objectContaining({
          message: 'ã‚¢ã‚¯ã‚»ã‚¹æ‹’å¦: ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“',
          reason: 'user_not_found',
        }),
      );
    });

    it('ãƒ­ãƒ¼ãƒ«ãŒä¸è¶³ã—ã¦ã„ã‚‹å ´åˆã«ãƒ­ã‚°ã‚’å‡ºåŠ›ã™ã‚‹', () => {
      jest
        .spyOn(reflector, 'getAllAndOverride')
        .mockReturnValueOnce(false)
        .mockReturnValueOnce([UserRole.ADMIN]);

      const context = createMockExecutionContext({
        userId: 'user-6',
        email: 'user@example.com',
        role: UserRole.USER,
      });
      guard.canActivate(context);

      expect(loggerWarnSpy).toHaveBeenCalledWith(
        expect.objectContaining({
          message: 'ã‚¢ã‚¯ã‚»ã‚¹æ‹’å¦: ãƒ­ãƒ¼ãƒ«ãŒä¸è¶³ã—ã¦ã„ã¾ã™',
          userId: 'user-6',
          userRole: UserRole.USER,
          reason: 'role_mismatch',
        }),
      );
    });

    it('ã‚¢ã‚¯ã‚»ã‚¹ãŒè¨±å¯ã•ã‚ŒãŸå ´åˆã¯ãƒ­ã‚°ã‚’å‡ºåŠ›ã—ãªã„', () => {
      jest
        .spyOn(reflector, 'getAllAndOverride')
        .mockReturnValueOnce(false)
        .mockReturnValueOnce([UserRole.ADMIN]);

      const context = createMockExecutionContext({
        userId: 'user-7',
        email: 'admin@example.com',
        role: UserRole.ADMIN,
      });
      guard.canActivate(context);

      expect(loggerWarnSpy).not.toHaveBeenCalled();
    });
  });
});
`````

## File: backend/src/auth/role.guard.ts
`````typescript
import { Injectable, CanActivate, ExecutionContext, Logger } from "@nestjs/common";
import { Reflector } from "@nestjs/core";

import { IS_PUBLIC_KEY } from "../common/decorators/public.decorator";

import type { UserRole, RequestUser } from "./auth.types";

@Injectable()
export class RoleGuard implements CanActivate {
  private readonly logger = new Logger(RoleGuard.name);

  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    // èªè¨¼ä¸è¦ãƒ«ãƒ¼ãƒˆã§ã¯ãƒ­ãƒ¼ãƒ«ãƒã‚§ãƒƒã‚¯ã‚‚ã—ãªã„ï¼ˆé–‹ç™ºç”¨ã®@Public()æƒ³å®šï¼‰
    if (isPublic) {
      return true;
    }

    const authDisabled =
      process.env.AUTH_DISABLED === 'YES' ||
      process.env.AUTH_DISABLED === 'true' ||
      process.env.AUTH_DISABLED === '1';

    // AUTH_DISABLED ã®é–‹ç™ºç’°å¢ƒã§ã¯ãƒ­ãƒ¼ãƒ«ãƒã‚§ãƒƒã‚¯ã‚’ã‚¹ã‚­ãƒƒãƒ—
    if (authDisabled) {
      return true;
    }

    const requiredRoles = this.reflector.getAllAndOverride<UserRole[]>('roles', [
      context.getHandler(),
      context.getClass(),
    ]);

    if (!requiredRoles) {
      return true;
    }

    const { user } = context.switchToHttp().getRequest<{ user?: RequestUser }>();
    
    if (!user) {
      this.logger.warn({
        message: 'ã‚¢ã‚¯ã‚»ã‚¹æ‹’å¦: ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“',
        requiredRoles,
        reason: 'user_not_found',
      });
      return false;
    }

    const hasRole = requiredRoles.includes(user.role as UserRole);

    if (!hasRole) {
      this.logger.warn({
        message: 'ã‚¢ã‚¯ã‚»ã‚¹æ‹’å¦: ãƒ­ãƒ¼ãƒ«ãŒä¸è¶³ã—ã¦ã„ã¾ã™',
        userId: user.userId,
        userRole: user.role,
        requiredRoles,
        reason: 'role_mismatch',
      });
      return false;
    }

    return true;
  }
}
`````

## File: backend/src/auth/roles.decorator.ts
`````typescript
import { SetMetadata } from '@nestjs/common';
import { UserRole } from '@prisma/client';

export const ROLES_KEY = 'roles';
export const Roles = (...roles: UserRole[]) => SetMetadata(ROLES_KEY, roles);
`````

## File: backend/src/breeding/dto/birth-plan.dto.ts
`````typescript
import { ApiProperty, ApiPropertyOptional } from "@nestjs/swagger";
import { BirthStatus } from "@prisma/client";
import { IsEnum, IsOptional, IsString, IsDateString, IsUUID, IsInt, Min } from "class-validator";

export class CreateBirthPlanDto {
  @ApiProperty({ description: "å‡ºç”£äºˆå®šã®æ¯è¦ªçŒ«ID" })
  @IsUUID()
  motherId: string;

  @ApiPropertyOptional({ description: "çˆ¶çŒ«ã®ID" })
  @IsOptional()
  @IsUUID()
  fatherId?: string;

  @ApiPropertyOptional({ description: "äº¤é…æ—¥" })
  @IsOptional()
  @IsDateString()
  matingDate?: string;

  @ApiProperty({ description: "å‡ºç”£äºˆå®šæ—¥" })
  @IsDateString()
  expectedBirthDate: string;

  @ApiPropertyOptional({ description: "å®Ÿéš›ã®å‡ºç”£æ—¥" })
  @IsOptional()
  @IsDateString()
  actualBirthDate?: string;

  @ApiProperty({ description: "å‡ºç”£çŠ¶æ…‹", enum: BirthStatus })
  @IsEnum(BirthStatus)
  status: BirthStatus;

  @ApiPropertyOptional({ description: "äºˆæƒ³ã•ã‚Œã‚‹å­çŒ«ã®æ•°" })
  @IsOptional()
  @IsInt()
  @Min(1)
  expectedKittens?: number;

  @ApiPropertyOptional({ description: "å®Ÿéš›ã®å­çŒ«ã®æ•°" })
  @IsOptional()
  @IsInt()
  @Min(0)
  actualKittens?: number;

  @ApiPropertyOptional({ description: "ãƒ¡ãƒ¢" })
  @IsOptional()
  @IsString()
  notes?: string;
}

export class UpdateBirthPlanDto {
  @ApiPropertyOptional({ description: "çˆ¶çŒ«ã®ID" })
  @IsOptional()
  @IsUUID()
  fatherId?: string;

  @ApiPropertyOptional({ description: "äº¤é…æ—¥" })
  @IsOptional()
  @IsDateString()
  matingDate?: string;

  @ApiPropertyOptional({ description: "å‡ºç”£äºˆå®šæ—¥" })
  @IsOptional()
  @IsDateString()
  expectedBirthDate?: string;

  @ApiPropertyOptional({ description: "å®Ÿéš›ã®å‡ºç”£æ—¥" })
  @IsOptional()
  @IsDateString()
  actualBirthDate?: string;

  @ApiPropertyOptional({ description: "å‡ºç”£çŠ¶æ…‹", enum: BirthStatus })
  @IsOptional()
  @IsEnum(BirthStatus)
  status?: BirthStatus;

  @ApiPropertyOptional({ description: "äºˆæƒ³ã•ã‚Œã‚‹å­çŒ«ã®æ•°" })
  @IsOptional()
  @IsInt()
  @Min(1)
  expectedKittens?: number;

  @ApiPropertyOptional({ description: "å®Ÿéš›ã®å­çŒ«ã®æ•°" })
  @IsOptional()
  @IsInt()
  @Min(0)
  actualKittens?: number;

  @ApiPropertyOptional({ description: "ãƒ¡ãƒ¢" })
  @IsOptional()
  @IsString()
  notes?: string;
}

export class BirthPlanQueryDto {
  @ApiPropertyOptional({ description: "æ¯è¦ªã®çŒ«ID" })
  @IsOptional()
  @IsUUID()
  motherId?: string;

  @ApiPropertyOptional({ description: "å‡ºç”£çŠ¶æ…‹", enum: BirthStatus })
  @IsOptional()
  @IsEnum(BirthStatus)
  status?: BirthStatus;

  @ApiPropertyOptional({ description: "ãƒšãƒ¼ã‚¸ç•ªå·", default: 1 })
  @IsOptional()
  @IsInt()
  @Min(1)
  page?: number = 1;

  @ApiPropertyOptional({ description: "1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•°", default: 20 })
  @IsOptional()
  @IsInt()
  @Min(1)
  limit?: number = 20;
}
`````

## File: backend/src/breeding/dto/breeding-query.dto.ts
`````typescript
import { ApiPropertyOptional } from "@nestjs/swagger";
import {
  IsDateString,
  IsIn,
  IsInt,
  IsOptional,
  IsPositive,
  IsUUID,
  Min,
} from "class-validator";

export class BreedingQueryDto {
  @ApiPropertyOptional({ example: 1 })
  @IsOptional()
  @IsInt()
  @Min(1)
  page?: number = 1;

  @ApiPropertyOptional({ example: 20 })
  @IsOptional()
  @IsInt()
  @IsPositive()
  limit?: number = 20;

  @ApiPropertyOptional({ description: "ãƒ¡ã‚¹çŒ«ID" })
  @IsOptional()
  @IsUUID()
  femaleId?: string;

  @ApiPropertyOptional({ description: "ã‚ªã‚¹çŒ«ID" })
  @IsOptional()
  @IsUUID()
  maleId?: string;

  @ApiPropertyOptional({ description: "é–‹å§‹æ—¥(YYYY-MM-DD)" })
  @IsOptional()
  @IsDateString()
  dateFrom?: string;

  @ApiPropertyOptional({ description: "çµ‚äº†æ—¥(YYYY-MM-DD)" })
  @IsOptional()
  @IsDateString()
  dateTo?: string;

  @ApiPropertyOptional({ example: "createdAt" })
  @IsOptional()
  sortBy?: string;

  @ApiPropertyOptional({ example: "desc", enum: ["asc", "desc"] })
  @IsOptional()
  @IsIn(["asc", "desc"])
  sortOrder?: "asc" | "desc";
}
`````

## File: backend/src/breeding/dto/breeding-schedule.dto.ts
`````typescript
/**
 * äº¤é…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ç”¨ DTO
 */
import { ApiProperty, ApiPropertyOptional, PartialType } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import {
  IsString,
  IsNotEmpty,
  IsDateString,
  IsInt,
  IsOptional,
  IsEnum,
  Min,
  Max,
  IsUUID,
} from 'class-validator';

// Prisma ã® enum ã¨åŒæœŸ
export enum BreedingScheduleStatus {
  SCHEDULED = 'SCHEDULED',
  IN_PROGRESS = 'IN_PROGRESS',
  COMPLETED = 'COMPLETED',
  CANCELLED = 'CANCELLED',
}

/**
 * äº¤é…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ä½œæˆ DTO
 */
export class CreateBreedingScheduleDto {
  @ApiProperty({ description: 'ã‚ªã‚¹çŒ«ID' })
  @IsString()
  @IsNotEmpty()
  @IsUUID()
  maleId: string;

  @ApiProperty({ description: 'ãƒ¡ã‚¹çŒ«ID' })
  @IsString()
  @IsNotEmpty()
  @IsUUID()
  femaleId: string;

  @ApiProperty({ description: 'é–‹å§‹æ—¥ (ISO8601)' })
  @IsDateString()
  startDate: string;

  @ApiProperty({ description: 'æœŸé–“ï¼ˆæ—¥æ•°ï¼‰', minimum: 1, maximum: 14 })
  @IsInt()
  @Min(1)
  @Max(14)
  duration: number;

  @ApiPropertyOptional({ description: 'ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹', enum: BreedingScheduleStatus })
  @IsOptional()
  @IsEnum(BreedingScheduleStatus)
  status?: BreedingScheduleStatus;

  @ApiPropertyOptional({ description: 'ãƒ¡ãƒ¢' })
  @IsOptional()
  @IsString()
  notes?: string;
}

/**
 * äº¤é…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«æ›´æ–° DTO
 */
export class UpdateBreedingScheduleDto extends PartialType(CreateBreedingScheduleDto) {}

/**
 * äº¤é…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¯ã‚¨ãƒª DTO
 */
export class BreedingScheduleQueryDto {
  @ApiPropertyOptional({ description: 'ãƒšãƒ¼ã‚¸ç•ªå·', default: 1 })
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  page?: number;

  @ApiPropertyOptional({ description: '1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•°', default: 50 })
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  @Max(100)
  limit?: number;

  @ApiPropertyOptional({ description: 'ã‚ªã‚¹çŒ«IDã§ãƒ•ã‚£ãƒ«ã‚¿' })
  @IsOptional()
  @IsString()
  maleId?: string;

  @ApiPropertyOptional({ description: 'ãƒ¡ã‚¹çŒ«IDã§ãƒ•ã‚£ãƒ«ã‚¿' })
  @IsOptional()
  @IsString()
  femaleId?: string;

  @ApiPropertyOptional({ description: 'ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã§ãƒ•ã‚£ãƒ«ã‚¿', enum: BreedingScheduleStatus })
  @IsOptional()
  @IsEnum(BreedingScheduleStatus)
  status?: BreedingScheduleStatus;

  @ApiPropertyOptional({ description: 'é–‹å§‹æ—¥ï¼ˆfromï¼‰' })
  @IsOptional()
  @IsDateString()
  dateFrom?: string;

  @ApiPropertyOptional({ description: 'é–‹å§‹æ—¥ï¼ˆtoï¼‰' })
  @IsOptional()
  @IsDateString()
  dateTo?: string;
}

/**
 * äº¤é…ãƒã‚§ãƒƒã‚¯ä½œæˆ DTO
 */
export class CreateMatingCheckDto {
  @ApiProperty({ description: 'ãƒã‚§ãƒƒã‚¯æ—¥ (ISO8601)' })
  @IsDateString()
  checkDate: string;

  @ApiPropertyOptional({ description: 'ãƒã‚§ãƒƒã‚¯å›æ•°', default: 1 })
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  count?: number;
}

/**
 * äº¤é…ãƒã‚§ãƒƒã‚¯æ›´æ–° DTO
 */
export class UpdateMatingCheckDto extends PartialType(CreateMatingCheckDto) {}
`````

## File: backend/src/breeding/dto/create-breeding-ng-rule.dto.ts
`````typescript
import { ApiProperty, ApiPropertyOptional } from "@nestjs/swagger";
import { BreedingNgRuleType } from "@prisma/client";
import {
  ArrayNotEmpty,
  IsArray,
  IsBoolean,
  IsEnum,
  IsInt,
  IsOptional,
  IsString,
  Min,
  ValidateIf,
} from "class-validator";

export class CreateBreedingNgRuleDto {
  @ApiProperty({ description: "ãƒ«ãƒ¼ãƒ«å", example: "è¿‘è¦ªäº¤é…é˜²æ­¢" })
  @IsString()
  name!: string;

  @ApiPropertyOptional({ description: "èª¬æ˜", example: "è¡€çµ±æ›¸ä»˜ãåŒå£«ã®äº¤é…ã‚’é¿ã‘ã‚‹" })
  @IsOptional()
  @IsString()
  description?: string;

  @ApiProperty({ enum: BreedingNgRuleType, example: BreedingNgRuleType.TAG_COMBINATION })
  @IsEnum(BreedingNgRuleType)
  type!: BreedingNgRuleType;

  @ApiPropertyOptional({ description: "æœ‰åŠ¹ãƒ•ãƒ©ã‚°", default: true })
  @IsOptional()
  @IsBoolean()
  active?: boolean;

  @ApiPropertyOptional({ description: "ã‚ªã‚¹å´ã®ã‚¿ã‚°æ¡ä»¶", type: [String] })
  @ValidateIf((dto: CreateBreedingNgRuleDto) => dto.type === BreedingNgRuleType.TAG_COMBINATION)
  @IsArray()
  @ArrayNotEmpty()
  @IsString({ each: true })
  maleConditions?: string[];

  @ApiPropertyOptional({ description: "ãƒ¡ã‚¹å´ã®ã‚¿ã‚°æ¡ä»¶", type: [String] })
  @ValidateIf((dto: CreateBreedingNgRuleDto) => dto.type === BreedingNgRuleType.TAG_COMBINATION)
  @IsArray()
  @ArrayNotEmpty()
  @IsString({ each: true })
  femaleConditions?: string[];

  @ApiPropertyOptional({ description: "ç¦æ­¢ã™ã‚‹ã‚ªã‚¹çŒ«ã®åå‰", type: [String] })
  @ValidateIf((dto: CreateBreedingNgRuleDto) => dto.type === BreedingNgRuleType.INDIVIDUAL_PROHIBITION)
  @IsArray()
  @ArrayNotEmpty()
  @IsString({ each: true })
  maleNames?: string[];

  @ApiPropertyOptional({ description: "ç¦æ­¢ã™ã‚‹ãƒ¡ã‚¹çŒ«ã®åå‰", type: [String] })
  @ValidateIf((dto: CreateBreedingNgRuleDto) => dto.type === BreedingNgRuleType.INDIVIDUAL_PROHIBITION)
  @IsArray()
  @ArrayNotEmpty()
  @IsString({ each: true })
  femaleNames?: string[];

  @ApiPropertyOptional({ description: "ä¸–ä»£åˆ¶é™ (è¦ªç­‰)", minimum: 1 })
  @ValidateIf((dto: CreateBreedingNgRuleDto) => dto.type === BreedingNgRuleType.GENERATION_LIMIT)
  @IsOptional()
  @IsInt()
  @Min(1)
  generationLimit?: number;
}
`````

## File: backend/src/breeding/dto/create-breeding.dto.ts
`````typescript
import { ApiProperty, ApiPropertyOptional } from "@nestjs/swagger";
import {
  IsDateString,
  IsOptional,
  IsString,
  IsUUID,
} from "class-validator";

export class CreateBreedingDto {
  @ApiProperty({
    description: "ãƒ¡ã‚¹çŒ«ã®ID",
    example: "11111111-1111-1111-1111-111111111111",
  })
  @IsUUID()
  femaleId: string;

  @ApiProperty({
    description: "ã‚ªã‚¹çŒ«ã®ID",
    example: "22222222-2222-2222-2222-222222222222",
  })
  @IsUUID()
  maleId: string;

  @ApiProperty({ description: "äº¤é…æ—¥", example: "2025-08-01" })
  @IsDateString()
  breedingDate: string;

  @ApiPropertyOptional({
    description: "å‡ºç”£äºˆå®šæ—¥ (YYYY-MM-DD)",
    example: "2025-10-01",
  })
  @IsOptional()
  @IsDateString()
  expectedDueDate?: string;

  @ApiPropertyOptional({ description: "ãƒ¡ãƒ¢", example: "åˆå›ã®äº¤é…ã€‚" })
  @IsOptional()
  @IsString()
  notes?: string;
}
`````

## File: backend/src/breeding/dto/index.ts
`````typescript
export * from "./create-breeding.dto";
export * from "./update-breeding.dto";
export * from "./breeding-query.dto";
export * from "./create-breeding-ng-rule.dto";
export * from "./update-breeding-ng-rule.dto";
export * from "./pregnancy-check.dto";
export * from "./birth-plan.dto";
export * from "./kitten-disposition.dto";
export * from "./breeding-schedule.dto";
`````

## File: backend/src/breeding/dto/kitten-disposition.dto.ts
`````typescript
import { ApiProperty, ApiPropertyOptional } from "@nestjs/swagger";
import { DispositionType } from "@prisma/client";
import { Type } from "class-transformer";
import { IsEnum, IsOptional, IsString, IsUUID, IsDateString, IsObject, ValidateNested, IsNumber } from "class-validator";

class SaleInfoDto {
  @ApiProperty({ description: "è­²æ¸¡å…ˆï¼ˆå€‹äººå/æ¥­è€…åï¼‰" })
  @IsString()
  buyer: string;

  @ApiProperty({ description: "è­²æ¸¡é‡‘é¡" })
  @IsNumber()
  price: number;

  @ApiProperty({ description: "è­²æ¸¡æ—¥" })
  @IsDateString()
  saleDate: string;

  @ApiPropertyOptional({ description: "ãƒ¡ãƒ¢" })
  @IsOptional()
  @IsString()
  notes?: string;
}

export class CreateKittenDispositionDto {
  @ApiProperty({ description: "å‡ºç”£è¨˜éŒ²ID" })
  @IsUUID()
  birthRecordId: string;

  @ApiPropertyOptional({ description: "å­çŒ«IDï¼ˆé¤Šæˆã®å ´åˆã®ã¿ï¼‰" })
  @IsOptional()
  @IsUUID()
  kittenId?: string;

  @ApiProperty({ description: "å­çŒ«å" })
  @IsString()
  name: string;

  @ApiProperty({ description: "æ€§åˆ¥" })
  @IsString()
  gender: string;

  @ApiProperty({ description: "å‡¦é‡ã‚¿ã‚¤ãƒ—", enum: DispositionType })
  @IsEnum(DispositionType)
  disposition: DispositionType;

  @ApiPropertyOptional({ description: "é¤Šæˆé–‹å§‹æ—¥ï¼ˆé¤Šæˆã®å ´åˆï¼‰" })
  @IsOptional()
  @IsDateString()
  trainingStartDate?: string;

  @ApiPropertyOptional({ description: "è­²æ¸¡æƒ…å ±ï¼ˆå‡ºè·ã®å ´åˆï¼‰" })
  @IsOptional()
  @IsObject()
  @ValidateNested()
  @Type(() => SaleInfoDto)
  saleInfo?: SaleInfoDto;

  @ApiPropertyOptional({ description: "æ­»äº¡æ—¥ï¼ˆæ­»äº¡ã®å ´åˆï¼‰" })
  @IsOptional()
  @IsDateString()
  deathDate?: string;

  @ApiPropertyOptional({ description: "æ­»äº¡ç†ç”±ï¼ˆæ­»äº¡ã®å ´åˆï¼‰" })
  @IsOptional()
  @IsString()
  deathReason?: string;

  @ApiPropertyOptional({ description: "ãƒ¡ãƒ¢" })
  @IsOptional()
  @IsString()
  notes?: string;
}

export class UpdateKittenDispositionDto {
  @ApiPropertyOptional({ description: "å­çŒ«IDï¼ˆé¤Šæˆã®å ´åˆã®ã¿ï¼‰" })
  @IsOptional()
  @IsUUID()
  kittenId?: string;

  @ApiPropertyOptional({ description: "å­çŒ«å" })
  @IsOptional()
  @IsString()
  name?: string;

  @ApiPropertyOptional({ description: "æ€§åˆ¥" })
  @IsOptional()
  @IsString()
  gender?: string;

  @ApiPropertyOptional({ description: "å‡¦é‡ã‚¿ã‚¤ãƒ—" })
  @IsOptional()
  @IsEnum(DispositionType)
  disposition?: DispositionType;

  @ApiPropertyOptional({ description: "é¤Šæˆé–‹å§‹æ—¥ï¼ˆé¤Šæˆã®å ´åˆï¼‰" })
  @IsOptional()
  @IsDateString()
  trainingStartDate?: string;

  @ApiPropertyOptional({ description: "è­²æ¸¡æƒ…å ±ï¼ˆå‡ºè·ã®å ´åˆï¼‰" })
  @IsOptional()
  @IsObject()
  @ValidateNested()
  @Type(() => SaleInfoDto)
  saleInfo?: SaleInfoDto;

  @ApiPropertyOptional({ description: "æ­»äº¡æ—¥ï¼ˆæ­»äº¡ã®å ´åˆï¼‰" })
  @IsOptional()
  @IsDateString()
  deathDate?: string;

  @ApiPropertyOptional({ description: "æ­»äº¡ç†ç”±ï¼ˆæ­»äº¡ã®å ´åˆï¼‰" })
  @IsOptional()
  @IsString()
  deathReason?: string;

  @ApiPropertyOptional({ description: "ãƒ¡ãƒ¢" })
  @IsOptional()
  @IsString()
  notes?: string;
}
`````

## File: backend/src/breeding/dto/pregnancy-check.dto.ts
`````typescript
import { ApiProperty, ApiPropertyOptional } from "@nestjs/swagger";
import { PregnancyStatus } from "@prisma/client";
import { IsEnum, IsOptional, IsString, IsDateString, IsUUID, IsInt, Min } from "class-validator";

export class CreatePregnancyCheckDto {
  @ApiProperty({ description: "å¦Šå¨ ãƒã‚§ãƒƒã‚¯å¯¾è±¡ã®çŒ«ID" })
  @IsUUID()
  motherId: string;

  @ApiPropertyOptional({ description: "çˆ¶çŒ«ã®ID" })
  @IsOptional()
  @IsUUID()
  fatherId?: string;

  @ApiPropertyOptional({ description: "äº¤é…æ—¥" })
  @IsOptional()
  @IsDateString()
  matingDate?: string;

  @ApiProperty({ description: "å¦Šå¨ ãƒã‚§ãƒƒã‚¯æ—¥" })
  @IsDateString()
  checkDate: string;

  @ApiProperty({ description: "å¦Šå¨ çŠ¶æ…‹", enum: PregnancyStatus })
  @IsEnum(PregnancyStatus)
  status: PregnancyStatus;

  @ApiPropertyOptional({ description: "ãƒ¡ãƒ¢" })
  @IsOptional()
  @IsString()
  notes?: string;
}

export class UpdatePregnancyCheckDto {
  @ApiPropertyOptional({ description: "çˆ¶çŒ«ã®ID" })
  @IsOptional()
  @IsUUID()
  fatherId?: string;

  @ApiPropertyOptional({ description: "äº¤é…æ—¥" })
  @IsOptional()
  @IsDateString()
  matingDate?: string;

  @ApiPropertyOptional({ description: "å¦Šå¨ ãƒã‚§ãƒƒã‚¯æ—¥" })
  @IsOptional()
  @IsDateString()
  checkDate?: string;

  @ApiPropertyOptional({ description: "å¦Šå¨ çŠ¶æ…‹", enum: PregnancyStatus })
  @IsOptional()
  @IsEnum(PregnancyStatus)
  status?: PregnancyStatus;

  @ApiPropertyOptional({ description: "ãƒ¡ãƒ¢" })
  @IsOptional()
  @IsString()
  notes?: string;
}

export class PregnancyCheckQueryDto {
  @ApiPropertyOptional({ description: "æ¯è¦ªã®çŒ«ID" })
  @IsOptional()
  @IsUUID()
  motherId?: string;

  @ApiPropertyOptional({ description: "å¦Šå¨ çŠ¶æ…‹", enum: PregnancyStatus })
  @IsOptional()
  @IsEnum(PregnancyStatus)
  status?: PregnancyStatus;

  @ApiPropertyOptional({ description: "ãƒšãƒ¼ã‚¸ç•ªå·", default: 1 })
  @IsOptional()
  @IsInt()
  @Min(1)
  page?: number = 1;

  @ApiPropertyOptional({ description: "1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•°", default: 20 })
  @IsOptional()
  @IsInt()
  @Min(1)
  limit?: number = 20;
}
`````

## File: backend/src/breeding/dto/update-breeding-ng-rule.dto.ts
`````typescript
import { PartialType } from "@nestjs/mapped-types";

import { CreateBreedingNgRuleDto } from "./create-breeding-ng-rule.dto";

export class UpdateBreedingNgRuleDto extends PartialType(CreateBreedingNgRuleDto) {}
`````

## File: backend/src/breeding/dto/update-breeding.dto.ts
`````typescript
import { PartialType } from "@nestjs/mapped-types";

import { CreateBreedingDto } from "./create-breeding.dto";

export class UpdateBreedingDto extends PartialType(CreateBreedingDto) {}
`````

## File: backend/src/breeding/types/breeding.types.ts
`````typescript
// Define enums locally
export type BreedingNgRuleType = 'TAG_COMBINATION' | 'INDIVIDUAL_PROHIBITION' | 'GENERATION_LIMIT';
export type PregnancyStatus = 'CONFIRMED' | 'SUSPECTED' | 'NEGATIVE' | 'ABORTED';
export type BirthStatus = 'EXPECTED' | 'BORN' | 'ABORTED' | 'STILLBORN';

export interface BreedingWhereInput {
  femaleId?: string;
  maleId?: string;
  breedingDate?: {
    gte?: Date;
    lte?: Date;
  };
}

// Type for the Prisma select operations
export type BreedingRecordWithRelations = {
  id: string;
  maleId: string;
  femaleId: string;
  breedingDate: Date;
  expectedDueDate: Date | null;
  actualDueDate: Date | null;
  numberOfKittens: number | null;
  notes: string | null;
  status: string;
  recordedBy: string;
  createdAt: Date;
  updatedAt: Date;
  male: { id: string; name: string | null } | null;
  female: { id: string; name: string | null } | null;
};

// Type for the Cat with gender property for validation
export interface CatWithGender {
  id: string;
  gender: string;
}

// API Response types
export interface BreedingListResponse {
  success: true;
  data: BreedingRecordWithRelations[];
  meta: {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
  };
}

export interface BreedingCreateResponse {
  success: true;
  data: BreedingRecordWithRelations;
}

export interface BreedingSuccessResponse {
  success: true;
}

export interface BreedingNgRule {
  id: string;
  name: string;
  description: string | null;
  type: BreedingNgRuleType;
  maleConditions: string[];
  femaleConditions: string[];
  maleNames: string[];
  femaleNames: string[];
  generationLimit: number | null;
  active: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export interface BreedingNgRuleListResponse {
  success: true;
  data: BreedingNgRule[];
}

export interface BreedingNgRuleResponse {
  success: true;
  data: BreedingNgRule;
}

// Pregnancy Check types
export type PregnancyCheckWithRelations = {
  id: string;
  motherId: string;
  checkDate: Date;
  status: PregnancyStatus;
  notes: string | null;
  createdAt: Date;
  updatedAt: Date;
  mother: { id: string; name: string | null } | null;
};

export interface PregnancyCheckListResponse {
  success: true;
  data: PregnancyCheckWithRelations[];
  meta: {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
  };
}

export interface PregnancyCheckResponse {
  success: true;
  data: PregnancyCheckWithRelations;
}

// Birth Plan types
export type BirthPlanWithRelations = {
  id: string;
  motherId: string;
  expectedBirthDate: Date;
  actualBirthDate: Date | null;
  status: BirthStatus;
  expectedKittens: number | null;
  actualKittens: number | null;
  notes: string | null;
  createdAt: Date;
  updatedAt: Date;
  mother: { id: string; name: string | null } | null;
};

export interface BirthPlanListResponse {
  success: true;
  data: BirthPlanWithRelations[];
  meta: {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
  };
}

export interface BirthPlanResponse {
  success: true;
  data: BirthPlanWithRelations;
}

// Breeding Schedule types
export type BreedingScheduleStatus = 'SCHEDULED' | 'IN_PROGRESS' | 'COMPLETED' | 'CANCELLED';

export type BreedingScheduleWithRelations = {
  id: string;
  maleId: string;
  femaleId: string;
  startDate: Date;
  duration: number;
  status: BreedingScheduleStatus;
  notes: string | null;
  recordedBy: string;
  createdAt: Date;
  updatedAt: Date;
  male: { id: string; name: string | null } | null;
  female: { id: string; name: string | null } | null;
  checks?: MatingCheckType[];
};

export type MatingCheckType = {
  id: string;
  scheduleId: string;
  checkDate: Date;
  count: number;
  createdAt: Date;
};

export interface BreedingScheduleListResponse {
  success: true;
  data: BreedingScheduleWithRelations[];
  meta: {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
  };
}

export interface BreedingScheduleResponse {
  success: true;
  data: BreedingScheduleWithRelations;
}

export interface MatingCheckResponse {
  success: true;
  data: MatingCheckType;
}
`````

## File: backend/src/breeding/breeding.controller.spec.ts
`````typescript
import { Test, TestingModule } from '@nestjs/testing';

import { getTestModuleImports, getTestModuleProviders } from '../test-utils/test-module-setup';

import { BreedingController } from './breeding.controller';
import { BreedingService } from './breeding.service';

describe('BreedingController', () => {
  let controller: BreedingController;
  let service: BreedingService;

  const mockBreedingService = {
    create: jest.fn(),
    findAll: jest.fn(),
    update: jest.fn(),
    remove: jest.fn(),
    findNgRules: jest.fn(),
    createNgRule: jest.fn(),
    updateNgRule: jest.fn(),
    removeNgRule: jest.fn(),
    findAllPregnancyChecks: jest.fn(),
    createPregnancyCheck: jest.fn(),
    updatePregnancyCheck: jest.fn(),
    removePregnancyCheck: jest.fn(),
    findAllBirthPlans: jest.fn(),
    createBirthPlan: jest.fn(),
    updateBirthPlan: jest.fn(),
    removeBirthPlan: jest.fn(),
    findAllKittenDispositions: jest.fn(),
    createKittenDisposition: jest.fn(),
    updateKittenDisposition: jest.fn(),
    removeKittenDisposition: jest.fn(),
    completeBirthRecord: jest.fn(),
    findAllBreedingSchedules: jest.fn(),
    createBreedingSchedule: jest.fn(),
    updateBreedingSchedule: jest.fn(),
    removeBreedingSchedule: jest.fn(),
    findMatingChecksBySchedule: jest.fn(),
    createMatingCheck: jest.fn(),
    updateMatingCheck: jest.fn(),
    removeMatingCheck: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      imports: getTestModuleImports(),
      controllers: [BreedingController],
      providers: [
        ...getTestModuleProviders(),
        {
          provide: BreedingService,
          useValue: mockBreedingService,
        },
      ],
    }).compile();

    controller = module.get<BreedingController>(BreedingController);
    service = module.get<BreedingService>(BreedingService);

    jest.clearAllMocks();
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });

  describe('create', () => {
    it('should create a breeding record', async () => {
      const createDto = {
        femaleId: 'mother-1',
        maleId: 'father-1',
        breedingDate: '2024-01-15',
      };
      const mockBreeding = { id: '1', ...createDto };

      mockBreedingService.create.mockResolvedValue(mockBreeding);

      const result = await controller.create(createDto, undefined);

      expect(result).toEqual(mockBreeding);
      expect(service.create).toHaveBeenCalledWith(createDto, undefined);
    });
  });

  describe('findAll', () => {
    it('should return paginated breeding records', async () => {
      const mockResponse = {
        data: [{ id: '1', fatherId: 'father-1' }],
        meta: { page: 1, limit: 10, total: 1, totalPages: 1 },
      };

      mockBreedingService.findAll.mockResolvedValue(mockResponse);

      const result = await controller.findAll({});

      expect(result).toEqual(mockResponse);
      expect(service.findAll).toHaveBeenCalledWith({});
    });
  });


});
`````

## File: backend/src/breeding/breeding.controller.ts
`````typescript
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  HttpStatus, UseGuards 
} from "@nestjs/common";
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiParam,
  ApiBearerAuth,
} from "@nestjs/swagger";

import type { RequestUser } from "../auth/auth.types";
import { GetUser } from "../auth/get-user.decorator";
import { JwtAuthGuard } from "../auth/jwt-auth.guard";


import { BreedingService } from "./breeding.service";
import {
  BreedingQueryDto,
  CreateBreedingDto,
  // UpdateBreedingDto, // Unused - keeping import for future use
  CreateBreedingNgRuleDto,
  UpdateBreedingNgRuleDto,
  CreatePregnancyCheckDto,
  UpdatePregnancyCheckDto,
  PregnancyCheckQueryDto,
  CreateBirthPlanDto,
  UpdateBirthPlanDto,
  BirthPlanQueryDto,
  CreateBreedingScheduleDto,
  UpdateBreedingScheduleDto,
  BreedingScheduleQueryDto,
  CreateMatingCheckDto,
  UpdateMatingCheckDto,
} from "./dto";
import { CreateKittenDispositionDto, UpdateKittenDispositionDto } from "./dto/kitten-disposition.dto";

@ApiTags("Breeding")
@Controller("breeding")
export class BreedingController {
  constructor(private readonly breedingService: BreedingService) {}

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Get()
  @ApiOperation({ summary: "äº¤é…è¨˜éŒ²ä¸€è¦§ã®å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK })
  findAll(@Query() query: BreedingQueryDto) {
    return this.breedingService.findAll(query);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Post()
  @ApiOperation({ summary: "äº¤é…è¨˜éŒ²ã®æ–°è¦ä½œæˆ" })
  @ApiResponse({ status: HttpStatus.CREATED })
  create(
    @Body() dto: CreateBreedingDto,
    @GetUser() user?: RequestUser,
  ) {
    return this.breedingService.create(dto, user?.userId);
  }

  // NOTE: parameterized routes for the main breeding resource are defined
  // later in the file so that static subpaths (e.g. "pregnancy-checks",
  // "birth-plans") are registered first. This prevents Express from
  // matching those static paths as an ":id" and returning 404.

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Get("ng-rules")
  @ApiOperation({ summary: "NGãƒšã‚¢ãƒ«ãƒ¼ãƒ«ä¸€è¦§ã®å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK })
  findNgRules() {
    return this.breedingService.findNgRules();
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Post("ng-rules")
  @ApiOperation({ summary: "NGãƒšã‚¢ãƒ«ãƒ¼ãƒ«ã®ä½œæˆ" })
  @ApiResponse({ status: HttpStatus.CREATED })
  createNgRule(@Body() dto: CreateBreedingNgRuleDto) {
    return this.breedingService.createNgRule(dto);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Patch("ng-rules/:id")
  @ApiOperation({ summary: "NGãƒšã‚¢ãƒ«ãƒ¼ãƒ«ã®æ›´æ–°" })
  @ApiResponse({ status: HttpStatus.OK })
  @ApiParam({ name: "id" })
  updateNgRule(@Param("id") id: string, @Body() dto: UpdateBreedingNgRuleDto) {
    return this.breedingService.updateNgRule(id, dto);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Delete("ng-rules/:id")
  @ApiOperation({ summary: "NGãƒšã‚¢ãƒ«ãƒ¼ãƒ«ã®å‰Šé™¤" })
  @ApiResponse({ status: HttpStatus.OK })
  @ApiParam({ name: "id" })
  removeNgRule(@Param("id") id: string) {
    return this.breedingService.removeNgRule(id);
  }

  // Pregnancy Check endpoints
  @Get("test")
  @ApiOperation({ summary: "ãƒ†ã‚¹ãƒˆ" })
  @ApiResponse({ status: HttpStatus.OK })
  test() {
    return { message: "test" };
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Get("pregnancy-checks")
  @ApiOperation({ summary: "å¦Šå¨ ãƒã‚§ãƒƒã‚¯ä¸€è¦§ã®å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK })
  findAllPregnancyChecks(@Query() query: PregnancyCheckQueryDto) {
    return this.breedingService.findAllPregnancyChecks(query);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Post("pregnancy-checks")
  @ApiOperation({ summary: "å¦Šå¨ ãƒã‚§ãƒƒã‚¯ã®æ–°è¦ä½œæˆ" })
  @ApiResponse({ status: HttpStatus.CREATED })
  createPregnancyCheck(
    @Body() dto: CreatePregnancyCheckDto,
    @GetUser() user?: RequestUser,
  ) {
    console.log('[DEBUG] createPregnancyCheck - Received DTO:', JSON.stringify(dto, null, 2));
    console.log('[DEBUG] motherId type:', typeof dto.motherId, 'value:', dto.motherId);
    console.log('[DEBUG] fatherId type:', typeof dto.fatherId, 'value:', dto.fatherId);
    return this.breedingService.createPregnancyCheck(dto, user?.userId);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Patch("pregnancy-checks/:id")
  @ApiOperation({ summary: "å¦Šå¨ ãƒã‚§ãƒƒã‚¯ã®æ›´æ–°" })
  @ApiResponse({ status: HttpStatus.OK })
  @ApiParam({ name: "id" })
  updatePregnancyCheck(@Param("id") id: string, @Body() dto: UpdatePregnancyCheckDto) {
    return this.breedingService.updatePregnancyCheck(id, dto);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Delete("pregnancy-checks/:id")
  @ApiOperation({ summary: "å¦Šå¨ ãƒã‚§ãƒƒã‚¯ã®å‰Šé™¤" })
  @ApiResponse({ status: HttpStatus.OK })
  @ApiParam({ name: "id" })
  removePregnancyCheck(@Param("id") id: string) {
    return this.breedingService.removePregnancyCheck(id);
  }

  // Birth Plan endpoints
  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Get("birth-plans")
  @ApiOperation({ summary: "å‡ºç”£è¨ˆç”»ä¸€è¦§ã®å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK })
  findAllBirthPlans(@Query() query: BirthPlanQueryDto) {
    return this.breedingService.findAllBirthPlans(query);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Post("birth-plans")
  @ApiOperation({ summary: "å‡ºç”£è¨ˆç”»ã®æ–°è¦ä½œæˆ" })
  @ApiResponse({ status: HttpStatus.CREATED })
  createBirthPlan(
    @Body() dto: CreateBirthPlanDto,
    @GetUser() user?: RequestUser,
  ) {
    return this.breedingService.createBirthPlan(dto, user?.userId);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Patch("birth-plans/:id")
  @ApiOperation({ summary: "å‡ºç”£è¨ˆç”»ã®æ›´æ–°" })
  @ApiResponse({ status: HttpStatus.OK })
  @ApiParam({ name: "id" })
  updateBirthPlan(@Param("id") id: string, @Body() dto: UpdateBirthPlanDto) {
    return this.breedingService.updateBirthPlan(id, dto);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Delete("birth-plans/:id")
  @ApiOperation({ summary: "å‡ºç”£è¨ˆç”»ã®å‰Šé™¤" })
  @ApiResponse({ status: HttpStatus.OK })
  @ApiParam({ name: "id" })
  removeBirthPlan(@Param("id") id: string) {
    return this.breedingService.removeBirthPlan(id);
  }

  // ========== Kitten Disposition Endpoints ==========

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Get("kitten-dispositions/:birthRecordId")
  @ApiOperation({ summary: "å‡ºç”£è¨˜éŒ²ã®å­çŒ«å‡¦é‡ä¸€è¦§å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK })
  @ApiParam({ name: "birthRecordId" })
  findAllKittenDispositions(@Param("birthRecordId") birthRecordId: string) {
    return this.breedingService.findAllKittenDispositions(birthRecordId);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Post("kitten-dispositions")
  @ApiOperation({ summary: "å­çŒ«å‡¦é‡ã®ç™»éŒ²" })
  @ApiResponse({ status: HttpStatus.CREATED })
  createKittenDisposition(
    @Body() dto: CreateKittenDispositionDto,
    @GetUser() user?: RequestUser,
  ) {
    return this.breedingService.createKittenDisposition(dto, user?.userId);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Patch("kitten-dispositions/:id")
  @ApiOperation({ summary: "å­çŒ«å‡¦é‡ã®æ›´æ–°" })
  @ApiResponse({ status: HttpStatus.OK })
  @ApiParam({ name: "id" })
  updateKittenDisposition(@Param("id") id: string, @Body() dto: UpdateKittenDispositionDto) {
    return this.breedingService.updateKittenDisposition(id, dto);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Delete("kitten-dispositions/:id")
  @ApiOperation({ summary: "å­çŒ«å‡¦é‡ã®å‰Šé™¤" })
  @ApiResponse({ status: HttpStatus.OK })
  @ApiParam({ name: "id" })
  removeKittenDisposition(@Param("id") id: string) {
    return this.breedingService.removeKittenDisposition(id);
  }

  @Post("birth-plans/:id/complete")
  @ApiOperation({ summary: "å‡ºç”£è¨˜éŒ²ã®å®Œäº†" })
  @ApiResponse({ status: HttpStatus.OK })
  @ApiParam({ name: "id" })
  completeBirthRecord(@Param("id") id: string) {
    return this.breedingService.completeBirthRecord(id);
  }

  // ========== Breeding Schedule Endpoints ==========

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Get("schedules")
  @ApiOperation({ summary: "äº¤é…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ä¸€è¦§ã®å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK })
  findAllBreedingSchedules(@Query() query: BreedingScheduleQueryDto) {
    return this.breedingService.findAllBreedingSchedules(query);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Post("schedules")
  @ApiOperation({ summary: "äº¤é…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä½œæˆ" })
  @ApiResponse({ status: HttpStatus.CREATED })
  createBreedingSchedule(
    @Body() dto: CreateBreedingScheduleDto,
    @GetUser() user?: RequestUser,
  ) {
    return this.breedingService.createBreedingSchedule(dto, user?.userId);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Patch("schedules/:id")
  @ApiOperation({ summary: "äº¤é…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æ›´æ–°" })
  @ApiResponse({ status: HttpStatus.OK })
  @ApiParam({ name: "id" })
  updateBreedingSchedule(@Param("id") id: string, @Body() dto: UpdateBreedingScheduleDto) {
    return this.breedingService.updateBreedingSchedule(id, dto);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Delete("schedules/:id")
  @ApiOperation({ summary: "äº¤é…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å‰Šé™¤" })
  @ApiResponse({ status: HttpStatus.OK })
  @ApiParam({ name: "id" })
  removeBreedingSchedule(@Param("id") id: string) {
    return this.breedingService.removeBreedingSchedule(id);
  }

  // ========== Mating Check Endpoints ==========

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Get("schedules/:scheduleId/checks")
  @ApiOperation({ summary: "äº¤é…ãƒã‚§ãƒƒã‚¯ä¸€è¦§ã®å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK })
  @ApiParam({ name: "scheduleId" })
  findMatingChecks(@Param("scheduleId") scheduleId: string) {
    return this.breedingService.findMatingChecksBySchedule(scheduleId);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Post("schedules/:scheduleId/checks")
  @ApiOperation({ summary: "äº¤é…ãƒã‚§ãƒƒã‚¯ã®è¿½åŠ " })
  @ApiResponse({ status: HttpStatus.CREATED })
  @ApiParam({ name: "scheduleId" })
  createMatingCheck(
    @Param("scheduleId") scheduleId: string,
    @Body() dto: CreateMatingCheckDto,
  ) {
    return this.breedingService.createMatingCheck(scheduleId, dto);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Patch("mating-checks/:id")
  @ApiOperation({ summary: "äº¤é…ãƒã‚§ãƒƒã‚¯ã®æ›´æ–°" })
  @ApiResponse({ status: HttpStatus.OK })
  @ApiParam({ name: "id" })
  updateMatingCheck(@Param("id") id: string, @Body() dto: UpdateMatingCheckDto) {
    return this.breedingService.updateMatingCheck(id, dto);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Delete("mating-checks/:id")
  @ApiOperation({ summary: "äº¤é…ãƒã‚§ãƒƒã‚¯ã®å‰Šé™¤" })
  @ApiResponse({ status: HttpStatus.OK })
  @ApiParam({ name: "id" })
  removeMatingCheck(@Param("id") id: string) {
    return this.breedingService.removeMatingCheck(id);
  }

  // Parameterized routes for the main breeding resource.
  // These are intentionally placed after static subpaths such as
  // "pregnancy-checks" and "birth-plans" so that Express does not
  // interpret those paths as an ":id" and cause 404s.
  // @ApiBearerAuth()
  // @UseGuards(JwtAuthGuard)
  // @Patch(":id")
  // @ApiOperation({ summary: "äº¤é…è¨˜éŒ²ã®æ›´æ–°" })
  // @ApiResponse({ status: HttpStatus.OK })
  // @ApiParam({ name: "id" })
  // update(@Param("id") id: string, @Body() dto: UpdateBreedingDto) {
  //   return this.breedingService.update(id, dto);
  // }

  // @ApiBearerAuth()
  // @UseGuards(JwtAuthGuard)
  // @Delete(":id")
  // @ApiOperation({ summary: "äº¤é…è¨˜éŒ²ã®å‰Šé™¤" })
  // @ApiResponse({ status: HttpStatus.OK })
  // @ApiParam({ name: "id" })
  // remove(@Param("id") id: string) {
  //   return this.breedingService.remove(id);
  // }
}
`````

## File: backend/src/breeding/breeding.module.ts
`````typescript
import { Module } from "@nestjs/common";

import { PrismaModule } from "../prisma/prisma.module";

import { BreedingController } from "./breeding.controller";
import { BreedingService } from "./breeding.service";

@Module({
  imports: [PrismaModule],
  controllers: [BreedingController],
  providers: [BreedingService],
})
export class BreedingModule {}
`````

## File: backend/src/breeding/breeding.service.spec.ts
`````typescript
import { NotFoundException } from '@nestjs/common';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { Test, TestingModule } from '@nestjs/testing';

import { PrismaService } from '../prisma/prisma.service';

import { BreedingService } from './breeding.service';



describe('BreedingService', () => {
  let service: BreedingService;
  let _prismaService: PrismaService;

  const mockPrismaService = {
    breeding: {
      create: jest.fn(),
      findMany: jest.fn(),
      findUnique: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
      count: jest.fn(),
    },
    breedingRecord: {
      create: jest.fn(),
      findMany: jest.fn(),
      findUnique: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
      count: jest.fn(),
    },
    cat: {
      findUnique: jest.fn(),
      findMany: jest.fn(),
    },
    breedingNgRule: {
      create: jest.fn(),
      findMany: jest.fn(),
      delete: jest.fn(),
    },
    user: {
      findFirst: jest.fn(),
    },
    $transaction: jest.fn((args) => Promise.all(args)),
  };

  const mockEventEmitter = {
    emit: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        BreedingService,
        {
          provide: PrismaService,
          useValue: mockPrismaService,
        },
        {
          provide: EventEmitter2,
          useValue: mockEventEmitter,
        },
      ],
    }).compile();

    service = module.get<BreedingService>(BreedingService);
    _prismaService = module.get<PrismaService>(PrismaService);

    jest.clearAllMocks();
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('create', () => {
    it('should create a breeding record successfully', async () => {
      const createDto = {
        femaleId: 'mother-1',
        maleId: 'father-1',
        breedingDate: '2024-01-15',
      };

      const mockFather = { id: 'father-1', gender: 'MALE' };
      const mockMother = { id: 'mother-1', gender: 'FEMALE' };
      const mockBreeding = {
        id: '1',
        femaleId: createDto.femaleId,
        maleId: createDto.maleId,
        breedingDate: new Date(createDto.breedingDate),
      };

      mockPrismaService.cat.findUnique
        .mockResolvedValueOnce(mockMother) // First call for female
        .mockResolvedValueOnce(mockFather); // Second call for male
      mockPrismaService.breedingNgRule.findMany.mockResolvedValue([]);
      mockPrismaService.user.findFirst.mockResolvedValue({ id: 'user-1', email: 'test@test.com' });
      mockPrismaService.breedingRecord.create.mockResolvedValue(mockBreeding);

      const result = await service.create(createDto);

      expect(result.success).toBe(true);
      expect(result.data).toEqual(mockBreeding);
      expect(mockPrismaService.breedingRecord.create).toHaveBeenCalled();
    });

    it('should throw NotFoundException for invalid father', async () => {
      const createDto = {
        femaleId: 'mother-1',
        maleId: 'invalid-father',
        breedingDate: '2024-01-15',
      };

      mockPrismaService.cat.findUnique.mockResolvedValueOnce(null);

      await expect(service.create(createDto)).rejects.toThrow(NotFoundException);
    });
  });

  describe('findAll', () => {
    it('should return paginated breeding records', async () => {
      const mockBreedings = [
        {
          id: '1',
          femaleId: 'mother-1',
          maleId: 'father-1',
          breedingDate: new Date(),
        },
      ];

      mockPrismaService.breedingRecord.count.mockResolvedValue(1);
      mockPrismaService.breedingRecord.findMany.mockResolvedValue(mockBreedings);

      const result = await service.findAll({});

      expect(result.data).toEqual(mockBreedings);
      expect(result.meta.total).toBe(1);
    });
  });


});
`````

## File: backend/src/breeding/breeding.service.ts
`````typescript
import { Injectable, BadRequestException, NotFoundException } from "@nestjs/common";
import { Prisma } from "@prisma/client";

import { PrismaService } from "../prisma/prisma.service";

import {
  BreedingQueryDto,
  CreateBreedingDto,
  UpdateBreedingDto,
  CreateBreedingNgRuleDto,
  UpdateBreedingNgRuleDto,
  CreatePregnancyCheckDto,
  UpdatePregnancyCheckDto,
  PregnancyCheckQueryDto,
  CreateBirthPlanDto,
  UpdateBirthPlanDto,
  BirthPlanQueryDto,
  CreateKittenDispositionDto,
  UpdateKittenDispositionDto,
  CreateBreedingScheduleDto,
  UpdateBreedingScheduleDto,
  BreedingScheduleQueryDto,
  CreateMatingCheckDto,
  UpdateMatingCheckDto,
} from "./dto";
import {
  BreedingWhereInput,
  CatWithGender,
  BreedingListResponse,
  BreedingCreateResponse,
  BreedingSuccessResponse,
  BreedingNgRuleListResponse,
  BreedingNgRuleResponse,
  PregnancyCheckListResponse,
  PregnancyCheckResponse,
  BirthPlanListResponse,
  BirthPlanResponse,
  BreedingScheduleListResponse,
  BreedingScheduleResponse,
  MatingCheckResponse,
} from "./types/breeding.types";

@Injectable()
export class BreedingService {
  constructor(private readonly prisma: PrismaService) {}

  async findAll(query: BreedingQueryDto): Promise<BreedingListResponse> {
    const {
      page = 1,
      limit = 20,
      femaleId,
      maleId,
      dateFrom,
      dateTo,
      sortBy = "createdAt",
      sortOrder = "desc",
    } = query;

    const where: BreedingWhereInput = {};
    if (femaleId) where.femaleId = femaleId;
    if (maleId) where.maleId = maleId;
    if (dateFrom || dateTo) {
      where.breedingDate = {};
      if (dateFrom) where.breedingDate.gte = new Date(dateFrom);
      if (dateTo) where.breedingDate.lte = new Date(dateTo);
    }

    const [total, data] = await this.prisma.$transaction([
      this.prisma.breedingRecord.count({ where }),
      this.prisma.breedingRecord.findMany({
        where,
        include: {
          male: { select: { id: true, name: true } },
          female: { select: { id: true, name: true } },
        },
        orderBy: { [sortBy]: sortOrder },
        skip: (page - 1) * limit,
        take: limit,
      }),
    ]);

    return {
      success: true,
      data,
      meta: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  async create(dto: CreateBreedingDto, userId?: string): Promise<BreedingCreateResponse> {
    // Validate parents existence
    const [female, male] = await Promise.all([
      this.prisma.cat.findUnique({ 
        where: { id: dto.femaleId },
        select: { id: true, gender: true }
      }),
      this.prisma.cat.findUnique({ 
        where: { id: dto.maleId },
        select: { id: true, gender: true }
      }),
    ]);

    if (!female) throw new NotFoundException("femaleId not found");
    if (!male) throw new NotFoundException("maleId not found");

    // Basic gender check (optional but useful)
    if ((female as CatWithGender).gender === "MALE") {
      throw new BadRequestException("femaleId must refer to a FEMALE cat");
    }
    if ((male as CatWithGender).gender === "FEMALE") {
      throw new BadRequestException("maleId must refer to a MALE cat");
    }

    const firstUser = userId ? null : await this.prisma.user.findFirst();
    const recordedById = userId ?? firstUser?.id;
    if (!recordedById) {
      throw new BadRequestException('è¨˜éŒ²è€…æƒ…å ±ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ');
    }

    const result = await this.prisma.breedingRecord.create({
      data: {
        femaleId: dto.femaleId,
        maleId: dto.maleId,
        breedingDate: new Date(dto.breedingDate),
        expectedDueDate: dto.expectedDueDate
          ? new Date(dto.expectedDueDate)
          : undefined,
        notes: dto.notes,
        recordedBy: recordedById,
      },
      include: {
        male: { select: { id: true, name: true } },
        female: { select: { id: true, name: true } },
      },
    });
    return { success: true, data: result };
  }

  async update(id: string, dto: UpdateBreedingDto): Promise<BreedingSuccessResponse> {
    await this.prisma.breedingRecord.update({
      where: { id },
      data: {
        femaleId: dto.femaleId,
        maleId: dto.maleId,
        breedingDate: dto.breedingDate ? new Date(dto.breedingDate) : undefined,
        expectedDueDate: dto.expectedDueDate
          ? new Date(dto.expectedDueDate)
          : undefined,
        notes: dto.notes,
      },
    });
    return { success: true };
  }

  async remove(id: string): Promise<BreedingSuccessResponse> {
    await this.prisma.breedingRecord.delete({ where: { id } });
    return { success: true };
  }

  async findNgRules(): Promise<BreedingNgRuleListResponse> {
    const rules = await this.prisma.breedingNgRule.findMany({
      orderBy: { createdAt: "desc" },
    });

    return { success: true, data: rules };
  }

  async createNgRule(dto: CreateBreedingNgRuleDto): Promise<BreedingNgRuleResponse> {
    const rule = await this.prisma.breedingNgRule.create({
      data: {
        name: dto.name,
        description: dto.description,
        type: dto.type,
        active: dto.active ?? true,
        maleConditions: dto.maleConditions ?? [],
        femaleConditions: dto.femaleConditions ?? [],
        maleNames: dto.maleNames ?? [],
        femaleNames: dto.femaleNames ?? [],
        generationLimit: dto.generationLimit,
      },
    });

    return { success: true, data: rule };
  }

  async updateNgRule(id: string, dto: UpdateBreedingNgRuleDto): Promise<BreedingNgRuleResponse> {
    const data: Prisma.BreedingNgRuleUpdateInput = {
      name: dto.name,
      description: dto.description,
      type: dto.type,
      active: dto.active,
      generationLimit: dto.generationLimit,
    };

    if (dto.maleConditions !== undefined) {
      data.maleConditions = { set: dto.maleConditions };
    }

    if (dto.femaleConditions !== undefined) {
      data.femaleConditions = { set: dto.femaleConditions };
    }

    if (dto.maleNames !== undefined) {
      data.maleNames = { set: dto.maleNames };
    }

    if (dto.femaleNames !== undefined) {
      data.femaleNames = { set: dto.femaleNames };
    }

    const rule = await this.prisma.breedingNgRule.update({
      where: { id },
      data,
    });

    return { success: true, data: rule };
  }

  async removeNgRule(id: string): Promise<BreedingSuccessResponse> {
    await this.prisma.breedingNgRule.delete({ where: { id } });
    return { success: true };
  }

  // Pregnancy Check methods
  async findAllPregnancyChecks(query: PregnancyCheckQueryDto): Promise<PregnancyCheckListResponse> {
    const {
      page = 1,
      limit = 20,
      motherId,
      status,
    } = query;

    const where: Prisma.PregnancyCheckWhereInput = {};
    if (motherId) where.motherId = motherId;
    if (status) where.status = status;

    const [total, data] = await this.prisma.$transaction([
      this.prisma.pregnancyCheck.count({ where }),
      this.prisma.pregnancyCheck.findMany({
        where,
        include: {
          mother: { select: { id: true, name: true } },
        },
        orderBy: { checkDate: "desc" },
        skip: (page - 1) * limit,
        take: limit,
      }),
    ]);

    return {
      success: true,
      data,
      meta: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  async createPregnancyCheck(dto: CreatePregnancyCheckDto, userId?: string): Promise<PregnancyCheckResponse> {
    // Validate mother exists and is female
    const mother = await this.prisma.cat.findUnique({
      where: { id: dto.motherId },
      select: { id: true, gender: true, name: true }
    });

    if (!mother) throw new NotFoundException("Mother cat not found");
    if (mother.gender === "MALE") {
      throw new BadRequestException("Mother must be a female cat");
    }

    // Validate father if provided
    if (dto.fatherId) {
      const father = await this.prisma.cat.findUnique({
        where: { id: dto.fatherId },
        select: { id: true, gender: true }
      });

      if (!father) throw new NotFoundException("Father cat not found");
      if (father.gender !== "MALE") {
        throw new BadRequestException("Father must be a male cat");
      }
    }

    const firstUser = userId ? null : await this.prisma.user.findFirst();
    const recordedById = userId ?? firstUser?.id;
    if (!recordedById) {
      throw new BadRequestException('è¨˜éŒ²è€…æƒ…å ±ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ');
    }

    const result = await this.prisma.pregnancyCheck.create({
      data: {
        motherId: dto.motherId,
        fatherId: dto.fatherId,
        matingDate: dto.matingDate ? new Date(dto.matingDate) : null,
        checkDate: new Date(dto.checkDate),
        status: dto.status,
        notes: dto.notes,
        recordedBy: recordedById,
      },
      include: {
        mother: { select: { id: true, name: true } },
      },
    });

    return { success: true, data: result };
  }

  async updatePregnancyCheck(id: string, dto: UpdatePregnancyCheckDto): Promise<BreedingSuccessResponse> {
    // Validate father if provided
    if (dto.fatherId) {
      const father = await this.prisma.cat.findUnique({
        where: { id: dto.fatherId },
        select: { id: true, gender: true }
      });

      if (!father) throw new NotFoundException("Father cat not found");
      if (father.gender !== "MALE") {
        throw new BadRequestException("Father must be a male cat");
      }
    }

    await this.prisma.pregnancyCheck.update({
      where: { id },
      data: {
        fatherId: dto.fatherId,
        matingDate: dto.matingDate ? new Date(dto.matingDate) : undefined,
        checkDate: dto.checkDate ? new Date(dto.checkDate) : undefined,
        status: dto.status,
        notes: dto.notes,
      },
    });
    return { success: true };
  }

  async removePregnancyCheck(id: string): Promise<BreedingSuccessResponse> {
    try {
      await this.prisma.pregnancyCheck.delete({ where: { id } });
      return { success: true };
    } catch (error) {
      console.error(`Failed to delete pregnancy check ${id}:`, error);
      const errorMessage = error instanceof Error ? error.message : 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼';
      throw new BadRequestException(
        `å¦Šå¨ ç¢ºèªã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ: ${errorMessage}`
      );
    }
  }

  // Birth Plan methods
  async findAllBirthPlans(query: BirthPlanQueryDto): Promise<BirthPlanListResponse> {
    const {
      page = 1,
      limit = 20,
      motherId,
      status,
    } = query;

    const where: Prisma.BirthPlanWhereInput = {};
    if (motherId) where.motherId = motherId;
    if (status) where.status = status;

    const [total, data] = await this.prisma.$transaction([
      this.prisma.birthPlan.count({ where }),
      this.prisma.birthPlan.findMany({
        where,
        include: {
          mother: { select: { id: true, name: true } },
          kittenDispositions: true,
        },
        orderBy: { expectedBirthDate: "desc" },
        skip: (page - 1) * limit,
        take: limit,
      }),
    ]);

    return {
      success: true,
      data,
      meta: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  async createBirthPlan(dto: CreateBirthPlanDto, userId?: string): Promise<BirthPlanResponse> {
    // Validate mother exists and is female
    const mother = await this.prisma.cat.findUnique({
      where: { id: dto.motherId },
      select: { id: true, gender: true, name: true }
    });

    if (!mother) throw new NotFoundException("Mother cat not found");
    if (mother.gender === "MALE") {
      throw new BadRequestException("Mother must be a female cat");
    }

    // Validate father if provided
    if (dto.fatherId) {
      const father = await this.prisma.cat.findUnique({
        where: { id: dto.fatherId },
        select: { id: true, gender: true }
      });

      if (!father) throw new NotFoundException("Father cat not found");
      if (father.gender !== "MALE") {
        throw new BadRequestException("Father must be a male cat");
      }
    }

    const firstUser = userId ? null : await this.prisma.user.findFirst();
    const recordedById = userId ?? firstUser?.id;

    if (!recordedById) {
      throw new BadRequestException("No user found to record the birth plan");
    }

    const result = await this.prisma.birthPlan.create({
      data: {
        motherId: dto.motherId,
        fatherId: dto.fatherId || undefined,
        matingDate: dto.matingDate ? new Date(dto.matingDate) : undefined,
        expectedBirthDate: new Date(dto.expectedBirthDate),
        actualBirthDate: dto.actualBirthDate ? new Date(dto.actualBirthDate) : undefined,
        status: dto.status,
        expectedKittens: dto.expectedKittens || undefined,
        actualKittens: dto.actualKittens || undefined,
        notes: dto.notes || undefined,
        recordedBy: recordedById,
      },
      include: {
        mother: { select: { id: true, name: true } },
      },
    });

    return { success: true, data: result };
  }

  async updateBirthPlan(id: string, dto: UpdateBirthPlanDto): Promise<BreedingSuccessResponse> {
    try {
      // Validate father if provided
      if (dto.fatherId) {
        const father = await this.prisma.cat.findUnique({
          where: { id: dto.fatherId },
          select: { id: true, gender: true }
        });

        if (!father) throw new NotFoundException("Father cat not found");
        if (father.gender !== "MALE") {
          throw new BadRequestException("Father must be a male cat");
        }
      }

      await this.prisma.birthPlan.update({
        where: { id },
        data: {
          fatherId: dto.fatherId,
          matingDate: dto.matingDate ? new Date(dto.matingDate) : undefined,
          expectedBirthDate: dto.expectedBirthDate ? new Date(dto.expectedBirthDate) : undefined,
          actualBirthDate: dto.actualBirthDate ? new Date(dto.actualBirthDate) : undefined,
          status: dto.status,
          expectedKittens: dto.expectedKittens,
          actualKittens: dto.actualKittens,
          notes: dto.notes,
        },
      });
      return { success: true };
    } catch (error) {
      console.error(`Failed to update birth plan ${id}:`, error);
      const errorMessage = error instanceof Error ? error.message : 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼';
      throw new BadRequestException(
        `å‡ºç”£äºˆå®šã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ: ${errorMessage}`
      );
    }
  }

  async removeBirthPlan(id: string): Promise<BreedingSuccessResponse> {
    try {
      // Check if birth plan has any kitten dispositions
      const kittenDispositionsCount = await this.prisma.kittenDisposition.count({
        where: { birthRecordId: id }
      });

      if (kittenDispositionsCount > 0) {
        throw new BadRequestException(
          'ã“ã®å‡ºç”£äºˆå®šã«ã¯å­çŒ«å‡¦é‡è¨˜éŒ²ãŒé–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹ãŸã‚ã€å‰Šé™¤ã§ãã¾ã›ã‚“ã€‚å­çŒ«å‡¦é‡è¨˜éŒ²ã‚’å…ˆã«å‰Šé™¤ã—ã¦ãã ã•ã„ã€‚'
        );
      }

      await this.prisma.birthPlan.delete({ where: { id } });
      return { success: true };
    } catch (error) {
      console.error(`Failed to delete birth plan ${id}:`, error);
      if (error instanceof BadRequestException) {
        throw error;
      }
      const errorMessage = error instanceof Error ? error.message : 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼';
      throw new BadRequestException(
        `å‡ºç”£äºˆå®šã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ: ${errorMessage}`
      );
    }
  }

  // ========== Kitten Disposition Methods ==========

  async findAllKittenDispositions(birthRecordId: string) {
    const dispositions = await this.prisma.kittenDisposition.findMany({
      where: { birthRecordId },
      include: {
        kitten: { select: { id: true, name: true } },
      },
      orderBy: { createdAt: "asc" },
    });

    return { success: true, data: dispositions };
  }

  async createKittenDisposition(dto: CreateKittenDispositionDto, _userId?: string) {
    const { birthRecordId, kittenId, name, gender, disposition, trainingStartDate, saleInfo, deathDate, deathReason, notes } = dto;

    // Validate birthRecord exists
    const birthRecord = await this.prisma.birthPlan.findUnique({
      where: { id: birthRecordId },
    });
    if (!birthRecord) throw new NotFoundException("Birth record not found");

    const result = await this.prisma.kittenDisposition.create({
      data: {
        birthRecordId,
        kittenId,
        name,
        gender,
        disposition,
        trainingStartDate: trainingStartDate ? new Date(trainingStartDate) : undefined,
        saleInfo: saleInfo ? (saleInfo as object) : undefined,
        deathDate: deathDate ? new Date(deathDate) : undefined,
        deathReason,
        notes,
      },
      include: {
        kitten: { select: { id: true, name: true } },
      },
    });

    return { success: true, data: result };
  }

  async updateKittenDisposition(id: string, dto: UpdateKittenDispositionDto) {
    const { kittenId, name, gender, disposition, trainingStartDate, saleInfo, deathDate, deathReason, notes } = dto;

    await this.prisma.kittenDisposition.update({
      where: { id },
      data: {
        kittenId,
        name,
        gender,
        disposition,
        trainingStartDate: trainingStartDate ? new Date(trainingStartDate) : undefined,
        saleInfo: saleInfo ? (saleInfo as object) : undefined,
        deathDate: deathDate ? new Date(deathDate) : undefined,
        deathReason,
        notes,
      },
    });

    return { success: true };
  }

  async removeKittenDisposition(id: string) {
    await this.prisma.kittenDisposition.delete({ where: { id } });
    return { success: true };
  }

  async completeBirthRecord(id: string) {
    await this.prisma.birthPlan.update({
      where: { id },
      data: {
        completedAt: new Date(),
      },
    });
    return { success: true };
  }

  // ========== Breeding Schedule Methods ==========

  async findAllBreedingSchedules(query: BreedingScheduleQueryDto): Promise<BreedingScheduleListResponse> {
    const {
      page = 1,
      limit = 50,
      maleId,
      femaleId,
      status,
      dateFrom,
      dateTo,
    } = query;

    const where: Prisma.BreedingScheduleWhereInput = {};
    if (maleId) where.maleId = maleId;
    if (femaleId) where.femaleId = femaleId;
    if (status) where.status = status;
    if (dateFrom || dateTo) {
      where.startDate = {};
      if (dateFrom) where.startDate.gte = new Date(dateFrom);
      if (dateTo) where.startDate.lte = new Date(dateTo);
    }

    const [total, data] = await this.prisma.$transaction([
      this.prisma.breedingSchedule.count({ where }),
      this.prisma.breedingSchedule.findMany({
        where,
        include: {
          male: { select: { id: true, name: true } },
          female: { select: { id: true, name: true } },
          checks: {
            orderBy: { checkDate: 'asc' },
          },
        },
        orderBy: { startDate: 'desc' },
        skip: (page - 1) * limit,
        take: limit,
      }),
    ]);

    return {
      success: true,
      data,
      meta: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  async createBreedingSchedule(dto: CreateBreedingScheduleDto, userId?: string): Promise<BreedingScheduleResponse> {
    // ã‚ªã‚¹çŒ«ã®å­˜åœ¨ç¢ºèª
    const male = await this.prisma.cat.findUnique({
      where: { id: dto.maleId },
      select: { id: true, gender: true, name: true }
    });
    if (!male) throw new NotFoundException("ã‚ªã‚¹çŒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
    if (male.gender !== "MALE") {
      throw new BadRequestException("maleId ã¯ã‚ªã‚¹çŒ«ã‚’æŒ‡å®šã—ã¦ãã ã•ã„");
    }

    // ãƒ¡ã‚¹çŒ«ã®å­˜åœ¨ç¢ºèª
    const female = await this.prisma.cat.findUnique({
      where: { id: dto.femaleId },
      select: { id: true, gender: true, name: true }
    });
    if (!female) throw new NotFoundException("ãƒ¡ã‚¹çŒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
    if (female.gender !== "FEMALE") {
      throw new BadRequestException("femaleId ã¯ãƒ¡ã‚¹çŒ«ã‚’æŒ‡å®šã—ã¦ãã ã•ã„");
    }

    // è¨˜éŒ²è€…ã®ç¢ºèª
    const firstUser = userId ? null : await this.prisma.user.findFirst();
    const recordedById = userId ?? firstUser?.id;
    if (!recordedById) {
      throw new BadRequestException('è¨˜éŒ²è€…æƒ…å ±ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ');
    }

    const result = await this.prisma.breedingSchedule.create({
      data: {
        maleId: dto.maleId,
        femaleId: dto.femaleId,
        startDate: new Date(dto.startDate),
        duration: dto.duration,
        status: dto.status ?? 'SCHEDULED',
        notes: dto.notes,
        recordedBy: recordedById,
      },
      include: {
        male: { select: { id: true, name: true } },
        female: { select: { id: true, name: true } },
        checks: true,
      },
    });

    return { success: true, data: result };
  }

  async updateBreedingSchedule(id: string, dto: UpdateBreedingScheduleDto): Promise<BreedingSuccessResponse> {
    // ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å­˜åœ¨ç¢ºèª
    const existing = await this.prisma.breedingSchedule.findUnique({
      where: { id },
    });
    if (!existing) throw new NotFoundException("ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");

    // ã‚ªã‚¹çŒ«ã®ç¢ºèªï¼ˆå¤‰æ›´æ™‚ã®ã¿ï¼‰
    if (dto.maleId && dto.maleId !== existing.maleId) {
      const male = await this.prisma.cat.findUnique({
        where: { id: dto.maleId },
        select: { id: true, gender: true }
      });
      if (!male) throw new NotFoundException("ã‚ªã‚¹çŒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
      if (male.gender !== "MALE") {
        throw new BadRequestException("maleId ã¯ã‚ªã‚¹çŒ«ã‚’æŒ‡å®šã—ã¦ãã ã•ã„");
      }
    }

    // ãƒ¡ã‚¹çŒ«ã®ç¢ºèªï¼ˆå¤‰æ›´æ™‚ã®ã¿ï¼‰
    if (dto.femaleId && dto.femaleId !== existing.femaleId) {
      const female = await this.prisma.cat.findUnique({
        where: { id: dto.femaleId },
        select: { id: true, gender: true }
      });
      if (!female) throw new NotFoundException("ãƒ¡ã‚¹çŒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
      if (female.gender !== "FEMALE") {
        throw new BadRequestException("femaleId ã¯ãƒ¡ã‚¹çŒ«ã‚’æŒ‡å®šã—ã¦ãã ã•ã„");
      }
    }

    await this.prisma.breedingSchedule.update({
      where: { id },
      data: {
        maleId: dto.maleId,
        femaleId: dto.femaleId,
        startDate: dto.startDate ? new Date(dto.startDate) : undefined,
        duration: dto.duration,
        status: dto.status,
        notes: dto.notes,
      },
    });

    return { success: true };
  }

  async removeBreedingSchedule(id: string): Promise<BreedingSuccessResponse> {
    const existing = await this.prisma.breedingSchedule.findUnique({
      where: { id },
    });
    if (!existing) throw new NotFoundException("ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");

    // MatingCheck ã¯ onDelete: Cascade ã§è‡ªå‹•å‰Šé™¤ã•ã‚Œã‚‹
    await this.prisma.breedingSchedule.delete({ where: { id } });
    return { success: true };
  }

  // ========== Mating Check Methods ==========

  async findMatingChecksBySchedule(scheduleId: string) {
    const schedule = await this.prisma.breedingSchedule.findUnique({
      where: { id: scheduleId },
    });
    if (!schedule) throw new NotFoundException("ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");

    const checks = await this.prisma.matingCheck.findMany({
      where: { scheduleId },
      orderBy: { checkDate: 'asc' },
    });

    return { success: true, data: checks };
  }

  async createMatingCheck(scheduleId: string, dto: CreateMatingCheckDto): Promise<MatingCheckResponse> {
    const schedule = await this.prisma.breedingSchedule.findUnique({
      where: { id: scheduleId },
    });
    if (!schedule) throw new NotFoundException("ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");

    const result = await this.prisma.matingCheck.create({
      data: {
        scheduleId,
        checkDate: new Date(dto.checkDate),
        count: dto.count ?? 1,
      },
    });

    return { success: true, data: result };
  }

  async updateMatingCheck(id: string, dto: UpdateMatingCheckDto): Promise<BreedingSuccessResponse> {
    const existing = await this.prisma.matingCheck.findUnique({
      where: { id },
    });
    if (!existing) throw new NotFoundException("äº¤é…ãƒã‚§ãƒƒã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");

    await this.prisma.matingCheck.update({
      where: { id },
      data: {
        checkDate: dto.checkDate ? new Date(dto.checkDate) : undefined,
        count: dto.count,
      },
    });

    return { success: true };
  }

  async removeMatingCheck(id: string): Promise<BreedingSuccessResponse> {
    const existing = await this.prisma.matingCheck.findUnique({
      where: { id },
    });
    if (!existing) throw new NotFoundException("äº¤é…ãƒã‚§ãƒƒã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");

    await this.prisma.matingCheck.delete({ where: { id } });
    return { success: true };
  }
}
`````

## File: backend/src/breeds/dto/breed-query.dto.ts
`````typescript
import { ApiPropertyOptional } from "@nestjs/swagger";
import { Type } from "class-transformer";
import { IsOptional, IsString, IsInt, IsIn, Min, Max } from "class-validator";

export class BreedQueryDto {
  @ApiPropertyOptional({ description: "ãƒšãƒ¼ã‚¸ç•ªå·", default: 1 })
  @IsOptional()
  @IsInt()
  @Min(1)
  @Type(() => Number)
  page?: number = 1;

  @ApiPropertyOptional({ description: "1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•°", default: 50, maximum: 1000 })
  @IsOptional()
  @IsInt()
  @Min(1)
  @Max(1000)
  @Type(() => Number)
  limit?: number = 50;

  @ApiPropertyOptional({ description: "æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰" })
  @IsOptional()
  @IsString()
  search?: string;

  @ApiPropertyOptional({ description: "ã‚½ãƒ¼ãƒˆé …ç›®", default: "name" })
  @IsOptional()
  @IsString()
  @IsIn(["name", "nameEn", "createdAt", "updatedAt", "code"])
  sortBy?: string = "name";

  @ApiPropertyOptional({ description: "ã‚½ãƒ¼ãƒˆé †", default: "asc" })
  @IsOptional()
  @IsString()
  @IsIn(["asc", "desc"])
  sortOrder?: "asc" | "desc" = "asc";
}
`````

## File: backend/src/breeds/dto/create-breed.dto.ts
`````typescript
import { ApiProperty, ApiPropertyOptional } from "@nestjs/swagger";
import { Type } from "class-transformer";
import { IsString, IsOptional, MaxLength, IsInt, Min, Max } from "class-validator";

export class CreateBreedDto {
  @ApiProperty({ description: "å“ç¨®ã‚³ãƒ¼ãƒ‰" })
  @IsInt()
  @Min(1)
  @Max(9999)
  @Type(() => Number)
  code: number;

  @ApiProperty({ description: "å“ç¨®å" })
  @IsString()
  @MaxLength(100)
  name: string;

  @ApiPropertyOptional({ description: "å“ç¨®ã®èª¬æ˜" })
  @IsOptional()
  @IsString()
  @MaxLength(1000)
  description?: string;
}
`````

## File: backend/src/breeds/dto/index.ts
`````typescript
export * from "./create-breed.dto";
export * from "./update-breed.dto";
export * from "./breed-query.dto";
`````

## File: backend/src/breeds/dto/update-breed.dto.ts
`````typescript
import { PartialType } from "@nestjs/mapped-types";

import { CreateBreedDto } from "./create-breed.dto";

export class UpdateBreedDto extends PartialType(CreateBreedDto) {}
`````

## File: backend/src/breeds/breed-master.data.ts
`````typescript
/**
 * Pedigreesãƒ†ãƒ¼ãƒ–ãƒ«ã®breedãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã§åˆ©ç”¨ã™ã‚‹å“ç¨®ãƒã‚¹ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿ã€‚
 * å…ƒãƒ‡ãƒ¼ã‚¿: çŒ«ç¨®ãƒ‡ãƒ¼ã‚¿UTF8Ver.csvï¼ˆãƒ˜ãƒƒãƒ€ãƒ¼: ã‚­ãƒ¼, ç¨®é¡åç§°ï¼‰
 * æœ¬ãƒ•ã‚¡ã‚¤ãƒ«ã§ã¯ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ code / name ã«ãƒªãƒãƒ¼ãƒ ã—ã€å…¨ãƒ¬ã‚³ãƒ¼ãƒ‰ (0-112) ã‚’ä¿æŒã™ã‚‹ã€‚
 */

export interface BreedMasterRecord {
  code: number;
  name: string;
}

export const BREED_MASTER_DATA: ReadonlyArray<BreedMasterRecord> = [
  { code: 0, name: "" },
  { code: 1, name: "Abyssinian" },
  { code: 2, name: "American Curl(LH)" },
  { code: 3, name: "American Curl(SH)" },
  { code: 4, name: "American Curl(LH.SE)" },
  { code: 5, name: "American Curl(SH.SE)" },
  { code: 6, name: "American Shorthair" },
  { code: 7, name: "American Wirehair" },
  { code: 8, name: "Balinese" },
  { code: 9, name: "Bengal" },
  { code: 10, name: "Birman" },
  { code: 11, name: "Bombay" },
  { code: 12, name: "British Shorthair" },
  { code: 13, name: "Burmese" },
  { code: 14, name: "Chartreux" },
  { code: 15, name: "Colorpoint Shorthair" },
  { code: 16, name: "Cornish Rex" },
  { code: 17, name: "Cymic" },
  { code: 18, name: "Devon Rex" },
  { code: 19, name: "Egyptian Mau" },
  { code: 20, name: "Exotic" },
  { code: 21, name: "Havana Brown" },
  { code: 22, name: "House Hold Pet" },
  { code: 23, name: "Japanese Bobtail" },
  { code: 24, name: "Javanese" },
  { code: 25, name: "Korat" },
  { code: 26, name: "Maine Coon" },
  { code: 27, name: "Manx" },
  { code: 28, name: "Munchkin (SH)" },
  { code: 29, name: "Norwegian Forest Cat" },
  { code: 30, name: "Ocicat" },
  { code: 31, name: "Oriental Longhair" },
  { code: 32, name: "Oriental Shorthair" },
  { code: 33, name: "Persian" },
  { code: 34, name: "Persian (HIMALAYAN)" },
  { code: 35, name: "Persian (C.P.C)" },
  { code: 36, name: "Ragdoll" },
  { code: 37, name: "Russian Blue" },
  { code: 38, name: "Scottish Fold (LH)" },
  { code: 39, name: "Scottish Fold (SH)" },
  { code: 40, name: "Scottish Fold(LH.SE)" },
  { code: 41, name: "Scottish Fold(SH.SE)" },
  { code: 42, name: "Snowshoe" },
  { code: 43, name: "Siamese" },
  { code: 44, name: "Selkirk Rex (SH)" },
  { code: 45, name: "Singapura" },
  { code: 46, name: "Somali" },
  { code: 47, name: "Sphynx" },
  { code: 48, name: "Tonkinese" },
  { code: 49, name: "Turkish Angora" },
  { code: 50, name: "Turkish Van" },
  { code: 51, name: "Wild Cat" },
  { code: 52, name: "Sugar Fold" },
  { code: 53, name: "Domestic Cat" },
  { code: 54, name: "European Burmese" },
  { code: 55, name: "Russian Blue (AOC)" },
  { code: 56, name: "Munchkin (SH.NL)" },
  { code: 57, name: "Munchkin (LH)" },
  { code: 58, name: "Exotic Longhair" },
  { code: 59, name: "Ragamuffin" },
  { code: 60, name: "American Curl" },
  { code: 61, name: "Scottish Fold" },
  { code: 62, name: "La Perm (LH)" },
  { code: 63, name: "La Perm (SH)" },
  { code: 64, name: "La Perm (LH.ST)" },
  { code: 65, name: "La Perm (SH.ST)" },
  { code: 66, name: "Munchkin (LH.NL)" },
  { code: 67, name: "Siberian" },
  { code: 68, name: "British Longhair" },
  { code: 69, name: "Domestic Cat (LH)" },
  { code: 70, name: "White (Albino)" },
  { code: 71, name: "Balinese-(Javanese)" },
  { code: 72, name: "Thai" },
  { code: 73, name: "Skookum" },
  { code: 74, name: "Selkirk Rex (LH)" },
  { code: 75, name: "Selkirk Rex (SH.ST)" },
  { code: 76, name: "Selkirk Rex (LH.ST)" },
  { code: 77, name: "American Curl (SWH)" },
  { code: 78, name: "American Curl (LWH)" },
  { code: 79, name: "Canadian Lop (SH)" },
  { code: 80, name: "Canadian Lop (LH)" },
  { code: 81, name: "Canadian Lop (SH.SE)" },
  { code: 82, name: "Canadian Lop (LH.SE)" },
  { code: 83, name: "Lamkin (SH)" },
  { code: 84, name: "Lamkin (LH)" },
  { code: 85, name: "Lamkin (SH.ST)" },
  { code: 86, name: "Lamkin (LH.ST)" },
  { code: 87, name: "Lamkin (SH.NL)" },
  { code: 88, name: "Lamkin (LH.NL)" },
  { code: 89, name: "Lamkin (SH.ST.NL)" },
  { code: 90, name: "Lamkin (LH.ST.NL)" },
  { code: 91, name: "Minuet(SH)" },
  { code: 92, name: "Minuet(LH)" },
  { code: 93, name: "Minuet(SH.NL)" },
  { code: 94, name: "Minuet(LH.NL)" },
  { code: 95, name: "Skookum (SH)" },
  { code: 96, name: "Skookum (LH)" },
  { code: 97, name: "Skookum (SH.NL)" },
  { code: 98, name: "Skookum (LH.NL)" },
  { code: 99, name: "Skookum (SH.ST)" },
  { code: 100, name: "Skookum (LH.ST)" },
  { code: 101, name: "Kinkaro (SH)" },
  { code: 102, name: "Kinkaro (LH)" },
  { code: 103, name: "Kinkaro (SH.SE)" },
  { code: 104, name: "Kinkaro (LH.SE)" },
  { code: 105, name: "Kinkaro (SH.NL)" },
  { code: 106, name: "Kinkaro (LH.NL)" },
  { code: 107, name: "Kinkaro (SH.SE.NL)" },
  { code: 108, name: "Kinkaro (LH.SE.NL)" },
  { code: 109, name: "ï½±ï½·" },
  { code: 110, name: "Bengal(A.O.C)" },
  { code: 111, name: "Jenetta" },
  { code: 112, name: "Toyger" },
];

const BREED_MASTER_MAP_ENTRIES = BREED_MASTER_DATA.map((record) => [record.code, record] as const);

export const BREED_MASTER_MAP: ReadonlyMap<number, BreedMasterRecord> = new Map(
  BREED_MASTER_MAP_ENTRIES,
);

export const findBreedByCode = (code: number): BreedMasterRecord | undefined =>
  BREED_MASTER_MAP.get(code);
`````

## File: backend/src/breeds/breeds.controller.spec.ts
`````typescript
import { Test, TestingModule } from '@nestjs/testing';

import { DisplayPreferencesService } from '../display-preferences/display-preferences.service';
import { getTestModuleImports, getTestModuleProviders } from '../test-utils/test-module-setup';

import { BreedsController } from './breeds.controller';
import { BreedsService } from './breeds.service';

describe('BreedsController', () => {
  let controller: BreedsController;
  let service: BreedsService;

  const mockBreedsService = {
    create: jest.fn(),
    findAll: jest.fn(),
    findOne: jest.fn(),
    update: jest.fn(),
    remove: jest.fn(),
    getMasterData: jest.fn(),
  };
  const mockDisplayPreferencesService = {
    getPreferences: jest.fn(),
    buildPersonalizedBreedRecords: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      imports: getTestModuleImports(),
      controllers: [BreedsController],
      providers: [
        ...getTestModuleProviders(),
        {
          provide: BreedsService,
          useValue: mockBreedsService,
        },
        {
          provide: DisplayPreferencesService,
          useValue: mockDisplayPreferencesService,
        },
      ],
    }).compile();

    controller = module.get<BreedsController>(BreedsController);
    service = module.get<BreedsService>(BreedsService);

    jest.clearAllMocks();
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });

  describe('create', () => {
    it('should create a breed', async () => {
      const createDto = { code: 1, name: 'Persian', description: 'Long-haired' };
      const mockBreed = { id: '1', ...createDto };

      mockBreedsService.create.mockResolvedValue(mockBreed);

      const result = await controller.create(createDto);

      expect(result).toEqual(mockBreed);
      expect(service.create).toHaveBeenCalledWith(createDto);
    });
  });

  describe('findAll', () => {
    it('should return paginated breeds', async () => {
      const mockResponse = {
        data: [{ id: '1', name: 'Persian' }],
        pagination: { page: 1, limit: 10, total: 1, totalPages: 1 },
      };

      mockBreedsService.findAll.mockResolvedValue(mockResponse);

      const result = await controller.findAll({});

      expect(result).toEqual(mockResponse);
      expect(service.findAll).toHaveBeenCalledWith({});
    });
  });

  describe('findOne', () => {
    it('should return a breed by id', async () => {
      const mockBreed = { id: '1', name: 'Persian' };

      mockBreedsService.findOne.mockResolvedValue(mockBreed);

      const result = await controller.findOne('1');

      expect(result).toEqual(mockBreed);
      expect(service.findOne).toHaveBeenCalledWith('1');
    });
  });

  describe('update', () => {
    it('should update a breed', async () => {
      const updateDto = { name: 'Updated Persian' };
      const mockBreed = { id: '1', name: 'Updated Persian' };

      mockBreedsService.update.mockResolvedValue(mockBreed);

      const result = await controller.update('1', updateDto);

      expect(result).toEqual(mockBreed);
      expect(service.update).toHaveBeenCalledWith('1', updateDto);
    });
  });

  describe('remove', () => {
    it('should delete a breed', async () => {
      mockBreedsService.remove.mockResolvedValue(undefined);

      await controller.remove('1');

      expect(service.remove).toHaveBeenCalledWith('1');
    });
  });

  describe('getMasterData', () => {
    it('should return master data via service', async () => {
      const mockMaster = [{ code: 1, name: 'Abyssinian' }];
      mockBreedsService.getMasterData.mockResolvedValue(mockMaster);

      const result = await controller.getMasterData(undefined);

      expect(result).toEqual(mockMaster);
      expect(service.getMasterData).toHaveBeenCalled();
    });
  });
});
`````

## File: backend/src/breeds/breeds.controller.ts
`````typescript
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  HttpStatus,
  UseGuards,
} from "@nestjs/common";
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiParam,
  ApiQuery,
  ApiBearerAuth,
  ApiOkResponse,
  ApiExtraModels,
} from "@nestjs/swagger";
import { UserRole } from "@prisma/client";

import type { RequestUser } from "../auth/auth.types";
import { GetUser } from "../auth/get-user.decorator";
import { JwtAuthGuard } from "../auth/jwt-auth.guard";
import { RoleGuard } from "../auth/role.guard";
import { Roles } from "../auth/roles.decorator";
import { DisplayPreferencesService } from "../display-preferences/display-preferences.service";
import { MasterDataItemDto } from "../display-preferences/dto/master-data-item.dto";

import { BreedsService } from "./breeds.service";
import { CreateBreedDto, UpdateBreedDto, BreedQueryDto } from "./dto";


@ApiExtraModels(MasterDataItemDto)
@ApiTags("Breeds")
@ApiBearerAuth()
@UseGuards(JwtAuthGuard)
@Controller("breeds")
export class BreedsController {
  constructor(
    private readonly breedsService: BreedsService,
    private readonly displayPreferences: DisplayPreferencesService,
  ) {}

  @Post()
  @UseGuards(RoleGuard)
  @Roles(UserRole.ADMIN, UserRole.SUPER_ADMIN)
  @ApiOperation({ summary: "å“ç¨®ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆï¼ˆç®¡ç†è€…ã®ã¿ï¼‰" })
  @ApiResponse({
    status: HttpStatus.CREATED,
    description: "å“ç¨®ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«ä½œæˆã•ã‚Œã¾ã—ãŸ",
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: "ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§ã™",
  })
  @ApiResponse({
    status: HttpStatus.FORBIDDEN,
    description: "ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™",
  })
  create(@Body() createBreedDto: CreateBreedDto) {
    return this.breedsService.create(createBreedDto);
  }

  @Get()
  @ApiOperation({ summary: "å“ç¨®ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œç´¢ãƒ»ä¸€è¦§å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK, description: "å“ç¨®ãƒ‡ãƒ¼ã‚¿ã®ä¸€è¦§" })
  @ApiQuery({
    name: "page",
    required: false,
    description: "ãƒšãƒ¼ã‚¸ç•ªå·",
    example: 1,
  })
  @ApiQuery({
    name: "limit",
    required: false,
    description: "1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•°",
    example: 50,
  })
  @ApiQuery({ name: "search", required: false, description: "æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰" })
  @ApiQuery({
    name: "sortBy",
    required: false,
    description: "ã‚½ãƒ¼ãƒˆé …ç›®",
    example: "name",
  })
  @ApiQuery({
    name: "sortOrder",
    required: false,
    description: "ã‚½ãƒ¼ãƒˆé †",
    example: "asc",
  })
  findAll(@Query() query: BreedQueryDto) {
    return this.breedsService.findAll(query);
  }

  @Get("master-data")
  @ApiOperation({ summary: "Pedigreeé€£æºç”¨ã®å“ç¨®ãƒã‚¹ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—" })
  @ApiOkResponse({
    description: "CSV ãƒã‚¹ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’ displayName / displayNameMode ä»˜ãã§è¿”å´",
    type: MasterDataItemDto,
    isArray: true,
  })
  async getMasterData(@GetUser() user: RequestUser | undefined) {
    if (!user) {
      return this.breedsService.getMasterData();
    }

    const preference = await this.displayPreferences.getPreferences(user.userId);
    const personalized =
      await this.displayPreferences.buildPersonalizedBreedRecords(preference);

    return personalized.map((record) => ({
      code: record.code,
      name: record.canonicalName,
      displayName: record.displayName,
      displayNameMode: preference.breedNameMode,
      isOverridden: record.isOverridden,
    }));
  }

  @Get("statistics")
  @ApiOperation({ summary: "å“ç¨®ãƒ‡ãƒ¼ã‚¿ã®çµ±è¨ˆæƒ…å ±ã‚’å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK, description: "çµ±è¨ˆæƒ…å ±" })
  getStatistics() {
    return this.breedsService.getStatistics();
  }

  @Get(":id")
  @ApiOperation({ summary: "IDã§å“ç¨®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK, description: "å“ç¨®ãƒ‡ãƒ¼ã‚¿" })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: "å“ç¨®ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
  })
  @ApiParam({ name: "id", description: "å“ç¨®ãƒ‡ãƒ¼ã‚¿ã®ID" })
  findOne(@Param("id") id: string) {
    return this.breedsService.findOne(id);
  }

  @Patch(":id")
  @UseGuards(RoleGuard)
  @Roles(UserRole.ADMIN, UserRole.SUPER_ADMIN)
  @ApiOperation({ summary: "å“ç¨®ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰" })
  @ApiResponse({
    status: HttpStatus.OK,
    description: "å“ç¨®ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«æ›´æ–°ã•ã‚Œã¾ã—ãŸ",
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: "å“ç¨®ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: "ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§ã™",
  })
  @ApiResponse({
    status: HttpStatus.FORBIDDEN,
    description: "ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™",
  })
  @ApiParam({ name: "id", description: "å“ç¨®ãƒ‡ãƒ¼ã‚¿ã®ID" })
  update(@Param("id") id: string, @Body() updateBreedDto: UpdateBreedDto) {
    return this.breedsService.update(id, updateBreedDto);
  }

  @Delete(":id")
  @UseGuards(RoleGuard)
  @Roles(UserRole.ADMIN, UserRole.SUPER_ADMIN)
  @ApiOperation({ summary: "å“ç¨®ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰" })
  @ApiResponse({
    status: HttpStatus.OK,
    description: "å“ç¨®ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«å‰Šé™¤ã•ã‚Œã¾ã—ãŸ",
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: "å“ç¨®ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
  })
  @ApiResponse({
    status: HttpStatus.FORBIDDEN,
    description: "ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™",
  })
  @ApiParam({ name: "id", description: "å“ç¨®ãƒ‡ãƒ¼ã‚¿ã®ID" })
  remove(@Param("id") id: string) {
    return this.breedsService.remove(id);
  }
}
`````

## File: backend/src/breeds/breeds.module.ts
`````typescript
import { Module } from "@nestjs/common";

import { DisplayPreferencesModule } from "../display-preferences/display-preferences.module";
import { PrismaModule } from "../prisma/prisma.module";

import { BreedsController } from "./breeds.controller";
import { BreedsService } from "./breeds.service";

@Module({
  imports: [PrismaModule, DisplayPreferencesModule],
  controllers: [BreedsController],
  providers: [BreedsService],
  exports: [BreedsService],
})
export class BreedsModule {}
`````

## File: backend/src/breeds/breeds.service.spec.ts
`````typescript
import { NotFoundException } from '@nestjs/common';
import { Test, TestingModule } from '@nestjs/testing';

import { PrismaService } from '../prisma/prisma.service';

import { BreedsService } from './breeds.service';


describe('BreedsService', () => {
  let service: BreedsService;
  let _prismaService: PrismaService;

  const mockPrismaService = {
    breed: {
      create: jest.fn(),
      findMany: jest.fn(),
      findUnique: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
      count: jest.fn(),
    },
    cat: {
      count: jest.fn(),
    },
    pedigree: {
      count: jest.fn(),
    },
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        BreedsService,
        {
          provide: PrismaService,
          useValue: mockPrismaService,
        },
      ],
    }).compile();

    service = module.get<BreedsService>(BreedsService);
    _prismaService = module.get<PrismaService>(PrismaService);

    jest.clearAllMocks();
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('create', () => {
    it('should create a breed successfully', async () => {
      const createDto = {
        code: 1,
        name: 'Persian',
        description: 'Long-haired cat',
      };

      const mockBreed = {
        id: '1',
        ...createDto,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      mockPrismaService.breed.create.mockResolvedValue(mockBreed);

      const result = await service.create(createDto);

      expect(result).toEqual(mockBreed);
      expect(mockPrismaService.breed.create).toHaveBeenCalledWith({
        data: createDto,
      });
    });
  });

  describe('findAll', () => {
    it('should return paginated breeds', async () => {
      const mockBreeds = [
        { id: '1', name: 'Persian' },
        { id: '2', name: 'Siamese' },
      ];

      mockPrismaService.breed.findMany.mockResolvedValue(mockBreeds);
      mockPrismaService.breed.count.mockResolvedValue(2);

      const result = await service.findAll({});

      expect(result.data).toEqual(mockBreeds);
      expect(result.meta.total).toBe(2);
      expect(mockPrismaService.breed.findMany).toHaveBeenCalled();
      expect(mockPrismaService.breed.count).toHaveBeenCalled();
    });

    it('should filter breeds by search term', async () => {
      const mockBreeds = [{ id: '1', name: 'Persian' }];

      mockPrismaService.breed.findMany.mockResolvedValue(mockBreeds);
      mockPrismaService.breed.count.mockResolvedValue(1);

      const result = await service.findAll({ search: 'Persian' });

      expect(result.data).toEqual(mockBreeds);
      expect(result.meta.total).toBe(1);
    });
  });

  describe('findOne', () => {
    it('should return a breed by id', async () => {
      const mockBreed = { id: '1', name: 'Persian', cats: [] };

      mockPrismaService.breed.findUnique.mockResolvedValue(mockBreed);

      const result = await service.findOne('1');

      expect(result).toEqual(mockBreed);
    });

    it('should throw NotFoundException when breed not found', async () => {
      mockPrismaService.breed.findUnique.mockResolvedValue(null);

      await expect(service.findOne('non-existent')).rejects.toThrow(NotFoundException);
    });
  });

  describe('update', () => {
    it('should update a breed successfully', async () => {
      const updateDto = { name: 'Updated Persian' };
      const mockBreed = { id: '1', name: 'Updated Persian' };

      mockPrismaService.breed.findUnique.mockResolvedValue({ id: '1', name: 'Persian' });
      mockPrismaService.breed.update.mockResolvedValue(mockBreed);

      const result = await service.update('1', updateDto);

      expect(result).toEqual(mockBreed);
      expect(mockPrismaService.breed.update).toHaveBeenCalledWith({
        where: { id: '1' },
        data: updateDto,
      });
    });

    it('should throw NotFoundException when updating non-existent breed', async () => {
      mockPrismaService.breed.findUnique.mockResolvedValue(null);

      await expect(service.update('non-existent', { name: 'Updated' })).rejects.toThrow(
        NotFoundException,
      );
    });
  });

  describe('remove', () => {
    it('should delete a breed successfully', async () => {
      const mockBreed = { id: '1', name: 'Persian' };

      mockPrismaService.breed.findUnique.mockResolvedValue(mockBreed);
      mockPrismaService.cat.count.mockResolvedValue(0);
      mockPrismaService.pedigree.count.mockResolvedValue(0);
      mockPrismaService.breed.delete.mockResolvedValue(mockBreed);

      await service.remove('1');

      expect(mockPrismaService.breed.delete).toHaveBeenCalledWith({
        where: { id: '1' },
      });
    });

    it('should throw NotFoundException when deleting non-existent breed', async () => {
      mockPrismaService.breed.findUnique.mockResolvedValue(null);

      await expect(service.remove('non-existent')).rejects.toThrow(NotFoundException);
    });
  });

  describe('getMasterData', () => {
    it('should return breed master data from prisma', async () => {
      const mockMaster = [
        { code: 1, name: 'Abyssinian' },
        { code: 2, name: 'American Curl(LH)' },
      ];

      mockPrismaService.breed.findMany.mockResolvedValue(mockMaster);

      const result = await service.getMasterData();

      expect(mockPrismaService.breed.findMany).toHaveBeenCalledWith({
        select: { code: true, name: true },
        where: { isActive: true },
        orderBy: { code: 'asc' },
      });
      expect(result).toEqual(mockMaster);
    });
  });
});
`````

## File: backend/src/breeds/breeds.service.ts
`````typescript
import { Injectable, NotFoundException } from "@nestjs/common";
import type { Prisma } from "@prisma/client";

import { PrismaService } from "../prisma/prisma.service";

import { CreateBreedDto, UpdateBreedDto, BreedQueryDto } from "./dto";

export type BreedMasterRecord = {
  code: number;
  name: string;
};

@Injectable()
export class BreedsService {
  constructor(private prisma: PrismaService) {}

  async create(createBreedDto: CreateBreedDto) {
    return this.prisma.breed.create({
      data: createBreedDto,
    });
  }

  async findAll(query: BreedQueryDto) {
    const {
      page = 1,
      limit = 50,
      search,
      sortBy = "name",
      sortOrder = "asc",
    } = query;

  const skip = (page - 1) * limit;
  const where: Prisma.BreedWhereInput = {};

    if (search) {
      where.OR = [
        { name: { contains: search, mode: "insensitive" } },
        { description: { contains: search, mode: "insensitive" } },
      ];
    }

    type Sortable = "name" | "createdAt" | "updatedAt" | "code";
    const sortMap: Record<string, Sortable> = {
      name: "name",
      nameEn: "name", // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒãªã„ãŸã‚ name ã¸ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      code: "code",
    };
    const sortKey = sortMap[sortBy] ?? "name";

    const [breeds, total] = await Promise.all([
      this.prisma.breed.findMany({
        where,
        skip,
        take: limit,
        include: {
          _count: {
            select: {
              cats: true,
            },
          },
        },
        orderBy: { [sortKey]: sortOrder } as Prisma.BreedOrderByWithRelationInput,
      }),
      this.prisma.breed.count({ where }),
    ]);

    return {
      data: breeds,
      meta: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  async findOne(id: string) {
    const breed = await this.prisma.breed.findUnique({
      where: { id },
      include: {
        cats: {
          include: {
            coatColor: true,
          },
          orderBy: {
            name: "asc",
          },
        },
        _count: {
          select: {
            cats: true,
          },
        },
      },
    });

    if (!breed) {
      throw new NotFoundException(`Breed with ID ${id} not found`);
    }

    return breed;
  }

  async update(id: string, updateBreedDto: UpdateBreedDto) {
    const existingBreed = await this.prisma.breed.findUnique({
      where: { id },
    });

    if (!existingBreed) {
      throw new NotFoundException(`Breed with ID ${id} not found`);
    }

    return this.prisma.breed.update({
      where: { id },
      data: updateBreedDto,
    });
  }

  async remove(id: string) {
    const existingBreed = await this.prisma.breed.findUnique({
      where: { id },
    });

    if (!existingBreed) {
      throw new NotFoundException(`Breed with ID ${id} not found`);
    }

    // Check if breed is being used
    const [catCount, pedigreeCount] = await Promise.all([
      this.prisma.cat.count({ where: { breedId: id } }),
      this.prisma.pedigree.count({ where: { breedCode: parseInt(id) } }),
    ]);

    if (catCount > 0 || pedigreeCount > 0) {
      throw new NotFoundException(
        `Cannot delete breed: ${catCount} cats and ${pedigreeCount} pedigrees are using this breed`,
      );
    }

    return this.prisma.breed.delete({
      where: { id },
    });
  }

  async getStatistics() {
    const [totalBreeds, mostPopularBreeds, breedDistribution] =
      await Promise.all([
        this.prisma.breed.count(),
        this.prisma.breed.findMany({
          include: {
            _count: {
              select: {
                cats: true,
              },
            },
          },
          orderBy: {
            cats: {
              _count: "desc",
            },
          },
          take: 10,
        }),
        this.prisma.cat.groupBy({
          by: ["breedId"],
          _count: true,
          orderBy: {
            _count: {
              breedId: "desc",
            },
          },
        }),
      ]);

    return {
      totalBreeds,
      mostPopularBreeds,
      breedDistribution,
    };
  }

  async getMasterData(): Promise<BreedMasterRecord[]> {
    return this.prisma.breed.findMany({
      select: { code: true, name: true },
      where: { isActive: true },
      orderBy: { code: "asc" },
    });
  }
}
`````

## File: backend/src/care/dto/care-query.dto.ts
`````typescript
import { ApiPropertyOptional } from "@nestjs/swagger";
import { CareType } from "@prisma/client";
import { Type } from "class-transformer";
import {
  IsDateString,
  IsEnum,
  IsInt,
  IsOptional,
  IsPositive,
  IsUUID,
  Min,
} from "class-validator";

export class CareQueryDto {
  @ApiPropertyOptional({ example: 1 })
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  page?: number = 1;

  @ApiPropertyOptional({ example: 20 })
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @IsPositive()
  limit?: number = 20;

  @ApiPropertyOptional({
    description: "çŒ«ID",
    example: "e7b6a7a7-2d7f-4b2f-9f3a-1c2b3d4e5f60",
  })
  @IsOptional()
  @IsUUID()
  catId?: string;

  @ApiPropertyOptional({
    description: "ã‚±ã‚¢ç¨®åˆ¥",
    enum: CareType,
    example: CareType.VACCINATION,
  })
  @IsOptional()
  @IsEnum(CareType)
  careType?: CareType;

  @ApiPropertyOptional({
    description: "é–‹å§‹æ—¥ (YYYY-MM-DD)",
    example: "2025-08-01",
  })
  @IsOptional()
  @IsDateString()
  dateFrom?: string;

  @ApiPropertyOptional({
    description: "çµ‚äº†æ—¥ (YYYY-MM-DD)",
    example: "2025-08-31",
  })
  @IsOptional()
  @IsDateString()
  dateTo?: string;
}
`````

## File: backend/src/care/dto/care-schedule-response.dto.ts
`````typescript
import { ApiProperty, ApiPropertyOptional } from "@nestjs/swagger";
import {
  CareType,
  Priority,
  ReminderChannel,
  ReminderOffsetUnit,
  ReminderRelativeTo,
  ReminderRepeatFrequency,
  ReminderTimingType,
  ScheduleStatus,
  ScheduleType,
} from "@prisma/client";

class CareScheduleCatDto {
  @ApiProperty({ example: "e7b6a7a7-2d7f-4b2f-9f3a-1c2b3d4e5f60" })
  id!: string;

  @ApiProperty({ example: "ãƒ¬ã‚ª" })
  name!: string;
}

class CareScheduleReminderDto {
  @ApiProperty({ example: "f1e2d3c4-b5a6-7890-1234-56789abcdef0" })
  id!: string;

  @ApiProperty({ enum: ReminderTimingType, example: ReminderTimingType.ABSOLUTE })
  timingType!: ReminderTimingType;

  @ApiPropertyOptional({ example: "2025-08-01T09:00:00.000Z" })
  remindAt!: string | null;

  @ApiPropertyOptional({ example: 2 })
  offsetValue!: number | null;

  @ApiPropertyOptional({ enum: ReminderOffsetUnit, example: ReminderOffsetUnit.DAY })
  offsetUnit!: ReminderOffsetUnit | null;

  @ApiPropertyOptional({ enum: ReminderRelativeTo, example: ReminderRelativeTo.START_DATE })
  relativeTo!: ReminderRelativeTo | null;

  @ApiProperty({ enum: ReminderChannel, example: ReminderChannel.IN_APP })
  channel!: ReminderChannel;

  @ApiPropertyOptional({
    enum: ReminderRepeatFrequency,
    example: ReminderRepeatFrequency.NONE,
  })
  repeatFrequency!: ReminderRepeatFrequency | null;

  @ApiPropertyOptional({ example: 1 })
  repeatInterval!: number | null;

  @ApiPropertyOptional({ example: 5 })
  repeatCount!: number | null;

  @ApiPropertyOptional({ example: "2025-12-31T00:00:00.000Z" })
  repeatUntil!: string | null;

  @ApiPropertyOptional({ example: "å‰æ—¥9æ™‚ã«é€šçŸ¥" })
  notes!: string | null;

  @ApiProperty({ example: true })
  isActive!: boolean;
}

class CareScheduleTagDto {
  @ApiProperty({ example: "a1b2c3d4-5678-90ab-cdef-1234567890ab" })
  id!: string;

  @ApiProperty({ example: "vaccination" })
  slug!: string;

  @ApiProperty({ example: "ãƒ¯ã‚¯ãƒãƒ³" })
  label!: string;

  @ApiProperty({ example: 1 })
  level!: number;

  @ApiPropertyOptional({ example: "parent-tag-id" })
  parentId!: string | null;
}

export class CareScheduleItemDto {
  @ApiProperty({ example: "a6f7e52f-4a3b-4a76-9870-1234567890ab" })
  id!: string;

  @ApiProperty({ example: "å¹´æ¬¡å¥åº·è¨ºæ–­" })
  name!: string;

  @ApiProperty({ example: "å¹´æ¬¡å¥åº·è¨ºæ–­" })
  title!: string;

  @ApiProperty({ example: "æ¯å¹´ã®å®šæœŸå¥è¨º" })
  description!: string | null;

  @ApiProperty({ example: "2025-09-01T00:00:00.000Z" })
  scheduleDate!: string;

  @ApiPropertyOptional({ example: "2025-09-01T01:00:00.000Z" })
  endDate!: string | null;

  @ApiPropertyOptional({ example: "Asia/Tokyo" })
  timezone!: string | null;

  @ApiProperty({ enum: ScheduleType, example: ScheduleType.CARE })
  scheduleType!: ScheduleType;

  @ApiProperty({ enum: ScheduleStatus, example: ScheduleStatus.PENDING })
  status!: ScheduleStatus;

  @ApiProperty({ enum: CareType, example: CareType.HEALTH_CHECK, nullable: true })
  careType!: CareType | null;

  @ApiProperty({ enum: Priority, example: Priority.MEDIUM })
  priority!: Priority;

  @ApiPropertyOptional({ example: "FREQ=YEARLY;INTERVAL=1" })
  recurrenceRule!: string | null;

  @ApiProperty({ example: "f3a2c1d7-1234-5678-90ab-cdef12345678" })
  assignedTo!: string;

  @ApiProperty({ type: CareScheduleCatDto, nullable: true })
  cat!: CareScheduleCatDto | null;

  @ApiProperty({ type: [CareScheduleCatDto], description: "å¯¾è±¡çŒ«ã®é…åˆ—" })
  cats!: CareScheduleCatDto[];

  @ApiProperty({ type: [CareScheduleReminderDto] })
  reminders!: CareScheduleReminderDto[];

  @ApiProperty({ type: [CareScheduleTagDto] })
  tags!: CareScheduleTagDto[];

  @ApiProperty({ example: "2025-08-01T00:00:00.000Z" })
  createdAt!: string;

  @ApiProperty({ example: "2025-08-15T12:34:56.000Z" })
  updatedAt!: string;
}

export class CareScheduleMetaDto {
  @ApiProperty({ example: 42 })
  total!: number;

  @ApiProperty({ example: 1 })
  page!: number;

  @ApiProperty({ example: 20 })
  limit!: number;

  @ApiProperty({ example: 3 })
  totalPages!: number;
}

export class CareScheduleResponseDto {
  @ApiProperty({ example: true })
  success!: true;

  @ApiProperty({ type: CareScheduleItemDto })
  data!: CareScheduleItemDto;
}

export class CareScheduleListResponseDto {
  @ApiProperty({ example: true })
  success!: true;

  @ApiProperty({ type: [CareScheduleItemDto] })
  data!: CareScheduleItemDto[];

  @ApiProperty({ type: CareScheduleMetaDto })
  meta!: CareScheduleMetaDto;
}

export class CareCompleteResponseDto {
  @ApiProperty({ example: true })
  success!: true;

  @ApiProperty({
    example: {
      scheduleId: "a6f7e52f-4a3b-4a76-9870-1234567890ab",
      recordId: "bcdef123-4567-890a-bcde-f1234567890a",
      medicalRecordId: "f1234567-89ab-cdef-0123-456789abcdef",
    },
  })
  data!: {
    scheduleId: string;
    recordId: string;
    medicalRecordId?: string | null;
  };
}

export type CareScheduleMeta = {
  total: number;
  page: number;
  limit: number;
  totalPages: number;
};

export type CareScheduleData = {
  id: string;
  name: string;
  title: string;
  description: string | null;
  scheduleDate: string;
  endDate: string | null;
  timezone: string | null;
  scheduleType: ScheduleType;
  status: ScheduleStatus;
  careType: CareType | null;
  priority: Priority;
  recurrenceRule: string | null;
  assignedTo: string;
  cat: { id: string; name: string } | null;
  cats: { id: string; name: string }[];
  reminders: {
    id: string;
    timingType: ReminderTimingType;
    remindAt: string | null;
    offsetValue: number | null;
    offsetUnit: ReminderOffsetUnit | null;
    relativeTo: ReminderRelativeTo | null;
    channel: ReminderChannel;
    repeatFrequency: ReminderRepeatFrequency | null;
    repeatInterval: number | null;
    repeatCount: number | null;
    repeatUntil: string | null;
    notes: string | null;
    isActive: boolean;
  }[];
  tags: {
    id: string;
    slug: string;
    label: string;
    level: number;
    parentId: string | null;
  }[];
  createdAt: string;
  updatedAt: string;
};

export type CareScheduleResponse = {
  success: true;
  data: CareScheduleData;
};

export type CareScheduleListResponse = {
  success: true;
  data: CareScheduleData[];
  meta: CareScheduleMeta;
};
`````

## File: backend/src/care/dto/complete-care.dto.ts
`````typescript
import { PartialType } from "@nestjs/mapped-types";
import { ApiPropertyOptional } from "@nestjs/swagger";
import { Type } from "class-transformer";
import {
  IsDateString,
  IsOptional,
  IsString,
  ValidateNested,
} from "class-validator";

import { CreateMedicalRecordDto } from "./create-medical-record.dto";

class CompleteCareMedicalRecordDto extends PartialType(CreateMedicalRecordDto) {}

export class CompleteCareDto {
  @ApiPropertyOptional({
    description: "å®Œäº†æ—¥ (YYYY-MM-DD)",
    example: "2025-08-10",
  })
  @IsOptional()
  @IsDateString()
  completedDate?: string;

  @ApiPropertyOptional({
    description: "æ¬¡å›äºˆå®šæ—¥ (YYYY-MM-DD)",
    example: "2026-08-10",
  })
  @IsOptional()
  @IsDateString()
  nextScheduledDate?: string;

  @ApiPropertyOptional({
    description: "ãƒ¡ãƒ¢",
    example: "ä½“èª¿è‰¯å¥½ã€‚æ¬¡å›ã¯ãƒ¯ã‚¯ãƒãƒ³Aã€‚",
  })
  @IsOptional()
  @IsString()
  notes?: string;

  @ApiPropertyOptional({ type: () => CompleteCareMedicalRecordDto })
  @IsOptional()
  @ValidateNested()
  @Type(() => CompleteCareMedicalRecordDto)
  medicalRecord?: CompleteCareMedicalRecordDto;
}
`````

## File: backend/src/care/dto/create-care-schedule.dto.ts
`````typescript
import { ApiProperty, ApiPropertyOptional } from "@nestjs/swagger";
import {
  CareType,
  Priority,
  ReminderChannel,
  ReminderOffsetUnit,
  ReminderRelativeTo,
  ReminderRepeatFrequency,
  ReminderTimingType,
} from "@prisma/client";
import { Type } from "class-transformer";
import {
  IsArray,
  IsBoolean,
  IsDateString,
  IsEnum,
  IsInt,
  IsNotEmpty,
  IsOptional,
  IsPositive,
  IsString,
  IsUUID,
  MaxLength,
  Min,
  MinLength,
  ValidateIf,
  ValidateNested,
} from "class-validator";

class ScheduleReminderDto {
  @ApiProperty({ enum: ReminderTimingType })
  @IsEnum(ReminderTimingType)
  timingType!: ReminderTimingType;

  @ApiPropertyOptional({
    description: "æŒ‡å®šæ—¥æ™‚ (ISO8601)",
    example: "2025-08-01T09:00:00.000Z",
  })
  @ValidateIf((o: ScheduleReminderDto) => o.timingType === ReminderTimingType.ABSOLUTE)
  @IsDateString()
  remindAt?: string;

  @ApiPropertyOptional({ description: "ç›¸å¯¾ãƒªãƒã‚¤ãƒ³ãƒ‰ã®å€¤", example: 2 })
  @ValidateIf((o: ScheduleReminderDto) => o.timingType === ReminderTimingType.RELATIVE)
  @IsInt()
  @Min(0)
  offsetValue?: number;

  @ApiPropertyOptional({ enum: ReminderOffsetUnit, example: ReminderOffsetUnit.DAY })
  @ValidateIf((o: ScheduleReminderDto) => o.timingType === ReminderTimingType.RELATIVE)
  @IsEnum(ReminderOffsetUnit)
  offsetUnit?: ReminderOffsetUnit;

  @ApiPropertyOptional({ enum: ReminderRelativeTo, example: ReminderRelativeTo.START_DATE })
  @ValidateIf((o: ScheduleReminderDto) => o.timingType === ReminderTimingType.RELATIVE)
  @IsEnum(ReminderRelativeTo)
  relativeTo?: ReminderRelativeTo;

  @ApiProperty({ enum: ReminderChannel, example: ReminderChannel.IN_APP })
  @IsEnum(ReminderChannel)
  channel!: ReminderChannel;

  @ApiPropertyOptional({
    enum: ReminderRepeatFrequency,
    example: ReminderRepeatFrequency.NONE,
  })
  @IsOptional()
  @IsEnum(ReminderRepeatFrequency)
  repeatFrequency?: ReminderRepeatFrequency;

  @ApiPropertyOptional({ description: "ç¹°ã‚Šè¿”ã—é–“éš”", example: 1 })
  @ValidateIf((o: ScheduleReminderDto) =>
    Boolean(o.repeatFrequency && o.repeatFrequency !== ReminderRepeatFrequency.NONE),
  )
  @IsInt()
  @IsPositive()
  repeatInterval?: number;

  @ApiPropertyOptional({ description: "ç¹°ã‚Šè¿”ã—å›æ•°", example: 5 })
  @ValidateIf((o: ScheduleReminderDto) =>
    Boolean(o.repeatFrequency && o.repeatFrequency !== ReminderRepeatFrequency.NONE),
  )
  @IsInt()
  @IsPositive()
  repeatCount?: number;

  @ApiPropertyOptional({ description: "ç¹°ã‚Šè¿”ã—çµ‚äº†æ—¥æ™‚", example: "2025-12-31T00:00:00.000Z" })
  @ValidateIf((o: ScheduleReminderDto) =>
    Boolean(o.repeatFrequency && o.repeatFrequency !== ReminderRepeatFrequency.NONE),
  )
  @IsDateString()
  repeatUntil?: string;

  @ApiPropertyOptional({ description: "å‚™è€ƒ", example: "å‰æ—¥9æ™‚ã«é€šçŸ¥" })
  @IsOptional()
  @IsString()
  @MaxLength(255)
  notes?: string;

  @ApiPropertyOptional({ description: "æœ‰åŠ¹ãƒ•ãƒ©ã‚°", example: true })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
}

export class CreateCareScheduleDto {
  @ApiProperty({
    description: "å¯¾è±¡çŒ«IDã®é…åˆ—",
    example: ["e7b6a7a7-2d7f-4b2f-9f3a-1c2b3d4e5f60"],
    type: [String],
  })
  @IsArray()
  @IsUUID(undefined, { each: true })
  catIds: string[];

  @ApiProperty({ description: "ã‚±ã‚¢å", example: "å¹´æ¬¡å¥åº·è¨ºæ–­" })
  @IsString()
  @MinLength(1)
  @MaxLength(120)
  name!: string;

  @ApiProperty({
    description: "ã‚±ã‚¢ç¨®åˆ¥",
    enum: CareType,
    example: CareType.HEALTH_CHECK,
  })
  @IsEnum(CareType)
  careType: CareType;

  @ApiProperty({ description: "äºˆå®šæ—¥ (ISO8601)", example: "2025-09-01" })
  @IsDateString()
  scheduledDate: string;

  @ApiPropertyOptional({ description: "çµ‚äº†æ—¥æ™‚ (ISO8601)", example: "2025-09-01T10:00:00.000Z" })
  @IsOptional()
  @IsDateString()
  endDate?: string;

  @ApiPropertyOptional({ description: "ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³", example: "Asia/Tokyo" })
  @IsOptional()
  @IsString()
  @IsNotEmpty()
  @MaxLength(80)
  timezone?: string;

  @ApiPropertyOptional({
    description: "ã‚±ã‚¢å/è©³ç´°",
    example: "å¥åº·è¨ºæ–­ (å¹´1å›)",
  })
  @IsOptional()
  @IsString()
  description?: string;

  @ApiPropertyOptional({ enum: Priority, example: Priority.MEDIUM })
  @IsOptional()
  @IsEnum(Priority)
  priority?: Priority;

  @ApiPropertyOptional({
    description: "RRULEå½¢å¼ãªã©ã®ç¹°ã‚Šè¿”ã—ãƒ«ãƒ¼ãƒ«",
    example: "FREQ=YEARLY;INTERVAL=1",
  })
  @IsOptional()
  @IsString()
  @MaxLength(255)
  recurrenceRule?: string;

  @ApiPropertyOptional({
    type: [ScheduleReminderDto],
    description: "ãƒªãƒã‚¤ãƒ³ãƒ€ãƒ¼è¨­å®š",
  })
  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => ScheduleReminderDto)
  reminders?: ScheduleReminderDto[];

  @ApiPropertyOptional({
    description: "é–¢é€£ã‚±ã‚¢ã‚¿ã‚°ID (æœ€å¤§3éšå±¤)",
    type: [String],
  })
  @IsOptional()
  @IsArray()
  @IsUUID(undefined, { each: true })
  careTagIds?: string[];
}

export type ScheduleReminderInput = ScheduleReminderDto;
`````

## File: backend/src/care/dto/create-medical-record.dto.ts
`````typescript
import { ApiProperty, ApiPropertyOptional } from "@nestjs/swagger";
import { MedicalRecordStatus } from "@prisma/client";
import { Type } from "class-transformer";
import {
  IsArray,
  IsDateString,
  IsEnum,
  IsInt,
  IsNotEmpty,
  IsOptional,
  IsPositive,
  IsString,
  IsUUID,
  MaxLength,
  ValidateNested,
} from "class-validator";

class MedicalRecordMedicationDto {
  @ApiProperty({ example: "æŠ—ç”Ÿç‰©è³ª" })
  @IsString()
  @IsNotEmpty()
  @MaxLength(120)
  name!: string;

  @ApiPropertyOptional({ example: "æœæ™© 1 éŒ " })
  @IsOptional()
  @IsString()
  @MaxLength(255)
  dosage?: string;
}

class MedicalRecordSymptomDto {
  @ApiProperty({ example: "ãã—ã‚ƒã¿" })
  @IsString()
  @IsNotEmpty()
  @MaxLength(120)
  label!: string;

  @ApiPropertyOptional({ example: "1é€±é–“ã»ã©ç¶šã„ã¦ã„ã‚‹" })
  @IsOptional()
  @IsString()
  @MaxLength(255)
  note?: string;
}

class MedicalRecordAttachmentInputDto {
  @ApiProperty({ example: "https://cdn.example.com/xray.png" })
  @IsString()
  @IsNotEmpty()
  url!: string;

  @ApiPropertyOptional({ example: "èƒ¸éƒ¨ãƒ¬ãƒ³ãƒˆã‚²ãƒ³" })
  @IsOptional()
  @IsString()
  @MaxLength(255)
  description?: string;

  @ApiPropertyOptional({ example: "xray.png" })
  @IsOptional()
  @IsString()
  @MaxLength(255)
  fileName?: string;

  @ApiPropertyOptional({ example: "image/png" })
  @IsOptional()
  @IsString()
  @MaxLength(100)
  fileType?: string;

  @ApiPropertyOptional({ example: 204800 })
  @IsOptional()
  @IsInt()
  @IsPositive()
  fileSize?: number;

  @ApiPropertyOptional({ example: "2025-08-10T09:30:00.000Z" })
  @IsOptional()
  @IsDateString()
  capturedAt?: string;
}

export class CreateMedicalRecordDto {
  @ApiProperty({ description: "çŒ«ID", example: "e7b6a7a7-2d7f-4b2f-9f3a-1c2b3d4e5f60" })
  @IsUUID()
  catId!: string;

  @ApiPropertyOptional({ description: "ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ID", example: "a6f7e52f-4a3b-4a76-9870-1234567890ab" })
  @IsOptional()
  @IsUUID()
  scheduleId?: string;

  @ApiProperty({ description: "å—è¨ºæ—¥", example: "2025-08-10" })
  @IsDateString()
  visitDate!: string;

  @ApiPropertyOptional({ description: "å—è¨ºç¨®åˆ¥ID", example: "c4a52a14-8d93-4b87-9f8c-7a6c2ef81234" })
  @IsOptional()
  @IsUUID()
  visitTypeId?: string;

  @ApiPropertyOptional({ example: "ã­ã“ã‚¯ãƒªãƒ‹ãƒƒã‚¯æ±äº¬" })
  @IsOptional()
  @IsString()
  @MaxLength(120)
  hospitalName?: string;

  @ApiPropertyOptional({ example: "ãã—ã‚ƒã¿ãŒæ­¢ã¾ã‚‰ãªã„" })
  @IsOptional()
  @IsString()
  @MaxLength(255)
  symptom?: string;

  @ApiPropertyOptional({ type: [MedicalRecordSymptomDto] })
  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => MedicalRecordSymptomDto)
  symptomDetails?: MedicalRecordSymptomDto[];

  @ApiPropertyOptional({ example: "çŒ«é¢¨é‚ª" })
  @IsOptional()
  @IsString()
  @MaxLength(120)
  diseaseName?: string;

  @ApiPropertyOptional({ example: "çŒ«é¢¨é‚ªã®å…†å€™" })
  @IsOptional()
  @IsString()
  diagnosis?: string;

  @ApiPropertyOptional({ example: "æŠ—ç”Ÿç‰©è³ªã‚’5æ—¥é–“æŠ•ä¸" })
  @IsOptional()
  @IsString()
  treatmentPlan?: string;

  @ApiPropertyOptional({ type: [MedicalRecordMedicationDto] })
  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => MedicalRecordMedicationDto)
  medications?: MedicalRecordMedicationDto[];

  @ApiPropertyOptional({ example: "2025-08-13" })
  @IsOptional()
  @IsDateString()
  followUpDate?: string;

  @ApiPropertyOptional({ example: "TREATING", enum: MedicalRecordStatus, default: MedicalRecordStatus.TREATING })
  @IsOptional()
  @IsEnum(MedicalRecordStatus)
  status?: MedicalRecordStatus;

  @ApiPropertyOptional({ example: "é£Ÿæ¬²ã‚‚æˆ»ã‚Šã¤ã¤ã‚ã‚Š" })
  @IsOptional()
  @IsString()
  notes?: string;

  @ApiPropertyOptional({ description: "é–¢é€£ã‚¿ã‚°ID", type: [String] })
  @IsOptional()
  @IsArray()
  @IsUUID(undefined, { each: true })
  tagIds?: string[];

  @ApiPropertyOptional({
    description: "æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ«",
    type: [MedicalRecordAttachmentInputDto],
  })
  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => MedicalRecordAttachmentInputDto)
  attachments?: MedicalRecordAttachmentInputDto[];
}

export type MedicalRecordMedicationInput = MedicalRecordMedicationDto;
export type MedicalRecordSymptomInput = MedicalRecordSymptomDto;
export type MedicalRecordAttachmentInput = MedicalRecordAttachmentInputDto;
`````

## File: backend/src/care/dto/index.ts
`````typescript
export * from "./care-query.dto";
export * from "./care-schedule-response.dto";
export * from "./complete-care.dto";
export * from "./create-care-schedule.dto";
export * from "./create-medical-record.dto";
export * from "./medical-record-query.dto";
export * from "./medical-record-response.dto";
`````

## File: backend/src/care/dto/medical-record-query.dto.ts
`````typescript
import { ApiPropertyOptional } from "@nestjs/swagger";
import { MedicalRecordStatus } from "@prisma/client";
import { Type } from "class-transformer";
import {
  IsDateString,
  IsEnum,
  IsInt,
  IsOptional,
  IsPositive,
  IsUUID,
  Min,
} from "class-validator";

export class MedicalRecordQueryDto {
  @ApiPropertyOptional({ example: 1 })
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  page?: number = 1;

  @ApiPropertyOptional({ example: 20 })
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @IsPositive()
  limit?: number = 20;

  @ApiPropertyOptional({ description: "çŒ«ID", example: "e7b6a7a7-2d7f-4b2f-9f3a-1c2b3d4e5f60" })
  @IsOptional()
  @IsUUID()
  catId?: string;

  @ApiPropertyOptional({ description: "ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ID", example: "a6f7e52f-4a3b-4a76-9870-1234567890ab" })
  @IsOptional()
  @IsUUID()
  scheduleId?: string;

  @ApiPropertyOptional({ description: "å—è¨ºç¨®åˆ¥ID", example: "c4a52a14-8d93-4b87-9f8c-7a6c2ef81234" })
  @IsOptional()
  @IsUUID()
  visitTypeId?: string;

  @ApiPropertyOptional({ enum: MedicalRecordStatus, example: MedicalRecordStatus.TREATING })
  @IsOptional()
  @IsEnum(MedicalRecordStatus)
  status?: MedicalRecordStatus;

  @ApiPropertyOptional({ description: "å—è¨ºé–‹å§‹æ—¥", example: "2025-08-01" })
  @IsOptional()
  @IsDateString()
  dateFrom?: string;

  @ApiPropertyOptional({ description: "å—è¨ºçµ‚äº†æ—¥", example: "2025-08-31" })
  @IsOptional()
  @IsDateString()
  dateTo?: string;
}
`````

## File: backend/src/care/dto/medical-record-response.dto.ts
`````typescript
import { ApiProperty, ApiPropertyOptional } from "@nestjs/swagger";
import { MedicalRecordStatus } from "@prisma/client";

class MedicalRecordCatDto {
  @ApiProperty({ example: "e7b6a7a7-2d7f-4b2f-9f3a-1c2b3d4e5f60" })
  id!: string;

  @ApiProperty({ example: "ãƒŸã‚±" })
  name!: string;
}

class MedicalRecordScheduleDto {
  @ApiProperty({ example: "a6f7e52f-4a3b-4a76-9870-1234567890ab" })
  id!: string;

  @ApiProperty({ example: "ãƒ¯ã‚¯ãƒãƒ³æ¥ç¨®" })
  name!: string;
}

class MedicalRecordVisitTypeDto {
  @ApiProperty({ example: "c4a52a14-8d93-4b87-9f8c-7a6c2ef81234" })
  id!: string;

  @ApiPropertyOptional({ example: "CHECKUP" })
  key!: string | null;

  @ApiProperty({ example: "å¥åº·è¨ºæ–­" })
  name!: string;

  @ApiPropertyOptional({ example: "å®šæœŸçš„ãªå¥åº·è¨ºæ–­" })
  description!: string | null;

  @ApiProperty({ example: 1 })
  displayOrder!: number;

  @ApiProperty({ example: true })
  isActive!: boolean;
}

class MedicalRecordTagDto {
  @ApiProperty({ example: "tag-123" })
  id!: string;

  @ApiProperty({ example: "ãƒ¯ã‚¯ãƒãƒ³" })
  name!: string;

  @ApiPropertyOptional({ example: "#3B82F6" })
  color!: string | null;

  @ApiPropertyOptional({ example: "#FFFFFF" })
  textColor!: string | null;

  @ApiProperty({ example: "group-123" })
  groupId!: string;

  @ApiPropertyOptional({ example: "åŒ»ç™‚" })
  groupName!: string | null;

  @ApiPropertyOptional({ example: "category-456" })
  categoryId!: string | null;

  @ApiPropertyOptional({ example: "åŒ»ç™‚ã‚¿ã‚°" })
  categoryName!: string | null;
}

class MedicalRecordAttachmentDto {
  @ApiProperty({ example: "https://cdn.example.com/xray.png" })
  url!: string;

  @ApiPropertyOptional({ example: "èƒ¸éƒ¨ãƒ¬ãƒ³ãƒˆã‚²ãƒ³" })
  description!: string | null;

  @ApiPropertyOptional({ example: "xray.png" })
  fileName!: string | null;

  @ApiPropertyOptional({ example: "image/png" })
  fileType!: string | null;

  @ApiPropertyOptional({ example: 204800 })
  fileSize!: number | null;

  @ApiPropertyOptional({ example: "2025-08-10T09:30:00.000Z" })
  capturedAt!: string | null;
}

class MedicalRecordMedicationDto {
  @ApiProperty({ example: "æŠ—ç”Ÿç‰©è³ª" })
  name!: string;

  @ApiPropertyOptional({ example: "æœæ™©1éŒ " })
  dosage!: string | null;
}

class MedicalRecordSymptomDto {
  @ApiProperty({ example: "ãã—ã‚ƒã¿" })
  label!: string;

  @ApiPropertyOptional({ example: "1é€±é–“ç¶™ç¶š" })
  note!: string | null;
}

export class MedicalRecordItemDto {
  @ApiProperty({ example: "bcdef123-4567-890a-bcde-f1234567890a" })
  id!: string;

  @ApiProperty({ example: "2025-08-10T00:00:00.000Z" })
  visitDate!: string;

  @ApiProperty({ type: MedicalRecordVisitTypeDto, nullable: true })
  visitType!: MedicalRecordVisitTypeDto | null;

  @ApiPropertyOptional({ example: "ã­ã“ã‚¯ãƒªãƒ‹ãƒƒã‚¯æ±äº¬" })
  hospitalName!: string | null;

  @ApiPropertyOptional({ example: "ãã—ã‚ƒã¿ãŒæ­¢ã¾ã‚‰ãªã„" })
  symptom!: string | null;

  @ApiPropertyOptional({ type: [MedicalRecordSymptomDto] })
  symptomDetails!: MedicalRecordSymptomDto[];

  @ApiPropertyOptional({ example: "çŒ«é¢¨é‚ª" })
  diseaseName!: string | null;

  @ApiPropertyOptional({ example: "çŒ«é¢¨é‚ªã®å…†å€™" })
  diagnosis!: string | null;

  @ApiPropertyOptional({ example: "æŠ—ç”Ÿç‰©è³ªã‚’5æ—¥é–“æŠ•ä¸" })
  treatmentPlan!: string | null;

  @ApiPropertyOptional({ type: [MedicalRecordMedicationDto] })
  medications!: MedicalRecordMedicationDto[];

  @ApiPropertyOptional({ example: "2025-08-13T00:00:00.000Z" })
  followUpDate!: string | null;

  @ApiProperty({ enum: MedicalRecordStatus, example: MedicalRecordStatus.TREATING })
  status!: MedicalRecordStatus;

  @ApiPropertyOptional({ example: "é£Ÿæ¬²ã¯æˆ»ã£ã¦ããŸ" })
  notes!: string | null;

  @ApiProperty({ type: MedicalRecordCatDto })
  cat!: MedicalRecordCatDto;

  @ApiPropertyOptional({ type: MedicalRecordScheduleDto, nullable: true })
  schedule!: MedicalRecordScheduleDto | null;

  @ApiProperty({ type: [MedicalRecordTagDto] })
  tags!: MedicalRecordTagDto[];

  @ApiProperty({ type: [MedicalRecordAttachmentDto] })
  attachments!: MedicalRecordAttachmentDto[];

  @ApiProperty({ example: "f3a2c1d7-1234-5678-90ab-cdef12345678" })
  recordedBy!: string;

  @ApiProperty({ example: "2025-08-10T09:30:00.000Z" })
  createdAt!: string;

  @ApiProperty({ example: "2025-08-15T12:34:56.000Z" })
  updatedAt!: string;
}

export class MedicalRecordMetaDto {
  @ApiProperty({ example: 42 })
  total!: number;

  @ApiProperty({ example: 1 })
  page!: number;

  @ApiProperty({ example: 20 })
  limit!: number;

  @ApiProperty({ example: 3 })
  totalPages!: number;
}

export class MedicalRecordResponseDto {
  @ApiProperty({ example: true })
  success!: true;

  @ApiProperty({ type: MedicalRecordItemDto })
  data!: MedicalRecordItemDto;
}

export class MedicalRecordListResponseDto {
  @ApiProperty({ example: true })
  success!: true;

  @ApiProperty({ type: [MedicalRecordItemDto] })
  data!: MedicalRecordItemDto[];

  @ApiProperty({ type: MedicalRecordMetaDto })
  meta!: MedicalRecordMetaDto;
}

export type MedicalRecordMeta = {
  total: number;
  page: number;
  limit: number;
  totalPages: number;
};

export type MedicalRecordData = {
  id: string;
  visitDate: string;
  visitType: {
    id: string;
    key: string | null;
    name: string;
    description: string | null;
    displayOrder: number;
    isActive: boolean;
  } | null;
  hospitalName: string | null;
  symptom: string | null;
  symptomDetails: { label: string; note: string | null }[];
  diseaseName: string | null;
  diagnosis: string | null;
  treatmentPlan: string | null;
  medications: { name: string; dosage: string | null }[];
  followUpDate: string | null;
  status: MedicalRecordStatus;
  notes: string | null;
  cat: { id: string; name: string };
  schedule: { id: string; name: string } | null;
  tags: {
    id: string;
    name: string;
    color: string | null;
    textColor: string | null;
    groupId: string;
    groupName: string | null;
    categoryId: string | null;
    categoryName: string | null;
  }[];
  attachments: {
    url: string;
    description: string | null;
    fileName: string | null;
    fileType: string | null;
    fileSize: number | null;
    capturedAt: string | null;
  }[];
  recordedBy: string;
  createdAt: string;
  updatedAt: string;
};

export type MedicalRecordResponse = {
  success: true;
  data: MedicalRecordData;
};

export type MedicalRecordListResponse = {
  success: true;
  data: MedicalRecordData[];
  meta: MedicalRecordMeta;
};
`````

## File: backend/src/care/care.controller.spec.ts
`````typescript
import { Test, TestingModule } from '@nestjs/testing';

import { getTestModuleImports, getTestModuleProviders } from '../test-utils/test-module-setup';

import { CareController } from './care.controller';
import { CareService } from './care.service';

describe('CareController', () => {
  let controller: CareController;
  let service: CareService;

  const mockCareService = {
    addSchedule: jest.fn(),
    findSchedules: jest.fn(),
    updateSchedule: jest.fn(),
    deleteSchedule: jest.fn(),
    complete: jest.fn(),
    addMedicalRecord: jest.fn(),
    findMedicalRecords: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      imports: getTestModuleImports(),
      controllers: [CareController],
      providers: [
        ...getTestModuleProviders(),
        {
          provide: CareService,
          useValue: mockCareService,
        },
      ],
    }).compile();

    controller = module.get<CareController>(CareController);
    service = module.get<CareService>(CareService);

    jest.clearAllMocks();
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });

  describe('addSchedule', () => {
    it('should create a care schedule', async () => {
      const createDto = {
        catIds: ['cat-1'],
        name: 'Vaccine',
        scheduledDate: '2024-12-01',
        careType: 'HEALTH_CHECK' as const,
      };
      const mockSchedule = { id: '1', ...createDto };

      mockCareService.addSchedule.mockResolvedValue(mockSchedule);

      const result = await controller.addSchedule(createDto, undefined);

      expect(result).toEqual(mockSchedule);
      expect(service.addSchedule).toHaveBeenCalledWith(createDto, undefined);
    });
  });

  describe('findSchedules', () => {
    it('should return paginated schedules', async () => {
      const mockResponse = {
        data: [{ id: '1', name: 'Vaccine' }],
        meta: { page: 1, limit: 10, total: 1, totalPages: 1 },
      };

      mockCareService.findSchedules.mockResolvedValue(mockResponse);

      const result = await controller.findSchedules({});

      expect(result).toEqual(mockResponse);
      expect(service.findSchedules).toHaveBeenCalledWith({});
    });
  });

  describe('complete', () => {
    it('should complete a care schedule', async () => {
      const completeDto = { notes: 'Completed successfully' };
      const mockSchedule = { success: true, data: { scheduleId: '1', recordId: 'record-1' } };

      mockCareService.complete.mockResolvedValue(mockSchedule);

      const result = await controller.complete('1', completeDto, undefined);

      expect(result).toEqual(mockSchedule);
      expect(service.complete).toHaveBeenCalledWith('1', completeDto, undefined);
    });
  });

  describe('addMedicalRecord', () => {
    it('should create a medical record', async () => {
      const createDto = {
        catId: 'cat-1',
        visitDate: '2024-01-15',
        diagnosis: 'Healthy',
      };
      const mockRecord = { id: '1', ...createDto };

      mockCareService.addMedicalRecord.mockResolvedValue(mockRecord);

      const result = await controller.addMedicalRecord(createDto, undefined);

      expect(result).toEqual(mockRecord);
      expect(service.addMedicalRecord).toHaveBeenCalledWith(createDto, undefined);
    });
  });

  describe('findMedicalRecords', () => {
    it('should return paginated medical records', async () => {
      const mockResponse = {
        data: [{ id: '1', diagnosis: 'Healthy' }],
        meta: { page: 1, limit: 10, total: 1, totalPages: 1 },
      };

      mockCareService.findMedicalRecords.mockResolvedValue(mockResponse);

      const result = await controller.findMedicalRecords({});

      expect(result).toEqual(mockResponse);
      expect(service.findMedicalRecords).toHaveBeenCalledWith({});
    });
  });

  describe('deleteSchedule', () => {
    it('should delete a schedule', async () => {
      const mockResponse = { success: true, message: 'Schedule deleted' };

      mockCareService.deleteSchedule.mockResolvedValue(mockResponse);

      const result = await controller.deleteSchedule('1');

      expect(result).toEqual(mockResponse);
      expect(service.deleteSchedule).toHaveBeenCalledWith('1');
    });
  });
});
`````

## File: backend/src/care/care.controller.ts
`````typescript
import {
  Body,
  Controller,
  Delete,
  Get,
  HttpStatus,
  Param,
  Patch,
  Put,
  Post,
  Query, UseGuards 
} from "@nestjs/common";
import {
  ApiBearerAuth,
  ApiOperation,
  ApiParam,
  ApiResponse,
  ApiTags,
} from "@nestjs/swagger";

import type { RequestUser } from "../auth/auth.types";
import { GetUser } from "../auth/get-user.decorator";
import { JwtAuthGuard } from "../auth/jwt-auth.guard";

import { CareService } from "./care.service";
import {
  CareCompleteResponseDto,
  CareQueryDto,
  CareScheduleListResponseDto,
  CareScheduleResponseDto,
  CompleteCareDto,
  CreateCareScheduleDto,
  CreateMedicalRecordDto,
  MedicalRecordListResponseDto,
  MedicalRecordQueryDto,
  MedicalRecordResponseDto,
} from "./dto";

@ApiTags("Care")
@Controller("care")
export class CareController {
  constructor(private readonly careService: CareService) {}

  @Get("schedules")
  @ApiOperation({ summary: "ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ä¸€è¦§ã®å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK, type: CareScheduleListResponseDto })
  findSchedules(@Query() query: CareQueryDto) {
    return this.careService.findSchedules(query);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Post("schedules")
  @ApiOperation({ summary: "ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®è¿½åŠ " })
  @ApiResponse({ status: HttpStatus.CREATED, type: CareScheduleResponseDto })
  addSchedule(
    @Body() dto: CreateCareScheduleDto,
    @GetUser() user?: RequestUser,
  ) {
    return this.careService.addSchedule(dto, user?.userId);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Patch("schedules/:id/complete")
  @Put("schedules/:id/complete")
  @ApiOperation({ summary: "ã‚±ã‚¢å®Œäº†å‡¦ç†ï¼ˆPATCH/PUTå¯¾å¿œï¼‰" })
  @ApiResponse({ status: HttpStatus.OK, type: CareCompleteResponseDto })
  @ApiParam({ name: "id" })
  complete(
    @Param("id") id: string,
    @Body() dto: CompleteCareDto,
    @GetUser() user?: RequestUser,
  ) {
    return this.careService.complete(id, dto, user?.userId);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Patch("schedules/:id")
  @ApiOperation({ summary: "ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æ›´æ–°" })
  @ApiResponse({ status: HttpStatus.OK, type: CareScheduleResponseDto })
  @ApiParam({ name: "id", description: "ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ID" })
  updateSchedule(
    @Param("id") id: string,
    @Body() dto: CreateCareScheduleDto,
    @GetUser() user?: RequestUser,
  ) {
    return this.careService.updateSchedule(id, dto, user?.userId);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Delete("schedules/:id")
  @ApiOperation({ summary: "ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å‰Šé™¤" })
  @ApiResponse({ status: HttpStatus.OK, description: "å‰Šé™¤æˆåŠŸ" })
  @ApiParam({ name: "id", description: "ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ID" })
  deleteSchedule(@Param("id") id: string) {
    return this.careService.deleteSchedule(id);
  }

  @Get("medical-records")
  @ApiOperation({ summary: "åŒ»ç™‚è¨˜éŒ²ä¸€è¦§ã®å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK, type: MedicalRecordListResponseDto })
  findMedicalRecords(@Query() query: MedicalRecordQueryDto) {
    return this.careService.findMedicalRecords(query);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Post("medical-records")
  @ApiOperation({ summary: "åŒ»ç™‚è¨˜éŒ²ã®è¿½åŠ " })
  @ApiResponse({ status: HttpStatus.CREATED, type: MedicalRecordResponseDto })
  addMedicalRecord(
    @Body() dto: CreateMedicalRecordDto,
    @GetUser() user?: RequestUser,
  ) {
    return this.careService.addMedicalRecord(dto, user?.userId);
  }
}
`````

## File: backend/src/care/care.module.ts
`````typescript
import { Module } from "@nestjs/common";

import { PrismaModule } from "../prisma/prisma.module";

import { CareController } from "./care.controller";
import { CareService } from "./care.service";

@Module({
  imports: [PrismaModule],
  controllers: [CareController],
  providers: [CareService],
})
export class CareModule {}
`````

## File: backend/src/care/care.service.spec.ts
`````typescript
import { NotFoundException } from '@nestjs/common';
import { Test, TestingModule } from '@nestjs/testing';

import { PrismaService } from '../prisma/prisma.service';

import { CareService } from './care.service';


describe('CareService', () => {
  let service: CareService;
  let _prismaService: PrismaService;

  const mockPrismaService = {
    careSchedule: {
      create: jest.fn(),
      findMany: jest.fn(),
      findUnique: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
      count: jest.fn(),
    },
    schedule: {
      create: jest.fn(),
      findMany: jest.fn(),
      findUnique: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
      count: jest.fn(),
    },
    medicalRecord: {
      create: jest.fn(),
      findMany: jest.fn(),
      findUnique: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
      count: jest.fn(),
    },
    careRecord: {
      create: jest.fn(),
      findMany: jest.fn(),
      findUnique: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
      count: jest.fn(),
    },
    cat: {
      findUnique: jest.fn(),
    },
    user: {
      findFirst: jest.fn(),
    },
    $transaction: jest.fn((args: any): any => {
      if (Array.isArray(args)) {
        return Promise.all(args);
      }
      return args(mockPrismaService);
    }),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        CareService,
        {
          provide: PrismaService,
          useValue: mockPrismaService,
        },
      ],
    }).compile();

    service = module.get<CareService>(CareService);
    _prismaService = module.get<PrismaService>(PrismaService);

    jest.clearAllMocks();
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('findSchedules', () => {
    it('should return paginated care schedules', async () => {
      const mockSchedules = [
        {
          id: '1',
          catId: 'cat-1',
          name: 'Vaccine',
          status: 'PENDING',
          scheduledDate: new Date(),
          reminders: [],
          tags: [],
        },
      ];

      mockPrismaService.schedule.count.mockResolvedValue(1);
      mockPrismaService.schedule.findMany.mockResolvedValue(mockSchedules);

      const result = await service.findSchedules({});

      expect(result.data).toBeDefined();
      expect(result.meta.total).toBe(1);
    });

    it('should filter schedules by catId', async () => {
      const mockSchedules = [
        {
          id: '1',
          catId: 'cat-1',
          name: 'Vaccine',
          scheduledDate: new Date(),
          reminders: [],
          tags: [],
        },
      ];

      mockPrismaService.schedule.count.mockResolvedValue(1);
      mockPrismaService.schedule.findMany.mockResolvedValue(mockSchedules);

      const result = await service.findSchedules({ catId: 'cat-1' });

      expect(result.data).toBeDefined();
    });
  });

  describe('addSchedule', () => {
    it('should create a care schedule successfully', async () => {
      const createDto = {
        name: 'Vaccine',
        catIds: ['cat-1'],
        scheduledDate: '2024-12-01',
        careType: 'HEALTH_CHECK' as const,
      };

      const mockSchedule = {
        id: '1',
        name: createDto.name,
        scheduledDate: new Date(createDto.scheduledDate),
        careType: createDto.careType,
        status: 'PENDING',
        createdAt: new Date(),
        reminders: [],
        tags: [],
      };

      mockPrismaService.user.findFirst.mockResolvedValue({ id: 'user-1' });
      mockPrismaService.schedule.create.mockResolvedValue(mockSchedule);

      const result = await service.addSchedule(createDto);

      expect(result).toBeDefined();
      expect(mockPrismaService.schedule.create).toHaveBeenCalled();
    });
  });

  describe('complete', () => {
    it('should complete a care schedule successfully', async () => {
      const mockSchedule = {
        id: '1',
        catId: 'cat-1',
        scheduleType: 'CARE',
        careType: 'HEALTH_CHECK',
      };

      const mockCareRecord = {
        id: 'record-1',
        scheduleId: '1',
        catId: 'cat-1',
      };

      mockPrismaService.user.findFirst.mockResolvedValue({ id: 'user-1' });
      mockPrismaService.schedule.findUnique.mockResolvedValue(mockSchedule);
      mockPrismaService.careRecord.create.mockResolvedValue(mockCareRecord);
      mockPrismaService.schedule.update.mockResolvedValue({ ...mockSchedule, status: 'COMPLETED' });

      const result = await service.complete('1', {});

      expect(result.success).toBe(true);
      expect(result.data).toBeDefined();
    });

    it('should throw NotFoundException for invalid schedule', async () => {
      mockPrismaService.schedule.findUnique.mockResolvedValue(null);

      await expect(service.complete('invalid', {})).rejects.toThrow(NotFoundException);
    });
  });

  describe('addMedicalRecord', () => {
    it('should create a medical record successfully', async () => {
      const createDto = {
        catId: 'cat-1',
        visitDate: '2024-01-15',
        diagnosis: 'Healthy',
        treatment: 'Regular checkup',
        veterinarian: 'Dr. Smith',
      };

      const mockRecord = {
        id: '1',
        catId: createDto.catId,
        visitDate: new Date(createDto.visitDate),
        diagnosis: createDto.diagnosis,
        treatment: createDto.treatment,
        veterinarian: createDto.veterinarian,
        createdAt: new Date(),
        updatedAt: new Date(),
        recordedBy: 'user-1',
        status: 'COMPLETED',
        cat: { id: 'cat-1', name: 'Test Cat' },
        schedule: null,
        tags: [],
        attachments: [],
      };

      mockPrismaService.user.findFirst.mockResolvedValue({ id: 'user-1' });
      mockPrismaService.cat.findUnique.mockResolvedValue({ id: 'cat-1', name: 'Test Cat' });
      mockPrismaService.medicalRecord.create.mockResolvedValue(mockRecord);

      const result = await service.addMedicalRecord(createDto);

      expect(result).toBeDefined();
      expect(result.success).toBe(true);
      expect(result.data.cat.id).toBe('cat-1');
      expect(mockPrismaService.medicalRecord.create).toHaveBeenCalled();
    });

    it('should throw NotFoundException for invalid cat', async () => {
      const createDto = {
        catId: 'invalid-cat',
        visitDate: '2024-01-15',
        diagnosis: 'Healthy',
      };

      mockPrismaService.user.findFirst.mockResolvedValue({ id: 'user-1' });
      // Mock Prisma to throw a foreign key constraint error
      mockPrismaService.medicalRecord.create.mockRejectedValue(
        new Error('Foreign key constraint failed on the field: `catId`')
      );

      await expect(service.addMedicalRecord(createDto)).rejects.toThrow();
    });
  });

  describe('findMedicalRecords', () => {
    it('should return paginated medical records', async () => {
      const mockRecords = [
        {
          id: '1',
          catId: 'cat-1',
          visitDate: new Date(),
          diagnosis: 'Healthy',
          createdAt: new Date(),
          updatedAt: new Date(),
          recordedBy: 'user-1',
          status: 'COMPLETED',
          cat: { id: 'cat-1', name: 'Test Cat' },
          schedule: null,
          tags: [],
          attachments: [],
        },
      ];

      mockPrismaService.medicalRecord.count.mockResolvedValue(1);
      mockPrismaService.medicalRecord.findMany.mockResolvedValue(mockRecords);

      const result = await service.findMedicalRecords({});

      expect(result.meta.total).toBe(1);
      expect(result.data).toBeDefined();
      expect(result.data[0].cat.id).toBe('cat-1');
    });
  });

  describe('deleteSchedule', () => {
    it('should delete a schedule successfully', async () => {
      const mockSchedule = { id: '1', name: 'Vaccine' };

      mockPrismaService.schedule.findUnique.mockResolvedValue(mockSchedule);
      mockPrismaService.schedule.delete.mockResolvedValue(mockSchedule);

      const result = await service.deleteSchedule('1');

      expect(result.success).toBe(true);
      expect(mockPrismaService.schedule.delete).toHaveBeenCalledWith({
        where: { id: '1' },
      });
    });

    it('should throw NotFoundException for invalid schedule', async () => {
      mockPrismaService.schedule.findUnique.mockResolvedValue(null);

      await expect(service.deleteSchedule('invalid')).rejects.toThrow(NotFoundException);
    });
  });
});
`````

## File: backend/src/care/care.service.ts
`````typescript
import { Injectable, NotFoundException } from "@nestjs/common";
import {
  CareType,
  MedicalRecordStatus,
  Priority,
  Prisma,
  ReminderRepeatFrequency,
  ScheduleStatus,
  ScheduleType,
} from "@prisma/client";

import { PrismaService } from "../prisma/prisma.service";


import {
  CareQueryDto,
  CompleteCareDto,
  CreateCareScheduleDto,
  CreateMedicalRecordDto,
  MedicalRecordQueryDto,
} from "./dto";
import type {
  CareScheduleListResponse,
  CareScheduleMeta,
  CareScheduleResponse,
} from "./dto/care-schedule-response.dto";
import type { ScheduleReminderInput } from "./dto/create-care-schedule.dto";
import type { MedicalRecordAttachmentInput } from "./dto/create-medical-record.dto";
import type {
  MedicalRecordData,
  MedicalRecordListResponse,
  MedicalRecordMeta,
  MedicalRecordResponse,
} from "./dto/medical-record-response.dto";
import {
  parseSymptomDetails,
  parseMedications,
  mapDtoToSymptomDetails,
  mapDtoToMedications,
  serializeSymptomDetails,
  serializeMedications,
} from "./json-value.utils";
import {
  parseRRule,
  calculateNextScheduleDate,
} from "./recurrence.utils";

const scheduleListInclude = {
  cat: { select: { id: true, name: true } },
  scheduleCats: { include: { cat: { select: { id: true, name: true } } } },
  reminders: true,
  tags: { include: { careTag: true } },
} as const;

const scheduleMinimalInclude = {
  cat: { select: { id: true, name: true } },
  tags: { select: { careTagId: true } },
} as const;

const medicalRecordInclude = {
  cat: { select: { id: true, name: true } },
  schedule: { select: { id: true, name: true } },
  visitType: true,
  tags: {
    include: {
      tag: {
        include: {
          group: {
            include: {
              category: true,
            },
          },
        },
      },
    },
  },
  attachments: true,
} as const;

type ScheduleWithRelations = Prisma.ScheduleGetPayload<{
  include: typeof scheduleListInclude;
}>;

type ScheduleCatRelation = {
  cat: { id: string; name: string };
};

// Properly typed MedicalRecord with relations
type MedicalRecordWithRelations = Prisma.MedicalRecordGetPayload<{
  include: typeof medicalRecordInclude;
}>;

type PrismaExecutor = Prisma.TransactionClient | PrismaService;

type MedicalRecordCreateInput = Partial<CreateMedicalRecordDto> & {
  catId?: string;
  scheduleId?: string;
  visitDate?: string;
  visitTypeId?: string;
};

// Extended types for scheduleCats relation
type ScheduleCreateWithCats = Omit<Prisma.ScheduleUncheckedCreateInput, 'scheduleCats'> & {
  scheduleCats?: {
    create?: Array<{
      cat: {
        connect: {
          id: string;
        };
      };
    }>;
  };
};

type ScheduleUpdateWithCats = Omit<Prisma.ScheduleUncheckedUpdateInput, 'scheduleCats'> & {
  scheduleCats?: {
    deleteMany?: Record<string, never>;
    create?: Array<{
      cat: {
        connect: {
          id: string;
        };
      };
    }>;
  };
};

const toIsoString = (value?: Date | null): string | null =>
  value ? value.toISOString() : null;

@Injectable()
export class CareService {
  constructor(private readonly prisma: PrismaService) {}

  async findSchedules(query: CareQueryDto): Promise<CareScheduleListResponse> {
    const { page = 1, limit = 20, catId, careType, dateFrom, dateTo } = query;
    const where: Prisma.ScheduleWhereInput = {
      scheduleType: ScheduleType.CARE,
    };
    if (catId) where.catId = catId;
    if (careType) {
      Object.assign(where, { careType });
    }
    if (dateFrom || dateTo) {
      const dateFilter: Prisma.DateTimeFilter = {};
      if (dateFrom) dateFilter.gte = new Date(dateFrom);
      if (dateTo) dateFilter.lte = new Date(dateTo);
      where.scheduleDate = dateFilter;
    }

    const [total, schedules] = await this.prisma.$transaction([
      this.prisma.schedule.count({ where }),
      this.prisma.schedule.findMany({
        where,
        include: scheduleListInclude,
        orderBy: { scheduleDate: "desc" },
        skip: (page - 1) * limit,
        take: limit,
      }),
    ]);

    const meta: CareScheduleMeta = {
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit),
    };

    return {
      success: true,
      data: schedules.map((schedule) => this.mapScheduleToResponse(schedule as ScheduleWithRelations)),
      meta,
    };
  }

  async addSchedule(
    dto: CreateCareScheduleDto,
    userId?: string,
  ): Promise<CareScheduleResponse> {
    const assignedUserId = await this.resolveUserId(userId);

    const reminderCreates = (dto.reminders ?? []).map((reminder) =>
      this.buildReminderCreateInput(reminder),
    );

    // æœ€åˆã®çŒ«IDã‚’æ—§catIdãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«è¨­å®šï¼ˆå¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ï¼‰
    const primaryCatId = dto.catIds?.[0];

    const createData: ScheduleCreateWithCats = {
      catId: primaryCatId,
      name: dto.name,
      title: dto.name,
      description: dto.description,
      scheduleType: ScheduleType.CARE,
      scheduleDate: new Date(dto.scheduledDate),
      endDate: dto.endDate ? new Date(dto.endDate) : undefined,
      timezone: dto.timezone,
      careType: dto.careType ?? null,
      status: ScheduleStatus.PENDING,
      priority: dto.priority ?? Priority.MEDIUM,
      recurrenceRule: dto.recurrenceRule,
      assignedTo: assignedUserId,
      reminders: reminderCreates.length
        ? { create: reminderCreates }
        : undefined,
      tags: dto.careTagIds?.length
        ? {
            create: dto.careTagIds.map((careTagId) => ({
              careTag: { connect: { id: careTagId } },
            })),
          }
        : undefined,
      scheduleCats: dto.catIds?.length
        ? {
            create: dto.catIds.map((catId) => ({
              cat: { connect: { id: catId } },
            })),
          }
        : undefined,
    };

    const schedule = await this.prisma.schedule.create({
      data: createData as unknown as Prisma.ScheduleCreateInput,
      include: scheduleListInclude,
    });

    return {
      success: true,
      data: this.mapScheduleToResponse(schedule as ScheduleWithRelations),
    };
  }

  async complete(
    id: string,
    dto: CompleteCareDto,
    userId?: string,
  ): Promise<{
    success: true;
    data: { scheduleId: string; recordId: string; medicalRecordId?: string | null };
  }> {
    const recorderId = await this.resolveUserId(userId);

    const existing = await this.prisma.schedule.findUnique({
      where: { id },
      include: scheduleMinimalInclude,
    });

    if (!existing) {
      throw new NotFoundException("ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
    }

    const completedDate = dto.completedDate ? new Date(dto.completedDate) : new Date();
    const hospitalName = this.normalizeOptionalText(dto.medicalRecord?.hospitalName);

    // æ¬¡å›äºˆå®šæ—¥ã®æ±ºå®š: æ˜ç¤ºçš„ã«æŒ‡å®šãŒãªã‘ã‚Œã°RRULEã‹ã‚‰è‡ªå‹•è¨ˆç®—
    const followUpDate = this.calculateFollowUpDate(dto, existing, completedDate);

    const result = await this.prisma.$transaction(async (tx) => {
      const updated = await tx.schedule.update({
        where: { id },
        data: { status: ScheduleStatus.COMPLETED },
      });

      // æ¬¡å›äºˆå®šãŒå­˜åœ¨ã™ã‚‹å ´åˆã€æ–°è¦ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½œæˆ
      if (followUpDate) {
        await this.createFollowUpSchedule(tx, existing, updated.assignedTo, followUpDate, dto.notes);
      }

      const careRecord = await tx.careRecord.create({
        data: {
          catId: existing.catId ?? '',
          careType: (existing.careType as CareType | null) ?? CareType.OTHER,
          description: existing.name,
          careDate: completedDate,
          nextDueDate: followUpDate,
          notes: dto.notes,
          veterinarian: hospitalName,
          recordedBy: recorderId,
        },
      });

      let medicalRecordId: string | null = null;
      if (dto.medicalRecord) {
        const catId = existing.catId ?? '';
        const record = await this.createMedicalRecordEntity(tx, dto.medicalRecord, recorderId, {
          catId: catId,
          scheduleId: existing.id,
        });
        medicalRecordId = record.id;
      }

      return { updated, careRecord, medicalRecordId };
    });

    return {
      success: true,
      data: {
        scheduleId: result.updated.id,
        recordId: result.careRecord.id,
        medicalRecordId: result.medicalRecordId,
      },
    };
  }

  async findMedicalRecords(
    query: MedicalRecordQueryDto,
  ): Promise<MedicalRecordListResponse> {
    const {
      page = 1,
      limit = 20,
      catId,
      scheduleId,
      visitTypeId,
      status,
      dateFrom,
      dateTo,
    } = query;

    const where: Prisma.MedicalRecordWhereInput = {};
    if (catId) where.catId = catId;
    if (scheduleId) where.scheduleId = scheduleId;
    if (visitTypeId) where.visitTypeId = visitTypeId;
    if (status) where.status = status;
    if (dateFrom || dateTo) {
      const dateFilter: Prisma.DateTimeFilter = {};
      if (dateFrom) dateFilter.gte = new Date(dateFrom);
      if (dateTo) dateFilter.lte = new Date(dateTo);
      where.visitDate = dateFilter;
    }

    const [total, records] = await this.prisma.$transaction([
      this.prisma.medicalRecord.count({ where }),
      this.prisma.medicalRecord.findMany({
        where,
        include: medicalRecordInclude,
        orderBy: { visitDate: "desc" },
        skip: (page - 1) * limit,
        take: limit,
      }),
    ]);

    const meta: MedicalRecordMeta = {
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit),
    };

    return {
      success: true,
      data: records.map((record) => this.mapMedicalRecordToResponse(record)),
      meta,
    };
  }

  async updateSchedule(
    id: string,
    dto: CreateCareScheduleDto,
    userId?: string,
  ): Promise<CareScheduleResponse> {
    const assignedUserId = await this.resolveUserId(userId);

    const existing = await this.prisma.schedule.findUnique({
      where: { id },
    });

    if (!existing) {
      throw new NotFoundException("Schedule not found");
    }

    const reminderCreates = (dto.reminders ?? []).map((reminder) =>
      this.buildReminderCreateInput(reminder),
    );

    const primaryCatId = dto.catIds?.[0];

    const updateData: ScheduleUpdateWithCats = {
      catId: primaryCatId,
      name: dto.name,
      title: dto.name,
      description: dto.description,
      scheduleDate: new Date(dto.scheduledDate),
      endDate: dto.endDate ? new Date(dto.endDate) : undefined,
      timezone: dto.timezone,
      careType: dto.careType ?? null,
      priority: dto.priority ?? Priority.MEDIUM,
      recurrenceRule: dto.recurrenceRule,
      assignedTo: assignedUserId,
      reminders: {
        deleteMany: {},
        create: reminderCreates,
      },
      tags: {
        deleteMany: {},
        create: dto.careTagIds?.length
          ? dto.careTagIds.map((careTagId) => ({
              careTag: { connect: { id: careTagId } },
            }))
          : undefined,
      },
      scheduleCats: {
        deleteMany: {},
        create: dto.catIds?.length
          ? dto.catIds.map((catId) => ({
              cat: { connect: { id: catId } },
            }))
          : undefined,
      },
    };

    const schedule = await this.prisma.schedule.update({
      where: { id },
      data: updateData as unknown as Prisma.ScheduleUpdateInput,
      include: scheduleListInclude,
    });

    return {
      success: true,
      data: this.mapScheduleToResponse(schedule as ScheduleWithRelations),
    };
  }

  async deleteSchedule(id: string): Promise<{ success: true; message: string }> {
    const existing = await this.prisma.schedule.findUnique({
      where: { id },
    });

    if (!existing) {
      throw new NotFoundException("Schedule not found");
    }

    await this.prisma.schedule.delete({
      where: { id },
    });

    return {
      success: true,
      message: "Schedule deleted successfully",
    };
  }

  async addMedicalRecord(
    dto: CreateMedicalRecordDto,
    userId?: string,
  ): Promise<MedicalRecordResponse> {
    const recorderId = await this.resolveUserId(userId);
    const record = await this.createMedicalRecordEntity(this.prisma, dto, recorderId);

    return {
      success: true,
      data: this.mapMedicalRecordToResponse(record),
    };
  }

  private async resolveUserId(userId?: string): Promise<string> {
    if (userId) {
      return userId;
    }

    const user = await this.prisma.user.findFirst({ select: { id: true } });
    if (!user) {
      throw new NotFoundException("Assignee user not found");
    }
    return user.id;
  }

  private buildReminderCreateInput(
    reminder: ScheduleReminderInput,
  ): Prisma.ScheduleReminderUncheckedCreateWithoutScheduleInput {
    return {
      timingType: reminder.timingType,
      remindAt: reminder.remindAt ? new Date(reminder.remindAt) : undefined,
      offsetValue: reminder.offsetValue ?? null,
      offsetUnit: reminder.offsetUnit ?? null,
      relativeTo: reminder.relativeTo ?? null,
      channel: reminder.channel,
      repeatFrequency: reminder.repeatFrequency ?? ReminderRepeatFrequency.NONE,
      repeatInterval: reminder.repeatInterval ?? null,
      repeatCount: reminder.repeatCount ?? null,
      repeatUntil: reminder.repeatUntil ? new Date(reminder.repeatUntil) : undefined,
      notes: reminder.notes ?? null,
      isActive: reminder.isActive ?? true,
    };
  }

  private mapScheduleToResponse(
    schedule: ScheduleWithRelations,
  ): CareScheduleResponse["data"] {
    const sortedReminders = [...schedule.reminders].sort((a, b) => {
      const aTime = a.remindAt?.getTime() ?? 0;
      const bTime = b.remindAt?.getTime() ?? 0;
      if (aTime !== bTime) return aTime - bTime;
      return a.createdAt.getTime() - b.createdAt.getTime();
    });

    const reminders = sortedReminders.map((reminder) => ({
      id: reminder.id,
      timingType: reminder.timingType,
      remindAt: toIsoString(reminder.remindAt),
      offsetValue: reminder.offsetValue ?? null,
      offsetUnit: reminder.offsetUnit ?? null,
      relativeTo: reminder.relativeTo ?? null,
      channel: reminder.channel,
      repeatFrequency: reminder.repeatFrequency ?? ReminderRepeatFrequency.NONE,
      repeatInterval: reminder.repeatInterval ?? null,
      repeatCount: reminder.repeatCount ?? null,
      repeatUntil: toIsoString(reminder.repeatUntil),
      notes: reminder.notes ?? null,
      isActive: reminder.isActive,
    }));

    const tags = schedule.tags
      .map(({ careTag }) => ({
        id: careTag.id,
        slug: careTag.slug,
        label: careTag.label,
        level: careTag.level,
        parentId: careTag.parentId ?? null,
      }))
      .sort((a, b) => a.level - b.level);

    return {
      id: schedule.id,
      name: schedule.name ?? schedule.title,
      title: schedule.title,
      description: schedule.description ?? null,
      scheduleDate: toIsoString(schedule.scheduleDate)!,
      endDate: toIsoString(schedule.endDate),
      timezone: schedule.timezone ?? null,
      scheduleType: schedule.scheduleType,
      status: schedule.status,
      careType: (schedule.careType as CareType | null) ?? null,
      priority: schedule.priority ?? Priority.MEDIUM,
      recurrenceRule: schedule.recurrenceRule ?? null,
      assignedTo: schedule.assignedTo,
      cat: schedule.cat ? { id: schedule.cat.id, name: schedule.cat.name } : null,
      cats: Array.isArray(schedule.scheduleCats)
        ? (schedule.scheduleCats as ScheduleCatRelation[]).map((sc) => ({
            id: sc.cat.id,
            name: sc.cat.name,
          }))
        : [],
      reminders,
      tags,
      createdAt: toIsoString(schedule.createdAt)!,
      updatedAt: toIsoString(schedule.updatedAt)!,
    };
  }

  private mapMedicalRecordToResponse(
    record: MedicalRecordWithRelations,
  ): MedicalRecordData {
    // å‹å®‰å…¨ãªJSONå¤‰æ›ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚’ä½¿ç”¨
    const symptomDetails = parseSymptomDetails(record.symptomDetails);
    const medications = parseMedications(record.medications);

    const visitType = record.visitType
      ? {
          id: record.visitType.id,
          key: record.visitType.key ?? null,
          name: record.visitType.name,
          description: record.visitType.description ?? null,
          displayOrder: record.visitType.displayOrder,
          isActive: record.visitType.isActive,
        }
      : null;

    const tags = record.tags
      .map((medicalRecordTag) => {
        const tag = medicalRecordTag.tag;
        if (!tag) {
          return null;
        }
        const group = tag.group ?? null;
        const category = group?.category ?? null;
        return {
          id: tag.id,
          name: tag.name,
          color: tag.color ?? null,
          textColor: tag.textColor ?? null,
          groupId: tag.groupId,
          groupName: group?.name ?? null,
          categoryId: group?.categoryId ?? null,
          categoryName: category?.name ?? null,
        };
      })
      .filter((item): item is NonNullable<typeof item> => item !== null)
      .sort((a, b) => a.name.localeCompare(b.name, "ja"));

    const attachments = record.attachments.map((attachment) => ({
      url: attachment.url,
      description: attachment.description ?? null,
      fileName: attachment.fileName ?? null,
      fileType: attachment.fileType ?? null,
      fileSize: attachment.fileSize ?? null,
      capturedAt: toIsoString(attachment.capturedAt),
    }));

    return {
      id: record.id,
      visitDate: toIsoString(record.visitDate)!,
      visitType,
      hospitalName: record.hospitalName ?? null,
      symptom: record.symptom ?? null,
      symptomDetails,
      diseaseName: record.diseaseName ?? null,
      diagnosis: record.diagnosis ?? null,
      treatmentPlan: record.treatmentPlan ?? null,
      medications,
      followUpDate: toIsoString(record.followUpDate),
      status: record.status,
      notes: record.notes ?? null,
      cat: { id: record.cat.id, name: record.cat.name },
      schedule: record.schedule
        ? { id: record.schedule.id, name: record.schedule.name }
        : null,
      tags,
      attachments,
      recordedBy: record.recordedBy,
      createdAt: toIsoString(record.createdAt)!,
      updatedAt: toIsoString(record.updatedAt)!,
    };
  }

  private async createMedicalRecordEntity(
    executor: PrismaExecutor,
    dto: MedicalRecordCreateInput,
    recorderId: string,
    defaults: { catId?: string; scheduleId?: string; visitTypeId?: string } = {},
  ): Promise<MedicalRecordWithRelations> {
    const catId = dto.catId ?? defaults.catId;
    if (!catId) {
      throw new NotFoundException("çŒ«IDã¯å¿…é ˆã§ã™");
    }

    // å‹å®‰å…¨ãªãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚’ä½¿ç”¨ã—ã¦DTOã‚’å¤‰æ›
    const symptomDetails = mapDtoToSymptomDetails(dto.symptomDetails);
    const medications = mapDtoToMedications(dto.medications);

    const attachments = dto.attachments ?? [];
    const hospitalName = this.normalizeOptionalText(dto.hospitalName);

    const record = await executor.medicalRecord.create({
      data: {
        catId,
        scheduleId: dto.scheduleId ?? defaults.scheduleId,
        recordedBy: recorderId,
        visitDate: new Date(dto.visitDate ?? dto.followUpDate ?? new Date()),
        visitTypeId: dto.visitTypeId ?? defaults.visitTypeId,
        hospitalName,
        symptom: dto.symptom,
        symptomDetails: serializeSymptomDetails(symptomDetails),
        diagnosis: dto.diagnosis,
        treatmentPlan: dto.treatmentPlan,
        medications: serializeMedications(medications),
        followUpDate: dto.followUpDate ? new Date(dto.followUpDate) : undefined,
        status: dto.status ?? MedicalRecordStatus.TREATING,
        notes: dto.notes,
        tags: dto.tagIds?.length
          ? {
              create: dto.tagIds.map((tagId) => ({
                tagId: tagId,
              })),
            }
          : undefined,
        attachments: attachments.length
          ? {
              create: attachments.map((attachment: MedicalRecordAttachmentInput) => ({
                url: attachment.url,
                description: attachment.description,
                fileName: attachment.fileName,
                fileType: attachment.fileType,
                fileSize: attachment.fileSize,
                capturedAt: attachment.capturedAt ? new Date(attachment.capturedAt) : undefined,
              })),
            }
          : undefined,
      },
      include: medicalRecordInclude,
    });

    return record;
  }

  private normalizeOptionalText(value?: string | null): string | undefined {
    if (typeof value !== "string") {
      return undefined;
    }
    const trimmed = value.trim();
    return trimmed.length > 0 ? trimmed : undefined;
  }

  /**
   * æ¬¡å›äºˆå®šæ—¥ã‚’è¨ˆç®—ã™ã‚‹
   * - æ˜ç¤ºçš„ãªæŒ‡å®šãŒã‚ã‚Œã°ãã‚Œã‚’ä½¿ç”¨
   * - ãªã‘ã‚Œã°RRULEã‹ã‚‰è‡ªå‹•è¨ˆç®—
   */
  private calculateFollowUpDate(
    dto: CompleteCareDto,
    existing: {
      recurrenceRule: string | null;
      scheduleDate: Date;
    },
    completedDate: Date,
  ): Date | undefined {
    // æ˜ç¤ºçš„ã«æ¬¡å›äºˆå®šæ—¥ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ãã‚Œã‚’ä½¿ç”¨
    if (dto.nextScheduledDate) {
      return new Date(dto.nextScheduledDate);
    }

    // RRULEãŒå­˜åœ¨ã™ã‚‹å ´åˆã€æ¬¡å›äºˆå®šæ—¥ã‚’è‡ªå‹•è¨ˆç®—
    const parsedRule = parseRRule(existing.recurrenceRule);
    if (!parsedRule) {
      return undefined;
    }

    // åŸºæº–æ—¥: å®Œäº†æ—¥ã¾ãŸã¯ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«æ—¥ã®ã†ã¡æ–°ã—ã„æ–¹
    const baseDate = completedDate > existing.scheduleDate ? completedDate : existing.scheduleDate;
    const nextDate = calculateNextScheduleDate(parsedRule, baseDate);

    return nextDate ?? undefined;
  }

  /**
   * ãƒ•ã‚©ãƒ­ãƒ¼ã‚¢ãƒƒãƒ—ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½œæˆã™ã‚‹
   */
  private async createFollowUpSchedule(
    tx: Prisma.TransactionClient,
    existing: {
      catId: string | null;
      name: string;
      description: string | null;
      timezone: string | null;
      careType: CareType | null;
      priority: Priority;
      recurrenceRule: string | null;
      tags: Array<{ careTagId: string }>;
    },
    assignedTo: string,
    followUpDate: Date,
    notes?: string,
  ): Promise<void> {
    await tx.schedule.create({
      data: {
        catId: existing.catId ?? undefined,
        name: existing.name,
        title: existing.name,
        description: notes ?? existing.description ?? undefined,
        scheduleType: ScheduleType.CARE,
        scheduleDate: followUpDate,
        timezone: existing.timezone ?? undefined,
        careType: existing.careType,
        status: ScheduleStatus.PENDING,
        priority: existing.priority ?? Priority.MEDIUM,
        recurrenceRule: existing.recurrenceRule ?? undefined,
        assignedTo: assignedTo,
        tags: existing.tags.length
          ? {
              create: existing.tags.map(({ careTagId }) => ({
                careTag: { connect: { id: careTagId } },
              })),
            }
          : undefined,
      },
    });
  }
}
`````

## File: backend/src/care/json-value.utils.spec.ts
`````typescript
/**
 * json-value.utils.ts ã®å˜ä½“ãƒ†ã‚¹ãƒˆ
 */

import { Prisma } from "@prisma/client";

import {
  parseSymptomDetails,
  parseMedications,
  mapDtoToSymptomDetails,
  mapDtoToMedications,
  serializeSymptomDetails,
  serializeMedications,
} from "./json-value.utils";

describe("JsonValueUtils", () => {
  describe("parseSymptomDetails", () => {
    it("nullã®å ´åˆã¯ç©ºé…åˆ—ã‚’è¿”ã™", () => {
      expect(parseSymptomDetails(null)).toEqual([]);
      expect(parseSymptomDetails(undefined)).toEqual([]);
    });

    it("é…åˆ—ã§ãªã„å ´åˆã¯ç©ºé…åˆ—ã‚’è¿”ã™", () => {
      expect(parseSymptomDetails("string" as Prisma.JsonValue)).toEqual([]);
      expect(parseSymptomDetails({ key: "value" } as Prisma.JsonValue)).toEqual([]);
    });

    it("æœ‰åŠ¹ãªç—‡çŠ¶è©³ç´°é…åˆ—ã‚’è§£æã§ãã‚‹", () => {
      const input = [
        { label: "ãã—ã‚ƒã¿", note: "1é€±é–“ç¶šã„ã¦ã„ã‚‹" },
        { label: "é£Ÿæ¬²ä½ä¸‹", note: null },
      ] as Prisma.JsonValue;

      const result = parseSymptomDetails(input);

      expect(result).toEqual([
        { label: "ãã—ã‚ƒã¿", note: "1é€±é–“ç¶šã„ã¦ã„ã‚‹" },
        { label: "é£Ÿæ¬²ä½ä¸‹", note: null },
      ]);
    });

    it("ä¸æ­£ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã™ã‚‹", () => {
      const input = [
        { label: "ãã—ã‚ƒã¿", note: "test" },
        { invalid: "item" }, // labelãŒãªã„
        null,
        "string",
        { label: 123 }, // labelãŒæ–‡å­—åˆ—ã§ãªã„
      ] as Prisma.JsonValue;

      const result = parseSymptomDetails(input);

      expect(result).toEqual([{ label: "ãã—ã‚ƒã¿", note: "test" }]);
    });

    it("noteãŒundefinedã®å ´åˆã¯nullã«å¤‰æ›ã™ã‚‹", () => {
      const input = [{ label: "ç—‡çŠ¶1" }] as Prisma.JsonValue;

      const result = parseSymptomDetails(input);

      expect(result[0].note).toBeNull();
    });
  });

  describe("parseMedications", () => {
    it("nullã®å ´åˆã¯ç©ºé…åˆ—ã‚’è¿”ã™", () => {
      expect(parseMedications(null)).toEqual([]);
      expect(parseMedications(undefined)).toEqual([]);
    });

    it("æœ‰åŠ¹ãªæŠ•è–¬æƒ…å ±é…åˆ—ã‚’è§£æã§ãã‚‹", () => {
      const input = [
        { name: "æŠ—ç”Ÿç‰©è³ª", dosage: "æœæ™©1éŒ " },
        { name: "èƒƒè–¬", dosage: null },
      ] as Prisma.JsonValue;

      const result = parseMedications(input);

      expect(result).toEqual([
        { name: "æŠ—ç”Ÿç‰©è³ª", dosage: "æœæ™©1éŒ " },
        { name: "èƒƒè–¬", dosage: null },
      ]);
    });

    it("ä¸æ­£ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã™ã‚‹", () => {
      const input = [
        { name: "è–¬A", dosage: "test" },
        { invalid: "item" }, // nameãŒãªã„
        null,
      ] as Prisma.JsonValue;

      const result = parseMedications(input);

      expect(result).toEqual([{ name: "è–¬A", dosage: "test" }]);
    });
  });

  describe("mapDtoToSymptomDetails", () => {
    it("undefinedã®å ´åˆã¯ç©ºé…åˆ—ã‚’è¿”ã™", () => {
      expect(mapDtoToSymptomDetails(undefined)).toEqual([]);
    });

    it("ç©ºé…åˆ—ã®å ´åˆã¯ç©ºé…åˆ—ã‚’è¿”ã™", () => {
      expect(mapDtoToSymptomDetails([])).toEqual([]);
    });

    it("DTOå½¢å¼ã‚’æ­£ã—ãå¤‰æ›ã™ã‚‹", () => {
      const input = [
        { label: "ãã—ã‚ƒã¿", note: "test" },
        { label: "é£Ÿæ¬²ä½ä¸‹" }, // noteãªã—
      ];

      const result = mapDtoToSymptomDetails(input);

      expect(result).toEqual([
        { label: "ãã—ã‚ƒã¿", note: "test" },
        { label: "é£Ÿæ¬²ä½ä¸‹", note: null },
      ]);
    });
  });

  describe("mapDtoToMedications", () => {
    it("undefinedã®å ´åˆã¯ç©ºé…åˆ—ã‚’è¿”ã™", () => {
      expect(mapDtoToMedications(undefined)).toEqual([]);
    });

    it("DTOå½¢å¼ã‚’æ­£ã—ãå¤‰æ›ã™ã‚‹", () => {
      const input = [
        { name: "è–¬A", dosage: "1æ—¥2å›" },
        { name: "è–¬B" }, // dosageãªã—
      ];

      const result = mapDtoToMedications(input);

      expect(result).toEqual([
        { name: "è–¬A", dosage: "1æ—¥2å›" },
        { name: "è–¬B", dosage: null },
      ]);
    });
  });

  describe("serializeSymptomDetails", () => {
    it("undefinedã®å ´åˆã¯DbNullã‚’è¿”ã™", () => {
      const result = serializeSymptomDetails(undefined);

      expect(result).toBe(Prisma.DbNull);
    });

    it("ç©ºé…åˆ—ã®å ´åˆã¯DbNullã‚’è¿”ã™", () => {
      const result = serializeSymptomDetails([]);

      expect(result).toBe(Prisma.DbNull);
    });

    it("ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã¯JsonArrayã‚’è¿”ã™", () => {
      const input = [
        { label: "ãã—ã‚ƒã¿", note: "test" },
        { label: "é£Ÿæ¬²ä½ä¸‹", note: null },
      ];

      const result = serializeSymptomDetails(input);

      expect(result).toEqual([
        { label: "ãã—ã‚ƒã¿", note: "test" },
        { label: "é£Ÿæ¬²ä½ä¸‹", note: null },
      ]);
    });
  });

  describe("serializeMedications", () => {
    it("undefinedã®å ´åˆã¯DbNullã‚’è¿”ã™", () => {
      const result = serializeMedications(undefined);

      expect(result).toBe(Prisma.DbNull);
    });

    it("ç©ºé…åˆ—ã®å ´åˆã¯DbNullã‚’è¿”ã™", () => {
      const result = serializeMedications([]);

      expect(result).toBe(Prisma.DbNull);
    });

    it("ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã¯JsonArrayã‚’è¿”ã™", () => {
      const input = [
        { name: "è–¬A", dosage: "1æ—¥2å›" },
        { name: "è–¬B", dosage: null },
      ];

      const result = serializeMedications(input);

      expect(result).toEqual([
        { name: "è–¬A", dosage: "1æ—¥2å›" },
        { name: "è–¬B", dosage: null },
      ]);
    });
  });
});
`````

## File: backend/src/care/json-value.utils.ts
`````typescript
/**
 * Prisma JsonValue ã®å‹å®‰å…¨ãªãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ»å¤‰æ›ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
 *
 * symptomDetails, medications ãªã©ã®JSONãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å‹å®‰å…¨ã«æ‰±ã†
 */

import { Prisma } from "@prisma/client";

/**
 * ç—‡çŠ¶è©³ç´°ã®å‹å®šç¾©
 */
export interface SymptomDetail {
  label: string;
  note: string | null;
}

/**
 * æŠ•è–¬æƒ…å ±ã®å‹å®šç¾©
 */
export interface MedicationDetail {
  name: string;
  dosage: string | null;
}

/**
 * æœªçŸ¥ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ SymptomDetail ã®æ§‹é€ ã‚’æŒã¤ã‹ãƒã‚§ãƒƒã‚¯
 */
function isSymptomDetailLike(value: unknown): value is SymptomDetail {
  if (!value || typeof value !== "object") {
    return false;
  }
  const obj = value as Record<string, unknown>;
  return (
    typeof obj.label === "string" &&
    (obj.note === null || obj.note === undefined || typeof obj.note === "string")
  );
}

/**
 * æœªçŸ¥ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒ MedicationDetail ã®æ§‹é€ ã‚’æŒã¤ã‹ãƒã‚§ãƒƒã‚¯
 */
function isMedicationDetailLike(value: unknown): value is MedicationDetail {
  if (!value || typeof value !== "object") {
    return false;
  }
  const obj = value as Record<string, unknown>;
  return (
    typeof obj.name === "string" &&
    (obj.dosage === null || obj.dosage === undefined || typeof obj.dosage === "string")
  );
}

/**
 * Prisma JsonValue ã‚’ SymptomDetail[] ã«å‹å®‰å…¨ã«å¤‰æ›
 *
 * @param data Prismaã‹ã‚‰å–å¾—ã—ãŸJsonValue
 * @returns æ¤œè¨¼æ¸ˆã¿ã® SymptomDetail é…åˆ—
 */
export function parseSymptomDetails(
  data: Prisma.JsonValue | null | undefined,
): SymptomDetail[] {
  if (!Array.isArray(data)) {
    return [];
  }

  const result: SymptomDetail[] = [];
  for (const item of data) {
    if (isSymptomDetailLike(item)) {
      result.push({
        label: item.label,
        note: typeof item.note === "string" ? item.note : null,
      });
    }
  }
  return result;
}

/**
 * Prisma JsonValue ã‚’ MedicationDetail[] ã«å‹å®‰å…¨ã«å¤‰æ›
 *
 * @param data Prismaã‹ã‚‰å–å¾—ã—ãŸJsonValue
 * @returns æ¤œè¨¼æ¸ˆã¿ã® MedicationDetail é…åˆ—
 */
export function parseMedications(
  data: Prisma.JsonValue | null | undefined,
): MedicationDetail[] {
  if (!Array.isArray(data)) {
    return [];
  }

  const result: MedicationDetail[] = [];
  for (const item of data) {
    if (isMedicationDetailLike(item)) {
      result.push({
        name: item.name,
        dosage: typeof item.dosage === "string" ? item.dosage : null,
      });
    }
  }
  return result;
}

/**
 * SymptomDetail[] ã‚’ Prisma JsonArray ã«å¤‰æ›
 *
 * @param details ç—‡çŠ¶è©³ç´°é…åˆ—
 * @returns Prisma JsonArray ã¾ãŸã¯ DbNull
 */
export function serializeSymptomDetails(
  details: SymptomDetail[] | undefined,
): Prisma.JsonArray | typeof Prisma.DbNull {
  if (!details || details.length === 0) {
    return Prisma.DbNull;
  }

  return details.map((detail) => ({
    label: detail.label,
    note: detail.note ?? null,
  })) as Prisma.JsonArray;
}

/**
 * MedicationDetail[] ã‚’ Prisma JsonArray ã«å¤‰æ›
 *
 * @param medications æŠ•è–¬æƒ…å ±é…åˆ—
 * @returns Prisma JsonArray ã¾ãŸã¯ DbNull
 */
export function serializeMedications(
  medications: MedicationDetail[] | undefined,
): Prisma.JsonArray | typeof Prisma.DbNull {
  if (!medications || medications.length === 0) {
    return Prisma.DbNull;
  }

  return medications.map((medication) => ({
    name: medication.name,
    dosage: medication.dosage ?? null,
  })) as Prisma.JsonArray;
}

/**
 * DTOå½¢å¼ã®ç—‡çŠ¶è©³ç´°ã‚’å‹å®‰å…¨ã«å¤‰æ›
 */
export function mapDtoToSymptomDetails(
  dtoDetails: Array<{ label: string; note?: string }> | undefined,
): SymptomDetail[] {
  if (!dtoDetails || dtoDetails.length === 0) {
    return [];
  }

  return dtoDetails.map((detail) => ({
    label: detail.label,
    note: detail.note ?? null,
  }));
}

/**
 * DTOå½¢å¼ã®æŠ•è–¬æƒ…å ±ã‚’å‹å®‰å…¨ã«å¤‰æ›
 */
export function mapDtoToMedications(
  dtoMedications: Array<{ name: string; dosage?: string }> | undefined,
): MedicationDetail[] {
  if (!dtoMedications || dtoMedications.length === 0) {
    return [];
  }

  return dtoMedications.map((medication) => ({
    name: medication.name,
    dosage: medication.dosage ?? null,
  }));
}
`````

## File: backend/src/care/recurrence.utils.spec.ts
`````typescript
/**
 * recurrence.utils.ts ã®å˜ä½“ãƒ†ã‚¹ãƒˆ
 */

import dayjs from "dayjs";

import {
  parseRRule,
  calculateNextScheduleDate,
  hasValidRecurrence,
  type ParsedRRule,
} from "./recurrence.utils";

describe("RecurrenceUtils", () => {
  describe("parseRRule", () => {
    it("nullã¾ãŸã¯undefinedã®å ´åˆã€nullã‚’è¿”ã™", () => {
      expect(parseRRule(null)).toBeNull();
      expect(parseRRule(undefined)).toBeNull();
      expect(parseRRule("")).toBeNull();
    });

    it("ç„¡åŠ¹ãªRRULEæ–‡å­—åˆ—ã®å ´åˆã€nullã‚’è¿”ã™", () => {
      expect(parseRRule("INVALID")).toBeNull();
      expect(parseRRule("FREQ=INVALID")).toBeNull();
    });

    describe("DAILY", () => {
      it("åŸºæœ¬çš„ãªæ¯æ—¥ç¹°ã‚Šè¿”ã—ã‚’è§£æã§ãã‚‹", () => {
        const result = parseRRule("FREQ=DAILY;INTERVAL=1");

        expect(result).not.toBeNull();
        expect(result?.frequency).toBe("DAILY");
        expect(result?.interval).toBe(1);
      });

      it("2æ—¥ã”ã¨ã®ç¹°ã‚Šè¿”ã—ã‚’è§£æã§ãã‚‹", () => {
        const result = parseRRule("FREQ=DAILY;INTERVAL=2");

        expect(result?.frequency).toBe("DAILY");
        expect(result?.interval).toBe(2);
      });
    });

    describe("WEEKLY", () => {
      it("åŸºæœ¬çš„ãªæ¯é€±ç¹°ã‚Šè¿”ã—ã‚’è§£æã§ãã‚‹", () => {
        const result = parseRRule("FREQ=WEEKLY;INTERVAL=1");

        expect(result?.frequency).toBe("WEEKLY");
        expect(result?.interval).toBe(1);
        expect(result?.byDay).toBeNull();
      });

      it("æ›œæ—¥æŒ‡å®šä»˜ãã®æ¯é€±ç¹°ã‚Šè¿”ã—ã‚’è§£æã§ãã‚‹", () => {
        const result = parseRRule("FREQ=WEEKLY;INTERVAL=1;BYDAY=MO,WE,FR");

        expect(result?.frequency).toBe("WEEKLY");
        expect(result?.byDay).toEqual([1, 3, 5]); // æœˆã€æ°´ã€é‡‘
      });

      it("å˜ä¸€æ›œæ—¥ã®ç¹°ã‚Šè¿”ã—ã‚’è§£æã§ãã‚‹", () => {
        const result = parseRRule("FREQ=WEEKLY;BYDAY=TU");

        expect(result?.byDay).toEqual([2]); // ç«æ›œæ—¥
      });
    });

    describe("MONTHLY", () => {
      it("åŸºæœ¬çš„ãªæ¯æœˆç¹°ã‚Šè¿”ã—ã‚’è§£æã§ãã‚‹", () => {
        const result = parseRRule("FREQ=MONTHLY;INTERVAL=1");

        expect(result?.frequency).toBe("MONTHLY");
        expect(result?.byMonthDay).toBeNull();
      });

      it("æ—¥ä»˜æŒ‡å®šä»˜ãã®æ¯æœˆç¹°ã‚Šè¿”ã—ã‚’è§£æã§ãã‚‹", () => {
        const result = parseRRule("FREQ=MONTHLY;BYMONTHDAY=15");

        expect(result?.frequency).toBe("MONTHLY");
        expect(result?.byMonthDay).toBe(15);
      });
    });

    describe("YEARLY", () => {
      it("æ¯å¹´ç¹°ã‚Šè¿”ã—ã‚’è§£æã§ãã‚‹", () => {
        const result = parseRRule("FREQ=YEARLY;INTERVAL=1");

        expect(result?.frequency).toBe("YEARLY");
        expect(result?.interval).toBe(1);
      });
    });

    describe("çµ‚äº†æ¡ä»¶", () => {
      it("COUNTæŒ‡å®šã‚’è§£æã§ãã‚‹", () => {
        const result = parseRRule("FREQ=DAILY;COUNT=10");

        expect(result?.count).toBe(10);
      });

      it("UNTILæŒ‡å®šï¼ˆYYYYMMDDå½¢å¼ï¼‰ã‚’è§£æã§ãã‚‹", () => {
        const result = parseRRule("FREQ=WEEKLY;UNTIL=20251231");

        expect(result?.until).not.toBeNull();
        expect(result?.until?.getFullYear()).toBe(2025);
        expect(result?.until?.getMonth()).toBe(11); // 12æœˆ
        expect(result?.until?.getDate()).toBe(31);
      });

      it("UNTILæŒ‡å®šï¼ˆISO8601å½¢å¼ï¼‰ã‚’è§£æã§ãã‚‹", () => {
        const result = parseRRule("FREQ=MONTHLY;UNTIL=20251231T235959Z");

        expect(result?.until).not.toBeNull();
      });
    });
  });

  describe("calculateNextScheduleDate", () => {
    const baseDate = new Date("2025-01-15T10:00:00.000Z");

    describe("DAILY", () => {
      it("æ¬¡ã®æ—¥ã‚’è¨ˆç®—ã§ãã‚‹", () => {
        const rrule: ParsedRRule = {
          frequency: "DAILY",
          interval: 1,
          byDay: null,
          byMonthDay: null,
          count: null,
          until: null,
        };

        const next = calculateNextScheduleDate(rrule, baseDate);

        expect(next).not.toBeNull();
        expect(dayjs(next).format("YYYY-MM-DD")).toBe("2025-01-16");
      });

      it("3æ—¥å¾Œã‚’è¨ˆç®—ã§ãã‚‹", () => {
        const rrule: ParsedRRule = {
          frequency: "DAILY",
          interval: 3,
          byDay: null,
          byMonthDay: null,
          count: null,
          until: null,
        };

        const next = calculateNextScheduleDate(rrule, baseDate);

        expect(dayjs(next).format("YYYY-MM-DD")).toBe("2025-01-18");
      });
    });

    describe("WEEKLY", () => {
      it("æ¬¡ã®é€±ã‚’è¨ˆç®—ã§ãã‚‹", () => {
        const rrule: ParsedRRule = {
          frequency: "WEEKLY",
          interval: 1,
          byDay: null,
          byMonthDay: null,
          count: null,
          until: null,
        };

        const next = calculateNextScheduleDate(rrule, baseDate);

        expect(dayjs(next).format("YYYY-MM-DD")).toBe("2025-01-22");
      });

      it("æ›œæ—¥æŒ‡å®šã§æ¬¡ã®è©²å½“æ›œæ—¥ã‚’è¨ˆç®—ã§ãã‚‹ï¼ˆä»Šé€±ï¼‰", () => {
        // 2025-01-15ã¯æ°´æ›œæ—¥
        const rrule: ParsedRRule = {
          frequency: "WEEKLY",
          interval: 1,
          byDay: [4, 5], // æœ¨ã€é‡‘
          byMonthDay: null,
          count: null,
          until: null,
        };

        const next = calculateNextScheduleDate(rrule, baseDate);

        // æ¬¡ã¯æœ¨æ›œæ—¥ (2025-01-16)
        expect(dayjs(next).format("YYYY-MM-DD")).toBe("2025-01-16");
      });
    });

    describe("MONTHLY", () => {
      it("æ¬¡ã®æœˆã‚’è¨ˆç®—ã§ãã‚‹", () => {
        const rrule: ParsedRRule = {
          frequency: "MONTHLY",
          interval: 1,
          byDay: null,
          byMonthDay: null,
          count: null,
          until: null,
        };

        const next = calculateNextScheduleDate(rrule, baseDate);

        expect(dayjs(next).format("YYYY-MM-DD")).toBe("2025-02-15");
      });

      it("æ—¥ä»˜æŒ‡å®šã§æ¬¡ã®è©²å½“æ—¥ã‚’è¨ˆç®—ã§ãã‚‹ï¼ˆä»Šæœˆï¼‰", () => {
        // 15æ—¥ã‚ˆã‚Šå¾Œã®20æ—¥
        const rrule: ParsedRRule = {
          frequency: "MONTHLY",
          interval: 1,
          byDay: null,
          byMonthDay: 20,
          count: null,
          until: null,
        };

        const next = calculateNextScheduleDate(rrule, baseDate);

        expect(dayjs(next).format("YYYY-MM-DD")).toBe("2025-01-20");
      });

      it("æ—¥ä»˜æŒ‡å®šã§æ¬¡ã®è©²å½“æ—¥ã‚’è¨ˆç®—ã§ãã‚‹ï¼ˆç¿Œæœˆï¼‰", () => {
        // 15æ—¥ã‚ˆã‚Šå‰ã®10æ—¥ â†’ ç¿Œæœˆ
        const rrule: ParsedRRule = {
          frequency: "MONTHLY",
          interval: 1,
          byDay: null,
          byMonthDay: 10,
          count: null,
          until: null,
        };

        const next = calculateNextScheduleDate(rrule, baseDate);

        expect(dayjs(next).format("YYYY-MM-DD")).toBe("2025-02-10");
      });
    });

    describe("YEARLY", () => {
      it("æ¬¡ã®å¹´ã‚’è¨ˆç®—ã§ãã‚‹", () => {
        const rrule: ParsedRRule = {
          frequency: "YEARLY",
          interval: 1,
          byDay: null,
          byMonthDay: null,
          count: null,
          until: null,
        };

        const next = calculateNextScheduleDate(rrule, baseDate);

        expect(dayjs(next).format("YYYY-MM-DD")).toBe("2026-01-15");
      });
    });

    describe("çµ‚äº†æ¡ä»¶", () => {
      it("UNTILæ—¥ã‚’è¶…ãˆã‚‹å ´åˆã¯nullã‚’è¿”ã™", () => {
        const rrule: ParsedRRule = {
          frequency: "DAILY",
          interval: 1,
          byDay: null,
          byMonthDay: null,
          count: null,
          until: new Date("2025-01-15T00:00:00.000Z"), // åŸºæº–æ—¥ã¨åŒã˜
        };

        const next = calculateNextScheduleDate(rrule, baseDate);

        expect(next).toBeNull();
      });
    });
  });

  describe("hasValidRecurrence", () => {
    it("æœ‰åŠ¹ãªRRULEã®å ´åˆã¯trueã‚’è¿”ã™", () => {
      expect(hasValidRecurrence("FREQ=DAILY")).toBe(true);
      expect(hasValidRecurrence("FREQ=WEEKLY;BYDAY=MO")).toBe(true);
      expect(hasValidRecurrence("FREQ=MONTHLY;BYMONTHDAY=1")).toBe(true);
      expect(hasValidRecurrence("FREQ=YEARLY")).toBe(true);
    });

    it("ç„¡åŠ¹ãªRRULEã®å ´åˆã¯falseã‚’è¿”ã™", () => {
      expect(hasValidRecurrence(null)).toBe(false);
      expect(hasValidRecurrence(undefined)).toBe(false);
      expect(hasValidRecurrence("")).toBe(false);
      expect(hasValidRecurrence("INVALID")).toBe(false);
    });
  });
});
`````

## File: backend/src/care/recurrence.utils.ts
`````typescript
/**
 * ç¹°ã‚Šè¿”ã—ãƒ«ãƒ¼ãƒ«ï¼ˆRRULEï¼‰ã®è§£æã¨ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ç”Ÿæˆãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
 *
 * å¯¾å¿œã‚¿ã‚¤ãƒ—: æ¯æ—¥(DAILY)ã€æ¯é€±(WEEKLY)ã€æ¯æœˆ(MONTHLY)ã€æ¯å¹´(YEARLY)
 */

import dayjs from "dayjs";

/**
 * RRULEé »åº¦ã‚¿ã‚¤ãƒ—
 */
export type RecurrenceFrequency = "DAILY" | "WEEKLY" | "MONTHLY" | "YEARLY";

/**
 * è§£æã•ã‚ŒãŸRRULEæƒ…å ±
 */
export interface ParsedRRule {
  /** ç¹°ã‚Šè¿”ã—é »åº¦ */
  frequency: RecurrenceFrequency;
  /** ç¹°ã‚Šè¿”ã—é–“éš”ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 1ï¼‰ */
  interval: number;
  /** æ›œæ—¥æŒ‡å®šï¼ˆWEEKLYç”¨ï¼‰: 0=æ—¥æ›œã€œ6=åœŸæ›œ */
  byDay: number[] | null;
  /** æ—¥ä»˜æŒ‡å®šï¼ˆMONTHLYç”¨ï¼‰: 1ã€œ31 */
  byMonthDay: number | null;
  /** çµ‚äº†å›æ•° */
  count: number | null;
  /** çµ‚äº†æ—¥æ™‚ */
  until: Date | null;
}

/**
 * RRULEã‚’è§£æã™ã‚‹
 *
 * @param rule RRULEæ–‡å­—åˆ—ï¼ˆä¾‹: "FREQ=WEEKLY;INTERVAL=1;BYDAY=MO,WE"ï¼‰
 * @returns è§£æçµæœã€‚ç„¡åŠ¹ãªãƒ«ãƒ¼ãƒ«ã®å ´åˆã¯null
 */
export function parseRRule(rule: string | null | undefined): ParsedRRule | null {
  if (!rule || typeof rule !== "string") {
    return null;
  }

  const parts = rule.split(";");
  const params: Record<string, string> = {};

  for (const part of parts) {
    const [key, value] = part.split("=");
    if (key && value) {
      params[key.trim().toUpperCase()] = value.trim();
    }
  }

  const freqValue = params["FREQ"];
  if (!freqValue || !isValidFrequency(freqValue)) {
    return null;
  }

  const frequency = freqValue as RecurrenceFrequency;
  const interval = parseInt(params["INTERVAL"] || "1", 10);
  const count = params["COUNT"] ? parseInt(params["COUNT"], 10) : null;
  const until = params["UNTIL"] ? parseRRuleDate(params["UNTIL"]) : null;

  // BYDAYè§£æï¼ˆæ›œæ—¥ï¼‰
  let byDay: number[] | null = null;
  if (params["BYDAY"]) {
    byDay = parseByDay(params["BYDAY"]);
  }

  // BYMONTHDAYè§£æï¼ˆæœˆã®æ—¥ä»˜ï¼‰
  let byMonthDay: number | null = null;
  if (params["BYMONTHDAY"]) {
    const day = parseInt(params["BYMONTHDAY"], 10);
    if (day >= 1 && day <= 31) {
      byMonthDay = day;
    }
  }

  return {
    frequency,
    interval: Number.isNaN(interval) || interval < 1 ? 1 : interval,
    byDay,
    byMonthDay,
    count: count && !Number.isNaN(count) ? count : null,
    until,
  };
}

/**
 * æœ‰åŠ¹ãªé »åº¦å€¤ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
 */
function isValidFrequency(value: string): value is RecurrenceFrequency {
  return ["DAILY", "WEEKLY", "MONTHLY", "YEARLY"].includes(value.toUpperCase());
}

/**
 * RRULEã®BYDAYå€¤ã‚’è§£æã™ã‚‹
 *
 * @param byday æ›œæ—¥æ–‡å­—åˆ—ï¼ˆä¾‹: "MO,WE,FR"ï¼‰
 * @returns æ›œæ—¥ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹é…åˆ—ï¼ˆ0=æ—¥æ›œã€œ6=åœŸæ›œï¼‰
 */
function parseByDay(byday: string): number[] {
  const dayMap: Record<string, number> = {
    SU: 0,
    MO: 1,
    TU: 2,
    WE: 3,
    TH: 4,
    FR: 5,
    SA: 6,
  };

  const days = byday.split(",").map((d) => d.trim().toUpperCase());
  const result: number[] = [];

  for (const day of days) {
    // ã€Œ-1MOã€ã®ã‚ˆã†ãªå½¢å¼ã«ã‚‚å¯¾å¿œï¼ˆæœ€åˆã®æ•°å­—éƒ¨åˆ†ã‚’é™¤å»ï¼‰
    const cleanDay = day.replace(/^-?\d*/, "");
    if (dayMap[cleanDay] !== undefined) {
      result.push(dayMap[cleanDay]);
    }
  }

  return result.length > 0 ? result : [];
}

/**
 * RRULEã®æ—¥ä»˜æ–‡å­—åˆ—ã‚’è§£æã™ã‚‹
 *
 * @param dateStr RRULEæ—¥ä»˜ï¼ˆä¾‹: "20251231T235959Z" ã¾ãŸã¯ "20251231"ï¼‰
 * @returns Dateã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚ç„¡åŠ¹ãªå ´åˆã¯null
 */
function parseRRuleDate(dateStr: string): Date | null {
  // YYYYMMDDå½¢å¼
  if (/^\d{8}$/.test(dateStr)) {
    const year = parseInt(dateStr.substring(0, 4), 10);
    const month = parseInt(dateStr.substring(4, 6), 10) - 1;
    const day = parseInt(dateStr.substring(6, 8), 10);
    const date = new Date(year, month, day);
    return Number.isNaN(date.getTime()) ? null : date;
  }

  // YYYYMMDDTHHmmssZå½¢å¼
  if (/^\d{8}T\d{6}Z?$/.test(dateStr)) {
    const year = parseInt(dateStr.substring(0, 4), 10);
    const month = parseInt(dateStr.substring(4, 6), 10) - 1;
    const day = parseInt(dateStr.substring(6, 8), 10);
    const hour = parseInt(dateStr.substring(9, 11), 10);
    const minute = parseInt(dateStr.substring(11, 13), 10);
    const second = parseInt(dateStr.substring(13, 15), 10);
    const date = new Date(Date.UTC(year, month, day, hour, minute, second));
    return Number.isNaN(date.getTime()) ? null : date;
  }

  // ISO8601å½¢å¼ã‚’è©¦è¡Œ
  const date = new Date(dateStr);
  return Number.isNaN(date.getTime()) ? null : date;
}

/**
 * RRULEã«åŸºã¥ã„ã¦æ¬¡å›äºˆå®šæ—¥ã‚’è¨ˆç®—ã™ã‚‹
 *
 * @param rrule è§£ææ¸ˆã¿RRULE
 * @param baseDate åŸºæº–æ—¥ï¼ˆé€šå¸¸ã¯å®Œäº†æ—¥ã¾ãŸã¯ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«æ—¥ï¼‰
 * @returns æ¬¡å›äºˆå®šæ—¥ã€‚çµ‚äº†æ¡ä»¶ã‚’æº€ãŸã—ãŸå ´åˆã¯null
 */
export function calculateNextScheduleDate(
  rrule: ParsedRRule,
  baseDate: Date,
): Date | null {
  const base = dayjs(baseDate);
  let next: dayjs.Dayjs;

  switch (rrule.frequency) {
    case "DAILY":
      next = base.add(rrule.interval, "day");
      break;

    case "WEEKLY":
      if (rrule.byDay && rrule.byDay.length > 0) {
        // æ›œæ—¥æŒ‡å®šãŒã‚ã‚‹å ´åˆã€æ¬¡ã®è©²å½“æ›œæ—¥ã‚’æ¢ã™
        next = findNextDayOfWeek(base, rrule.byDay, rrule.interval);
      } else {
        next = base.add(rrule.interval, "week");
      }
      break;

    case "MONTHLY":
      if (rrule.byMonthDay !== null) {
        // æ—¥ä»˜æŒ‡å®šãŒã‚ã‚‹å ´åˆã€æ¬¡ã®æŒ‡å®šæ—¥ã‚’æ¢ã™
        next = findNextMonthDay(base, rrule.byMonthDay, rrule.interval);
      } else {
        next = base.add(rrule.interval, "month");
      }
      break;

    case "YEARLY":
      next = base.add(rrule.interval, "year");
      break;

    default:
      return null;
  }

  // çµ‚äº†æ¡ä»¶ãƒã‚§ãƒƒã‚¯
  if (rrule.until && next.isAfter(rrule.until)) {
    return null;
  }

  return next.toDate();
}

/**
 * æ¬¡ã®æŒ‡å®šæ›œæ—¥ã‚’æ¢ã™
 */
function findNextDayOfWeek(
  base: dayjs.Dayjs,
  targetDays: number[],
  weekInterval: number,
): dayjs.Dayjs {
  const currentDay = base.day();
  const sortedDays = [...targetDays].sort((a, b) => a - b);

  // ä»Šé€±ã®æ®‹ã‚Šã®æ›œæ—¥ã‹ã‚‰æ¢ã™
  for (const day of sortedDays) {
    if (day > currentDay) {
      return base.day(day);
    }
  }

  // æ¬¡ã®é€±ã®æœ€åˆã®è©²å½“æ›œæ—¥
  const nextWeekBase = base.add(weekInterval, "week").startOf("week");
  return nextWeekBase.day(sortedDays[0]);
}

/**
 * æ¬¡ã®æŒ‡å®šæ—¥ã‚’æ¢ã™
 */
function findNextMonthDay(
  base: dayjs.Dayjs,
  targetDay: number,
  monthInterval: number,
): dayjs.Dayjs {
  const currentDay = base.date();

  // ä»Šæœˆã®æŒ‡å®šæ—¥ãŒã¾ã æ¥ã¦ã„ãªã„å ´åˆ
  if (currentDay < targetDay) {
    const daysInMonth = base.daysInMonth();
    const actualDay = Math.min(targetDay, daysInMonth);
    return base.date(actualDay);
  }

  // æ¬¡ã®æœˆã®æŒ‡å®šæ—¥
  const nextMonth = base.add(monthInterval, "month");
  const daysInNextMonth = nextMonth.daysInMonth();
  const actualDay = Math.min(targetDay, daysInNextMonth);
  return nextMonth.date(actualDay);
}

/**
 * ç¹°ã‚Šè¿”ã—ãƒ«ãƒ¼ãƒ«ãŒæœ‰åŠ¹ã‹ã©ã†ã‹ã‚’ç¢ºèªã™ã‚‹
 */
export function hasValidRecurrence(rule: string | null | undefined): boolean {
  return parseRRule(rule) !== null;
}
`````

## File: backend/src/cats/constants/gender.spec.ts
`````typescript
import {
  CatGender,
  InvalidGenderError,
  parseGenderInput,
  parseOptionalGenderInput,
} from "./gender";

describe("gender master parsing", () => {
  it("parses master names case-insensitively", () => {
    expect(parseGenderInput("Male")).toBe(CatGender.MALE);
    expect(parseGenderInput("female")).toBe(CatGender.FEMALE);
    expect(parseGenderInput("Neuter")).toBe(CatGender.NEUTER);
    expect(parseGenderInput("SPAY")).toBe(CatGender.SPAY);
  });

  it("parses master keys", () => {
    expect(parseGenderInput("1")).toBe(CatGender.MALE);
    expect(parseGenderInput("2")).toBe(CatGender.FEMALE);
    expect(parseGenderInput("3")).toBe(CatGender.NEUTER);
    expect(parseGenderInput("4")).toBe(CatGender.SPAY);
  });

  it("ignores optional inputs when undefined or blank", () => {
    expect(parseOptionalGenderInput(undefined)).toBeUndefined();
    expect(parseOptionalGenderInput(null)).toBeUndefined();
    expect(parseOptionalGenderInput("   ")).toBeUndefined();
  });

  it("throws for unsupported values", () => {
    expect(() => parseGenderInput("0")).toThrow(InvalidGenderError);
    expect(() => parseGenderInput("unknown"))
      .toThrow(InvalidGenderError);
  });
});
`````

## File: backend/src/cats/constants/gender.ts
`````typescript
export enum CatGender {
  MALE = "MALE",
  FEMALE = "FEMALE",
  NEUTER = "NEUTER",
  SPAY = "SPAY",
}

export type GenderMasterKey = "1" | "2" | "3" | "4";
export type CatGenderInput = CatGender | GenderMasterKey;

export interface GenderMasterRecord {
  key: GenderMasterKey;
  name: string;
  canonical: CatGender;
}

export const GENDER_MASTER: ReadonlyArray<GenderMasterRecord> = [
  { key: "1", name: "Male", canonical: CatGender.MALE },
  { key: "2", name: "Female", canonical: CatGender.FEMALE },
  { key: "3", name: "Neuter", canonical: CatGender.NEUTER },
  { key: "4", name: "Spay", canonical: CatGender.SPAY },
];

const NAME_TO_CANONICAL = new Map<string, CatGender>();
const KEY_TO_CANONICAL = new Map<string, CatGender>();

for (const record of GENDER_MASTER) {
  NAME_TO_CANONICAL.set(record.name.toUpperCase(), record.canonical);
  NAME_TO_CANONICAL.set(record.canonical, record.canonical);
  KEY_TO_CANONICAL.set(record.key, record.canonical);
}

export const GENDER_INPUT_VALUES: ReadonlyArray<string> = [
  ...Object.values(CatGender),
  ...GENDER_MASTER.map((record) => record.key),
];

const DIGIT_PATTERN = /^\d+$/u;

export const transformGenderInput = (
  value: unknown,
): string | undefined => {
  if (value === undefined || value === null) {
    return undefined;
  }

  if (typeof value === "number") {
    return String(value);
  }

  if (typeof value === "string") {
    const trimmed = value.trim();
    if (!trimmed) {
      return trimmed;
    }

    if (DIGIT_PATTERN.test(trimmed)) {
      return trimmed;
    }

    return trimmed.toUpperCase();
  }

  return "";
};

export class InvalidGenderError extends Error {
  constructor(input: string) {
    super(`Invalid gender value: ${input}`);
    this.name = "InvalidGenderError";
  }
}

const coerceInputString = (value: unknown): string => {
  if (value === undefined || value === null) {
    return "";
  }

  if (typeof value === "number") {
    return String(value);
  }

  if (typeof value === "string") {
    return value.trim();
  }

  return "";
};

const resolveCanonicalGender = (value: string): CatGender | undefined => {
  if (!value) {
    return undefined;
  }

  const normalized = value.length === 1 ? value : value.toUpperCase();
  const fromName = NAME_TO_CANONICAL.get(normalized);
  if (fromName) {
    return fromName;
  }

  const fromKey = KEY_TO_CANONICAL.get(value);
  if (fromKey) {
    return fromKey;
  }

  return undefined;
};

export const parseGenderInput = (value: unknown): CatGender => {
  const input = coerceInputString(value);
  const canonical = resolveCanonicalGender(input);
  if (!canonical) {
    throw new InvalidGenderError(input || String(value));
  }

  return canonical;
};

export const parseOptionalGenderInput = (
  value: unknown,
): CatGender | undefined => {
  if (value === undefined || value === null) {
    return undefined;
  }

  const input = coerceInputString(value);
  if (!input) {
    return undefined;
  }

  const canonical = resolveCanonicalGender(input);
  if (!canonical) {
    throw new InvalidGenderError(input);
  }

  return canonical;
};

export const GENDER_CANONICAL_ORDER: ReadonlyArray<CatGender> = [
  CatGender.MALE,
  CatGender.FEMALE,
  CatGender.NEUTER,
  CatGender.SPAY,
];
`````

## File: backend/src/cats/dto/cat-family.dto.ts
`````typescript
/**
 * çŒ«ã®å®¶æ—æƒ…å ±ï¼ˆè¡€çµ±ã‚¿ãƒ–ç”¨ï¼‰DTO
 */

/**
 * ç¥–å…ˆï¼ˆç¥–çˆ¶æ¯ãƒ»æ›¾ç¥–çˆ¶æ¯ï¼‰ã®æƒ…å ±
 * Pedigreeãƒ†ãƒ¼ãƒ–ãƒ«ã‹ã‚‰å–å¾—ã•ã‚Œã‚‹å…ˆç¥–æƒ…å ±
 */
export interface AncestorInfo {
  /** è¡€çµ±æ›¸IDï¼ˆPedigreeãƒ¬ã‚³ãƒ¼ãƒ‰ãŒã‚ã‚‹å ´åˆï¼‰ */
  pedigreeId: string | null;
  /** çŒ«ã®åå‰ */
  catName: string | null;
  /** æ¯›è‰² */
  coatColor: string | null;
  /** ã‚¿ã‚¤ãƒˆãƒ« */
  title: string | null;
  /** JCUç•ªå· */
  jcu: string | null;
}

/**
 * è¦ªæƒ…å ±ï¼ˆçˆ¶ã¾ãŸã¯æ¯ï¼‰
 * çŒ«ãƒ¬ã‚³ãƒ¼ãƒ‰ã¨Pedigreeãƒ¬ã‚³ãƒ¼ãƒ‰ã®ä¸¡æ–¹ã‹ã‚‰æƒ…å ±ã‚’å–å¾—
 */
export interface ParentInfo {
  /** çŒ«IDï¼ˆCatãƒ¬ã‚³ãƒ¼ãƒ‰ãŒã‚ã‚‹å ´åˆï¼‰ */
  id: string | null;
  /** è¡€çµ±æ›¸IDï¼ˆPedigreeãƒ¬ã‚³ãƒ¼ãƒ‰ãŒã‚ã‚‹å ´åˆï¼‰ */
  pedigreeId: string | null;
  /** çŒ«ã®åå‰ */
  name: string;
  /** æ€§åˆ¥ */
  gender: string | null;
  /** ç”Ÿå¹´æœˆæ—¥ */
  birthDate: string | null;
  /** å“ç¨® */
  breed: { id: string; name: string } | null;
  /** æ¯›è‰² */
  coatColor: { id: string; name: string } | string | null;
  /** çˆ¶æ–¹ç¥–çˆ¶ */
  father: AncestorInfo | null;
  /** çˆ¶æ–¹ç¥–æ¯ */
  mother: AncestorInfo | null;
}

/**
 * å…„å¼Ÿå§‰å¦¹æƒ…å ±
 */
export interface SiblingInfo {
  /** çŒ«ID */
  id: string;
  /** åå‰ */
  name: string;
  /** æ€§åˆ¥ */
  gender: string;
  /** ç”Ÿå¹´æœˆæ—¥ */
  birthDate: string;
  /** å“ç¨® */
  breed: { id: string; name: string } | null;
  /** æ¯›è‰² */
  coatColor: { id: string; name: string } | null;
  /** è¡€çµ±æ›¸ID */
  pedigreeId: string | null;
}

/**
 * å­çŒ«æƒ…å ±
 */
export interface OffspringInfo {
  /** çŒ«ID */
  id: string;
  /** åå‰ */
  name: string;
  /** æ€§åˆ¥ */
  gender: string;
  /** ç”Ÿå¹´æœˆæ—¥ */
  birthDate: string;
  /** å“ç¨® */
  breed: { id: string; name: string } | null;
  /** æ¯›è‰² */
  coatColor: { id: string; name: string } | null;
  /** è¡€çµ±æ›¸ID */
  pedigreeId: string | null;
  /** ç›¸æ‰‹ã®è¦ªï¼ˆã“ã®çŒ«ãŒã‚ªã‚¹ãªã‚‰æ¯ã€ãƒ¡ã‚¹ãªã‚‰çˆ¶ï¼‰ */
  otherParent: {
    id: string;
    name: string;
    gender: string;
    pedigreeId: string | null;
  } | null;
}

/**
 * çŒ«ã®å®¶æ—æƒ…å ±ãƒ¬ã‚¹ãƒãƒ³ã‚¹
 */
export interface CatFamilyResponse {
  /** æœ¬çŒ«ã®æƒ…å ± */
  cat: {
    id: string;
    name: string;
    gender: string;
    birthDate: string;
    pedigreeId: string | null;
    breed: { id: string; name: string } | null;
    coatColor: { id: string; name: string } | null;
  };
  /** çˆ¶è¦ªæƒ…å ±ï¼ˆPedigreeã‹ã‚‰ç¥–çˆ¶æ¯ãƒ»æ›¾ç¥–çˆ¶æ¯ã‚’å«ã‚€ï¼‰ */
  father: ParentInfo | null;
  /** æ¯è¦ªæƒ…å ±ï¼ˆPedigreeã‹ã‚‰ç¥–çˆ¶æ¯ãƒ»æ›¾ç¥–çˆ¶æ¯ã‚’å«ã‚€ï¼‰ */
  mother: ParentInfo | null;
  /** å…„å¼Ÿå§‰å¦¹ï¼ˆä¸¡è¦ªãŒä¸€è‡´ã™ã‚‹çŒ«ã®ã¿ï¼‰ */
  siblings: SiblingInfo[];
  /** å­çŒ«ä¸€è¦§ï¼ˆã“ã®çŒ«ãŒè¦ªã®å ´åˆï¼‰ */
  offspring: OffspringInfo[];
}
`````

## File: backend/src/cats/dto/cat-query.dto.ts
`````typescript
import { ApiPropertyOptional } from "@nestjs/swagger";
import { Transform, Type } from "class-transformer";
import {
  IsOptional,
  IsString,
  IsInt,
  IsIn,
  IsBoolean,
  Min,
  Max,
} from "class-validator";

import {
  CatGenderInput,
  GENDER_INPUT_VALUES,
  transformGenderInput,
} from "../constants/gender";

export class CatQueryDto {
  @ApiPropertyOptional({ description: "ãƒšãƒ¼ã‚¸ç•ªå·", default: 1 })
  @IsOptional()
  @IsInt()
  @Min(1)
  @Type(() => Number)
  page?: number = 1;

  @ApiPropertyOptional({ description: "1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•°", default: 10 })
  @IsOptional()
  @IsInt()
  @Min(1)
  @Max(1000)
  @Type(() => Number)
  limit?: number = 10;

  @ApiPropertyOptional({ description: "æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰" })
  @IsOptional()
  @IsString()
  search?: string;

  @ApiPropertyOptional({ description: "å“ç¨®ID" })
  @IsOptional()
  @IsString()
  breedId?: string;

  @ApiPropertyOptional({ description: "æ¯›è‰²ID" })
  @IsOptional()
  @IsString()
  coatColorId?: string;

  @ApiPropertyOptional({
    description: "æ€§åˆ¥",
    enum: GENDER_INPUT_VALUES,
  })
  @IsOptional()
  @Transform(({ value }) => transformGenderInput(value), { toClassOnly: true })
  @IsString()
  @IsIn(GENDER_INPUT_VALUES)
  gender?: CatGenderInput;

  @ApiPropertyOptional({ description: "åœ¨èˆä¸­ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼" })
  @IsOptional()
  @Transform(({ value }) => value === 'true' || value === true)
  @IsBoolean()
  isInHouse?: boolean;

  @ApiPropertyOptional({ description: "æœ€å°å¹´é½¢" })
  @IsOptional()
  @IsInt()
  @Min(0)
  @Type(() => Number)
  ageMin?: number;

  @ApiPropertyOptional({ description: "æœ€å¤§å¹´é½¢" })
  @IsOptional()
  @IsInt()
  @Min(0)
  @Type(() => Number)
  ageMax?: number;

  @ApiPropertyOptional({ description: "ã‚½ãƒ¼ãƒˆé …ç›®", default: "createdAt" })
  @IsOptional()
  @IsString()
  @IsIn(["createdAt", "updatedAt", "name", "birthDate", "weight"])
  sortBy?: string = "createdAt";

  @ApiPropertyOptional({ description: "ã‚½ãƒ¼ãƒˆé †", default: "desc" })
  @IsOptional()
  @IsString()
  @IsIn(["asc", "desc"])
  sortOrder?: "asc" | "desc" = "desc";
}
`````

## File: backend/src/cats/dto/cat-statistics.dto.ts
`````typescript
/**
 * çŒ«çµ±è¨ˆæƒ…å ±ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹DTO
 * ã‚¿ãƒ–åˆ¥ã‚«ã‚¦ãƒ³ãƒˆã‚’å«ã‚€æ‹¡å¼µçµ±è¨ˆæƒ…å ±
 */

/**
 * ã‚¿ãƒ–åˆ¥ã‚«ã‚¦ãƒ³ãƒˆæƒ…å ±
 */
export interface TabCounts {
  /** å…¨æˆçŒ«æ•°ï¼ˆå­çŒ«é™¤å¤–ï¼‰ */
  total: number;
  /** ã‚ªã‚¹æˆçŒ«æ•° */
  male: number;
  /** ãƒ¡ã‚¹æˆçŒ«æ•° */
  female: number;
  /** å­çŒ«æ•°ï¼ˆç”Ÿå¾Œ3ãƒ¶æœˆä»¥å†… + æ¯çŒ«ã‚ã‚Šï¼‰ */
  kitten: number;
  /** é¤Šæˆä¸­ã‚¿ã‚°ä»˜ãçŒ«æ•° */
  raising: number;
  /** å’æ¥­äºˆå®šã‚¿ã‚°ä»˜ãçŒ«æ•° */
  grad: number;
}

/**
 * æ€§åˆ¥åˆ†å¸ƒæƒ…å ±
 */
export interface GenderDistribution {
  MALE: number;
  FEMALE: number;
  NEUTER: number;
  SPAY: number;
}

/**
 * å“ç¨®çµ±è¨ˆæƒ…å ±
 */
export interface BreedStat {
  breed: {
    id: string;
    name: string;
  } | null;
  count: number;
}

/**
 * çŒ«çµ±è¨ˆãƒ¬ã‚¹ãƒãƒ³ã‚¹
 */
export interface CatStatisticsResponse {
  /** å…¨çŒ«æ•° */
  total: number;
  /** æ€§åˆ¥åˆ†å¸ƒ */
  genderDistribution: GenderDistribution;
  /** å“ç¨®åˆ†å¸ƒï¼ˆä¸Šä½10ä»¶ï¼‰ */
  breedDistribution: BreedStat[];
  /** ã‚¿ãƒ–åˆ¥ã‚«ã‚¦ãƒ³ãƒˆï¼ˆçŒ«ä¸€è¦§ãƒšãƒ¼ã‚¸ç”¨ï¼‰ */
  tabCounts: TabCounts;
}
`````

## File: backend/src/cats/dto/create-cat.dto.ts
`````typescript
import { ApiProperty, ApiPropertyOptional } from "@nestjs/swagger";
import {
  IsString,
  IsOptional,
  IsDateString,
  MaxLength,
  IsBoolean,
  IsArray,
  IsIn,
} from "class-validator";

export class CreateCatDto {
  @ApiProperty({ description: "çŒ«ã®åå‰", example: "Alpha" })
  @IsString()
  @MaxLength(200)
  name: string;

  @ApiProperty({
    description: "æ€§åˆ¥",
    enum: ["MALE", "FEMALE", "NEUTER", "SPAY"],
    example: "MALE",
  })
  @IsString()
  @IsIn(["MALE", "FEMALE", "NEUTER", "SPAY"])
  gender: "MALE" | "FEMALE" | "NEUTER" | "SPAY";

  @ApiProperty({ description: "ç”Ÿå¹´æœˆæ—¥", example: "2024-05-01" })
  @IsDateString()
  birthDate: string;

  @ApiPropertyOptional({ description: "å“ç¨®ID" })
  @IsOptional()
  @IsString()
  breedId?: string;

  @ApiPropertyOptional({ description: "æ¯›è‰²ID" })
  @IsOptional()
  @IsString()
  coatColorId?: string;

  @ApiPropertyOptional({ description: "ãƒã‚¤ã‚¯ãƒ­ãƒãƒƒãƒ—ç•ªå·" })
  @IsOptional()
  @IsString()
  @MaxLength(50)
  microchipNumber?: string;

  @ApiPropertyOptional({ description: "ç™»éŒ²ç•ªå·" })
  @IsOptional()
  @IsString()
  @MaxLength(100)
  registrationNumber?: string;

  @ApiPropertyOptional({ description: "èª¬æ˜ãƒ»å‚™è€ƒ" })
  @IsOptional()
  @IsString()
  @MaxLength(1000)
  description?: string;

  @ApiPropertyOptional({ description: "æ–½è¨­å†…ã«åœ¨èˆã—ã¦ã„ã‚‹ã‹" })
  @IsOptional()
  @IsBoolean()
  isInHouse?: boolean;

  @ApiPropertyOptional({ description: "çˆ¶çŒ«ã®ID" })
  @IsOptional()
  @IsString()
  fatherId?: string;

  @ApiPropertyOptional({ description: "æ¯çŒ«ã®ID" })
  @IsOptional()
  @IsString()
  motherId?: string;

  @ApiPropertyOptional({ description: "ã‚¿ã‚°IDé…åˆ—" })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tagIds?: string[];
}
`````

## File: backend/src/cats/dto/index.ts
`````typescript
export * from "./create-cat.dto";
export * from "./update-cat.dto";
export * from "./cat-query.dto";
export * from "./kitten-query.dto";
export * from "./weight-record.dto";
export * from "./cat-family.dto";
export * from "./cat-statistics.dto";
export {
	CatGender,
	CatGenderInput,
	GenderMasterKey,
	GENDER_INPUT_VALUES,
} from "../constants/gender";
`````

## File: backend/src/cats/dto/kitten-query.dto.ts
`````typescript
import { ApiPropertyOptional } from "@nestjs/swagger";
import { Type } from "class-transformer";
import {
  IsOptional,
  IsString,
  IsInt,
  IsIn,
  IsUUID,
  Min,
  Max,
} from "class-validator";

/**
 * å­çŒ«ä¸€è¦§å–å¾—ç”¨ã‚¯ã‚¨ãƒªDTO
 * ç”Ÿå¾Œ6ãƒ¶æœˆæœªæº€ã®çŒ«ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã—ã€æ¯çŒ«ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
 */
export class KittenQueryDto {
  @ApiPropertyOptional({ description: "æ¯çŒ«IDï¼ˆæŒ‡å®šæ™‚ã¯ãã®æ¯çŒ«ã®å­çŒ«ã®ã¿å–å¾—ï¼‰" })
  @IsOptional()
  @IsUUID("4")
  motherId?: string;

  @ApiPropertyOptional({ description: "ãƒšãƒ¼ã‚¸ç•ªå·", default: 1 })
  @IsOptional()
  @IsInt()
  @Min(1)
  @Type(() => Number)
  page?: number = 1;

  @ApiPropertyOptional({ description: "1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•°", default: 50 })
  @IsOptional()
  @IsInt()
  @Min(1)
  @Max(200)
  @Type(() => Number)
  limit?: number = 50;

  @ApiPropertyOptional({ description: "æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼ˆå­çŒ«åï¼‰" })
  @IsOptional()
  @IsString()
  search?: string;

  @ApiPropertyOptional({ description: "ã‚½ãƒ¼ãƒˆé …ç›®", default: "birthDate" })
  @IsOptional()
  @IsString()
  @IsIn(["birthDate", "name", "createdAt"])
  sortBy?: string = "birthDate";

  @ApiPropertyOptional({ description: "ã‚½ãƒ¼ãƒˆé †", default: "desc" })
  @IsOptional()
  @IsString()
  @IsIn(["asc", "desc"])
  sortOrder?: "asc" | "desc" = "desc";
}
`````

## File: backend/src/cats/dto/update-cat.dto.ts
`````typescript
import { PartialType } from "@nestjs/mapped-types";
import { IsIn, IsOptional } from "class-validator";

import { CreateCatDto } from "./create-cat.dto";

export class UpdateCatDto extends PartialType(CreateCatDto) {
  @IsOptional()
  @IsIn(["MALE", "FEMALE", "NEUTER", "SPAY"])
  gender?: "MALE" | "FEMALE" | "NEUTER" | "SPAY";
}
`````

## File: backend/src/cats/dto/weight-record.dto.ts
`````typescript
import { ApiProperty, ApiPropertyOptional } from "@nestjs/swagger";
import { Type } from "class-transformer";
import {
  IsString,
  IsNumber,
  IsOptional,
  IsDateString,
  IsUUID,
  IsArray,
  ValidateNested,
  ArrayMinSize,
  Min,
  Max,
} from "class-validator";

/**
 * ä½“é‡è¨˜éŒ²ä½œæˆ DTO
 */
export class CreateWeightRecordDto {
  @ApiProperty({
    description: "ä½“é‡ï¼ˆã‚°ãƒ©ãƒ å˜ä½ï¼‰",
    example: 350,
    minimum: 1,
    maximum: 50000,
  })
  @IsNumber()
  @Min(1, { message: "ä½“é‡ã¯1gä»¥ä¸Šã§å…¥åŠ›ã—ã¦ãã ã•ã„" })
  @Max(50000, { message: "ä½“é‡ã¯50000gä»¥ä¸‹ã§å…¥åŠ›ã—ã¦ãã ã•ã„" })
  @Type(() => Number)
  weight!: number;

  @ApiPropertyOptional({
    description: "è¨˜éŒ²æ—¥æ™‚ï¼ˆçœç•¥æ™‚ã¯ç¾åœ¨æ—¥æ™‚ï¼‰",
    example: "2024-01-15T10:00:00.000Z",
  })
  @IsOptional()
  @IsDateString({}, { message: "è¨˜éŒ²æ—¥æ™‚ã¯æœ‰åŠ¹ãªæ—¥ä»˜å½¢å¼ã§å…¥åŠ›ã—ã¦ãã ã•ã„" })
  recordedAt?: string;

  @ApiPropertyOptional({
    description: "ãƒ¡ãƒ¢",
    example: "ãƒŸãƒ«ã‚¯ã‚’ã‚ˆãé£²ã‚“ã§ã„ã‚‹",
  })
  @IsOptional()
  @IsString()
  notes?: string;
}

/**
 * ä½“é‡è¨˜éŒ²æ›´æ–° DTO
 */
export class UpdateWeightRecordDto {
  @ApiPropertyOptional({
    description: "ä½“é‡ï¼ˆã‚°ãƒ©ãƒ å˜ä½ï¼‰",
    example: 380,
    minimum: 1,
    maximum: 50000,
  })
  @IsOptional()
  @IsNumber()
  @Min(1, { message: "ä½“é‡ã¯1gä»¥ä¸Šã§å…¥åŠ›ã—ã¦ãã ã•ã„" })
  @Max(50000, { message: "ä½“é‡ã¯50000gä»¥ä¸‹ã§å…¥åŠ›ã—ã¦ãã ã•ã„" })
  @Type(() => Number)
  weight?: number;

  @ApiPropertyOptional({
    description: "è¨˜éŒ²æ—¥æ™‚",
    example: "2024-01-15T10:00:00.000Z",
  })
  @IsOptional()
  @IsDateString({}, { message: "è¨˜éŒ²æ—¥æ™‚ã¯æœ‰åŠ¹ãªæ—¥ä»˜å½¢å¼ã§å…¥åŠ›ã—ã¦ãã ã•ã„" })
  recordedAt?: string;

  @ApiPropertyOptional({
    description: "ãƒ¡ãƒ¢",
    example: "é †èª¿ã«æˆé•·ä¸­",
  })
  @IsOptional()
  @IsString()
  notes?: string;
}

/**
 * ä½“é‡è¨˜éŒ²ã‚¯ã‚¨ãƒª DTO
 */
export class WeightRecordQueryDto {
  @ApiPropertyOptional({
    description: "ãƒšãƒ¼ã‚¸ç•ªå·",
    example: 1,
    default: 1,
  })
  @IsOptional()
  @IsNumber()
  @Min(1)
  @Type(() => Number)
  page?: number;

  @ApiPropertyOptional({
    description: "1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•°",
    example: 50,
    default: 50,
  })
  @IsOptional()
  @IsNumber()
  @Min(1)
  @Max(200)
  @Type(() => Number)
  limit?: number;

  @ApiPropertyOptional({
    description: "é–‹å§‹æ—¥ï¼ˆã“ã®æ—¥ä»¥é™ã®è¨˜éŒ²ã‚’å–å¾—ï¼‰",
    example: "2024-01-01",
  })
  @IsOptional()
  @IsDateString({}, { message: "é–‹å§‹æ—¥ã¯æœ‰åŠ¹ãªæ—¥ä»˜å½¢å¼ã§å…¥åŠ›ã—ã¦ãã ã•ã„" })
  startDate?: string;

  @ApiPropertyOptional({
    description: "çµ‚äº†æ—¥ï¼ˆã“ã®æ—¥ä»¥å‰ã®è¨˜éŒ²ã‚’å–å¾—ï¼‰",
    example: "2024-12-31",
  })
  @IsOptional()
  @IsDateString({}, { message: "çµ‚äº†æ—¥ã¯æœ‰åŠ¹ãªæ—¥ä»˜å½¢å¼ã§å…¥åŠ›ã—ã¦ãã ã•ã„" })
  endDate?: string;

  @ApiPropertyOptional({
    description: "ã‚½ãƒ¼ãƒˆé †",
    example: "desc",
    default: "desc",
  })
  @IsOptional()
  @IsString()
  sortOrder?: "asc" | "desc";
}

/**
 * ä¸€æ‹¬ä½“é‡è¨˜éŒ²ã®å€‹åˆ¥ãƒ¬ã‚³ãƒ¼ãƒ‰ DTO
 */
export class BulkWeightRecordItemDto {
  @ApiProperty({
    description: "çŒ«ID",
    example: "550e8400-e29b-41d4-a716-446655440000",
  })
  @IsUUID("4", { message: "çŒ«IDã¯æœ‰åŠ¹ãªUUIDå½¢å¼ã§å…¥åŠ›ã—ã¦ãã ã•ã„" })
  catId!: string;

  @ApiProperty({
    description: "ä½“é‡ï¼ˆã‚°ãƒ©ãƒ å˜ä½ï¼‰",
    example: 350,
    minimum: 1,
    maximum: 50000,
  })
  @IsNumber()
  @Min(1, { message: "ä½“é‡ã¯1gä»¥ä¸Šã§å…¥åŠ›ã—ã¦ãã ã•ã„" })
  @Max(50000, { message: "ä½“é‡ã¯50000gä»¥ä¸‹ã§å…¥åŠ›ã—ã¦ãã ã•ã„" })
  @Type(() => Number)
  weight!: number;

  @ApiPropertyOptional({
    description: "ãƒ¡ãƒ¢",
    example: "å…ƒæ°—",
  })
  @IsOptional()
  @IsString()
  notes?: string;
}

/**
 * ä¸€æ‹¬ä½“é‡è¨˜éŒ²ä½œæˆ DTO
 */
export class CreateBulkWeightRecordsDto {
  @ApiProperty({
    description: "è¨˜éŒ²æ—¥æ™‚ï¼ˆå…¨ãƒ¬ã‚³ãƒ¼ãƒ‰å…±é€šï¼‰",
    example: "2024-01-15T10:00:00.000Z",
  })
  @IsDateString({}, { message: "è¨˜éŒ²æ—¥æ™‚ã¯æœ‰åŠ¹ãªæ—¥ä»˜å½¢å¼ã§å…¥åŠ›ã—ã¦ãã ã•ã„" })
  recordedAt!: string;

  @ApiProperty({
    description: "ä½“é‡è¨˜éŒ²ã®é…åˆ—",
    type: [BulkWeightRecordItemDto],
  })
  @IsArray()
  @ArrayMinSize(1, { message: "å°‘ãªãã¨ã‚‚1ä»¶ã®ä½“é‡è¨˜éŒ²ãŒå¿…è¦ã§ã™" })
  @ValidateNested({ each: true })
  @Type(() => BulkWeightRecordItemDto)
  records!: BulkWeightRecordItemDto[];
}

/**
 * ä¸€æ‹¬ä½“é‡è¨˜éŒ²ãƒ¬ã‚¹ãƒãƒ³ã‚¹å‹
 */
export interface BulkWeightRecordsResponse {
  success: boolean;
  created: number;
  records: WeightRecordResponse[];
}

/**
 * ä½“é‡è¨˜éŒ²ãƒ¬ã‚¹ãƒãƒ³ã‚¹å‹ï¼ˆå‹å®šç¾©ã®ã¿ã€ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãªã—ï¼‰
 */
export interface WeightRecordResponse {
  id: string;
  catId: string;
  weight: number;
  recordedAt: string;
  notes: string | null;
  recordedBy: string;
  createdAt: string;
  updatedAt: string;
  recorder?: {
    id: string;
    firstName: string | null;
    lastName: string | null;
    email: string;
  };
}

/**
 * ä½“é‡è¨˜éŒ²ä¸€è¦§ãƒ¬ã‚¹ãƒãƒ³ã‚¹å‹
 */
export interface WeightRecordsListResponse {
  data: WeightRecordResponse[];
  meta: {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
  };
  summary?: {
    latestWeight: number | null;
    previousWeight: number | null;
    weightChange: number | null;
    latestRecordedAt: string | null;
    recordCount: number;
  };
}
`````

## File: backend/src/cats/types/cat.types.ts
`````typescript
import { Prisma } from "@prisma/client";

export const catWithRelationsInclude = Prisma.validator<Prisma.CatInclude>()({
  breed: {
    select: {
      id: true,
      name: true,
      code: true,
    },
  },
  coatColor: {
    select: {
      id: true,
      name: true,
      code: true,
    },
  },
  father: {
    select: {
      id: true,
      name: true,
      gender: true,
    },
  },
  mother: {
    select: {
      id: true,
      name: true,
      gender: true,
    },
  },
  pedigree: {
    select: {
      id: true,
      pedigreeId: true,
      catName: true,
      breedCode: true,
      coatColorCode: true,
      genderCode: true,
      birthDate: true,
      breederName: true,
      ownerName: true,
    },
  },
  tags: {
    include: {
      tag: {
        select: {
          id: true,
          name: true,
          color: true,
          textColor: true,
          group: {
            select: {
              id: true,
              name: true,
              category: {
                select: {
                  id: true,
                  name: true,
                },
              },
            },
          },
        },
      },
    },
  },
});

export type CatWithRelations = Prisma.CatGetPayload<{
  include: typeof catWithRelationsInclude;
}>;
`````

## File: backend/src/cats/cats.controller.spec.ts
`````typescript
import { Test, TestingModule } from '@nestjs/testing';

import { getTestModuleImports, getTestModuleProviders } from '../test-utils/test-module-setup';

import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

describe('CatsController', () => {
  let controller: CatsController;
  let service: CatsService;

  const mockCatsService = {
    create: jest.fn(),
    findAll: jest.fn(),
    findOne: jest.fn(),
    update: jest.fn(),
    remove: jest.fn(),
    getBreedingHistory: jest.fn(),
    getCareHistory: jest.fn(),
    getStatistics: jest.fn(),
    findKittens: jest.fn(),
    getWeightRecords: jest.fn(),
    createWeightRecord: jest.fn(),
    updateWeightRecord: jest.fn(),
    deleteWeightRecord: jest.fn(),
    getWeightRecord: jest.fn(),
    createBulkWeightRecords: jest.fn(),
    getWeightRecordsForKittens: jest.fn(),
    getCatFamily: jest.fn(),
    assignTags: jest.fn(),
    removeTags: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      imports: getTestModuleImports(),
      controllers: [CatsController],
      providers: [
        ...getTestModuleProviders(),
        {
          provide: CatsService,
          useValue: mockCatsService,
        },
      ],
    }).compile();

    controller = module.get<CatsController>(CatsController);
    service = module.get<CatsService>(CatsService);

    jest.clearAllMocks();
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });

  describe('create', () => {
    it('should create a cat', async () => {
      const createDto = {
        name: 'Test Cat',
        gender: 'FEMALE' as const,
        birthDate: '2024-01-01',
        isInHouse: true,
      };
      const mockCat = { id: '1', ...createDto };

      mockCatsService.create.mockResolvedValue(mockCat);

      const result = await controller.create(createDto);

      expect(result).toEqual(mockCat);
      expect(service.create).toHaveBeenCalledWith(createDto);
    });
  });

  describe('findAll', () => {
    it('should return paginated cats', async () => {
      const mockResponse = {
        data: [{ id: '1', name: 'Cat 1' }],
        pagination: { page: 1, limit: 10, total: 1, totalPages: 1 },
      };

      mockCatsService.findAll.mockResolvedValue(mockResponse);

      const result = await controller.findAll({});

      expect(result).toEqual(mockResponse);
      expect(service.findAll).toHaveBeenCalledWith({});
    });
  });

  describe('findOne', () => {
    it('should return a cat by id', async () => {
      const mockCat = { id: '1', name: 'Test Cat' };

      mockCatsService.findOne.mockResolvedValue(mockCat);

      const result = await controller.findOne('1');

      expect(result).toEqual(mockCat);
      expect(service.findOne).toHaveBeenCalledWith('1');
    });
  });

  describe('update', () => {
    it('should update a cat', async () => {
      const updateDto = { name: 'Updated Cat' };
      const mockCat = { id: '1', name: 'Updated Cat' };

      mockCatsService.update.mockResolvedValue(mockCat);

      const result = await controller.update('1', updateDto);

      expect(result).toEqual(mockCat);
      expect(service.update).toHaveBeenCalledWith('1', updateDto);
    });
  });

  describe('remove', () => {
    it('should delete a cat', async () => {
      mockCatsService.remove.mockResolvedValue(undefined);

      await controller.remove('1');

      expect(service.remove).toHaveBeenCalledWith('1');
    });
  });

  describe('getStatistics', () => {
    it('should return cat statistics', async () => {
      const mockStats = {
        total: 18,
        female: 10,
        male: 8,
        inHouse: 15,
        graduated: 3,
      };

      mockCatsService.getStatistics.mockResolvedValue(mockStats);

      const result = await controller.getStatistics();

      expect(result).toEqual(mockStats);
      expect(service.getStatistics).toHaveBeenCalled();
    });
  });
});
`````

## File: backend/src/cats/cats.controller.ts
`````typescript
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  HttpStatus,
  Logger,
  UseGuards,
  ParseUUIDPipe,
  Header,
} from "@nestjs/common";
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiParam,
  ApiQuery,
  ApiBearerAuth,
} from "@nestjs/swagger";

import type { RequestUser } from "../auth/auth.types";
import { GetUser } from "../auth/get-user.decorator";
import { JwtAuthGuard } from "../auth/jwt-auth.guard";

import { CatsService } from "./cats.service";
import { GENDER_MASTER } from "./constants/gender";
import {
  CreateCatDto,
  UpdateCatDto,
  CatQueryDto,
  KittenQueryDto,
  CreateWeightRecordDto,
  UpdateWeightRecordDto,
  WeightRecordQueryDto,
  CreateBulkWeightRecordsDto,
} from "./dto";

@ApiTags("Cats")
@ApiBearerAuth()
@UseGuards(JwtAuthGuard)
@Controller("cats")
export class CatsController {
  private readonly logger = new Logger(CatsController.name);

  constructor(private readonly catsService: CatsService) {}

  @Post()
  @ApiOperation({ summary: "çŒ«ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ" })
  @ApiResponse({
    status: HttpStatus.CREATED,
    description: "çŒ«ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«ä½œæˆã•ã‚Œã¾ã—ãŸ",
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: "ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§ã™",
  })
  create(@Body() createCatDto: CreateCatDto) {
    this.logger.log({
      message: 'Creating new cat',
      catName: createCatDto.name,
      breedId: createCatDto.breedId,
      timestamp: new Date().toISOString(),
    });
    return this.catsService.create(createCatDto);
  }

  @Get()
  @Header('Cache-Control', 'no-cache')
  @ApiOperation({ summary: "çŒ«ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œç´¢ãƒ»ä¸€è¦§å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK, description: "çŒ«ãƒ‡ãƒ¼ã‚¿ã®ä¸€è¦§" })
  @ApiQuery({
    name: "page",
    required: false,
    description: "ãƒšãƒ¼ã‚¸ç•ªå·",
    example: 1,
  })
  @ApiQuery({
    name: "limit",
    required: false,
    description: "1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•°",
    example: 10,
  })
  @ApiQuery({ name: "search", required: false, description: "æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰" })
  @ApiQuery({ name: "breedId", required: false, description: "å“ç¨®ID" })
  @ApiQuery({ name: "coatColorId", required: false, description: "æ¯›è‰²ID" })
  @ApiQuery({ name: "gender", required: false, description: "æ€§åˆ¥" })
  @ApiQuery({ name: "status", required: false, description: "ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹" })
  @ApiQuery({ name: "ageMin", required: false, description: "æœ€å°å¹´é½¢" })
  @ApiQuery({ name: "ageMax", required: false, description: "æœ€å¤§å¹´é½¢" })
  @ApiQuery({
    name: "sortBy",
    required: false,
    description: "ã‚½ãƒ¼ãƒˆé …ç›®",
    example: "createdAt",
  })
  @ApiQuery({
    name: "sortOrder",
    required: false,
    description: "ã‚½ãƒ¼ãƒˆé †",
    example: "desc",
  })
  findAll(@Query() query: CatQueryDto) {
    return this.catsService.findAll(query);
  }

  @Get("statistics")
  @ApiOperation({ summary: "çŒ«ãƒ‡ãƒ¼ã‚¿ã®çµ±è¨ˆæƒ…å ±ã‚’å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK, description: "çµ±è¨ˆæƒ…å ±" })
  getStatistics() {
    return this.catsService.getStatistics();
  }

  @Get("kittens")
  @Header('Cache-Control', 'no-cache')
  @ApiOperation({ summary: "å­çŒ«ä¸€è¦§ã‚’å–å¾—ï¼ˆç”Ÿå¾Œ6ãƒ¶æœˆæœªæº€ã€æ¯çŒ«ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ï¼‰" })
  @ApiResponse({ status: HttpStatus.OK, description: "å­çŒ«ãƒ‡ãƒ¼ã‚¿ã®ä¸€è¦§ï¼ˆæ¯çŒ«ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ï¼‰" })
  @ApiQuery({
    name: "motherId",
    required: false,
    description: "æ¯çŒ«IDï¼ˆæŒ‡å®šæ™‚ã¯ãã®æ¯çŒ«ã®å­çŒ«ã®ã¿å–å¾—ï¼‰",
  })
  @ApiQuery({
    name: "page",
    required: false,
    description: "ãƒšãƒ¼ã‚¸ç•ªå·",
    example: 1,
  })
  @ApiQuery({
    name: "limit",
    required: false,
    description: "1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•°",
    example: 50,
  })
  @ApiQuery({ name: "search", required: false, description: "æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼ˆå­çŒ«åï¼‰" })
  @ApiQuery({
    name: "sortBy",
    required: false,
    description: "ã‚½ãƒ¼ãƒˆé …ç›®",
    example: "birthDate",
  })
  @ApiQuery({
    name: "sortOrder",
    required: false,
    description: "ã‚½ãƒ¼ãƒˆé †",
    example: "desc",
  })
  findKittens(@Query() query: KittenQueryDto) {
    return this.catsService.findKittens(query);
  }

  @Get(":id")
  @ApiOperation({ summary: "IDã§çŒ«ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK, description: "çŒ«ãƒ‡ãƒ¼ã‚¿" })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: "çŒ«ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
  })
  @ApiParam({ name: "id", description: "çŒ«ãƒ‡ãƒ¼ã‚¿ã®ID" })
  findOne(@Param("id", new ParseUUIDPipe({ version: "4" })) id: string) {
    return this.catsService.findOne(id);
  }

  @Get(":id/breeding-history")
  @ApiOperation({ summary: "çŒ«ã®ç¹æ®–å±¥æ­´ã‚’å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK, description: "ç¹æ®–å±¥æ­´" })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: "çŒ«ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
  })
  @ApiParam({ name: "id", description: "çŒ«ãƒ‡ãƒ¼ã‚¿ã®ID" })
  getBreedingHistory(@Param("id", new ParseUUIDPipe({ version: "4" })) id: string) {
    return this.catsService.getBreedingHistory(id);
  }

  @Get(":id/care-history")
  @ApiOperation({ summary: "çŒ«ã®ã‚±ã‚¢å±¥æ­´ã‚’å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK, description: "ã‚±ã‚¢å±¥æ­´" })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: "çŒ«ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
  })
  @ApiParam({ name: "id", description: "çŒ«ãƒ‡ãƒ¼ã‚¿ã®ID" })
  getCareHistory(@Param("id", new ParseUUIDPipe({ version: "4" })) id: string) {
    return this.catsService.getCareHistory(id);
  }

  @Get(":id/family")
  @Header('Cache-Control', 'no-cache')
  @ApiOperation({ summary: "çŒ«ã®å®¶æ—æƒ…å ±ã‚’å–å¾—ï¼ˆè¡€çµ±ã‚¿ãƒ–ç”¨ï¼‰" })
  @ApiResponse({ status: HttpStatus.OK, description: "å®¶æ—æƒ…å ±ï¼ˆè¦ªãƒ»å…„å¼Ÿå§‰å¦¹ãƒ»å­çŒ«ï¼‰" })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: "çŒ«ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
  })
  @ApiParam({ name: "id", description: "çŒ«ãƒ‡ãƒ¼ã‚¿ã®ID" })
  getCatFamily(@Param("id", new ParseUUIDPipe({ version: "4" })) id: string) {
    return this.catsService.getCatFamily(id);
  }

  @Patch(":id")
  @ApiOperation({ summary: "çŒ«ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°" })
  @ApiResponse({
    status: HttpStatus.OK,
    description: "çŒ«ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«æ›´æ–°ã•ã‚Œã¾ã—ãŸ",
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: "çŒ«ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: "ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§ã™",
  })
  @ApiParam({ name: "id", description: "çŒ«ãƒ‡ãƒ¼ã‚¿ã®ID" })
  update(
    @Param("id", new ParseUUIDPipe({ version: "4" })) id: string,
    @Body() updateCatDto: UpdateCatDto,
  ) {
    this.logger.log({
      message: 'Updating cat',
      catId: id,
      fields: Object.keys(updateCatDto),
      timestamp: new Date().toISOString(),
    });
    return this.catsService.update(id, updateCatDto);
  }

  @Delete(":id")
  @ApiOperation({ summary: "çŒ«ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤" })
  @ApiResponse({
    status: HttpStatus.OK,
    description: "çŒ«ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«å‰Šé™¤ã•ã‚Œã¾ã—ãŸ",
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: "çŒ«ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
  })
  @ApiParam({ name: "id", description: "çŒ«ãƒ‡ãƒ¼ã‚¿ã®ID" })
  remove(@Param("id", new ParseUUIDPipe({ version: "4" })) id: string) {
    this.logger.warn({
      message: 'Deleting cat',
      catId: id,
      timestamp: new Date().toISOString(),
    });
    return this.catsService.remove(id);
  }

  @Get("genders")
  @ApiOperation({ summary: "æ€§åˆ¥ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—" })
  @ApiResponse({
    status: HttpStatus.OK,
    description: "æ€§åˆ¥ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’è¿”å´",
  })
  getGenders() {
    return {
      success: true,
      data: GENDER_MASTER.map(record => ({
        id: parseInt(record.key),
        code: parseInt(record.key),
        name: record.name,
        canonical: record.canonical,
      })),
    };
  }

  // ==========================================
  // ä½“é‡è¨˜éŒ² API ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
  // ==========================================

  @Get(":id/weight-records")
  @Header("Cache-Control", "no-cache")
  @ApiOperation({ summary: "çŒ«ã®ä½“é‡è¨˜éŒ²ä¸€è¦§ã‚’å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK, description: "ä½“é‡è¨˜éŒ²ä¸€è¦§" })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: "çŒ«ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
  })
  @ApiParam({ name: "id", description: "çŒ«ãƒ‡ãƒ¼ã‚¿ã®ID" })
  @ApiQuery({
    name: "page",
    required: false,
    description: "ãƒšãƒ¼ã‚¸ç•ªå·",
    example: 1,
  })
  @ApiQuery({
    name: "limit",
    required: false,
    description: "1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•°",
    example: 50,
  })
  @ApiQuery({
    name: "startDate",
    required: false,
    description: "é–‹å§‹æ—¥",
  })
  @ApiQuery({
    name: "endDate",
    required: false,
    description: "çµ‚äº†æ—¥",
  })
  @ApiQuery({
    name: "sortOrder",
    required: false,
    description: "ã‚½ãƒ¼ãƒˆé †",
    example: "desc",
  })
  getWeightRecords(
    @Param("id", new ParseUUIDPipe({ version: "4" })) id: string,
    @Query() query: WeightRecordQueryDto,
    @GetUser() user: RequestUser,
  ) {
    return this.catsService.getWeightRecords(id, query, user.userId);
  }

  @Post(":id/weight-records")
  @ApiOperation({ summary: "çŒ«ã®ä½“é‡è¨˜éŒ²ã‚’è¿½åŠ " })
  @ApiResponse({
    status: HttpStatus.CREATED,
    description: "ä½“é‡è¨˜éŒ²ãŒæ­£å¸¸ã«ä½œæˆã•ã‚Œã¾ã—ãŸ",
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: "çŒ«ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: "ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§ã™",
  })
  @ApiParam({ name: "id", description: "çŒ«ãƒ‡ãƒ¼ã‚¿ã®ID" })
  createWeightRecord(
    @Param("id", new ParseUUIDPipe({ version: "4" })) id: string,
    @Body() dto: CreateWeightRecordDto,
    @GetUser() user: RequestUser,
  ) {
    this.logger.log({
      message: "Creating weight record",
      catId: id,
      weight: dto.weight,
      timestamp: new Date().toISOString(),
    });
    return this.catsService.createWeightRecord(id, dto, user.userId);
  }

  @Get("weight-records/:recordId")
  @ApiOperation({ summary: "ä½“é‡è¨˜éŒ²ã‚’å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK, description: "ä½“é‡è¨˜éŒ²" })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: "ä½“é‡è¨˜éŒ²ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
  })
  @ApiParam({ name: "recordId", description: "ä½“é‡è¨˜éŒ²ã®ID" })
  getWeightRecord(
    @Param("recordId", new ParseUUIDPipe({ version: "4" })) recordId: string,
  ) {
    return this.catsService.getWeightRecord(recordId);
  }

  @Patch("weight-records/:recordId")
  @ApiOperation({ summary: "ä½“é‡è¨˜éŒ²ã‚’æ›´æ–°" })
  @ApiResponse({
    status: HttpStatus.OK,
    description: "ä½“é‡è¨˜éŒ²ãŒæ­£å¸¸ã«æ›´æ–°ã•ã‚Œã¾ã—ãŸ",
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: "ä½“é‡è¨˜éŒ²ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: "ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§ã™",
  })
  @ApiParam({ name: "recordId", description: "ä½“é‡è¨˜éŒ²ã®ID" })
  updateWeightRecord(
    @Param("recordId", new ParseUUIDPipe({ version: "4" })) recordId: string,
    @Body() dto: UpdateWeightRecordDto,
    @GetUser() user: RequestUser,
  ) {
    this.logger.log({
      message: "Updating weight record",
      recordId,
      fields: Object.keys(dto),
      timestamp: new Date().toISOString(),
    });
    return this.catsService.updateWeightRecord(recordId, dto, user.userId);
  }

  @Delete("weight-records/:recordId")
  @ApiOperation({ summary: "ä½“é‡è¨˜éŒ²ã‚’å‰Šé™¤" })
  @ApiResponse({
    status: HttpStatus.OK,
    description: "ä½“é‡è¨˜éŒ²ãŒæ­£å¸¸ã«å‰Šé™¤ã•ã‚Œã¾ã—ãŸ",
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: "ä½“é‡è¨˜éŒ²ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
  })
  @ApiParam({ name: "recordId", description: "ä½“é‡è¨˜éŒ²ã®ID" })
  deleteWeightRecord(
    @Param("recordId", new ParseUUIDPipe({ version: "4" })) recordId: string,
    @GetUser() user: RequestUser,
  ) {
    this.logger.warn({
      message: "Deleting weight record",
      recordId,
      timestamp: new Date().toISOString(),
    });
    return this.catsService.deleteWeightRecord(recordId, user.userId);
  }

  @Post("weight-records/bulk")
  @ApiOperation({ summary: "è¤‡æ•°ã®çŒ«ã®ä½“é‡ã‚’ä¸€æ‹¬ç™»éŒ²" })
  @ApiResponse({
    status: HttpStatus.CREATED,
    description: "ä½“é‡è¨˜éŒ²ãŒæ­£å¸¸ã«ä¸€æ‹¬ä½œæˆã•ã‚Œã¾ã—ãŸ",
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: "ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§ã™",
  })
  createBulkWeightRecords(
    @Body() dto: CreateBulkWeightRecordsDto,
    @GetUser() user: RequestUser,
  ) {
    this.logger.log({
      message: "Creating bulk weight records",
      count: dto.records.length,
      recordedAt: dto.recordedAt,
      timestamp: new Date().toISOString(),
    });
    return this.catsService.createBulkWeightRecords(dto, user.userId);
  }
}
`````

## File: backend/src/cats/cats.module.ts
`````typescript
import { Module } from "@nestjs/common";
import { EventEmitterModule } from "@nestjs/event-emitter";

import { AuthModule } from "../auth/auth.module";
import { PrismaModule } from "../prisma/prisma.module";

import { CatsController } from "./cats.controller";
import { CatsService } from "./cats.service";

@Module({
  imports: [PrismaModule, AuthModule, EventEmitterModule],
  controllers: [CatsController],
  providers: [CatsService],
  exports: [CatsService],
})
export class CatsModule {}
`````

## File: backend/src/cats/cats.service.spec.ts
`````typescript
import { BadRequestException, NotFoundException } from '@nestjs/common';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { Test, TestingModule } from '@nestjs/testing';

import { PrismaService } from '../prisma/prisma.service';

import { CatsService } from './cats.service';
import { CreateCatDto } from './dto';

describe('CatsService', () => {
  let service: CatsService;
  let _prismaService: PrismaService;
  let _eventEmitter: EventEmitter2;

  const mockPrismaService = {
    cat: {
      create: jest.fn(),
      findMany: jest.fn(),
      findUnique: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
      count: jest.fn(),
      groupBy: jest.fn(),
    },
    kittenDisposition: {
      deleteMany: jest.fn(),
    },
    breed: {
      findUnique: jest.fn(),
      findFirst: jest.fn(),
      findMany: jest.fn(),
    },
    coatColor: {
      findUnique: jest.fn(),
      findFirst: jest.fn(),
    },
    tag: {
      findMany: jest.fn(),
    },
    catTag: {
      count: jest.fn(),
    },
  };

  const mockEventEmitter = {
    emit: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        CatsService,
        {
          provide: PrismaService,
          useValue: mockPrismaService,
        },
        {
          provide: EventEmitter2,
          useValue: mockEventEmitter,
        },
      ],
    }).compile();

    service = module.get<CatsService>(CatsService);
    _prismaService = module.get<PrismaService>(PrismaService);
    _eventEmitter = module.get<EventEmitter2>(EventEmitter2);

    jest.clearAllMocks();
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('create', () => {
    it('should create a cat successfully', async () => {
      const createCatDto: CreateCatDto = {
        name: 'Test Cat',
        gender: 'FEMALE',
        birthDate: '2024-01-01',
        isInHouse: true,
      };

      const mockCat = {
        id: '1',
        ...createCatDto,
        birthDate: new Date(createCatDto.birthDate),
        breed: null,
        coatColor: null,
        tags: [],
      };

      mockPrismaService.cat.create.mockResolvedValue(mockCat);

      const result = await service.create(createCatDto);

      expect(result).toEqual(mockCat);
      expect(mockPrismaService.cat.create).toHaveBeenCalledTimes(1);
    });

    it('should throw BadRequestException for invalid breed', async () => {
      const createCatDto: CreateCatDto = {
        name: 'Test Cat',
        gender: 'FEMALE',
        birthDate: '2024-01-01',
        breedId: 'invalid-breed-id',
        isInHouse: true,
      };

      mockPrismaService.breed.findUnique.mockResolvedValue(null);
      mockPrismaService.breed.findFirst.mockResolvedValue(null);

      await expect(service.create(createCatDto)).rejects.toThrow(BadRequestException);
    });

    it('should throw BadRequestException for invalid coat color', async () => {
      const createCatDto: CreateCatDto = {
        name: 'Test Cat',
        gender: 'FEMALE',
        birthDate: '2024-01-01',
        coatColorId: 'invalid-color-id',
        isInHouse: true,
      };

      mockPrismaService.coatColor.findUnique.mockResolvedValue(null);
      mockPrismaService.coatColor.findFirst.mockResolvedValue(null);

      await expect(service.create(createCatDto)).rejects.toThrow(BadRequestException);
    });
  });

  describe('findAll', () => {
    it('should return paginated cats', async () => {
      const mockCats = [
        { id: '1', name: 'Cat 1', gender: 'FEMALE', birthDate: new Date() },
        { id: '2', name: 'Cat 2', gender: 'MALE', birthDate: new Date() },
      ];

      mockPrismaService.cat.findMany.mockResolvedValue(mockCats);
      mockPrismaService.cat.count.mockResolvedValue(2);

      const result = await service.findAll({});

      expect(result.data).toEqual(mockCats);
      expect(result.meta.total).toBe(2);
      expect(mockPrismaService.cat.findMany).toHaveBeenCalledTimes(1);
      expect(mockPrismaService.cat.count).toHaveBeenCalledTimes(1);
    });

    it('should filter cats by gender', async () => {
      const mockCats = [
        { id: '1', name: 'Cat 1', gender: 'FEMALE', birthDate: new Date() },
      ];

      mockPrismaService.cat.findMany.mockResolvedValue(mockCats);
      mockPrismaService.cat.count.mockResolvedValue(1);

      const result = await service.findAll({ gender: 'FEMALE' as any });

      expect(result.data).toEqual(mockCats);
      expect(result.meta.total).toBe(1);
    });
  });

  describe('findOne', () => {
    it('should return a cat by id', async () => {
      const mockCat = {
        id: '1',
        name: 'Test Cat',
        gender: 'FEMALE',
        birthDate: new Date(),
      };

      mockPrismaService.cat.findUnique.mockResolvedValue(mockCat);

      const result = await service.findOne('1');

      expect(result).toEqual(mockCat);
      expect(mockPrismaService.cat.findUnique).toHaveBeenCalledWith({
        where: { id: '1' },
        include: expect.any(Object),
      });
    });

    it('should throw NotFoundException when cat not found', async () => {
      mockPrismaService.cat.findUnique.mockResolvedValue(null);

      await expect(service.findOne('non-existent')).rejects.toThrow(NotFoundException);
    });
  });

  describe('update', () => {
    it('should update a cat successfully', async () => {
      const updateDto = { name: 'Updated Cat' };
      const mockCat = {
        id: '1',
        name: 'Updated Cat',
        gender: 'FEMALE',
        birthDate: new Date(),
      };

      mockPrismaService.cat.findUnique.mockResolvedValue(mockCat);
      mockPrismaService.cat.update.mockResolvedValue(mockCat);

      const result = await service.update('1', updateDto);

      expect(result).toEqual(mockCat);
      expect(mockPrismaService.cat.update).toHaveBeenCalledTimes(1);
    });

    it('should throw NotFoundException when updating non-existent cat', async () => {
      mockPrismaService.cat.findUnique.mockResolvedValue(null);

      await expect(service.update('non-existent', { name: 'Updated' })).rejects.toThrow(
        NotFoundException,
      );
    });
  });

  describe('remove', () => {
    it('should delete a cat successfully', async () => {
      const mockCat = {
        id: '1',
        name: 'Test Cat',
        gender: 'FEMALE',
        birthDate: new Date(),
      };

      mockPrismaService.cat.findUnique.mockResolvedValue(mockCat);
      mockPrismaService.cat.delete.mockResolvedValue(mockCat);

      await service.remove('1');

      expect(mockPrismaService.kittenDisposition.deleteMany).toHaveBeenCalledWith({
        where: { kittenId: '1' },
      });
      expect(mockPrismaService.cat.delete).toHaveBeenCalledWith({
        where: { id: '1' },
        include: {
          breed: {
            select: {
              id: true,
              name: true,
              code: true,
            },
          },
          coatColor: {
            select: {
              id: true,
              name: true,
              code: true,
            },
          },
          father: {
            select: {
              id: true,
              name: true,
              gender: true,
            },
          },
          mother: {
            select: {
              id: true,
              name: true,
              gender: true,
            },
          },
          pedigree: {
            select: {
              id: true,
              pedigreeId: true,
              catName: true,
              breedCode: true,
              coatColorCode: true,
              genderCode: true,
              birthDate: true,
              breederName: true,
              ownerName: true,
            },
          },
          tags: {
            include: {
              tag: {
                select: {
                  id: true,
                  name: true,
                  color: true,
                  textColor: true,
                  group: {
                    select: {
                      id: true,
                      name: true,
                      category: {
                        select: {
                          id: true,
                          name: true,
                        },
                      },
                    },
                  },
                },
              },
            },
          },
        },
      });
    });

    it('should throw NotFoundException when deleting non-existent cat', async () => {
      mockPrismaService.cat.findUnique.mockResolvedValue(null);

      await expect(service.remove('non-existent')).rejects.toThrow(NotFoundException);
    });
  });

  describe('getStatistics', () => {
    it('should return cat statistics', async () => {
      // å…¨çŒ«æ•°
      mockPrismaService.cat.count.mockResolvedValue(18);
      
      // æ€§åˆ¥åˆ†å¸ƒã¨ãƒ–ãƒªãƒ¼ãƒ‰åˆ†å¸ƒã®groupByï¼ˆ2å›å‘¼ã°ã‚Œã‚‹ï¼‰
      mockPrismaService.cat.groupBy
        .mockResolvedValueOnce([
          { gender: 'MALE', _count: 8 },
          { gender: 'FEMALE', _count: 10 },
        ])
        .mockResolvedValueOnce([
          { breedId: 'breed-1', _count: 10 },
          { breedId: 'breed-2', _count: 8 },
        ]);

      // åœ¨èˆçŒ«ã®ãƒ‡ãƒ¼ã‚¿ï¼ˆã‚¿ãƒ–ã‚«ã‚¦ãƒ³ãƒˆè¨ˆç®—ç”¨ï¼‰
      const sixMonthsAgo = new Date();
      sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
      const threeMonthsAgo = new Date();
      threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
      
      mockPrismaService.cat.findMany.mockResolvedValue([
        { id: 'cat-1', gender: 'MALE', birthDate: new Date('2023-01-01'), motherId: null },
        { id: 'cat-2', gender: 'FEMALE', birthDate: new Date('2023-02-01'), motherId: null },
        { id: 'cat-3', gender: 'MALE', birthDate: new Date(Date.now() - 2 * 30 * 24 * 60 * 60 * 1000), motherId: 'cat-2' },
      ]);

      // é¤Šæˆä¸­ã‚¿ã‚°æ•°
      mockPrismaService.catTag.count
        .mockResolvedValueOnce(2)
        // å’æ¥­äºˆå®šã‚¿ã‚°æ•°
        .mockResolvedValueOnce(1);

      // ãƒ–ãƒªãƒ¼ãƒ‰æƒ…å ±
      mockPrismaService.breed.findMany.mockResolvedValue([
        { id: 'breed-1', name: 'Persian', code: 1 },
        { id: 'breed-2', name: 'Siamese', code: 2 },
      ]);

      const result = await service.getStatistics();

      expect(result.total).toBe(18);
      expect(result.genderDistribution.MALE).toBe(8);
      expect(result.genderDistribution.FEMALE).toBe(10);
    });
  });
});
`````

## File: backend/src/cats/cats.service.ts
`````typescript
import {
  Injectable,
  NotFoundException,
  BadRequestException,
  ConflictException,
} from "@nestjs/common";
import { EventEmitter2 } from "@nestjs/event-emitter";
import { Prisma } from "@prisma/client";

import { PrismaService } from "../prisma/prisma.service";
import { TAG_AUTOMATION_EVENTS } from "../tags/events/tag-automation.events";

import {
  CreateCatDto,
  UpdateCatDto,
  CatQueryDto,
  KittenQueryDto,
  CreateWeightRecordDto,
  UpdateWeightRecordDto,
  WeightRecordQueryDto,
  WeightRecordResponse,
  WeightRecordsListResponse,
  CreateBulkWeightRecordsDto,
  BulkWeightRecordsResponse,
  CatFamilyResponse,
  ParentInfo,
  AncestorInfo,
  SiblingInfo,
  OffspringInfo,
  CatStatisticsResponse,
} from "./dto";
import { catWithRelationsInclude, CatWithRelations } from "./types/cat.types";

@Injectable()
export class CatsService {
  constructor(
    private prisma: PrismaService,
    private eventEmitter: EventEmitter2,
  ) {}

  async create(createCatDto: CreateCatDto) {
    const {
      name,
      gender,
      birthDate,
      breedId,
      coatColorId,
      microchipNumber,
      registrationNumber,
      description,
      isInHouse,
      fatherId,
      motherId,
      tagIds,
    } = createCatDto;

    // Validate breed if provided
    let breedIdToConnect: string | undefined;
    if (breedId) {
      // Try to find by ID first
      let breed = await this.prisma.breed.findUnique({
        where: { id: breedId },
      });
      
      // If not found by ID, try to find by name
      if (!breed) {
        breed = await this.prisma.breed.findFirst({
          where: { name: breedId },
        });
      }
      
      if (!breed) {
        throw new BadRequestException("Invalid breed ID or name");
      }
      
      breedIdToConnect = breed.id;
    }

    // Validate coatColor if provided
    let coatColorIdToConnect: string | undefined;
    if (coatColorId) {
      // Try to find by ID first
      let color = await this.prisma.coatColor.findUnique({
        where: { id: coatColorId },
      });
      
      // If not found by ID, try to find by name
      if (!color) {
        color = await this.prisma.coatColor.findFirst({
          where: { name: coatColorId },
        });
      }
      
      if (!color) {
        throw new BadRequestException("Invalid coat color ID or name");
      }
      
      coatColorIdToConnect = color.id;
    }

    const birth = new Date(birthDate);

    try {
      // Create the cat
      let cat = await this.prisma.cat.create({
        data: {
          name,
          gender,
          birthDate: birth,
          ...(registrationNumber ? { registrationNumber } : {}),
          ...(microchipNumber ? { microchipNumber } : {}),
          ...(description ? { description } : {}),
          isInHouse: isInHouse ?? true,
          ...(breedIdToConnect ? { breed: { connect: { id: breedIdToConnect } } } : {}),
          ...(coatColorIdToConnect ? { coatColor: { connect: { id: coatColorIdToConnect } } } : {}),
          ...(fatherId ? { father: { connect: { id: fatherId } } } : {}),
          ...(motherId ? { mother: { connect: { id: motherId } } } : {}),
        },
        include: catWithRelationsInclude,
      });

      // Handle tag assignments if provided
      if (tagIds && tagIds.length > 0) {
        await this.prisma.catTag.createMany({
          data: tagIds.map((tagId) => ({
            catId: cat.id,
            tagId,
          })),
          skipDuplicates: true,
        });

        // Fetch the cat again with tags
        const updatedCat = await this.prisma.cat.findUnique({
          where: { id: cat.id },
          include: catWithRelationsInclude,
        });
        if (updatedCat) {
          cat = updatedCat;
        }
      }

      // å­çŒ«ç™»éŒ²ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«ï¼ˆæ¯çŒ«ã¾ãŸã¯çˆ¶çŒ«ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆï¼‰
      if (cat && (motherId || fatherId)) {
        this.eventEmitter.emit(TAG_AUTOMATION_EVENTS.KITTEN_REGISTERED, {
          eventType: "KITTEN_REGISTERED" as const,
          kittenId: cat.id,
          motherId: motherId || undefined,
          fatherId: fatherId || undefined,
        });
      }

      return cat;
    } catch (error) {
      if (
        error instanceof Prisma.PrismaClientKnownRequestError &&
        error.code === "P2002"
      ) {
        const target = error.meta?.target as string[] | undefined;
        if (target?.includes("microchipNumber") || target?.includes("microchip_number")) {
          throw new ConflictException("Cat with the same microchip number already exists");
        }
        throw new ConflictException("Cat with the same registration number already exists");
      }
      throw error;
    }
  }

  async findAll(query: CatQueryDto) {
    const {
      page = 1,
      limit = 10,
      search,
      breedId,
      coatColorId,
      gender,
      isInHouse,
      ageMin,
      ageMax,
      sortBy = "createdAt",
      sortOrder = "desc",
    } = query;

    const skip = (page - 1) * limit;
    const where: Prisma.CatWhereInput = {};

    // Search functionality
    if (search) {
      where.OR = [
        { name: { contains: search, mode: "insensitive" } },
        { microchipNumber: { contains: search, mode: "insensitive" } },
        { description: { contains: search, mode: "insensitive" } },
      ];
    }

    // Filters
    if (breedId) where.breedId = breedId;
    if (coatColorId) where.coatColorId = coatColorId;
    if (gender) {
      where.gender = gender;
    }
    if (isInHouse !== undefined) {
      where.isInHouse = isInHouse;
    }

    // Age filters
    if (ageMin || ageMax) {
      const now = new Date();
      const birthFilter: Prisma.DateTimeFilter = {};
      if (ageMax) {
        const minBirthDate = new Date(
          now.getFullYear() - ageMax,
          now.getMonth(),
          now.getDate(),
        );
        birthFilter.gte = minBirthDate;
      }
      if (ageMin) {
        const maxBirthDate = new Date(
          now.getFullYear() - ageMin,
          now.getMonth(),
          now.getDate(),
        );
        birthFilter.lte = maxBirthDate;
      }
      if (birthFilter.gte || birthFilter.lte) {
        where.birthDate = birthFilter;
      }
    }

    type Sortable = "createdAt" | "updatedAt" | "name" | "birthDate";
    const orderBy: Prisma.CatOrderByWithRelationInput = {
      [sortBy as Sortable]: sortOrder,
    } as Prisma.CatOrderByWithRelationInput;

    const [cats, total] = (await Promise.all([
      this.prisma.cat.findMany({
        where,
        skip,
        take: limit,
        include: catWithRelationsInclude,
        orderBy,
      }),
      this.prisma.cat.count({ where }),
    ])) as [CatWithRelations[], number];

    return {
      data: cats,
      meta: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  async findOne(id: string) {
    const cat = await this.prisma.cat.findUnique({
      where: { id },
      include: catWithRelationsInclude,
    });

    if (!cat) {
      throw new NotFoundException(`Cat with ID ${id} not found`);
    }

    return cat;
  }

  async update(id: string, updateCatDto: UpdateCatDto) {
    const existingCat = await this.prisma.cat.findUnique({
      where: { id },
    });

    if (!existingCat) {
      throw new NotFoundException(`Cat with ID ${id} not found`);
    }

    const {
      name,
      gender,
      birthDate,
      breedId,
      coatColorId,
      microchipNumber,
      registrationNumber,
      description,
      isInHouse,
      fatherId,
      motherId,
      tagIds,
    } = updateCatDto;

    // Validate breed if provided
    let breedIdToConnect: string | undefined;
    if (breedId) {
      // Try to find by ID first
      let breed = await this.prisma.breed.findUnique({
        where: { id: breedId },
      });
      
      // If not found by ID, try to find by name
      if (!breed) {
        breed = await this.prisma.breed.findFirst({
          where: { name: breedId },
        });
      }
      
      if (!breed) {
        throw new BadRequestException("Invalid breed ID or name");
      }
      
      breedIdToConnect = breed.id;
    }

    // Validate color if provided
    let coatColorIdToConnect: string | undefined;
    if (coatColorId) {
      // Try to find by ID first
      let color = await this.prisma.coatColor.findUnique({
        where: { id: coatColorId },
      });
      
      // If not found by ID, try to find by name
      if (!color) {
        color = await this.prisma.coatColor.findFirst({
          where: { name: coatColorId },
        });
      }
      
      if (!color) {
        throw new BadRequestException("Invalid coat color ID or name");
      }
      
      coatColorIdToConnect = color.id;
    }

    const birth = birthDate ? new Date(birthDate) : undefined;

    try {
      // ã‚¿ã‚°ã®æ›´æ–°å‡¦ç†ï¼ˆtagIdsãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆï¼‰
      if (tagIds !== undefined) {
        // æ—¢å­˜ã®ã‚¿ã‚°ã‚’å…¨ã¦å‰Šé™¤
        await this.prisma.catTag.deleteMany({
          where: { catId: id },
        });

        // æ–°ã—ã„ã‚¿ã‚°ã‚’è¿½åŠ 
        if (tagIds.length > 0) {
          await this.prisma.catTag.createMany({
            data: tagIds.map((tagId) => ({
              catId: id,
              tagId,
            })),
            skipDuplicates: true,
          });
        }
      }

      return await this.prisma.cat.update({
        where: { id },
        data: {
          ...(name ? { name } : {}),
          ...(gender ? { gender } : {}),
          ...(birth ? { birthDate: birth } : {}),
          ...(registrationNumber !== undefined ? { registrationNumber } : {}),
          ...(microchipNumber !== undefined ? { microchipNumber } : {}),
          ...(description !== undefined ? { description } : {}),
          ...(isInHouse !== undefined ? { isInHouse } : {}),
          ...(breedIdToConnect ? { breed: { connect: { id: breedIdToConnect } } } : {}),
          ...(coatColorIdToConnect ? { coatColor: { connect: { id: coatColorIdToConnect } } } : {}),
          ...(fatherId ? { father: { connect: { id: fatherId } } } : {}),
          ...(motherId ? { mother: { connect: { id: motherId } } } : {}),
        },
        include: catWithRelationsInclude,
      });
    } catch (error) {
      if (
        error instanceof Prisma.PrismaClientKnownRequestError &&
        error.code === "P2002"
      ) {
        const target = error.meta?.target as string[] | undefined;
        if (target?.includes("microchipNumber") || target?.includes("microchip_number")) {
          throw new ConflictException("Cat with the same microchip number already exists");
        }
        throw new ConflictException("Cat with the same registration number already exists");
      }
      throw error;
    }
  }

  async remove(id: string) {
    const existingCat = await this.prisma.cat.findUnique({
      where: { id },
    });

    if (!existingCat) {
      throw new NotFoundException(`Cat with ID ${id} not found`);
    }

    await this.prisma.kittenDisposition.deleteMany({
      where: { kittenId: id },
    });

    return this.prisma.cat.delete({
      where: { id },
      include: catWithRelationsInclude,
    });
  }

  async getBreedingHistory(id: string) {
    const cat = await this.findOne(id);

    const breedingRecords = await this.prisma.breedingRecord.findMany({
      where: {
        OR: [{ maleId: id }, { femaleId: id }],
      },
      include: {
        male: {
          include: {
            breed: true,
            coatColor: true,
          },
        },
        female: {
          include: {
            breed: true,
            coatColor: true,
          },
        },
        recorder: true,
      },
      orderBy: {
        breedingDate: "desc",
      },
    });

    return {
      cat,
      breedingRecords,
    };
  }

  async getCareHistory(id: string) {
    const cat = await this.findOne(id);

    const careRecords = await this.prisma.careRecord.findMany({
      where: { catId: id },
      include: {
        recorder: true,
      },
      orderBy: {
        careDate: "desc",
      },
    });

    return {
      cat,
      careRecords,
    };
  }

  async getStatistics(): Promise<CatStatisticsResponse> {
    // ç”Ÿå¾Œ6ãƒ¶æœˆã®åŸºæº–æ—¥ã‚’è¨ˆç®—ï¼ˆæˆçŒ«åˆ¤å®šç”¨ï¼‰
    const sixMonthsAgo = new Date();
    sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);

    // ç”Ÿå¾Œ3ãƒ¶æœˆã®åŸºæº–æ—¥ã‚’è¨ˆç®—ï¼ˆå­çŒ«åˆ¤å®šç”¨ï¼‰
    const threeMonthsAgo = new Date();
    threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);

    // åŸºæœ¬çµ±è¨ˆã¨ã‚¿ãƒ–åˆ¥ã‚«ã‚¦ãƒ³ãƒˆã‚’ä¸¦åˆ—å–å¾—
    const [
      totalCats,
      genderGroups,
      breedStats,
      // ã‚¿ãƒ–åˆ¥ã‚«ã‚¦ãƒ³ãƒˆç”¨ã‚¯ã‚¨ãƒª
      inHouseCats,
      raisingTagCats,
      gradTagCats,
    ] = await Promise.all([
      // å…¨çŒ«æ•°
      this.prisma.cat.count(),
      // æ€§åˆ¥åˆ†å¸ƒ
      this.prisma.cat.groupBy({
        by: ["gender"],
        _count: true,
      }),
      // å“ç¨®åˆ†å¸ƒï¼ˆä¸Šä½10ä»¶ï¼‰
      this.prisma.cat.groupBy({
        by: ["breedId"],
        _count: true,
        orderBy: {
          _count: {
            breedId: "desc",
          },
        },
        take: 10,
      }),
      // åœ¨èˆçŒ«ã®åŸºæœ¬æƒ…å ±ï¼ˆã‚¿ãƒ–ã‚«ã‚¦ãƒ³ãƒˆè¨ˆç®—ç”¨ï¼‰
      this.prisma.cat.findMany({
        where: { isInHouse: true },
        select: {
          id: true,
          gender: true,
          birthDate: true,
          motherId: true,
        },
      }),
      // é¤Šæˆä¸­ã‚¿ã‚°ãŒä»˜ã„ãŸçŒ«æ•°
      this.prisma.catTag.count({
        where: {
          cat: { isInHouse: true },
          tag: { name: "é¤Šæˆä¸­" },
        },
      }),
      // å’æ¥­äºˆå®šã‚¿ã‚°ãŒä»˜ã„ãŸçŒ«æ•°
      this.prisma.catTag.count({
        where: {
          cat: { isInHouse: true },
          tag: { name: "å’æ¥­äºˆå®š" },
        },
      }),
    ]);

    // æ€§åˆ¥åˆ†å¸ƒã‚’æ§‹ç¯‰
    const genderDistribution: Record<string, number> = {
      MALE: 0,
      FEMALE: 0,
      NEUTER: 0,
      SPAY: 0,
    };

    for (const group of genderGroups) {
      if (group.gender === "MALE" || group.gender === "FEMALE" || group.gender === "NEUTER" || group.gender === "SPAY") {
        genderDistribution[group.gender] = group._count;
      }
    }

    // å“ç¨®æƒ…å ±ã‚’å–å¾—
    const breedIds = breedStats.map((stat) => stat.breedId).filter((id): id is string => id !== null);
    const breeds = await this.prisma.breed.findMany({
      where: { id: { in: breedIds } },
    });

    const breedStatsWithNames = breedStats.map((stat) => ({
      breed: breeds.find((breed) => breed.id === stat.breedId) ?? null,
      count: stat._count,
    }));

    // ã‚¿ãƒ–åˆ¥ã‚«ã‚¦ãƒ³ãƒˆã‚’è¨ˆç®—
    // æˆçŒ«: ç”Ÿå¾Œ6ãƒ¶æœˆä»¥ä¸Šã®åœ¨èˆçŒ«
    const adultCats = inHouseCats.filter(
      (cat) => new Date(cat.birthDate) < sixMonthsAgo
    );

    // å­çŒ«: ç”Ÿå¾Œ3ãƒ¶æœˆä»¥å†… + æ¯çŒ«ã‚ã‚Š
    const kittenCount = inHouseCats.filter((cat) => {
      if (!cat.motherId) return false;
      return new Date(cat.birthDate) >= threeMonthsAgo;
    }).length;

    // ã‚ªã‚¹æˆçŒ«æ•°
    const maleCount = adultCats.filter((cat) => cat.gender === "MALE").length;

    // ãƒ¡ã‚¹æˆçŒ«æ•°
    const femaleCount = adultCats.filter((cat) => cat.gender === "FEMALE").length;

    return {
      total: totalCats,
      genderDistribution: {
        MALE: genderDistribution.MALE,
        FEMALE: genderDistribution.FEMALE,
        NEUTER: genderDistribution.NEUTER,
        SPAY: genderDistribution.SPAY,
      },
      breedDistribution: breedStatsWithNames,
      tabCounts: {
        total: adultCats.length,
        male: maleCount,
        female: femaleCount,
        kitten: kittenCount,
        raising: raisingTagCats,
        grad: gradTagCats,
      },
    };
  }

  /**
   * å­çŒ«ä¸€è¦§ã‚’å–å¾—ï¼ˆç”Ÿå¾Œ6ãƒ¶æœˆæœªæº€ã€æ¯çŒ«ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ï¼‰
   */
  async findKittens(query: KittenQueryDto) {
    const {
      motherId,
      page = 1,
      limit = 50,
      search,
      sortBy = "birthDate",
      sortOrder = "desc",
    } = query;

    // ç”Ÿå¾Œ6ãƒ¶æœˆã®åŸºæº–æ—¥ã‚’è¨ˆç®—
    const sixMonthsAgo = new Date();
    sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);

    const skip = (page - 1) * limit;
    const where: Prisma.CatWhereInput = {
      // ç”Ÿå¾Œ6ãƒ¶æœˆæœªæº€
      birthDate: { gte: sixMonthsAgo },
      // æ¯çŒ«ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ï¼ˆå­çŒ«ã¨ã—ã¦ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ï¼‰
      motherId: motherId ? motherId : { not: null },
    };

    // æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
    if (search) {
      where.OR = [
        { name: { contains: search, mode: "insensitive" } },
        { description: { contains: search, mode: "insensitive" } },
      ];
    }

    type Sortable = "birthDate" | "name" | "createdAt";
    const orderBy: Prisma.CatOrderByWithRelationInput = {
      [sortBy as Sortable]: sortOrder,
    } as Prisma.CatOrderByWithRelationInput;

    // å­çŒ«ä¸€è¦§ã‚’å–å¾—
    const [kittens, total] = await Promise.all([
      this.prisma.cat.findMany({
        where,
        skip,
        take: limit,
        include: {
          ...catWithRelationsInclude,
          mother: {
            select: {
              id: true,
              name: true,
              gender: true,
              birthDate: true,
              breed: {
                select: { id: true, name: true },
              },
              coatColor: {
                select: { id: true, name: true },
              },
            },
          },
        },
        orderBy,
      }),
      this.prisma.cat.count({ where }),
    ]);

    // æ¯çŒ«ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
    const motherGroups = new Map<string, {
      mother: {
        id: string;
        name: string;
        gender: string;
        birthDate: Date;
        breed: { id: string; name: string } | null;
        coatColor: { id: string; name: string } | null;
      };
      kittens: typeof kittens;
      fatherId: string | null;
    }>();

    for (const kitten of kittens) {
      if (!kitten.mother) continue;

      const motherId = kitten.mother.id;
      if (!motherGroups.has(motherId)) {
        motherGroups.set(motherId, {
          mother: kitten.mother,
          kittens: [],
          fatherId: kitten.fatherId,
        });
      }
      const group = motherGroups.get(motherId);
      if (group) {
        group.kittens.push(kitten);
      }
    }

    // çˆ¶çŒ«æƒ…å ±ã‚’å–å¾—
    const fatherIds = Array.from(motherGroups.values())
      .map((g) => g.fatherId)
      .filter((id): id is string => id !== null);
    
    const fathers = fatherIds.length > 0
      ? await this.prisma.cat.findMany({
          where: { id: { in: fatherIds } },
          select: {
            id: true,
            name: true,
            gender: true,
            breed: { select: { id: true, name: true } },
            coatColor: { select: { id: true, name: true } },
          },
        })
      : [];

    const fatherMap = new Map(fathers.map((f) => [f.id, f]));

    // ãƒ¬ã‚¹ãƒãƒ³ã‚¹å½¢å¼ã«å¤‰æ›
    const groupedData = Array.from(motherGroups.entries()).map(([, group]) => ({
      mother: group.mother,
      father: group.fatherId ? fatherMap.get(group.fatherId) ?? null : null,
      kittens: group.kittens,
      kittenCount: group.kittens.length,
      deliveryDate: group.kittens[0]?.birthDate ?? null,
    }));

    // å‡ºç”£æ—¥ã§é™é †ã‚½ãƒ¼ãƒˆï¼ˆæœ€æ–°ã®å‡ºç”£ãŒå…ˆé ­ï¼‰
    groupedData.sort((a, b) => {
      const dateA = a.deliveryDate ? new Date(a.deliveryDate).getTime() : 0;
      const dateB = b.deliveryDate ? new Date(b.deliveryDate).getTime() : 0;
      return dateB - dateA;
    });

    return {
      data: groupedData,
      meta: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
        totalGroups: motherGroups.size,
      },
    };
  }

  // ==========================================
  // ä½“é‡è¨˜éŒ² CRUD ãƒ¡ã‚½ãƒƒãƒ‰
  // ==========================================

  /**
   * çŒ«ã®ä½“é‡è¨˜éŒ²ä¸€è¦§ã‚’å–å¾—
   */
  async getWeightRecords(
    catId: string,
    query: WeightRecordQueryDto,
    _userId: string,
  ): Promise<WeightRecordsListResponse> {
    // çŒ«ã®å­˜åœ¨ç¢ºèª
    await this.findOne(catId);

    const {
      page = 1,
      limit = 50,
      startDate,
      endDate,
      sortOrder = "desc",
    } = query;

    const skip = (page - 1) * limit;
    const where: Prisma.WeightRecordWhereInput = { catId };

    // æ—¥ä»˜ãƒ•ã‚£ãƒ«ã‚¿
    if (startDate || endDate) {
      where.recordedAt = {};
      if (startDate) {
        where.recordedAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.recordedAt.lte = new Date(endDate);
      }
    }

    const [records, total] = await Promise.all([
      this.prisma.weightRecord.findMany({
        where,
        skip,
        take: limit,
        orderBy: { recordedAt: sortOrder },
        include: {
          recorder: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
            },
          },
        },
      }),
      this.prisma.weightRecord.count({ where }),
    ]);

    // ã‚µãƒãƒªãƒ¼æƒ…å ±ã‚’è¨ˆç®—
    const latestRecords = await this.prisma.weightRecord.findMany({
      where: { catId },
      orderBy: { recordedAt: "desc" },
      take: 2,
      select: { weight: true, recordedAt: true },
    });

    const latestWeight = latestRecords[0]?.weight ?? null;
    const previousWeight = latestRecords[1]?.weight ?? null;
    const weightChange =
      latestWeight !== null && previousWeight !== null
        ? latestWeight - previousWeight
        : null;
    const latestRecordedAt = latestRecords[0]?.recordedAt?.toISOString() ?? null;

    const data: WeightRecordResponse[] = records.map((record) => ({
      id: record.id,
      catId: record.catId,
      weight: record.weight,
      recordedAt: record.recordedAt.toISOString(),
      notes: record.notes,
      recordedBy: record.recordedBy,
      createdAt: record.createdAt.toISOString(),
      updatedAt: record.updatedAt.toISOString(),
      recorder: record.recorder,
    }));

    return {
      data,
      meta: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
      summary: {
        latestWeight,
        previousWeight,
        weightChange,
        latestRecordedAt,
        recordCount: total,
      },
    };
  }

  /**
   * ä½“é‡è¨˜éŒ²ã‚’ä½œæˆ
   */
  async createWeightRecord(
    catId: string,
    dto: CreateWeightRecordDto,
    userId: string,
  ): Promise<WeightRecordResponse> {
    // çŒ«ã®å­˜åœ¨ç¢ºèª
    await this.findOne(catId);

    const record = await this.prisma.weightRecord.create({
      data: {
        catId,
        weight: dto.weight,
        recordedAt: dto.recordedAt ? new Date(dto.recordedAt) : new Date(),
        notes: dto.notes,
        recordedBy: userId,
      },
      include: {
        recorder: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
          },
        },
      },
    });

    return {
      id: record.id,
      catId: record.catId,
      weight: record.weight,
      recordedAt: record.recordedAt.toISOString(),
      notes: record.notes,
      recordedBy: record.recordedBy,
      createdAt: record.createdAt.toISOString(),
      updatedAt: record.updatedAt.toISOString(),
      recorder: record.recorder,
    };
  }

  /**
   * ä½“é‡è¨˜éŒ²ã‚’æ›´æ–°
   */
  async updateWeightRecord(
    recordId: string,
    dto: UpdateWeightRecordDto,
    _userId: string,
  ): Promise<WeightRecordResponse> {
    const existingRecord = await this.prisma.weightRecord.findUnique({
      where: { id: recordId },
    });

    if (!existingRecord) {
      throw new NotFoundException(`ä½“é‡è¨˜éŒ²ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆID: ${recordId}ï¼‰`);
    }

    const record = await this.prisma.weightRecord.update({
      where: { id: recordId },
      data: {
        ...(dto.weight !== undefined ? { weight: dto.weight } : {}),
        ...(dto.recordedAt ? { recordedAt: new Date(dto.recordedAt) } : {}),
        ...(dto.notes !== undefined ? { notes: dto.notes } : {}),
      },
      include: {
        recorder: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
          },
        },
      },
    });

    return {
      id: record.id,
      catId: record.catId,
      weight: record.weight,
      recordedAt: record.recordedAt.toISOString(),
      notes: record.notes,
      recordedBy: record.recordedBy,
      createdAt: record.createdAt.toISOString(),
      updatedAt: record.updatedAt.toISOString(),
      recorder: record.recorder,
    };
  }

  /**
   * ä½“é‡è¨˜éŒ²ã‚’å‰Šé™¤
   */
  async deleteWeightRecord(recordId: string, _userId: string): Promise<void> {
    const existingRecord = await this.prisma.weightRecord.findUnique({
      where: { id: recordId },
    });

    if (!existingRecord) {
      throw new NotFoundException(`ä½“é‡è¨˜éŒ²ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆID: ${recordId}ï¼‰`);
    }

    await this.prisma.weightRecord.delete({
      where: { id: recordId },
    });
  }

  /**
   * å˜ä¸€ã®ä½“é‡è¨˜éŒ²ã‚’å–å¾—
   */
  async getWeightRecord(recordId: string): Promise<WeightRecordResponse> {
    const record = await this.prisma.weightRecord.findUnique({
      where: { id: recordId },
      include: {
        recorder: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
          },
        },
      },
    });

    if (!record) {
      throw new NotFoundException(`ä½“é‡è¨˜éŒ²ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆID: ${recordId}ï¼‰`);
    }

    return {
      id: record.id,
      catId: record.catId,
      weight: record.weight,
      recordedAt: record.recordedAt.toISOString(),
      notes: record.notes,
      recordedBy: record.recordedBy,
      createdAt: record.createdAt.toISOString(),
      updatedAt: record.updatedAt.toISOString(),
      recorder: record.recorder,
    };
  }

  /**
   * è¤‡æ•°ã®çŒ«ã®ä½“é‡ã‚’ä¸€æ‹¬ç™»éŒ²
   */
  async createBulkWeightRecords(
    dto: CreateBulkWeightRecordsDto,
    userId: string,
  ): Promise<BulkWeightRecordsResponse> {
    const { recordedAt, records } = dto;
    const recordedAtDate = new Date(recordedAt);

    // å…¨ã¦ã®çŒ«IDã®å­˜åœ¨ç¢ºèª
    const catIds = records.map((r) => r.catId);
    const existingCats = await this.prisma.cat.findMany({
      where: { id: { in: catIds } },
      select: { id: true },
    });

    const existingCatIds = new Set(existingCats.map((c) => c.id));
    const missingCatIds = catIds.filter((id) => !existingCatIds.has(id));

    if (missingCatIds.length > 0) {
      throw new BadRequestException(
        `ä»¥ä¸‹ã®çŒ«IDãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${missingCatIds.join(", ")}`,
      );
    }

    // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã§ä¸€æ‹¬ç™»éŒ²
    const createdRecords = await this.prisma.$transaction(
      records.map((record) =>
        this.prisma.weightRecord.create({
          data: {
            catId: record.catId,
            weight: record.weight,
            recordedAt: recordedAtDate,
            notes: record.notes,
            recordedBy: userId,
          },
          include: {
            recorder: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
                email: true,
              },
            },
          },
        }),
      ),
    );

    const responseRecords: WeightRecordResponse[] = createdRecords.map((r) => ({
      id: r.id,
      catId: r.catId,
      weight: r.weight,
      recordedAt: r.recordedAt.toISOString(),
      notes: r.notes,
      recordedBy: r.recordedBy,
      createdAt: r.createdAt.toISOString(),
      updatedAt: r.updatedAt.toISOString(),
      recorder: r.recorder,
    }));

    return {
      success: true,
      created: createdRecords.length,
      records: responseRecords,
    };
  }

  /**
   * è¤‡æ•°ã®çŒ«ã®ä½“é‡è¨˜éŒ²å±¥æ­´ã‚’ä¸€æ‹¬å–å¾—ï¼ˆãƒ†ãƒ¼ãƒ–ãƒ«è¡¨ç¤ºç”¨ï¼‰
   */
  async getWeightRecordsForKittens(
    catIds: string[],
    limit: number = 8,
  ): Promise<
    Map<
      string,
      Array<{
        id: string;
        weight: number;
        recordedAt: string;
        notes: string | null;
      }>
    >
  > {
    // å„çŒ«ã®æœ€æ–°Nä»¶ã®ä½“é‡è¨˜éŒ²ã‚’å–å¾—
    const records = await this.prisma.weightRecord.findMany({
      where: { catId: { in: catIds } },
      orderBy: { recordedAt: "desc" },
      select: {
        id: true,
        catId: true,
        weight: true,
        recordedAt: true,
        notes: true,
      },
    });

    // çŒ«ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã—ã€æœ€æ–°Nä»¶ã«åˆ¶é™
    const result = new Map<
      string,
      Array<{
        id: string;
        weight: number;
        recordedAt: string;
        notes: string | null;
      }>
    >();

    for (const catId of catIds) {
      const catRecords = records
        .filter((r) => r.catId === catId)
        .slice(0, limit)
        .map((r) => ({
          id: r.id,
          weight: r.weight,
          recordedAt: r.recordedAt.toISOString(),
          notes: r.notes,
        }));
      result.set(catId, catRecords);
    }

    return result;
  }

  /**
   * çŒ«ã®å®¶æ—æƒ…å ±ã‚’å–å¾—ï¼ˆè¡€çµ±ã‚¿ãƒ–ç”¨ï¼‰
   * - çˆ¶æ¯æƒ…å ±ï¼ˆPedigreeãŒã‚ã‚‹å ´åˆã¯ç¥–çˆ¶æ¯ãƒ»æ›¾ç¥–çˆ¶æ¯ã‚‚å«ã‚€ï¼‰
   * - å…„å¼Ÿå§‰å¦¹ï¼ˆä¸¡è¦ªãŒä¸€è‡´ã™ã‚‹çŒ«ã®ã¿ï¼‰
   * - å­çŒ«ä¸€è¦§
   */
  async getCatFamily(id: string): Promise<CatFamilyResponse> {
    // çŒ«ã®è©³ç´°æƒ…å ±ã‚’å–å¾—
    const cat = await this.prisma.cat.findUnique({
      where: { id },
      include: {
        breed: { select: { id: true, name: true } },
        coatColor: { select: { id: true, name: true } },
        father: {
          include: {
            breed: { select: { id: true, name: true } },
            coatColor: { select: { id: true, name: true } },
            pedigree: true,
          },
        },
        mother: {
          include: {
            breed: { select: { id: true, name: true } },
            coatColor: { select: { id: true, name: true } },
            pedigree: true,
          },
        },
        pedigree: true,
      },
    });

    if (!cat) {
      throw new NotFoundException(`çŒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆID: ${id}ï¼‰`);
    }

    // çˆ¶è¦ªæƒ…å ±ã®æ§‹ç¯‰
    const father = this.buildParentInfo(cat.father, "father");

    // æ¯è¦ªæƒ…å ±ã®æ§‹ç¯‰
    const mother = this.buildParentInfo(cat.mother, "mother");

    // å…„å¼Ÿå§‰å¦¹ã‚’å–å¾—ï¼ˆä¸¡è¦ªãŒä¸€è‡´ã™ã‚‹çŒ«ã®ã¿ï¼‰
    let siblings: SiblingInfo[] = [];
    if (cat.fatherId && cat.motherId) {
      const siblingCats = await this.prisma.cat.findMany({
        where: {
          fatherId: cat.fatherId,
          motherId: cat.motherId,
          id: { not: cat.id }, // è‡ªåˆ†è‡ªèº«ã‚’é™¤å¤–
        },
        include: {
          breed: { select: { id: true, name: true } },
          coatColor: { select: { id: true, name: true } },
          pedigree: { select: { pedigreeId: true } },
        },
        orderBy: { birthDate: "asc" },
      });

      siblings = siblingCats.map((sibling) => ({
        id: sibling.id,
        name: sibling.name,
        gender: sibling.gender,
        birthDate: sibling.birthDate.toISOString(),
        breed: sibling.breed,
        coatColor: sibling.coatColor,
        pedigreeId: sibling.pedigree?.pedigreeId ?? null,
      }));
    }

    // å­çŒ«ã‚’å–å¾—ï¼ˆã“ã®çŒ«ãŒè¦ªã®å ´åˆï¼‰
    const offspringCats = await this.prisma.cat.findMany({
      where: {
        OR: [
          { fatherId: cat.id },
          { motherId: cat.id },
        ],
      },
      include: {
        breed: { select: { id: true, name: true } },
        coatColor: { select: { id: true, name: true } },
        pedigree: { select: { pedigreeId: true } },
        father: {
          select: {
            id: true,
            name: true,
            gender: true,
            pedigree: { select: { pedigreeId: true } },
          },
        },
        mother: {
          select: {
            id: true,
            name: true,
            gender: true,
            pedigree: { select: { pedigreeId: true } },
          },
        },
      },
      orderBy: { birthDate: "desc" },
    });

    const offspring: OffspringInfo[] = offspringCats.map((child) => {
      // ã“ã®çŒ«ãŒã‚ªã‚¹ãªã‚‰æ¯è¦ªã‚’ã€ãƒ¡ã‚¹ãªã‚‰çˆ¶è¦ªã‚’ç›¸æ‰‹ã®è¦ªã¨ã—ã¦è¿”ã™
      const isFather = child.fatherId === cat.id;
      const otherParentData = isFather ? child.mother : child.father;

      return {
        id: child.id,
        name: child.name,
        gender: child.gender,
        birthDate: child.birthDate.toISOString(),
        breed: child.breed,
        coatColor: child.coatColor,
        pedigreeId: child.pedigree?.pedigreeId ?? null,
        otherParent: otherParentData
          ? {
              id: otherParentData.id,
              name: otherParentData.name,
              gender: otherParentData.gender,
              pedigreeId: otherParentData.pedigree?.pedigreeId ?? null,
            }
          : null,
      };
    });

    return {
      cat: {
        id: cat.id,
        name: cat.name,
        gender: cat.gender,
        birthDate: cat.birthDate.toISOString(),
        pedigreeId: cat.pedigree?.pedigreeId ?? null,
        breed: cat.breed,
        coatColor: cat.coatColor,
      },
      father,
      mother,
      siblings,
      offspring,
    };
  }

  /**
   * è¦ªæƒ…å ±ã‚’æ§‹ç¯‰ï¼ˆPedigreeã‹ã‚‰ç¥–çˆ¶æ¯ãƒ»æ›¾ç¥–çˆ¶æ¯æƒ…å ±ã‚’å«ã‚€ï¼‰
   */
  private buildParentInfo(
    parent: {
      id: string;
      name: string;
      gender: string;
      birthDate: Date;
      breed: { id: string; name: string } | null;
      coatColor: { id: string; name: string } | null;
      pedigree: {
        pedigreeId: string;
        // çˆ¶æ–¹ã®ç¥–çˆ¶æ¯
        ffTitle: string | null;
        ffCatName: string | null;
        ffCatColor: string | null;
        ffjcu: string | null;
        fmTitle: string | null;
        fmCatName: string | null;
        fmCatColor: string | null;
        fmjcu: string | null;
        // æ¯æ–¹ã®ç¥–çˆ¶æ¯
        mfTitle: string | null;
        mfCatName: string | null;
        mfCatColor: string | null;
        mfjcu: string | null;
        mmTitle: string | null;
        mmCatName: string | null;
        mmCatColor: string | null;
        mmjcu: string | null;
        // çˆ¶æ–¹ã®æ›¾ç¥–çˆ¶æ¯
        fffTitle: string | null;
        fffCatName: string | null;
        fffCatColor: string | null;
        fffjcu: string | null;
        ffmTitle: string | null;
        ffmCatName: string | null;
        ffmCatColor: string | null;
        ffmjcu: string | null;
        fmfTitle: string | null;
        fmfCatName: string | null;
        fmfCatColor: string | null;
        fmfjcu: string | null;
        fmmTitle: string | null;
        fmmCatName: string | null;
        fmmCatColor: string | null;
        fmmjcu: string | null;
        // æ¯æ–¹ã®æ›¾ç¥–çˆ¶æ¯
        mffTitle: string | null;
        mffCatName: string | null;
        mffCatColor: string | null;
        mffjcu: string | null;
        mfmTitle: string | null;
        mfmCatName: string | null;
        mfmCatColor: string | null;
        mfmjcu: string | null;
        mmfTitle: string | null;
        mmfCatName: string | null;
        mmfCatColor: string | null;
        mmfjcu: string | null;
        mmmTitle: string | null;
        mmmCatName: string | null;
        mmmCatColor: string | null;
        mmmjcu: string | null;
        // è¦ªã®è¦ªæƒ…å ±
        fatherJCU: string | null;
        fatherCatName: string | null;
        fatherCoatColor: string | null;
        fatherTitle: string | null;
        motherJCU: string | null;
        motherCatName: string | null;
        motherCoatColor: string | null;
        motherTitle: string | null;
      } | null;
    } | null,
    _position: "father" | "mother",
  ): ParentInfo | null {
    if (!parent) {
      return null;
    }

    const pedigree = parent.pedigree;

    // çˆ¶æ–¹ã®ç¥–çˆ¶æ¯æƒ…å ±ã‚’æ§‹ç¯‰
    const fatherAncestor: AncestorInfo | null = pedigree
      ? {
          pedigreeId: pedigree.fatherJCU,
          catName: pedigree.fatherCatName,
          coatColor: pedigree.fatherCoatColor,
          title: pedigree.fatherTitle,
          jcu: pedigree.fatherJCU,
        }
      : null;

    // æ¯æ–¹ã®ç¥–çˆ¶æ¯æƒ…å ±ã‚’æ§‹ç¯‰
    const motherAncestor: AncestorInfo | null = pedigree
      ? {
          pedigreeId: pedigree.motherJCU,
          catName: pedigree.motherCatName,
          coatColor: pedigree.motherCoatColor,
          title: pedigree.motherTitle,
          jcu: pedigree.motherJCU,
        }
      : null;

    return {
      id: parent.id,
      pedigreeId: pedigree?.pedigreeId ?? null,
      name: parent.name,
      gender: parent.gender,
      birthDate: parent.birthDate.toISOString(),
      breed: parent.breed,
      coatColor: parent.coatColor,
      father: fatherAncestor,
      mother: motherAncestor,
    };
  }
}
`````

## File: backend/src/coat-colors/dto/coat-color-query.dto.ts
`````typescript
import { ApiPropertyOptional } from "@nestjs/swagger";
import { Type } from "class-transformer";
import { IsOptional, IsString, IsInt, IsIn, Min, Max } from "class-validator";

export class CoatColorQueryDto {
  @ApiPropertyOptional({ description: "ãƒšãƒ¼ã‚¸ç•ªå·", default: 1 })
  @IsOptional()
  @IsInt()
  @Min(1)
  @Type(() => Number)
  page?: number = 1;

  @ApiPropertyOptional({ description: "1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•°", default: 50, maximum: 1000 })
  @IsOptional()
  @IsInt()
  @Min(1)
  @Max(1000)
  @Type(() => Number)
  limit?: number = 50;

  @ApiPropertyOptional({ description: "æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰" })
  @IsOptional()
  @IsString()
  search?: string;

  @ApiPropertyOptional({ description: "ã‚½ãƒ¼ãƒˆé …ç›®", default: "name" })
  @IsOptional()
  @IsString()
  @IsIn(["name", "nameEn", "colorCode", "category", "createdAt", "updatedAt", "code"])
  sortBy?: string = "name";

  @ApiPropertyOptional({ description: "ã‚½ãƒ¼ãƒˆé †", default: "asc" })
  @IsOptional()
  @IsString()
  @IsIn(["asc", "desc"])
  sortOrder?: "asc" | "desc" = "asc";
}
`````

## File: backend/src/coat-colors/dto/create-coat-color.dto.ts
`````typescript
import { ApiProperty, ApiPropertyOptional } from "@nestjs/swagger";
import { Type } from "class-transformer";
import { IsString, IsOptional, MaxLength, IsInt, Min, Max } from "class-validator";

export class CreateCoatColorDto {
  @ApiProperty({ description: "æ¯›è‰²ã‚³ãƒ¼ãƒ‰" })
  @IsInt()
  @Min(1)
  @Max(9999)
  @Type(() => Number)
  code: number;

  @ApiProperty({ description: "æ¯›è‰²å" })
  @IsString()
  @MaxLength(100)
  name: string;

  @ApiPropertyOptional({ description: "æ¯›è‰²ã®èª¬æ˜" })
  @IsOptional()
  @IsString()
  @MaxLength(1000)
  description?: string;
}
`````

## File: backend/src/coat-colors/dto/index.ts
`````typescript
export * from "./create-coat-color.dto";
export * from "./update-coat-color.dto";
export * from "./coat-color-query.dto";
`````

## File: backend/src/coat-colors/dto/update-coat-color.dto.ts
`````typescript
import { PartialType } from "@nestjs/mapped-types";

import { CreateCoatColorDto } from "./create-coat-color.dto";

export class UpdateCoatColorDto extends PartialType(CreateCoatColorDto) {}
`````

## File: backend/src/coat-colors/coat-color-master.data.ts
`````typescript
/**
 * Pedigreesãƒ†ãƒ¼ãƒ–ãƒ«ã®coat-colorsãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã§åˆ©ç”¨ã™ã‚‹è‰²æŸ„ãƒã‚¹ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿ã€‚
 * å…ƒãƒ‡ãƒ¼ã‚¿: è‰²æŸ„ãƒ‡ãƒ¼ã‚¿UTF8Ver.csvï¼ˆãƒ˜ãƒƒãƒ€ãƒ¼: ã‚­ãƒ¼, æ¯›è‰²åç§° / BOMä»˜ï¼‰
 * æœ¬ãƒ•ã‚¡ã‚¤ãƒ«ã§ã¯ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ code / name ã«ç½®ãæ›ãˆã€CSVåŸæœ¬ã®ä¸¦ã³ã¨å€¤ã‚’ãã®ã¾ã¾ä¿æŒã™ã‚‹ã€‚
 */

export interface CoatColorMasterRecord {
  code: number;
  name: string;
}

const RAW_COAT_COLOR_CSV = `
code,name
0,
1,White
2,Blue
3,Black
4,Red
5,Peke-Face Red
6,Cream
7,Cameo
8,Ruddy
9,Fawn
10,Sable
11,Champagne
12,Platinum
13,Blue Gray
14,Silver
15,Bronze
16,Lilac
17,Chocolate
18,Brown
19,Lavender
20,Blue Silver
21,Sepia Agouti
22,Ebony
23,Chestnut
24,Shell Cameo
30,Tortoiseshell
31,Blue Cream
32,Calico
33,Dilute Calico
34,Mike Tri Color
35,Blue-White
36,Black-White
37,Red-White
38,Cream-White
39,Cameo-White
40,Tortoiseshell-White
41,Blue Cream-White
42,Blue-White Van
43,Black-White Van
44,Red-White Van
45,Cream-White Van
46,Cameo-White Van
47,Van Calico
48,Dilute Calico Van
49,Blue Smoke-White
50,Black Smoke-White
51,Cream Smoke-White
52,Tortie Smoke-White
53,Blue Cream Smoke-White
54,Cameo Red Smoke-White
60,Chinchilla Silver
61,Chinchilla Golden
62,Shaded Silver
63,Shaded Golden
64,Blue Chinchilla Silver
65,Blue Shaded Silver
66,Shaded Cameo
70,Black Smoke
71,Blue Smoke
72,Tortie Smoke
73,Cream Smoke
74,Blue Cream Smoke
75,Cameo Smoke
80,Seal Point
81,Blue Point
82,Lilac Point
83,Red Point
84,Chocolate Point
85,Cream Point
86,Tortie Point
87,Blue Cream Point
88,Lilac Cream Point
89,Seal Tortie Point
90,Choco Tortie Point
91,Flame Point
100,Seal Lynx Point
101,Blue Lynx Point
102,Brown Lynx Point
103,Lilac Lynx Point
104,Red Lynx Point
105,Chocolate Lynx Point
106,Cream Lynx Point
107,Seal Tortie Lynx Point
108,Choco Tortie Lynx Point
109,Blue Cream Lynx Point
110,Lilac Cream Lynx Point
120,Seal Point Mitted
121,Blue Point Mitted
130,Silver Tabby
131,Silver Mackerel Tabby
132,Brown Tabby
133,Brown Mackerel Tabby
134,Blue Tabby
135,Blue Mackerel Tabby
136,Red Tabby
137,Red Mackerel Tabby
138,Cream Tabby
139,Cream Mackerel Tabby
140,Cameo Tabby
141,Cameo Mackerel Tabby
142,Peke-Face Red Tabby
143,Peke-Face Red Mc Tabby
144,Golden Tabby
145,Golden Mc Tabby
146,Chestnut Tabby
147,Lavender Tabby
148,Ebony Tabby
149,Fawn Tabby
150,Cinnamon Tabby
151,Blue Silver Tabby
152,Chestnut Silver Tabby
153,Silver Ticked Tabby
154,Brown Ticked Tabby
155,Blue Ticked Tabby
160,Silver Patched Tabby
161,Silver Patched Mc Tabby
162,Brown Patched Tabby
163,Brown Patched Mc Tabby
165,Blue Patched Tabby
166,Blue Patched Mc Tabby
167,Cinnamon Patched Tabby
168,Ebony Patched Tabby
169,Chestnut Patched Tabby
170,Lavender Patched Tabby
171,Fawn Patched Tabby
180,Silver Tabby-White
181,Silver Mc Tabby-White
182,Brown Tabby-White
183,Brown Mc Tabby-White
184,Blue Tabby-White
185,Blue Mc Tabby-White
186,Red Tabby-White
187,Red Mc Tabby-White
188,P-F Red Tabby-White
189,P-F Red Mc Tabby-White
190,Cream Tabby-White
191,Cream Mc Tabby-White
192,Cameo Tabby-White
193,Cameo Mc Tabby-White
194,Silver Tc Tabby-White
195,Brown Tc Tabby-White
196,Blue Tc Tabby-White
200,Silver Pt Tabby-White
201,Silver Pt Mc Tabby-White
202,Brown Pt Tabby-White
203,Brown Pt Mc Tabby-White
204,Blue Pt Tabby-White
205,Blue Pt Mc Tabby-White
206,Silver Tabby-White Van
207,Silver Mc Tabby-W Van
208,Brown Tabby-White Van
209,Brown Mc Tabby-White Van
210,Blue Tabby-White Van
211,Blue Mc Tabby-White Van
212,Red Tabby-White Van
213,Red Mc Tabby-White Van
214,Cream Tabby-White Van
215,Cream Mc Tabby-White Van
216,Cameo Tabby-White Van
217,Cameo Mc Tabby-White Van
220,Silver Pt Tabby-W Van
221,Silver Pt Mc Tabby-W Van
222,Brown Pt Tabby-White Van
223,Brown Pt Mc Tabby-W Van
224,Blue Pt Tabby-White Van
225,Blue Pt Mc Tabby-W Van
230,Silver Spotted Tabby
231,Brown Spotted Tabby
232,Red Spotted Tabby
233,Blue Spotted Tabby
234,Cream Spotted Tabby
235,Tawny Spotted Tabby
236,Cinnamon Spotted Tabby
237,Fawn Spotted Tabby
238,Chocolate Spotted Tabby
239,Lavender Spotted Tabby
240,Silver Sp Tabby-White
241,Brown Sp Tabby-White
242,Red Sp Tabby-White
243,Blue Sp Tabby-White
244,Cream Sp Tabby-White
250,Leopard
260,Any Other Color
261,AOV
270,Silver Pt Sp Tabby
271,Brown Pt Sp Tabby
272,Blue Pt Sp Tabby
273,Silver Pt Sp Tabby-White
274,Brown Pt Sp Tabby-White
275,Blue Pt Sp Tabby-White
276,Blue Smoke-White Van
277,Black Smoke-White Van
278,Cream Smoke-White Van
279,Tortie Smoke-White Van
280,Blue Cream Smoke-White Van
281,Cameo Red Smoke-White Van
282,Silver Ticked Tabby-White
283,Brown Ticked Tabby-White
284,Chocolate Point Mitted
285,Snow
286,Blue Silver Tabby-White
287,Sorrel (Red)
288,Sorrel Spotted Tabby
289,Brown-White
290,Cinnamon
291,Seal Tortie Point
292,Seal Point Bi-Color
293,Chocolate Point Bi-Color
294,Blue Point Bi-Color
295,Lilac Point Bi-Color
296,Brown Marbled Tabby
297,Seal Point(A.O.C)
298,Blue Marble
299,Flame Point Bi-Color
300,Shell Tortoiseshell
301,Blue Tortie-White
302,Blue Silver Pt Tabby-White
303,Blue Silver Pt T-W Van
304,Shaded Tortie
305,Blue Tortie
306,Seal Lynx Point Bi-Color
307,Brown Classic Tobie
308,Tortie Point Bi-Color
309,Chocolate Tortie Point Bi-Color
310,Blue Silver Mc Tabby
311,Shaded Cameo-White
312,Calico Smoke
313,Smoke Dilute Calico
314,Red Point Bi-Color
315,Cream Point Bi-Color
316,Silver Classic Tobie
317,Silver Mackerel Tobie
318,Brown Mackerel Tobie
319,Blue Tortie Point Mitted
320,Lilac Point Mitted
321,Blue Tortie Point Bi-Color
322,Blue Silver Mc Tabby-White
323,Red Point Mitted
324,Smoke
325,Ebony Silver
326,Shaded Chocolate
327,Chocolate Tortie
328,Lilac Tortie
329,Cream Cameo Tabby
330,Cream Cameo Mc Tabby
331,Cream Cameo Tabby-White
332,Cream Cameo Mc Tabby-W
333,Blue Silver Tabby-W Van
334,Chocolate Lynx Point-White
335,Cream Cameo
336,Seal Tortie Point Bi-Color
337,Seal Tortie Point Mitted
338,Browm Classic Torbie-White
339,Platinum Mink(Lilac Mink)
340,Blue Silver Classic Tabby
341,Cream Shell Cameo
342,Flame Lynx Point
343,Shell Cream
344,Shaded Cream
345,Tortie Point Mitted
346,Seal Tortie Point
347,Blue Cream Point Bi-Color
348,Sable Ticked Tabby
349,Chocolate Cream P Bi-Color
350,Shell Blue(Blue Chinchilla)
351,Seal Point (A.O.C)
352,Blue Point (A.O.C)
353,Cream Point Mitted
354,Shaded Silver-White
355,Tortoiseshell-White Van
356,Champagne Mink
357,Champagne Solid 
358,Platinum Solid
359,Seal Lynx Point-White
360,Natural Point
361,Platinum Point
362,Champagne Point
363,Blue Cream Point Mitted
364,Blue Silver Patched Tabby
365,Seal Lynx Point Van Bi-C
366,Blue Lynx Point Van Bi-C
367,Flame Point Bi-Color
368,Brown Mc Tobie-White
369,Blue Lynx Point-White
370,Natural Mink (Seal Mink)
371,Chocolate Point-White
372,Blue Solid
373,Blue Mink
374,Choco Tortie Point Mitted
375,Chocolate Point Mitted
376,Blue Cream-White Van
377,Choco Silver Lynx Point-W
378,Chocolate Patched Tabby
379,Seal Point-White
380,Snow Spotted Tabby
381,Seal Tortie Point-White
382,Chocolate-White
383,Blue Point-White
384,Shell Tortoiseshell-White
385,Natural Solid
386,Cameo(Red Silver) Tabby
387,Seal Tortie Lynx Point-W
388,Blue Chinchilla Golden
389,Blue Silver Pt Mc Tabby-W
390,Blue Silver Pt Mc Tabby
391,Red Lynx Point-White
392,Chocolate Silver Spotted Tabby
393,Ebony Silver Ticked T
394,Shaded Tortie-White
395,Black Brown Spotted Tabby
396,Ebony Silver Mc Tabby
397,Red Silver(Cameo)Tabby-W
398,Chocolate Tabby
399,Blue Silver Spotted Tabby
400,Cinnamon-White
401,Blue Ticked Tabby-White
402,Chestnut Tortie
403,Flame Point Mitted
404,Chestnut Tortie-White
405,Chestnut Tortie Point-W
406,Choco Silver Tortie Lynx Point 
407,Brown Sp Tabby (Rosettes)
408,Choco Tortie Lynx Point Mitted
409,Shell Cameo-White
410,Ebony Smoke
411,Ebony Tabby
412,Ebony Mackerel Tabby
413,Red Point-White
414,Chinchilla Silver-White
415,Chinchilla Golden-White
416,Red Ticked Tabby
417,Cream Ticked Tabby
418,Chocolate Lynx Point (AOC)
419,Chocolate Pt Tabby-White
420,Cream Silver Tabby-White
421,Smoke Calico Van
422,Cameo Spotted Tabby
423,Blue Silver Pt Sp Tabby
424,Ebony Silver Spotted Tabby
425,Silver Marbled Tabby
426,Blue Silver Sp Tabby-W
427,Cream Point-White
428,Lilac-White
429,Choco Cream Point
430,Choco Tortie Lynx Point-W
431,Choco Cream Lynx Point-W
432,Ebony-White
433,Ebony Silver Ticked T-W
434,Ebony Silver Tabby-White
435,Seal Mink Spotted Tabby
436,Cinnamon Tabby(AOC)
437,Cream Classic Tabby-White
438,Blue Classic Tabby-White
439,Smoke Tortoiseshell
440,Lilac Point-White
441,Lilac Tabby
442,Cinnamon Mackerel Tabby
443,Chocolate Tortie Lynx Point-White
444,Blue Spotted
445,Blue Cream Point-White
446,Brown Pt Ticked Tabby-W
447,Black(A.O.C)
448,Blue Shaded
449,Cream Cameo Tabby-White Van
450,Blue Silver-White
451,Silver Lynx Point
452,Blue Lynx Point Bi-Color
453,Lilac Point Bi-Color
454,Chocolate Tortie Lynx Point
455,Lilac Cream
456,Seal Bi-Color
457,Blue Cream Lynx Point-White
458,Smoke Calico
459,Brown Pt Ticked Tabby
460,Blue Silver Pt Tabby-White Van
461,Black Silver Spotted Tabby
462,Silver Pt Tc Tabby-White
463,Lilac Tortie Point Mitted
464,Lilac Cream Point-White
465,Seal Tortie Lynx Point-White
466,Brown Classic Tabby-White
467,Brown Ticked Pt Tabby
468,Lilac Silver Tabby-White
469,Cream Lynx Point Bi-Color
470,Black(AOC)
471,Cinnamon Ticked Tabby
472,Chocolate Lynx Point Bi-Color
473,Silver Pt Ticked Tabby
474,Seal Mink
475,Shaded Tortie Lynx Point-White
476,Silver Patched Ticked Tabby
477,Brown Patched Sp Tabby
478,Blue Tortie Point
479,Black Silver Marbled Tabby
480,Lilac Tabby-White
481,Shell Tortoiseshell
482,Silver Classic Tabby
483,Seal Tortie Lynx Point Bi-Color
484,Seal Tortie Lynx Point Mitted
485,Silver-White
486,Shaded Golden-White
487,Cream Ticked Tabby-White
488,Blue Shaded Golden
489,Lilac Tortie Lynx Point Mitted
490,Tortie Point-White
491,Flame Point-White
492,Blue Silver Ticked Tabby
493,Blue Lynx Point Mitted
`;

const parseCoatColorMasterData = (): ReadonlyArray<CoatColorMasterRecord> => {
  const [, ...lines] = RAW_COAT_COLOR_CSV.trim().split(/\r?\n/);

  return lines
    .filter((line) => line.length > 0)
    .map((line) => {
      const [codePart, ...nameParts] = line.split(",");
      const code = Number.parseInt(codePart.trim(), 10);
      if (Number.isNaN(code)) {
        throw new Error(`Invalid coat color code detected: ${line}`);
      }
      const name = nameParts.join(",");
      return { code, name };
    });
};

export const COAT_COLOR_MASTER_DATA: ReadonlyArray<CoatColorMasterRecord> =
  Object.freeze(parseCoatColorMasterData());

const COAT_COLOR_MASTER_MAP_ENTRIES = COAT_COLOR_MASTER_DATA.map(
  (record) => [record.code, record] as const,
);

export const COAT_COLOR_MASTER_MAP: ReadonlyMap<number, CoatColorMasterRecord> =
  new Map(COAT_COLOR_MASTER_MAP_ENTRIES);

export const findCoatColorByCode = (
  code: number,
): CoatColorMasterRecord | undefined => COAT_COLOR_MASTER_MAP.get(code);
`````

## File: backend/src/coat-colors/coat-colors.controller.spec.ts
`````typescript
import { Test, TestingModule } from '@nestjs/testing';

import { DisplayPreferencesService } from '../display-preferences/display-preferences.service';
import { getTestModuleImports, getTestModuleProviders } from '../test-utils/test-module-setup';

import { CoatColorsController } from './coat-colors.controller';
import { CoatColorsService } from './coat-colors.service';

describe('CoatColorsController', () => {
  let controller: CoatColorsController;
  let service: CoatColorsService;

  const mockCoatColorsService = {
    create: jest.fn(),
    findAll: jest.fn(),
    findOne: jest.fn(),
    update: jest.fn(),
    remove: jest.fn(),
    getMasterData: jest.fn(),
  };
  const mockDisplayPreferencesService = {
    getPreferences: jest.fn(),
    buildPersonalizedCoatColorRecords: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      imports: getTestModuleImports(),
      controllers: [CoatColorsController],
      providers: [
        ...getTestModuleProviders(),
        {
          provide: CoatColorsService,
          useValue: mockCoatColorsService,
        },
        {
          provide: DisplayPreferencesService,
          useValue: mockDisplayPreferencesService,
        },
      ],
    }).compile();

    controller = module.get<CoatColorsController>(CoatColorsController);
    service = module.get<CoatColorsService>(CoatColorsService);

    jest.clearAllMocks();
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });

  describe('create', () => {
    it('should create a coat color', async () => {
      const createDto = { code: 1, name: 'Black', description: 'Solid black' };
      const mockColor = { id: '1', ...createDto };

      mockCoatColorsService.create.mockResolvedValue(mockColor);

      const result = await controller.create(createDto);

      expect(result).toEqual(mockColor);
      expect(service.create).toHaveBeenCalledWith(createDto);
    });
  });

  describe('findAll', () => {
    it('should return paginated coat colors', async () => {
      const mockResponse = {
        data: [{ id: '1', name: 'Black' }],
        pagination: { page: 1, limit: 10, total: 1, totalPages: 1 },
      };

      mockCoatColorsService.findAll.mockResolvedValue(mockResponse);

      const result = await controller.findAll({});

      expect(result).toEqual(mockResponse);
      expect(service.findAll).toHaveBeenCalledWith({});
    });
  });

  describe('findOne', () => {
    it('should return a coat color by id', async () => {
      const mockColor = { id: '1', name: 'Black' };

      mockCoatColorsService.findOne.mockResolvedValue(mockColor);

      const result = await controller.findOne('1');

      expect(result).toEqual(mockColor);
      expect(service.findOne).toHaveBeenCalledWith('1');
    });
  });

  describe('update', () => {
    it('should update a coat color', async () => {
      const updateDto = { name: 'Updated Black' };
      const mockColor = { id: '1', name: 'Updated Black' };

      mockCoatColorsService.update.mockResolvedValue(mockColor);

      const result = await controller.update('1', updateDto);

      expect(result).toEqual(mockColor);
      expect(service.update).toHaveBeenCalledWith('1', updateDto);
    });
  });

  describe('remove', () => {
    it('should delete a coat color', async () => {
      mockCoatColorsService.remove.mockResolvedValue(undefined);

      await controller.remove('1');

      expect(service.remove).toHaveBeenCalledWith('1');
    });
  });

  describe('getMasterData', () => {
    it('should return master data via service', async () => {
      const mockMaster = [{ code: 1, name: 'White' }];
      mockCoatColorsService.getMasterData.mockResolvedValue(mockMaster);

      const result = await controller.getMasterData(undefined);

      expect(result).toEqual(mockMaster);
      expect(service.getMasterData).toHaveBeenCalled();
    });
  });
});
`````

## File: backend/src/coat-colors/coat-colors.controller.ts
`````typescript
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  HttpStatus,
  UseGuards,
} from "@nestjs/common";
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiParam,
  ApiQuery,
  ApiBearerAuth,
  ApiOkResponse,
  ApiExtraModels,
} from "@nestjs/swagger";
import { UserRole } from "@prisma/client";

import type { RequestUser } from "../auth/auth.types";
import { GetUser } from "../auth/get-user.decorator";
import { JwtAuthGuard } from "../auth/jwt-auth.guard";
import { RoleGuard } from "../auth/role.guard";
import { Roles } from "../auth/roles.decorator";
import { DisplayPreferencesService } from "../display-preferences/display-preferences.service";
import { MasterDataItemDto } from "../display-preferences/dto/master-data-item.dto";

import { CoatColorsService } from "./coat-colors.service";
import {
  CreateCoatColorDto,
  UpdateCoatColorDto,
  CoatColorQueryDto,
} from "./dto";


@ApiExtraModels(MasterDataItemDto)
@ApiTags("Coat Colors")
@ApiBearerAuth()
@UseGuards(JwtAuthGuard)
@Controller("coat-colors")
export class CoatColorsController {
  constructor(
    private readonly coatColorsService: CoatColorsService,
    private readonly displayPreferences: DisplayPreferencesService,
  ) {}

  @Post()
  @UseGuards(RoleGuard)
  @Roles(UserRole.ADMIN, UserRole.SUPER_ADMIN)
  @ApiOperation({ summary: "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆï¼ˆç®¡ç†è€…ã®ã¿ï¼‰" })
  @ApiResponse({
    status: HttpStatus.CREATED,
    description: "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«ä½œæˆã•ã‚Œã¾ã—ãŸ",
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: "ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§ã™",
  })
  @ApiResponse({
    status: HttpStatus.FORBIDDEN,
    description: "ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™",
  })
  create(@Body() createCoatColorDto: CreateCoatColorDto) {
    return this.coatColorsService.create(createCoatColorDto);
  }

  @Get()
  @ApiOperation({ summary: "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œç´¢ãƒ»ä¸€è¦§å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK, description: "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã®ä¸€è¦§" })
  @ApiQuery({
    name: "page",
    required: false,
    description: "ãƒšãƒ¼ã‚¸ç•ªå·",
    example: 1,
  })
  @ApiQuery({
    name: "limit",
    required: false,
    description: "1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•°",
    example: 50,
  })
  @ApiQuery({ name: "search", required: false, description: "æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰" })
  @ApiQuery({
    name: "sortBy",
    required: false,
    description: "ã‚½ãƒ¼ãƒˆé …ç›®",
    example: "name",
  })
  @ApiQuery({
    name: "sortOrder",
    required: false,
    description: "ã‚½ãƒ¼ãƒˆé †",
    example: "asc",
  })
  findAll(@Query() query: CoatColorQueryDto) {
    return this.coatColorsService.findAll(query);
  }

  @Get("master-data")
  @ApiOperation({ summary: "Pedigreeé€£æºç”¨ã®è‰²æŸ„ãƒã‚¹ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—" })
  @ApiOkResponse({
    description: "CSV ãƒã‚¹ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’ displayName / displayNameMode ä»˜ãã§è¿”å´",
    type: MasterDataItemDto,
    isArray: true,
  })
  async getMasterData(@GetUser() user: RequestUser | undefined) {
    if (!user) {
      return this.coatColorsService.getMasterData();
    }

    const preference = await this.displayPreferences.getPreferences(user.userId);
    const personalized =
      await this.displayPreferences.buildPersonalizedCoatColorRecords(preference);

    return personalized.map((record) => ({
      code: record.code,
      name: record.canonicalName,
      displayName: record.displayName,
      displayNameMode: preference.coatColorNameMode,
      isOverridden: record.isOverridden,
    }));
  }

  @Get("statistics")
  @ApiOperation({ summary: "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã®çµ±è¨ˆæƒ…å ±ã‚’å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK, description: "çµ±è¨ˆæƒ…å ±" })
  getStatistics() {
    return this.coatColorsService.getStatistics();
  }

  @Get(":id")
  @ApiOperation({ summary: "IDã§æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK, description: "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿" })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
  })
  @ApiParam({ name: "id", description: "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã®ID" })
  findOne(@Param("id") id: string) {
    return this.coatColorsService.findOne(id);
  }

  @Patch(":id")
  @UseGuards(RoleGuard)
  @Roles(UserRole.ADMIN, UserRole.SUPER_ADMIN)
  @ApiOperation({ summary: "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰" })
  @ApiResponse({
    status: HttpStatus.OK,
    description: "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«æ›´æ–°ã•ã‚Œã¾ã—ãŸ",
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: "ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§ã™",
  })
  @ApiResponse({
    status: HttpStatus.FORBIDDEN,
    description: "ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™",
  })
  @ApiParam({ name: "id", description: "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã®ID" })
  update(
    @Param("id") id: string,
    @Body() updateCoatColorDto: UpdateCoatColorDto,
  ) {
    return this.coatColorsService.update(id, updateCoatColorDto);
  }

  @Delete(":id")
  @UseGuards(RoleGuard)
  @Roles(UserRole.ADMIN, UserRole.SUPER_ADMIN)
  @ApiOperation({ summary: "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰" })
  @ApiResponse({
    status: HttpStatus.OK,
    description: "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«å‰Šé™¤ã•ã‚Œã¾ã—ãŸ",
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
  })
  @ApiResponse({
    status: HttpStatus.FORBIDDEN,
    description: "ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™",
  })
  @ApiParam({ name: "id", description: "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã®ID" })
  remove(@Param("id") id: string) {
    return this.coatColorsService.remove(id);
  }
}
`````

## File: backend/src/coat-colors/coat-colors.module.ts
`````typescript
import { Module } from "@nestjs/common";

import { DisplayPreferencesModule } from "../display-preferences/display-preferences.module";
import { PrismaModule } from "../prisma/prisma.module";

import { CoatColorsController } from "./coat-colors.controller";
import { CoatColorsService } from "./coat-colors.service";

@Module({
  imports: [PrismaModule, DisplayPreferencesModule],
  controllers: [CoatColorsController],
  providers: [CoatColorsService],
  exports: [CoatColorsService],
})
export class CoatColorsModule {}
`````

## File: backend/src/coat-colors/coat-colors.service.spec.ts
`````typescript
import { NotFoundException } from '@nestjs/common';
import { Test, TestingModule } from '@nestjs/testing';

import { PrismaService } from '../prisma/prisma.service';

import { CoatColorsService } from './coat-colors.service';


describe('CoatColorsService', () => {
  let service: CoatColorsService;
  let _prismaService: PrismaService;

  const mockPrismaService = {
    coatColor: {
      create: jest.fn(),
      findMany: jest.fn(),
      findUnique: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
      count: jest.fn(),
    },
    cat: {
      count: jest.fn(),
    },
    pedigree: {
      count: jest.fn(),
    },
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        CoatColorsService,
        {
          provide: PrismaService,
          useValue: mockPrismaService,
        },
      ],
    }).compile();

    service = module.get<CoatColorsService>(CoatColorsService);
    _prismaService = module.get<PrismaService>(PrismaService);

    jest.clearAllMocks();
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('create', () => {
    it('should create a coat color successfully', async () => {
      const createDto = {
        code: 1,
        name: 'Black',
        description: 'Solid black coat',
      };

      const mockColor = {
        id: '1',
        ...createDto,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      mockPrismaService.coatColor.create.mockResolvedValue(mockColor);

      const result = await service.create(createDto);

      expect(result).toEqual(mockColor);
      expect(mockPrismaService.coatColor.create).toHaveBeenCalledWith({
        data: createDto,
      });
    });
  });

  describe('findAll', () => {
    it('should return paginated coat colors', async () => {
      const mockColors = [
        { id: '1', name: 'Black' },
        { id: '2', name: 'White' },
      ];

      mockPrismaService.coatColor.findMany.mockResolvedValue(mockColors);
      mockPrismaService.coatColor.count.mockResolvedValue(2);

      const result = await service.findAll({});

      expect(result.data).toEqual(mockColors);
      expect(result.meta.total).toBe(2);
    });
  });

  describe('findOne', () => {
    it('should return a coat color by id', async () => {
      const mockColor = { id: '1', name: 'Black' };

      mockPrismaService.coatColor.findUnique.mockResolvedValue(mockColor);

      const result = await service.findOne('1');

      expect(result).toEqual(mockColor);
    });

    it('should throw NotFoundException when coat color not found', async () => {
      mockPrismaService.coatColor.findUnique.mockResolvedValue(null);

      await expect(service.findOne('non-existent')).rejects.toThrow(NotFoundException);
    });
  });

  describe('update', () => {
    it('should update a coat color successfully', async () => {
      const updateDto = { name: 'Updated Black' };
      const mockColor = { id: '1', name: 'Updated Black' };

      mockPrismaService.coatColor.findUnique.mockResolvedValue({ id: '1', name: 'Black' });
      mockPrismaService.coatColor.update.mockResolvedValue(mockColor);

      const result = await service.update('1', updateDto);

      expect(result).toEqual(mockColor);
      expect(mockPrismaService.coatColor.update).toHaveBeenCalledWith({
        where: { id: '1' },
        data: updateDto,
      });
    });
  });

  describe('remove', () => {
    it('should delete a coat color successfully', async () => {
      const mockColor = { id: '1', name: 'Black' };

      mockPrismaService.coatColor.findUnique.mockResolvedValue(mockColor);
      mockPrismaService.cat.count.mockResolvedValue(0);
      mockPrismaService.pedigree.count.mockResolvedValue(0);
      mockPrismaService.coatColor.delete.mockResolvedValue(mockColor);

      await service.remove('1');

      expect(mockPrismaService.coatColor.delete).toHaveBeenCalledWith({
        where: { id: '1' },
      });
    });
  });

  describe('getMasterData', () => {
    it('should return coat color master data from prisma', async () => {
      const mockMaster = [
        { code: 1, name: 'White' },
        { code: 2, name: 'Blue' },
      ];

      mockPrismaService.coatColor.findMany.mockResolvedValue(mockMaster);

      const result = await service.getMasterData();

      expect(mockPrismaService.coatColor.findMany).toHaveBeenCalledWith({
        select: { code: true, name: true },
        where: { isActive: true },
        orderBy: { code: 'asc' },
      });
      expect(result).toEqual(mockMaster);
    });
  });
});
`````

## File: backend/src/coat-colors/coat-colors.service.ts
`````typescript
import { Injectable, NotFoundException } from "@nestjs/common";
import type { Prisma } from "@prisma/client";

import { PrismaService } from "../prisma/prisma.service";

import {
  CreateCoatColorDto,
  UpdateCoatColorDto,
  CoatColorQueryDto,
} from "./dto";

export type CoatColorMasterRecord = {
  code: number;
  name: string;
};

@Injectable()
export class CoatColorsService {
  constructor(private prisma: PrismaService) {}

  async create(createCoatColorDto: CreateCoatColorDto) {
    return this.prisma.coatColor.create({
      data: createCoatColorDto,
    });
  }

  async findAll(query: CoatColorQueryDto) {
    const {
      page = 1,
      limit = 50,
      search,
      sortBy = "name",
      sortOrder = "asc",
    } = query;

  const skip = (page - 1) * limit;
  const where: Prisma.CoatColorWhereInput = {};

    if (search) {
      where.OR = [
        { name: { contains: search, mode: "insensitive" } },
        { description: { contains: search, mode: "insensitive" } },
      ];
    }

    type Sortable = "name" | "createdAt" | "updatedAt" | "code";
    const sortMap: Record<string, Sortable> = {
      name: "name",
      nameEn: "name", // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒãªã„ãŸã‚ name ã¸ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
      colorCode: "code",
      category: "name", // ãƒ¢ãƒ‡ãƒ«ã«ãªã„ãŸã‚ name ã¸ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
      createdAt: "createdAt",
      updatedAt: "updatedAt",
    };
    const sortKey = sortMap[sortBy] ?? "name";

    const [colors, total] = await Promise.all([
      this.prisma.coatColor.findMany({
        where,
        skip,
        take: limit,
        include: {
          _count: {
            select: {
              cats: true,
            },
          },
        },
        orderBy: { [sortKey]: sortOrder } as Prisma.CoatColorOrderByWithRelationInput,
      }),
      this.prisma.coatColor.count({ where }),
    ]);

    return {
      data: colors,
      meta: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  async findOne(id: string) {
    const color = await this.prisma.coatColor.findUnique({
      where: { id },
      include: {
        cats: {
          include: {
            breed: true,
          },
          orderBy: {
            name: "asc",
          },
        },
        _count: {
          select: {
            cats: true,
          },
        },
      },
    });

    if (!color) {
      throw new NotFoundException(`Coat color with ID ${id} not found`);
    }

    return color;
  }

  async update(id: string, updateCoatColorDto: UpdateCoatColorDto) {
    const existingColor = await this.prisma.coatColor.findUnique({
      where: { id },
    });

    if (!existingColor) {
      throw new NotFoundException(`Coat color with ID ${id} not found`);
    }

    return this.prisma.coatColor.update({
      where: { id },
      data: updateCoatColorDto,
    });
  }

  async remove(id: string) {
    const existingColor = await this.prisma.coatColor.findUnique({
      where: { id },
    });

    if (!existingColor) {
      throw new NotFoundException(`Coat color with ID ${id} not found`);
    }

    // Check if color is being used
    const [catCount, pedigreeCount] = await Promise.all([
      this.prisma.cat.count({ where: { coatColorId: id } }),
      this.prisma.pedigree.count({ where: { coatColorCode: parseInt(id) } }),
    ]);

    if (catCount > 0 || pedigreeCount > 0) {
      throw new NotFoundException(
        `Cannot delete coat color: ${catCount} cats and ${pedigreeCount} pedigrees are using this color`,
      );
    }

    return this.prisma.coatColor.delete({
      where: { id },
    });
  }

  async getStatistics() {
    const [totalColors, mostPopularColors, colorDistribution] =
      await Promise.all([
        this.prisma.coatColor.count(),
        this.prisma.coatColor.findMany({
          include: {
            _count: {
              select: {
                cats: true,
              },
            },
          },
          orderBy: {
            cats: {
              _count: "desc",
            },
          },
          take: 10,
        }),
        this.prisma.cat.groupBy({
          by: ["coatColorId"],
          _count: true,
          orderBy: {
            _count: {
              coatColorId: "desc",
            },
          },
        }),
      ]);

    return {
      totalColors,
      mostPopularColors,
      colorDistribution,
    };
  }

  async getMasterData(): Promise<CoatColorMasterRecord[]> {
    return this.prisma.coatColor.findMany({
      select: { code: true, name: true },
      where: { isActive: true },
      orderBy: { code: "asc" },
    });
  }
}
`````

## File: backend/src/common/config/env.validation.ts
`````typescript
import { z } from 'zod';

/**
 * ç’°å¢ƒå¤‰æ•°ã®ã‚¹ã‚­ãƒ¼ãƒå®šç¾©
 */
export const envSchema = z.object({
  // Nodeç’°å¢ƒ
  NODE_ENV: z.enum(['development', 'staging', 'production', 'test']).default('development'),
  PORT: z.coerce.number().min(1000).max(65535).default(3004),
  LOG_LEVEL: z.enum(['fatal', 'error', 'warn', 'info', 'debug', 'trace']).default('info'),

  // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹
  DATABASE_URL: z.string().min(1, 'DATABASE_URL ã¯å¿…é ˆã§ã™'),

  // CORS
  CORS_ORIGIN: z.string().optional(),

  // JWT - ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³
  JWT_SECRET: z
    .string()
    .min(32, 'JWT_SECRET ã¯æœ€ä½32æ–‡å­—å¿…è¦ã§ã™ï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åº¦ã®ãŸã‚ï¼‰'),
  JWT_EXPIRES_IN: z.string().default('15m'),

  // JWT - ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³
  JWT_REFRESH_SECRET: z
    .string()
    .min(32, 'JWT_REFRESH_SECRET ã¯æœ€ä½32æ–‡å­—å¿…è¦ã§ã™ï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åº¦ã®ãŸã‚ï¼‰')
    .refine(
      (val) => {
        const jwtSecret = process.env.JWT_SECRET;
        return !jwtSecret || val !== jwtSecret;
      },
      {
        message: 'JWT_REFRESH_SECRET ã¯ JWT_SECRET ã¨ç•°ãªã‚‹å€¤ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™',
      }
    ),
  JWT_REFRESH_EXPIRES_IN: z.string().default('7d'),

  // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰
  PASSWORD_MIN_LENGTH: z.coerce.number().min(8).default(8),

  // Argon2 è¨­å®š
  ARGON2_MEMORY_COST: z.coerce.number().default(65536),
  ARGON2_TIME_COST: z.coerce.number().default(3),
  ARGON2_PARALLELISM: z.coerce.number().default(4),
  ARGON2_HASH_LENGTH: z.coerce.number().default(64),
  ARGON2_SALT_LENGTH: z.coerce.number().default(32),

  // ãƒ¬ãƒ¼ãƒˆåˆ¶é™
  THROTTLE_TTL: z.coerce.number().default(60000),
  THROTTLE_LIMIT: z.coerce.number().default(100),

  // ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
  HEALTH_CHECK_DATABASE: z
    .string()
    .transform((val) => val === 'true')
    .default('true'),
  HEALTH_CHECK_MEMORY_THRESHOLD: z.coerce.number().min(0).max(1).default(0.9),

  // ç®¡ç†è€…ã‚¢ã‚«ã‚¦ãƒ³ãƒˆï¼ˆé–‹ç™º/ã‚·ãƒ¼ãƒ‰ç”¨ï¼‰
  ADMIN_EMAIL: z.string().email().optional(),
  ADMIN_PASSWORD: z.string().min(8).optional(),
  ADMIN_FORCE_UPDATE: z.coerce.number().min(0).max(1).default(0),

  // èªè¨¼ãƒã‚¤ãƒ‘ã‚¹ï¼ˆé–‹ç™ºå°‚ç”¨ãƒ»éæ¨å¥¨ï¼‰
  AUTH_DISABLED: z.coerce.number().min(0).max(1).default(0),

  // Prisma
  PRISMA_CLIENT_ENGINE_TYPE: z.enum(['library', 'binary']).default('library'),

  // Sentryï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
  SENTRY_DSN: z.string().url().optional(),
  SENTRY_TRACES_SAMPLE_RATE: z.coerce.number().min(0).max(1).default(0.1),
  SENTRY_PROFILES_SAMPLE_RATE: z.coerce.number().min(0).max(1).default(0.1),

  // Resend Email Serviceï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
  RESEND_API_KEY: z.string().min(1).optional(),
  EMAIL_FROM: z.string().email().optional(),
  EMAIL_FROM_NAME: z.string().min(1).optional(),

  // ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰URLï¼ˆãƒ¡ãƒ¼ãƒ«ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç­‰ã§ä½¿ç”¨ï¼‰
  FRONTEND_URL: z.string().url().default('https://nekoya.co.jp'),
});

export type Environment = z.infer<typeof envSchema>;

/**
 * ç’°å¢ƒå¤‰æ•°ã‚’ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
 * 
 * @throws {Error} ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼æ™‚
 */
export function validateEnvironment(): Environment {
  try {
    const validated = envSchema.parse(process.env);
    return validated;
  } catch (error) {
    if (error instanceof z.ZodError) {
      console.error('âŒ ç’°å¢ƒå¤‰æ•°ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã«å¤±æ•—ã—ã¾ã—ãŸ:');
      error.errors.forEach((err) => {
        const path = err.path.join('.');
        console.error(`  - ${path}: ${err.message}`);
      });
      throw new Error('ç’°å¢ƒå¤‰æ•°ã®è¨­å®šãŒä¸æ­£ã§ã™ã€‚ä¸Šè¨˜ã®ã‚¨ãƒ©ãƒ¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
    }
    throw error;
  }
}

/**
 * æœ¬ç•ªç’°å¢ƒç”¨ã®è¿½åŠ ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
 */
export function validateProductionEnvironment(): void {
  const env = validateEnvironment();

  // æœ¬ç•ªç’°å¢ƒã§ã¯å¿…é ˆã®è¨­å®š
  const requiredForProduction = [
    { key: 'CORS_ORIGIN', value: env.CORS_ORIGIN },
    { key: 'JWT_SECRET', value: env.JWT_SECRET },
    { key: 'JWT_REFRESH_SECRET', value: env.JWT_REFRESH_SECRET },
  ];

  const missingConfigs = requiredForProduction.filter(
    (config) => !config.value || (typeof config.value === 'string' && config.value.length === 0)
  );

  if (missingConfigs.length > 0) {
    console.error('âŒ æœ¬ç•ªç’°å¢ƒã§å¿…é ˆã®è¨­å®šãŒä¸è¶³ã—ã¦ã„ã¾ã™:');
    missingConfigs.forEach((config) => {
      console.error(`  - ${config.key}`);
    });
    throw new Error('æœ¬ç•ªç’°å¢ƒã®è¨­å®šãŒä¸å®Œå…¨ã§ã™');
  }

  // é–‹ç™ºç”¨ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ãŒä½¿ã‚ã‚Œã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯
  const insecureDefaults = [];

  if (typeof env.JWT_SECRET === 'string' && (env.JWT_SECRET.includes('changeme') || env.JWT_SECRET.includes('local'))) {
    insecureDefaults.push('JWT_SECRET ã«é–‹ç™ºç”¨ã®å€¤ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã™');
  }

  if (typeof env.JWT_REFRESH_SECRET === 'string' && (env.JWT_REFRESH_SECRET.includes('changeme') || env.JWT_REFRESH_SECRET.includes('local'))) {
    insecureDefaults.push('JWT_REFRESH_SECRET ã«é–‹ç™ºç”¨ã®å€¤ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã™');
  }

  if (env.AUTH_DISABLED === 1) {
    insecureDefaults.push('AUTH_DISABLED=1 ã¯æœ¬ç•ªç’°å¢ƒã§ä½¿ç”¨ã§ãã¾ã›ã‚“');
  }

  if (insecureDefaults.length > 0) {
    console.error('âŒ æœ¬ç•ªç’°å¢ƒã§ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šå•é¡Œã®ã‚ã‚‹è¨­å®šãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ:');
    insecureDefaults.forEach((issue) => {
      console.error(`  - ${issue}`);
    });
    throw new Error('ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„');
  }
}

/**
 * ç’°å¢ƒå¤‰æ•°ã®æƒ…å ±ã‚’ãƒ­ã‚°å‡ºåŠ›ï¼ˆæ©Ÿå¯†æƒ…å ±ã¯éš ã™ï¼‰
 */
export function logEnvironmentInfo(): void {
  const env = validateEnvironment();

  console.log('ğŸ“‹ ç’°å¢ƒå¤‰æ•°ã®è¨­å®š:');
  console.log(`  NODE_ENV: ${env.NODE_ENV}`);
  console.log(`  PORT: ${env.PORT}`);
  console.log(`  LOG_LEVEL: ${env.LOG_LEVEL}`);
  console.log(`  DATABASE_URL: ${maskConnectionString(String(env.DATABASE_URL))}`);
  console.log(`  CORS_ORIGIN: ${env.CORS_ORIGIN || '(é–‹ç™ºãƒ¢ãƒ¼ãƒ‰)'}`);
  console.log(`  JWT_SECRET: ${maskSecret(String(env.JWT_SECRET))}`);
  console.log(`  JWT_REFRESH_SECRET: ${maskSecret(String(env.JWT_REFRESH_SECRET))}`);
  console.log(`  AUTH_DISABLED: ${env.AUTH_DISABLED === 1 ? 'âš ï¸ YES (é–‹ç™ºå°‚ç”¨)' : 'NO'}`);
}

/**
 * æ¥ç¶šæ–‡å­—åˆ—ã‚’ãƒã‚¹ã‚¯
 */
function maskConnectionString(connectionString: string): string {
  try {
    const url = new URL(connectionString);
    if (url.password) {
      url.password = '***';
    }
    return url.toString();
  } catch {
    return '***';
  }
}

/**
 * ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆå€¤ã‚’ãƒã‚¹ã‚¯
 */
function maskSecret(secret: string): string {
  if (!secret || secret.length < 8) {
    return '***';
  }
  return `${secret.substring(0, 4)}...${secret.substring(secret.length - 4)} (${secret.length}æ–‡å­—)`;
}
`````

## File: backend/src/common/config/rate-limit.config.ts
`````typescript
import type { Request } from 'express';

import type { RateLimitOptions, RateLimitTracker } from '../decorators/rate-limit.decorator';

type RateLimitGroup = Record<string, RateLimitOptions>;

interface RateLimitConfigShape {
  auth: RateLimitGroup;
  api: RateLimitGroup;
  upload: RateLimitOptions;
  default: RateLimitOptions;
}

/**
 * ãƒ¬ãƒ¼ãƒˆåˆ¶é™è¨­å®š
 * ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã”ã¨ã®åˆ¶é™å€¤ã‚’å®šç¾©
 */

const extractClientIp = (req: Request): string => {
  const forwarded = req.headers['x-forwarded-for'];
  if (typeof forwarded === 'string' && forwarded.length > 0) {
    return forwarded.split(',')[0]?.trim() || req.ip || 'unknown';
  }
  const realIp = req.headers['x-real-ip'];
  if (typeof realIp === 'string' && realIp.length > 0) {
    return realIp.trim();
  }
  return req.ip || req.connection?.remoteAddress || 'unknown';
};

const normalizeEmail = (value: unknown): string => {
  if (typeof value === 'string') {
    return value.trim().toLowerCase();
  }
  return 'unknown';
};

const loginTracker: RateLimitTracker = async (rawReq) => {
  const req = rawReq as unknown as Request;
  const email = normalizeEmail((req.body as Record<string, unknown> | undefined)?.email);
  return `${extractClientIp(req)}:login:${email}`;
};

const registerTracker: RateLimitTracker = async (rawReq) => {
  const req = rawReq as unknown as Request;
  const ip = extractClientIp(req);
  const email = normalizeEmail((req.body as Record<string, unknown> | undefined)?.email);

  if (process.env.NODE_ENV === 'test' && email.includes('@')) {
    const localPart = email.split('@')[0];
    const match = localPart.match(/(.+)_\d+$/);
    const namespace = match ? match[1] : localPart;
    return `register:${ip}:${namespace}`;
  }

  return `register:${ip}`;
};

const refreshTracker: RateLimitTracker = async (rawReq) => {
  const req = rawReq as unknown as Request;
  const token = (() => {
    const bodyToken = (req.body as Record<string, unknown> | undefined)?.refreshToken;
    if (typeof bodyToken === 'string' && bodyToken.length > 0) {
      return bodyToken;
    }
    const cookies = req.cookies as Record<string, unknown> | undefined;
    const cookieToken = typeof cookies?.refresh_token === 'string' ? cookies.refresh_token : undefined;
    return cookieToken ?? 'missing';
  })();
  return `${extractClientIp(req)}:refresh:${token}`;
};

export const RateLimitConfig: RateLimitConfigShape = {
  // èªè¨¼ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ: å³æ ¼ãªåˆ¶é™
  auth: {
    login: { ttl: 60000, limit: 20, tracker: loginTracker },           // 1åˆ†é–“ã«20å›ï¼ˆIP+ãƒ¡ãƒ¼ãƒ«å˜ä½ï¼‰
    register: { ttl: 60000, limit: 5, tracker: registerTracker },      // 1åˆ†é–“ã«5å›ï¼ˆIPå˜ä½ / ãƒ†ã‚¹ãƒˆã¯ãƒ¡ãƒ¼ãƒ«åˆ¥ï¼‰
    refresh: { ttl: 60000, limit: 20, tracker: refreshTracker },       // 1åˆ†é–“ã«20å›ï¼ˆåŒä¸€ãƒˆãƒ¼ã‚¯ãƒ³å˜ä½ï¼‰
    resetPassword: { ttl: 300000, limit: 3 },                          // 5åˆ†é–“ã«3å›
    requestReset: { ttl: 300000, limit: 3 },                           // 5åˆ†é–“ã«3å›
  },

  // API ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ: é€šå¸¸ã®åˆ¶é™
  api: {
    read: { ttl: 60000, limit: 100 },          // 1åˆ†é–“ã«100å›ï¼ˆGETï¼‰
    write: { ttl: 60000, limit: 30 },          // 1åˆ†é–“ã«30å›ï¼ˆPOST/PUT/DELETEï¼‰
    heavy: { ttl: 60000, limit: 10 },          // 1åˆ†é–“ã«10å›ï¼ˆé‡ã„å‡¦ç†ï¼‰
  },

  // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰: å³æ ¼ãªåˆ¶é™
  upload: {
    ttl: 300000,
    limit: 10,                                 // 5åˆ†é–“ã«10å›
  },

  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
  default: {
    ttl: 60000,
    limit: 100,                                // 1åˆ†é–“ã«100å›
  },
};
`````

## File: backend/src/common/controllers/master-data.controller.ts
`````typescript
import { Controller, Get, HttpStatus } from "@nestjs/common";
import { ApiTags, ApiOperation, ApiResponse } from "@nestjs/swagger";

import { GENDER_MASTER } from "../../cats/constants/gender";

@ApiTags("Master Data")
@Controller("master")
export class MasterDataController {
  @Get("genders")
  @ApiOperation({ summary: "æ€§åˆ¥ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆèªè¨¼ä¸è¦ï¼‰" })
  @ApiResponse({
    status: HttpStatus.OK,
    description: "æ€§åˆ¥ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’è¿”å´",
  })
  getGenders() {
    return {
      success: true,
      data: GENDER_MASTER.map(record => ({
        id: parseInt(record.key),
        code: parseInt(record.key),
        name: record.name,
        canonical: record.canonical,
      })),
    };
  }
}
`````

## File: backend/src/common/decorators/public.decorator.ts
`````typescript
import { SetMetadata } from '@nestjs/common';

/**
 * Public ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿
 * 
 * èªè¨¼ä¸è¦ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆï¼ˆæ‹›å¾…å®Œäº†APIãªã©ï¼‰ã«ä½¿ç”¨ã—ã¾ã™ã€‚
 */
export const IS_PUBLIC_KEY = 'isPublic';
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);
`````

## File: backend/src/common/decorators/rate-limit.decorator.ts
`````typescript
import { SetMetadata } from '@nestjs/common';

export const RATE_LIMIT_KEY = 'rate_limit';

export type RateLimitTracker = (req: Record<string, unknown>) => string | Promise<string>;

export interface RateLimitOptions {
  ttl: number;
  limit: number;
  tracker?: RateLimitTracker;
}

/**
 * ã‚«ã‚¹ã‚¿ãƒ ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿
 * 
 * @example
 * ```typescript
 * @RateLimit({ ttl: 60000, limit: 10 })
 * @Post('login')
 * async login() { ... }
 * ```
 */
export const RateLimit = (options: RateLimitOptions) =>
  SetMetadata(RATE_LIMIT_KEY, options);
`````

## File: backend/src/common/dto/api-response.dto.ts
`````typescript
/**
 * çµ±ä¸€APIãƒ¬ã‚¹ãƒãƒ³ã‚¹å‹
 * å…¨ã¦ã®APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã§ä½¿ç”¨ã™ã‚‹æ¨™æº–ãƒ¬ã‚¹ãƒãƒ³ã‚¹å½¢å¼
 */
export class ApiResponse<T> {
  /**
   * APIå‘¼ã³å‡ºã—ã®æˆåŠŸå¯å¦
   */
  success: boolean;

  /**
   * ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ‡ãƒ¼ã‚¿
   */
  data?: T;

  /**
   * ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆå¤±æ•—æ™‚ï¼‰
   */
  error?: string;

  /**
   * ã‚¨ãƒ©ãƒ¼è©³ç´°ï¼ˆå¤±æ•—æ™‚ã€é–‹ç™ºç”¨ï¼‰
   */
  details?: unknown;

  /**
   * ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
   */
  timestamp: string;

  constructor(success: boolean, data?: T, error?: string, details?: unknown) {
    this.success = success;
    this.data = data;
    this.error = error;
    this.details = details;
    this.timestamp = new Date().toISOString();
  }

  /**
   * æˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ç”Ÿæˆ
   */
  static success<T>(data: T): ApiResponse<T> {
    return new ApiResponse(true, data);
  }

  /**
   * ã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ç”Ÿæˆ
   */
  static error<T>(error: string, details?: unknown): ApiResponse<T> {
    return new ApiResponse(false, undefined as T, error, details);
  }
}

/**
 * ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ä»˜ããƒ¬ã‚¹ãƒãƒ³ã‚¹
 */
export class PaginatedResponse<T> extends ApiResponse<T[]> {
  total: number;
  page: number;
  pageSize: number;
  totalPages: number;

  constructor(
    data: T[],
    total: number,
    page: number,
    pageSize: number,
  ) {
    super(true, data);
    this.total = total;
    this.page = page;
    this.pageSize = pageSize;
    this.totalPages = Math.ceil(total / pageSize);
  }
}
`````

## File: backend/src/common/filters/enhanced-global-exception.filter.ts
`````typescript
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
  Logger,
} from '@nestjs/common';
import * as Sentry from '@sentry/node';
import { Request, Response } from 'express';

import type { RequestUser } from '../../auth/auth.types';

/**
 * ã‚¨ãƒ©ãƒ¼ç›£è¦–ã‚’å¼·åŒ–ã—ãŸã‚°ãƒ­ãƒ¼ãƒãƒ«ä¾‹å¤–ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
 * Sentryã¨æ§‹é€ åŒ–ãƒ­ã‚°ã«å¯¾å¿œ
 */
@Catch()
export class EnhancedGlobalExceptionFilter implements ExceptionFilter {
  private readonly logger = new Logger('GlobalExceptionFilter');

  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request & { user?: RequestUser }>();

    const status =
      exception instanceof HttpException
        ? exception.getStatus()
        : HttpStatus.INTERNAL_SERVER_ERROR;

    const exceptionResponse =
      exception instanceof HttpException ? exception.getResponse() : undefined;

    const responseMessage =
      typeof exceptionResponse === 'object' && exceptionResponse !== null
        ? (exceptionResponse as Record<string, unknown>).message
        : undefined;

    const message = Array.isArray(responseMessage)
      ? responseMessage.join(', ')
      : typeof responseMessage === 'string'
        ? responseMessage
        : exception instanceof HttpException
            ? exception.message
            : 'Internal server error';

    const errorResponse: Record<string, unknown> = {
      statusCode: status,
      code: HttpStatus[status] ?? 'ERROR',
      message,
      timestamp: new Date().toISOString(),
      path: request.url,
      method: request.method,
    };

    if (Array.isArray(responseMessage)) {
      errorResponse.details = responseMessage;
    }

    if (
      typeof exceptionResponse === 'object' &&
      exceptionResponse !== null &&
      'details' in exceptionResponse &&
      !('details' in errorResponse)
    ) {
      errorResponse.details = (exceptionResponse as Record<string, unknown>).details;
    }

    // æ§‹é€ åŒ–ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°
    const logData = {
      ...errorResponse,
      ip: request.ip,
      userAgent: request.get('user-agent'),
      userId: request.user?.userId,
      error: exception instanceof Error ? exception.stack : String(exception),
    };

    // ã‚¨ãƒ©ãƒ¼ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ãŸãƒ­ã‚°å‡ºåŠ›
    if (status >= 500) {
      this.logger.error({
        message: 'Server error occurred',
        ...logData,
        severity: 'error',
      });

      // Sentryã«å ±å‘Šï¼ˆæœ¬ç•ªç’°å¢ƒã®ã¿ï¼‰
      if (process.env.NODE_ENV === 'production' && process.env.SENTRY_DSN) {
        Sentry.captureException(exception, {
          contexts: {
            request: {
              method: request.method,
              url: request.url,
              headers: request.headers,
            },
            user: {
              id: request.user?.userId,
              email: request.user?.email,
            },
          },
        });
      }
    } else if (status >= 400) {
      this.logger.warn({
        message: 'Client error occurred',
        ...logData,
        severity: 'warning',
      });
    }

    // ãƒ¬ã‚¹ãƒãƒ³ã‚¹é€ä¿¡
    response.status(status).json({
      success: false,
      error: errorResponse,
    });
  }
}
`````

## File: backend/src/common/filters/global-exception.filter.ts
`````typescript
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
  Logger,
} from '@nestjs/common';
import { Prisma } from '@prisma/client';
import { Response, Request } from 'express';

@Catch()
export class GlobalExceptionFilter implements ExceptionFilter {
  private readonly logger = new Logger(GlobalExceptionFilter.name);

  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
  const request = ctx.getRequest<Request>();

    let status = HttpStatus.INTERNAL_SERVER_ERROR;
    let message = 'Internal server error';
    let code = 'INTERNAL_ERROR';
  let details: unknown = undefined;

    // NestJSã®HTTPä¾‹å¤–
    if (exception instanceof HttpException) {
      status = exception.getStatus();
  const exceptionResponse = exception.getResponse();
      
      if (typeof exceptionResponse === 'string') {
        message = exceptionResponse;
      } else if (typeof exceptionResponse === 'object' && exceptionResponse) {
        const resp = exceptionResponse as Record<string, unknown> & { message?: string | string[]; error?: string };
        const msg = resp.message;
        message = Array.isArray(msg) ? msg.join(', ') : (typeof msg === 'string' ? msg : (resp.error ?? message));
        code = (typeof resp.error === 'string' ? resp.error : undefined) || this.getErrorCodeFromStatus(status);
        details = (resp as { details?: unknown }).details;
      }
    }
    // Prismaã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
    else if (exception instanceof Prisma.PrismaClientKnownRequestError) {
      const prismaError = this.handlePrismaError(exception);
      status = prismaError.status;
      message = prismaError.message;
      code = prismaError.code;
    }
    // Prisma Unknown Request Error
    else if (exception instanceof Prisma.PrismaClientUnknownRequestError) {
      status = HttpStatus.INTERNAL_SERVER_ERROR;
      message = 'Unknown database error';
      code = 'DATABASE_UNKNOWN_ERROR';
      details = { message: exception.message };
    }
    // Prisma Rust Panic Error
    else if (exception instanceof Prisma.PrismaClientRustPanicError) {
      status = HttpStatus.INTERNAL_SERVER_ERROR;
      message = 'Database engine panic';
      code = 'DATABASE_PANIC';
      details = { message: exception.message };
    }
    // Prisma Validation Error
    else if (exception instanceof Prisma.PrismaClientValidationError) {
      status = HttpStatus.BAD_REQUEST;
      message = 'Invalid data provided';
      code = 'VALIDATION_ERROR';
      // å¯èƒ½ã§ã‚ã‚Œã° message ã‹ã‚‰ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å˜ä½ã®æƒ…å ±ã‚’æ¨æ¸¬ã—ã¦æŠ½å‡º
      const parsed = this.parsePrismaValidationMessage(exception.message);
      details = parsed ?? { message: exception.message };
    }
    // ãã®ä»–ã®ã‚¨ãƒ©ãƒ¼
    else if (exception instanceof Error) {
      message = exception.message;
      this.logger.error(exception.stack);
    }

    // ãƒ­ã‚°å‡ºåŠ›
    this.logger.error(
  `${request.method} ${request.url} - ${status} ${message}`,
  exception instanceof Error ? exception.stack : String(exception),
    );

    // çµ±ä¸€ãƒ¬ã‚¹ãƒãƒ³ã‚¹å½¢å¼ã§ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™
    const errorResponse = {
      success: false,
      error: {
        code,
        message,
        ...(details ? { details } : {}),
      },
      timestamp: new Date().toISOString(),
      path: request.url,
    };

    response.status(status).json(errorResponse);
  }

  private handlePrismaError(error: Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case 'P2002': {
        // ä¸€æ„åˆ¶ç´„é•å
        const field = error.meta?.target as string[] | undefined;
        return {
          status: HttpStatus.CONFLICT,
          message: field
            ? `${field.join(', ')} already exists`
            : 'Duplicate entry',
          code: 'DUPLICATE_ENTRY',
        };
      }
      
      case 'P2025':
        // ãƒ¬ã‚³ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚‰ãªã„
        return {
          status: HttpStatus.NOT_FOUND,
          message: 'Record not found',
          code: 'NOT_FOUND',
        };
      
      case 'P2003':
        // å¤–éƒ¨ã‚­ãƒ¼åˆ¶ç´„é•å
        return {
          status: HttpStatus.BAD_REQUEST,
          message: 'Foreign key constraint failed',
          code: 'FOREIGN_KEY_ERROR',
        };
      
      case 'P2014':
        // å¿…é ˆé–¢é€£ãƒ¬ã‚³ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚‰ãªã„
        return {
          status: HttpStatus.BAD_REQUEST,
          message: 'Required relation missing',
          code: 'RELATION_ERROR',
        };
      
      default:
        return {
          status: HttpStatus.INTERNAL_SERVER_ERROR,
          message: 'Database error',
          code: 'DATABASE_ERROR',
        };
    }
  }

  private getErrorCodeFromStatus(status: number): string {
    switch (status) {
      case HttpStatus.BAD_REQUEST:
        return 'BAD_REQUEST';
      case HttpStatus.UNAUTHORIZED:
        return 'UNAUTHORIZED';
      case HttpStatus.FORBIDDEN:
        return 'FORBIDDEN';
      case HttpStatus.NOT_FOUND:
        return 'NOT_FOUND';
      case HttpStatus.CONFLICT:
        return 'CONFLICT';
      case HttpStatus.UNPROCESSABLE_ENTITY:
        return 'VALIDATION_ERROR';
      case HttpStatus.TOO_MANY_REQUESTS:
        return 'RATE_LIMITED';
      default:
        return 'INTERNAL_ERROR';
    }
  }

  /**
   * Prisma ValidationError ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆè‹±èªï¼‰ã‹ã‚‰ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã‚„ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’æ¨æ¸¬ã—ã¦æŠ½å‡ºã—ã¾ã™ã€‚
   * ä¾‹: "Argument name for data.name is missing." / "Unknown arg `foo` in data.foo for type CatCreateInput."
   * ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ Prisma ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ã‚ˆã‚Šå¤‰ã‚ã‚‹ãŸã‚ã€å¤±æ•—ã—ã¦ã‚‚å®‰å…¨ã« undefined ã‚’è¿”ã—ã¾ã™ã€‚
   */
  private parsePrismaValidationMessage(msg: string):
    | {
        issues: Array<{
          field?: string;
          message: string;
          hint?: string;
        }>;
        raw: string;
      }
    | undefined {
    try {
      const issues: Array<{ field?: string; message: string; hint?: string }> = [];

      const lines = msg.split('\n').map((l) => l.trim());
      for (const line of lines) {
        if (!line) continue;

        // Unknown arg `foo` in data.foo for type CatCreateInput.
        let m = line.match(/Unknown arg `([^`]+)` in (data\.[^\s]+) for type /i);
        if (m) {
          issues.push({ field: m[2], message: `Unknown argument: ${m[1]}` });
          continue;
        }

        // Argument name for data.name is missing.
        m = line.match(/Argument [^\s]+ for (data\.[^\s]+) is missing\.?/i);
        if (m) {
          issues.push({ field: m[1], message: 'Required field is missing' });
          continue;
        }

        // Type mismatch: "Argument name: Provided String, expected Int" ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç·©ãæ¤œå‡º
        m = line.match(/Argument ([^:]+): Provided ([^,]+), expected ([^.]+)\.?/i);
        if (m) {
          issues.push({ field: m[1], message: `Type mismatch: ${m[2]} -> ${m[3]}` });
          continue;
        }

        // data.foo.tooLong:ã€œã®ã‚ˆã†ãªã‚«ã‚¹ã‚¿ãƒ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚‚æ‹¾ã£ã¦ãŠã
        m = line.match(/(data\.[^\s:]+):\s*(.+)$/i);
        if (m) {
          issues.push({ field: m[1], message: m[2] });
          continue;
        }

        // ãã‚Œä»¥å¤–ã¯ç”Ÿã®è¡Œã‚’æ ¼ç´
        issues.push({ message: line });
      }

      if (issues.length === 0) return undefined;
      return { issues, raw: msg };
    } catch {
      return undefined;
    }
  }
}
`````

## File: backend/src/common/guards/enhanced-throttler.guard.ts
`````typescript
import { ExecutionContext, Injectable } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import {
  ThrottlerGuard,
  ThrottlerModuleOptions,
  ThrottlerOptions,
  ThrottlerStorage,
  ThrottlerGetTrackerFunction,
  ThrottlerGenerateKeyFunction,
  ThrottlerException,
} from '@nestjs/throttler';
import { Request, Response } from 'express';

import { RATE_LIMIT_KEY, RateLimitOptions } from '../decorators/rate-limit.decorator';

/**
 * æ‹¡å¼µç‰ˆThrottlerã‚¬ãƒ¼ãƒ‰
 * 
 * æ©Ÿèƒ½:
 * - ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆåˆ¥ãƒ¬ãƒ¼ãƒˆåˆ¶é™
 * - IPã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’çµ„ã¿åˆã‚ã›ãŸãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°
 * - ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®é™¤å¤–
 */
@Injectable()
export class EnhancedThrottlerGuard extends ThrottlerGuard {
  constructor(
    protected readonly options: ThrottlerModuleOptions,
    protected readonly storageService: ThrottlerStorage,
    protected readonly reflector: Reflector,
  ) {
    super(options, storageService, reflector);
  }

  /**
   * ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ãƒˆãƒ©ãƒƒã‚«ãƒ¼IDã‚’ç”Ÿæˆ
   * IPã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’çµ„ã¿åˆã‚ã›ã‚‹
   */
  protected async getTracker(req: Request): Promise<string> {
    const reqWithUser = req as Request & {
      user?: { userId?: string; id?: string };
      path?: string;
      connection?: { remoteAddress?: string };
    };

    const ip = this.getIpAddress(reqWithUser);
    const userId = reqWithUser.user?.userId || reqWithUser.user?.id || 'anonymous';
    const path = reqWithUser.path || reqWithUser.url || '';
    const method = reqWithUser.method || '';

    return `${ip}:${userId}:${method}:${path}`;
  }

  /**
   * IPã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
   */
  private getIpAddress(req: Request & { connection?: { remoteAddress?: string } }): string {
    // X-Forwarded-For ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã®å ´åˆï¼‰
    const forwardedFor = req.headers['x-forwarded-for'];
    if (typeof forwardedFor === 'string') {
      const ips = forwardedFor.split(',');
      return ips[0].trim();
    }
    
    // X-Real-IP ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯
    const realIp = req.headers['x-real-ip'];
    if (typeof realIp === 'string') {
      return realIp.trim();
    }
    
    // ç›´æ¥æ¥ç¶šã®å ´åˆ
    return req.ip || req.connection?.remoteAddress || 'unknown';
  }

  /**
   * ã‚¹ã‚­ãƒƒãƒ—ã™ã¹ããƒªã‚¯ã‚¨ã‚¹ãƒˆã‹ã©ã†ã‹ã‚’åˆ¤å®š
   */
  protected async shouldSkip(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest<Request>();
    const path = request.path || request.url;

    // ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¯é™¤å¤–
    const skipPaths = ['/health', '/api/v1/health', '/'];
    if (skipPaths.includes(path)) {
      return true;
    }

    return false;
  }

  /**
   * ã‚«ã‚¹ã‚¿ãƒ ãƒ¬ãƒ¼ãƒˆåˆ¶é™è¨­å®šã‚’å–å¾—
   */
  protected async getThrottlerConfig(context: ExecutionContext): Promise<RateLimitOptions | null> {
    const customLimit = this.reflector.getAllAndOverride<RateLimitOptions>(
      RATE_LIMIT_KEY,
      [context.getHandler(), context.getClass()],
    );

    return customLimit ?? null;
  }

  protected async handleRequest(
    context: ExecutionContext,
    limit: number,
    ttl: number,
    throttler: ThrottlerOptions,
    getTracker: ThrottlerGetTrackerFunction,
    generateKey: ThrottlerGenerateKeyFunction,
  ): Promise<boolean> {
    const customConfig = await this.getThrottlerConfig(context);
    const effectiveLimit = customConfig?.limit ?? limit;
    const effectiveTtl = customConfig?.ttl ?? ttl;
    const trackerFn = customConfig?.tracker ?? getTracker;

    const { req, res } = this.getRequestResponse(context);
    const request = req as Request;
    const response = res as Response;
    const ignoreUserAgents = throttler.ignoreUserAgents ?? this.commonOptions.ignoreUserAgents;
    if (Array.isArray(ignoreUserAgents)) {
      for (const pattern of ignoreUserAgents) {
        const userAgent = request.headers['user-agent'];
        if (typeof userAgent === 'string' && pattern.test(userAgent)) {
          return true;
        }
      }
    }

    const throttlerName = throttler.name ?? 'default';
    const tracker = await trackerFn(request as unknown as Record<string, unknown>);
    const key = generateKey(context, tracker, throttlerName);
    const { totalHits, timeToExpire } = await this.storageService.increment(key, effectiveTtl);
    const suffix = throttlerName === 'default' ? '' : `-${throttlerName}`;
    const remaining = Math.max(0, effectiveLimit - totalHits);

    response.header(`${this.headerPrefix}-Limit${suffix}`, effectiveLimit.toString());
    response.header(`${this.headerPrefix}-Remaining${suffix}`, remaining.toString());
    response.header(`${this.headerPrefix}-Reset${suffix}`, timeToExpire.toString());

    if (totalHits > effectiveLimit) {
      response.header(`Retry-After${suffix}`, timeToExpire.toString());
      throw new ThrottlerException('ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒé›†ä¸­ã—ã¦ã„ã¾ã™ã€‚ã—ã°ã‚‰ãå¾…ã£ã¦ã‹ã‚‰å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚');
    }

    return true;
  }
}
`````

## File: backend/src/common/guards/tenant-scoped.guard.spec.ts
`````typescript
import { ExecutionContext, ForbiddenException } from '@nestjs/common';
import { Reflector } from '@nestjs/core';

import { TenantScopedGuard } from './tenant-scoped.guard';

describe('TenantScopedGuard', () => {
  let guard: TenantScopedGuard;
  let reflector: Reflector;

  beforeEach(() => {
    reflector = new Reflector();
    guard = new TenantScopedGuard(reflector);
  });

  const createMockExecutionContext = (
    user?: { role?: string; tenantId?: string },
    params?: Record<string, string>,
    body?: Record<string, unknown>,
  ): ExecutionContext => {
    return {
      switchToHttp: () => ({
        getRequest: () => ({ user, params, body }),
      }),
    } as ExecutionContext;
  };

  describe('èªè¨¼ã•ã‚Œã¦ã„ãªã„ãƒ¦ãƒ¼ã‚¶ãƒ¼', () => {
    it('èªè¨¼ãŒå¿…è¦ã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ã‚‹', () => {
      const context = createMockExecutionContext();
      expect(() => guard.canActivate(context)).toThrow(ForbiddenException);
      expect(() => guard.canActivate(context)).toThrow('èªè¨¼ãŒå¿…è¦ã§ã™');
    });
  });

  describe('SUPER_ADMIN ãƒ¦ãƒ¼ã‚¶ãƒ¼', () => {
    it('ã™ã¹ã¦ã®ãƒ†ãƒŠãƒ³ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½', () => {
      const context = createMockExecutionContext(
        { role: 'SUPER_ADMIN', tenantId: 'tenant-1' },
        { tenantId: 'tenant-2' },
      );
      expect(guard.canActivate(context)).toBe(true);
    });

    it('ãƒ†ãƒŠãƒ³ãƒˆIDãŒæŒ‡å®šã•ã‚Œã¦ã„ãªãã¦ã‚‚ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½', () => {
      const context = createMockExecutionContext(
        { role: 'SUPER_ADMIN', tenantId: 'tenant-1' },
        {},
      );
      expect(guard.canActivate(context)).toBe(true);
    });
  });

  describe('TENANT_ADMIN ã¾ãŸã¯ USER', () => {
    it('è‡ªåˆ†ã®ãƒ†ãƒŠãƒ³ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ï¼ˆparamsçµŒç”±ï¼‰', () => {
      const context = createMockExecutionContext(
        { role: 'TENANT_ADMIN', tenantId: 'tenant-1' },
        { tenantId: 'tenant-1' },
      );
      expect(guard.canActivate(context)).toBe(true);
    });

    it('è‡ªåˆ†ã®ãƒ†ãƒŠãƒ³ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ï¼ˆbodyçµŒç”±ï¼‰', () => {
      const context = createMockExecutionContext(
        { role: 'USER', tenantId: 'tenant-1' },
        {},
        { tenantId: 'tenant-1' },
      );
      expect(guard.canActivate(context)).toBe(true);
    });

    it('ä»–ã®ãƒ†ãƒŠãƒ³ãƒˆã«ã¯ã‚¢ã‚¯ã‚»ã‚¹ä¸å¯', () => {
      const context = createMockExecutionContext(
        { role: 'TENANT_ADMIN', tenantId: 'tenant-1' },
        { tenantId: 'tenant-2' },
      );
      expect(() => guard.canActivate(context)).toThrow(ForbiddenException);
      expect(() => guard.canActivate(context)).toThrow(
        'ã“ã®ãƒ†ãƒŠãƒ³ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“',
      );
    });

    it('ãƒ†ãƒŠãƒ³ãƒˆIDãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼', () => {
      const context = createMockExecutionContext(
        { role: 'TENANT_ADMIN', tenantId: 'tenant-1' },
        {},
      );
      expect(() => guard.canActivate(context)).toThrow(ForbiddenException);
      expect(() => guard.canActivate(context)).toThrow(
        'ãƒ†ãƒŠãƒ³ãƒˆIDãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“',
      );
    });
  });

  describe('paramsã¨bodyã®å„ªå…ˆé †ä½', () => {
    it('paramsãŒå„ªå…ˆã•ã‚Œã‚‹', () => {
      const context = createMockExecutionContext(
        { role: 'USER', tenantId: 'tenant-1' },
        { tenantId: 'tenant-1' },
        { tenantId: 'tenant-2' },
      );
      expect(guard.canActivate(context)).toBe(true);
    });
  });
});
`````

## File: backend/src/common/guards/tenant-scoped.guard.ts
`````typescript
import { 
  Injectable, 
  CanActivate, 
  ExecutionContext, 
  ForbiddenException 
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';

import type { RequestUser } from '../../auth/auth.types';

/**
 * ãƒ†ãƒŠãƒ³ãƒˆã‚¹ã‚³ãƒ¼ãƒ—ã‚¬ãƒ¼ãƒ‰
 * 
 * ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ãƒ†ãƒŠãƒ³ãƒˆIDã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ†ãƒŠãƒ³ãƒˆIDãŒä¸€è‡´ã™ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã™ã€‚
 * SUPER_ADMINã¯ã™ã¹ã¦ã®ãƒ†ãƒŠãƒ³ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ã§ã™ã€‚
 */
@Injectable()
export class TenantScopedGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest<{ user?: RequestUser; params?: Record<string, string>; body?: Record<string, unknown> }>();
    const user = request.user;
    
    if (!user) {
      throw new ForbiddenException('èªè¨¼ãŒå¿…è¦ã§ã™');
    }

    // SUPER_ADMIN ã¯å…¨ãƒ†ãƒŠãƒ³ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
    if (user.role === 'SUPER_ADMIN') {
      return true;
    }

    // ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‹ã‚‰ãƒ†ãƒŠãƒ³ãƒˆIDã‚’å–å¾—ï¼ˆå„ªå…ˆé †ä½: params > bodyï¼‰
    const requestTenantId = request.params?.tenantId || request.body?.tenantId;

    // ãƒ†ãƒŠãƒ³ãƒˆIDãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã‚¢ã‚¯ã‚»ã‚¹æ‹’å¦
    if (!requestTenantId) {
      throw new ForbiddenException('ãƒ†ãƒŠãƒ³ãƒˆIDãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');
    }

    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ†ãƒŠãƒ³ãƒˆIDã¨ä¸€è‡´ã—ãªã„å ´åˆã¯ã‚¢ã‚¯ã‚»ã‚¹æ‹’å¦
    if (user.tenantId !== requestTenantId) {
      throw new ForbiddenException('ã“ã®ãƒ†ãƒŠãƒ³ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“');
    }

    return true;
  }
}
`````

## File: backend/src/common/interceptors/performance-monitoring.interceptor.ts
`````typescript
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
  Logger,
} from '@nestjs/common';
import type { Request, Response } from 'express';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

/**
 * ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–ã‚¤ãƒ³ã‚¿ãƒ¼ã‚»ãƒ—ã‚¿ãƒ¼
 * ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚¿ã‚¤ãƒ ã‚’è¨ˆæ¸¬ã—ã€é…ã„ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’è­¦å‘Šã™ã‚‹
 */
@Injectable()
export class PerformanceMonitoringInterceptor implements NestInterceptor {
  private readonly logger = new Logger('PerformanceMonitor');
  private readonly SLOW_REQUEST_THRESHOLD_MS = 1000; // 1ç§’ä»¥ä¸Šã‚’é…ã„ã¨åˆ¤å®š
  private readonly VERY_SLOW_REQUEST_THRESHOLD_MS = 3000; // 3ç§’ä»¥ä¸Šã‚’éå¸¸ã«é…ã„ã¨åˆ¤å®š

  intercept(context: ExecutionContext, next: CallHandler): Observable<unknown> {
    const httpContext = context.switchToHttp();
    const request = httpContext.getRequest<Request>();
    const response = httpContext.getResponse<Response>();
    const { method, url, ip } = request;
    const userAgent = request.get('user-agent') ?? '';
    const startTime = Date.now();

    return next.handle().pipe(
      tap({
        next: () => {
          const responseTime = Date.now() - startTime;
          const { statusCode } = response;

          // åŸºæœ¬çš„ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ­ã‚°
          const logData = {
            method,
            url,
            statusCode,
            responseTime: `${responseTime}ms`,
            ip,
            userAgent: userAgent.substring(0, 100), // é•·ã™ãã‚‹å ´åˆã¯åˆ‡ã‚Šè©°ã‚
            timestamp: new Date().toISOString(),
          };

          // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è­¦å‘Š
          if (responseTime >= this.VERY_SLOW_REQUEST_THRESHOLD_MS) {
            this.logger.error({
              message: 'Very slow request detected',
              ...logData,
              severity: 'critical',
            });
          } else if (responseTime >= this.SLOW_REQUEST_THRESHOLD_MS) {
            this.logger.warn({
              message: 'Slow request detected',
              ...logData,
              severity: 'warning',
            });
          } else if (process.env.NODE_ENV === 'development') {
            // é–‹ç™ºç’°å¢ƒã§ã¯å…¨ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ãƒ­ã‚°
            this.logger.debug(logData);
          }
        },
        error: (error: unknown) => {
          const responseTime = Date.now() - startTime;
          const errorDetails = error instanceof Error
            ? { message: error.message, stack: error.stack }
            : { message: String(error), stack: undefined };

          this.logger.error({
            message: 'Request failed with error',
            method,
            url,
            responseTime: `${responseTime}ms`,
            ip,
            error: errorDetails.message,
            stack: errorDetails.stack,
            timestamp: new Date().toISOString(),
          });
        },
      }),
    );
  }
}
`````

## File: backend/src/common/interceptors/transform-response.interceptor.ts
`````typescript
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

type Wrapped<T, M = undefined> = { success: true; data?: T; meta?: M } | { success: true };

@Injectable()
export class TransformResponseInterceptor<T, M = undefined>
  implements NestInterceptor<T, Wrapped<T, M>>
{
  intercept(context: ExecutionContext, next: CallHandler): Observable<Wrapped<T, M>> {
    return next.handle().pipe(
      map((data: T) => {
        // 1) æ—¢ã«ãƒ©ãƒƒãƒ—æ¸ˆã¿ã¯ãã®ã¾ã¾è¿”ã™
        if (data && typeof data === 'object' && 'success' in (data as unknown as { success: true })) {
          return data as unknown as Wrapped<T, M>;
        }

        // 2) null/undefined ã¯ payload ãªã—ã®æˆåŠŸ
        if (data === null || data === undefined) {
          return { success: true };
        }

        // 3) { data, meta } ã£ã½ã„æ§‹é€ ã¯ãƒ¡ã‚¿ã‚’ç¶­æŒ
        if (data && typeof data === 'object') {
          const obj = data as { data?: T; meta?: M };
          if ('data' in obj && !('success' in obj)) {
            const payload: { success: true; data: T; meta?: M } = {
              success: true,
              data: obj.data as T,
            };
            if ('meta' in obj) {
              payload.meta = obj.meta;
            }
            return payload as Wrapped<T, M>;
          }
        }

  // 4) é…åˆ—ãƒ»ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ data ã«åŒ…ã‚€
  return { success: true, data } as Wrapped<T, M>;
      }),
    );
  }
}
`````

## File: backend/src/common/middleware/cookie-parser.middleware.ts
`````typescript
import { Injectable, NestMiddleware } from '@nestjs/common';
import cookieParser from 'cookie-parser';
import { Request, Response, NextFunction } from 'express';

/**
 * Cookie Parser ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
 * ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®Cookieã‚’ãƒ‘ãƒ¼ã‚¹ã—ã¦req.cookiesã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«æ ¼ç´
 */
@Injectable()
export class CookieParserMiddleware implements NestMiddleware {
  private parser = cookieParser();

  use(req: Request, res: Response, next: NextFunction) {
    this.parser(req, res, next);
  }
}
`````

## File: backend/src/common/middleware/request-id.middleware.ts
`````typescript
import { randomUUID } from 'crypto';

import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

export const REQUEST_ID_HEADER = 'x-request-id';

@Injectable()
export class RequestIdMiddleware implements NestMiddleware {
  use(req: Request & { requestId?: string }, res: Response, next: NextFunction) {
    const existing = (req.headers[REQUEST_ID_HEADER] || req.headers[REQUEST_ID_HEADER.toUpperCase()]) as string | undefined;
    const id = existing || randomUUID();
    req.requestId = id;
    res.setHeader(REQUEST_ID_HEADER, id);
    next();
  }
}
`````

## File: backend/src/common/middleware/security.middleware.ts
`````typescript
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

/**
 * Security headers middleware for production deployment
 * Adds essential security headers to protect against common attacks
 */
@Injectable()
export class SecurityMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    // Prevent XSS attacks
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.setHeader('X-Frame-Options', 'DENY');
    res.setHeader('X-XSS-Protection', '1; mode=block');
    res.setHeader('X-DNS-Prefetch-Control', 'off');
    res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains; preload');
    
    // Content Security Policy
  res.setHeader('Content-Security-Policy', "default-src 'self'");
    
    // Referrer Policy
    res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
    
    // Feature Policy
    res.setHeader('Permissions-Policy', 'geolocation=(), microphone=(), camera=()');
    
    // Remove server signature
    res.removeHeader('X-Powered-By');
    
    next();
  }
}
`````

## File: backend/src/common/types/express.d.ts
`````typescript
import { RequestUser } from '../../auth/auth.types';

declare global {
  namespace Express {
    interface Request {
      user?: RequestUser;
    }
  }
}
`````

## File: backend/src/common/types/shift.types.ts
`````typescript
import { Shift, Staff } from '@prisma/client';

/**
 * ã‚·ãƒ•ãƒˆã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ï¼ˆãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å«ã‚€ï¼‰
 */
export type ShiftEntity = Shift & {
  staff: Staff;
};

/**
 * ã‚·ãƒ•ãƒˆãƒ¬ã‚¹ãƒãƒ³ã‚¹DTO
 */
export interface ShiftResponseDto {
  id: string;
  staffId: string;
  staffName: string;
  staffColor: string;
  shiftDate: string; // ISO 8601å½¢å¼
  displayName: string | null;
  status: string;
  notes: string | null;
  createdAt: string;
  updatedAt: string;
}

/**
 * ã‚·ãƒ•ãƒˆä½œæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆï¼ˆæœ€å°å®Ÿè£…: ã‚¹ã‚¿ãƒƒãƒ•åã‚’ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã§ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã«é…ç½®ï¼‰
 */
export interface CreateShiftRequest {
  staffId: string;
  shiftDate: string; // YYYY-MM-DDå½¢å¼
  displayName?: string | null;
  notes?: string | null;
}

/**
 * ã‚·ãƒ•ãƒˆæ›´æ–°ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
 */
export interface UpdateShiftRequest {
  staffId?: string;
  shiftDate?: string; // YYYY-MM-DDå½¢å¼
  displayName?: string | null;
  notes?: string | null;
  status?: string;
}

/**
 * ã‚·ãƒ•ãƒˆä¸€è¦§å–å¾—ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
 */
export interface GetShiftsQuery {
  startDate?: string; // YYYY-MM-DD
  endDate?: string;   // YYYY-MM-DD
  staffId?: string;
}

/**
 * ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ç”¨ã‚·ãƒ•ãƒˆã‚¤ãƒ™ãƒ³ãƒˆ
 */
export interface CalendarShiftEvent {
  id: string;
  title: string;
  start: string; // ISO 8601
  end: string;   // ISO 8601
  backgroundColor: string;
  borderColor: string;
  extendedProps: {
    shiftId: string;
    staffId: string;
    staffName: string;
    displayName: string | null;
    notes: string | null;
  };
}
`````

## File: backend/src/common/types/staff.types.ts
`````typescript
import { Staff } from '@prisma/client';

/**
 * æ›œæ—¥å‹
 */
export type Weekday = 'mon' | 'tue' | 'wed' | 'thu' | 'fri' | 'sat' | 'sun';

/**
 * å‹¤å‹™æ™‚é–“ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
 */
export interface WorkTimeTemplate {
  startHour: number; // 0â€“23
  endHour: number; // 1â€“24, must be > startHour
}

/**
 * ã‚¹ã‚¿ãƒƒãƒ•ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ï¼ˆDBã‹ã‚‰å–å¾—ã•ã‚Œã‚‹å®Œå…¨ãªå‹ï¼‰
 */
export type StaffEntity = Staff;

/**
 * ã‚¹ã‚¿ãƒƒãƒ•ãƒ¬ã‚¹ãƒãƒ³ã‚¹DTOï¼ˆãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã«è¿”å´ã•ã‚Œã‚‹å‹ï¼‰
 */
export interface StaffResponseDto {
  id: string;
  name: string;
  email: string | null;
  role: string;
  color: string;
  isActive: boolean;
  workingDays: Weekday[] | null;
  workTimeTemplate: WorkTimeTemplate | null;
  createdAt: string;
  updatedAt: string;
}

/**
 * ã‚¹ã‚¿ãƒƒãƒ•ä½œæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆï¼ˆãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‹ã‚‰å—ã‘å–ã‚‹å‹ï¼‰
 */
export interface CreateStaffRequest {
  name: string;
  email?: string | null;
  role?: string;
  color?: string;
  workingDays?: Weekday[] | null;
  workTimeTemplate?: WorkTimeTemplate | null;
}

/**
 * ã‚¹ã‚¿ãƒƒãƒ•æ›´æ–°ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
 */
export interface UpdateStaffRequest {
  name?: string;
  email?: string | null;
  role?: string;
  color?: string;
  isActive?: boolean;
  workingDays?: Weekday[] | null;
  workTimeTemplate?: WorkTimeTemplate | null;
}

/**
 * ã‚¹ã‚¿ãƒƒãƒ•ä¸€è¦§ãƒ¬ã‚¹ãƒãƒ³ã‚¹
 */
export interface StaffListResponseDto {
  staffList: StaffResponseDto[];
  total: number;
}
`````

## File: backend/src/common/environment.validation.ts
`````typescript
/**
 * Production Environment Validation
 * Ensures all required environment variables are properly configured
 */

export interface ProductionConfig {
  DATABASE_URL: string;
  JWT_SECRET: string;
  JWT_REFRESH_SECRET: string;
  NODE_ENV: string;
  PORT: number;
  CORS_ORIGIN: string;
}

export function validateProductionEnvironment(): ProductionConfig {
  const errors: string[] = [];

  // Required variables
  const requiredVars = {
    DATABASE_URL: process.env.DATABASE_URL,
    JWT_SECRET: process.env.JWT_SECRET,
    JWT_REFRESH_SECRET: process.env.JWT_REFRESH_SECRET,
    NODE_ENV: process.env.NODE_ENV,
    PORT: process.env.PORT,
    CORS_ORIGIN: process.env.CORS_ORIGIN,
  };

  // Check for missing variables
  Object.entries(requiredVars).forEach(([key, value]) => {
    if (!value) {
      errors.push(`Missing required environment variable: ${key}`);
    }
  });

  // Validate JWT secret length (should be at least 256 bits / 32 characters)
  if (requiredVars.JWT_SECRET && requiredVars.JWT_SECRET.length < 32) {
    errors.push("JWT_SECRET must be at least 32 characters long for security");
  }

  // Validate JWT refresh secret length
  if (requiredVars.JWT_REFRESH_SECRET && requiredVars.JWT_REFRESH_SECRET.length < 32) {
    errors.push("JWT_REFRESH_SECRET must be at least 32 characters long for security");
  }

  // Ensure JWT_REFRESH_SECRET is different from JWT_SECRET
  if (requiredVars.JWT_SECRET && requiredVars.JWT_REFRESH_SECRET && 
      requiredVars.JWT_SECRET === requiredVars.JWT_REFRESH_SECRET) {
    errors.push("JWT_REFRESH_SECRET must be different from JWT_SECRET for security");
  }

  // Validate NODE_ENV
  if (requiredVars.NODE_ENV && !["development", "staging", "production", "test"].includes(requiredVars.NODE_ENV)) {
    errors.push("NODE_ENV must be one of: development, staging, production, test");
  }

  // Validate PORT
  const port = Number(requiredVars.PORT);
  if (isNaN(port) || port < 1 || port > 65535) {
    errors.push("PORT must be a valid port number between 1 and 65535");
  }

  // Validate CORS origins for production
  if (requiredVars.NODE_ENV === "production" && requiredVars.CORS_ORIGIN) {
    const origins = requiredVars.CORS_ORIGIN.split(",").map(o => o.trim());
    origins.forEach(origin => {
      if (!origin.startsWith("https://")) {
        errors.push(`CORS origin must use HTTPS in production: ${origin}`);
      }
    });
  }

  // Validate database URL format
  if (requiredVars.DATABASE_URL && !requiredVars.DATABASE_URL.startsWith("postgresql://")) {
    errors.push("DATABASE_URL must be a valid PostgreSQL connection string");
  }

  if (errors.length > 0) {
    throw new Error(
      `Environment validation failed:\n${errors.map(e => `  - ${e}`).join("\n")}`
    );
  }

  return {
    DATABASE_URL: requiredVars.DATABASE_URL!,
    JWT_SECRET: requiredVars.JWT_SECRET!,
    JWT_REFRESH_SECRET: requiredVars.JWT_REFRESH_SECRET!,
    NODE_ENV: requiredVars.NODE_ENV!,
    PORT: Number(requiredVars.PORT!),
    CORS_ORIGIN: requiredVars.CORS_ORIGIN!,
  };
}

export function logEnvironmentInfo(): void {
  console.log("ğŸ”§ Environment Configuration:");
  console.log(`  NODE_ENV: ${process.env.NODE_ENV}`);
  console.log(`  PORT: ${process.env.PORT}`);
  console.log(`  Database: ${process.env.DATABASE_URL ? "âœ“ Configured" : "âœ— Missing"}`);
  console.log(`  JWT Secret: ${process.env.JWT_SECRET ? "âœ“ Configured" : "âœ— Missing"}`);
  console.log(`  JWT Refresh Secret: ${process.env.JWT_REFRESH_SECRET ? "âœ“ Configured" : "âœ— Missing"}`);
  console.log(`  CORS Origins: ${process.env.CORS_ORIGIN || "default"}`);
}
`````

## File: backend/src/display-preferences/dto/master-data-item.dto.ts
`````typescript
import { ApiProperty, ApiPropertyOptional } from "@nestjs/swagger";
import { DisplayNameMode } from "@prisma/client";

export class MasterDataItemDto {
  @ApiProperty({ description: "ãƒã‚¹ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿ã®ã‚³ãƒ¼ãƒ‰", example: 26 })
  code!: number;

  @ApiProperty({ description: "CSV å®šç¾©ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆåç§°", example: "Maine Coon" })
  name!: string;

  @ApiPropertyOptional({
    description: "ç”»é¢ã«è¡¨ç¤ºã•ã‚Œã‚‹åç§°ã€‚å€‹åˆ¥è¨­å®šãŒç„¡ã„å ´åˆã¯ name ã¨åŒä¸€ã€‚",
    example: "26 - Maine Coon",
  })
  displayName?: string;

  @ApiPropertyOptional({
    enum: DisplayNameMode,
    description: "ã“ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã«é©ç”¨ã•ã‚ŒãŸè¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰",
    example: DisplayNameMode.CODE_AND_NAME,
  })
  displayNameMode?: DisplayNameMode;

  @ApiPropertyOptional({ description: "ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸Šæ›¸ããŒé©ç”¨ã•ã‚ŒãŸå ´åˆã« true", example: true })
  isOverridden?: boolean;
}
`````

## File: backend/src/display-preferences/dto/update-display-preference.dto.ts
`````typescript
import { ApiPropertyOptional } from "@nestjs/swagger";
import { DisplayNameMode } from "@prisma/client";
import { Type } from "class-transformer";
import {
  IsArray,
  IsEnum,
  IsInt,
  IsOptional,
  IsString,
  MaxLength,
  Min,
  MinLength,
  ValidateNested,
} from "class-validator";

export class LabelOverrideDto {
  @ApiPropertyOptional({ description: "å¯¾è±¡ã‚³ãƒ¼ãƒ‰", example: 26 })
  @IsInt()
  @Min(0)
  code!: number;

  @ApiPropertyOptional({ description: "è¡¨ç¤ºåã®ä¸Šæ›¸ã", example: "ãƒ¡ã‚¤ãƒ³ã‚¯ãƒ¼ãƒ³" })
  @IsString()
  @MinLength(1)
  @MaxLength(120)
  label!: string;
}

export class UpdateDisplayPreferenceDto {
  @ApiPropertyOptional({ enum: DisplayNameMode, description: "å“ç¨®ãƒã‚¹ã‚¿ã®è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰" })
  @IsOptional()
  @IsEnum(DisplayNameMode)
  breedNameMode?: DisplayNameMode;

  @ApiPropertyOptional({ enum: DisplayNameMode, description: "æ¯›è‰²ãƒã‚¹ã‚¿ã®è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰" })
  @IsOptional()
  @IsEnum(DisplayNameMode)
  coatColorNameMode?: DisplayNameMode;

  @ApiPropertyOptional({
    description: "å“ç¨®ã‚³ãƒ¼ãƒ‰ã”ã¨ã®è¡¨ç¤ºåä¸Šæ›¸ã",
    type: () => [LabelOverrideDto],
  })
  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => LabelOverrideDto)
  breedLabelOverrides?: LabelOverrideDto[];

  @ApiPropertyOptional({
    description: "æ¯›è‰²ã‚³ãƒ¼ãƒ‰ã”ã¨ã®è¡¨ç¤ºåä¸Šæ›¸ã",
    type: () => [LabelOverrideDto],
  })
  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => LabelOverrideDto)
  coatColorLabelOverrides?: LabelOverrideDto[];
}
`````

## File: backend/src/display-preferences/display-preferences.controller.spec.ts
`````typescript
import { UnauthorizedException } from "@nestjs/common";
import { Test, type TestingModule } from "@nestjs/testing";
import { DisplayNameMode } from "@prisma/client";

import type { RequestUser } from "../auth/auth.types";
import { getTestModuleImports, getTestModuleProviders } from "../test-utils/test-module-setup";

import { DisplayPreferencesController } from "./display-preferences.controller";
import { DisplayPreferencesService } from "./display-preferences.service";
import type { DisplayPreferenceView } from "./display-preferences.types";
import { UpdateDisplayPreferenceDto } from "./dto/update-display-preference.dto";

describe("DisplayPreferencesController", () => {
  let controller: DisplayPreferencesController;
  let service: {
    getPreferences: jest.Mock;
    upsertPreferences: jest.Mock;
  };

  const basePreference: DisplayPreferenceView = {
    userId: "user-1",
    breedNameMode: DisplayNameMode.CANONICAL,
    coatColorNameMode: DisplayNameMode.CANONICAL,
    breedLabelOverrides: {},
    coatColorLabelOverrides: {},
    updatedAt: new Date("2024-01-02T00:00:00.000Z"),
    createdAt: new Date("2024-01-01T00:00:00.000Z"),
  };

  beforeEach(async () => {
    service = {
      getPreferences: jest.fn().mockResolvedValue(basePreference),
      upsertPreferences: jest.fn().mockResolvedValue(basePreference),
    };

    const module: TestingModule = await Test.createTestingModule({
      imports: getTestModuleImports(),
      controllers: [DisplayPreferencesController],
      providers: [
        ...getTestModuleProviders(),
        {
          provide: DisplayPreferencesService,
          useValue: service,
        },
      ],
    }).compile();

    controller = module.get(DisplayPreferencesController);
  });

  describe("getMine", () => {
    it("returns current user's preferences", async () => {
      const user: RequestUser = {
        userId: "user-1",
        role: "USER",
        email: "user@example.com",
      } as RequestUser;

      const result = await controller.getMine(user);

      expect(result).toBe(basePreference);
      expect(service.getPreferences).toHaveBeenCalledWith("user-1");
    });

    it("throws when user is missing", async () => {
      await expect(controller.getMine(undefined)).rejects.toThrow(UnauthorizedException);
      expect(service.getPreferences).not.toHaveBeenCalled();
    });
  });

  describe("updateMine", () => {
    it("updates preferences for the authenticated user", async () => {
      const user: RequestUser = {
        userId: "user-2",
        role: "USER",
        email: "user2@example.com",
      } as RequestUser;
      const dto: UpdateDisplayPreferenceDto = {
        breedNameMode: DisplayNameMode.CUSTOM,
      };

      await controller.updateMine(user, dto);

      expect(service.upsertPreferences).toHaveBeenCalledWith("user-2", dto);
    });

    it("rejects updates when user is missing", async () => {
      await expect(controller.updateMine(undefined, {} as UpdateDisplayPreferenceDto)).rejects.toThrow(
        UnauthorizedException,
      );
      expect(service.upsertPreferences).not.toHaveBeenCalled();
    });
  });
});
`````

## File: backend/src/display-preferences/display-preferences.controller.ts
`````typescript
import {
  Body,
  Controller,
  Get,
  HttpStatus,
  Patch,
  UnauthorizedException,
  UseGuards,
} from "@nestjs/common";
import { ApiBearerAuth, ApiOperation, ApiResponse, ApiTags } from "@nestjs/swagger";

import type { RequestUser } from "../auth/auth.types";
import { GetUser } from "../auth/get-user.decorator";
import { JwtAuthGuard } from "../auth/jwt-auth.guard";

import { DisplayPreferencesService } from "./display-preferences.service";
import { UpdateDisplayPreferenceDto } from "./dto/update-display-preference.dto";

@ApiTags("Display Preferences")
@ApiBearerAuth()
@UseGuards(JwtAuthGuard)
@Controller("display-preferences")
export class DisplayPreferencesController {
  constructor(private readonly displayPreferences: DisplayPreferencesService) {}

  @Get("me")
  @ApiOperation({ summary: "è‡ªèº«ã®è¡¨ç¤ºè¨­å®šã‚’å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK, description: "è¡¨ç¤ºè¨­å®šã®å–å¾—ã«æˆåŠŸ" })
  async getMine(@GetUser() user: RequestUser | undefined) {
    if (!user) {
      throw new UnauthorizedException("ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’ç¢ºèªã§ãã¾ã›ã‚“ã§ã—ãŸ");
    }

    return this.displayPreferences.getPreferences(user.userId);
  }

  @Patch("me")
  @ApiOperation({ summary: "è‡ªèº«ã®è¡¨ç¤ºè¨­å®šã‚’æ›´æ–°" })
  @ApiResponse({ status: HttpStatus.OK, description: "è¡¨ç¤ºè¨­å®šã®æ›´æ–°ã«æˆåŠŸ" })
  async updateMine(
    @GetUser() user: RequestUser | undefined,
    @Body() dto: UpdateDisplayPreferenceDto,
  ) {
    if (!user) {
      throw new UnauthorizedException("ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’ç¢ºèªã§ãã¾ã›ã‚“ã§ã—ãŸ");
    }

    return this.displayPreferences.upsertPreferences(user.userId, dto);
  }
}
`````

## File: backend/src/display-preferences/display-preferences.module.ts
`````typescript
import { Module } from "@nestjs/common";

import { PrismaModule } from "../prisma/prisma.module";

import { DisplayPreferencesController } from "./display-preferences.controller";
import { DisplayPreferencesService } from "./display-preferences.service";

@Module({
  imports: [PrismaModule],
  controllers: [DisplayPreferencesController],
  providers: [DisplayPreferencesService],
  exports: [DisplayPreferencesService],
})
export class DisplayPreferencesModule {}
`````

## File: backend/src/display-preferences/display-preferences.service.spec.ts
`````typescript
import { BadRequestException } from "@nestjs/common";
import { Test, type TestingModule } from "@nestjs/testing";
import { DisplayNameMode, Prisma, type DisplayPreference } from "@prisma/client";

import { PrismaService } from "../prisma/prisma.service";

import { DisplayPreferencesService } from "./display-preferences.service";
import type { DisplayPreferenceView } from "./display-preferences.types";

describe("DisplayPreferencesService", () => {
  let service: DisplayPreferencesService;
  let prisma: {
    displayPreference: {
      findUnique: jest.Mock;
      upsert: jest.Mock;
    };
    breed: {
      findMany: jest.Mock;
    };
    coatColor: {
      findMany: jest.Mock;
    };
  };

  beforeEach(async () => {
    prisma = {
      displayPreference: {
        findUnique: jest.fn(),
        upsert: jest.fn(),
      },
      breed: {
        findMany: jest.fn().mockResolvedValue([
          { code: 26, name: "Maine Coon" },
          { code: 1, name: "Abyssinian" },
        ]),
      },
      coatColor: {
        findMany: jest.fn().mockResolvedValue([
          { code: 1, name: "White" },
          { code: 2, name: "Blue" },
        ]),
      },
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        DisplayPreferencesService,
        {
          provide: PrismaService,
          useValue: prisma,
        },
      ],
    }).compile();

    service = module.get(DisplayPreferencesService);
  });

  describe("getPreferences", () => {
    it("should build default view when record is absent", async () => {
      prisma.displayPreference.findUnique.mockResolvedValue(null);

      const result = await service.getPreferences("user-1");

      expect(result).toMatchObject({
        userId: "user-1",
        breedNameMode: DisplayNameMode.CANONICAL,
        coatColorNameMode: DisplayNameMode.CANONICAL,
        breedLabelOverrides: {},
        coatColorLabelOverrides: {},
      });
      expect(result.updatedAt.getTime()).toBe(0);
      expect(prisma.displayPreference.findUnique).toHaveBeenCalledWith({
        where: { userId: "user-1" },
      });
    });

    it("should map persisted entity to view format", async () => {
      const timestamp = new Date("2024-02-01T00:00:00.000Z");
      const breedOverrides: Prisma.JsonObject = { "26": "å’Œåãƒ¡ã‚¤ãƒ³ã‚¯ãƒ¼ãƒ³" };
      const entity: DisplayPreference = {
        id: "pref-1",
        userId: "user-1",
        breedNameMode: DisplayNameMode.CUSTOM,
        coatColorNameMode: DisplayNameMode.CODE_AND_NAME,
        breedNameOverrides: breedOverrides,
  coatColorNameOverrides: null,
        createdAt: timestamp,
        updatedAt: timestamp,
      };
      prisma.displayPreference.findUnique.mockResolvedValue(entity);

      const result = await service.getPreferences("user-1");

      expect(result).toEqual({
        userId: "user-1",
        breedNameMode: DisplayNameMode.CUSTOM,
        coatColorNameMode: DisplayNameMode.CODE_AND_NAME,
        breedLabelOverrides: { 26: "å’Œåãƒ¡ã‚¤ãƒ³ã‚¯ãƒ¼ãƒ³" },
        coatColorLabelOverrides: {},
        createdAt: timestamp,
        updatedAt: timestamp,
      });
    });
  });

  describe("buildPersonalized*Records", () => {
    const baseView: DisplayPreferenceView = {
      userId: "user-1",
      breedNameMode: DisplayNameMode.CANONICAL,
      coatColorNameMode: DisplayNameMode.CANONICAL,
      breedLabelOverrides: {},
      coatColorLabelOverrides: {},
      createdAt: new Date("2024-01-01T00:00:00.000Z"),
      updatedAt: new Date("2024-01-02T00:00:00.000Z"),
    };

    it("should reflect custom breed overrides when mode is CUSTOM", async () => {
      const preference: DisplayPreferenceView = {
        ...baseView,
        breedNameMode: DisplayNameMode.CUSTOM,
        breedLabelOverrides: {
          26: "ãƒ¡ã‚¤ãƒ³ã‚¯ãƒ¼ãƒ³æ§˜",
        },
      };

      const records = await service.buildPersonalizedBreedRecords(preference);
      const target = records.find((record) => record.code === 26);

      expect(target).toEqual({
        code: 26,
        canonicalName: "Maine Coon",
        displayName: "ãƒ¡ã‚¤ãƒ³ã‚¯ãƒ¼ãƒ³æ§˜",
        displayNameMode: DisplayNameMode.CUSTOM,
        isOverridden: true,
      });
    });

    it("should compose coat color labels when mode is CODE_AND_NAME", async () => {
      const preference: DisplayPreferenceView = {
        ...baseView,
        coatColorNameMode: DisplayNameMode.CODE_AND_NAME,
      };

      const records = await service.buildPersonalizedCoatColorRecords(preference);
      const target = records.find((record) => record.code === 1);

      expect(target).toEqual({
        code: 1,
        canonicalName: "White",
        displayName: "1 - White",
        displayNameMode: DisplayNameMode.CODE_AND_NAME,
        isOverridden: false,
      });
    });
  });

  describe("upsertPreferences", () => {
    it("should upsert preferences with trimmed overrides", async () => {
      const timestamp = new Date("2024-03-01T00:00:00.000Z");
      const persisted: DisplayPreference = {
        id: "pref-1",
        userId: "user-1",
        breedNameMode: DisplayNameMode.CUSTOM,
        coatColorNameMode: DisplayNameMode.CANONICAL,
        breedNameOverrides: { "26": "ç‹æ§˜" },
  coatColorNameOverrides: null,
        createdAt: timestamp,
        updatedAt: timestamp,
      };
      prisma.displayPreference.upsert.mockResolvedValue(persisted);

      const result = await service.upsertPreferences("user-1", {
        breedNameMode: DisplayNameMode.CUSTOM,
        breedLabelOverrides: [{ code: 26, label: " ç‹æ§˜ " }],
      });

      expect(prisma.breed.findMany).toHaveBeenCalled();
      expect(prisma.displayPreference.upsert).toHaveBeenCalledWith({
        where: { userId: "user-1" },
        create: expect.objectContaining({
          breedNameMode: DisplayNameMode.CUSTOM,
          breedNameOverrides: { "26": "ç‹æ§˜" },
        }),
        update: expect.objectContaining({
          breedNameMode: DisplayNameMode.CUSTOM,
          breedNameOverrides: { "26": "ç‹æ§˜" },
        }),
      });

      expect(result.breedLabelOverrides).toEqual({ 26: "ç‹æ§˜" });
      expect(result.breedNameMode).toBe(DisplayNameMode.CUSTOM);
    });

    it("should throw when overrides reference unknown codes", async () => {
      prisma.breed.findMany.mockResolvedValue([{ code: 1, name: "Abyssinian" }]);

      await expect(
        service.upsertPreferences("user-1", {
          breedLabelOverrides: [{ code: 9999, label: "??" }],
        }),
      ).rejects.toThrow(BadRequestException);

      expect(prisma.breed.findMany).toHaveBeenCalled();
      expect(prisma.displayPreference.upsert).not.toHaveBeenCalled();
    });
  });
});
`````

## File: backend/src/display-preferences/display-preferences.service.ts
`````typescript
import { BadRequestException, Injectable } from "@nestjs/common";
import { DisplayNameMode, type DisplayPreference, Prisma } from "@prisma/client";

import { PrismaService } from "../prisma/prisma.service";

import type {
  DisplayPreferenceView,
  LabelOverrideMap,
  PersonalizedMasterRecord,
} from "./display-preferences.types";
import { LabelOverrideDto, UpdateDisplayPreferenceDto } from "./dto/update-display-preference.dto";

type MasterDataDomain = "breed" | "coatColor";
interface MasterRecord {
  code: number;
  name: string;
}

@Injectable()
export class DisplayPreferencesService {
  constructor(private readonly prisma: PrismaService) {}

  async getPreferences(userId: string): Promise<DisplayPreferenceView> {
    const preference = await this.prisma.displayPreference.findUnique({
      where: { userId },
    });

    return preference ? this.toView(preference) : this.buildDefaultView(userId);
  }

  async upsertPreferences(
    userId: string,
    dto: UpdateDisplayPreferenceDto,
  ): Promise<DisplayPreferenceView> {
    const breedOverrides = await this.normalizeOverrides(
      dto.breedLabelOverrides,
      "breed",
    );
    const coatColorOverrides = await this.normalizeOverrides(
      dto.coatColorLabelOverrides,
      "coatColor",
    );

    const createData: Prisma.DisplayPreferenceCreateInput = {
      user: {
        connect: { id: userId },
      },
      breedNameMode: dto.breedNameMode ?? DisplayNameMode.CANONICAL,
      coatColorNameMode: dto.coatColorNameMode ?? DisplayNameMode.CANONICAL,
      breedNameOverrides: this.serializeOverrides(breedOverrides),
      coatColorNameOverrides: this.serializeOverrides(coatColorOverrides),
    };

    const updateData: Prisma.DisplayPreferenceUpdateInput = {};
    if (dto.breedNameMode) {
      updateData.breedNameMode = dto.breedNameMode;
    }
    if (dto.coatColorNameMode) {
      updateData.coatColorNameMode = dto.coatColorNameMode;
    }
    if (dto.breedLabelOverrides !== undefined) {
      updateData.breedNameOverrides = this.serializeOverrides(breedOverrides);
    }
    if (dto.coatColorLabelOverrides !== undefined) {
      updateData.coatColorNameOverrides = this.serializeOverrides(
        coatColorOverrides,
      );
    }

    const result = await this.prisma.displayPreference.upsert({
      where: { userId },
      create: createData,
      update: updateData,
    });

    return this.toView(result);
  }

  async buildPersonalizedBreedRecords(
    preference: DisplayPreferenceView,
  ): Promise<PersonalizedMasterRecord[]> {
    const records = await this.fetchMasterRecords("breed");
    return this.buildPersonalizedRecords(
      records,
      preference.breedNameMode,
      preference.breedLabelOverrides,
    );
  }

  async buildPersonalizedCoatColorRecords(
    preference: DisplayPreferenceView,
  ): Promise<PersonalizedMasterRecord[]> {
    const records = await this.fetchMasterRecords("coatColor");
    return this.buildPersonalizedRecords(
      records,
      preference.coatColorNameMode,
      preference.coatColorLabelOverrides,
    );
  }

  private buildPersonalizedRecords(
    sourceRecords: ReadonlyArray<MasterRecord>,
    displayMode: DisplayNameMode,
    overrides: LabelOverrideMap,
  ): PersonalizedMasterRecord[] {
    const records: PersonalizedMasterRecord[] = [];
    sourceRecords.forEach((record) => {
      const displayName = this.resolveDisplayName(
        record,
        displayMode,
        overrides,
      );
      records.push({
        code: record.code,
        canonicalName: record.name,
        displayName,
        displayNameMode: displayMode,
        isOverridden: overrides[record.code] !== undefined,
      });
    });

    return records;
  }

  private resolveDisplayName(
    record: { code: number; name: string },
    mode: DisplayNameMode,
    overrides: LabelOverrideMap,
  ): string {
    if (mode === DisplayNameMode.CUSTOM) {
      const override = overrides[record.code];
      if (override) {
        return override;
      }
    }

    if (mode === DisplayNameMode.CODE_AND_NAME) {
      const label = record.name ? `${record.code} - ${record.name}` : `${record.code}`;
      return label;
    }

    return record.name || `${record.code}`;
  }

  private serializeOverrides(
    map: LabelOverrideMap,
  ): Prisma.NullableJsonNullValueInput | Prisma.InputJsonValue {
    const entries = Object.entries(map);
    if (entries.length === 0) {
      return Prisma.JsonNull;
    }

    return entries.reduce<Prisma.JsonObject>((acc, [code, label]) => {
      acc[code] = label;
      return acc;
    }, {});
  }

  private async normalizeOverrides(
    overrides: LabelOverrideDto[] | undefined,
    domain: MasterDataDomain,
  ): Promise<LabelOverrideMap> {
    if (!overrides || overrides.length === 0) {
      return {};
    }

    const sourceMap = await this.buildMasterRecordMap(domain);

    return overrides.reduce<LabelOverrideMap>((acc, item) => {
      const label = item.label.trim();
      if (!label) {
        return acc;
      }

      if (!sourceMap.has(item.code)) {
        throw new BadRequestException(`å­˜åœ¨ã—ãªã„${domain === "breed" ? "å“ç¨®" : "æ¯›è‰²"}ã‚³ãƒ¼ãƒ‰: ${item.code}`);
      }

      acc[item.code] = label;
      return acc;
    }, {});
  }

  private buildDefaultView(userId: string): DisplayPreferenceView {
    return {
      userId,
      breedNameMode: DisplayNameMode.CANONICAL,
      coatColorNameMode: DisplayNameMode.CANONICAL,
      breedLabelOverrides: {},
      coatColorLabelOverrides: {},
      updatedAt: new Date(0),
      createdAt: undefined,
    };
  }

  private async fetchMasterRecords(domain: MasterDataDomain): Promise<ReadonlyArray<MasterRecord>> {
    if (domain === "breed") {
      return this.prisma.breed.findMany({
        select: { code: true, name: true },
        where: { isActive: true },
        orderBy: { code: "asc" },
      });
    }

    return this.prisma.coatColor.findMany({
      select: { code: true, name: true },
      where: { isActive: true },
      orderBy: { code: "asc" },
    });
  }

  private async buildMasterRecordMap(domain: MasterDataDomain): Promise<Map<number, string>> {
    const records = await this.fetchMasterRecords(domain);
    return records.reduce<Map<number, string>>((acc, record) => {
      acc.set(record.code, record.name ?? "");
      return acc;
    }, new Map());
  }

  private toView(entity: DisplayPreference): DisplayPreferenceView {
    return {
      userId: entity.userId,
      breedNameMode: entity.breedNameMode,
      coatColorNameMode: entity.coatColorNameMode,
      breedLabelOverrides: this.parseOverrideMap(entity.breedNameOverrides),
      coatColorLabelOverrides: this.parseOverrideMap(entity.coatColorNameOverrides),
      updatedAt: entity.updatedAt,
      createdAt: entity.createdAt,
    };
  }

  private parseOverrideMap(value: Prisma.JsonValue | null): LabelOverrideMap {
    if (!value || typeof value !== "object" || Array.isArray(value)) {
      return {};
    }

    return Object.entries(value).reduce<LabelOverrideMap>((acc, [code, label]) => {
      if (typeof label === "string" && label.trim()) {
        const numericCode = Number(code);
        if (!Number.isNaN(numericCode)) {
          acc[numericCode] = label;
        }
      }
      return acc;
    }, {});
  }
}
`````

## File: backend/src/display-preferences/display-preferences.types.ts
`````typescript
import type { DisplayNameMode } from "@prisma/client";

export type LabelOverrideMap = Record<number, string>;

export interface DisplayPreferenceView {
  userId: string;
  breedNameMode: DisplayNameMode;
  coatColorNameMode: DisplayNameMode;
  breedLabelOverrides: LabelOverrideMap;
  coatColorLabelOverrides: LabelOverrideMap;
  updatedAt: Date;
  createdAt?: Date;
}

export interface PersonalizedMasterRecord {
  code: number;
  canonicalName: string;
  displayName: string;
  displayNameMode: DisplayNameMode;
  isOverridden: boolean;
}
`````

## File: backend/src/email/email.module.ts
`````typescript
import { Module } from '@nestjs/common';

import { EmailService } from './email.service';

/**
 * ãƒ¡ãƒ¼ãƒ«é€ä¿¡æ©Ÿèƒ½ã‚’æä¾›ã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
 * Resend APIã‚’ä½¿ç”¨ã—ã¦ãƒ¡ãƒ¼ãƒ«é€ä¿¡ã‚’å®Ÿè¡Œ
 */
@Module({
  providers: [EmailService],
  exports: [EmailService], // ä»–ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ä½¿ç”¨å¯èƒ½ã«ã™ã‚‹
})
export class EmailModule {}
`````

## File: backend/src/email/email.service.spec.ts
`````typescript
import { ConfigService } from '@nestjs/config';
import { Test, TestingModule } from '@nestjs/testing';

import { EmailService } from './email.service';

describe('EmailService', () => {
  let service: EmailService;
  let mockResendSend: jest.Mock;

  // Resendã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ¢ãƒƒã‚¯
  const mockResendInstance = {
    emails: {
      send: jest.fn(),
    },
  };

  const mockConfigServiceEnabled = {
    get: jest.fn((key: string, defaultValue?: string) => {
      const config: Record<string, string> = {
        RESEND_API_KEY: 're_test_api_key',
        EMAIL_FROM: 'test@example.com',
        EMAIL_FROM_NAME: 'Test Sender',
        FRONTEND_URL: 'https://test.example.com',
      };
      return config[key] || defaultValue;
    }),
  };

  const mockConfigServiceDisabled = {
    get: jest.fn((key: string, defaultValue?: string) => {
      const config: Record<string, string> = {
        EMAIL_FROM: 'test@example.com',
        EMAIL_FROM_NAME: 'Test Sender',
        FRONTEND_URL: 'https://test.example.com',
      };
      return config[key] || defaultValue;
    }),
  };

  describe('when email is enabled', () => {
    beforeEach(async () => {
      // Resendã®ãƒ¢ãƒƒã‚¯ã‚’ãƒªã‚»ãƒƒãƒˆ
      mockResendInstance.emails.send = jest.fn();
      mockResendSend = mockResendInstance.emails.send;

      const module: TestingModule = await Test.createTestingModule({
        providers: [
          EmailService,
          {
            provide: ConfigService,
            useValue: mockConfigServiceEnabled,
          },
        ],
      }).compile();

      service = module.get<EmailService>(EmailService);

      // ã‚µãƒ¼ãƒ“ã‚¹å†…éƒ¨ã®resendã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç½®ãæ›ãˆ
      (service as unknown as { resend: typeof mockResendInstance }).resend = mockResendInstance;
    });

    afterEach(() => {
      jest.clearAllMocks();
    });

    it('should be defined', () => {
      expect(service).toBeDefined();
    });

    describe('sendEmail', () => {
      it('ãƒ¡ãƒ¼ãƒ«é€ä¿¡ãŒæˆåŠŸã™ã‚‹ã“ã¨', async () => {
        mockResendSend.mockResolvedValue({
          data: { id: 'test-message-id' },
          error: null,
        });

        const result = await service.sendEmail({
          to: 'recipient@example.com',
          subject: 'ãƒ†ã‚¹ãƒˆãƒ¡ãƒ¼ãƒ«',
          html: '<p>ãƒ†ã‚¹ãƒˆæœ¬æ–‡</p>',
        });

        expect(result.success).toBe(true);
        expect(result.messageId).toBe('test-message-id');
        expect(mockResendSend).toHaveBeenCalledWith(
          expect.objectContaining({
            from: 'Test Sender <test@example.com>',
            to: 'recipient@example.com',
            subject: 'ãƒ†ã‚¹ãƒˆãƒ¡ãƒ¼ãƒ«',
            html: '<p>ãƒ†ã‚¹ãƒˆæœ¬æ–‡</p>',
          })
        );
      });

      it('Resend APIãŒã‚¨ãƒ©ãƒ¼ã‚’è¿”ã—ãŸå ´åˆã€å¤±æ•—ã‚’è¿”ã™ã“ã¨', async () => {
        mockResendSend.mockResolvedValue({
          data: null,
          error: { message: 'API Error' },
        });

        const result = await service.sendEmail({
          to: 'recipient@example.com',
          subject: 'ãƒ†ã‚¹ãƒˆãƒ¡ãƒ¼ãƒ«',
          text: 'ãƒ†ã‚¹ãƒˆæœ¬æ–‡',
        });

        expect(result.success).toBe(false);
        expect(result.messageId).toBeUndefined();
      });

      it('ä¾‹å¤–ãŒç™ºç”Ÿã—ãŸå ´åˆã€å¤±æ•—ã‚’è¿”ã™ã“ã¨', async () => {
        mockResendSend.mockRejectedValue(new Error('Network error'));

        const result = await service.sendEmail({
          to: 'recipient@example.com',
          subject: 'ãƒ†ã‚¹ãƒˆãƒ¡ãƒ¼ãƒ«',
          text: 'ãƒ†ã‚¹ãƒˆæœ¬æ–‡',
        });

        expect(result.success).toBe(false);
      });

      it('replyToã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒæ­£ã—ãè¨­å®šã•ã‚Œã‚‹ã“ã¨', async () => {
        mockResendSend.mockResolvedValue({
          data: { id: 'test-id' },
          error: null,
        });

        await service.sendEmail({
          to: 'recipient@example.com',
          subject: 'ãƒ†ã‚¹ãƒˆ',
          text: 'ãƒ†ã‚¹ãƒˆ',
          replyTo: 'reply@example.com',
        });

        expect(mockResendSend).toHaveBeenCalledWith(
          expect.objectContaining({
            replyTo: 'reply@example.com',
          })
        );
      });

      it('è¤‡æ•°ã®å®›å…ˆã«é€ä¿¡ã§ãã‚‹ã“ã¨', async () => {
        mockResendSend.mockResolvedValue({
          data: { id: 'test-id' },
          error: null,
        });

        await service.sendEmail({
          to: ['user1@example.com', 'user2@example.com'],
          subject: 'ãƒ†ã‚¹ãƒˆ',
          text: 'ãƒ†ã‚¹ãƒˆ',
        });

        expect(mockResendSend).toHaveBeenCalledWith(
          expect.objectContaining({
            to: ['user1@example.com', 'user2@example.com'],
          })
        );
      });
    });

    describe('sendPasswordResetEmail', () => {
      it('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆãƒ¡ãƒ¼ãƒ«ãŒæ­£ã—ã„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§é€ä¿¡ã•ã‚Œã‚‹ã“ã¨', async () => {
        mockResendSend.mockResolvedValue({
          data: { id: 'reset-message-id' },
          error: null,
        });

        const result = await service.sendPasswordResetEmail(
          'user@example.com',
          'test-reset-token'
        );

        expect(result).toBe(true);
        expect(mockResendSend).toHaveBeenCalledWith(
          expect.objectContaining({
            to: 'user@example.com',
            subject: 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆã®ã”æ¡ˆå†…',
          })
        );

        // URLã«ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰URLã¨ãƒˆãƒ¼ã‚¯ãƒ³ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
        const callArgs = mockResendSend.mock.calls[0][0];
        expect(callArgs.html).toContain('https://test.example.com/reset-password?token=test-reset-token');
        expect(callArgs.text).toContain('https://test.example.com/reset-password?token=test-reset-token');
      });

      it('ãƒ¡ãƒ¼ãƒ«é€ä¿¡ãŒå¤±æ•—ã—ãŸå ´åˆã€falseã‚’è¿”ã™ã“ã¨', async () => {
        mockResendSend.mockResolvedValue({
          data: null,
          error: { message: 'Failed' },
        });

        const result = await service.sendPasswordResetEmail(
          'user@example.com',
          'test-token'
        );

        expect(result).toBe(false);
      });
    });

    describe('sendWelcomeEmail', () => {
      it('ã‚¦ã‚§ãƒ«ã‚«ãƒ ãƒ¡ãƒ¼ãƒ«ãŒæ­£ã—ã„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§é€ä¿¡ã•ã‚Œã‚‹ã“ã¨', async () => {
        mockResendSend.mockResolvedValue({
          data: { id: 'welcome-message-id' },
          error: null,
        });

        const result = await service.sendWelcomeEmail(
          'newuser@example.com',
          'ãƒ†ã‚¹ãƒˆãƒ¦ãƒ¼ã‚¶ãƒ¼'
        );

        expect(result).toBe(true);
        expect(mockResendSend).toHaveBeenCalledWith(
          expect.objectContaining({
            to: 'newuser@example.com',
            subject: 'MyCats Pro ã¸ã‚ˆã†ã“ã!',
          })
        );

        // HTMLã«ãƒ¦ãƒ¼ã‚¶ãƒ¼åã¨ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰URLãŒå«ã¾ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
        const callArgs = mockResendSend.mock.calls[0][0];
        expect(callArgs.html).toContain('ãƒ†ã‚¹ãƒˆãƒ¦ãƒ¼ã‚¶ãƒ¼');
        expect(callArgs.html).toContain('https://test.example.com/cats/new');
        expect(callArgs.html).toContain('https://test.example.com');
      });

      it('ãƒ¡ãƒ¼ãƒ«é€ä¿¡ãŒå¤±æ•—ã—ãŸå ´åˆã€falseã‚’è¿”ã™ã“ã¨', async () => {
        mockResendSend.mockResolvedValue({
          data: null,
          error: { message: 'Failed' },
        });

        const result = await service.sendWelcomeEmail(
          'user@example.com',
          'ãƒ¦ãƒ¼ã‚¶ãƒ¼'
        );

        expect(result).toBe(false);
      });
    });

    describe('sendCatRegistrationEmail', () => {
      it('çŒ«ç™»éŒ²ç¢ºèªãƒ¡ãƒ¼ãƒ«ãŒæ­£ã—ã„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§é€ä¿¡ã•ã‚Œã‚‹ã“ã¨', async () => {
        mockResendSend.mockResolvedValue({
          data: { id: 'cat-reg-message-id' },
          error: null,
        });

        const result = await service.sendCatRegistrationEmail(
          'owner@example.com',
          'ã‚¿ãƒ',
          'CAT-12345'
        );

        expect(result).toBe(true);
        expect(mockResendSend).toHaveBeenCalledWith(
          expect.objectContaining({
            to: 'owner@example.com',
            subject: 'ã€ç™»éŒ²å®Œäº†ã€‘ã‚¿ãƒ ã®ç™»éŒ²ãŒå®Œäº†ã—ã¾ã—ãŸ',
          })
        );

        // HTMLã«çŒ«ã®åå‰ã€ç™»éŒ²ç•ªå·ã€ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰URLãŒå«ã¾ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
        const callArgs = mockResendSend.mock.calls[0][0];
        expect(callArgs.html).toContain('ã‚¿ãƒ');
        expect(callArgs.html).toContain('CAT-12345');
        expect(callArgs.html).toContain('https://test.example.com/cats/CAT-12345');
        expect(callArgs.html).toContain('https://test.example.com');
      });

      it('ãƒ¡ãƒ¼ãƒ«é€ä¿¡ãŒå¤±æ•—ã—ãŸå ´åˆã€falseã‚’è¿”ã™ã“ã¨', async () => {
        mockResendSend.mockResolvedValue({
          data: null,
          error: { message: 'Failed' },
        });

        const result = await service.sendCatRegistrationEmail(
          'owner@example.com',
          'ã‚¿ãƒ',
          'CAT-12345'
        );

        expect(result).toBe(false);
      });
    });
  });

  describe('when email is disabled', () => {
    beforeEach(async () => {
      const module: TestingModule = await Test.createTestingModule({
        providers: [
          EmailService,
          {
            provide: ConfigService,
            useValue: mockConfigServiceDisabled,
          },
        ],
      }).compile();

      service = module.get<EmailService>(EmailService);
    });

    it('should be defined', () => {
      expect(service).toBeDefined();
    });

    it('isEnabled ãŒ false ã®å ´åˆã€ãƒ¡ãƒ¼ãƒ«é€ä¿¡ãŒã‚¹ã‚­ãƒƒãƒ—ã•ã‚Œã‚‹ã“ã¨', async () => {
      const result = await service.sendEmail({
        to: 'recipient@example.com',
        subject: 'ãƒ†ã‚¹ãƒˆ',
        text: 'ãƒ†ã‚¹ãƒˆ',
      });

      expect(result.success).toBe(false);
      expect(result.messageId).toBeUndefined();
    });

    it('sendPasswordResetEmail ãŒ false ã‚’è¿”ã™ã“ã¨', async () => {
      const result = await service.sendPasswordResetEmail(
        'user@example.com',
        'token'
      );

      expect(result).toBe(false);
    });

    it('sendWelcomeEmail ãŒ false ã‚’è¿”ã™ã“ã¨', async () => {
      const result = await service.sendWelcomeEmail(
        'user@example.com',
        'ãƒ¦ãƒ¼ã‚¶ãƒ¼'
      );

      expect(result).toBe(false);
    });

    it('sendCatRegistrationEmail ãŒ false ã‚’è¿”ã™ã“ã¨', async () => {
      const result = await service.sendCatRegistrationEmail(
        'owner@example.com',
        'ã‚¿ãƒ',
        'CAT-123'
      );

      expect(result).toBe(false);
    });
  });
});
`````

## File: backend/src/email/email.service.ts
`````typescript
import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { Resend } from 'resend';

/**
 * ãƒ¡ãƒ¼ãƒ«é€ä¿¡DTO
 */
export interface SendEmailDto {
  to: string | string[];
  subject: string;
  html?: string;
  text?: string;
  replyTo?: string;
}

/**
 * ãƒ¡ãƒ¼ãƒ«é€ä¿¡ã‚µãƒ¼ãƒ“ã‚¹
 * Resend APIã‚’ä½¿ç”¨ã—ã¦ãƒ¡ãƒ¼ãƒ«ã‚’é€ä¿¡
 */
@Injectable()
export class EmailService {
  private readonly logger = new Logger(EmailService.name);
  private readonly resend: Resend | null;
  private readonly from: string;
  private readonly fromName: string;
  private readonly frontendUrl: string;
  private readonly isEnabled: boolean;

  constructor(private readonly configService: ConfigService) {
    const apiKey = this.configService.get<string>('RESEND_API_KEY');
    this.from = this.configService.get<string>('EMAIL_FROM', 'noreply@nekoya.co.jp');
    this.fromName = this.configService.get<string>('EMAIL_FROM_NAME', 'MyCats Pro');
    this.frontendUrl = this.configService.get<string>('FRONTEND_URL', 'https://nekoya.co.jp');

    if (apiKey) {
      this.resend = new Resend(apiKey);
      this.isEnabled = true;
      this.logger.log(`EmailService initialized with from: ${this.fromName} <${this.from}>`);
    } else {
      this.resend = null;
      this.isEnabled = false;
      this.logger.warn('RESEND_API_KEY not set. Email sending is disabled.');
    }
  }

  /**
   * ãƒ¡ãƒ¼ãƒ«ã‚’é€ä¿¡
   */
  async sendEmail(dto: SendEmailDto): Promise<{ success: boolean; messageId?: string }> {
    if (!this.isEnabled || !this.resend) {
      this.logger.warn('Email sending is disabled. Skipping.');
      return { success: false };
    }

    try {
      const emailOptions = {
        from: `${this.fromName} <${this.from}>`,
        to: dto.to,
        subject: dto.subject,
        ...(dto.html && { html: dto.html }),
        ...(dto.text && { text: dto.text }),
        ...(dto.replyTo && { replyTo: dto.replyTo }),
      } as Parameters<Resend['emails']['send']>[0];

      const response = await this.resend.emails.send(emailOptions);

      if (response.error) {
        this.logger.error(`Failed to send email: ${response.error.message}`);
        return { success: false };
      }

      this.logger.log(`Email sent successfully: ${response.data?.id}`);
      return { success: true, messageId: response.data?.id };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger.error(`Error sending email: ${errorMessage}`);
      return { success: false };
    }
  }

  /**
   * ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆãƒ¡ãƒ¼ãƒ«ã‚’é€ä¿¡
   */
  async sendPasswordResetEmail(email: string, resetToken: string): Promise<boolean> {
    const resetUrl = `${this.frontendUrl}/reset-password?token=${resetToken}`;

    const html = `
      <!DOCTYPE html>
      <html lang="ja">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆ</title>
      </head>
      <body style="font-family: sans-serif; line-height: 1.6; color: #333;">
        <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
          <h2>ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆ</h2>
          <p>ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å—ã‘ä»˜ã‘ã¾ã—ãŸã€‚</p>
          <p>ä»¥ä¸‹ã®ãƒªãƒ³ã‚¯ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã€æ–°ã—ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’è¨­å®šã—ã¦ãã ã•ã„:</p>
          <p>
            <a href="${resetUrl}" style="display: inline-block; background-color: #007bff; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px;">
              ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆ
            </a>
          </p>
          <p>ã¾ãŸã¯ã€ä»¥ä¸‹ã®URLã‚’ãƒ–ãƒ©ã‚¦ã‚¶ã«ã‚³ãƒ”ãƒ¼&ãƒšãƒ¼ã‚¹ãƒˆã—ã¦ãã ã•ã„:</p>
          <p style="word-break: break-all; color: #007bff;">${resetUrl}</p>
          <p><strong>ã“ã®ãƒªãƒ³ã‚¯ã¯1æ™‚é–“å¾Œã«ç„¡åŠ¹ã«ãªã‚Šã¾ã™ã€‚</strong></p>
          <p>ã“ã®ãƒ¡ãƒ¼ãƒ«ã«å¿ƒå½“ãŸã‚ŠãŒãªã„å ´åˆã¯ã€ç„¡è¦–ã—ã¦ãã ã•ã„ã€‚</p>
          <hr style="margin: 30px 0; border: none; border-top: 1px solid #eee;">
          <p style="font-size: 12px; color: #999;">
            ã“ã®ãƒ¡ãƒ¼ãƒ«ã¯ MyCats Pro ã‹ã‚‰è‡ªå‹•é€ä¿¡ã•ã‚Œã¦ã„ã¾ã™ã€‚<br>
            è¿”ä¿¡ã¯ã§ãã¾ã›ã‚“ã®ã§ã”äº†æ‰¿ãã ã•ã„ã€‚
          </p>
        </div>
      </body>
      </html>
    `;

    const text = `
ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆ

ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å—ã‘ä»˜ã‘ã¾ã—ãŸã€‚
ä»¥ä¸‹ã®URLã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ã€æ–°ã—ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’è¨­å®šã—ã¦ãã ã•ã„:

${resetUrl}

ã“ã®ãƒªãƒ³ã‚¯ã¯1æ™‚é–“å¾Œã«ç„¡åŠ¹ã«ãªã‚Šã¾ã™ã€‚

ã“ã®ãƒ¡ãƒ¼ãƒ«ã«å¿ƒå½“ãŸã‚ŠãŒãªã„å ´åˆã¯ã€ç„¡è¦–ã—ã¦ãã ã•ã„ã€‚
    `;

    const result = await this.sendEmail({
      to: email,
      subject: 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆã®ã”æ¡ˆå†…',
      html,
      text,
    });

    return result.success;
  }

  /**
   * ã‚¦ã‚§ãƒ«ã‚«ãƒ ãƒ¡ãƒ¼ãƒ«ã‚’é€ä¿¡
   */
  async sendWelcomeEmail(email: string, username: string): Promise<boolean> {
    const html = `
      <!DOCTYPE html>
      <html lang="ja">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>ã‚ˆã†ã“ã MyCats Pro ã¸</title>
      </head>
      <body style="font-family: sans-serif; line-height: 1.6; color: #333;">
        <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
          <h2>ã‚ˆã†ã“ãã€${username} ã•ã‚“!</h2>
          <p>MyCats Pro ã¸ã®ã”ç™»éŒ²ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚</p>
          <p>ã•ã£ããã€ã‚ãªãŸã®çŒ«ã¡ã‚ƒã‚“ãŸã¡ã‚’ç™»éŒ²ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚</p>
          <p>
            <a href="${this.frontendUrl}/cats/new" style="display: inline-block; background-color: #28a745; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px;">
              çŒ«ã‚’ç™»éŒ²ã™ã‚‹
            </a>
          </p>
          <p>ã”ä¸æ˜ãªç‚¹ãŒã”ã–ã„ã¾ã—ãŸã‚‰ã€ãŠæ°—è»½ã«ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚</p>
          <hr style="margin: 30px 0; border: none; border-top: 1px solid #eee;">
          <p style="font-size: 12px; color: #999;">
            MyCats Pro - çŒ«ç”Ÿä½“ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ <br>
            ${this.frontendUrl}
          </p>
        </div>
      </body>
      </html>
    `;

    const result = await this.sendEmail({
      to: email,
      subject: 'MyCats Pro ã¸ã‚ˆã†ã“ã!',
      html,
    });

    return result.success;
  }

  /**
   * çŒ«ã®ç™»éŒ²ç¢ºèªãƒ¡ãƒ¼ãƒ«ã‚’é€ä¿¡
   */
  async sendCatRegistrationEmail(email: string, catName: string, registrationNumber: string): Promise<boolean> {
    const html = `
      <!DOCTYPE html>
      <html lang="ja">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>çŒ«ã®ç™»éŒ²å®Œäº†</title>
      </head>
      <body style="font-family: sans-serif; line-height: 1.6; color: #333;">
        <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
          <h2>çŒ«ã®ç™»éŒ²ãŒå®Œäº†ã—ã¾ã—ãŸ</h2>
          <p><strong>${catName}</strong> ã®ç™»éŒ²ãŒå®Œäº†ã—ã¾ã—ãŸã€‚</p>
          <div style="background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin: 20px 0;">
            <p style="margin: 5px 0;"><strong>çŒ«ã®åå‰:</strong> ${catName}</p>
            <p style="margin: 5px 0;"><strong>ç™»éŒ²ç•ªå·:</strong> ${registrationNumber}</p>
          </div>
          <p>
            <a href="${this.frontendUrl}/cats/${registrationNumber}" style="display: inline-block; background-color: #007bff; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px;">
              è©³ç´°ã‚’è¦‹ã‚‹
            </a>
          </p>
          <hr style="margin: 30px 0; border: none; border-top: 1px solid #eee;">
          <p style="font-size: 12px; color: #999;">
            MyCats Pro - çŒ«ç”Ÿä½“ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ <br>
            ${this.frontendUrl}
          </p>
        </div>
      </body>
      </html>
    `;

    const result = await this.sendEmail({
      to: email,
      subject: `ã€ç™»éŒ²å®Œäº†ã€‘${catName} ã®ç™»éŒ²ãŒå®Œäº†ã—ã¾ã—ãŸ`,
      html,
    });

    return result.success;
  }

  /**
   * ãƒ¦ãƒ¼ã‚¶ãƒ¼æ‹›å¾…ãƒ¡ãƒ¼ãƒ«ã‚’é€ä¿¡
   * 
   * @param email æ‹›å¾…å…ˆãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹
   * @param invitationToken æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³
   * @param tenantName ãƒ†ãƒŠãƒ³ãƒˆå
   * @param role æ‹›å¾…ã•ã‚Œã‚‹ãƒ­ãƒ¼ãƒ«
   * @returns é€ä¿¡æˆåŠŸ/å¤±æ•—
   */
  async sendInvitationEmail(
    email: string,
    invitationToken: string,
    tenantName: string,
    role: string,
  ): Promise<boolean> {
    // æœ¬ç•ªç’°å¢ƒã®URLã‚’ä½¿ç”¨
    const baseUrl = this.configService.get<string>('FRONTEND_URL', 'https://nekoya.co.jp');
    const invitationUrl = `${baseUrl}/accept-invitation?token=${invitationToken}`;

    const roleLabel = this.getRoleLabel(role);

    const html = `
      <!DOCTYPE html>
      <html lang="ja">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>MyCats Pro ã¸ã®æ‹›å¾…</title>
      </head>
      <body style="font-family: sans-serif; line-height: 1.6; color: #333;">
        <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
          <h2>MyCats Pro ã¸ã®æ‹›å¾…</h2>
          <p>ã‚ãªãŸã¯ <strong>${tenantName}</strong> ã®${roleLabel}ã¨ã—ã¦æ‹›å¾…ã•ã‚Œã¾ã—ãŸã€‚</p>
          <p>ä»¥ä¸‹ã®ãƒªãƒ³ã‚¯ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã€ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ä½œæˆã—ã¦ãã ã•ã„:</p>
          <p>
            <a href="${invitationUrl}" style="display: inline-block; background-color: #007bff; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px;">
              æ‹›å¾…ã‚’å—ã‘å…¥ã‚Œã‚‹
            </a>
          </p>
          <p>ã¾ãŸã¯ã€ä»¥ä¸‹ã®URLã‚’ãƒ–ãƒ©ã‚¦ã‚¶ã«ã‚³ãƒ”ãƒ¼&ãƒšãƒ¼ã‚¹ãƒˆã—ã¦ãã ã•ã„:</p>
          <p style="word-break: break-all; color: #007bff;">${invitationUrl}</p>
          <p><strong>ã“ã®æ‹›å¾…ãƒªãƒ³ã‚¯ã¯7æ—¥é–“æœ‰åŠ¹ã§ã™ã€‚</strong></p>
          <p>ã“ã®ãƒ¡ãƒ¼ãƒ«ã«å¿ƒå½“ãŸã‚ŠãŒãªã„å ´åˆã¯ã€ç„¡è¦–ã—ã¦ãã ã•ã„ã€‚</p>
          <hr style="margin: 30px 0; border: none; border-top: 1px solid #eee;">
          <p style="font-size: 12px; color: #999;">
            ã“ã®ãƒ¡ãƒ¼ãƒ«ã¯ MyCats Pro ã‹ã‚‰è‡ªå‹•é€ä¿¡ã•ã‚Œã¦ã„ã¾ã™ã€‚<br>
            è¿”ä¿¡ã¯ã§ãã¾ã›ã‚“ã®ã§ã”äº†æ‰¿ãã ã•ã„ã€‚
          </p>
        </div>
      </body>
      </html>
    `;

    const text = `
MyCats Pro ã¸ã®æ‹›å¾…

ã‚ãªãŸã¯ ${tenantName} ã®${roleLabel}ã¨ã—ã¦æ‹›å¾…ã•ã‚Œã¾ã—ãŸã€‚

ä»¥ä¸‹ã®URLã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ã€ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ä½œæˆã—ã¦ãã ã•ã„:

${invitationUrl}

ã“ã®æ‹›å¾…ãƒªãƒ³ã‚¯ã¯7æ—¥é–“æœ‰åŠ¹ã§ã™ã€‚

ã“ã®ãƒ¡ãƒ¼ãƒ«ã«å¿ƒå½“ãŸã‚ŠãŒãªã„å ´åˆã¯ã€ç„¡è¦–ã—ã¦ãã ã•ã„ã€‚
    `;

    const result = await this.sendEmail({
      to: email,
      subject: `ã€æ‹›å¾…ã€‘${tenantName} ã¸ã®å‚åŠ ã®ã”æ¡ˆå†…`,
      html,
      text,
    });

    return result.success;
  }

  /**
   * ãƒ­ãƒ¼ãƒ«ã‚’æ—¥æœ¬èªãƒ©ãƒ™ãƒ«ã«å¤‰æ›
   */
  private getRoleLabel(role: string): string {
    const roleLabels: Record<string, string> = {
      SUPER_ADMIN: 'ã‚¹ãƒ¼ãƒ‘ãƒ¼ç®¡ç†è€…',
      TENANT_ADMIN: 'ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†è€…',
      ADMIN: 'ç®¡ç†è€…',
      USER: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼',
    };
    return roleLabels[role] ?? role;
  }
}
`````

## File: backend/src/gallery/dto/add-media.dto.ts
`````typescript
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsString, IsOptional, IsEnum } from 'class-validator';

import { MediaTypeDto } from './create-gallery-entry.dto';

/**
 * ãƒ¡ãƒ‡ã‚£ã‚¢è¿½åŠ  DTO
 */
export class AddMediaDto {
  @ApiProperty({ enum: MediaTypeDto, description: 'ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¿ã‚¤ãƒ—' })
  @IsEnum(MediaTypeDto)
  type: MediaTypeDto;

  @ApiProperty({ description: 'ãƒ¡ãƒ‡ã‚£ã‚¢URL' })
  @IsString()
  url: string;

  @ApiPropertyOptional({ description: 'ã‚µãƒ ãƒã‚¤ãƒ«URLï¼ˆYouTubeç”¨ï¼‰' })
  @IsOptional()
  @IsString()
  thumbnailUrl?: string;
}
`````

## File: backend/src/gallery/dto/create-gallery-entry.dto.ts
`````typescript
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import {
  IsString,
  IsOptional,
  IsEnum,
  IsUUID,
  IsDateString,
  IsArray,
  ValidateNested,
} from 'class-validator';

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚«ãƒ†ã‚´ãƒª
 */
export enum GalleryCategoryDto {
  KITTEN = 'KITTEN',
  FATHER = 'FATHER',
  MOTHER = 'MOTHER',
  GRADUATION = 'GRADUATION',
}

/**
 * ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¿ã‚¤ãƒ—
 */
export enum MediaTypeDto {
  IMAGE = 'IMAGE',
  YOUTUBE = 'YOUTUBE',
}

/**
 * ãƒ¡ãƒ‡ã‚£ã‚¢ä½œæˆ DTO
 */
export class CreateMediaDto {
  @ApiProperty({ enum: MediaTypeDto, description: 'ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¿ã‚¤ãƒ—' })
  @IsEnum(MediaTypeDto)
  type: MediaTypeDto;

  @ApiProperty({ description: 'ãƒ¡ãƒ‡ã‚£ã‚¢URL' })
  @IsString()
  url: string;

  @ApiPropertyOptional({ description: 'ã‚µãƒ ãƒã‚¤ãƒ«URLï¼ˆYouTubeç”¨ï¼‰' })
  @IsOptional()
  @IsString()
  thumbnailUrl?: string;

  @ApiPropertyOptional({ description: 'è¡¨ç¤ºé †åº' })
  @IsOptional()
  order?: number;
}

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªä½œæˆ DTO
 */
export class CreateGalleryEntryDto {
  @ApiProperty({ enum: GalleryCategoryDto, description: 'ã‚«ãƒ†ã‚´ãƒª' })
  @IsEnum(GalleryCategoryDto)
  category: GalleryCategoryDto;

  @ApiProperty({ description: 'çŒ«ã®åå‰' })
  @IsString()
  name: string;

  @ApiProperty({
    description: 'æ€§åˆ¥',
    enum: ['MALE', 'FEMALE', 'NEUTER', 'SPAY'],
  })
  @IsEnum(['MALE', 'FEMALE', 'NEUTER', 'SPAY'])
  gender: string;

  @ApiPropertyOptional({ description: 'æ¯›è‰²' })
  @IsOptional()
  @IsString()
  coatColor?: string;

  @ApiPropertyOptional({ description: 'å“ç¨®' })
  @IsOptional()
  @IsString()
  breed?: string;

  @ApiPropertyOptional({ description: 'åœ¨èˆçŒ«IDï¼ˆå‚ç…§ç”¨ï¼‰' })
  @IsOptional()
  @IsUUID()
  catId?: string;

  @ApiPropertyOptional({ description: 'è­²æ¸¡æ—¥ï¼ˆå’æ¥­çŒ«ç”¨ï¼‰' })
  @IsOptional()
  @IsDateString()
  transferDate?: string;

  @ApiPropertyOptional({ description: 'è­²æ¸¡å…ˆï¼ˆå’æ¥­çŒ«ç”¨ï¼‰' })
  @IsOptional()
  @IsString()
  destination?: string;

  @ApiPropertyOptional({ description: 'å¤–éƒ¨ãƒªãƒ³ã‚¯ï¼ˆå’æ¥­çŒ«ç”¨ï¼‰' })
  @IsOptional()
  @IsString()
  externalLink?: string;

  @ApiPropertyOptional({ description: 'å‚™è€ƒ' })
  @IsOptional()
  @IsString()
  notes?: string;

  @ApiPropertyOptional({
    description: 'ãƒ¡ãƒ‡ã‚£ã‚¢ï¼ˆç”»åƒãƒ»å‹•ç”»ï¼‰',
    type: [CreateMediaDto],
  })
  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => CreateMediaDto)
  media?: CreateMediaDto[];
}
`````

## File: backend/src/gallery/dto/gallery-query.dto.ts
`````typescript
import { ApiPropertyOptional } from '@nestjs/swagger';
import { Transform } from 'class-transformer';
import { IsOptional, IsEnum, IsNumber, Min, Max } from 'class-validator';

import { GalleryCategoryDto } from './create-gallery-entry.dto';

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ä¸€è¦§å–å¾—ç”¨ã‚¯ã‚¨ãƒª DTO
 */
export class GalleryQueryDto {
  @ApiPropertyOptional({ enum: GalleryCategoryDto, description: 'ã‚«ãƒ†ã‚´ãƒªãƒ•ã‚£ãƒ«ã‚¿ãƒ¼' })
  @IsOptional()
  @IsEnum(GalleryCategoryDto)
  category?: GalleryCategoryDto;

  @ApiPropertyOptional({ default: 1, description: 'ãƒšãƒ¼ã‚¸ç•ªå·' })
  @IsOptional()
  @Transform(({ value }: { value: string }) => parseInt(value, 10))
  @IsNumber()
  @Min(1)
  page?: number = 1;

  @ApiPropertyOptional({ default: 20, description: '1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•°' })
  @IsOptional()
  @Transform(({ value }: { value: string }) => parseInt(value, 10))
  @IsNumber()
  @Min(1)
  @Max(100)
  limit?: number = 20;
}
`````

## File: backend/src/gallery/dto/index.ts
`````typescript
export * from './create-gallery-entry.dto';
export * from './update-gallery-entry.dto';
export * from './gallery-query.dto';
export * from './add-media.dto';
`````

## File: backend/src/gallery/dto/update-gallery-entry.dto.ts
`````typescript
import { PartialType } from '@nestjs/swagger';

import { CreateGalleryEntryDto } from './create-gallery-entry.dto';

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªæ›´æ–° DTO
 */
export class UpdateGalleryEntryDto extends PartialType(CreateGalleryEntryDto) {}
`````

## File: backend/src/gallery/gallery.controller.ts
`````typescript
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiParam,
  ApiQuery,
} from '@nestjs/swagger';

import {
  CreateGalleryEntryDto,
  UpdateGalleryEntryDto,
  GalleryQueryDto,
  AddMediaDto,
  GalleryCategoryDto,
} from './dto';
import { GalleryService } from './gallery.service';

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªã®CRUD APIã‚’æä¾›
 */
@ApiTags('Gallery')
@Controller('gallery')
export class GalleryController {
  constructor(private readonly galleryService: GalleryService) {}

  @Get()
  @ApiOperation({ summary: 'ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªä¸€è¦§å–å¾—' })
  @ApiQuery({
    name: 'category',
    required: false,
    enum: GalleryCategoryDto,
    description: 'ã‚«ãƒ†ã‚´ãƒªã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°',
  })
  @ApiQuery({ name: 'page', required: false, type: Number, description: 'ãƒšãƒ¼ã‚¸ç•ªå·' })
  @ApiQuery({ name: 'limit', required: false, type: Number, description: '1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•°' })
  @ApiResponse({ status: 200, description: 'ã‚®ãƒ£ãƒ©ãƒªãƒ¼ä¸€è¦§' })
  async findAll(@Query() query: GalleryQueryDto) {
    return this.galleryService.findAll(query);
  }

  @Get(':id')
  @ApiOperation({ summary: 'ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªè©³ç´°å–å¾—' })
  @ApiParam({ name: 'id', description: 'ã‚¨ãƒ³ãƒˆãƒªID' })
  @ApiResponse({ status: 200, description: 'ã‚®ãƒ£ãƒ©ãƒªãƒ¼è©³ç´°' })
  @ApiResponse({ status: 404, description: 'ã‚¨ãƒ³ãƒˆãƒªãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“' })
  async findOne(@Param('id') id: string) {
    return this.galleryService.findOne(id);
  }

  @Post()
  @HttpCode(HttpStatus.CREATED)
  @ApiOperation({ summary: 'ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªä½œæˆ' })
  @ApiResponse({ status: 201, description: 'ä½œæˆæˆåŠŸ' })
  async create(@Body() dto: CreateGalleryEntryDto) {
    return this.galleryService.create(dto);
  }

  @Put(':id')
  @ApiOperation({ summary: 'ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªæ›´æ–°' })
  @ApiParam({ name: 'id', description: 'ã‚¨ãƒ³ãƒˆãƒªID' })
  @ApiResponse({ status: 200, description: 'æ›´æ–°æˆåŠŸ' })
  @ApiResponse({ status: 404, description: 'ã‚¨ãƒ³ãƒˆãƒªãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“' })
  async update(
    @Param('id') id: string,
    @Body() dto: UpdateGalleryEntryDto,
  ) {
    return this.galleryService.update(id, dto);
  }

  @Delete(':id')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªå‰Šé™¤' })
  @ApiParam({ name: 'id', description: 'ã‚¨ãƒ³ãƒˆãƒªID' })
  @ApiResponse({ status: 200, description: 'å‰Šé™¤æˆåŠŸ' })
  @ApiResponse({ status: 404, description: 'ã‚¨ãƒ³ãƒˆãƒªãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“' })
  async delete(@Param('id') id: string) {
    return this.galleryService.delete(id);
  }

  @Post(':id/media')
  @HttpCode(HttpStatus.CREATED)
  @ApiOperation({ summary: 'ãƒ¡ãƒ‡ã‚£ã‚¢è¿½åŠ ' })
  @ApiParam({ name: 'id', description: 'ã‚¨ãƒ³ãƒˆãƒªID' })
  @ApiResponse({ status: 201, description: 'ãƒ¡ãƒ‡ã‚£ã‚¢è¿½åŠ æˆåŠŸ' })
  async addMedia(@Param('id') id: string, @Body() dto: AddMediaDto) {
    return this.galleryService.addMedia(id, dto);
  }

  @Delete('media/:mediaId')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'ãƒ¡ãƒ‡ã‚£ã‚¢å‰Šé™¤' })
  @ApiParam({ name: 'mediaId', description: 'ãƒ¡ãƒ‡ã‚£ã‚¢ID' })
  @ApiResponse({ status: 200, description: 'ãƒ¡ãƒ‡ã‚£ã‚¢å‰Šé™¤æˆåŠŸ' })
  async deleteMedia(@Param('mediaId') mediaId: string) {
    return this.galleryService.deleteMedia(mediaId);
  }

  @Post('bulk')
  @HttpCode(HttpStatus.CREATED)
  @ApiOperation({ summary: 'ä¸€æ‹¬ç™»éŒ²ï¼ˆå­è‚²ã¦ä¸­ã‚¿ãƒ–ç”¨ï¼‰' })
  @ApiResponse({ status: 201, description: 'ä¸€æ‹¬ç™»éŒ²æˆåŠŸ' })
  async bulkCreate(@Body() entries: CreateGalleryEntryDto[]) {
    return this.galleryService.bulkCreate(entries);
  }
}
`````

## File: backend/src/gallery/gallery.module.ts
`````typescript
import { Module } from '@nestjs/common';

import { GalleryUploadModule } from '../gallery-upload/gallery-upload.module';
import { PrismaModule } from '../prisma/prisma.module';

import { GalleryController } from './gallery.controller';
import { GalleryService } from './gallery.service';

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªã® CRUD æ©Ÿèƒ½ã‚’æä¾›
 */
@Module({
  imports: [PrismaModule, GalleryUploadModule],
  controllers: [GalleryController],
  providers: [GalleryService],
  exports: [GalleryService],
})
export class GalleryModule {}
`````

## File: backend/src/gallery/gallery.service.ts
`````typescript
import { Injectable, NotFoundException, Logger } from '@nestjs/common';
import { GalleryCategory, MediaType, Prisma } from '@prisma/client';

import { GalleryUploadService } from '../gallery-upload/gallery-upload.service';
import { PrismaService } from '../prisma/prisma.service';

import {
  CreateGalleryEntryDto,
  UpdateGalleryEntryDto,
  GalleryQueryDto,
  AddMediaDto,
  GalleryCategoryDto,
  MediaTypeDto,
} from './dto';

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚µãƒ¼ãƒ“ã‚¹
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªã®CRUDæ“ä½œã¨ãƒ¡ãƒ‡ã‚£ã‚¢ç®¡ç†ã‚’æä¾›
 */
@Injectable()
export class GalleryService {
  private readonly logger = new Logger(GalleryService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly uploadService: GalleryUploadService,
  ) {}

  /**
   * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªä¸€è¦§å–å¾—
   */
  async findAll(query: GalleryQueryDto) {
    const { category, page = 1, limit = 20 } = query;
    const skip = (page - 1) * limit;

    const where: Prisma.GalleryEntryWhereInput = category
      ? { category: category as GalleryCategory }
      : {};

    const [entries, total] = await Promise.all([
      this.prisma.galleryEntry.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: 'desc' },
        include: {
          media: {
            orderBy: { order: 'asc' },
          },
        },
      }),
      this.prisma.galleryEntry.count({ where }),
    ]);

    return {
      success: true,
      data: entries,
      meta: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  /**
   * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªè©³ç´°å–å¾—
   */
  async findOne(id: string) {
    const entry = await this.prisma.galleryEntry.findUnique({
      where: { id },
      include: {
        media: {
          orderBy: { order: 'asc' },
        },
        cat: {
          select: {
            id: true,
            name: true,
            gender: true,
            birthDate: true,
          },
        },
      },
    });

    if (!entry) {
      throw new NotFoundException(`ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªï¼ˆID: ${id}ï¼‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
    }

    return {
      success: true,
      data: entry,
    };
  }

  /**
   * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªä½œæˆ
   */
  async create(dto: CreateGalleryEntryDto, userId?: string) {
    const { media, catId, transferDate, ...entryData } = dto;

    // åœ¨èˆçŒ«ã‹ã‚‰ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã‚’å–å¾—
    let catSnapshot: Prisma.InputJsonValue | undefined = undefined;
    if (catId) {
      const cat = await this.prisma.cat.findUnique({
        where: { id: catId },
        include: {
          breed: true,
          coatColor: true,
          tags: { include: { tag: true } },
        },
      });
      if (cat) {
        // Prisma InputJsonValue ã¨ã—ã¦å®‰å…¨ã«å¤‰æ›
        catSnapshot = JSON.parse(JSON.stringify(cat)) as Prisma.InputJsonValue;
      }
    }

    const entry = await this.prisma.galleryEntry.create({
      data: {
        ...entryData,
        category: this.mapCategoryDtoToPrisma(dto.category),
        catId,
        transferDate: transferDate ? new Date(transferDate) : null,
        transferredBy: userId,
        catSnapshot,
        media: media
          ? {
              create: media.map((m, index) => ({
                type: this.mapMediaTypeDtoToPrisma(m.type),
                url: m.url,
                thumbnailUrl: m.thumbnailUrl,
                order: m.order ?? index,
              })),
            }
          : undefined,
      },
      include: {
        media: {
          orderBy: { order: 'asc' },
        },
      },
    });

    this.logger.log(`ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªä½œæˆ: ${entry.id} (${entry.category})`);

    return {
      success: true,
      data: entry,
    };
  }

  /**
   * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªæ›´æ–°
   */
  async update(id: string, dto: UpdateGalleryEntryDto) {
    const existing = await this.prisma.galleryEntry.findUnique({
      where: { id },
    });
    if (!existing) {
      throw new NotFoundException(`ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªï¼ˆID: ${id}ï¼‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
    }

    const { media: _media, transferDate, category, ...updateData } = dto;

    const entry = await this.prisma.galleryEntry.update({
      where: { id },
      data: {
        ...updateData,
        category: category ? this.mapCategoryDtoToPrisma(category) : undefined,
        transferDate: transferDate ? new Date(transferDate) : undefined,
      },
      include: {
        media: {
          orderBy: { order: 'asc' },
        },
      },
    });

    this.logger.log(`ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªæ›´æ–°: ${entry.id}`);

    return {
      success: true,
      data: entry,
    };
  }

  /**
   * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªå‰Šé™¤
   */
  async delete(id: string) {
    const entry = await this.prisma.galleryEntry.findUnique({
      where: { id },
      include: { media: true },
    });

    if (!entry) {
      throw new NotFoundException(`ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªï¼ˆID: ${id}ï¼‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
    }

    // é–¢é€£ç”»åƒã‚’Cloud Storageã‹ã‚‰å‰Šé™¤
    for (const m of entry.media) {
      if (m.type === 'IMAGE' && m.url.includes('storage.googleapis.com')) {
        const fileKey = this.extractFileKey(m.url);
        if (fileKey) {
          await this.uploadService.deleteFile(fileKey);
        }
      }
    }

    await this.prisma.galleryEntry.delete({ where: { id } });

    this.logger.log(`ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªå‰Šé™¤: ${id}`);

    return {
      success: true,
      message: 'ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
    };
  }

  /**
   * ãƒ¡ãƒ‡ã‚£ã‚¢è¿½åŠ 
   */
  async addMedia(
    entryId: string,
    mediaData: AddMediaDto,
  ) {
    const entry = await this.prisma.galleryEntry.findUnique({
      where: { id: entryId },
      include: { media: true },
    });

    if (!entry) {
      throw new NotFoundException(`ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªï¼ˆID: ${entryId}ï¼‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
    }

    const maxOrder = entry.media.reduce((max, m) => Math.max(max, m.order), -1);

    const media = await this.prisma.galleryMedia.create({
      data: {
        galleryEntryId: entryId,
        type: this.mapMediaTypeDtoToPrisma(mediaData.type),
        url: mediaData.url,
        thumbnailUrl: mediaData.thumbnailUrl,
        order: maxOrder + 1,
      },
    });

    this.logger.log(`ãƒ¡ãƒ‡ã‚£ã‚¢è¿½åŠ : entryId=${entryId}, mediaId=${media.id}`);

    return {
      success: true,
      data: media,
    };
  }

  /**
   * ãƒ¡ãƒ‡ã‚£ã‚¢å‰Šé™¤
   */
  async deleteMedia(mediaId: string) {
    const media = await this.prisma.galleryMedia.findUnique({
      where: { id: mediaId },
    });

    if (!media) {
      throw new NotFoundException(`ãƒ¡ãƒ‡ã‚£ã‚¢ï¼ˆID: ${mediaId}ï¼‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
    }

    // ç”»åƒã®å ´åˆã¯Cloud Storageã‹ã‚‰ã‚‚å‰Šé™¤
    if (media.type === 'IMAGE' && media.url.includes('storage.googleapis.com')) {
      const fileKey = this.extractFileKey(media.url);
      if (fileKey) {
        await this.uploadService.deleteFile(fileKey);
      }
    }

    await this.prisma.galleryMedia.delete({ where: { id: mediaId } });

    this.logger.log(`ãƒ¡ãƒ‡ã‚£ã‚¢å‰Šé™¤: ${mediaId}`);

    return {
      success: true,
      message: 'ãƒ¡ãƒ‡ã‚£ã‚¢ã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
    };
  }

  /**
   * ä¸€æ‹¬ç™»éŒ²ï¼ˆå­è‚²ã¦ä¸­ã‚¿ãƒ–ã‹ã‚‰ï¼‰
   */
  async bulkCreate(entries: CreateGalleryEntryDto[], userId?: string) {
    const results = [];

    for (const dto of entries) {
      const result = await this.create(dto, userId);
      results.push(result.data);
    }

    this.logger.log(`ä¸€æ‹¬ç™»éŒ²å®Œäº†: ${results.length}ä»¶`);

    return {
      success: true,
      data: results,
      meta: {
        created: results.length,
      },
    };
  }

  /**
   * URL ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚­ãƒ¼ã‚’æŠ½å‡º
   */
  private extractFileKey(url: string): string | null {
    const match = url.match(/storage\.googleapis\.com\/[^/]+\/(.+)/);
    return match ? match[1] : null;
  }

  /**
   * ã‚«ãƒ†ã‚´ãƒª DTO ã‚’ Prisma enum ã«ãƒãƒƒãƒ”ãƒ³ã‚°
   */
  private mapCategoryDtoToPrisma(category: GalleryCategoryDto): GalleryCategory {
    const mapping: Record<GalleryCategoryDto, GalleryCategory> = {
      [GalleryCategoryDto.KITTEN]: GalleryCategory.KITTEN,
      [GalleryCategoryDto.FATHER]: GalleryCategory.FATHER,
      [GalleryCategoryDto.MOTHER]: GalleryCategory.MOTHER,
      [GalleryCategoryDto.GRADUATION]: GalleryCategory.GRADUATION,
    };
    return mapping[category];
  }

  /**
   * ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¿ã‚¤ãƒ— DTO ã‚’ Prisma enum ã«ãƒãƒƒãƒ”ãƒ³ã‚°
   */
  private mapMediaTypeDtoToPrisma(type: MediaTypeDto): MediaType {
    const mapping: Record<MediaTypeDto, MediaType> = {
      [MediaTypeDto.IMAGE]: MediaType.IMAGE,
      [MediaTypeDto.YOUTUBE]: MediaType.YOUTUBE,
    };
    return mapping[type];
  }
}
`````

## File: backend/src/gallery-upload/dto/confirm-upload.dto.ts
`````typescript
import { ApiProperty } from '@nestjs/swagger';
import { IsString, IsUUID, IsOptional } from 'class-validator';

/**
 * ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº†ç¢ºèªãƒªã‚¯ã‚¨ã‚¹ãƒˆ DTO
 */
export class ConfirmUploadDto {
  @ApiProperty({
    description: 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ™‚ã«ç™ºè¡Œã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚­ãƒ¼',
    example: 'gallery/550e8400-e29b-41d4-a716-446655440000.jpg',
  })
  @IsString()
  fileKey: string;

  @ApiProperty({
    description: 'ç´ä»˜ã‘ã‚‹ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªIDï¼ˆä»»æ„ï¼‰',
    required: false,
    example: '550e8400-e29b-41d4-a716-446655440001',
  })
  @IsOptional()
  @IsUUID('4', { message: 'æœ‰åŠ¹ãªUUIDã‚’æŒ‡å®šã—ã¦ãã ã•ã„' })
  galleryEntryId?: string;
}
`````

## File: backend/src/gallery-upload/dto/generate-upload-url.dto.ts
`````typescript
import { ApiProperty } from '@nestjs/swagger';
import { IsString, IsIn, IsNumber, Min, Max } from 'class-validator';

/**
 * ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç”¨ Signed URL ç”Ÿæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆ DTO
 */
export class GenerateUploadUrlDto {
  @ApiProperty({ description: 'ãƒ•ã‚¡ã‚¤ãƒ«å', example: 'kitten-photo-1.jpg' })
  @IsString()
  fileName: string;

  @ApiProperty({
    description: 'ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¤ãƒ—',
    enum: ['image/jpeg', 'image/png', 'image/webp'],
    example: 'image/jpeg',
  })
  @IsIn(['image/jpeg', 'image/png', 'image/webp'], {
    message: 'å¯¾å¿œå½¢å¼ã¯ JPEG, PNG, WebP ã®ã¿ã§ã™',
  })
  contentType: 'image/jpeg' | 'image/png' | 'image/webp';

  @ApiProperty({
    description: 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºï¼ˆãƒã‚¤ãƒˆï¼‰',
    example: 1024000,
    minimum: 1,
    maximum: 10485760,
  })
  @IsNumber()
  @Min(1, { message: 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã¯1ãƒã‚¤ãƒˆä»¥ä¸Šã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™' })
  @Max(10 * 1024 * 1024, { message: 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã¯10MBä»¥ä¸‹ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™' })
  fileSize: number;
}
`````

## File: backend/src/gallery-upload/dto/index.ts
`````typescript
export { GenerateUploadUrlDto } from './generate-upload-url.dto';
export { ConfirmUploadDto } from './confirm-upload.dto';
`````

## File: backend/src/gallery-upload/interfaces/upload-result.interface.ts
`````typescript
/**
 * ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰çµæœã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
 */
export interface UploadResult {
  /** æ“ä½œæˆåŠŸãƒ•ãƒ©ã‚° */
  success: boolean;
  /** å…¬é–‹URL */
  url: string;
  /** ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºï¼ˆãƒã‚¤ãƒˆï¼‰ */
  size: number;
}

/**
 * Signed URL ç”Ÿæˆçµæœã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
 */
export interface SignedUrlResult {
  /** ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç”¨ Signed URL */
  uploadUrl: string;
  /** GCS å†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚­ãƒ¼ */
  fileKey: string;
  /** ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å¾Œã®å…¬é–‹URL */
  publicUrl: string;
}
`````

## File: backend/src/gallery-upload/gallery-upload.controller.ts
`````typescript
import {
  Controller,
  Post,
  Body,
  Delete,
  Param,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiParam } from '@nestjs/swagger';

import { GenerateUploadUrlDto, ConfirmUploadDto } from './dto';
import { GalleryUploadService } from './gallery-upload.service';

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç”¨ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼
 * Signed URL æ–¹å¼ã§ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ç›´æ¥ GCS ã¸ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚’è¡Œã†
 */
@ApiTags('Gallery Upload')
@Controller('gallery/upload')
export class GalleryUploadController {
  constructor(private readonly uploadService: GalleryUploadService) {}

  /**
   * ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç”¨ Signed URL ã‚’ç”Ÿæˆ
   */
  @Post('signed-url')
  @ApiOperation({
    summary: 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç”¨Signed URLã‚’ç”Ÿæˆ',
    description: 'ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒGCSã¸ç›´æ¥ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãŸã‚ã®Signed URLã‚’ç™ºè¡Œã—ã¾ã™ã€‚æœ‰åŠ¹æœŸé™ã¯15åˆ†ã§ã™ã€‚',
  })
  @ApiResponse({
    status: 201,
    description: 'Signed URLç”ŸæˆæˆåŠŸ',
    schema: {
      type: 'object',
      properties: {
        success: { type: 'boolean', example: true },
        data: {
          type: 'object',
          properties: {
            uploadUrl: { type: 'string', description: 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç”¨Signed URL' },
            fileKey: { type: 'string', description: 'GCSå†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚­ãƒ¼' },
            publicUrl: { type: 'string', description: 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å¾Œã®å…¬é–‹URL' },
          },
        },
      },
    },
  })
  @ApiResponse({ status: 400, description: 'ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚¨ãƒ©ãƒ¼' })
  async generateUploadUrl(@Body() dto: GenerateUploadUrlDto) {
    const result = await this.uploadService.generateUploadUrl(dto);
    return {
      success: true,
      data: result,
    };
  }

  /**
   * ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº†ã‚’ç¢ºèª
   */
  @Post('confirm')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº†ã‚’ç¢ºèª',
    description: 'ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒGCSã¸ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº†å¾Œã«å‘¼ã³å‡ºã—ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ã‚’ç¢ºèªã—ã¾ã™ã€‚',
  })
  @ApiResponse({
    status: 200,
    description: 'ç¢ºèªæˆåŠŸ',
    schema: {
      type: 'object',
      properties: {
        success: { type: 'boolean', example: true },
        data: {
          type: 'object',
          properties: {
            success: { type: 'boolean', example: true },
            url: { type: 'string', description: 'ãƒ•ã‚¡ã‚¤ãƒ«ã®å…¬é–‹URL' },
            size: { type: 'number', description: 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºï¼ˆãƒã‚¤ãƒˆï¼‰' },
          },
        },
      },
    },
  })
  @ApiResponse({ status: 400, description: 'ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã„' })
  async confirmUpload(@Body() dto: ConfirmUploadDto) {
    const result = await this.uploadService.confirmUpload(dto.fileKey);
    return {
      success: true,
      data: result,
    };
  }

  /**
   * ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ¸ˆã¿ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤
   */
  @Delete(':fileKey')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ¸ˆã¿ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤',
    description: 'æŒ‡å®šã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚­ãƒ¼ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’GCSã‹ã‚‰å‰Šé™¤ã—ã¾ã™ã€‚',
  })
  @ApiParam({
    name: 'fileKey',
    description: 'å‰Šé™¤ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚­ãƒ¼ï¼ˆURLã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰æ¸ˆã¿ï¼‰',
    example: 'gallery%2F550e8400-e29b-41d4-a716-446655440000.jpg',
  })
  @ApiResponse({ status: 200, description: 'å‰Šé™¤æˆåŠŸ' })
  async deleteFile(@Param('fileKey') fileKey: string) {
    await this.uploadService.deleteFile(decodeURIComponent(fileKey));
    return {
      success: true,
      message: 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
    };
  }
}
`````

## File: backend/src/gallery-upload/gallery-upload.module.ts
`````typescript
import { Module } from '@nestjs/common';

import { GalleryUploadController } from './gallery-upload.controller';
import { GalleryUploadService } from './gallery-upload.service';

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
 * Google Cloud Storage ã‚’ä½¿ç”¨ã—ãŸç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½ã‚’æä¾›
 */
@Module({
  controllers: [GalleryUploadController],
  providers: [GalleryUploadService],
  exports: [GalleryUploadService],
})
export class GalleryUploadModule {}
`````

## File: backend/src/gallery-upload/gallery-upload.service.ts
`````typescript
import { Storage } from '@google-cloud/storage';
import { Injectable, BadRequestException, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { v4 as uuidv4 } from 'uuid';

import { GenerateUploadUrlDto } from './dto/generate-upload-url.dto';
import { SignedUrlResult, UploadResult } from './interfaces/upload-result.interface';

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚µãƒ¼ãƒ“ã‚¹
 * Google Cloud Storage ã‚’ä½¿ç”¨ã—ãŸ Signed URL æ–¹å¼ã§ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚’æä¾›
 */
@Injectable()
export class GalleryUploadService {
  private readonly logger = new Logger(GalleryUploadService.name);
  private readonly storage: Storage;
  private readonly bucketName: string;

  constructor(private readonly configService: ConfigService) {
    const projectId = this.configService.get<string>('GCS_PROJECT_ID', 'my-cats-pro-staging');
    
    this.storage = new Storage({
      projectId,
    });
    
    this.bucketName = this.configService.get<string>('GCS_BUCKET_NAME', 'mycats-pro-gallery-staging');
    
    this.logger.log(`GalleryUploadService initialized: bucket=${this.bucketName}, project=${projectId}`);
  }

  /**
   * ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¤ãƒ—ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µå­ã‚’å–å¾—
   */
  private getExtension(contentType: string): string {
    const extensionMap: Record<string, string> = {
      'image/jpeg': '.jpg',
      'image/png': '.png',
      'image/webp': '.webp',
    };
    return extensionMap[contentType] ?? '.jpg';
  }

  /**
   * Signed URL ã‚’ç”Ÿæˆã—ã¦ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«è¿”ã™
   * ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ã“ã® URL ã‚’ä½¿ã£ã¦ç›´æ¥ GCS ã¸ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã™ã‚‹
   */
  async generateUploadUrl(dto: GenerateUploadUrlDto): Promise<SignedUrlResult> {
    const fileExtension = this.getExtension(dto.contentType);
    const fileKey = `gallery/${uuidv4()}${fileExtension}`;

    try {
      const bucket = this.storage.bucket(this.bucketName);
      const file = bucket.file(fileKey);

      const [signedUrl] = await file.getSignedUrl({
        version: 'v4',
        action: 'write',
        expires: Date.now() + 15 * 60 * 1000, // 15åˆ†æœ‰åŠ¹
        contentType: dto.contentType,
      });

      const publicUrl = `https://storage.googleapis.com/${this.bucketName}/${fileKey}`;

      this.logger.log(`Signed URL generated: fileKey=${fileKey}, fileName=${dto.fileName}`);

      return {
        uploadUrl: signedUrl,
        fileKey,
        publicUrl,
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼';
      this.logger.error(`Signed URL ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ: ${errorMessage}`, error instanceof Error ? error.stack : undefined);
      throw new BadRequestException('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰URLã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
  }

  /**
   * ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº†ã‚’ç¢ºèªã—ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ã‚’ãƒã‚§ãƒƒã‚¯
   */
  async confirmUpload(fileKey: string): Promise<UploadResult> {
    try {
      const bucket = this.storage.bucket(this.bucketName);
      const file = bucket.file(fileKey);

      const [exists] = await file.exists();
      if (!exists) {
        throw new BadRequestException('ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãŒå®Œäº†ã—ã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™');
      }

      const [metadata] = await file.getMetadata();

      this.logger.log(`Upload confirmed: fileKey=${fileKey}, size=${metadata.size}`);

      return {
        success: true,
        url: `https://storage.googleapis.com/${this.bucketName}/${fileKey}`,
        size: Number(metadata.size),
      };
    } catch (error) {
      if (error instanceof BadRequestException) {
        throw error;
      }
      const errorMessage = error instanceof Error ? error.message : 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼';
      this.logger.error(`ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç¢ºèªã«å¤±æ•—ã—ã¾ã—ãŸ: ${errorMessage}`, error instanceof Error ? error.stack : undefined);
      throw new BadRequestException('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã®ç¢ºèªã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
  }

  /**
   * ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤
   */
  async deleteFile(fileKey: string): Promise<void> {
    try {
      const bucket = this.storage.bucket(this.bucketName);
      const file = bucket.file(fileKey);
      
      const [exists] = await file.exists();
      if (!exists) {
        this.logger.warn(`å‰Šé™¤å¯¾è±¡ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ã¾ã›ã‚“: ${fileKey}`);
        return;
      }
      
      await file.delete();
      this.logger.log(`ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤ã—ã¾ã—ãŸ: ${fileKey}`);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼';
      this.logger.error(`ãƒ•ã‚¡ã‚¤ãƒ«å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ: ${fileKey}, error=${errorMessage}`);
      // å‰Šé™¤å¤±æ•—ã¯è‡´å‘½çš„ã§ã¯ãªã„ã®ã§ã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ãªã„
    }
  }
}
`````

## File: backend/src/graduation/dto/index.ts
`````typescript
export * from './transfer-cat.dto';
`````

## File: backend/src/graduation/dto/transfer-cat.dto.ts
`````typescript
import { ApiProperty } from '@nestjs/swagger';
import { IsString, IsDateString, IsOptional } from 'class-validator';

export class TransferCatDto {
  @ApiProperty({
    description: 'è­²æ¸¡æ—¥',
    example: '2025-11-11',
  })
  @IsDateString()
  transferDate: string;

  @ApiProperty({
    description: 'è­²æ¸¡å…ˆ',
    example: 'å±±ç”°å®¶',
  })
  @IsString()
  destination: string;

  @ApiProperty({
    description: 'å‚™è€ƒ',
    example: 'è­²æ¸¡å…ˆã¯æ„›æƒ…æ·±ã„å®¶åº­ã§ã™',
    required: false,
  })
  @IsOptional()
  @IsString()
  notes?: string;
}
`````

## File: backend/src/graduation/graduation.controller.spec.ts
`````typescript
import { Test, TestingModule } from '@nestjs/testing';

import { getTestModuleImports, getTestModuleProviders } from '../test-utils/test-module-setup';

import { GraduationController } from './graduation.controller';
import { GraduationService } from './graduation.service';

describe('GraduationController', () => {
  let controller: GraduationController;
  let service: GraduationService;

  const mockGraduationService = {
    transferCat: jest.fn(),
    findAllGraduations: jest.fn(),
    findOneGraduation: jest.fn(),
    cancelGraduation: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      imports: getTestModuleImports(),
      controllers: [GraduationController],
      providers: [
        ...getTestModuleProviders(),
        {
          provide: GraduationService,
          useValue: mockGraduationService,
        },
      ],
    }).compile();

    controller = module.get<GraduationController>(GraduationController);
    service = module.get<GraduationService>(GraduationService);

    jest.clearAllMocks();
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });

  describe('transferCat', () => {
    it('should transfer a cat', async () => {
      const catId = 'cat-1';
      const transferDto = {
        transferDate: '2024-01-15',
        destination: 'New Home',
      };
      const mockRecord = { success: true, data: { id: '1', catId, ...transferDto } };

      mockGraduationService.transferCat.mockResolvedValue(mockRecord);

      const result = await controller.transferCat(catId, transferDto);

      expect(result).toEqual(mockRecord);
      expect(service.transferCat).toHaveBeenCalledWith(catId, transferDto);
    });
  });

  describe('findAllGraduations', () => {
    it('should return graduation records', async () => {
      const mockResponse = {
        data: [{ id: '1', catId: 'cat-1' }],
        meta: { page: 1, limit: 50, total: 1, totalPages: 1 },
      };

      mockGraduationService.findAllGraduations.mockResolvedValue(mockResponse);

      const result = await controller.findAllGraduations('1', '50');

      expect(result).toEqual(mockResponse);
      expect(service.findAllGraduations).toHaveBeenCalledWith(1, 50);
    });
  });

  describe('findOneGraduation', () => {
    it('should return a graduation record', async () => {
      const mockGraduation = { id: '1', catId: 'cat-1', transferDate: new Date() };

      mockGraduationService.findOneGraduation.mockResolvedValue(mockGraduation);

      const result = await controller.findOneGraduation('1');

      expect(result).toEqual(mockGraduation);
      expect(service.findOneGraduation).toHaveBeenCalledWith('1');
    });
  });

  describe('cancelGraduation', () => {
    it('should cancel a graduation', async () => {
      const mockResponse = { success: true, message: 'Graduation cancelled' };

      mockGraduationService.cancelGraduation.mockResolvedValue(mockResponse);

      const result = await controller.cancelGraduation('1');

      expect(result).toEqual(mockResponse);
      expect(service.cancelGraduation).toHaveBeenCalledWith('1');
    });
  });
});
`````

## File: backend/src/graduation/graduation.controller.ts
`````typescript
import {
  Controller,
  Post,
  Get,
  Delete,
  Param,
  Body,
  Query,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiParam,
  ApiQuery,
} from '@nestjs/swagger';

import { TransferCatDto } from './dto';
import { GraduationService } from './graduation.service';

@ApiTags('Graduation')
@Controller('graduations')
export class GraduationController {
  constructor(private readonly graduationService: GraduationService) {}

  /**
   * çŒ«ã‚’è­²æ¸¡ï¼ˆå’æ¥­ï¼‰ã™ã‚‹
   */
  @Post('cats/:id/transfer')
  @HttpCode(HttpStatus.CREATED)
  @ApiOperation({ summary: 'çŒ«ã‚’è­²æ¸¡ï¼ˆå’æ¥­ï¼‰ã™ã‚‹' })
  @ApiParam({ name: 'id', description: 'çŒ«ID' })
  @ApiResponse({ status: 201, description: 'è­²æ¸¡æˆåŠŸ' })
  @ApiResponse({ status: 404, description: 'çŒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“' })
  @ApiResponse({ status: 400, description: 'ã™ã§ã«å’æ¥­æ¸ˆã¿ã§ã™' })
  async transferCat(@Param('id') id: string, @Body() dto: TransferCatDto) {
    return this.graduationService.transferCat(id, dto);
  }

  /**
   * å’æ¥­çŒ«ä¸€è¦§å–å¾—
   */
  @Get()
  @ApiOperation({ summary: 'å’æ¥­çŒ«ä¸€è¦§å–å¾—' })
  @ApiQuery({ name: 'page', required: false, type: Number })
  @ApiQuery({ name: 'limit', required: false, type: Number })
  @ApiResponse({ status: 200, description: 'å’æ¥­çŒ«ä¸€è¦§' })
  async findAllGraduations(
    @Query('page') page?: string,
    @Query('limit') limit?: string,
  ) {
    const pageNum = page ? parseInt(page, 10) : 1;
    const limitNum = limit ? parseInt(limit, 10) : 50;
    return this.graduationService.findAllGraduations(pageNum, limitNum);
  }

  /**
   * å’æ¥­çŒ«è©³ç´°å–å¾—
   */
  @Get(':id')
  @ApiOperation({ summary: 'å’æ¥­çŒ«è©³ç´°å–å¾—' })
  @ApiParam({ name: 'id', description: 'å’æ¥­ID' })
  @ApiResponse({ status: 200, description: 'å’æ¥­çŒ«è©³ç´°' })
  @ApiResponse({ status: 404, description: 'å’æ¥­è¨˜éŒ²ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“' })
  async findOneGraduation(@Param('id') id: string) {
    return this.graduationService.findOneGraduation(id);
  }

  /**
   * å’æ¥­å–ã‚Šæ¶ˆã—ï¼ˆç·Šæ€¥æ™‚ç”¨ï¼‰
   */
  @Delete(':id')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'å’æ¥­å–ã‚Šæ¶ˆã—ï¼ˆç·Šæ€¥æ™‚ç”¨ï¼‰' })
  @ApiParam({ name: 'id', description: 'å’æ¥­ID' })
  @ApiResponse({ status: 200, description: 'å’æ¥­å–ã‚Šæ¶ˆã—æˆåŠŸ' })
  @ApiResponse({ status: 404, description: 'å’æ¥­è¨˜éŒ²ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“' })
  async cancelGraduation(@Param('id') id: string) {
    return this.graduationService.cancelGraduation(id);
  }
}
`````

## File: backend/src/graduation/graduation.module.ts
`````typescript
import { Module } from '@nestjs/common';

import { PrismaModule } from '../prisma/prisma.module';

import { GraduationController } from './graduation.controller';
import { GraduationService } from './graduation.service';

@Module({
  imports: [PrismaModule],
  controllers: [GraduationController],
  providers: [GraduationService],
  exports: [GraduationService],
})
export class GraduationModule {}
`````

## File: backend/src/graduation/graduation.service.spec.ts
`````typescript
import { NotFoundException } from '@nestjs/common';
import { Test, TestingModule } from '@nestjs/testing';

import { PrismaService } from '../prisma/prisma.service';

import { GraduationService } from './graduation.service';


describe('GraduationService', () => {
  let service: GraduationService;
  let _prismaService: PrismaService;

  const mockPrismaService: any = {
    cat: {
      findUnique: jest.fn(),
      update: jest.fn(),
      findMany: jest.fn(),
    },
    graduation: {
      create: jest.fn(),
      findMany: jest.fn(),
      findUnique: jest.fn(),
      delete: jest.fn(),
      count: jest.fn(),
    },
    $transaction: jest.fn((callback: any) => callback(mockPrismaService)),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        GraduationService,
        {
          provide: PrismaService,
          useValue: mockPrismaService,
        },
      ],
    }).compile();

    service = module.get<GraduationService>(GraduationService);
    _prismaService = module.get<PrismaService>(PrismaService);

    jest.clearAllMocks();
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('transferCat', () => {
    it('should transfer a cat successfully', async () => {
      const catId = 'cat-1';
      const transferDto = {
        transferDate: '2024-01-15',
        destination: 'New Home',
        notes: 'Good home',
      };

      const mockCat = {
        id: 'cat-1',
        name: 'Test Cat',
        isInHouse: true,
        isGraduated: false,
      };

      const mockGraduation = {
        id: '1',
        catId: 'cat-1',
        transferDate: new Date(transferDto.transferDate),
        destination: transferDto.destination,
        notes: transferDto.notes,
      };

      mockPrismaService.cat.findUnique.mockResolvedValue(mockCat);
      mockPrismaService.graduation.create.mockResolvedValue(mockGraduation);
      mockPrismaService.cat.update.mockResolvedValue({ ...mockCat, isGraduated: true, isInHouse: false });

      const result = await service.transferCat(catId, transferDto);

      expect(result.success).toBe(true);
      expect(result.data).toBeDefined();
    });

    it('should throw NotFoundException for invalid cat', async () => {
      const catId = 'invalid-cat';
      const transferDto = {
        transferDate: '2024-01-15',
        destination: 'New Home',
      };

      mockPrismaService.cat.findUnique.mockResolvedValue(null);

      await expect(service.transferCat(catId, transferDto)).rejects.toThrow(NotFoundException);
    });
  });

  describe('findAllGraduations', () => {
    it('should return paginated graduation records', async () => {
      const mockRecords = [
        {
          id: '1',
          catId: 'cat-1',
          transferDate: new Date(),
          destination: 'New Home',
          cat: {
            id: 'cat-1',
            name: 'Test Cat',
            gender: 'MALE',
            birthDate: new Date(),
          },
        },
      ];

      mockPrismaService.graduation.findMany.mockResolvedValue(mockRecords);
      mockPrismaService.graduation.count.mockResolvedValue(1);

      const result = await service.findAllGraduations(1, 50);

      expect(result.data).toEqual(mockRecords);
      expect(result.meta.total).toBe(1);
    });
  });

  describe('findOneGraduation', () => {
    it('should return a graduation record', async () => {
      const mockGraduation = {
        id: '1',
        catId: 'cat-1',
        transferDate: new Date(),
        destination: 'New Home',
      };

      mockPrismaService.graduation.findUnique.mockResolvedValue(mockGraduation);

      const result = await service.findOneGraduation('1');

      expect(result.success).toBe(true);
      expect(result.data).toEqual(mockGraduation);
    });

    it('should throw NotFoundException for invalid graduation', async () => {
      mockPrismaService.graduation.findUnique.mockResolvedValue(null);

      await expect(service.findOneGraduation('invalid')).rejects.toThrow(NotFoundException);
    });
  });

  describe('cancelGraduation', () => {
    it('should cancel a graduation successfully', async () => {
      const mockGraduation = {
        id: '1',
        catId: 'cat-1',
      };

      const mockCat = {
        id: 'cat-1',
        isGraduated: true,
        isInHouse: false,
      };

      mockPrismaService.graduation.findUnique.mockResolvedValue(mockGraduation);
      mockPrismaService.cat.findUnique.mockResolvedValue(mockCat);
      mockPrismaService.graduation.delete.mockResolvedValue(mockGraduation);
      mockPrismaService.cat.update.mockResolvedValue({ ...mockCat, isGraduated: false, isInHouse: true });

      const result = await service.cancelGraduation('1');

      expect(result.success).toBe(true);
    });
  });
});
`````

## File: backend/src/graduation/graduation.service.ts
`````typescript
import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';

import { PrismaService } from '../prisma/prisma.service';

import { TransferCatDto } from './dto';

@Injectable()
export class GraduationService {
  constructor(private readonly prisma: PrismaService) {}

  /**
   * çŒ«ã‚’è­²æ¸¡ï¼ˆå’æ¥­ï¼‰ã™ã‚‹
   * 1. çŒ«ãƒ‡ãƒ¼ã‚¿ã®ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã‚’ä½œæˆ
   * 2. Graduationãƒ¬ã‚³ãƒ¼ãƒ‰ä½œæˆ
   * 3. Catã®ãƒ•ãƒ©ã‚°æ›´æ–°ï¼ˆisGraduated=true, isInHouse=falseï¼‰
   */
  async transferCat(catId: string, dto: TransferCatDto, userId?: string) {
    // çŒ«ãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
    const cat = await this.prisma.cat.findUnique({
      where: { id: catId },
      include: {
        breed: true,
        coatColor: true,
        father: true,
        mother: true,
        tags: {
          include: {
            tag: true,
          },
        },
      },
    });

    if (!cat) {
      throw new NotFoundException(`Cat with ID ${catId} not found`);
    }

    // ã™ã§ã«å’æ¥­æ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
    if (cat.isGraduated) {
      throw new BadRequestException('This cat has already been graduated');
    }

    // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã§å‡¦ç†
    const result = await this.prisma.$transaction(async (tx) => {
      // 1. Graduationãƒ¬ã‚³ãƒ¼ãƒ‰ä½œæˆ
      const graduation = await tx.graduation.create({
        data: {
          catId: cat.id,
          transferDate: new Date(dto.transferDate),
          destination: dto.destination,
          notes: dto.notes,
          transferredBy: userId,
          catSnapshot: cat, // çŒ«ã®å…¨ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆ
        },
      });

      // 2. Catã®ãƒ•ãƒ©ã‚°æ›´æ–°
      await tx.cat.update({
        where: { id: catId },
        data: {
          isGraduated: true,
          isInHouse: false,
        },
      });

      return graduation;
    });

    return {
      success: true,
      data: result,
    };
  }

  /**
   * å’æ¥­çŒ«ä¸€è¦§å–å¾—
   */
  async findAllGraduations(page = 1, limit = 50) {
    const skip = (page - 1) * limit;

    const [graduations, total] = await Promise.all([
      this.prisma.graduation.findMany({
        skip,
        take: limit,
        orderBy: {
          transferDate: 'desc',
        },
        include: {
          cat: {
            select: {
              id: true,
              name: true,
              gender: true,
              birthDate: true,
            },
          },
        },
      }),
      this.prisma.graduation.count(),
    ]);

    return {
      success: true,
      data: graduations,
      meta: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  /**
   * å’æ¥­çŒ«è©³ç´°å–å¾—
   */
  async findOneGraduation(id: string) {
    const graduation = await this.prisma.graduation.findUnique({
      where: { id },
      include: {
        cat: true,
      },
    });

    if (!graduation) {
      throw new NotFoundException(`Graduation with ID ${id} not found`);
    }

    return {
      success: true,
      data: graduation,
    };
  }

  /**
   * å’æ¥­å–ã‚Šæ¶ˆã—ï¼ˆç·Šæ€¥æ™‚ç”¨ï¼‰
   */
  async cancelGraduation(id: string) {
    const graduation = await this.prisma.graduation.findUnique({
      where: { id },
    });

    if (!graduation) {
      throw new NotFoundException(`Graduation with ID ${id} not found`);
    }

    // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã§å‰Šé™¤ã¨ãƒ•ãƒ©ã‚°å¾©å…ƒ
    await this.prisma.$transaction(async (tx) => {
      // Graduationãƒ¬ã‚³ãƒ¼ãƒ‰å‰Šé™¤
      await tx.graduation.delete({
        where: { id },
      });

      // Catã®ãƒ•ãƒ©ã‚°å¾©å…ƒ
      await tx.cat.update({
        where: { id: graduation.catId },
        data: {
          isGraduated: false,
          isInHouse: true,
        },
      });
    });

    return {
      success: true,
      message: 'Graduation cancelled successfully',
    };
  }
}
`````

## File: backend/src/health/health.controller.spec.ts
`````typescript
import { Test, TestingModule } from '@nestjs/testing';

import { HealthController } from './health.controller';

describe('HealthController', () => {
  let controller: HealthController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [HealthController],
    }).compile();

    controller = module.get<HealthController>(HealthController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });

  describe('check', () => {
    it('should return health check response', () => {
      const result = controller.check();

      expect(result.success).toBe(true);
      expect(result.data.status).toBe('ok');
      expect(result.data.service).toBe('Cat Management System API');
      expect(result.data.timestamp).toBeDefined();
      expect(result.data.uptime).toBeDefined();
      expect(result.data.environment).toBeDefined();
    });
  });
});
`````

## File: backend/src/health/health.controller.ts
`````typescript
import { Controller, Get } from '@nestjs/common';

@Controller('health')
export class HealthController {
  @Get()
  check() {
    return {
      success: true,
      data: {
        status: 'ok',
        service: 'Cat Management System API',
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        environment: process.env.NODE_ENV ?? 'development',
      },
    };
  }
}
`````

## File: backend/src/health/health.module.ts
`````typescript
import { Module } from '@nestjs/common';

import { HealthController } from './health.controller';

@Module({
  controllers: [HealthController],
})
export class HealthModule {}
`````

## File: backend/src/pedigree/dto/create-pedigree.dto.ts
`````typescript
import { ApiProperty, ApiPropertyOptional } from "@nestjs/swagger";
import { Type } from "class-transformer";
import {
  IsString,
  IsOptional,
  IsInt,
  MaxLength,
} from "class-validator";

/**
 * è¡€çµ±æ›¸ä½œæˆDTOï¼ˆAccessè¨­è¨ˆæº–æ‹ ï¼‰
 * åŸºæœ¬æƒ…å ±17é …ç›® + è¡€çµ±æƒ…å ±62é …ç›®
 */
export class CreatePedigreeDto {
  // ==================== åŸºæœ¬æƒ…å ±ï¼ˆ17é …ç›®ï¼‰====================
  @ApiProperty({ description: "è¡€çµ±æ›¸ç•ªå·", example: "700545" })
  @IsString()
  @MaxLength(100)
  pedigreeId: string;

  @ApiPropertyOptional({ description: "ã‚¿ã‚¤ãƒˆãƒ«", example: "Champion" })
  @IsOptional()
  @IsString()
  @MaxLength(300)
  title?: string;

  @ApiPropertyOptional({ description: "çŒ«ã®åå‰", example: "Jolly Tokuichi" })
  @IsOptional()
  @IsString()
  @MaxLength(200)
  catName?: string;

  @ApiPropertyOptional({ description: "ã‚­ãƒ£ãƒƒãƒ†ãƒªãƒ¼å", example: "Jolly Tokuichi" })
  @IsOptional()
  @IsString()
  @MaxLength(200)
  catName2?: string;

  @ApiPropertyOptional({ description: "å“ç¨®ã‚³ãƒ¼ãƒ‰", example: 92 })
  @IsOptional()
  @IsInt()
  @Type(() => Number)
  breedCode?: number;

  @ApiPropertyOptional({ description: "æ€§åˆ¥ã‚³ãƒ¼ãƒ‰ (1: ã‚ªã‚¹, 2: ãƒ¡ã‚¹)", example: 1 })
  @IsOptional()
  @IsInt()
  @Type(() => Number)
  genderCode?: number;

  @ApiPropertyOptional({ description: "ç›®ã®è‰²", example: "Gold" })
  @IsOptional()
  @IsString()
  @MaxLength(50)
  eyeColor?: string;

  @ApiPropertyOptional({ description: "æ¯›è‰²ã‚³ãƒ¼ãƒ‰", example: 190 })
  @IsOptional()
  @IsInt()
  @Type(() => Number)
  coatColorCode?: number;

  @ApiPropertyOptional({ description: "ç”Ÿå¹´æœˆæ—¥", example: "2019-01-05" })
  @IsOptional()
  @IsString()
  birthDate?: string;

  @ApiPropertyOptional({ description: "ãƒ–ãƒªãƒ¼ãƒ€ãƒ¼å", example: "Hayato Inami" })
  @IsOptional()
  @IsString()
  @MaxLength(200)
  breederName?: string;

  @ApiPropertyOptional({ description: "ã‚ªãƒ¼ãƒŠãƒ¼å", example: "Hayato Inami" })
  @IsOptional()
  @IsString()
  @MaxLength(200)
  ownerName?: string;

  @ApiPropertyOptional({ description: "ç™»éŒ²å¹´æœˆæ—¥", example: "2022-02-22" })
  @IsOptional()
  @IsString()
  registrationDate?: string;

  @ApiPropertyOptional({ description: "å…„å¼Ÿã®äººæ•°", example: 2 })
  @IsOptional()
  @IsInt()
  @Type(() => Number)
  brotherCount?: number;

  @ApiPropertyOptional({ description: "å§‰å¦¹ã®äººæ•°", example: 2 })
  @IsOptional()
  @IsInt()
  @Type(() => Number)
  sisterCount?: number;

  @ApiPropertyOptional({ description: "å‚™è€ƒ" })
  @IsOptional()
  @IsString()
  @MaxLength(1000)
  notes?: string;

  @ApiPropertyOptional({ description: "å‚™è€ƒï¼’" })
  @IsOptional()
  @IsString()
  @MaxLength(1000)
  notes2?: string;

  @ApiPropertyOptional({ description: "ä»–å›£ä½“No", example: "921901-700545" })
  @IsOptional()
  @IsString()
  @MaxLength(100)
  otherNo?: string;

  // ==================== è¡€çµ±æƒ…å ±ï¼ˆ62é …ç›®ï¼‰====================
  
  // ç¬¬1ä¸–ä»£: çˆ¶è¦ªï¼ˆ7é …ç›®ï¼‰
  @ApiPropertyOptional({ description: "çˆ¶è¦ªã‚¿ã‚¤ãƒˆãƒ«" })
  @IsOptional()
  @IsString()
  fatherTitle?: string;

  @ApiPropertyOptional({ description: "çˆ¶è¦ªå" })
  @IsOptional()
  @IsString()
  fatherCatName?: string;

  @ApiPropertyOptional({ description: "çˆ¶è¦ªã‚­ãƒ£ãƒƒãƒ†ãƒªãƒ¼å" })
  @IsOptional()
  @IsString()
  fatherCatName2?: string;

  @ApiPropertyOptional({ description: "çˆ¶è¦ªæ¯›è‰²" })
  @IsOptional()
  @IsString()
  fatherCoatColor?: string;

  @ApiPropertyOptional({ description: "çˆ¶è¦ªç›®ã®è‰²" })
  @IsOptional()
  @IsString()
  fatherEyeColor?: string;

  @ApiPropertyOptional({ description: "çˆ¶è¦ªJCUç•ªå·" })
  @IsOptional()
  @IsString()
  fatherJCU?: string;

  @ApiPropertyOptional({ description: "çˆ¶è¦ªä»–å›£ä½“ã‚³ãƒ¼ãƒ‰" })
  @IsOptional()
  @IsString()
  fatherOtherCode?: string;

  // ç¬¬1ä¸–ä»£: æ¯è¦ªï¼ˆ7é …ç›®ï¼‰
  @ApiPropertyOptional({ description: "æ¯è¦ªã‚¿ã‚¤ãƒˆãƒ«" })
  @IsOptional()
  @IsString()
  motherTitle?: string;

  @ApiPropertyOptional({ description: "æ¯è¦ªå" })
  @IsOptional()
  @IsString()
  motherCatName?: string;

  @ApiPropertyOptional({ description: "æ¯è¦ªã‚­ãƒ£ãƒƒãƒ†ãƒªãƒ¼å" })
  @IsOptional()
  @IsString()
  motherCatName2?: string;

  @ApiPropertyOptional({ description: "æ¯è¦ªæ¯›è‰²" })
  @IsOptional()
  @IsString()
  motherCoatColor?: string;

  @ApiPropertyOptional({ description: "æ¯è¦ªç›®ã®è‰²" })
  @IsOptional()
  @IsString()
  motherEyeColor?: string;

  @ApiPropertyOptional({ description: "æ¯è¦ªJCUç•ªå·" })
  @IsOptional()
  @IsString()
  motherJCU?: string;

  @ApiPropertyOptional({ description: "æ¯è¦ªä»–å›£ä½“ã‚³ãƒ¼ãƒ‰" })
  @IsOptional()
  @IsString()
  motherOtherCode?: string;

  // ç¬¬2ä¸–ä»£: çˆ¶æ–¹ç¥–çˆ¶ï¼ˆ4é …ç›®ï¼‰
  @ApiPropertyOptional({ description: "çˆ¶æ–¹ç¥–çˆ¶ã‚¿ã‚¤ãƒˆãƒ«" })
  @IsOptional()
  @IsString()
  ffTitle?: string;

  @ApiPropertyOptional({ description: "çˆ¶æ–¹ç¥–çˆ¶å" })
  @IsOptional()
  @IsString()
  ffCatName?: string;

  @ApiPropertyOptional({ description: "çˆ¶æ–¹ç¥–çˆ¶æ¯›è‰²" })
  @IsOptional()
  @IsString()
  ffCatColor?: string;

  @ApiPropertyOptional({ description: "çˆ¶æ–¹ç¥–çˆ¶JCU" })
  @IsOptional()
  @IsString()
  ffjcu?: string;

  // ç¬¬2ä¸–ä»£: çˆ¶æ–¹ç¥–æ¯ï¼ˆ4é …ç›®ï¼‰
  @ApiPropertyOptional({ description: "çˆ¶æ–¹ç¥–æ¯ã‚¿ã‚¤ãƒˆãƒ«" })
  @IsOptional()
  @IsString()
  fmTitle?: string;

  @ApiPropertyOptional({ description: "çˆ¶æ–¹ç¥–æ¯å" })
  @IsOptional()
  @IsString()
  fmCatName?: string;

  @ApiPropertyOptional({ description: "çˆ¶æ–¹ç¥–æ¯æ¯›è‰²" })
  @IsOptional()
  @IsString()
  fmCatColor?: string;

  @ApiPropertyOptional({ description: "çˆ¶æ–¹ç¥–æ¯JCU" })
  @IsOptional()
  @IsString()
  fmjcu?: string;

  // ç¬¬2ä¸–ä»£: æ¯æ–¹ç¥–çˆ¶ï¼ˆ4é …ç›®ï¼‰
  @ApiPropertyOptional({ description: "æ¯æ–¹ç¥–çˆ¶ã‚¿ã‚¤ãƒˆãƒ«" })
  @IsOptional()
  @IsString()
  mfTitle?: string;

  @ApiPropertyOptional({ description: "æ¯æ–¹ç¥–çˆ¶å" })
  @IsOptional()
  @IsString()
  mfCatName?: string;

  @ApiPropertyOptional({ description: "æ¯æ–¹ç¥–çˆ¶æ¯›è‰²" })
  @IsOptional()
  @IsString()
  mfCatColor?: string;

  @ApiPropertyOptional({ description: "æ¯æ–¹ç¥–çˆ¶JCU" })
  @IsOptional()
  @IsString()
  mfjcu?: string;

  // ç¬¬2ä¸–ä»£: æ¯æ–¹ç¥–æ¯ï¼ˆ4é …ç›®ï¼‰
  @ApiPropertyOptional({ description: "æ¯æ–¹ç¥–æ¯ã‚¿ã‚¤ãƒˆãƒ«" })
  @IsOptional()
  @IsString()
  mmTitle?: string;

  @ApiPropertyOptional({ description: "æ¯æ–¹ç¥–æ¯å" })
  @IsOptional()
  @IsString()
  mmCatName?: string;

  @ApiPropertyOptional({ description: "æ¯æ–¹ç¥–æ¯æ¯›è‰²" })
  @IsOptional()
  @IsString()
  mmCatColor?: string;

  @ApiPropertyOptional({ description: "æ¯æ–¹ç¥–æ¯JCU" })
  @IsOptional()
  @IsString()
  mmjcu?: string;

  // ç¬¬3ä¸–ä»£: çˆ¶çˆ¶çˆ¶ï¼ˆ4é …ç›®ï¼‰
  @ApiPropertyOptional({ description: "çˆ¶çˆ¶çˆ¶ã‚¿ã‚¤ãƒˆãƒ«" })
  @IsOptional()
  @IsString()
  fffTitle?: string;

  @ApiPropertyOptional({ description: "çˆ¶çˆ¶çˆ¶å" })
  @IsOptional()
  @IsString()
  fffCatName?: string;

  @ApiPropertyOptional({ description: "çˆ¶çˆ¶çˆ¶æ¯›è‰²" })
  @IsOptional()
  @IsString()
  fffCatColor?: string;

  @ApiPropertyOptional({ description: "çˆ¶çˆ¶çˆ¶JCU" })
  @IsOptional()
  @IsString()
  fffjcu?: string;

  // ç¬¬3ä¸–ä»£: çˆ¶çˆ¶æ¯ï¼ˆ4é …ç›®ï¼‰
  @ApiPropertyOptional({ description: "çˆ¶çˆ¶æ¯ã‚¿ã‚¤ãƒˆãƒ«" })
  @IsOptional()
  @IsString()
  ffmTitle?: string;

  @ApiPropertyOptional({ description: "çˆ¶çˆ¶æ¯å" })
  @IsOptional()
  @IsString()
  ffmCatName?: string;

  @ApiPropertyOptional({ description: "çˆ¶çˆ¶æ¯æ¯›è‰²" })
  @IsOptional()
  @IsString()
  ffmCatColor?: string;

  @ApiPropertyOptional({ description: "çˆ¶çˆ¶æ¯JCU" })
  @IsOptional()
  @IsString()
  ffmjcu?: string;

  // ç¬¬3ä¸–ä»£: çˆ¶æ¯çˆ¶ï¼ˆ4é …ç›®ï¼‰
  @ApiPropertyOptional({ description: "çˆ¶æ¯çˆ¶ã‚¿ã‚¤ãƒˆãƒ«" })
  @IsOptional()
  @IsString()
  fmfTitle?: string;

  @ApiPropertyOptional({ description: "çˆ¶æ¯çˆ¶å" })
  @IsOptional()
  @IsString()
  fmfCatName?: string;

  @ApiPropertyOptional({ description: "çˆ¶æ¯çˆ¶æ¯›è‰²" })
  @IsOptional()
  @IsString()
  fmfCatColor?: string;

  @ApiPropertyOptional({ description: "çˆ¶æ¯çˆ¶JCU" })
  @IsOptional()
  @IsString()
  fmfjcu?: string;

  // ç¬¬3ä¸–ä»£: çˆ¶æ¯æ¯ï¼ˆ4é …ç›®ï¼‰
  @ApiPropertyOptional({ description: "çˆ¶æ¯æ¯ã‚¿ã‚¤ãƒˆãƒ«" })
  @IsOptional()
  @IsString()
  fmmTitle?: string;

  @ApiPropertyOptional({ description: "çˆ¶æ¯æ¯å" })
  @IsOptional()
  @IsString()
  fmmCatName?: string;

  @ApiPropertyOptional({ description: "çˆ¶æ¯æ¯æ¯›è‰²" })
  @IsOptional()
  @IsString()
  fmmCatColor?: string;

  @ApiPropertyOptional({ description: "çˆ¶æ¯æ¯JCU" })
  @IsOptional()
  @IsString()
  fmmjcu?: string;

  // ç¬¬3ä¸–ä»£: æ¯çˆ¶çˆ¶ï¼ˆ4é …ç›®ï¼‰
  @ApiPropertyOptional({ description: "æ¯çˆ¶çˆ¶ã‚¿ã‚¤ãƒˆãƒ«" })
  @IsOptional()
  @IsString()
  mffTitle?: string;

  @ApiPropertyOptional({ description: "æ¯çˆ¶çˆ¶å" })
  @IsOptional()
  @IsString()
  mffCatName?: string;

  @ApiPropertyOptional({ description: "æ¯çˆ¶çˆ¶æ¯›è‰²" })
  @IsOptional()
  @IsString()
  mffCatColor?: string;

  @ApiPropertyOptional({ description: "æ¯çˆ¶çˆ¶JCU" })
  @IsOptional()
  @IsString()
  mffjcu?: string;

  // ç¬¬3ä¸–ä»£: æ¯çˆ¶æ¯ï¼ˆ4é …ç›®ï¼‰
  @ApiPropertyOptional({ description: "æ¯çˆ¶æ¯ã‚¿ã‚¤ãƒˆãƒ«" })
  @IsOptional()
  @IsString()
  mfmTitle?: string;

  @ApiPropertyOptional({ description: "æ¯çˆ¶æ¯å" })
  @IsOptional()
  @IsString()
  mfmCatName?: string;

  @ApiPropertyOptional({ description: "æ¯çˆ¶æ¯æ¯›è‰²" })
  @IsOptional()
  @IsString()
  mfmCatColor?: string;

  @ApiPropertyOptional({ description: "æ¯çˆ¶æ¯JCU" })
  @IsOptional()
  @IsString()
  mfmjcu?: string;

  // ç¬¬3ä¸–ä»£: æ¯æ¯çˆ¶ï¼ˆ4é …ç›®ï¼‰
  @ApiPropertyOptional({ description: "æ¯æ¯çˆ¶ã‚¿ã‚¤ãƒˆãƒ«" })
  @IsOptional()
  @IsString()
  mmfTitle?: string;

  @ApiPropertyOptional({ description: "æ¯æ¯çˆ¶å" })
  @IsOptional()
  @IsString()
  mmfCatName?: string;

  @ApiPropertyOptional({ description: "æ¯æ¯çˆ¶æ¯›è‰²" })
  @IsOptional()
  @IsString()
  mmfCatColor?: string;

  @ApiPropertyOptional({ description: "æ¯æ¯çˆ¶JCU" })
  @IsOptional()
  @IsString()
  mmfjcu?: string;

  // ç¬¬3ä¸–ä»£: æ¯æ¯æ¯ï¼ˆ4é …ç›®ï¼‰
  @ApiPropertyOptional({ description: "æ¯æ¯æ¯ã‚¿ã‚¤ãƒˆãƒ«" })
  @IsOptional()
  @IsString()
  mmmTitle?: string;

  @ApiPropertyOptional({ description: "æ¯æ¯æ¯å" })
  @IsOptional()
  @IsString()
  mmmCatName?: string;

  @ApiPropertyOptional({ description: "æ¯æ¯æ¯æ¯›è‰²" })
  @IsOptional()
  @IsString()
  mmmCatColor?: string;

  @ApiPropertyOptional({ description: "æ¯æ¯æ¯JCU" })
  @IsOptional()
  @IsString()
  mmmjcu?: string;

  // ãã®ä»–
  @ApiPropertyOptional({ description: "æ—§ã‚³ãƒ¼ãƒ‰" })
  @IsOptional()
  @IsString()
  @MaxLength(50)
  oldCode?: string;
}
`````

## File: backend/src/pedigree/dto/index.ts
`````typescript
export * from "./create-pedigree.dto";
export * from "./update-pedigree.dto";
export * from "./pedigree-query.dto";
`````

## File: backend/src/pedigree/dto/pedigree-query.dto.ts
`````typescript
import { ApiPropertyOptional } from "@nestjs/swagger";
import { Type } from "class-transformer";
import { IsOptional, IsString, IsInt, IsIn } from "class-validator";

export class PedigreeQueryDto {
  @ApiPropertyOptional({ description: "ãƒšãƒ¼ã‚¸ç•ªå·", default: 1 })
  @IsOptional()
  @IsInt()
  @Type(() => Number)
  page?: number = 1;

  @ApiPropertyOptional({ description: "1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•°", default: 10 })
  @IsOptional()
  @IsInt()
  @Type(() => Number)
  limit?: number = 10;

  @ApiPropertyOptional({ description: "æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰" })
  @IsOptional()
  @IsString()
  search?: string;

  @ApiPropertyOptional({ description: "å“ç¨®ID" })
  @IsOptional()
  @IsString()
  breedId?: string;

  @ApiPropertyOptional({ description: "æ¯›è‰²ID" })
  @IsOptional()
  @IsString()
  coatColorId?: string;

  @ApiPropertyOptional({ description: "æ€§åˆ¥ (1: ã‚ªã‚¹, 2: ãƒ¡ã‚¹)" })
  @IsOptional()
  @IsString()
  gender?: string;

  @ApiPropertyOptional({ description: "ã‚­ãƒ£ãƒƒãƒ†ãƒªãƒ¼å" })
  @IsOptional()
  @IsString()
  catName2?: string;

  @ApiPropertyOptional({ description: "ç›®ã®è‰²" })
  @IsOptional()
  @IsString()
  eyeColor?: string;

  @ApiPropertyOptional({ description: "ã‚½ãƒ¼ãƒˆé …ç›®", default: "createdAt" })
  @IsOptional()
  @IsString()
  @IsIn(["createdAt", "catName", "birthDate", "pedigreeIssueDate"])
  sortBy?: string = "createdAt";

  @ApiPropertyOptional({ description: "ã‚½ãƒ¼ãƒˆé †", default: "desc" })
  @IsOptional()
  @IsString()
  @IsIn(["asc", "desc"])
  sortOrder?: "asc" | "desc" = "desc";
}
`````

## File: backend/src/pedigree/dto/update-pedigree.dto.ts
`````typescript
import { PartialType } from "@nestjs/mapped-types";

import { CreatePedigreeDto } from "./create-pedigree.dto";

export class UpdatePedigreeDto extends PartialType(CreatePedigreeDto) {}
`````

## File: backend/src/pedigree/pdf/pedigree-pdf.service.ts
`````typescript
import * as fsModule from 'fs';
import * as path from 'path';

import { Injectable, NotFoundException } from '@nestjs/common';
import type { Pedigree } from '@prisma/client';
// eslint-disable-next-line @typescript-eslint/no-require-imports -- pdfmakeã¯CommonJSãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãŸã‚requireãŒå¿…è¦
import PdfPrinter = require('pdfmake');
import type { TDocumentDefinitions, TFontDictionary, Content } from 'pdfmake/interfaces';

import { PrismaService } from '../../prisma/prisma.service';

import { Position, PositionsConfig, PrintSettingsService } from './print-settings.service';

/**
 * è¡€çµ±æ›¸PDFç”Ÿæˆã‚µãƒ¼ãƒ“ã‚¹ï¼ˆãƒ•ã‚©ãƒ¼ãƒ å°å­—ãƒ¢ãƒ¼ãƒ‰ï¼‰
 *
 * æ—¢å­˜ã®WCAè¡€çµ±æ›¸ç”¨ç´™ã«ã€Œå€¤ã®ã¿ã€ã‚’å°åˆ·ã™ã‚‹
 * - ç”¨ç´™ã‚µã‚¤ã‚º: 339mm Ã— 228mmï¼ˆæ¨ªé•·ï¼‰
 * - èƒŒæ™¯ãƒ»ç½«ç·šãƒ»ãƒ©ãƒ™ãƒ«ã¯å°åˆ·ã—ãªã„
 * - å€¤ã‚’çµ¶å¯¾åº§æ¨™ã§é…ç½®
 * - åº§æ¨™ã¯DBã«ä¿å­˜ã•ã‚ŒãŸå°åˆ·è¨­å®šã‚’æ¯å›èª­ã¿è¾¼ã¿ï¼ˆå†èµ·å‹•ä¸è¦ã§èª¿æ•´å¯èƒ½ï¼‰
 */
@Injectable()
export class PedigreePdfService {
  private printer: PdfPrinter;

  // mm to points å¤‰æ›ä¿‚æ•°ï¼ˆ1mm = 2.83465ptï¼‰
  private readonly MM_TO_PT = 2.83465;

  // ãƒšãƒ¼ã‚¸è¨­å®š
  private readonly PAGE_WIDTH = 339; // mm
  private readonly PAGE_HEIGHT = 228; // mm

  constructor(
    private readonly prisma: PrismaService,
    private readonly printSettingsService: PrintSettingsService,
  ) {
    const fonts: TFontDictionary = {
      Helvetica: {
        normal: 'Helvetica',
        bold: 'Helvetica-Bold',
        italics: 'Helvetica-Oblique',
        bolditalics: 'Helvetica-BoldOblique',
      },
    };
    this.printer = new PdfPrinter(fonts);
  }

  private resolvePdfAssetPath(fileName: string): string {
    const candidates = [
      path.join(__dirname, fileName),
      // nest start --watch ç­‰ã§å®Ÿè¡Œæ™‚ã® __dirname ã¨ã‚¢ã‚»ãƒƒãƒˆé…ç½®ãŒã‚ºãƒ¬ã‚‹å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
      path.join(process.cwd(), 'src', 'pedigree', 'pdf', fileName),
      path.join(process.cwd(), 'backend', 'src', 'pedigree', 'pdf', fileName),
    ];

    for (const candidate of candidates) {
      if (fsModule.existsSync(candidate)) {
        return candidate;
      }
    }

    return candidates[0];
  }

  /**
   * DBã‹ã‚‰åº§æ¨™è¨­å®šã‚’èª­ã¿è¾¼ã‚€ï¼ˆPrintSettingsServiceçµŒç”±ã€æ¯å›èª­ã¿è¾¼ã¿ãƒ»ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãªã—ï¼‰
   */
  private async loadPositions(): Promise<PositionsConfig> {
    return this.printSettingsService.getSettings();
  }

  /**
   * è¡€çµ±æ›¸IDã‹ã‚‰PDFã‚’ç”Ÿæˆï¼ˆãƒ•ã‚©ãƒ¼ãƒ å°å­—ãƒ¢ãƒ¼ãƒ‰ï¼‰
   * @param debugMode trueã®å ´åˆã€èƒŒæ™¯ã«è¡€çµ±æ›¸ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”»åƒã‚’åŠé€æ˜ã§è¡¨ç¤ºï¼ˆåº§æ¨™èª¿æ•´ç”¨ï¼‰
   */
  async generatePdf(pedigreeId: string, debugMode = false): Promise<Buffer> {
    const pedigree = await this.prisma.pedigree.findFirst({
      where: { pedigreeId },
    });

    if (!pedigree) {
      throw new NotFoundException(`è¡€çµ±æ›¸IDã€Œ${pedigreeId}ã€ã®ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
    }

    const masterData = await this.fetchMasterData(pedigree);
    const docDefinition = await this.buildFormOverlayDocument(pedigree, masterData, debugMode);

    return this.createPdfBuffer(docDefinition);
  }

  /**
   * PDFã‚’Base64å½¢å¼ã§å–å¾—
   */
  async generateBase64(pedigreeId: string): Promise<string> {
    const pdfBuffer = await this.generatePdf(pedigreeId);
    return pdfBuffer.toString('base64');
  }

  /**
   * ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
   */
  private async fetchMasterData(
    pedigree: Pedigree,
  ): Promise<{ breedName: string; genderName: string; coatColorName: string }> {
    let breedName = '';
    let genderName = '';
    let coatColorName = '';

    if (pedigree.breedCode) {
      const breed = await this.prisma.breed.findFirst({
        where: { code: pedigree.breedCode },
      });
      breedName = breed?.name || String(pedigree.breedCode);
    }

    if (pedigree.genderCode) {
      const gender = await this.prisma.gender.findFirst({
        where: { code: pedigree.genderCode },
      });
      genderName = gender?.name || String(pedigree.genderCode);
    }

    if (pedigree.coatColorCode) {
      const coatColor = await this.prisma.coatColor.findFirst({
        where: { code: pedigree.coatColorCode },
      });
      coatColorName = coatColor?.name || String(pedigree.coatColorCode);
    }

    return { breedName, genderName, coatColorName };
  }

  /**
   * ãƒ•ã‚©ãƒ¼ãƒ å°å­—ç”¨ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’æ§‹ç¯‰ï¼ˆå€¤ã®ã¿é…ç½®ï¼‰
   * @param debugMode trueã®å ´åˆã€èƒŒæ™¯ç”»åƒã‚’è¡¨ç¤º
   */
  private async buildFormOverlayDocument(
    pedigree: Pedigree,
    masterData: { breedName: string; genderName: string; coatColorName: string },
    debugMode = false,
  ): Promise<TDocumentDefinitions> {
    const config = await this.loadPositions();
    const content: Content[] = [];
    const fs = config.fontSizes;

    // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰: èƒŒæ™¯ç”»åƒã‚’åŠé€æ˜ã§è¡¨ç¤º
    if (debugMode) {
      const templatePath = this.resolvePdfAssetPath('è¡€çµ±æ›¸è¦‹æœ¬.png');
      if (fsModule.existsSync(templatePath)) {
        const imageData = fsModule.readFileSync(templatePath);
        const base64Image = imageData.toString('base64');
        content.push({
          image: `data:image/png;base64,${base64Image}`,
          width: this.PAGE_WIDTH * this.MM_TO_PT,
          height: this.PAGE_HEIGHT * this.MM_TO_PT,
          absolutePosition: { x: 0, y: 0 },
          opacity: 0.3,
        } as Content);
      }
    }

    // === ãƒ˜ãƒƒãƒ€ãƒ¼æƒ…å ±ï¼ˆå·¦å´ï¼‰===
    content.push(this.absoluteText(masterData.breedName, config.breed, config.offsetX, config.offsetY, fs.headerInfo));
    content.push(this.absoluteText(masterData.genderName, config.sex, config.offsetX, config.offsetY, fs.headerInfo));
    content.push(this.absoluteText(this.formatDate(pedigree.birthDate), config.dateOfBirth, config.offsetX, config.offsetY, fs.headerInfo));
    content.push(this.absoluteText(pedigree.eyeColor || '', config.eyeColor, config.offsetX, config.offsetY, fs.headerInfo));
    content.push(this.absoluteText(masterData.coatColorName, config.color, config.offsetX, config.offsetY, fs.headerInfo));

    // === ä¸­å¤®ã‚¨ãƒªã‚¢ ===
    const catName = this.formatCatName(pedigree.title, pedigree.catName, pedigree.catName2);
    content.push(this.absoluteText(catName, config.catName, config.offsetX, config.offsetY, fs.catName, 'center'));
    content.push(this.absoluteText(pedigree.pedigreeId, config.wcaNo, config.offsetX, config.offsetY, fs.wcaNo, 'center'));

    // === ãƒ˜ãƒƒãƒ€ãƒ¼æƒ…å ±ï¼ˆå³å´ï¼‰===
    content.push(this.absoluteText(pedigree.ownerName || '', config.owner, config.offsetX, config.offsetY, fs.headerInfo, 'right'));
    content.push(this.absoluteText(pedigree.breederName || '', config.breeder, config.offsetX, config.offsetY, fs.headerInfo, 'right'));
    content.push(this.absoluteText(this.formatDate(pedigree.registrationDate), config.dateOfRegistration, config.offsetX, config.offsetY, fs.headerInfo));
    content.push(this.absoluteText(String(pedigree.brotherCount || ''), config.littersM, config.offsetX, config.offsetY, fs.headerInfo));
    content.push(this.absoluteText(String(pedigree.sisterCount || ''), config.littersF, config.offsetX, config.offsetY, fs.headerInfo));

    // === PARENTS: SIREï¼ˆçˆ¶ï¼‰===
    content.push(this.absoluteText(
      this.formatCatName(pedigree.fatherTitle, pedigree.fatherCatName, pedigree.fatherCatName2),
      config.sire.name, config.offsetX, config.offsetY, fs.parentName, 'left', true
    ));
    content.push(this.absoluteText(pedigree.fatherCoatColor || '', config.sire.color, config.offsetX, config.offsetY, fs.parentDetail));
    if (config.sire.eyeColor) {
      content.push(this.absoluteText(pedigree.fatherEyeColor || '', config.sire.eyeColor, config.offsetX, config.offsetY, fs.parentDetail));
    }
    content.push(this.absoluteText(pedigree.fatherJCU || '', config.sire.jcu, config.offsetX, config.offsetY, fs.parentDetail));

    // === PARENTS: DAMï¼ˆæ¯ï¼‰===
    content.push(this.absoluteText(
      this.formatCatName(pedigree.motherTitle, pedigree.motherCatName, pedigree.motherCatName2),
      config.dam.name, config.offsetX, config.offsetY, fs.parentName, 'left', true
    ));
    content.push(this.absoluteText(pedigree.motherCoatColor || '', config.dam.color, config.offsetX, config.offsetY, fs.parentDetail));
    if (config.dam.eyeColor) {
      content.push(this.absoluteText(pedigree.motherEyeColor || '', config.dam.eyeColor, config.offsetX, config.offsetY, fs.parentDetail));
    }
    content.push(this.absoluteText(pedigree.motherJCU || '', config.dam.jcu, config.offsetX, config.offsetY, fs.parentDetail));

    // === GRAND PARENTS ===
    const gp = config.grandParents;
    // 3: ffï¼ˆçˆ¶ã®çˆ¶ï¼‰
    content.push(this.absoluteText(this.formatCatName(pedigree.ffTitle, pedigree.ffCatName, null), gp.ff.name, config.offsetX, config.offsetY, fs.grandParentName));
    content.push(this.absoluteText(pedigree.ffCatColor || '', gp.ff.color, config.offsetX, config.offsetY, fs.grandParentDetail));
    content.push(this.absoluteText(pedigree.ffjcu || '', gp.ff.jcu, config.offsetX, config.offsetY, fs.grandParentDetail));
    // 4: fmï¼ˆçˆ¶ã®æ¯ï¼‰
    content.push(this.absoluteText(this.formatCatName(pedigree.fmTitle, pedigree.fmCatName, null), gp.fm.name, config.offsetX, config.offsetY, fs.grandParentName));
    content.push(this.absoluteText(pedigree.fmCatColor || '', gp.fm.color, config.offsetX, config.offsetY, fs.grandParentDetail));
    content.push(this.absoluteText(pedigree.fmjcu || '', gp.fm.jcu, config.offsetX, config.offsetY, fs.grandParentDetail));
    // 5: mfï¼ˆæ¯ã®çˆ¶ï¼‰
    content.push(this.absoluteText(this.formatCatName(pedigree.mfTitle, pedigree.mfCatName, null), gp.mf.name, config.offsetX, config.offsetY, fs.grandParentName));
    content.push(this.absoluteText(pedigree.mfCatColor || '', gp.mf.color, config.offsetX, config.offsetY, fs.grandParentDetail));
    content.push(this.absoluteText(pedigree.mfjcu || '', gp.mf.jcu, config.offsetX, config.offsetY, fs.grandParentDetail));
    // 6: mmï¼ˆæ¯ã®æ¯ï¼‰
    content.push(this.absoluteText(this.formatCatName(pedigree.mmTitle, pedigree.mmCatName, null), gp.mm.name, config.offsetX, config.offsetY, fs.grandParentName));
    content.push(this.absoluteText(pedigree.mmCatColor || '', gp.mm.color, config.offsetX, config.offsetY, fs.grandParentDetail));
    content.push(this.absoluteText(pedigree.mmjcu || '', gp.mm.jcu, config.offsetX, config.offsetY, fs.grandParentDetail));

    // === GREAT GRAND PARENTS ===
    const ggp = config.greatGrandParents;
    // 7: fff
    content.push(this.absoluteText(this.formatCatName(pedigree.fffTitle, pedigree.fffCatName, null), ggp.fff.name, config.offsetX, config.offsetY, fs.greatGrandParent));
    content.push(this.absoluteText(pedigree.fffjcu || '', ggp.fff.jcu, config.offsetX, config.offsetY, fs.greatGrandParent));
    // 8: ffm
    content.push(this.absoluteText(this.formatCatName(pedigree.ffmTitle, pedigree.ffmCatName, null), ggp.ffm.name, config.offsetX, config.offsetY, fs.greatGrandParent));
    content.push(this.absoluteText(pedigree.ffmjcu || '', ggp.ffm.jcu, config.offsetX, config.offsetY, fs.greatGrandParent));
    // 9: fmf
    content.push(this.absoluteText(this.formatCatName(pedigree.fmfTitle, pedigree.fmfCatName, null), ggp.fmf.name, config.offsetX, config.offsetY, fs.greatGrandParent));
    content.push(this.absoluteText(pedigree.fmfjcu || '', ggp.fmf.jcu, config.offsetX, config.offsetY, fs.greatGrandParent));
    // 10: fmm
    content.push(this.absoluteText(this.formatCatName(pedigree.fmmTitle, pedigree.fmmCatName, null), ggp.fmm.name, config.offsetX, config.offsetY, fs.greatGrandParent));
    content.push(this.absoluteText(pedigree.fmmjcu || '', ggp.fmm.jcu, config.offsetX, config.offsetY, fs.greatGrandParent));
    // 11: mff
    content.push(this.absoluteText(this.formatCatName(pedigree.mffTitle, pedigree.mffCatName, null), ggp.mff.name, config.offsetX, config.offsetY, fs.greatGrandParent));
    content.push(this.absoluteText(pedigree.mffjcu || '', ggp.mff.jcu, config.offsetX, config.offsetY, fs.greatGrandParent));
    // 12: mfm
    content.push(this.absoluteText(this.formatCatName(pedigree.mfmTitle, pedigree.mfmCatName, null), ggp.mfm.name, config.offsetX, config.offsetY, fs.greatGrandParent));
    content.push(this.absoluteText(pedigree.mfmjcu || '', ggp.mfm.jcu, config.offsetX, config.offsetY, fs.greatGrandParent));
    // 13: mmf
    content.push(this.absoluteText(this.formatCatName(pedigree.mmfTitle, pedigree.mmfCatName, null), ggp.mmf.name, config.offsetX, config.offsetY, fs.greatGrandParent));
    content.push(this.absoluteText(pedigree.mmfjcu || '', ggp.mmf.jcu, config.offsetX, config.offsetY, fs.greatGrandParent));
    // 14: mmm
    content.push(this.absoluteText(this.formatCatName(pedigree.mmmTitle, pedigree.mmmCatName, null), ggp.mmm.name, config.offsetX, config.offsetY, fs.greatGrandParent));
    content.push(this.absoluteText(pedigree.mmmjcu || '', ggp.mmm.jcu, config.offsetX, config.offsetY, fs.greatGrandParent));

    // === ãƒ•ãƒƒã‚¿ãƒ¼ ===
    if (pedigree.otherNo) {
      content.push(this.absoluteText(pedigree.otherNo, config.otherOrganizationsNo, config.offsetX, config.offsetY, fs.footer));
    }

    return {
      pageSize: {
        width: this.PAGE_WIDTH * this.MM_TO_PT,
        height: this.PAGE_HEIGHT * this.MM_TO_PT,
      },
      pageOrientation: 'landscape',
      pageMargins: [0, 0, 0, 0], // ãƒãƒ¼ã‚¸ãƒ³ãªã—ï¼ˆçµ¶å¯¾åº§æ¨™ã§é…ç½®ï¼‰
      defaultStyle: {
        font: 'Helvetica',
      },
      content,
    };
  }

  /**
   * çµ¶å¯¾åº§æ¨™ã§ãƒ†ã‚­ã‚¹ãƒˆã‚’é…ç½®
   * alignãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã§é…ç½®æ–¹æ³•ã‚’æŒ‡å®šå¯èƒ½ï¼ˆleft/center/rightï¼‰
   */
  private absoluteText(
    text: string,
    position: Position & { align?: 'left' | 'center' | 'right' },
    offsetX: number,
    offsetY: number,
    fontSize: number,
    _alignment: 'left' | 'center' | 'right' = 'left', // äº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼ˆposition.alignã‚’å„ªå…ˆï¼‰
    bold = false,
  ): Content {
    const align = position.align || 'left';
    let x = (position.x + offsetX) * this.MM_TO_PT;
    const y = (position.y + offsetY) * this.MM_TO_PT;

    // æ–‡å­—å¹…ã‚’æ¨å®šã—ã¦alignã«å¿œã˜ã¦èª¿æ•´
    if (align !== 'left' && text) {
      const textWidth = this.estimateTextWidth(text, fontSize);
      if (align === 'center') {
        x -= textWidth / 2;
      } else if (align === 'right') {
        x -= textWidth;
      }
    }

    return {
      text: text || '',
      fontSize,
      bold,
      absolutePosition: { x, y },
    };
  }

  /**
   * æ–‡å­—å¹…ã‚’æ¨å®šï¼ˆãƒã‚¤ãƒ³ãƒˆå˜ä½ï¼‰
   * è‹±æ•°å­—ã¨æ—¥æœ¬èªã§ä¿‚æ•°ã‚’å¤‰ãˆã¦è¨ˆç®—
   */
  private estimateTextWidth(text: string, fontSize: number): number {
    let width = 0;
    for (const char of text) {
      // ASCIIæ–‡å­—ï¼ˆè‹±æ•°å­—ãƒ»è¨˜å·ï¼‰ã¯ç‹­ã„ã€ãã‚Œä»¥å¤–ï¼ˆæ—¥æœ¬èªç­‰ï¼‰ã¯åºƒã„
      if (char.charCodeAt(0) < 128) {
        width += fontSize * 0.55; // è‹±æ•°å­—ã®å¹³å‡å¹…
      } else {
        width += fontSize * 1.0; // æ—¥æœ¬èªç­‰ã®å…¨è§’æ–‡å­—
      }
    }
    return width;
  }

  /**
   * Cat's Nameã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
   */
  private formatCatName(
    title: string | null,
    name: string | null,
    name2: string | null,
  ): string {
    const parts = [title, name, name2].filter(Boolean);
    return parts.join(' ') || '';
  }

  /**
   * æ—¥ä»˜ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼ˆYYYY.MM.DDå½¢å¼ï¼‰
   */
  private formatDate(date: Date | string | null): string {
    if (!date) return '';
    const d = typeof date === 'string' ? new Date(date) : date;
    const year = d.getFullYear();
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${year}.${month}.${day}`;
  }

  /**
   * PDFãƒãƒƒãƒ•ã‚¡ã‚’ç”Ÿæˆ
   */
  private createPdfBuffer(docDefinition: TDocumentDefinitions): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      try {
        const pdfDoc = this.printer.createPdfKitDocument(docDefinition);
        const chunks: Buffer[] = [];

        pdfDoc.on('data', (chunk: Buffer) => {
          chunks.push(chunk);
        });

        pdfDoc.on('end', () => {
          resolve(Buffer.concat(chunks));
        });

        pdfDoc.on('error', (err: Error) => {
          reject(err);
        });

        pdfDoc.end();
      } catch (error) {
        reject(error instanceof Error ? error : new Error(String(error)));
      }
    });
  }
}
`````

## File: backend/src/pedigree/pdf/positions.json
`````json
{
  "offsetX": 0,
  "offsetY": 0,
  
  "breed": { "x": 50, "y": 50 },
  "sex": { "x": 50, "y": 60 },
  "dateOfBirth": { "x": 77, "y": 60 },
  "eyeColor": { "x": 50, "y": 69 },
  "color": { "x": 77, "y": 69 },
  
  "catName": { "x": 170, "y": 55, "align": "center" },
  "wcaNo": { "x": 170, "y": 69, "align": "center" },
  
  "owner": { "x": 320, "y": 50, "align": "right" },
  "breeder": { "x": 320, "y": 60, "align": "right" },
  "dateOfRegistration": { "x": 240, "y": 69 },
  "littersM": { "x": 277, "y": 69 },
  "littersF": { "x": 285, "y": 69 },
  
  "sire": {
    "name": { "x": 50, "y": 110 },
    "color": { "x": 50, "y": 127 },
    "eyeColor": { "x": 50, "y": 132 },
    "jcu": { "x": 50, "y": 137 }
  },
  "dam": {
    "name": { "x": 50, "y": 160 },
    "color": { "x": 50, "y": 177 },
    "eyeColor": { "x": 50, "y": 182 },
    "jcu": { "x": 50, "y": 188 }
  },
  
  "grandParents": {
    "ff": { "name": { "x": 140, "y": 101 }, "color": { "x": 140, "y": 106 }, "jcu": { "x": 140, "y": 111 } },
    "fm": { "name": { "x": 140, "y": 127 }, "color": { "x": 140, "y": 132 }, "jcu": { "x": 140, "y": 137 } },
    "mf": { "name": { "x": 140, "y": 152 }, "color": { "x": 140, "y": 157 }, "jcu": { "x": 140, "y": 162 } },
    "mm": { "name": { "x": 140, "y": 178 }, "color": { "x": 140, "y": 183 }, "jcu": { "x": 140, "y": 188 } }
  },
  
  "greatGrandParents": {
    "fff": { "name": { "x": 232, "y": 94 }, "jcu": { "x": 232, "y": 98 } },
    "ffm": { "name": { "x": 232, "y": 107 }, "jcu": { "x": 232, "y": 111 } },
    "fmf": { "name": { "x": 232, "y": 120 }, "jcu": { "x": 232, "y": 124 } },
    "fmm": { "name": { "x": 232, "y": 133 }, "jcu": { "x": 232, "y": 137 } },
    "mff": { "name": { "x": 232, "y": 146 }, "jcu": { "x": 232, "y": 150 } },
    "mfm": { "name": { "x": 232, "y": 158 }, "jcu": { "x": 232, "y": 162 } },
    "mmf": { "name": { "x": 232, "y": 171 }, "jcu": { "x": 232, "y": 175 } },
    "mmm": { "name": { "x": 232, "y": 184 }, "jcu": { "x": 232, "y": 188 } }
  },
  
  "otherOrganizationsNo": { "x": 85, "y": 210 },
  
  "fontSizes": {
    "catName": 13,
    "wcaNo": 12,
    "headerInfo": 11,
    "parentName": 12,
    "parentDetail": 11,
    "grandParentName": 11,
    "grandParentDetail": 11,
    "greatGrandParent": 10,
    "footer": 7
  }
}
`````

## File: backend/src/pedigree/pdf/print-settings.service.ts
`````typescript
import { Injectable, InternalServerErrorException, Logger } from "@nestjs/common";
import { Prisma } from "@prisma/client";

import { PrismaService } from "../../prisma/prisma.service";

// åº§æ¨™è¨­å®šã®å‹å®šç¾©
export interface Position {
  x: number;
  y: number;
  align?: "left" | "center" | "right";
}

export interface ParentPositions {
  name: Position;
  color: Position;
  eyeColor?: Position;
  jcu: Position;
}

export interface GrandParentPositions {
  name: Position;
  color: Position;
  jcu: Position;
}

export interface GreatGrandParentPositions {
  name: Position;
  jcu: Position;
}

export interface FontSizes {
  catName: number;
  wcaNo: number;
  headerInfo: number;
  parentName: number;
  parentDetail: number;
  grandParentName: number;
  grandParentDetail: number;
  greatGrandParent: number;
  footer: number;
}

export interface PositionsConfig {
  offsetX: number;
  offsetY: number;
  breed: Position;
  sex: Position;
  dateOfBirth: Position;
  eyeColor: Position;
  color: Position;
  catName: Position;
  wcaNo: Position;
  owner: Position;
  breeder: Position;
  dateOfRegistration: Position;
  littersM: Position;
  littersF: Position;
  sire: ParentPositions;
  dam: ParentPositions;
  grandParents: {
    ff: GrandParentPositions;
    fm: GrandParentPositions;
    mf: GrandParentPositions;
    mm: GrandParentPositions;
  };
  greatGrandParents: {
    fff: GreatGrandParentPositions;
    ffm: GreatGrandParentPositions;
    fmf: GreatGrandParentPositions;
    fmm: GreatGrandParentPositions;
    mff: GreatGrandParentPositions;
    mfm: GreatGrandParentPositions;
    mmf: GreatGrandParentPositions;
    mmm: GreatGrandParentPositions;
  };
  otherOrganizationsNo: Position;
  fontSizes: FontSizes;
}

@Injectable()
export class PrintSettingsService {
  private readonly logger = new Logger(PrintSettingsService.name);
  private readonly GLOBAL_KEY = "GLOBAL";

  private readonly defaultSettings: PositionsConfig = {
    offsetX: 0,
    offsetY: 0,
    breed: { x: 50, y: 50 },
    sex: { x: 50, y: 60 },
    dateOfBirth: { x: 77, y: 60 },
    eyeColor: { x: 50, y: 69 },
    color: { x: 77, y: 69 },
    catName: { x: 170, y: 55, align: "center" },
    wcaNo: { x: 170, y: 69, align: "center" },
    owner: { x: 320, y: 50, align: "right" },
    breeder: { x: 320, y: 60, align: "right" },
    dateOfRegistration: { x: 240, y: 69 },
    littersM: { x: 277, y: 69 },
    littersF: { x: 285, y: 69 },
    sire: {
      name: { x: 50, y: 110 },
      color: { x: 50, y: 127 },
      eyeColor: { x: 50, y: 132 },
      jcu: { x: 50, y: 137 },
    },
    dam: {
      name: { x: 50, y: 160 },
      color: { x: 50, y: 177 },
      eyeColor: { x: 50, y: 182 },
      jcu: { x: 50, y: 188 },
    },
    grandParents: {
      ff: { name: { x: 140, y: 101 }, color: { x: 140, y: 106 }, jcu: { x: 140, y: 111 } },
      fm: { name: { x: 140, y: 127 }, color: { x: 140, y: 132 }, jcu: { x: 140, y: 137 } },
      mf: { name: { x: 140, y: 152 }, color: { x: 140, y: 157 }, jcu: { x: 140, y: 162 } },
      mm: { name: { x: 140, y: 178 }, color: { x: 140, y: 183 }, jcu: { x: 140, y: 188 } },
    },
    greatGrandParents: {
      fff: { name: { x: 232, y: 94 }, jcu: { x: 232, y: 98 } },
      ffm: { name: { x: 232, y: 107 }, jcu: { x: 232, y: 111 } },
      fmf: { name: { x: 232, y: 120 }, jcu: { x: 232, y: 124 } },
      fmm: { name: { x: 232, y: 133 }, jcu: { x: 232, y: 137 } },
      mff: { name: { x: 232, y: 146 }, jcu: { x: 232, y: 150 } },
      mfm: { name: { x: 232, y: 158 }, jcu: { x: 232, y: 162 } },
      mmf: { name: { x: 232, y: 171 }, jcu: { x: 232, y: 175 } },
      mmm: { name: { x: 232, y: 184 }, jcu: { x: 232, y: 188 } },
    },
    otherOrganizationsNo: { x: 85, y: 210 },
    fontSizes: {
      catName: 13,
      wcaNo: 12,
      headerInfo: 11,
      parentName: 12,
      parentDetail: 11,
      grandParentName: 11,
      grandParentDetail: 11,
      greatGrandParent: 10,
      footer: 7,
    },
  };

  constructor(private readonly prisma: PrismaService) {}

  async getSettings(tenantId?: string): Promise<PositionsConfig> {
    try {
      const where = this.buildWhereClause(tenantId);
      const record = await this.prisma.pedigreePrintSetting.findUnique({ where });
      if (!record) {
        return this.defaultSettings;
      }
      return this.deserializeSettings(record.settings);
    } catch (error) {
      this.logger.error(
        "å°åˆ·è¨­å®šã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ",
        error instanceof Error ? error.stack : JSON.stringify(error),
      );
      throw new InternalServerErrorException("å°åˆ·è¨­å®šã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ");
    }
  }

  async updateSettings(settings: PositionsConfig, tenantId?: string): Promise<PositionsConfig> {
    try {
      const where = this.buildWhereClause(tenantId);
      const settingsJson = this.serializeSettings(settings);
      await this.prisma.pedigreePrintSetting.upsert({
        where,
        create: {
          tenantId: tenantId ?? null,
          globalKey: tenantId ? null : this.GLOBAL_KEY,
          settings: settingsJson,
        },
        update: {
          settings: settingsJson,
          version: { increment: 1 },
        },
      });
      return settings;
    } catch (error) {
      this.logger.error(
        "å°åˆ·è¨­å®šã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ",
        error instanceof Error ? error.stack : JSON.stringify(error),
      );
      throw new InternalServerErrorException("å°åˆ·è¨­å®šã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ");
    }
  }

  async resetToDefault(tenantId?: string): Promise<PositionsConfig> {
    return this.updateSettings(this.defaultSettings, tenantId);
  }

  /**
   * å°åˆ·è¨­å®šã®æ§‹é€ ã‚’æ¤œè¨¼ã™ã‚‹
   * @param value æ¤œè¨¼å¯¾è±¡ã®å€¤
   * @returns æœ‰åŠ¹ãª PositionsConfig ã§ã‚ã‚Œã° true
   */
  public isPositionsConfig(value: unknown): value is PositionsConfig {
    if (!value || typeof value !== "object" || Array.isArray(value)) {
      return false;
    }
    const record = value as Record<string, unknown>;

    // åŸºæœ¬çš„ãªæ•°å€¤ãƒ»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ãƒã‚§ãƒƒã‚¯
    if (typeof record.offsetX !== "number" || typeof record.offsetY !== "number") {
      return false;
    }
    if (typeof record.breed !== "object" || record.breed === null) {
      return false;
    }

    // PDF ç”Ÿæˆæ™‚ã«å¿…é ˆã¨ãªã‚‹ä¸»è¦ãªãƒã‚¹ãƒˆæ§‹é€ ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
    const requiredObjectKeys = [
      "sex",
      "dateOfBirth",
      "catName",
      "sire",
      "dam",
      "grandParents",
      "greatGrandParents",
      "fontSizes",
    ] as const;

    for (const key of requiredObjectKeys) {
      const v = record[key as string];
      if (typeof v !== "object" || v === null) {
        return false;
      }
    }

    return true;
  }

  private buildWhereClause(tenantId?: string): Prisma.PedigreePrintSettingWhereUniqueInput {
    if (tenantId) {
      return { tenantId };
    }
    return { globalKey: this.GLOBAL_KEY };
  }

  private deserializeSettings(value: Prisma.JsonValue | null): PositionsConfig {
    if (!value || !this.isPositionsConfig(value)) {
      return this.defaultSettings;
    }
    // Prisma ã® JsonValue ã¯ãƒ—ãƒ¬ãƒ¼ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆäº’æ›ã®ãŸã‚ã€ç›´æ¥ã‚­ãƒ£ã‚¹ãƒˆå¯èƒ½
    // TypeScript ã®å‹ãƒã‚§ãƒƒã‚¯ã‚’é€šéã™ã‚‹ãŸã‚ã€unknown ã‚’çµŒç”±ã—ã¦ã‚­ãƒ£ã‚¹ãƒˆ
    return value as unknown as PositionsConfig;
  }

  private serializeSettings(settings: PositionsConfig): Prisma.InputJsonValue {
    // Prisma ã® JsonValue/InputJsonValue ã¯ãƒ—ãƒ¬ãƒ¼ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆäº’æ›ã®ãŸã‚ã€ãã®ã¾ã¾ä¿å­˜ã™ã‚‹
    // TypeScript ã®å‹ãƒã‚§ãƒƒã‚¯ã‚’é€šéã™ã‚‹ãŸã‚ã€unknown ã‚’çµŒç”±ã—ã¦ã‚­ãƒ£ã‚¹ãƒˆ
    return settings as unknown as Prisma.InputJsonValue;
  }
}
`````

## File: backend/src/pedigree/types/pedigree.types.ts
`````typescript
import { Prisma } from "@prisma/client";

// Prisma ã®æ­£è¦ where å‹ã‚’ãã®ã¾ã¾åˆ©ç”¨ã—ã€æŸ”è»Ÿãªãƒ•ã‚£ãƒ«ã‚¿ã«å¯¾å¿œ
export type PedigreeWhereInput = Prisma.PedigreeWhereInput;

// Type for query building without any
export interface QueryFilterInput {
  [key: string]: string | undefined;
}

// Type for safe field mapping
export interface FieldMapping {
  [dtoField: string]: string; // Maps DTO field to database field
}

export const pedigreeWithRelationsInclude = Prisma.validator<Prisma.PedigreeInclude>()({
  breed: {
    select: {
      id: true,
      code: true,
      name: true,
    },
  },
  coatColor: {
    select: {
      id: true,
      code: true,
      name: true,
    },
  },
  gender: {
    select: {
      id: true,
      code: true,
      name: true,
    },
  },
});

// Pedigree with relationships for responses
export type PedigreeWithRelations = Prisma.PedigreeGetPayload<{
  include: typeof pedigreeWithRelationsInclude;
}>;

// API Response types
export interface PedigreeCreateResponse {
  success: true;
  data: PedigreeWithRelations;
}

export interface PedigreeListResponse {
  success: true;
  data: PedigreeWithRelations[];
  meta: {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
  };
}

// Type for family tree structure
// Pedigreeãƒ¢ãƒ‡ãƒ«ã¯è¡€çµ±æƒ…å ±ã‚’æ–‡å­—åˆ—ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¨ã—ã¦ä¿æŒã—ã¦ã„ã‚‹ãŸã‚ã€
// ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯ãªããƒ•ãƒ©ãƒƒãƒˆãªæ§‹é€ 
export type PedigreeTreeNode = Prisma.PedigreeGetPayload<{
  include: typeof pedigreeWithRelationsInclude;
}>;

export interface PedigreeSuccessResponse {
  success: true;
}
`````

## File: backend/src/pedigree/pedigree.controller.spec.ts
`````typescript
import { Test, TestingModule } from '@nestjs/testing';

import { getTestModuleImports, getTestModuleProviders } from '../test-utils/test-module-setup';

import { PedigreePdfService } from './pdf/pedigree-pdf.service';
import { PrintSettingsService } from './pdf/print-settings.service';
import { PedigreeController } from './pedigree.controller';
import { PedigreeService } from './pedigree.service';

describe('PedigreeController', () => {
  let controller: PedigreeController;
  let service: PedigreeService;

  const mockPedigreeService = {
    create: jest.fn(),
    findAll: jest.fn(),
    findOne: jest.fn(),
    update: jest.fn(),
    remove: jest.fn(),
    findByCat: jest.fn(),
  };

  const mockPedigreePdfService = {
    generatePdf: jest.fn(),
  };

  const mockPrintSettingsService = {
    getSettings: jest.fn(),
    updateSettings: jest.fn(),
    resetToDefault: jest.fn(),
    isPositionsConfig: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      imports: getTestModuleImports(),
      controllers: [PedigreeController],
      providers: [
        ...getTestModuleProviders(),
        {
          provide: PedigreeService,
          useValue: mockPedigreeService,
        },
        {
          provide: PedigreePdfService,
          useValue: mockPedigreePdfService,
        },
        {
          provide: PrintSettingsService,
          useValue: mockPrintSettingsService,
        },
      ],
    }).compile();

    controller = module.get<PedigreeController>(PedigreeController);
    service = module.get<PedigreeService>(PedigreeService);

    jest.clearAllMocks();
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });

  describe('create', () => {
    it('should create a pedigree record', async () => {
      const createDto = {
        pedigreeId: '700545',
        catName: 'Test Cat',
        breedCode: 92,
      };
      const mockPedigree = { id: '1', ...createDto };

      mockPedigreeService.create.mockResolvedValue(mockPedigree);

      const result = await controller.create(createDto);

      expect(result).toEqual(mockPedigree);
      expect(service.create).toHaveBeenCalledWith(createDto);
    });
  });

  describe('findAll', () => {
    it('should return paginated pedigree records', async () => {
      const mockResponse = {
        data: [{ id: '1', registrationNumber: 'PED-001' }],
        meta: { page: 1, limit: 10, total: 1, totalPages: 1 },
      };

      mockPedigreeService.findAll.mockResolvedValue(mockResponse);

      const result = await controller.findAll({});

      expect(result).toEqual(mockResponse);
      expect(service.findAll).toHaveBeenCalledWith({});
    });
  });

  describe('findOne', () => {
    it('should return a pedigree record by id', async () => {
      const mockPedigree = { id: '1', registrationNumber: 'PED-001' };

      mockPedigreeService.findOne.mockResolvedValue(mockPedigree);

      const result = await controller.findOne('1');

      expect(result).toEqual(mockPedigree);
      expect(service.findOne).toHaveBeenCalledWith('1');
    });
  });

  describe('update', () => {
    it('should update a pedigree record', async () => {
      const updateDto = { catName: 'Updated Cat Name', title: 'Champion' };
      const mockPedigree = { id: '1', ...updateDto };

      mockPedigreeService.update.mockResolvedValue(mockPedigree);

      const result = await controller.update('1', updateDto);

      expect(result).toEqual(mockPedigree);
      expect(service.update).toHaveBeenCalledWith('1', updateDto);
    });
  });

  describe('remove', () => {
    it('should delete a pedigree record', async () => {
      mockPedigreeService.remove.mockResolvedValue(undefined);

      await controller.remove('1');

      expect(service.remove).toHaveBeenCalledWith('1');
    });
  });

  describe('getPrintSettings', () => {
    it('should return print settings', async () => {
      const mockSettings = {
        offsetX: 0,
        offsetY: 0,
        breed: { x: 50, y: 50 },
        sex: { x: 50, y: 60 },
        dateOfBirth: { x: 77, y: 60 },
        catName: { x: 170, y: 55 },
        fontSizes: { catName: 13 },
      };

      mockPrintSettingsService.getSettings.mockResolvedValue(mockSettings);

      const result = await controller.getPrintSettings();

      expect(result).toEqual(mockSettings);
      expect(mockPrintSettingsService.getSettings).toHaveBeenCalled();
    });

    it('should handle service errors', async () => {
      mockPrintSettingsService.getSettings.mockRejectedValue(
        new Error('Database error'),
      );

      await expect(controller.getPrintSettings()).rejects.toThrow();
    });
  });

  describe('updatePrintSettings', () => {
    const validSettings = {
      offsetX: 10,
      offsetY: 20,
      breed: { x: 55, y: 55 },
      sex: { x: 55, y: 65 },
      dateOfBirth: { x: 80, y: 65 },
      eyeColor: { x: 55, y: 74 },
      color: { x: 80, y: 74 },
      catName: { x: 175, y: 60, align: 'center' as const },
      wcaNo: { x: 175, y: 74, align: 'center' as const },
      owner: { x: 325, y: 55, align: 'right' as const },
      breeder: { x: 325, y: 65, align: 'right' as const },
      dateOfRegistration: { x: 245, y: 74 },
      littersM: { x: 280, y: 74 },
      littersF: { x: 290, y: 74 },
      sire: {
        name: { x: 55, y: 115 },
        color: { x: 55, y: 132 },
        eyeColor: { x: 55, y: 137 },
        jcu: { x: 55, y: 142 },
      },
      dam: {
        name: { x: 55, y: 165 },
        color: { x: 55, y: 182 },
        eyeColor: { x: 55, y: 187 },
        jcu: { x: 55, y: 193 },
      },
      grandParents: {
        ff: { name: { x: 145, y: 106 }, color: { x: 145, y: 111 }, jcu: { x: 145, y: 116 } },
        fm: { name: { x: 145, y: 132 }, color: { x: 145, y: 137 }, jcu: { x: 145, y: 142 } },
        mf: { name: { x: 145, y: 157 }, color: { x: 145, y: 162 }, jcu: { x: 145, y: 167 } },
        mm: { name: { x: 145, y: 183 }, color: { x: 145, y: 188 }, jcu: { x: 145, y: 193 } },
      },
      greatGrandParents: {
        fff: { name: { x: 237, y: 99 }, jcu: { x: 237, y: 103 } },
        ffm: { name: { x: 237, y: 112 }, jcu: { x: 237, y: 116 } },
        fmf: { name: { x: 237, y: 125 }, jcu: { x: 237, y: 129 } },
        fmm: { name: { x: 237, y: 138 }, jcu: { x: 237, y: 142 } },
        mff: { name: { x: 237, y: 151 }, jcu: { x: 237, y: 155 } },
        mfm: { name: { x: 237, y: 163 }, jcu: { x: 237, y: 167 } },
        mmf: { name: { x: 237, y: 176 }, jcu: { x: 237, y: 180 } },
        mmm: { name: { x: 237, y: 189 }, jcu: { x: 237, y: 193 } },
      },
      otherOrganizationsNo: { x: 90, y: 215 },
      fontSizes: {
        catName: 14,
        wcaNo: 13,
        headerInfo: 12,
        parentName: 13,
        parentDetail: 12,
        grandParentName: 12,
        grandParentDetail: 12,
        greatGrandParent: 11,
        footer: 8,
      },
    };

    it('should update print settings with valid data', async () => {
      mockPrintSettingsService.isPositionsConfig.mockReturnValue(true);
      mockPrintSettingsService.updateSettings.mockResolvedValue(validSettings);

      const result = await controller.updatePrintSettings(validSettings);

      expect(result).toEqual(validSettings);
      expect(mockPrintSettingsService.isPositionsConfig).toHaveBeenCalledWith(validSettings);
      expect(mockPrintSettingsService.updateSettings).toHaveBeenCalledWith(validSettings);
    });

    it('should reject invalid settings (missing required fields)', async () => {
      const invalidSettings = {
        offsetX: 10,
        offsetY: 20,
        breed: { x: 55, y: 55 },
        // Missing required fields
      };

      mockPrintSettingsService.isPositionsConfig.mockReturnValue(false);

      await expect(controller.updatePrintSettings(invalidSettings as any)).rejects.toThrow(
        'ç„¡åŠ¹ãªè¨­å®šãƒ‡ãƒ¼ã‚¿ã§ã™',
      );
      expect(mockPrintSettingsService.isPositionsConfig).toHaveBeenCalledWith(invalidSettings);
      expect(mockPrintSettingsService.updateSettings).not.toHaveBeenCalled();
    });

    it('should handle service errors', async () => {
      mockPrintSettingsService.updateSettings.mockRejectedValue(
        new Error('Database error'),
      );

      await expect(controller.updatePrintSettings(validSettings)).rejects.toThrow();
    });
  });

  describe('resetPrintSettings', () => {
    it('should reset print settings to default', async () => {
      const defaultSettings = {
        offsetX: 0,
        offsetY: 0,
        breed: { x: 50, y: 50 },
        fontSizes: { catName: 13 },
      };

      mockPrintSettingsService.resetToDefault.mockResolvedValue(defaultSettings);

      const result = await controller.resetPrintSettings();

      expect(result).toEqual(defaultSettings);
      expect(mockPrintSettingsService.resetToDefault).toHaveBeenCalled();
    });

    it('should handle service errors', async () => {
      mockPrintSettingsService.resetToDefault.mockRejectedValue(
        new Error('Database error'),
      );

      await expect(controller.resetPrintSettings()).rejects.toThrow();
    });
  });
});
`````

## File: backend/src/pedigree/pedigree.controller.ts
`````typescript
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  HttpStatus,
  UseGuards,
  Res,
  BadRequestException,
} from "@nestjs/common";
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiParam,
  ApiQuery,
  ApiBearerAuth,
} from "@nestjs/swagger";
import { UserRole } from "@prisma/client";
import { Response } from 'express';

import { JwtAuthGuard } from "../auth/jwt-auth.guard";
import { RoleGuard } from "../auth/role.guard";
import { Roles } from "../auth/roles.decorator";
import { Public } from "../common/decorators/public.decorator";

import { CreatePedigreeDto, UpdatePedigreeDto, PedigreeQueryDto } from "./dto";
import { PedigreePdfService } from "./pdf/pedigree-pdf.service";
import { PrintSettingsService, PositionsConfig } from "./pdf/print-settings.service";
import { PedigreeService } from "./pedigree.service";


@ApiTags("Pedigrees")
@ApiBearerAuth()
@UseGuards(JwtAuthGuard)
@Controller("pedigrees")
export class PedigreeController {
  constructor(
    private readonly pedigreeService: PedigreeService,
    private readonly pedigreePdfService: PedigreePdfService,
    private readonly printSettingsService: PrintSettingsService,
  ) {}

  // TODO: æœ¬ç•ªãƒªãƒªãƒ¼ã‚¹å‰ã«å‰Šé™¤ - @Public()ã¯é–‹ç™ºç’°å¢ƒå°‚ç”¨
  @Public()
  @Post()
  @UseGuards(RoleGuard)
  @Roles(UserRole.ADMIN, UserRole.SUPER_ADMIN)
  @ApiOperation({ summary: "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆï¼ˆç®¡ç†è€…ã®ã¿ï¼‰" })
  @ApiResponse({
    status: HttpStatus.CREATED,
    description: "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«ä½œæˆã•ã‚Œã¾ã—ãŸ",
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: "ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§ã™",
  })
  @ApiResponse({
    status: HttpStatus.FORBIDDEN,
    description: "ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™",
  })
  create(@Body() createPedigreeDto: CreatePedigreeDto) {
    return this.pedigreeService.create(createPedigreeDto);
  }

  @Get()
  @ApiOperation({ summary: "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œç´¢ãƒ»ä¸€è¦§å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK, description: "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®ä¸€è¦§" })
  @ApiQuery({
    name: "page",
    required: false,
    description: "ãƒšãƒ¼ã‚¸ç•ªå·",
    example: 1,
  })
  @ApiQuery({
    name: "limit",
    required: false,
    description: "1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•°",
    example: 10,
  })
  @ApiQuery({ name: "search", required: false, description: "æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰" })
  @ApiQuery({ name: "breedId", required: false, description: "å“ç¨®ID" })
  @ApiQuery({ name: "coatColorId", required: false, description: "æ¯›è‰²ID" })
  @ApiQuery({
    name: "gender",
    required: false,
    description: "æ€§åˆ¥ (1: ã‚ªã‚¹, 2: ãƒ¡ã‚¹)",
  })
  @ApiQuery({
    name: "sortBy",
    required: false,
    description: "ã‚½ãƒ¼ãƒˆé …ç›®",
    example: "createdAt",
  })
  @ApiQuery({
    name: "sortOrder",
    required: false,
    description: "ã‚½ãƒ¼ãƒˆé †",
    example: "desc",
  })
  findAll(@Query() query: PedigreeQueryDto) {
    return this.pedigreeService.findAll(query);
  }

  @Get("next-id")
  @ApiOperation({ summary: "æ¬¡ã®è¡€çµ±æ›¸ç•ªå·ã‚’å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK, description: "æ¬¡ã®è¡€çµ±æ›¸ç•ªå·" })
  getNextId() {
    return this.pedigreeService.getNextId();
  }

  // ===== å°åˆ·è¨­å®š APIï¼ˆé™çš„ãƒ«ãƒ¼ãƒˆãªã®ã§ :id ã‚ˆã‚Šå…ˆã«å®šç¾©ï¼‰ =====

  @Get("print-settings")
  @Public()
  @ApiOperation({ summary: "å°åˆ·è¨­å®šã‚’å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK, description: "ç¾åœ¨ã®å°åˆ·è¨­å®š" })
  async getPrintSettings() {
    return this.printSettingsService.getSettings();
  }

  @Patch("print-settings")
  @Public()
  @ApiOperation({ summary: "å°åˆ·è¨­å®šã‚’æ›´æ–°" })
  @ApiResponse({ status: HttpStatus.OK, description: "æ›´æ–°å¾Œã®å°åˆ·è¨­å®š" })
  @ApiResponse({ status: HttpStatus.BAD_REQUEST, description: "ç„¡åŠ¹ãªè¨­å®šãƒ‡ãƒ¼ã‚¿ã§ã™" })
  async updatePrintSettings(@Body() settings: PositionsConfig) {
    // å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã®æ§‹é€ ã‚’æ¤œè¨¼ï¼ˆã‚µãƒ¼ãƒ“ã‚¹ã®æ¤œè¨¼ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å†åˆ©ç”¨ï¼‰
    if (!this.printSettingsService.isPositionsConfig(settings)) {
      throw new BadRequestException("ç„¡åŠ¹ãªè¨­å®šãƒ‡ãƒ¼ã‚¿ã§ã™");
    }
    return this.printSettingsService.updateSettings(settings);
  }

  @Post("print-settings/reset")
  @Public()
  @ApiOperation({ summary: "å°åˆ·è¨­å®šã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«ãƒªã‚»ãƒƒãƒˆ" })
  @ApiResponse({ status: HttpStatus.OK, description: "ãƒªã‚»ãƒƒãƒˆå¾Œã®å°åˆ·è¨­å®š" })
  async resetPrintSettings() {
    return this.printSettingsService.resetToDefault();
  }

  @Get("pedigree-id/:pedigreeId/pdf")
  // TODO: æœ¬ç•ªãƒªãƒªãƒ¼ã‚¹å‰ã«å‰Šé™¤ - @Public()ã¯é–‹ç™ºç’°å¢ƒå°‚ç”¨
  @Public()
  @ApiOperation({ summary: "è¡€çµ±æ›¸PDFã‚’ç”Ÿæˆã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰" })
  @ApiResponse({ status: HttpStatus.OK, description: "PDFç”ŸæˆæˆåŠŸ", type: 'application/pdf' })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
  })
  @ApiParam({ name: "pedigreeId", description: "è¡€çµ±æ›¸ç•ªå·" })
  @ApiQuery({ name: "format", required: false, description: "å‡ºåŠ›å½¢å¼ (pdf|base64)", example: "pdf" })
  @ApiQuery({ name: "debug", required: false, description: "ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ï¼ˆèƒŒæ™¯ç”»åƒè¡¨ç¤ºï¼‰", example: "false" })
  async generatePdf(
    @Param("pedigreeId") pedigreeId: string,
    @Query("format") format: string = "pdf",
    @Query("debug") debug: string = "false",
    @Res() res: Response,
  ) {
    const debugMode = debug === "true" || debug === "1";
    
    if (format === "base64") {
      const base64Data = await this.pedigreePdfService.generateBase64(pedigreeId);
      const today = new Date().toISOString().split('T')[0].replace(/-/g, '');
      return res.json({
        pedigreeId,
        format: "base64",
        data: base64Data,
        filename: `pedigree_${pedigreeId}_${today}.pdf`,
      });
    }

    const pdfBuffer = await this.pedigreePdfService.generatePdf(pedigreeId, debugMode);
    const today = new Date().toISOString().split('T')[0].replace(/-/g, '');
    const filename = `pedigree_${pedigreeId}_${today}.pdf`;

    res.setHeader('Content-Type', 'application/pdf');
    // ãƒ–ãƒ©ã‚¦ã‚¶å†…ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆPDFãƒ“ãƒ¥ãƒ¼ã‚¢ï¼‰ã‚’å„ªå…ˆã—ã€å°åˆ·ã«é€²ã¿ã‚„ã™ãã™ã‚‹
    res.setHeader('Content-Disposition', `inline; filename="${filename}"`);
    res.setHeader('Content-Length', pdfBuffer.length);
    res.send(pdfBuffer);
  }

  @Get("pedigree-id/:pedigreeId")
  @ApiOperation({ summary: "è¡€çµ±æ›¸ç•ªå·ã§è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK, description: "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿" })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
  })
  @ApiParam({ name: "pedigreeId", description: "è¡€çµ±æ›¸ç•ªå·" })
  findByPedigreeId(@Param("pedigreeId") pedigreeId: string) {
    return this.pedigreeService.findByPedigreeId(pedigreeId);
  }

  @Get(":id")
  @ApiOperation({ summary: "IDã§è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK, description: "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿" })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
  })
  @ApiParam({ name: "id", description: "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®ID" })
  findOne(@Param("id") id: string) {
    return this.pedigreeService.findOne(id);
  }

  @Get(":id/family-tree")
  @ApiOperation({ summary: "è¡€çµ±æ›¸ã®å®¶ç³»å›³ã‚’å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK, description: "å®¶ç³»å›³ãƒ‡ãƒ¼ã‚¿" })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
  })
  @ApiParam({ name: "id", description: "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®ID" })
  getFamilyTree(@Param("id") id: string) {
    return this.pedigreeService.getFamilyTree(id);
  }

  @Get(":id/family")
  @ApiOperation({ summary: "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®å®¶ç³»å›³ã‚’å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK, description: "å®¶ç³»å›³ãƒ‡ãƒ¼ã‚¿" })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
  })
  @ApiParam({ name: "id", description: "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®ID" })
  @ApiQuery({
    name: "generations",
    required: false,
    description: "å–å¾—ã™ã‚‹ä¸–ä»£æ•°",
    example: 3,
  })
  getFamily(
    @Param("id") id: string,
    @Query("generations") generations?: number,
  ) {
    return this.pedigreeService.getFamily(id, generations);
  }

  @Get(":id/descendants")
  @ApiOperation({ summary: "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®å­å­«ã‚’å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK, description: "å­å­«ãƒ‡ãƒ¼ã‚¿" })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
  })
  @ApiParam({ name: "id", description: "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®ID" })
  getDescendants(@Param("id") id: string) {
    return this.pedigreeService.getDescendants(id);
  }

  // TODO: æœ¬ç•ªãƒªãƒªãƒ¼ã‚¹å‰ã«å‰Šé™¤ - @Public()ã¯é–‹ç™ºç’°å¢ƒå°‚ç”¨
  @Public()
  @Patch(":id")
  @UseGuards(RoleGuard)
  @Roles(UserRole.ADMIN, UserRole.SUPER_ADMIN)
  @ApiOperation({ summary: "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰" })
  @ApiResponse({
    status: HttpStatus.OK,
    description: "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«æ›´æ–°ã•ã‚Œã¾ã—ãŸ",
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: "ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§ã™",
  })
  @ApiResponse({
    status: HttpStatus.FORBIDDEN,
    description: "ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™",
  })
  @ApiParam({ name: "id", description: "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®ID" })
  update(
    @Param("id") id: string,
    @Body() updatePedigreeDto: UpdatePedigreeDto,
  ) {
    return this.pedigreeService.update(id, updatePedigreeDto);
  }

  @Delete(":id")
  @UseGuards(RoleGuard)
  @Roles(UserRole.ADMIN, UserRole.SUPER_ADMIN)
  @ApiOperation({ summary: "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰" })
  @ApiResponse({
    status: HttpStatus.OK,
    description: "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«å‰Šé™¤ã•ã‚Œã¾ã—ãŸ",
  })
  @ApiResponse({
    status: HttpStatus.NOT_FOUND,
    description: "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
  })
  @ApiResponse({
    status: HttpStatus.FORBIDDEN,
    description: "ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™",
  })
  @ApiParam({ name: "id", description: "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®ID" })
  remove(@Param("id") id: string) {
    return this.pedigreeService.remove(id);
  }
}
`````

## File: backend/src/pedigree/pedigree.module.ts
`````typescript
import { Module } from "@nestjs/common";

import { PrismaModule } from "../prisma/prisma.module";

import { PedigreePdfService } from "./pdf/pedigree-pdf.service";
import { PrintSettingsService } from "./pdf/print-settings.service";
import { PedigreeController } from "./pedigree.controller";
import { PedigreeService } from "./pedigree.service";

@Module({
  imports: [PrismaModule],
  controllers: [PedigreeController],
  providers: [PedigreeService, PedigreePdfService, PrintSettingsService],
  exports: [PedigreeService],
})
export class PedigreeModule {}
`````

## File: backend/src/pedigree/pedigree.service.spec.ts
`````typescript
import { NotFoundException } from '@nestjs/common';
import { Test, TestingModule } from '@nestjs/testing';

import { PrismaService } from '../prisma/prisma.service';

import { PedigreeService } from './pedigree.service';


describe('PedigreeService', () => {
  let service: PedigreeService;
  let _prismaService: PrismaService;

  const mockPrismaService = {
    pedigree: {
      create: jest.fn(),
      findMany: jest.fn(),
      findUnique: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
      count: jest.fn(),
    },
    cat: {
      findUnique: jest.fn(),
    },
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        PedigreeService,
        {
          provide: PrismaService,
          useValue: mockPrismaService,
        },
      ],
    }).compile();

    service = module.get<PedigreeService>(PedigreeService);
    _prismaService = module.get<PrismaService>(PrismaService);

    jest.clearAllMocks();
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('create', () => {
    it('should create a pedigree record successfully', async () => {
      const createDto = {
        pedigreeId: '700545',
        catName: 'Test Cat',
        breedCode: 92,
      };

      const mockPedigree = {
        id: '1',
        ...createDto,
        createdAt: new Date(),
      };

      mockPrismaService.pedigree.create.mockResolvedValue(mockPedigree);

      const result = await service.create(createDto);

      expect(result.success).toBe(true);
      expect(result.data).toEqual(mockPedigree);
      expect(mockPrismaService.pedigree.create).toHaveBeenCalled();
    });

    it('should throw NotFoundException for invalid pedigree id', async () => {
      const createDto = {
        pedigreeId: '',
      };

      mockPrismaService.pedigree.create.mockRejectedValue(new Error('Invalid pedigreeId'));

      await expect(service.create(createDto)).rejects.toThrow();
    });
  });

  describe('findAll', () => {
    it('should return paginated pedigree records', async () => {
      const mockPedigrees = [
        {
          id: '1',
          catId: 'cat-1',
          registrationNumber: 'PED-001',
        },
      ];

      mockPrismaService.pedigree.findMany.mockResolvedValue(mockPedigrees);
      mockPrismaService.pedigree.count.mockResolvedValue(1);

      const result = await service.findAll({});

      expect(result.data).toEqual(mockPedigrees);
      expect(result.meta.total).toBe(1);
    });
  });

  describe('findOne', () => {
    it('should return a pedigree record by id', async () => {
      const mockPedigree = {
        id: '1',
        catId: 'cat-1',
        registrationNumber: 'PED-001',
      };

      mockPrismaService.pedigree.findUnique.mockResolvedValue(mockPedigree);

      const result = await service.findOne('1');

      expect(result).toEqual(mockPedigree);
    });

    it('should throw NotFoundException when pedigree not found', async () => {
      mockPrismaService.pedigree.findUnique.mockResolvedValue(null);

      await expect(service.findOne('non-existent')).rejects.toThrow(NotFoundException);
    });
  });

  describe('update', () => {
    it('should update a pedigree record successfully', async () => {
      const updateDto = { catName: 'Updated Cat Name', title: 'Champion' };
      const mockPedigree = {
        id: '1',
        pedigreeId: '700545',
        catName: 'Updated Cat Name',
        title: 'Champion',
      };

      mockPrismaService.pedigree.findUnique.mockResolvedValue({
        id: '1',
        pedigreeId: '700545',
      });
      mockPrismaService.pedigree.update.mockResolvedValue(mockPedigree);

      const result = await service.update('1', updateDto);

      expect(result.success).toBe(true);
      expect(result.data).toEqual(mockPedigree);
    });
  });

  describe('remove', () => {
    it('should delete a pedigree record successfully', async () => {
      const mockPedigree = { id: '1', catId: 'cat-1' };

      mockPrismaService.pedigree.findUnique.mockResolvedValue(mockPedigree);
      mockPrismaService.pedigree.delete.mockResolvedValue(mockPedigree);

      await service.remove('1');

      expect(mockPrismaService.pedigree.delete).toHaveBeenCalledWith({
        where: { id: '1' },
      });
    });
  });
});
`````

## File: backend/src/pedigree/pedigree.service.ts
`````typescript
import {
  Injectable,
  BadRequestException,
  ConflictException,
  NotFoundException,
} from "@nestjs/common";
import { Prisma } from "@prisma/client";

import { PrismaService } from "../prisma/prisma.service";

import { CreatePedigreeDto, UpdatePedigreeDto, PedigreeQueryDto } from "./dto";
import {
  PedigreeWhereInput,
  PedigreeCreateResponse,
  PedigreeListResponse,
  PedigreeSuccessResponse,
  PedigreeTreeNode,
  pedigreeWithRelationsInclude,
} from "./types/pedigree.types";

@Injectable()
export class PedigreeService {
  constructor(private prisma: PrismaService) {}

  async create(createPedigreeDto: CreatePedigreeDto): Promise<PedigreeCreateResponse> {
    // Accessè¨­è¨ˆæº–æ‹ : å…¨79é …ç›®ã‚’ãã®ã¾ã¾ä¿å­˜
    const createData: Prisma.PedigreeCreateInput = {
      // åŸºæœ¬æƒ…å ±ï¼ˆ17é …ç›®ï¼‰
      pedigreeId: createPedigreeDto.pedigreeId,
      ...(createPedigreeDto.title && { title: createPedigreeDto.title }),
      ...(createPedigreeDto.catName && { catName: createPedigreeDto.catName }),
      ...(createPedigreeDto.catName2 && { catName2: createPedigreeDto.catName2 }),
      ...(createPedigreeDto.breedCode !== undefined && { breedCode: createPedigreeDto.breedCode }),
      ...(createPedigreeDto.genderCode !== undefined && { genderCode: createPedigreeDto.genderCode }),
      ...(createPedigreeDto.eyeColor && { eyeColor: createPedigreeDto.eyeColor }),
      ...(createPedigreeDto.coatColorCode !== undefined && { coatColorCode: createPedigreeDto.coatColorCode }),
      ...(createPedigreeDto.birthDate && { birthDate: createPedigreeDto.birthDate }),
      ...(createPedigreeDto.breederName && { breederName: createPedigreeDto.breederName }),
      ...(createPedigreeDto.ownerName && { ownerName: createPedigreeDto.ownerName }),
      ...(createPedigreeDto.registrationDate && { registrationDate: createPedigreeDto.registrationDate }),
      ...(createPedigreeDto.brotherCount !== undefined && { brotherCount: createPedigreeDto.brotherCount }),
      ...(createPedigreeDto.sisterCount !== undefined && { sisterCount: createPedigreeDto.sisterCount }),
      ...(createPedigreeDto.notes && { notes: createPedigreeDto.notes }),
      ...(createPedigreeDto.notes2 && { notes2: createPedigreeDto.notes2 }),
      ...(createPedigreeDto.otherNo && { otherNo: createPedigreeDto.otherNo }),
      
      // è¡€çµ±æƒ…å ±ï¼ˆ62é …ç›®ï¼‰
      // ç¬¬1ä¸–ä»£: çˆ¶è¦ªï¼ˆ7é …ç›®ï¼‰
      ...(createPedigreeDto.fatherTitle && { fatherTitle: createPedigreeDto.fatherTitle }),
      ...(createPedigreeDto.fatherCatName && { fatherCatName: createPedigreeDto.fatherCatName }),
      ...(createPedigreeDto.fatherCatName2 && { fatherCatName2: createPedigreeDto.fatherCatName2 }),
      ...(createPedigreeDto.fatherCoatColor && { fatherCoatColor: createPedigreeDto.fatherCoatColor }),
      ...(createPedigreeDto.fatherEyeColor && { fatherEyeColor: createPedigreeDto.fatherEyeColor }),
      ...(createPedigreeDto.fatherJCU && { fatherJCU: createPedigreeDto.fatherJCU }),
      ...(createPedigreeDto.fatherOtherCode && { fatherOtherCode: createPedigreeDto.fatherOtherCode }),

      // ç¬¬1ä¸–ä»£: æ¯è¦ªï¼ˆ7é …ç›®ï¼‰
      ...(createPedigreeDto.motherTitle && { motherTitle: createPedigreeDto.motherTitle }),
      ...(createPedigreeDto.motherCatName && { motherCatName: createPedigreeDto.motherCatName }),
      ...(createPedigreeDto.motherCatName2 && { motherCatName2: createPedigreeDto.motherCatName2 }),
      ...(createPedigreeDto.motherCoatColor && { motherCoatColor: createPedigreeDto.motherCoatColor }),
      ...(createPedigreeDto.motherEyeColor && { motherEyeColor: createPedigreeDto.motherEyeColor }),
      ...(createPedigreeDto.motherJCU && { motherJCU: createPedigreeDto.motherJCU }),
      ...(createPedigreeDto.motherOtherCode && { motherOtherCode: createPedigreeDto.motherOtherCode }),

      // ç¬¬2ä¸–ä»£: ç¥–çˆ¶æ¯ï¼ˆ16é …ç›®ï¼‰
      ...(createPedigreeDto.ffTitle && { ffTitle: createPedigreeDto.ffTitle }),
      ...(createPedigreeDto.ffCatName && { ffCatName: createPedigreeDto.ffCatName }),
      ...(createPedigreeDto.ffCatColor && { ffCatColor: createPedigreeDto.ffCatColor }),
      ...(createPedigreeDto.ffjcu && { ffjcu: createPedigreeDto.ffjcu }),

      ...(createPedigreeDto.fmTitle && { fmTitle: createPedigreeDto.fmTitle }),
      ...(createPedigreeDto.fmCatName && { fmCatName: createPedigreeDto.fmCatName }),
      ...(createPedigreeDto.fmCatColor && { fmCatColor: createPedigreeDto.fmCatColor }),
      ...(createPedigreeDto.fmjcu && { fmjcu: createPedigreeDto.fmjcu }),

      ...(createPedigreeDto.mfTitle && { mfTitle: createPedigreeDto.mfTitle }),
      ...(createPedigreeDto.mfCatName && { mfCatName: createPedigreeDto.mfCatName }),
      ...(createPedigreeDto.mfCatColor && { mfCatColor: createPedigreeDto.mfCatColor }),
      ...(createPedigreeDto.mfjcu && { mfjcu: createPedigreeDto.mfjcu }),

      ...(createPedigreeDto.mmTitle && { mmTitle: createPedigreeDto.mmTitle }),
      ...(createPedigreeDto.mmCatName && { mmCatName: createPedigreeDto.mmCatName }),
      ...(createPedigreeDto.mmCatColor && { mmCatColor: createPedigreeDto.mmCatColor }),
      ...(createPedigreeDto.mmjcu && { mmjcu: createPedigreeDto.mmjcu }),

      // ç¬¬3ä¸–ä»£: æ›¾ç¥–çˆ¶æ¯ï¼ˆ32é …ç›®ï¼‰
      ...(createPedigreeDto.fffTitle && { fffTitle: createPedigreeDto.fffTitle }),
      ...(createPedigreeDto.fffCatName && { fffCatName: createPedigreeDto.fffCatName }),
      ...(createPedigreeDto.fffCatColor && { fffCatColor: createPedigreeDto.fffCatColor }),
      ...(createPedigreeDto.fffjcu && { fffjcu: createPedigreeDto.fffjcu }),

      ...(createPedigreeDto.ffmTitle && { ffmTitle: createPedigreeDto.ffmTitle }),
      ...(createPedigreeDto.ffmCatName && { ffmCatName: createPedigreeDto.ffmCatName }),
      ...(createPedigreeDto.ffmCatColor && { ffmCatColor: createPedigreeDto.ffmCatColor }),
      ...(createPedigreeDto.ffmjcu && { ffmjcu: createPedigreeDto.ffmjcu }),

      ...(createPedigreeDto.fmfTitle && { fmfTitle: createPedigreeDto.fmfTitle }),
      ...(createPedigreeDto.fmfCatName && { fmfCatName: createPedigreeDto.fmfCatName }),
      ...(createPedigreeDto.fmfCatColor && { fmfCatColor: createPedigreeDto.fmfCatColor }),
      ...(createPedigreeDto.fmfjcu && { fmfjcu: createPedigreeDto.fmfjcu }),

      ...(createPedigreeDto.fmmTitle && { fmmTitle: createPedigreeDto.fmmTitle }),
      ...(createPedigreeDto.fmmCatName && { fmmCatName: createPedigreeDto.fmmCatName }),
      ...(createPedigreeDto.fmmCatColor && { fmmCatColor: createPedigreeDto.fmmCatColor }),
      ...(createPedigreeDto.fmmjcu && { fmmjcu: createPedigreeDto.fmmjcu }),

      ...(createPedigreeDto.mffTitle && { mffTitle: createPedigreeDto.mffTitle }),
      ...(createPedigreeDto.mffCatName && { mffCatName: createPedigreeDto.mffCatName }),
      ...(createPedigreeDto.mffCatColor && { mffCatColor: createPedigreeDto.mffCatColor }),
      ...(createPedigreeDto.mffjcu && { mffjcu: createPedigreeDto.mffjcu }),

      ...(createPedigreeDto.mfmTitle && { mfmTitle: createPedigreeDto.mfmTitle }),
      ...(createPedigreeDto.mfmCatName && { mfmCatName: createPedigreeDto.mfmCatName }),
      ...(createPedigreeDto.mfmCatColor && { mfmCatColor: createPedigreeDto.mfmCatColor }),
      ...(createPedigreeDto.mfmjcu && { mfmjcu: createPedigreeDto.mfmjcu }),

      ...(createPedigreeDto.mmfTitle && { mmfTitle: createPedigreeDto.mmfTitle }),
      ...(createPedigreeDto.mmfCatName && { mmfCatName: createPedigreeDto.mmfCatName }),
      ...(createPedigreeDto.mmfCatColor && { mmfCatColor: createPedigreeDto.mmfCatColor }),
      ...(createPedigreeDto.mmfjcu && { mmfjcu: createPedigreeDto.mmfjcu }),

      ...(createPedigreeDto.mmmTitle && { mmmTitle: createPedigreeDto.mmmTitle }),
      ...(createPedigreeDto.mmmCatName && { mmmCatName: createPedigreeDto.mmmCatName }),
      ...(createPedigreeDto.mmmCatColor && { mmmCatColor: createPedigreeDto.mmmCatColor }),
      ...(createPedigreeDto.mmmjcu && { mmmjcu: createPedigreeDto.mmmjcu }),

      ...(createPedigreeDto.oldCode && { oldCode: createPedigreeDto.oldCode }),
    };

    try {
      const result = await this.prisma.pedigree.create({
        data: createData,
        include: pedigreeWithRelationsInclude,
      });

      return { success: true, data: result };
    } catch (error) {
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2002') {
          throw new ConflictException('è¡€çµ±æ›¸ç•ªå·ã¯æ—¢ã«ç™»éŒ²ã•ã‚Œã¦ã„ã¾ã™');
        }

        if (error.code === 'P2003') {
          throw new BadRequestException('é–¢é€£ãƒã‚¹ã‚¿ã«å­˜åœ¨ã—ãªã„ã‚³ãƒ¼ãƒ‰ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã™ï¼ˆå“ç¨®/æ€§åˆ¥/æ¯›è‰²ï¼‰');
        }
      }

      throw error;
    }

  }

  async findAll(query: PedigreeQueryDto): Promise<PedigreeListResponse> {
    const {
      page = 1,
      limit = 10,
      search,
      breedId,
      coatColorId,
      gender,
      catName2: _catName2,
      eyeColor,
      sortBy = "createdAt",
      sortOrder = "desc",
    } = query;

    const skip = (page - 1) * limit;
    const where: PedigreeWhereInput = {};

    // Search functionality
    if (search) {
      where.OR = [
        { catName: { contains: search, mode: "insensitive" } },
        { title: { contains: search, mode: "insensitive" } },
        { breederName: { contains: search, mode: "insensitive" } },
        { ownerName: { contains: search, mode: "insensitive" } },
      ];
    }

    // Filters
    if (breedId) where.breedCode = parseInt(breedId, 10);
    if (coatColorId) where.coatColorCode = parseInt(coatColorId, 10);
    if (gender) where.genderCode = parseInt(gender, 10);
    if (eyeColor) where.eyeColor = eyeColor;
    if (_catName2) {
      where.catName2 = {
        contains: _catName2,
        mode: "insensitive",
      };
    }

    const [pedigrees, total] = await Promise.all([
      this.prisma.pedigree.findMany({
        where,
        skip,
        take: limit,
        orderBy: {
          [sortBy]: sortOrder,
        },
        include: pedigreeWithRelationsInclude,
      }),
      this.prisma.pedigree.count({ where }),
    ]);

    return {
      success: true,
      data: pedigrees,
      meta: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  async findOne(id: string) {
    const pedigree = await this.prisma.pedigree.findUnique({
      where: { id },
      include: pedigreeWithRelationsInclude,
    });

    if (!pedigree) {
      throw new NotFoundException(`Pedigree with ID ${id} not found`);
    }

    return pedigree;
  }

  async findByPedigreeId(pedigreeId: string) {
    const pedigree = await this.prisma.pedigree.findUnique({
      where: { pedigreeId },
      include: pedigreeWithRelationsInclude,
    });

    if (!pedigree) {
      throw new NotFoundException(
        `Pedigree with pedigree ID ${pedigreeId} not found`,
      );
    }

    return pedigree;
  }

  async update(id: string, updatePedigreeDto: UpdatePedigreeDto): Promise<PedigreeCreateResponse> {
    const existingPedigree = await this.prisma.pedigree.findUnique({
      where: { id },
    });

    if (!existingPedigree) {
      throw new NotFoundException(`Pedigree with ID ${id} not found`);
    }

    // Prisma ã®å‹ã«é©åˆã™ã‚‹ã‚ˆã†ã«ãƒ‡ãƒ¼ã‚¿ã‚’æº–å‚™ (Access schema 79 fields)
    const updateData: Prisma.PedigreeUpdateInput = {
      // Basic information (17 fields)
      ...(updatePedigreeDto.pedigreeId && { pedigreeId: updatePedigreeDto.pedigreeId }),
      ...(updatePedigreeDto.title && { title: updatePedigreeDto.title }),
      ...(updatePedigreeDto.catName && { catName: updatePedigreeDto.catName }),
      ...(updatePedigreeDto.catName2 && { catName2: updatePedigreeDto.catName2 }),
      ...(updatePedigreeDto.breedCode !== undefined && { breedCode: updatePedigreeDto.breedCode }),
      ...(updatePedigreeDto.genderCode !== undefined && { genderCode: updatePedigreeDto.genderCode }),
      ...(updatePedigreeDto.eyeColor && { eyeColor: updatePedigreeDto.eyeColor }),
      ...(updatePedigreeDto.coatColorCode !== undefined && { coatColorCode: updatePedigreeDto.coatColorCode }),
      ...(updatePedigreeDto.birthDate && { birthDate: updatePedigreeDto.birthDate }),
      ...(updatePedigreeDto.breederName && { breederName: updatePedigreeDto.breederName }),
      ...(updatePedigreeDto.ownerName && { ownerName: updatePedigreeDto.ownerName }),
      ...(updatePedigreeDto.registrationDate && { registrationDate: updatePedigreeDto.registrationDate }),
      ...(updatePedigreeDto.brotherCount !== undefined && { brotherCount: updatePedigreeDto.brotherCount }),
      ...(updatePedigreeDto.sisterCount !== undefined && { sisterCount: updatePedigreeDto.sisterCount }),
      ...(updatePedigreeDto.notes && { notes: updatePedigreeDto.notes }),
      ...(updatePedigreeDto.notes2 && { notes2: updatePedigreeDto.notes2 }),
      ...(updatePedigreeDto.otherNo && { otherNo: updatePedigreeDto.otherNo }),

      // Generation 1 - Father (7 fields)
      ...(updatePedigreeDto.fatherTitle && { fatherTitle: updatePedigreeDto.fatherTitle }),
      ...(updatePedigreeDto.fatherCatName && { fatherCatName: updatePedigreeDto.fatherCatName }),
      ...(updatePedigreeDto.fatherCatName2 && { fatherCatName2: updatePedigreeDto.fatherCatName2 }),
      ...(updatePedigreeDto.fatherCoatColor && { fatherCoatColor: updatePedigreeDto.fatherCoatColor }),
      ...(updatePedigreeDto.fatherEyeColor && { fatherEyeColor: updatePedigreeDto.fatherEyeColor }),
      ...(updatePedigreeDto.fatherJCU && { fatherJCU: updatePedigreeDto.fatherJCU }),
      ...(updatePedigreeDto.fatherOtherCode && { fatherOtherCode: updatePedigreeDto.fatherOtherCode }),

      // Generation 1 - Mother (7 fields)
      ...(updatePedigreeDto.motherTitle && { motherTitle: updatePedigreeDto.motherTitle }),
      ...(updatePedigreeDto.motherCatName && { motherCatName: updatePedigreeDto.motherCatName }),
      ...(updatePedigreeDto.motherCatName2 && { motherCatName2: updatePedigreeDto.motherCatName2 }),
      ...(updatePedigreeDto.motherCoatColor && { motherCoatColor: updatePedigreeDto.motherCoatColor }),
      ...(updatePedigreeDto.motherEyeColor && { motherEyeColor: updatePedigreeDto.motherEyeColor }),
      ...(updatePedigreeDto.motherJCU && { motherJCU: updatePedigreeDto.motherJCU }),
      ...(updatePedigreeDto.motherOtherCode && { motherOtherCode: updatePedigreeDto.motherOtherCode }),

      // Generation 2 - Paternal Grandfather (FF) (4 fields)
      ...(updatePedigreeDto.ffTitle && { ffTitle: updatePedigreeDto.ffTitle }),
      ...(updatePedigreeDto.ffCatName && { ffCatName: updatePedigreeDto.ffCatName }),
      ...(updatePedigreeDto.ffCatColor && { ffCatColor: updatePedigreeDto.ffCatColor }),
      ...(updatePedigreeDto.ffjcu && { ffjcu: updatePedigreeDto.ffjcu }),

      // Generation 2 - Paternal Grandmother (FM) (4 fields)
      ...(updatePedigreeDto.fmTitle && { fmTitle: updatePedigreeDto.fmTitle }),
      ...(updatePedigreeDto.fmCatName && { fmCatName: updatePedigreeDto.fmCatName }),
      ...(updatePedigreeDto.fmCatColor && { fmCatColor: updatePedigreeDto.fmCatColor }),
      ...(updatePedigreeDto.fmjcu && { fmjcu: updatePedigreeDto.fmjcu }),

      // Generation 2 - Maternal Grandfather (MF) (4 fields)
      ...(updatePedigreeDto.mfTitle && { mfTitle: updatePedigreeDto.mfTitle }),
      ...(updatePedigreeDto.mfCatName && { mfCatName: updatePedigreeDto.mfCatName }),
      ...(updatePedigreeDto.mfCatColor && { mfCatColor: updatePedigreeDto.mfCatColor }),
      ...(updatePedigreeDto.mfjcu && { mfjcu: updatePedigreeDto.mfjcu }),

      // Generation 2 - Maternal Grandmother (MM) (4 fields)
      ...(updatePedigreeDto.mmTitle && { mmTitle: updatePedigreeDto.mmTitle }),
      ...(updatePedigreeDto.mmCatName && { mmCatName: updatePedigreeDto.mmCatName }),
      ...(updatePedigreeDto.mmCatColor && { mmCatColor: updatePedigreeDto.mmCatColor }),
      ...(updatePedigreeDto.mmjcu && { mmjcu: updatePedigreeDto.mmjcu }),

      // Generation 3 - Great-Grandfathers and Great-Grandmothers (32 fields)
      // FFF (Father's Father's Father)
      ...(updatePedigreeDto.fffTitle && { fffTitle: updatePedigreeDto.fffTitle }),
      ...(updatePedigreeDto.fffCatName && { fffCatName: updatePedigreeDto.fffCatName }),
      ...(updatePedigreeDto.fffCatColor && { fffCatColor: updatePedigreeDto.fffCatColor }),
      ...(updatePedigreeDto.fffjcu && { fffjcu: updatePedigreeDto.fffjcu }),

      // FFM (Father's Father's Mother)
      ...(updatePedigreeDto.ffmTitle && { ffmTitle: updatePedigreeDto.ffmTitle }),
      ...(updatePedigreeDto.ffmCatName && { ffmCatName: updatePedigreeDto.ffmCatName }),
      ...(updatePedigreeDto.ffmCatColor && { ffmCatColor: updatePedigreeDto.ffmCatColor }),
      ...(updatePedigreeDto.ffmjcu && { ffmjcu: updatePedigreeDto.ffmjcu }),

      // FMF (Father's Mother's Father)
      ...(updatePedigreeDto.fmfTitle && { fmfTitle: updatePedigreeDto.fmfTitle }),
      ...(updatePedigreeDto.fmfCatName && { fmfCatName: updatePedigreeDto.fmfCatName }),
      ...(updatePedigreeDto.fmfCatColor && { fmfCatColor: updatePedigreeDto.fmfCatColor }),
      ...(updatePedigreeDto.fmfjcu && { fmfjcu: updatePedigreeDto.fmfjcu }),

      // FMM (Father's Mother's Mother)
      ...(updatePedigreeDto.fmmTitle && { fmmTitle: updatePedigreeDto.fmmTitle }),
      ...(updatePedigreeDto.fmmCatName && { fmmCatName: updatePedigreeDto.fmmCatName }),
      ...(updatePedigreeDto.fmmCatColor && { fmmCatColor: updatePedigreeDto.fmmCatColor }),
      ...(updatePedigreeDto.fmmjcu && { fmmjcu: updatePedigreeDto.fmmjcu }),

      // MFF (Mother's Father's Father)
      ...(updatePedigreeDto.mffTitle && { mffTitle: updatePedigreeDto.mffTitle }),
      ...(updatePedigreeDto.mffCatName && { mffCatName: updatePedigreeDto.mffCatName }),
      ...(updatePedigreeDto.mffCatColor && { mffCatColor: updatePedigreeDto.mffCatColor }),
      ...(updatePedigreeDto.mffjcu && { mffjcu: updatePedigreeDto.mffjcu }),

      // MFM (Mother's Father's Mother)
      ...(updatePedigreeDto.mfmTitle && { mfmTitle: updatePedigreeDto.mfmTitle }),
      ...(updatePedigreeDto.mfmCatName && { mfmCatName: updatePedigreeDto.mfmCatName }),
      ...(updatePedigreeDto.mfmCatColor && { mfmCatColor: updatePedigreeDto.mfmCatColor }),
      ...(updatePedigreeDto.mfmjcu && { mfmjcu: updatePedigreeDto.mfmjcu }),

      // MMF (Mother's Mother's Father)
      ...(updatePedigreeDto.mmfTitle && { mmfTitle: updatePedigreeDto.mmfTitle }),
      ...(updatePedigreeDto.mmfCatName && { mmfCatName: updatePedigreeDto.mmfCatName }),
      ...(updatePedigreeDto.mmfCatColor && { mmfCatColor: updatePedigreeDto.mmfCatColor }),
      ...(updatePedigreeDto.mmfjcu && { mmfjcu: updatePedigreeDto.mmfjcu }),

      // MMM (Mother's Mother's Mother)
      ...(updatePedigreeDto.mmmTitle && { mmmTitle: updatePedigreeDto.mmmTitle }),
      ...(updatePedigreeDto.mmmCatName && { mmmCatName: updatePedigreeDto.mmmCatName }),
      ...(updatePedigreeDto.mmmCatColor && { mmmCatColor: updatePedigreeDto.mmmCatColor }),
      ...(updatePedigreeDto.mmmjcu && { mmmjcu: updatePedigreeDto.mmmjcu }),

      // Old Code (1 field)
      ...(updatePedigreeDto.oldCode && { oldCode: updatePedigreeDto.oldCode }),
    };

    const result = await this.prisma.pedigree.update({
      where: { id },
      data: updateData,
      include: pedigreeWithRelationsInclude,
    });

    return { success: true, data: result };
  }

  async remove(id: string): Promise<PedigreeSuccessResponse> {
    const existingPedigree = await this.prisma.pedigree.findUnique({
      where: { id },
    });

    if (!existingPedigree) {
      throw new NotFoundException(`Pedigree with ID ${id} not found`);
    }

    await this.prisma.pedigree.delete({
      where: { id },
    });

    return { success: true };
  }

  async getFamily(id: string, _generations: number = 3): Promise<PedigreeTreeNode> {
    // Pedigreeãƒ¢ãƒ‡ãƒ«ã¯è¡€çµ±æƒ…å ±ã‚’æ–‡å­—åˆ—ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¨ã—ã¦ä¿æŒã—ã¦ã„ã‚‹ãŸã‚ã€
    // ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯ãªãç›´æ¥ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
    const pedigree = await this.prisma.pedigree.findUnique({
      where: { id },
      include: pedigreeWithRelationsInclude,
    });

    if (!pedigree) {
      throw new NotFoundException(`Pedigree with ID ${id} not found`);
    }

    // è¡€çµ±æƒ…å ±ã¯æ—¢ã«ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å«ã¾ã‚Œã¦ã„ã‚‹ãŸã‚ã€ãã®ã¾ã¾è¿”ã™
    return pedigree;
  }

  async getFamilyTree(id: string, generations: number = 3): Promise<PedigreeTreeNode> {
    return this.getFamily(id, generations);
  }

  async getDescendants(id: string) {
    const pedigree = await this.findOne(id);

    const nameConditions: Prisma.PedigreeWhereInput[] = [];

    if (pedigree.catName) {
      nameConditions.push({ fatherCatName: { equals: pedigree.catName } });
      nameConditions.push({ motherCatName: { equals: pedigree.catName } });
    }

    const descendants = nameConditions.length
      ? await this.prisma.pedigree.findMany({
          where: {
            OR: nameConditions,
          },
          include: pedigreeWithRelationsInclude,
        })
      : [];

    return {
      pedigree,
      children: descendants,
    };
  }

  async getNextId(): Promise<{ nextId: string }> {
    try {
      // æ•°å€¤ã®ã¿ã§æ§‹æˆã•ã‚Œã‚‹pedigree_idã®æœ€å¤§å€¤ã‚’å–å¾—
      // PostgreSQLå›ºæœ‰ã®æ­£è¦è¡¨ç¾æ¼”ç®—å­ ~ ã‚’ä½¿ç”¨
      const result = await this.prisma.$queryRaw<{ max_id: number }[]>`
        SELECT MAX(CAST(pedigree_id AS INTEGER)) as max_id 
        FROM pedigrees 
        WHERE pedigree_id ~ '^[0-9]+$'
      `;

      if (result && result[0] && result[0].max_id !== null) {
        // BigIntã§è¿”ã£ã¦ãã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€Numberã¾ãŸã¯Stringå¤‰æ›ã—ã¦å‡¦ç†
        const maxId = Number(result[0].max_id);
        return { nextId: (maxId + 1).toString() };
      }

      // ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã¯åˆæœŸå€¤ "1" ã‚’è¿”ã™
      return { nextId: "1" };
    } catch (error) {
      console.error("Failed to get next pedigree ID:", error);
      // ã‚¨ãƒ©ãƒ¼æ™‚ã¯å®‰å…¨ãªãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¿”ã™
      return { nextId: "1" };
    }
  }
}
`````

## File: backend/src/print-templates/dto/index.ts
`````typescript
export * from './print-template.dto';
`````

## File: backend/src/print-templates/dto/print-template.dto.ts
`````typescript
import { Type } from 'class-transformer';
import {
  IsString,
  IsOptional,
  IsInt,
  IsBoolean,
  IsObject,
  IsEnum,
  Min,
  Max,
} from 'class-validator';

/** å°åˆ·ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚«ãƒ†ã‚´ãƒª */
export enum PrintTemplateCategory {
  PEDIGREE = 'PEDIGREE',
  KITTEN_TRANSFER = 'KITTEN_TRANSFER',
  HEALTH_CERTIFICATE = 'HEALTH_CERTIFICATE',
  VACCINATION_RECORD = 'VACCINATION_RECORD',
  BREEDING_RECORD = 'BREEDING_RECORD',
  CONTRACT = 'CONTRACT',
  INVOICE = 'INVOICE',
  CUSTOM = 'CUSTOM',
}

/** ã‚«ãƒ†ã‚´ãƒªã®æ—¥æœ¬èªãƒ©ãƒ™ãƒ« */
export const PrintTemplateCategoryLabels: Record<PrintTemplateCategory, string> = {
  [PrintTemplateCategory.PEDIGREE]: 'è¡€çµ±æ›¸',
  [PrintTemplateCategory.KITTEN_TRANSFER]: 'å­çŒ«è­²æ¸¡è¨¼æ˜æ›¸',
  [PrintTemplateCategory.HEALTH_CERTIFICATE]: 'å¥åº·è¨ºæ–­æ›¸',
  [PrintTemplateCategory.VACCINATION_RECORD]: 'ãƒ¯ã‚¯ãƒãƒ³æ¥ç¨®è¨˜éŒ²',
  [PrintTemplateCategory.BREEDING_RECORD]: 'ç¹æ®–è¨˜éŒ²',
  [PrintTemplateCategory.CONTRACT]: 'å¥‘ç´„æ›¸',
  [PrintTemplateCategory.INVOICE]: 'è«‹æ±‚æ›¸/é ˜åæ›¸',
  [PrintTemplateCategory.CUSTOM]: 'ã‚«ã‚¹ã‚¿ãƒ æ›¸é¡',
};

/** ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä½œæˆDTO */
export class CreatePrintTemplateDto {
  @IsOptional()
  @IsString()
  tenantId?: string;

  @IsString()
  name: string;

  @IsOptional()
  @IsString()
  description?: string;

  @IsEnum(PrintTemplateCategory)
  category: PrintTemplateCategory;

  @IsInt()
  @Min(50)
  @Max(500)
  paperWidth: number; // mmå˜ä½

  @IsInt()
  @Min(50)
  @Max(500)
  paperHeight: number; // mmå˜ä½

  @IsOptional()
  @IsString()
  backgroundUrl?: string;

  @IsOptional()
  @IsInt()
  @Min(0)
  @Max(100)
  backgroundOpacity?: number;

  @IsObject()
  positions: Record<string, unknown>;

  @IsOptional()
  @IsObject()
  fontSizes?: Record<string, number>;

  @IsOptional()
  @IsBoolean()
  isDefault?: boolean;

  @IsOptional()
  @IsInt()
  displayOrder?: number;
}

/** ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆæ›´æ–°DTO */
export class UpdatePrintTemplateDto {
  @IsOptional()
  @IsString()
  name?: string;

  @IsOptional()
  @IsString()
  description?: string;

  @IsOptional()
  @IsEnum(PrintTemplateCategory)
  category?: PrintTemplateCategory;

  @IsOptional()
  @IsInt()
  @Min(50)
  @Max(500)
  paperWidth?: number;

  @IsOptional()
  @IsInt()
  @Min(50)
  @Max(500)
  paperHeight?: number;

  @IsOptional()
  @IsString()
  backgroundUrl?: string;

  @IsOptional()
  @IsInt()
  @Min(0)
  @Max(100)
  backgroundOpacity?: number;

  @IsOptional()
  @IsObject()
  positions?: Record<string, unknown>;

  @IsOptional()
  @IsObject()
  fontSizes?: Record<string, number>;

  @IsOptional()
  @IsBoolean()
  isActive?: boolean;

  @IsOptional()
  @IsBoolean()
  isDefault?: boolean;

  @IsOptional()
  @IsInt()
  displayOrder?: number;
}

/** ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿DTO */
export class QueryPrintTemplatesDto {
  @IsOptional()
  @IsEnum(PrintTemplateCategory)
  category?: PrintTemplateCategory;

  @IsOptional()
  @IsBoolean()
  @Type(() => Boolean)
  isActive?: boolean;

  @IsOptional()
  @IsString()
  tenantId?: string;

  @IsOptional()
  @IsBoolean()
  @Type(() => Boolean)
  includeGlobal?: boolean; // ãƒ†ãƒŠãƒ³ãƒˆæŒ‡å®šæ™‚ã€å…±é€šãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚‚å«ã‚ã‚‹ã‹
}

/** ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆè¤‡è£½DTO */
export class DuplicatePrintTemplateDto {
  @IsString()
  name: string;

  @IsOptional()
  @IsString()
  tenantId?: string;
}

/** ãƒ¬ã‚¹ãƒãƒ³ã‚¹å‹ */
export interface PrintTemplateResponse {
  id: string;
  tenantId: string | null;
  name: string;
  description: string | null;
  category: PrintTemplateCategory;
  paperWidth: number;
  paperHeight: number;
  backgroundUrl: string | null;
  backgroundOpacity: number;
  positions: Record<string, unknown>;
  fontSizes: Record<string, number> | null;
  isActive: boolean;
  isDefault: boolean;
  displayOrder: number;
  createdAt: Date;
  updatedAt: Date;
}
`````

## File: backend/src/print-templates/index.ts
`````typescript
export * from './print-templates.module';
export * from './print-templates.service';
export * from './print-templates.controller';
export * from './dto';
`````

## File: backend/src/print-templates/print-templates.controller.ts
`````typescript
import {
  Controller,
  Get,
  Post,
  Patch,
  Delete,
  Body,
  Param,
  Query,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';

import {
  CreatePrintTemplateDto,
  UpdatePrintTemplateDto,
  QueryPrintTemplatesDto,
  DuplicatePrintTemplateDto,
  PrintTemplateCategory,
} from './dto';
import { PrintTemplatesService } from './print-templates.service';

@Controller('print-templates')
export class PrintTemplatesController {
  constructor(private readonly service: PrintTemplatesService) {}

  /**
   * åˆ©ç”¨å¯èƒ½ãªã‚«ãƒ†ã‚´ãƒªä¸€è¦§ã‚’å–å¾—
   * GET /api/v1/print-templates/categories
   */
  @Get('categories')
  getCategories() {
    return {
      success: true,
      data: this.service.getCategories(),
    };
  }

  /**
   * ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä¸€è¦§ã‚’å–å¾—
   * GET /api/v1/print-templates
   */
  @Get()
  async findAll(@Query() query: QueryPrintTemplatesDto) {
    const templates = await this.service.findAll(query);
    return {
      success: true,
      data: templates,
    };
  }

  /**
   * ã‚«ãƒ†ã‚´ãƒªåˆ¥ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä¸€è¦§ã‚’å–å¾—
   * GET /api/v1/print-templates/category/:category
   */
  @Get('category/:category')
  async findByCategory(
    @Param('category') category: PrintTemplateCategory,
    @Query('tenantId') tenantId?: string,
  ) {
    const templates = await this.service.findByCategory(category, tenantId);
    return {
      success: true,
      data: templates,
    };
  }

  /**
   * ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’å–å¾—
   * GET /api/v1/print-templates/default/:category
   */
  @Get('default/:category')
  async findDefault(
    @Param('category') category: PrintTemplateCategory,
    @Query('tenantId') tenantId?: string,
  ) {
    const template = await this.service.findDefault(category, tenantId);
    return {
      success: true,
      data: template,
    };
  }

  /**
   * ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’1ä»¶å–å¾—
   * GET /api/v1/print-templates/:id
   */
  @Get(':id')
  async findOne(@Param('id') id: string) {
    const template = await this.service.findOne(id);
    return {
      success: true,
      data: template,
    };
  }

  /**
   * ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ä½œæˆ
   * POST /api/v1/print-templates
   */
  @Post()
  async create(@Body() dto: CreatePrintTemplateDto) {
    const template = await this.service.create(dto, dto.tenantId);
    return {
      success: true,
      data: template,
    };
  }

  /**
   * ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’è¤‡è£½
   * POST /api/v1/print-templates/:id/duplicate
   */
  @Post(':id/duplicate')
  async duplicate(
    @Param('id') id: string,
    @Body() dto: DuplicatePrintTemplateDto,
  ) {
    const template = await this.service.duplicate(id, dto);
    return {
      success: true,
      data: template,
    };
  }

  /**
   * ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’æ›´æ–°
   * PATCH /api/v1/print-templates/:id
   */
  @Patch(':id')
  async update(
    @Param('id') id: string,
    @Body() dto: UpdatePrintTemplateDto,
  ) {
    const template = await this.service.update(id, dto);
    return {
      success: true,
      data: template,
    };
  }

  /**
   * ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’å‰Šé™¤
   * DELETE /api/v1/print-templates/:id
   */
  @Delete(':id')
  @HttpCode(HttpStatus.NO_CONTENT)
  async remove(@Param('id') id: string) {
    await this.service.remove(id);
  }
}
`````

## File: backend/src/print-templates/print-templates.module.ts
`````typescript
import { Module } from '@nestjs/common';

import { PrismaModule } from '../prisma/prisma.module';

import { PrintTemplatesController } from './print-templates.controller';
import { PrintTemplatesService } from './print-templates.service';

@Module({
  imports: [PrismaModule],
  controllers: [PrintTemplatesController],
  providers: [PrintTemplatesService],
  exports: [PrintTemplatesService],
})
export class PrintTemplatesModule {}
`````

## File: backend/src/print-templates/print-templates.service.ts
`````typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { Prisma } from '@prisma/client';

import { PrismaService } from '../prisma/prisma.service';

import {
  CreatePrintTemplateDto,
  UpdatePrintTemplateDto,
  QueryPrintTemplatesDto,
  DuplicatePrintTemplateDto,
  PrintTemplateCategory,
  PrintTemplateResponse,
} from './dto';

@Injectable()
export class PrintTemplatesService {
  constructor(private readonly prisma: PrismaService) {}

  /**
   * ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä¸€è¦§ã‚’å–å¾—
   */
  async findAll(query: QueryPrintTemplatesDto): Promise<PrintTemplateResponse[]> {
    const where: Prisma.PrintTemplateWhereInput = {};

    if (query.category) {
      where.category = query.category;
    }

    if (query.isActive !== undefined) {
      where.isActive = query.isActive;
    }

    if (query.tenantId) {
      if (query.includeGlobal) {
        // ãƒ†ãƒŠãƒ³ãƒˆå›ºæœ‰ + å…±é€šãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
        where.OR = [
          { tenantId: query.tenantId },
          { tenantId: null },
        ];
      } else {
        where.tenantId = query.tenantId;
      }
    }

    const templates = await this.prisma.printTemplate.findMany({
      where,
      orderBy: [
        { category: 'asc' },
        { displayOrder: 'asc' },
        { name: 'asc' },
      ],
    });

    return templates.map(this.mapToResponse);
  }

  /**
   * ã‚«ãƒ†ã‚´ãƒªã”ã¨ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä¸€è¦§ã‚’å–å¾—
   */
  async findByCategory(
    category: PrintTemplateCategory,
    tenantId?: string,
  ): Promise<PrintTemplateResponse[]> {
    const where: Prisma.PrintTemplateWhereInput = {
      category,
      isActive: true,
    };

    if (tenantId) {
      where.OR = [
        { tenantId },
        { tenantId: null },
      ];
    }

    const templates = await this.prisma.printTemplate.findMany({
      where,
      orderBy: [
        { isDefault: 'desc' },
        { displayOrder: 'asc' },
        { name: 'asc' },
      ],
    });

    return templates.map(this.mapToResponse);
  }

  /**
   * ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’1ä»¶å–å¾—
   */
  async findOne(id: string): Promise<PrintTemplateResponse> {
    const template = await this.prisma.printTemplate.findUnique({
      where: { id },
    });

    if (!template) {
      throw new NotFoundException(`ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${id}`);
    }

    return this.mapToResponse(template);
  }

  /**
   * ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’å–å¾—
   */
  async findDefault(
    category: PrintTemplateCategory,
    tenantId?: string,
  ): Promise<PrintTemplateResponse | null> {
    // ã¾ãšãƒ†ãƒŠãƒ³ãƒˆå›ºæœ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’æ¢ã™
    if (tenantId) {
      const tenantDefault = await this.prisma.printTemplate.findFirst({
        where: {
          category,
          tenantId,
          isDefault: true,
          isActive: true,
        },
      });
      if (tenantDefault) {
        return this.mapToResponse(tenantDefault);
      }
    }

    // ãªã‘ã‚Œã°å…±é€šãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’æ¢ã™
    const globalDefault = await this.prisma.printTemplate.findFirst({
      where: {
        category,
        tenantId: null,
        isDefault: true,
        isActive: true,
      },
    });

    return globalDefault ? this.mapToResponse(globalDefault) : null;
  }

  /**
   * ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ä½œæˆ
   */
  async create(
    dto: CreatePrintTemplateDto,
    tenantId?: string,
  ): Promise<PrintTemplateResponse> {
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã®å ´åˆã€åŒã‚«ãƒ†ã‚´ãƒªã®æ—¢å­˜ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’è§£é™¤
    if (dto.isDefault) {
      await this.clearDefaultForCategory(dto.category, tenantId ?? null);
    }

    const template = await this.prisma.printTemplate.create({
      data: {
        tenantId: tenantId || null,
        name: dto.name,
        description: dto.description,
        category: dto.category,
        paperWidth: dto.paperWidth,
        paperHeight: dto.paperHeight,
        backgroundUrl: dto.backgroundUrl,
        backgroundOpacity: dto.backgroundOpacity ?? 100,
        positions: dto.positions as Prisma.InputJsonValue,
        fontSizes: dto.fontSizes as Prisma.InputJsonValue,
        isDefault: dto.isDefault ?? false,
        displayOrder: dto.displayOrder ?? 0,
      },
    });

    return this.mapToResponse(template);
  }

  /**
   * ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’æ›´æ–°
   */
  async update(
    id: string,
    dto: UpdatePrintTemplateDto,
  ): Promise<PrintTemplateResponse> {
    const existing = await this.prisma.printTemplate.findUnique({
      where: { id },
    });

    if (!existing) {
      throw new NotFoundException(`ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${id}`);
    }

    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«è¨­å®šã™ã‚‹å ´åˆã€åŒã‚«ãƒ†ã‚´ãƒªã®æ—¢å­˜ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’è§£é™¤
    if (dto.isDefault && !existing.isDefault) {
      const category = dto.category || (existing.category as PrintTemplateCategory);
      await this.clearDefaultForCategory(category, existing.tenantId);
    }

    const template = await this.prisma.printTemplate.update({
      where: { id },
      data: {
        name: dto.name,
        description: dto.description,
        category: dto.category,
        paperWidth: dto.paperWidth,
        paperHeight: dto.paperHeight,
        backgroundUrl: dto.backgroundUrl,
        backgroundOpacity: dto.backgroundOpacity,
        positions: dto.positions as Prisma.InputJsonValue,
        fontSizes: dto.fontSizes as Prisma.InputJsonValue,
        isActive: dto.isActive,
        isDefault: dto.isDefault,
        displayOrder: dto.displayOrder,
      },
    });

    return this.mapToResponse(template);
  }

  /**
   * ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’å‰Šé™¤
   */
  async remove(id: string): Promise<void> {
    const existing = await this.prisma.printTemplate.findUnique({
      where: { id },
    });

    if (!existing) {
      throw new NotFoundException(`ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${id}`);
    }

    await this.prisma.printTemplate.delete({
      where: { id },
    });
  }

  /**
   * ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’è¤‡è£½
   */
  async duplicate(
    id: string,
    dto: DuplicatePrintTemplateDto,
  ): Promise<PrintTemplateResponse> {
    const source = await this.prisma.printTemplate.findUnique({
      where: { id },
    });

    if (!source) {
      throw new NotFoundException(`ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${id}`);
    }

    const template = await this.prisma.printTemplate.create({
      data: {
        tenantId: dto.tenantId || source.tenantId,
        name: dto.name,
        description: source.description ? `${source.description} (ã‚³ãƒ”ãƒ¼)` : null,
        category: source.category as PrintTemplateCategory,
        paperWidth: source.paperWidth,
        paperHeight: source.paperHeight,
        backgroundUrl: source.backgroundUrl,
        backgroundOpacity: source.backgroundOpacity,
        positions: source.positions as Prisma.InputJsonValue,
        fontSizes: source.fontSizes as Prisma.InputJsonValue,
        isDefault: false, // è¤‡è£½ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«ã—ãªã„
        displayOrder: source.displayOrder,
      },
    });

    return this.mapToResponse(template);
  }

  /**
   * åˆ©ç”¨å¯èƒ½ãªã‚«ãƒ†ã‚´ãƒªä¸€è¦§ã‚’å–å¾—
   */
  getCategories(): Array<{ value: PrintTemplateCategory; label: string }> {
    return Object.values(PrintTemplateCategory).map((value) => ({
      value,
      label: this.getCategoryLabel(value),
    }));
  }

  /**
   * åŒã‚«ãƒ†ã‚´ãƒªãƒ»åŒãƒ†ãƒŠãƒ³ãƒˆã®æ—¢å­˜ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’è§£é™¤
   */
  private async clearDefaultForCategory(
    category: PrintTemplateCategory,
    tenantId: string | null,
  ): Promise<void> {
    await this.prisma.printTemplate.updateMany({
      where: {
        category,
        tenantId,
        isDefault: true,
      },
      data: {
        isDefault: false,
      },
    });
  }

  /**
   * ã‚«ãƒ†ã‚´ãƒªã®æ—¥æœ¬èªãƒ©ãƒ™ãƒ«ã‚’å–å¾—
   */
  private getCategoryLabel(category: PrintTemplateCategory): string {
    const labels: Record<PrintTemplateCategory, string> = {
      [PrintTemplateCategory.PEDIGREE]: 'è¡€çµ±æ›¸',
      [PrintTemplateCategory.KITTEN_TRANSFER]: 'å­çŒ«è­²æ¸¡è¨¼æ˜æ›¸',
      [PrintTemplateCategory.HEALTH_CERTIFICATE]: 'å¥åº·è¨ºæ–­æ›¸',
      [PrintTemplateCategory.VACCINATION_RECORD]: 'ãƒ¯ã‚¯ãƒãƒ³æ¥ç¨®è¨˜éŒ²',
      [PrintTemplateCategory.BREEDING_RECORD]: 'ç¹æ®–è¨˜éŒ²',
      [PrintTemplateCategory.CONTRACT]: 'å¥‘ç´„æ›¸',
      [PrintTemplateCategory.INVOICE]: 'è«‹æ±‚æ›¸/é ˜åæ›¸',
      [PrintTemplateCategory.CUSTOM]: 'ã‚«ã‚¹ã‚¿ãƒ æ›¸é¡',
    };
    return labels[category] || category;
  }

  /**
   * DBãƒ¢ãƒ‡ãƒ«ã‚’ãƒ¬ã‚¹ãƒãƒ³ã‚¹å‹ã«å¤‰æ›
   */
  private mapToResponse(template: {
    id: string;
    tenantId: string | null;
    name: string;
    description: string | null;
    category: string;
    paperWidth: number;
    paperHeight: number;
    backgroundUrl: string | null;
    backgroundOpacity: number;
    positions: Prisma.JsonValue;
    fontSizes: Prisma.JsonValue;
    isActive: boolean;
    isDefault: boolean;
    displayOrder: number;
    createdAt: Date;
    updatedAt: Date;
  }): PrintTemplateResponse {
    return {
      id: template.id,
      tenantId: template.tenantId,
      name: template.name,
      description: template.description,
      category: template.category as PrintTemplateCategory,
      paperWidth: template.paperWidth,
      paperHeight: template.paperHeight,
      backgroundUrl: template.backgroundUrl,
      backgroundOpacity: template.backgroundOpacity,
      positions: template.positions as Record<string, unknown>,
      fontSizes: template.fontSizes as Record<string, number> | null,
      isActive: template.isActive,
      isDefault: template.isDefault,
      displayOrder: template.displayOrder,
      createdAt: template.createdAt,
      updatedAt: template.updatedAt,
    };
  }
}
`````

## File: backend/src/prisma/prisma.module.ts
`````typescript
import { Global, Module } from "@nestjs/common";

import { PrismaService } from "./prisma.service";

@Global()
@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}
`````

## File: backend/src/prisma/prisma.service.ts
`````typescript
import {
  Injectable,
  OnModuleInit,
  OnModuleDestroy,
  Logger,
} from "@nestjs/common";
import { PrismaClient } from "@prisma/client";

@Injectable()
export class PrismaService
  extends PrismaClient
  implements OnModuleInit, OnModuleDestroy
{
  private readonly logger = new Logger(PrismaService.name);

  constructor() {
    super({
      log: process.env.NODE_ENV === 'production' 
        ? ['error', 'warn'] 
        : ['query', 'info', 'warn', 'error'],
      errorFormat: 'minimal',
    });
  }

  async onModuleInit() {
    try {
      this.logger.log("Connecting to database...");
      await this.$connect();
      this.logger.log("âœ… Successfully connected to database");
      
      // Test database connectivity
      await this.$queryRaw`SELECT 1`;
      this.logger.log("âœ… Database health check passed");
      
    } catch (error) {
      this.logger.error("âŒ Failed to connect to database:", error);
      throw error;
    }
  }

  async onModuleDestroy() {
    try {
      this.logger.log("ğŸ”Œ Disconnecting from database...");
      await this.$disconnect();
      this.logger.log("ğŸ”Œ Successfully disconnected from database");
    } catch (error) {
      this.logger.error("âŒ Failed to disconnect from database:", error);
    }
  }

  // Health check method for monitoring
  async healthCheck(): Promise<boolean> {
    try {
      await this.$queryRaw`SELECT 1`;
      return true;
    } catch {
      return false;
    }
  }

  // Connection count for monitoring
  async getConnectionCount(): Promise<number> {
    try {
      const result = await this.$queryRaw<[{ count: number }]>`
        SELECT count(*) as count FROM pg_stat_activity 
        WHERE state = 'active' AND application_name LIKE '%prisma%'
      `;
      return result[0]?.count || 0;
    } catch {
      return -1;
    }
  }
}
`````

## File: backend/src/prisma/seed.ts
`````typescript
import { PrismaClient, UserRole } from "@prisma/client";
import * as argon2 from "argon2";

import { BREED_MASTER_DATA } from "../breeds/breed-master.data";
import { GENDER_MASTER } from "../cats/constants/gender";
import { COAT_COLOR_MASTER_DATA } from "../coat-colors/coat-color-master.data";

const prisma = new PrismaClient();

async function syncBreedMasterData() {
  console.log("â¡ï¸ Syncing breed master data...");
  for (const record of BREED_MASTER_DATA) {
    await prisma.breed.upsert({
      where: { code: record.code },
      update: {
        name: record.name ?? "",
        description: null,
        isActive: true,
      },
      create: {
        code: record.code,
        name: record.name ?? "",
        description: null,
        isActive: true,
      },
    });
  }
  console.log(`âœ… Synced ${BREED_MASTER_DATA.length} breed records`);
}

async function syncCoatColorMasterData() {
  console.log("â¡ï¸ Syncing coat color master data...");
  for (const record of COAT_COLOR_MASTER_DATA) {
    await prisma.coatColor.upsert({
      where: { code: record.code },
      update: {
        name: record.name ?? "",
        description: null,
        isActive: true,
      },
      create: {
        code: record.code,
        name: record.name ?? "",
        description: null,
        isActive: true,
      },
    });
  }
  console.log(`âœ… Synced ${COAT_COLOR_MASTER_DATA.length} coat color records`);
}

async function syncGenderMasterData() {
  console.log("â¡ï¸ Syncing gender master data...");
  for (const record of GENDER_MASTER) {
    const code = Number.parseInt(record.key, 10);
    if (Number.isNaN(code)) {
      continue;
    }

    await prisma.gender.upsert({
      where: { code },
      update: {
        name: record.name,
        description: record.canonical,
        isActive: true,
      },
      create: {
        code,
        name: record.name,
        description: record.canonical,
        isActive: true,
      },
    });
  }
  console.log(`âœ… Synced ${GENDER_MASTER.length} gender records`);
}

async function syncMasterData() {
  await syncBreedMasterData();
  await syncCoatColorMasterData();
  await syncGenderMasterData();
}

async function main() {
  console.log("Seeding database...");

  // 1) Admin user (ENV override, éç ´å£ŠåŒ–ãƒ­ã‚¸ãƒƒã‚¯)
  const email = (process.env.ADMIN_EMAIL || "admin@example.com").toLowerCase();
  const password = process.env.ADMIN_PASSWORD || "Passw0rd!";
  const forceUpdate = process.env.ADMIN_FORCE_UPDATE === "1"; // æ—¢å­˜ç®¡ç†è€…ã‚’å¼·åˆ¶æ›´æ–°ã™ã‚‹ã‹

  const existingAdmin = await prisma.user.findUnique({ where: { email } });
  let adminAction: "created" | "kept" | "updated" = "kept";
  let admin: { id: string };

  if (!existingAdmin) {
    // æ–°è¦ä½œæˆ
    const hash = await argon2.hash(password, {
      type: argon2.argon2id,
      memoryCost: 65536,
      timeCost: 3,
      parallelism: 4,
      hashLength: 64,
    });
    admin = await prisma.user.create({
      data: {
        clerkId: "local_admin",
        email,
        firstName: "Admin",
        lastName: "User",
        role: UserRole.ADMIN,
        isActive: true,
        passwordHash: hash,
      },
    });
    adminAction = "created";
  } else {
    // æ—¢å­˜: åŸå‰‡ passwordHash ã‚’å¤‰æ›´ã—ãªã„ / å½¹å‰²ã‚„æœ‰åŠ¹åŒ–ã®ã¿èª¿æ•´
    let needsUpdate = false;
    const updateData: Partial<typeof existingAdmin> = {};
    if (existingAdmin.role !== UserRole.ADMIN) {
      updateData.role = UserRole.ADMIN;
      needsUpdate = true;
    }
    if (!existingAdmin.isActive) {
      updateData.isActive = true;
      needsUpdate = true;
    }
    if (forceUpdate) {
      const hash = await argon2.hash(password, {
        type: argon2.argon2id,
        memoryCost: 65536,
        timeCost: 3,
        parallelism: 4,
        hashLength: 64,
      });
      updateData.passwordHash = hash;
      needsUpdate = true;
    }
    if (needsUpdate) {
      admin = await prisma.user.update({ where: { email }, data: updateData });
      adminAction = forceUpdate ? "updated" : "updated"; // updated (role/status or password)
    } else {
      admin = existingAdmin;
      adminAction = "kept";
    }
  }

  await syncMasterData();

  // 2) Sample tag category & tag
  const category = await prisma.tagCategory.upsert({
    where: { key: "cat_status" },
    update: {
      name: "çŒ«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹",
      description: "çŒ«ã®çŠ¶æ…‹ã‚’åˆ¤åˆ¥ã™ã‚‹ã‚µãƒ³ãƒ—ãƒ«ã‚«ãƒ†ã‚´ãƒª",
      color: "#6366F1",
      displayOrder: 1,
      scopes: ["cats"],
      isActive: true,
    },
    create: {
      key: "cat_status",
      name: "çŒ«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹",
      description: "çŒ«ã®çŠ¶æ…‹ã‚’åˆ¤åˆ¥ã™ã‚‹ã‚µãƒ³ãƒ—ãƒ«ã‚«ãƒ†ã‚´ãƒª",
      color: "#6366F1",
      displayOrder: 1,
      scopes: ["cats"],
      isActive: true,
    },
  });

  const group = await prisma.tagGroup.upsert({
    where: {
      categoryId_name: {
        categoryId: category.id,
        name: "default",
      },
    },
    update: {
      description: category.description,
      displayOrder: category.displayOrder,
      isActive: category.isActive,
    },
    create: {
      name: "default",
      description: category.description,
      displayOrder: category.displayOrder,
      isActive: category.isActive,
      category: { connect: { id: category.id } },
    },
  });

  const tag = await prisma.tag.upsert({
    where: {
      groupId_name: {
        groupId: group.id,
        name: "indoor",
      },
    },
    update: {
      color: "#10B981",
      allowsManual: true,
      allowsAutomation: true,
      metadata: { description: "å®¤å†…é£¼ã„çŒ«" },
      isActive: true,
    },
    create: {
      name: "indoor",
      color: "#10B981",
      allowsManual: true,
      allowsAutomation: true,
      metadata: { description: "å®¤å†…é£¼ã„çŒ«" },
      isActive: true,
      group: { connect: { id: group.id } },
    },
  });

  console.log("Seed complete âœ…");
  console.log("Admin:", { email, password: forceUpdate || adminAction === "created" ? password : "(unchanged)", id: admin.id, action: adminAction });
  console.log("Tag Category:", { id: category.id, key: category.key, name: category.name });
  console.log("Tag Group:", { id: group.id, name: group.name, categoryId: group.categoryId });
  console.log("Tag:", { id: tag.id, name: tag.name, groupId: tag.groupId });

  // --- Additional test data: Breeding tag category/group/tags and NG rule ---
  const breedingCategory = await prisma.tagCategory.upsert({
    where: { key: 'breeding' },
    update: { name: 'Breeding', description: 'Breeding related tags', scopes: ['cats'] },
    create: { key: 'breeding', name: 'Breeding', description: 'Breeding related tags', scopes: ['cats'] },
  });

  const bodyGroup = await prisma.tagGroup.findFirst({ where: { categoryId: breedingCategory.id, name: 'Body-Type' } });
  const tagGroupBody = bodyGroup ?? await prisma.tagGroup.create({ data: { categoryId: breedingCategory.id, name: 'Body-Type', description: 'Body type tags' } });

  const shortTag = await prisma.tag.upsert({
    where: { groupId_name: { groupId: tagGroupBody.id, name: 'çŸ­è¶³' } },
    update: { isActive: true },
    create: { groupId: tagGroupBody.id, name: 'çŸ­è¶³', color: '#F97316', textColor: '#FFFFFF' },
  });

  const longTag = await prisma.tag.upsert({
    where: { groupId_name: { groupId: tagGroupBody.id, name: 'é•·è¶³' } },
    update: { isActive: true },
    create: { groupId: tagGroupBody.id, name: 'é•·è¶³', color: '#06B6D4', textColor: '#FFFFFF' },
  });

  // Assign tags to sample cats if they exist
  const alpha = await prisma.cat.findUnique({ where: { id: 'a1111111-1111-4111-8111-111111111111' } });
  const anna = await prisma.cat.findUnique({ where: { id: 'a2222222-2222-4222-8222-222222222222' } });
  if (alpha) {
    await prisma.catTag.upsert({ where: { catId_tagId: { catId: alpha.id, tagId: shortTag.id } }, update: {}, create: { catId: alpha.id, tagId: shortTag.id } });
  }
  if (anna) {
    await prisma.catTag.upsert({ where: { catId_tagId: { catId: anna.id, tagId: longTag.id } }, update: {}, create: { catId: anna.id, tagId: longTag.id } });
  }

  // Create breeding NG rule if not exists
  const ngRule = await prisma.breedingNgRule.findFirst({ where: { name: 'çŸ­è¶³Ã—é•·è¶³ç¦æ­¢' } });
  if (!ngRule) {
    await prisma.breedingNgRule.create({ data: { name: 'çŸ­è¶³Ã—é•·è¶³ç¦æ­¢', description: 'çŸ­è¶³(ã‚ªã‚¹) ã¨ é•·è¶³(ãƒ¡ã‚¹) ã®çµ„åˆã›ã‚’ç¦æ­¢ (ãƒ†ã‚¹ãƒˆ)', type: 'TAG_COMBINATION', maleConditions: [shortTag.name], femaleConditions: [longTag.name], active: true } });
  }

  console.log('âœ… Added breeding tags and NG rule (çŸ­è¶³/é•·è¶³)');
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(() => {
    void prisma.$disconnect();
  });
`````

## File: backend/src/schedule/schedule.module.ts
`````typescript
import { Module } from "@nestjs/common";

@Module({
  controllers: [],
  providers: [],
})
export class ScheduleModule {}
`````

## File: backend/src/scripts/utils/prisma-batch.ts
`````typescript
import type { Prisma, PrismaClient } from '@prisma/client';

export type BatchResult<T> = {
  total: number;
  success: number;
  failed: number;
  errors: Array<{ index: number; item: T; error: unknown }>;
};

export type BatchOptions = {
  batchSize?: number; // ä»¶æ•°å˜ä½ã§ã®å°ãƒãƒƒãƒï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 100ï¼‰
  continueOnError?: boolean; // ãƒãƒƒãƒå†…ã®ä¸€éƒ¨å¤±æ•—æ™‚ã«ç¶šè¡Œã™ã‚‹ã‹ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: trueï¼‰
  logEvery?: number; // é€²æ—ãƒ­ã‚°ã‚’å‡ºã™é–“éš”ï¼ˆä»¶æ•°ãƒ™ãƒ¼ã‚¹ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 500ï¼‰
  label?: string; // ãƒ­ã‚°ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹
};

/**
 * ä¸ãˆã‚‰ã‚ŒãŸé…åˆ—ã‚’å°ãƒãƒƒãƒã«åˆ†ã‘ã€å„ãƒãƒƒãƒã‚’ prisma.$transaction ã§ã¾ã¨ã‚ã¦å®Ÿè¡Œã—ã¾ã™ã€‚
 * ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹é¢ã§ã®å¾€å¾©å›æ•°å‰Šæ¸›ã¨ã€ãƒ­ã‚°ã®ã‚¹ãƒ­ãƒƒãƒˆãƒªãƒ³ã‚°ãŒç›®çš„ã§ã™ã€‚
 */
export async function batchTransaction<T>(
  prisma: PrismaClient,
  items: T[],
  builder: (tx: Prisma.TransactionClient, item: T, index: number) => Promise<unknown>,
  options: BatchOptions = {},
): Promise<BatchResult<T>> {
  const {
    batchSize = 100,
    continueOnError = true,
    logEvery = 500,
    label = 'batch',
  } = options;

  const total = items.length;
  let processed = 0;
  let success = 0;
  const errors: BatchResult<T>['errors'] = [];

  const t0 = Date.now();
  for (let start = 0; start < items.length; start += batchSize) {
    const end = Math.min(start + batchSize, items.length);
    const chunk = items.slice(start, end);

    try {
      await prisma.$transaction(async (tx) => {
        for (let i = 0; i < chunk.length; i++) {
          const item = chunk[i];
          const globalIndex = start + i;
          await builder(tx, item, globalIndex);
        }
      });
      success += chunk.length;
    } catch (e) {
      // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å…¨ä½“ãŒãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ã•ã‚Œã‚‹ãŸã‚ã€å€‹åˆ¥ã«ãƒªãƒˆãƒ©ã‚¤ã¯ã›ãšã€å¿…è¦ãªã‚‰1ä»¶ãšã¤å®Ÿè¡Œ
      if (!continueOnError) {
        throw e;
      }
      // 1ä»¶ãšã¤å®Ÿè¡Œã—ã€å¤±æ•—ã—ãŸã‚‚ã®ã ã‘ã‚¨ãƒ©ãƒ¼åé›†
      for (let i = 0; i < chunk.length; i++) {
        const item = chunk[i];
        const globalIndex = start + i;
        try {
          await prisma.$transaction((tx) => builder(tx, item, globalIndex));
          success += 1;
        } catch (err) {
          errors.push({ index: globalIndex, item, error: err });
        }
      }
    }

    processed = end;
    if (processed % logEvery === 0 || processed === total) {
      const dt = Date.now() - t0;
       
      console.log(
        `[${label}] ${processed}/${total} done (${((processed / total) * 100).toFixed(
          1,
        )}%), ok=${success}, err=${errors.length}, ${dt}ms`,
      );
    }
  }

  return {
    total,
    success,
    failed: errors.length,
    errors,
  };
}

/**
 * èª­ã¿å–ã‚Šç³»ã‚„ä»»æ„é–¢æ•°ã‚’å°ãƒãƒƒãƒã§é †æ¬¡å®Ÿè¡Œã—ãŸã„å ´åˆã®æ±ç”¨ãƒ˜ãƒ«ãƒ‘ãƒ¼ã€‚
 */
export async function forEachChunk<T>(
  items: T[],
  fn: (chunk: T[], start: number, end: number) => Promise<void>,
  { batchSize = 100, logEvery = 500, label = 'chunk' }: BatchOptions = {},
) {
  const total = items.length;
  const t0 = Date.now();
  for (let start = 0; start < items.length; start += batchSize) {
    const end = Math.min(start + batchSize, items.length);
    const chunk = items.slice(start, end);
    await fn(chunk, start, end);
    if (end % logEvery === 0 || end === total) {
      const dt = Date.now() - t0;
       
      console.log(
        `[${label}] ${end}/${total} done (${((end / total) * 100).toFixed(1)}%), ${dt}ms`,
      );
    }
  }
}
`````

## File: backend/src/scripts/build-pedigree-relations.ts
`````typescript
import * as fs from "fs";
import * as path from "path";

import { PrismaClient } from "@prisma/client";
import { parse } from "csv-parse";

const prisma = new PrismaClient();

/**
 * è¡€çµ±æ›¸ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ§‹ç¯‰ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
 *
 * JCUæƒ…å ±ã‚’ä½¿ç”¨ã—ã¦çˆ¶æ¯ã®ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ§‹ç¯‰
 * JCUå½¢å¼: "JCU-No XXXXXX-YYYYYY" ã¾ãŸã¯ "WCA-No XXXXXX-YYYYYY"
 */

interface PedigreeRelationData {
  PedigreeID: string;
  FatherJCU: string;
  MotherJCU: string;
}

interface PedigreeUpdateData {
  fatherPedigreeId?: string;
  motherPedigreeId?: string;
}

async function buildPedigreeRelations() {
  const csvPath = path.join(
    __dirname,
    "../../NewPedigree/è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿Renamed.csv",
  );

  try {
    console.log("ğŸ”„ è¡€çµ±æ›¸ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ§‹ç¯‰ã‚’é–‹å§‹...\n");

    // 1. CSV ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
    console.log("ğŸ“ CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­...");
    const records: PedigreeRelationData[] = [];

    await new Promise<void>((resolve, reject) => {
      fs.createReadStream(csvPath)
        .pipe(
          parse({
            columns: true,
            skip_empty_lines: true,
            trim: true,
          }),
        )
        .on("data", (record: Record<string, string>) => {
          records.push({
            PedigreeID: record.PedigreeID,
            FatherJCU: record.FatherJCU,
            MotherJCU: record.MotherJCU,
          });
        })
        .on("end", () => {
          console.log(`ğŸ“Š CSVãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å®Œäº†: ${records.length}ä»¶`);
          resolve();
        })
        .on("error", reject);
    });

    // 2. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã®è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
    console.log("ğŸ—„ï¸  ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ä¸­...");
    const pedigrees = await prisma.pedigree.findMany({
      select: {
        id: true,
        pedigreeId: true,
      },
    });

    console.log(`ğŸ“Š ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…è¡€çµ±æ›¸: ${pedigrees.length}ä»¶`);

    // 3. è¡€çµ±æ›¸ç•ªå·ã‹ã‚‰UUIDã¸ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ä½œæˆ
    const pedigreeMap = new Map<string, string>();

    pedigrees.forEach((p) => {
      if (p.pedigreeId) {
        pedigreeMap.set(p.pedigreeId, p.id);
      }
    });

    console.log(`ğŸ“‹ è¡€çµ±æ›¸ãƒãƒƒãƒ”ãƒ³ã‚°: ${pedigreeMap.size}ä»¶`);

    // 4. ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ§‹ç¯‰
    let relationCount = 0;
    let errorCount = 0;

    console.log("ğŸ”— ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ§‹ç¯‰ä¸­...\n");

    for (const record of records) {
      if (!pedigreeMap.has(record.PedigreeID)) {
        continue; // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«å­˜åœ¨ã—ãªã„è¡€çµ±æ›¸ã¯ã‚¹ã‚­ãƒƒãƒ—
      }

      try {
        const updateData: PedigreeUpdateData = {};

        // çˆ¶è¦ªã®ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
        const fatherPedigreeId = extractPedigreeNumber(record.FatherJCU);
        if (fatherPedigreeId && pedigreeMap.has(fatherPedigreeId)) {
          updateData.fatherPedigreeId = pedigreeMap.get(fatherPedigreeId);
        }

        // æ¯è¦ªã®ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
        const motherPedigreeId = extractPedigreeNumber(record.MotherJCU);
        if (motherPedigreeId && pedigreeMap.has(motherPedigreeId)) {
          updateData.motherPedigreeId = pedigreeMap.get(motherPedigreeId);
        }

        // ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã™ã‚‹å†…å®¹ãŒã‚ã‚‹å ´åˆã®ã¿å®Ÿè¡Œ
        if (Object.keys(updateData).length > 0) {
          await prisma.pedigree.update({
            where: { pedigreeId: record.PedigreeID },
            data: updateData,
          });

          relationCount++;

          if (relationCount <= 10) {
            console.log(
              `âœ… ${record.PedigreeID}: ${Object.keys(updateData).join(", ")}`,
            );
          }
        }
      } catch (error) {
        console.error(`âŒ ã‚¨ãƒ©ãƒ¼ (ID: ${record.PedigreeID}):`, error);
        errorCount++;
      }
    }

    console.log("\nğŸ‰ ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ§‹ç¯‰å®Œäº†ï¼");
    console.log(`ğŸ“Š æˆåŠŸ: ${relationCount}ä»¶`);
    console.log(`âŒ ã‚¨ãƒ©ãƒ¼: ${errorCount}ä»¶`);

    // 5. çµæœç¢ºèª
    console.log("\nğŸ” æ§‹ç¯‰ã•ã‚ŒãŸãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç¢ºèª:");
    const relatedPedigrees = await prisma.pedigree.findMany({
      where: {
        OR: [
          { fatherPedigreeId: { not: null } },
          { motherPedigreeId: { not: null } },
        ],
      },
      include: {
        fatherPedigree: {
          select: { pedigreeId: true, catName: true },
        },
        motherPedigree: {
          select: { pedigreeId: true, catName: true },
        },
      },
      take: 10,
    });

    relatedPedigrees.forEach((p) => {
      const father = p.fatherPedigree
        ? `çˆ¶: ${p.fatherPedigree.pedigreeId} (${p.fatherPedigree.catName})`
        : "";
      const mother = p.motherPedigree
        ? `æ¯: ${p.motherPedigree.pedigreeId} (${p.motherPedigree.catName})`
        : "";
      console.log(`  ${p.pedigreeId}: ${father} ${mother}`);
    });
  } catch (error) {
    console.error("ğŸ’¥ ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ§‹ç¯‰ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:", error);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

/**
 * JCUæ–‡å­—åˆ—ã‹ã‚‰è¡€çµ±æ›¸ç•ªå·ã‚’æŠ½å‡º
 * ä¾‹: "JCU-No 921361-163553" -> "163553" (æœ«å°¾6æ¡)
 */
function extractPedigreeNumber(jcuString: string): string | null {
  if (!jcuString) return null;

  // "JCU-No " ã¾ãŸã¯ "WCA-No " ã‚’é™¤å»
  const match = jcuString.match(/(?:JCU-No|WCA-No)\s+(.+)/);
  if (match) {
    const fullNumber = match[1].trim();
    // "XXXXXX-YYYYYY" ã‹ã‚‰æœ«å°¾ã® "YYYYYY" ã‚’æŠ½å‡º
    const keyMatch = fullNumber.match(/^\d{6}-(\d{6})$/);
    if (keyMatch) {
      return keyMatch[1]; // æœ«å°¾6æ¡ã®ã‚­ãƒ¼éƒ¨åˆ†
    }
    return fullNumber;
  }

  // ç›´æ¥è¡€çµ±æ›¸ç•ªå·ã®å ´åˆ
  if (jcuString.match(/^\d{6}$/)) {
    return jcuString;
  }

  return null;
}

// ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œ
if (require.main === module) {
  // eslint-disable-next-line @typescript-eslint/no-floating-promises
  (async () => {
    try {
      await buildPedigreeRelations();
      console.log("ğŸ‰ è¡€çµ±æ›¸ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ§‹ç¯‰ãŒå®Œäº†ã—ã¾ã—ãŸï¼");
      process.exit(0);
    } catch (error) {
      console.error("ğŸ’¥ ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ§‹ç¯‰å‡¦ç†ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:", error);
      process.exit(1);
    }
  })();
}

export { buildPedigreeRelations };
`````

## File: backend/src/scripts/check-parent-pedigrees.ts
`````typescript
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

async function checkParentPedigrees() {
  try {
    // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã®å…¨è¡€çµ±æ›¸ç•ªå·ã‚’å–å¾—
    const allPedigrees = await prisma.pedigree.findMany({
      select: {
        pedigreeId: true,
        catName: true,
        breedCode: true,
        genderCode: true,
      },
    });

    console.log(`ğŸ“Š ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…è¡€çµ±æ›¸: ${allPedigrees.length}ä»¶`);
    console.log("è¡€çµ±æ›¸IDä¸€è¦§:");
    allPedigrees.forEach((p) => {
      console.log(
        `  ${p.pedigreeId} - ${p.catName || "åå‰ãªã—"} (çŒ«ç¨®: ${p.breedCode}, æ€§åˆ¥: ${p.genderCode})`,
      );
    });

    // æ¤œç´¢ã™ã‚‹çˆ¶æ¯ã®è¡€çµ±æ›¸ç•ªå·
    const searchPedigreeIds = [
      "921361-163553", // 701606ã®çˆ¶
      "941862-169010", // 701606ã®æ¯
      "841901-700538", // 701607ã®çˆ¶
      "441652-142007", // 701607ã®æ¯
      "662862-700900", // 701608ã®æ¯
      "400371-150501", // 701609ã®çˆ¶
      "391402-116197", // 701609ã®æ¯
    ];

    console.log("\nğŸ” çˆ¶æ¯è¡€çµ±æ›¸ç•ªå·ã®æ¤œç´¢çµæœ:");
    for (const pedigreeId of searchPedigreeIds) {
      const found = allPedigrees.find((p) => p.pedigreeId === pedigreeId);
      if (found) {
        console.log(
          `  âœ… ${pedigreeId}: è¦‹ã¤ã‹ã‚Šã¾ã—ãŸ - ${found.catName || "åå‰ãªã—"}`,
        );
      } else {
        console.log(`  âŒ ${pedigreeId}: è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ`);
      }
    }
  } catch (error) {
    console.error("ã‚¨ãƒ©ãƒ¼:", error);
  } finally {
    await prisma.$disconnect();
  }
}

void checkParentPedigrees();
`````

## File: backend/src/scripts/create-admin.ts
`````typescript
import { PrismaClient } from '@prisma/client';
import * as argon2 from 'argon2';

const prisma = new PrismaClient();

async function createAdmin() {
  try {
  const email = process.env.ADMIN_EMAIL || 'admin@example.com';
  const password = process.env.ADMIN_PASSWORD || 'Passw0rd!';

    console.log('ğŸ” ç®¡ç†è€…ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ç¢ºèªä¸­...');

    // æ—¢å­˜ãƒã‚§ãƒƒã‚¯
    const existing = await prisma.user.findUnique({ where: { email } });
    if (existing) {
      console.log('âœ… ç®¡ç†è€…ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™');
      console.log(`ğŸ“§ Email: ${email}`);
      console.log(`ğŸ”‘ Password: ${password}`);
      console.log('ğŸ‘¤ Role:', existing.role);
      return;
    }

    console.log('ğŸ” ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–ä¸­...');
    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥åŒ–
    const passwordHash = await argon2.hash(password, {
      type: argon2.argon2id,
      memoryCost: 65536,
      timeCost: 3,
      parallelism: 4,
    });

    console.log('ğŸ‘¤ ç®¡ç†è€…ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ä½œæˆä¸­...');
    // ç®¡ç†è€…ä½œæˆ
    const admin = await prisma.user.create({
      data: {
        clerkId: `admin-${Date.now()}`,
        email,
        passwordHash,
        role: 'ADMIN',
        isActive: true,
      },
    });

    console.log('âœ… ç®¡ç†è€…ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ä½œæˆã—ã¾ã—ãŸï¼');
    console.log('');
  console.log(`ğŸ“§ Email: ${email}`);
  console.log(`ğŸ”‘ Password: ${password}`);
    console.log('ğŸ‘¤ Role: ADMIN');
    console.log('ğŸ†” User ID:', admin.id);
    console.log('');
    console.log('ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸: http://localhost:3000/login');
  } catch (error) {
    console.error('âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:', error);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

void createAdmin();
`````

## File: backend/src/scripts/create-or-update-admin.ts
`````typescript
import { PrismaClient, UserRole } from "@prisma/client";
import * as argon2 from "argon2";

/**
 * å†å®Ÿè¡Œå®‰å…¨ãªç®¡ç†è€…ãƒ¦ãƒ¼ã‚¶ãƒ¼ create/update ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
 * ç’°å¢ƒå¤‰æ•°:
 *  ADMIN_EMAIL / ADMIN_PASSWORD / ADMIN_FORCE_UPDATE=1
 *
 * ä¾‹:
 *  ADMIN_FORCE_UPDATE=1 pnpm --filter backend exec ts-node src/scripts/create-or-update-admin.ts
 */
async function main() {
  const prisma = new PrismaClient();
  const email = (process.env.ADMIN_EMAIL || "admin@example.com").toLowerCase();
  const password = process.env.ADMIN_PASSWORD || "Passw0rd!";
  const forceUpdate = process.env.ADMIN_FORCE_UPDATE === "1";

  const existing = await prisma.user.findUnique({ where: { email } });

  if (!existing) {
    const hash = await argon2.hash(password, {
      type: argon2.argon2id,
      memoryCost: 65536,
      timeCost: 3,
      parallelism: 4,
    });
    const created = await prisma.user.create({
      data: {
        email,
        passwordHash: hash,
        role: UserRole.ADMIN,
        isActive: true,
        clerkId: "local_admin",
        firstName: "Admin",
        lastName: "User",
      },
    });
    console.log("âœ… Admin created", { id: created.id, email });
  } else {
  const updateData: Partial<typeof existing> = {};
    let changed = false;
    if (existing.role !== UserRole.ADMIN) {
      updateData.role = UserRole.ADMIN; changed = true;
    }
    if (!existing.isActive) { updateData.isActive = true; changed = true; }
    if (forceUpdate) {
      const hash = await argon2.hash(password, {
        type: argon2.argon2id,
        memoryCost: 65536,
        timeCost: 3,
        parallelism: 4,
      });
      updateData.passwordHash = hash; changed = true;
    }
    if (changed) {
      await prisma.user.update({ where: { email }, data: updateData });
       
      console.log(`â™»ï¸  Admin updated (${forceUpdate ? "password+meta" : "meta"})`, { email });
    } else {
       
      console.log("â„¹ï¸  Admin unchanged", { email });
    }
  }

  await prisma.$disconnect();
}

main().catch((e) => {
   
  console.error(e);
  process.exit(1);
});
`````

## File: backend/src/scripts/create-views-and-preview.ts
`````typescript
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function createViews() {
  // Drop if exists, then create with snake_case columns (å„æ–‡ã‚’å€‹åˆ¥ã«å®Ÿè¡Œ)
  await prisma.$executeRawUnsafe(`DROP VIEW IF EXISTS public.v_cats_summary`);
  await prisma.$executeRawUnsafe(`
    CREATE VIEW public.v_cats_summary AS
    SELECT
      c.id AS cat_id,
      c.registration_id,
      c.name AS cat_name,
      c.gender,
      c.birth_date,
      c.microchip_id,
      c.is_active,
      c.created_at,
      c.updated_at,
      b.code AS breed_code,
      b.name AS breed_name,
      cc.code AS coat_color_code,
      cc.name AS coat_color_name,
      u.email AS owner_email
    FROM public.cats c
    LEFT JOIN public.breeds b ON b.id = c.breed_id
    LEFT JOIN public.coat_colors cc ON cc.id = c.color_id
    LEFT JOIN public.users u ON u.id = c.owner_id
  `);

  await prisma.$executeRawUnsafe(`DROP VIEW IF EXISTS public.v_pedigrees_summary`);
  await prisma.$executeRawUnsafe(`
    CREATE VIEW public.v_pedigrees_summary AS
    SELECT
      p.id AS pedigree_row_id,
      p.pedigree_id,
      p.cat_id,
      p.cat_name,
      p.cat_name2,
      p.gender,
      p.birth_date,
      p.registration_date,
      p.pedigree_issue_date,
      p.breeder_name,
      p.owner_name,
      p.brother_count,
      p.sister_count,
      p.other_no,
      p.old_code,
      p.created_at,
      p.updated_at,
      b.code AS breed_code,
      b.name AS breed_name,
      cc.code AS coat_color_code,
      cc.name AS coat_color_name,
      f.pedigree_id AS father_pedigree_no,
      m.pedigree_id AS mother_pedigree_no
    FROM public.pedigrees p
    LEFT JOIN public.breeds b ON b.id = p.breed_id
    LEFT JOIN public.coat_colors cc ON cc.id = p.color_id
    LEFT JOIN public.pedigrees f ON f.id = p.father_pedigree_id
    LEFT JOIN public.pedigrees m ON m.id = p.mother_pedigree_id
  `);
}

type Row = Record<string, unknown>;
async function preview() {
  const cats = await prisma.$queryRawUnsafe<Row[]>(`SELECT * FROM public.v_cats_summary ORDER BY created_at DESC LIMIT 10`);
  const peds = await prisma.$queryRawUnsafe<Row[]>(`SELECT * FROM public.v_pedigrees_summary ORDER BY created_at DESC LIMIT 10`);

  console.log('\nVIEW v_cats_summary (top 10)');
  console.table(cats);

  console.log('\nVIEW v_pedigrees_summary (top 10)');
  console.table(peds);
}

void (async () => {
  try {
    await createViews();
    await preview();
  } catch (e) {
    console.error(e);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
})();
`````

## File: backend/src/scripts/generate-swagger.ts
`````typescript
import { mkdir, writeFile } from 'node:fs/promises';
import { dirname, join } from 'node:path';

import { Logger } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';

import { AppModule } from '../app.module';

async function generateSwagger(): Promise<void> {
  const logger = new Logger('SwaggerGenerator');
  const app = await NestFactory.create(AppModule, {
    logger: false,
  });

  app.setGlobalPrefix('api/v1');

  const config = new DocumentBuilder()
    .setTitle('Cat Management System API')
    .setDescription('API for managing cat breeding and care records')
    .setVersion('1.0')
    .addBearerAuth()
    .build();

  const document = SwaggerModule.createDocument(app, config);
  const outputPath = join(process.cwd(), 'openapi.json');

  const directory = dirname(outputPath);
  await mkdir(directory, { recursive: true });
  await writeFile(outputPath, JSON.stringify(document, null, 2), 'utf8');

  logger.log(`âœ… Swagger schema exported to ${outputPath}`);

  await app.close();
}

generateSwagger().catch((error) => {
  const logger = new Logger('SwaggerGenerator');
  logger.error('Failed to generate Swagger schema', error);
  process.exitCode = 1;
});
`````

## File: backend/src/scripts/import-csv-data.ts
`````typescript
import * as fs from "node:fs";
import * as path from "node:path";

import { PrismaClient } from "@prisma/client";
import csv from "csv-parser";

const prisma = new PrismaClient();

interface BreedData {
  key: string;
  name: string;
}

interface CoatColorData {
  key: string;
  name: string;
}

interface PedigreeData {
  PedigreeID: string;
  Title: string;
  CatName: string;
  CatName2: string;
  BreedCode: string;
  Gender: string; // CSV header uses "Gender", maps to genderCode in database
  EyeColor: string;
  CoatColorCode: string;
  BirthDate: string;
  BreederName: string;
  OwnerName: string;
  RegistrationDate: string;
  BrotherCount: string;
  SisterCount: string;
  Notes: string;
  Notes2: string;
  OtherNo: string;
  // Father data
  FatherTitle: string;
  FatherName: string;
  FatherCatName2: string;
  FatherCoatColor: string;
  FatherEyeColor: string;
  FatherJCU: string;
  FatherOtherCode: string;
  // Mother data
  MotherTitle: string;
  MotherCatName: string;
  MotherCatName2: string;
  MotherCoatColor: string;
  MotherEyeColor: string;
  MotherJCU: string;
  MotherOtherCode: string;
  // Grandparents data - Father's Father's side
  FFTitle: string;
  FFCatName: string;
  FFCatColor: string;
  FFJCU: string;
  // Grandparents data - Father's Mother's side
  FMTitle: string;
  FMCatName: string;
  FMCatColor: string;
  FMJCU: string;
  // Grandparents data - Mother's Father's side
  MFTitle: string;
  MFCatName: string;
  MFCatColor: string;
  MFJCU: string;
  // Grandparents data - Mother's Mother's side
  MMTitle: string;
  MMCatName: string;
  MMCatColor: string;
  MMJCU: string;
  // Great-grandparents data - Father's Father's Father's side
  FFFTitle: string;
  FFFCatName: string;
  FFFCatColor: string;
  FFFJCU: string;
  // Great-grandparents data - Father's Father's Mother's side
  FFMTitle: string;
  FFMCatName: string;
  FFMCatColor: string;
  FFMJCU: string;
  // Great-grandparents data - Father's Mother's Father's side
  FMFTitle: string;
  FMFCatName: string;
  FMFCatColor: string;
  FMFJCU: string;
  // Great-grandparents data - Father's Mother's Mother's side
  FMMTitle: string;
  FMMCatName: string;
  FMMCatColor: string;
  FMMJCU: string;
  // Great-grandparents data - Mother's Father's Father's side
  MFFTitle: string;
  MFFCatName: string;
  MFFCatColor: string;
  MFFJCU: string;
  // Great-grandparents data - Mother's Father's Mother's side
  MFMTitle: string;
  MFMCatName: string;
  MFMCatColor: string;
  MFMJCU: string;
  // Great-grandparents data - Mother's Mother's Father's side
  MMFTitle: string;
  MMFCatName: string;
  MMFCatColor: string;
  MMFJCU: string;
  // Great-grandparents data - Mother's Mother's Mother's side
  MMMTitle: string;
  MMMCatName: string;
  MMMCatColor: string;
  MMMJCU: string;
  OldCode: string;
}

async function importBreeds() {
  console.log("ğŸ± Importing breed data...");

  const breeds: BreedData[] = [];
  const _csvPath = path.join(
    __dirname,
    "../../NewPedigree/çŒ«ç¨®ãƒ†ã‚™ãƒ¼ã‚¿UTF8Ver.csv",
  );

  // Use absolute path to ensure it works regardless of execution context
  const absoluteCsvPath = path.resolve(__dirname, "../../NewPedigree/çŒ«ç¨®ãƒ†ã‚™ãƒ¼ã‚¿UTF8Ver.csv");

  return new Promise<void>((resolve, reject) => {
    fs.createReadStream(absoluteCsvPath)
      .pipe(csv({ headers: ["key", "name"] }))
      .on("data", (data: BreedData) => {
        if (data.key && data.name && data.key !== "ã‚­ãƒ¼") {
          breeds.push(data);
        }
      })
      .on("end", async () => {
        try {
          const processedNames = new Set<string>();
          for (const breed of breeds) {
            const code = parseInt(breed.key);
            const trimmedName = breed.name.trim();
            if (
              !isNaN(code) &&
              trimmedName &&
              !processedNames.has(trimmedName)
            ) {
              processedNames.add(trimmedName);
              await prisma.breed.upsert({
                where: { code },
                update: { name: trimmedName },
                create: {
                  code,
                  name: trimmedName,
                },
              });
            }
          }
          console.log(`âœ… Imported ${breeds.length} breeds`);
          resolve();
        } catch (error) {
          reject(error instanceof Error ? error : new Error(String(error)));
        }
      })
  .on("error", (err) => reject(err instanceof Error ? err : new Error(String(err))));
  });
}

async function importCoatColors() {
  console.log("ğŸ¨ Importing coat color data...");

  const colors: CoatColorData[] = [];
  const _csvPath = path.join(
    __dirname,
    "../../NewPedigree/è‰²æŸ„ãƒ†ã‚™ãƒ¼ã‚¿UTF8Ver.csv",
  );

  // Use absolute path to ensure it works regardless of execution context
  const absoluteCsvPath = path.resolve(__dirname, "../../NewPedigree/è‰²æŸ„ãƒ†ã‚™ãƒ¼ã‚¿UTF8Ver.csv");

  return new Promise<void>((resolve, reject) => {
    fs.createReadStream(absoluteCsvPath)
      .pipe(csv({ headers: ["key", "name"] }))
      .on("data", (data: CoatColorData) => {
        if (data.key && data.name && data.key !== "ã‚­ãƒ¼") {
          colors.push(data);
        }
      })
      .on("end", async () => {
        try {
          const processedColorNames = new Set<string>();
          for (const color of colors) {
            const code = parseInt(color.key);
            const trimmedName = color.name.trim();
            if (
              !isNaN(code) &&
              trimmedName &&
              !processedColorNames.has(trimmedName)
            ) {
              processedColorNames.add(trimmedName);
              await prisma.coatColor.upsert({
                where: { code },
                update: { name: trimmedName },
                create: {
                  code,
                  name: trimmedName,
                },
              });
            }
          }
          console.log(`âœ… Imported ${colors.length} coat colors`);
          resolve();
        } catch (error) {
          reject(error instanceof Error ? error : new Error(String(error)));
        }
      })
      .on("error", (err) => reject(err instanceof Error ? err : new Error(String(err))));
  });
}

async function assertCsvHeaders(csvPath: string, expected: string[]): Promise<void> {
  const fullPath = path.resolve(__dirname, "../../NewPedigree/", path.basename(csvPath));
  const content = fs.readFileSync(fullPath, "utf-8");
  const firstLine = content.split("\n")[0];
  if (!firstLine) {
    throw new Error("Could not read CSV header");
  }
  const header = firstLine.split(",").map(h => h.trim());
  const missing = expected.filter((k) => !header.includes(k));
  if (missing.length > 0) {
    throw new Error(`CSV header missing keys: ${missing.join(", ")}`);
  }
}

async function importPedigrees() {
  console.log("ğŸ“œ Importing pedigree data...");

  const pedigrees: PedigreeData[] = [];
  const csvPath = path.join(
    process.cwd(),
    "NewPedigree/è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿Renamed.csv",
  );

  // Use absolute path to ensure it works regardless of execution context
  const absoluteCsvPath = path.resolve(process.cwd(), "NewPedigree/è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿Renamed.csv");

  // Define headers based on actual CSV structure
  const headers = [
    "PedigreeID",
    "Title",
    "CatName",
    "CatName2",
    "BreedCode",
    "Gender",
    "EyeColor",
    "CoatColorCode",
    "BirthDate",
    "BreederName",
    "OwnerName",
    "RegistrationDate",
    "BrotherCount",
    "SisterCount",
    "Notes",
    "Notes2",
    "OtherNo",
    "FatherTitle",
    "FatherName",
    "FatherCatName2",
    "FatherCoatColor",
    "FatherEyeColor",
    "FatherJCU",
    "FatherOtherCode",
    "MotherTitle",
    "MotherCatName",
    "MotherCatName2",
    "MotherCoatColor",
    "MotherEyeColor",
    "MotherJCU",
    "MotherOtherCode",
    "FFTitle",
    "FFCatName",
    "FFCatColor",
    "FFJCU",
    "FMTitle",
    "FMCatName",
    "FMCatColor",
    "FMJCU",
    "MFTitle",
    "MFCatName",
    "MFCatColor",
    "MFJCU",
    "MMTitle",
    "MMCatName",
    "MMCatColor",
    "MMJCU",
    "FFFTitle",
    "FFFCatName",
    "FFFCatColor",
    "FFFJCU",
    "FFMTitle",
    "FFMCatName",
    "FFMCatColor",
    "FFMJCU",
    "FMFTitle",
    "FMFCatName",
    "FMFCatColor",
    "FMFJCU",
    "FMMTitle",
    "FMMCatName",
    "FMMCatColor",
    "FMMJCU",
    "MFFTitle",
    "MFFCatName",
    "MFFCatColor",
    "MFFJCU",
    "MFMTitle",
    "MFMCatName",
    "MFMCatColor",
    "MFMJCU",
    "MMFTitle",
    "MMFCatName",
    "MMFCatColor",
    "MMFJCU",
    "MMMTitle",
    "MMMCatName",
    "MMMCatColor",
    "MMMJCU",
    "OldCode",
  ];

  // Early check: CSV header must include expected columns
  await assertCsvHeaders(csvPath, headers);
  // Additional fields...
  return new Promise<void>((resolve, reject) => {
    let _rowCount = 0;

    fs.createReadStream(absoluteCsvPath)
      .pipe(csv({ headers }))
      .on("data", (data: PedigreeData) => {
        _rowCount++;
        if (data.PedigreeID) {
          // Skip empty rows
          pedigrees.push(data);
        }
      })
      .on("end", async () => {
        try {
          console.log(`Processing ${pedigrees.length} pedigrees...`);

          // Import in batches to avoid memory issues
          const batchSize = 100;
          for (let i = 0; i < pedigrees.length; i += batchSize) {
            const batch = pedigrees.slice(i, i + batchSize);

            for (const pedigree of batch) {
              try {
                // Parse dates as strings (not Date objects)
                const birthDate = pedigree.BirthDate || null;
                const registrationDate = pedigree.RegistrationDate || null;

                // Parse numbers
                const breedCode = pedigree.BreedCode
                  ? parseInt(pedigree.BreedCode)
                  : null;
                const coatColorCode = pedigree.CoatColorCode
                  ? parseInt(pedigree.CoatColorCode)
                  : null;
                const genderCode = pedigree.Gender
                  ? parseInt(pedigree.Gender)
                  : null;
                const brotherCount = pedigree.BrotherCount
                  ? parseInt(pedigree.BrotherCount)
                  : null;
                const sisterCount = pedigree.SisterCount
                  ? parseInt(pedigree.SisterCount)
                  : null;

                await prisma.pedigree.upsert({
                  where: { pedigreeId: pedigree.PedigreeID.toString() },
                  update: {
                    title: pedigree.Title || null,
                    catName: pedigree.CatName || "",
                    catName2: pedigree.CatName2 || null,
                    breedCode,
                    genderCode,
                    eyeColor: pedigree.EyeColor || null,
                    coatColorCode,
                    birthDate,
                    breederName: pedigree.BreederName || null,
                    ownerName: pedigree.OwnerName || null,
                    registrationDate,
                    brotherCount,
                    sisterCount,
                    notes: pedigree.Notes || null,
                    notes2: pedigree.Notes2 || null,
                    otherNo: pedigree.OtherNo || null,
                    // Father data
                    fatherTitle: pedigree.FatherTitle || null,
                    fatherCatName: pedigree.FatherName || null,
                    fatherCatName2: pedigree.FatherCatName2 || null,
                    fatherCoatColor: pedigree.FatherCoatColor || null,
                    fatherEyeColor: pedigree.FatherEyeColor || null,
                    fatherJCU: pedigree.FatherJCU || null,
                    fatherOtherCode: pedigree.FatherOtherCode || null,
                    // Mother data
                    motherTitle: pedigree.MotherTitle || null,
                    motherCatName: pedigree.MotherCatName || null,
                    motherCatName2: pedigree.MotherCatName2 || null,
                    motherCoatColor: pedigree.MotherCoatColor || null,
                    motherEyeColor: pedigree.MotherEyeColor || null,
                    motherJCU: pedigree.MotherJCU || null,
                    motherOtherCode: pedigree.MotherOtherCode || null,
                    // Grandparents data - Father's Father's side
                    ffTitle: pedigree.FFTitle || null,
                    ffCatName: pedigree.FFCatName || null,
                    ffCatColor: pedigree.FFCatColor || null,
                    ffjcu: pedigree.FFJCU || null,
                    // Grandparents data - Father's Mother's side
                    fmTitle: pedigree.FMTitle || null,
                    fmCatName: pedigree.FMCatName || null,
                    fmCatColor: pedigree.FMCatColor || null,
                    fmjcu: pedigree.FMJCU || null,
                    // Grandparents data - Mother's Father's side
                    mfTitle: pedigree.MFTitle || null,
                    mfCatName: pedigree.MFCatName || null,
                    mfCatColor: pedigree.MFCatColor || null,
                    mfjcu: pedigree.MFJCU || null,
                    // Grandparents data - Mother's Mother's side
                    mmTitle: pedigree.MMTitle || null,
                    mmCatName: pedigree.MMCatName || null,
                    mmCatColor: pedigree.MMCatColor || null,
                    mmjcu: pedigree.MMJCU || null,
                    // Great-grandparents data - Father's Father's Father's side
                    fffTitle: pedigree.FFFTitle || null,
                    fffCatName: pedigree.FFFCatName || null,
                    fffCatColor: pedigree.FFFCatColor || null,
                    fffjcu: pedigree.FFFJCU || null,
                    // Great-grandparents data - Father's Father's Mother's side
                    ffmTitle: pedigree.FFMTitle || null,
                    ffmCatName: pedigree.FFMCatName || null,
                    ffmCatColor: pedigree.FFMCatColor || null,
                    ffmjcu: pedigree.FFMJCU || null,
                    // Great-grandparents data - Father's Mother's Father's side
                    fmfTitle: pedigree.FMFTitle || null,
                    fmfCatName: pedigree.FMFCatName || null,
                    fmfCatColor: pedigree.FMFCatColor || null,
                    fmfjcu: pedigree.FMFJCU || null,
                    // Great-grandparents data - Father's Mother's Mother's side
                    fmmTitle: pedigree.FMMTitle || null,
                    fmmCatName: pedigree.FMMCatName || null,
                    fmmCatColor: pedigree.FMMCatColor || null,
                    fmmjcu: pedigree.FMMJCU || null,
                    // Great-grandparents data - Mother's Father's Father's side
                    mffTitle: pedigree.MFFTitle || null,
                    mffCatName: pedigree.MFFCatName || null,
                    mffCatColor: pedigree.MFFCatColor || null,
                    mffjcu: pedigree.MFFJCU || null,
                    // Great-grandparents data - Mother's Father's Mother's side
                    mfmTitle: pedigree.MFMTitle || null,
                    mfmCatName: pedigree.MFMCatName || null,
                    mfmCatColor: pedigree.MFMCatColor || null,
                    mfmjcu: pedigree.MFMJCU || null,
                    // Great-grandparents data - Mother's Mother's Father's side
                    mmfTitle: pedigree.MMFTitle || null,
                    mmfCatName: pedigree.MMFCatName || null,
                    mmfCatColor: pedigree.MMFCatColor || null,
                    mmfjcu: pedigree.MMFJCU || null,
                    // Great-grandparents data - Mother's Mother's Mother's side
                    mmmTitle: pedigree.MMMTitle || null,
                    mmmCatName: pedigree.MMMCatName || null,
                    mmmCatColor: pedigree.MMMCatColor || null,
                    mmmjcu: pedigree.MMMJCU || null,
                    oldCode: pedigree.OldCode || null,
                  },
                  create: {
                    pedigreeId: pedigree.PedigreeID.toString(),
                    title: pedigree.Title || null,
                    catName: pedigree.CatName || "",
                    catName2: pedigree.CatName2 || null,
                    breedCode,
                    genderCode,
                    eyeColor: pedigree.EyeColor || null,
                    coatColorCode,
                    birthDate,
                    breederName: pedigree.BreederName || null,
                    ownerName: pedigree.OwnerName || null,
                    registrationDate,
                    brotherCount,
                    sisterCount,
                    notes: pedigree.Notes || null,
                    notes2: pedigree.Notes2 || null,
                    otherNo: pedigree.OtherNo || null,
                    // Father data
                    fatherTitle: pedigree.FatherTitle || null,
                    fatherCatName: pedigree.FatherName || null,
                    fatherCatName2: pedigree.FatherCatName2 || null,
                    fatherCoatColor: pedigree.FatherCoatColor || null,
                    fatherEyeColor: pedigree.FatherEyeColor || null,
                    fatherJCU: pedigree.FatherJCU || null,
                    fatherOtherCode: pedigree.FatherOtherCode || null,
                    // Mother data
                    motherTitle: pedigree.MotherTitle || null,
                    motherCatName: pedigree.MotherCatName || null,
                    motherCatName2: pedigree.MotherCatName2 || null,
                    motherCoatColor: pedigree.MotherCoatColor || null,
                    motherEyeColor: pedigree.MotherEyeColor || null,
                    motherJCU: pedigree.MotherJCU || null,
                    motherOtherCode: pedigree.MotherOtherCode || null,
                    // Grandparents data - Father's Father's side
                    ffTitle: pedigree.FFTitle || null,
                    ffCatName: pedigree.FFCatName || null,
                    ffCatColor: pedigree.FFCatColor || null,
                    ffjcu: pedigree.FFJCU || null,
                    // Grandparents data - Father's Mother's side
                    fmTitle: pedigree.FMTitle || null,
                    fmCatName: pedigree.FMCatName || null,
                    fmCatColor: pedigree.FMCatColor || null,
                    fmjcu: pedigree.FMJCU || null,
                    // Grandparents data - Mother's Father's side
                    mfTitle: pedigree.MFTitle || null,
                    mfCatName: pedigree.MFCatName || null,
                    mfCatColor: pedigree.MFCatColor || null,
                    mfjcu: pedigree.MFJCU || null,
                    // Grandparents data - Mother's Mother's side
                    mmTitle: pedigree.MMTitle || null,
                    mmCatName: pedigree.MMCatName || null,
                    mmCatColor: pedigree.MMCatColor || null,
                    mmjcu: pedigree.MMJCU || null,
                    // Great-grandparents data - Father's Father's Father's side
                    fffTitle: pedigree.FFFTitle || null,
                    fffCatName: pedigree.FFFCatName || null,
                    fffCatColor: pedigree.FFFCatColor || null,
                    fffjcu: pedigree.FFFJCU || null,
                    // Great-grandparents data - Father's Father's Mother's side
                    ffmTitle: pedigree.FFMTitle || null,
                    ffmCatName: pedigree.FFMCatName || null,
                    ffmCatColor: pedigree.FFMCatColor || null,
                    ffmjcu: pedigree.FFMJCU || null,
                    // Great-grandparents data - Father's Mother's Father's side
                    fmfTitle: pedigree.FMFTitle || null,
                    fmfCatName: pedigree.FMFCatName || null,
                    fmfCatColor: pedigree.FMFCatColor || null,
                    fmfjcu: pedigree.FMFJCU || null,
                    // Great-grandparents data - Father's Mother's Mother's side
                    fmmTitle: pedigree.FMMTitle || null,
                    fmmCatName: pedigree.FMMCatName || null,
                    fmmCatColor: pedigree.FMMCatColor || null,
                    fmmjcu: pedigree.FMMJCU || null,
                    // Great-grandparents data - Mother's Father's Father's side
                    mffTitle: pedigree.MFFTitle || null,
                    mffCatName: pedigree.MFFCatName || null,
                    mffCatColor: pedigree.MFFCatColor || null,
                    mffjcu: pedigree.MFFJCU || null,
                    // Great-grandparents data - Mother's Father's Mother's side
                    mfmTitle: pedigree.MFMTitle || null,
                    mfmCatName: pedigree.MFMCatName || null,
                    mfmCatColor: pedigree.MFMCatColor || null,
                    mfmjcu: pedigree.MFMJCU || null,
                    // Great-grandparents data - Mother's Mother's Father's side
                    mmfTitle: pedigree.MMFTitle || null,
                    mmfCatName: pedigree.MMFCatName || null,
                    mmfCatColor: pedigree.MMFCatColor || null,
                    mmfjcu: pedigree.MMFJCU || null,
                    // Great-grandparents data - Mother's Mother's Mother's side
                    mmmTitle: pedigree.MMMTitle || null,
                    mmmCatName: pedigree.MMMCatName || null,
                    mmmCatColor: pedigree.MMMCatColor || null,
                    mmmjcu: pedigree.MMMJCU || null,
                    oldCode: pedigree.OldCode || null,
                  },
                });
              } catch (error) {
                console.warn(
                  `Warning: Failed to import pedigree ${pedigree.PedigreeID}:`,
                  error,
                );
              }
            }

            console.log(
              `Processed batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(pedigrees.length / batchSize)}`,
            );
          }

          console.log(`âœ… Imported ${pedigrees.length} pedigrees`);
          resolve();
        } catch (error) {
          reject(error);
        }
      })
      .on("error", (err) => reject(err instanceof Error ? err : new Error(String(err))));
  });
}

function _parseDate(dateStr: string): Date | null {
  if (!dateStr || dateStr.trim() === "") return null;

  // Handle different date formats
  const formats = [
    /(\d{4})\.(\d{1,2})\.(\d{1,2})/, // YYYY.MM.DD
    /(\d{4})-(\d{1,2})-(\d{1,2})/, // YYYY-MM-DD
    /(\d{4})\/(\d{1,2})\/(\d{1,2})/, // YYYY/MM/DD
  ];

  for (const format of formats) {
    const match = dateStr.match(format);
    if (match) {
      const year = parseInt(match[1]);
      const month = parseInt(match[2]);
      const day = parseInt(match[3]);

      if (
        year > 1900 &&
        year < 2100 &&
        month >= 1 &&
        month <= 12 &&
        day >= 1 &&
        day <= 31
      ) {
        return new Date(year, month - 1, day);
      }
    }
  }

  return null;
}

async function main() {
  try {
    console.log("ğŸš€ Starting CSV data import...");

    await importBreeds();
    await importCoatColors();
    await importPedigrees();

    console.log("ğŸ‰ All data imported successfully!");

    // Display summary
    const breedCount = await prisma.breed.count();
    const colorCount = await prisma.coatColor.count();
    const pedigreeCount = await prisma.pedigree.count();

    console.log("\nğŸ“Š Import Summary:");
    console.log(`   Breeds: ${breedCount}`);
    console.log(`   Coat Colors: ${colorCount}`);
    console.log(`   Pedigrees: ${pedigreeCount}`);
  } catch (error) {
    console.error("âŒ Import failed:", error);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

if (require.main === module) {
  void (async (): Promise<void> => {
    try {
      await main();
      process.exit(0);
    } catch (e) {
      console.error(e);
      process.exit(1);
    }
  })();
}

export { importBreeds, importCoatColors, importPedigrees };
`````

## File: backend/src/scripts/import-master-data.ts
`````typescript
import * as fsSync from 'fs';
import { promises as fs } from 'fs';
import path from 'path';

import { PrismaClient } from '@prisma/client';

import { batchTransaction } from './utils/prisma-batch';

const prisma = new PrismaClient();

async function readCsvWithBom(filePath: string): Promise<string[][]> {
  const fileBuffer = await fs.readFile(filePath);
  
  // BOMã‚’å‰Šé™¤ï¼ˆUTF-8 BOM: EF BB BFï¼‰
  let content = fileBuffer.toString('utf8');
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  
  const lines = content.split('\n').filter(line => line.trim() !== '');
  return lines.map(line => line.split(','));
}

async function importBreeds() {
  console.log('ğŸ± çŒ«ç¨®ãƒ‡ãƒ¼ã‚¿ã®æŠ•å…¥é–‹å§‹...');
  
  const breedPath = path.join(__dirname, '../../NewPedigree/çŒ«ç¨®ãƒ‡ãƒ¼ã‚¿UTF8Ver.csv');
  
  // ãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ç¢ºèª
  if (!fsSync.existsSync(breedPath)) {
    console.log(`âš ï¸  ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${breedPath}`);
    console.log('   ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é…ç½®ã—ã¦ã‹ã‚‰å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚');
    return;
  }
  
  // æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªã‚¢
  await prisma.breed.deleteMany();
  
  const breedData = await readCsvWithBom(breedPath);
  
  // ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã‚’ã‚¹ã‚­ãƒƒãƒ—
  const breeds = breedData.slice(1).map(row => ({
    code: parseInt(row[0].trim(), 10),
    name: row[1]?.trim() || '',
  })).filter(breed => !isNaN(breed.code) && breed.name);
  
  console.log(`æŠ•å…¥äºˆå®šä»¶æ•°: ${breeds.length}`);
  await batchTransaction(
    prisma,
    breeds,
    async (tx, breed) => {
      await tx.breed.create({
        data: {
          id: crypto.randomUUID(),
          code: breed.code,
          name: breed.name,
        },
      });
    },
    { batchSize: 200, logEvery: 1000, label: 'breeds' },
  );
  
  console.log('ğŸ± çŒ«ç¨®ãƒ‡ãƒ¼ã‚¿ã®æŠ•å…¥å®Œäº†');
}

async function importCoatColors() {
  console.log('ğŸ¨ è‰²æŸ„ãƒ‡ãƒ¼ã‚¿ã®æŠ•å…¥é–‹å§‹...');
  
  const colorPath = path.join(__dirname, '../../NewPedigree/è‰²æŸ„ãƒ‡ãƒ¼ã‚¿UTF8Ver.csv');
  
  // ãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ç¢ºèª
  if (!fsSync.existsSync(colorPath)) {
    console.log(`âš ï¸  ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${colorPath}`);
    console.log('   ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é…ç½®ã—ã¦ã‹ã‚‰å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚');
    return;
  }
  
  // æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªã‚¢
  await prisma.coatColor.deleteMany();
  
  const colorData = await readCsvWithBom(colorPath);
  
  // ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã‚’ã‚¹ã‚­ãƒƒãƒ—
  const colors = colorData.slice(1).map(row => ({
    code: parseInt(row[0].trim(), 10),
    name: row[1]?.trim() || '',
  })).filter(color => !isNaN(color.code) && color.name);
  
  console.log(`æŠ•å…¥äºˆå®šä»¶æ•°: ${colors.length}`);
  await batchTransaction(
    prisma,
    colors,
    async (tx, color) => {
      await tx.coatColor.create({
        data: {
          id: crypto.randomUUID(),
          code: color.code,
          name: color.name,
        },
      });
    },
    { batchSize: 200, logEvery: 1000, label: 'coatColors' },
  );
  
  console.log('ğŸ¨ è‰²æŸ„ãƒ‡ãƒ¼ã‚¿ã®æŠ•å…¥å®Œäº†');
}

async function clearPedigreeData() {
  console.log('ğŸ“‹ æ—¢å­˜è¡€çµ±ãƒ‡ãƒ¼ã‚¿ã®ã‚¯ãƒªã‚¢é–‹å§‹...');
  
  // ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è€ƒæ…®ã—ãŸé †åºã§ã‚¯ãƒªã‚¢
  await prisma.pedigree.deleteMany();
  
  console.log('ğŸ“‹ æ—¢å­˜è¡€çµ±ãƒ‡ãƒ¼ã‚¿ã®ã‚¯ãƒªã‚¢å®Œäº†');
}

async function main() {
  try {
    console.log('ğŸš€ ãƒã‚¹ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿æŠ•å…¥ã‚¹ã‚¯ãƒªãƒ—ãƒˆé–‹å§‹');
    
    await clearPedigreeData();
    await importBreeds();
    await importCoatColors();
    
    console.log('âœ… ãƒã‚¹ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿æŠ•å…¥å®Œäº†');
  } catch (error) {
    console.error('âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:', error);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

if (require.main === module) {
  // eslint-disable-next-line @typescript-eslint/no-floating-promises
  (async () => {
    try {
      await main();
      process.exit(0);
    } catch (e) {
      console.error(e);
      process.exit(1);
    }
  })();
}
`````

## File: backend/src/scripts/import-parent-pedigrees.ts
`````typescript
import * as fs from "fs";
import * as path from "path";

import { PrismaClient } from "@prisma/client";
import { parse } from "csv-parse";

import { batchTransaction } from "./utils/prisma-batch";

const prisma = new PrismaClient();

/**
 * è¦ªè¡€çµ±æ›¸ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒˆ
 * ç¾åœ¨ã®ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ã®çˆ¶æ¯ã‚’è¿½åŠ ã§ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
 */

interface PedigreeData {
  PedigreeID: string;
  Title?: string;
  CatteryName: string;
  CatName?: string;
  BreedCode: string;
  Gender: string;
  EyeColor?: string;
  CoatColorCode: string;
  BirthDate: string;
  BreederName: string;
  OwnerName: string;
  RegistrationDate: string;
  BrotherCount: string;
  SisterCount: string;
  Notes?: string;
  Notes2?: string;
  OtherNo?: string;
}

async function importParentPedigrees() {
  const csvPath = path.join(
    __dirname,
    "../../NewPedigree/è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿Renamed.csv",
  );

  // è¦ªã®IDãƒªã‚¹ãƒˆï¼ˆJCUã‹ã‚‰æŠ½å‡ºã—ãŸç•ªå·ï¼‰
  const parentIds = [
    "163553",
    "169010",
    "700538",
    "142007",
    "700900",
    "150501",
    "116197",
  ];

  try {
    console.log("ğŸ”„ è¦ªè¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’é–‹å§‹...\n");

    const records: PedigreeData[] = [];

    await new Promise<void>((resolve, reject) => {
      fs.createReadStream(csvPath)
        .pipe(
          parse({
            columns: true,
            skip_empty_lines: true,
            trim: true,
          }),
        )
        .on("data", (record: Record<string, string>) => {
          // è¦ªã®IDãŒå«ã¾ã‚Œã‚‹è¡€çµ±æ›¸ã®ã¿å‡¦ç†
          if (parentIds.includes(record.PedigreeID)) {
            records.push({
              PedigreeID: record.PedigreeID,
              Title: record.Title ?? undefined,
              CatteryName: record.CatteryName ?? "",
              CatName: record.CatName ?? "",
              BreedCode: record.BreedCode,
              Gender: record.Gender,
              EyeColor: record.EyeColor ?? undefined,
              CoatColorCode: record.CoatColorCode,
              BirthDate: record.BirthDate,
              BreederName: record.BreederName ?? "",
              OwnerName: record.OwnerName ?? "",
              RegistrationDate: record.RegistrationDate,
              BrotherCount: record.BrotherCount ?? "0",
              SisterCount: record.SisterCount ?? "0",
              Notes: record.Notes ?? undefined,
              Notes2: record.Notes2 ?? undefined,
              OtherNo: record.OtherNo ?? undefined,
            });
          }
        })
        .on("end", () => {
          console.log(`ğŸ“Š è¦‹ã¤ã‹ã£ãŸè¦ªè¡€çµ±æ›¸: ${records.length}ä»¶`);
          resolve();
        })
        .on("error", reject);
    });

    const result = await batchTransaction(
      prisma,
      records,
      async (tx, record) => {
        // æ—¢ã«å­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        const existing = await tx.pedigree.findUnique({
          where: { pedigreeId: record.PedigreeID },
        });
        if (existing) return; // ã‚¹ã‚­ãƒƒãƒ—

        const birthDate = record.BirthDate
          ? new Date(record.BirthDate.replace(/\./g, "-")).toISOString()
          : null;
        const registrationDate = record.RegistrationDate
          ? new Date(record.RegistrationDate.replace(/\./g, "-")).toISOString()
          : null;

        await tx.pedigree.create({
          data: {
            pedigreeId: record.PedigreeID,
            title: record.Title ?? null,
            catName: record.CatName ?? "",
            breedCode: parseInt(record.BreedCode, 10),
            genderCode: parseInt(record.Gender, 10),
            eyeColor: record.EyeColor ?? null,
            coatColorCode: parseInt(record.CoatColorCode, 10),
            birthDate,
            breederName: record.BreederName ?? null,
            ownerName: record.OwnerName ?? null,
            registrationDate,
            brotherCount: parseInt(record.BrotherCount, 10),
            sisterCount: parseInt(record.SisterCount, 10),
            notes: record.Notes ?? null,
            notes2: record.Notes2 ?? null,
            otherNo: record.OtherNo ?? null,
          },
        });
      },
      { batchSize: 200, logEvery: 1000, label: "parentPedigrees" },
    );

    console.log("\nğŸ‰ è¦ªè¡€çµ±æ›¸ã‚¤ãƒ³ãƒãƒ¼ãƒˆå®Œäº†ï¼");
    console.log(`ğŸ“Š æˆåŠŸ: ${result.success}ä»¶`);
    console.log(`âŒ ã‚¨ãƒ©ãƒ¼: ${result.failed}ä»¶`);
  } catch (error) {
    console.error("ğŸ’¥ ã‚¤ãƒ³ãƒãƒ¼ãƒˆå‡¦ç†ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:", error);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

// ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œ
if (require.main === module) {
  importParentPedigrees()
    .then(() => {
      console.log("ğŸ‰ è¦ªè¡€çµ±æ›¸ã‚¤ãƒ³ãƒãƒ¼ãƒˆãŒå®Œäº†ã—ã¾ã—ãŸï¼");
      process.exit(0);
    })
    .catch((error) => {
      console.error("ğŸ’¥ ã‚¤ãƒ³ãƒãƒ¼ãƒˆå‡¦ç†ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:", error);
      process.exit(1);
    });
}

export { importParentPedigrees };
`````

## File: backend/src/scripts/import-pedigree-data.ts
`````typescript
import { promises as fs } from 'fs';
import * as path from 'path';

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function readCsvWithBom(filePath: string): Promise<string[][]> {
  const fileBuffer = await fs.readFile(filePath);
  
  // BOMã‚’å‰Šé™¤ï¼ˆUTF-8 BOM: EF BB BFï¼‰
  let content = fileBuffer.toString('utf8');
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  
  const lines = content.split('\n').filter(line => line.trim() !== '');
  return lines.map(line => line.split(','));
}

async function importPedigreeData() {
  console.log('ğŸ“‹ è¡€çµ±ãƒ‡ãƒ¼ã‚¿ã®æŠ•å…¥é–‹å§‹...');
  
  const pedigreePath = path.join(process.cwd(), 'NewPedigree/testdatepedigrees100.csv');
  const pedigreeData = await readCsvWithBom(pedigreePath);
  
  // ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã‚’ã‚¹ã‚­ãƒƒãƒ—
  const pedigrees = pedigreeData.slice(1);
  
  console.log(`è¡€çµ±ãƒ‡ãƒ¼ã‚¿ä»¶æ•°: ${pedigrees.length}`);
  console.log(`CSVåˆ—æ•°: ${pedigrees[0]?.length}`);
  
  let successCount = 0;
  let errorCount = 0;
  
  for (let i = 0; i < pedigrees.length; i++) {
    const row = pedigrees[i];
    
    try {
      // åŸºæœ¬æƒ…å ±ã®å–å¾— (åˆ—ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯0ã‹ã‚‰å§‹ã¾ã‚‹)
      const pedigreeId = row[0]?.trim(); // PedigreeID
      const title = row[1]?.trim(); // Title
      const catName = row[2]?.trim(); // CatName
      const catName2 = row[3]?.trim(); // CatName2
      const breedCodeStr = row[4]?.trim(); // BreedCode
      const genderStr = row[5]?.trim(); // Gender
      const coatColorCodeStr = row[6]?.trim(); // CoatColorCode
      
      // å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ãƒã‚§ãƒƒã‚¯
      if (!pedigreeId || !catName) {
        console.warn(`âš ï¸  Row ${i + 2}: å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒä¸è¶³ - PedigreeID: ${pedigreeId}, CatName: ${catName}`);
        continue;
      }
      
      // æ•°å€¤å¤‰æ›
      const breedCode = breedCodeStr ? parseInt(breedCodeStr, 10) : null;
      const coatColorCode = coatColorCodeStr ? parseInt(coatColorCodeStr, 10) : null;
      
      await prisma.pedigree.create({
        data: {
          id: crypto.randomUUID(),
          pedigreeId: pedigreeId,
          title: title || null,
          catName: catName,
          catName2: catName2 || null,
          breedCode: (breedCode !== null && !isNaN(breedCode)) ? breedCode : null,
          genderCode: genderStr ? parseInt(genderStr, 10) : null,
          coatColorCode: (coatColorCode !== null && !isNaN(coatColorCode)) ? coatColorCode : null,
        },
      });
      
      successCount++;
      console.log(`âœ“ ${i + 1}/${pedigrees.length} è¡€çµ±è¿½åŠ : ${pedigreeId} - ${catName}`);
      
    } catch (error) {
      errorCount++;
      console.error(`âœ— Row ${i + 2}: è¡€çµ±è¿½åŠ ã‚¨ãƒ©ãƒ¼:`, error);
      console.error(`ãƒ‡ãƒ¼ã‚¿å†…å®¹: ${row.slice(0, 10).join(', ')}...`);
    }
  }
  
  console.log(`ğŸ“‹ è¡€çµ±ãƒ‡ãƒ¼ã‚¿ã®æŠ•å…¥å®Œäº† - æˆåŠŸ: ${successCount}, ã‚¨ãƒ©ãƒ¼: ${errorCount}`);
}

async function main() {
  try {
    console.log('ğŸš€ è¡€çµ±ãƒ‡ãƒ¼ã‚¿æŠ•å…¥ã‚¹ã‚¯ãƒªãƒ—ãƒˆé–‹å§‹');
    
    await importPedigreeData();
    
    console.log('âœ… è¡€çµ±ãƒ‡ãƒ¼ã‚¿æŠ•å…¥å®Œäº†');
  } catch (error) {
    console.error('âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:', error);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

if (require.main === module) {
  // eslint-disable-next-line @typescript-eslint/no-floating-promises
  (async () => {
    try {
      await main();
      process.exit(0);
    } catch (e) {
      console.error(e);
      process.exit(1);
    }
  })();
}
`````

## File: backend/src/scripts/inspect-admin.ts
`````typescript
import { PrismaClient } from '@prisma/client';

async function main() {
  const prisma = new PrismaClient();
  try {
    const admin = await prisma.user.findUnique({
      where: { email: 'admin@example.com' },
      select: {
        id: true,
        email: true,
        failedLoginAttempts: true,
        lockedUntil: true,
        isActive: true,
        passwordHash: true,
      },
    });

    if (!admin) {
      console.log('Admin user not found');
      return;
    }

    console.log('Admin user info:', {
      email: admin.email,
      failedLoginAttempts: admin.failedLoginAttempts,
      lockedUntil: admin.lockedUntil,
      isActive: admin.isActive,
      passwordHashPreview: admin.passwordHash?.slice(0, 16),
    });

    const recentAttempts = await prisma.loginAttempt.findMany({
      where: { email: admin.email },
      orderBy: { createdAt: 'desc' },
      take: 5,
      select: {
        createdAt: true,
        success: true,
        reason: true,
        ipAddress: true,
        userAgent: true,
      },
    });

    console.log('Recent login attempts:', recentAttempts);
  } finally {
    await prisma.$disconnect();
  }
}

main().catch((error) => {
  console.error('Failed to inspect admin user', error);
  process.exit(1);
});
`````

## File: backend/src/scripts/inspect-schema.ts
`````typescript
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

const tables = [
  'users',
  'login_attempts',
  'breeds',
  'coat_colors',
  'cats',
  'breeding_records',
  'care_records',
  'schedules',
  'tags',
  'pedigrees',
  'cat_tags',
];

async function main() {
  for (const t of tables) {
    const cols = await prisma.$queryRawUnsafe<
      { column_name: string; data_type: string; is_nullable: string; column_default: string | null }[]
    >(`
      SELECT column_name, data_type, is_nullable, column_default
      FROM information_schema.columns
      WHERE table_schema = 'public' AND table_name = '${t}'
      ORDER BY ordinal_position
    `);

    console.log(`\nTABLE: ${t}`);
    console.table(
      cols.map((c) => ({
        column: c.column_name,
        type: c.data_type,
        nullable: c.is_nullable,
        default: c.column_default,
      }))
    );
  }
}

// eslint-disable-next-line @typescript-eslint/no-floating-promises
(async () => {
  try {
    await main();
    process.exit(0);
  } catch (e) {
    console.error(e);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
})();
`````

## File: backend/src/scripts/list-tag-categories.ts
`````typescript
import 'reflect-metadata';
import { PrismaClient } from '@prisma/client';

async function main() {
  const prisma = new PrismaClient();
  try {
    const categories = await prisma.tagCategory.findMany({
      include: {
        groups: {
          include: {
            tags: true,
          },
        },
      },
      orderBy: [{ displayOrder: 'asc' }, { name: 'asc' }],
    });

    if (!categories.length) {
      console.log('No tag categories found');
      return;
    }

    console.log(`Found ${categories.length} categories`);
    for (const category of categories) {
      console.log(
        JSON.stringify(
          {
            id: category.id,
            name: category.name,
            key: category.key,
            scopes: category.scopes,
            isActive: category.isActive,
            groups: category.groups.map((group) => ({
              id: group.id,
              name: group.name,
              isActive: group.isActive,
              tags: group.tags.map((tag) => ({ id: tag.id, name: tag.name, isActive: tag.isActive })),
            })),
          },
          null,
          2,
        ),
      );
    }
  } finally {
    await prisma.$disconnect();
  }
}

main().catch((error) => {
  console.error('Failed to list tag categories', error);
  process.exit(1);
});
`````

## File: backend/src/scripts/rename-pedigree-csv.ts
`````typescript
import * as fsSync from "fs";
import { promises as fs } from "fs";
import * as path from "path";

/**
 * è¡€çµ±æ›¸CSVã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã‚’ãƒªãƒãƒ¼ãƒ ã—ã¦ã€1è¡Œç›®ã‚’å‰Šé™¤ã™ã‚‹ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
 *
 * å¤‰æ›´å†…å®¹:
 * 1. 1è¡Œç›®ï¼ˆæ—¥æœ¬èªãƒ˜ãƒƒãƒ€ãƒ¼ï¼‰ã‚’å‰Šé™¤
 * 2. ç¥–çˆ¶æ¯ä¸–ä»£ä»¥é™ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã‚’F/Mç•¥ç§°ã«å¤‰æ›´
 * 3. å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰: PedigreeID, Gender
 * 4. ãã®ä»–ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯Nullå¯
 */

function parseArgs(argv: string[]) {
  const args: Record<string, string> = {};
  for (let i = 2; i < argv.length; i++) {
    const a = argv[i];
    if (a.startsWith("--")) {
      const [k, v] = a.replace(/^--/, "").split("=");
      if (k) args[k] = v ?? "";
    }
  }
  return args;
}

function detectInputPath(): string {
  const candidates = [
    path.join(__dirname, "../../NewPedigree/è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿UTF8Ver.csv"),
    path.join(__dirname, "../../NewPedigree/è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿UTFVer.csv"),
    path.join(__dirname, "../../NewPedigree/testdatepedigrees100.csv"),
  ];
  for (const p of candidates) {
    if (fsSync.existsSync(p)) return p;
  }
  // æœ€å¾Œã®å€™è£œã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¨ã—ã¦è¿”ã—ï¼ˆå­˜åœ¨ã—ãªã„å ´åˆã¯å‘¼ã³å‡ºã—å´ã§ã‚¨ãƒ©ãƒ¼ã«ï¼‰
  return candidates[candidates.length - 1];
}

async function renamePedigreeCsvFields() {
  const args = parseArgs(process.argv);
  // ãƒ¦ãƒ¼ã‚¶ãƒ¼æŒ‡å®šã®ãƒ‘ã‚¹ã¯ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª(process.cwd())åŸºæº–ã§è§£æ±ºã™ã‚‹ã€‚
  // æœªæŒ‡å®šæ™‚ã®ã¿ã€ã‚¹ã‚¯ãƒªãƒ—ãƒˆä½ç½®(__dirname)åŸºæº–ã®è‡ªå‹•æ¤œå‡º/ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’ä½¿ã†ã€‚
  const csvPath = args.in
    ? path.isAbsolute(args.in)
      ? args.in
      : path.resolve(process.cwd(), args.in)
    : detectInputPath();
  const outputPath = args.out
    ? path.isAbsolute(args.out)
      ? args.out
      : path.resolve(process.cwd(), args.out)
    : path.join(__dirname, "../../NewPedigree/è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿Renamed.csv");

  // ãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ç¢ºèª
  if (!fsSync.existsSync(csvPath)) {
    console.log(`âš ï¸  å…¥åŠ›ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${csvPath}`);
    console.log('   ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é…ç½®ã—ã¦ã‹ã‚‰å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚');
    console.log('   ä½¿ç”¨æ–¹æ³•: npm run pedigree:rename -- --in /path/to/input.csv');
    return;
  }

  try {
  console.log("ğŸ”„ CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­...");
  console.log(`ğŸ“‚ å…¥åŠ›ãƒ‘ã‚¹: ${csvPath}`);
  console.log(`ğŸ“‚ å‡ºåŠ›ãƒ‘ã‚¹: ${outputPath}`);
    const content = await fs.readFile(csvPath, "utf-8");
    const lines = content.split("\n");

    if (lines.length < 2) {
      throw new Error("CSVãƒ•ã‚¡ã‚¤ãƒ«ãŒæ­£ã—ã„å½¢å¼ã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼ˆ2è¡Œæœªæº€ï¼‰");
    }

    console.log(`ğŸ“Š ç·è¡Œæ•°: ${lines.length}`);
    // 1è¡Œç›®/2è¡Œç›®ã®ã©ã¡ã‚‰ãŒãƒ˜ãƒƒãƒ€ãƒ¼ã‹ã‚’ç°¡æ˜“åˆ¤å®š
    const looksLikeHeader = (s: string) => /PedigreeID|Title|Breed|Gender|Date|Name|Color/i.test(s);
    const headerIndex = looksLikeHeader(lines[0]) ? 0 : looksLikeHeader(lines[1]) ? 1 : 0;
    const dataStart = headerIndex + 1;

    console.log(`ğŸ“ ãƒ˜ãƒƒãƒ€ãƒ¼å€™è£œ(${headerIndex + 1}è¡Œç›®): ${lines[headerIndex].substring(0, 120)}...`);
    if (headerIndex === 1) {
      console.log(`ğŸ“ 1è¡Œç›® (å‰Šé™¤æƒ³å®š): ${lines[0].substring(0, 100)}...`);
    }

    // ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’å–å¾—ã—ã¦ãƒªãƒãƒ¼ãƒ 
    const originalHeader = lines[headerIndex];
    const renamedHeader = renameFields(originalHeader);

    console.log("ğŸ”„ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã‚’ãƒªãƒãƒ¼ãƒ ä¸­...");
    console.log(`ğŸ“ ãƒªãƒãƒ¼ãƒ å¾Œ: ${renamedHeader.substring(0, 100)}...`);

  // ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œä»¥å¤–ã®ãƒ‡ãƒ¼ã‚¿ã‚’çµåˆï¼ˆheaderIndexã‚ˆã‚Šå‰ã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼‰
  const newContent = [renamedHeader, ...lines.slice(dataStart)].join("\n");

    // æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
  await fs.writeFile(outputPath, newContent, "utf-8");

    console.log("âœ… CSVãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒªãƒãƒ¼ãƒ ãŒå®Œäº†ã—ã¾ã—ãŸ");
    console.log(`ğŸ“ å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«: ${outputPath}`);
  console.log(`ğŸ“Š æ–°ã—ã„ç·è¡Œæ•°: ${newContent.split("\n").length}`);

    // çµæœã®ç¢ºèª
  const newLines = newContent.split("\n");
    console.log(`ğŸ“ æ–°ã—ã„ãƒ˜ãƒƒãƒ€ãƒ¼: ${newLines[0].substring(0, 150)}...`);
    console.log(`ğŸ“ æœ€åˆã®ãƒ‡ãƒ¼ã‚¿è¡Œ: ${newLines[1].substring(0, 100)}...`);
  } catch (error) {
    console.error("âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:", error);
    throw error;
  }
}

/**
 * ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã‚’ãƒªãƒãƒ¼ãƒ ã™ã‚‹é–¢æ•°
 */
function renameFields(headerLine: string): string {
  const fields = headerLine.split(",");
  const originalSet = new Set(fields.map((f) => f.trim()));
  const used = new Set<string>();

  // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã®ãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆç¥–çˆ¶æ¯ä¸–ä»£ä»¥é™ã‚’F/Mç•¥ç§°ã«å¤‰æ›´ï¼‰
  const fieldMapping: { [key: string]: string } = {
    // åŸºæœ¬æƒ…å ±ï¼ˆãã®ã¾ã¾ï¼‰
    PedigreeID: "PedigreeID",
    Title: "Title",
    CatteryName: "CatName",
    CatName: "CatName2",
    BreedCode: "BreedCode",
    Gender: "Gender",
    EyeColor: "EyeColor",
    CoatColorCode: "CoatColorCode",
    BirthDate: "BirthDate",
    BreederName: "BreederName",
    OwnerName: "OwnerName",
    RegistrationDate: "RegistrationDate",
    BrotherCount: "BrotherCount",
    SisterCount: "SisterCount",
    Notes: "Notes",
    Notes2: "Notes2",
    OtherNo: "OtherNo",

    // çˆ¶æ¯æƒ…å ±ï¼ˆãã®ã¾ã¾ï¼‰
    FatherTitle: "FatherTitle",
    FatherCatteryName: "FatherCatName",
    FatherCatName: "FatherCatName2",
    FatherCoatColor: "FatherCoatColor",
    FatherEyeColor: "FatherEyeColor",
    FatherJCU: "FatherJCU",
    FatherOtherCode: "FatherOtherCode",
    MotherTitle: "MotherTitle",
    MotherCatteryName: "MotherCatName",
  MotherCatName: "MotherCatName2",
    MotherCoatColor: "MotherCoatColor",
    MotherEyeColor: "MotherEyeColor",
    MotherJCU: "MotherJCU",
    MotherOtherCode: "MotherOtherCode",

  // ç¥–çˆ¶æ¯ä¸–ä»£ï¼ˆF/Mç•¥ç§°ã«å¤‰æ›´ï¼‰ 
    PatGrandFatherTitle: "FFTitle",
    PatGrandFatherCatteryName: "FFCatName",
    PatGrandFatherCatName: "FFCatName2",
    PatGrandFatherJCU: "FFJCU",
    PatGrandMotherTitle: "FMTitle",
    PatGrandMotherCatteryName: "FMCatName",
    PatGrandMotherCatName: "FMCatName2",
    PatGrandMotherJCU: "FMJCU",
  PatGrandFatherChampionFlag: "FFChampionFlag",
  PatGrandMotherChampionFlag: "FMChampionFlag",
  MatGrandFatherChampionFlag: "MFChampionFlag",
  MatGrandFatherTitle: "MFTitle",
  MatGrandFatherCatteryName: "MFCatName",
  MatGrandFatherCatName: "MFCatName2",
  MatGrandFatherJCU: "MFJCU",
  MatGrandMotherChampionFlag: "MMChampionFlag",
  MatGrandMotherTitle: "MMTitle",
  MatGrandMotherCatteryName: "MMCatName",
  MatGrandMotherCatName: "MMCatName2",
  MatGrandMotherJCU: "MMJCU",

    // æ›¾ç¥–çˆ¶æ¯ä¸–ä»£ï¼ˆFF, FM, MF, MM + F/Mï¼‰
    PatGreatGrandFatherChampionFlag: "FFFChampionFlag",
    PatGreatGrandFatherTitle: "FFFTitle",
    PatGreatGrandFatherCatteryName: "FFFCatteryName",
    PatGreatGrandFatherCatName: "FFFCatName",
    PatGreatGrandFatherJCU: "FFFJCU",
    PatGreatGrandMotherChampionFlag: "FFMChampionFlag",
    PatGreatGrandMotherTitle: "FFMTitle",
    PatGreatGrandMotherCatteryName: "FFMCatteryName",
    PatGreatGrandMotherCatName: "FFMCatName",
    PatGreatGrandMotherJCU: "FFMJCU",
    PatGreatGrandFatherMatChampionFlag: "FMFChampionFlag",
    PatGreatGrandFatherMatTitle: "FMFTitle",
    PatGreatGrandFatherMatCatteryName: "FMFCatteryName",
    PatGreatGrandFatherMatCatName: "FMFCatName",
    PatGreatGrandFatherMatJCU: "FMFJCU",
    PatGreatGrandMotherMatChampionFlag: "FMMChampionFlag",
    PatGreatGrandMotherMatTitle: "FMMTitle",
    PatGreatGrandMotherMatCatteryName: "FMMCatteryName",
    PatGreatGrandMotherMatCatName: "FMMCatName",
    PatGreatGrandMotherMatJCU: "FMMJCU",
    MatGreatGrandFatherChampionFlag: "MFFChampionFlag",
    MatGreatGrandFatherTitle: "MFFTitle",
    MatGreatGrandFatherCatteryName: "MFFCatteryName",
    MatGreatGrandFatherCatName: "MFFCatName",
    MatGreatGrandFatherJCU: "MFFJCU",
    MatGreatGrandMotherChampionFlag: "MFMChampionFlag",
    MatGreatGrandMotherTitle: "MFMTitle",
    MatGreatGrandMotherCatteryName: "MFMCatteryName",
    MatGreatGrandMotherCatName: "MFMCatName",
    MatGreatGrandMotherJCU: "MFMJCU",
    MatGreatGrandFatherMatChampionFlag: "MMFChampionFlag",
    MatGreatGrandFatherMatTitle: "MMFTitle",
    MatGreatGrandFatherMatCatteryName: "MMFCatteryName",
    MatGreatGrandFatherMatCatName: "MMFCatName",
    MatGreatGrandFatherMatJCU: "MMFJCU",
    MatGreatGrandMotherMatChampionFlag: "MMMChampionFlag",
    MatGreatGrandMotherMatTitle: "MMMTitle",
    MatGreatGrandMotherMatCatteryName: "MMMCatteryName",
    MatGreatGrandMotherMatCatName: "MMMCatName",
    MatGreatGrandMotherMatJCU: "MMMJCU",

    // ãã®ä»–
    OldCode: "OldCode",
  };

  // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã‚’ãƒãƒƒãƒ”ãƒ³ã‚°ã«å¾“ã£ã¦å¤‰æ›´
  const renamedFields = fields.map((field) => {
    const trimmedField = field.trim();
    let target = fieldMapping[trimmedField] || trimmedField;

    // æ—¢ã«ã€Œ*2ã€åˆ—ãŒå­˜åœ¨ã™ã‚‹å ´åˆã€åŒã˜ã€Œ*2ã€ã¸ã®ãƒªãƒãƒ¼ãƒ ã¯ã‚¹ã‚­ãƒƒãƒ—ã—ã¦é‡è¤‡ã‚’å›é¿
    if (target !== trimmedField && originalSet.has(target) && /2$/.test(target)) {
      target = trimmedField; // æœ«å°¾2ãŒæ—¢ã«ã‚ã‚‹ã®ã§ã€ã“ã®åˆ—ã¯å…ƒã®ã¾ã¾ã«ã™ã‚‹
    }

    // åŒä¸€å®Ÿè¡Œä¸­ã®é‡è¤‡ã‚‚å›é¿ï¼ˆä¾‹ãˆã°å‰åˆ—ã®ãƒªãƒãƒ¼ãƒ çµæœã¨è¡çªã—ãŸå ´åˆï¼‰
    if (used.has(target) && target !== trimmedField) {
      // è¡çªæ™‚ã¯ã‚ªãƒªã‚¸ãƒŠãƒ«åã‚’ç¶­æŒ
      target = trimmedField;
    }

    used.add(target);
    return target;
  });

  return renamedFields.join(",");
}

// ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œ
if (require.main === module) {
  // eslint-disable-next-line @typescript-eslint/no-floating-promises
  (async () => {
    try {
      await renamePedigreeCsvFields();
      console.log("ğŸ‰ è¡€çµ±æ›¸CSVã®ãƒªãƒãƒ¼ãƒ ãŒå®Œäº†ã—ã¾ã—ãŸï¼");
      process.exit(0);
    } catch (error) {
      console.error("ğŸ’¥ ãƒªãƒãƒ¼ãƒ å‡¦ç†ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:", error);
      process.exit(1);
    }
  })();
}

export { renamePedigreeCsvFields };
`````

## File: backend/src/scripts/selective-csv-import.ts
`````typescript
import * as fs from "fs";
import * as path from "path";

import { PrismaClient } from "@prisma/client";
import { parse } from "csv-parse/sync";

const prisma = new PrismaClient();

interface PedigreeRow {
  ã‚­ãƒ¼: string;
  ï¼§ï¼°: string;
  çŒ«åå‰ï¼‘: string;
  çŒ«åå‰ï¼’: string;
  çŒ«åå‰ï¼“: string;
  çŒ«ç¨®ï½ºï½°ï¾„ï¾: string;
  æ€§åˆ¥: string;
  ç›®è‰²: string;
  æ¯›è‰²ï½ºï½°ï¾„ï¾: string;
  ç”Ÿå¹´æœˆæ—¥: string;
  ç¹æ®–è€…å: string;
  æ‰€æœ‰è€…å: string;
  ç™»éŒ²å¹´æœˆæ—¥: string;
  å…„å¼Ÿã®äººæ•°: string;
  å§‰å¦¹ã®äººæ•°: string;
  æ‘˜è¦: string;
  æ‘˜è¦ï¼’: string;
  ä»–å›£ä½“No: string;
  çˆ¶ã®ï¼§ï¼°: string;
  çˆ¶ã®åå‰ï¼‘: string;
  çˆ¶ã®åå‰ï¼’: string;
  çˆ¶ã®åå‰ï¼“: string;
  æ¯ã®ï¼§ï¼°: string;
  æ¯ã®åå‰ï¼‘: string;
  æ¯ã®åå‰ï¼’: string;
  æ¯ã®åå‰ï¼“: string;
  // ç¥–çˆ¶æ¯ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚‚å¿…è¦ã«å¿œã˜ã¦è¿½åŠ 
  æ—§ã‚³ãƒ¼ãƒ‰: string;
}

interface ImportOptions {
  keyStart?: number;
  keyEnd?: number;
  specificKeys?: number[];
  maxRecords?: number;
  preview?: boolean;
}

/**
 * CSVã‹ã‚‰ç‰¹å®šç¯„å›²ã®ã‚­ãƒ¼ã‚’æŠ½å‡ºã—ã¦ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
 */
async function importSelectedPedigrees(options: ImportOptions = {}) {
  const csvPath = path.join(
    __dirname,
    "../../NewPedigree/è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿UTFVer.csv",
  );

  if (!fs.existsSync(csvPath)) {
    console.error("âŒ CSVãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“:", csvPath);
    return;
  }

  console.log("ğŸ“‚ CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­...");
  const csvContent = fs.readFileSync(csvPath, "utf-8");

  // ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦2è¡Œç›®ã‹ã‚‰é–‹å§‹
  const records = parse(csvContent, {
    columns: true,
    skip_empty_lines: true,
    from_line: 2, // 1è¡Œç›®ã¯æ—¥æœ¬èªãƒ˜ãƒƒãƒ€ãƒ¼ã€2è¡Œç›®ã¯è‹±èªãƒ˜ãƒƒãƒ€ãƒ¼
  }) as PedigreeRow[];

  console.log(`ğŸ“Š ç·ãƒ¬ã‚³ãƒ¼ãƒ‰æ•°: ${records.length}`);

  // ã‚­ãƒ¼ã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
  let filteredRecords = records;

  if (options.specificKeys && options.specificKeys.length > 0) {
    // ç‰¹å®šã®ã‚­ãƒ¼ã®ã¿
    filteredRecords = records.filter((record: PedigreeRow) => {
      const key = parseInt(record.ã‚­ãƒ¼);
      return (options.specificKeys as number[]).includes(key);
    });
    console.log(`ğŸ” ç‰¹å®šã‚­ãƒ¼æŠ½å‡º: ${options.specificKeys.join(", ")}`);
  } else if (options.keyStart !== undefined && options.keyEnd !== undefined) {
    // ç¯„å›²æŒ‡å®š
    filteredRecords = records.filter((record: PedigreeRow) => {
      const key = parseInt(record.ã‚­ãƒ¼);
      return key >= (options.keyStart as number) && key <= (options.keyEnd as number);
    });
    console.log(`ğŸ” ç¯„å›²æŠ½å‡º: ${options.keyStart} - ${options.keyEnd}`);
  }

  // æœ€å¤§ä»¶æ•°åˆ¶é™
  if (options.maxRecords) {
    filteredRecords = filteredRecords.slice(0, options.maxRecords);
  }

  console.log(`ğŸ“‹ æŠ½å‡ºã•ã‚ŒãŸãƒ¬ã‚³ãƒ¼ãƒ‰æ•°: ${filteredRecords.length}`);

  if (options.preview) {
    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ï¼šå®Ÿéš›ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã¯è¡Œã‚ãªã„
    console.log("\nğŸ” ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ - æœ€åˆã®5ä»¶:");
  filteredRecords.slice(0, 5).forEach((record: PedigreeRow, index: number) => {
      console.log(
        `${index + 1}. ã‚­ãƒ¼: ${record.ã‚­ãƒ¼}, GP: ${record.ï¼§ï¼°}, åå‰: ${record.çŒ«åå‰ï¼“}`,
      );
    });
    return;
  }

  // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
  console.log("ğŸ’¾ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¸ã‚¤ãƒ³ãƒãƒ¼ãƒˆä¸­...");
  let successCount = 0;
  let errorCount = 0;

  for (const record of filteredRecords as PedigreeRow[]) {
    try {
      // çŒ«ç¨®ã¨ã‚³ãƒ¼ãƒˆã‚«ãƒ©ãƒ¼ã®ãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆå¿…è¦ã«å¿œã˜ã¦å®Ÿè£…ï¼‰
      const breedId = await getOrCreateBreed(record.çŒ«ç¨®ï½ºï½°ï¾„ï¾);
      const colorId = await getOrCreateCoatColor(record.æ¯›è‰²ï½ºï½°ï¾„ï¾);

      // è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®ä½œæˆ
      await prisma.pedigree.create({
        data: {
          pedigreeId: record.ï¼§ï¼° || `GP_${record.ã‚­ãƒ¼}`,
          title: record.çŒ«åå‰ï¼‘ || null,
          catName:
            ((record.çŒ«åå‰ï¼’ || "") + " " + (record.çŒ«åå‰ï¼“ || "")).trim() ||
            `Cat_${record.ã‚­ãƒ¼}`,
          breedId: breedId,
          breedCode: parseInt(record.çŒ«ç¨®ï½ºï½°ï¾„ï¾) || null,
          genderCode: parseInt(record.æ€§åˆ¥) || null,
          eyeColor: record.ç›®è‰² || null,
          colorId: colorId,
          coatColorCode: parseInt(record.æ¯›è‰²ï½ºï½°ï¾„ï¾) || null,
          birthDate: parseDate(record.ç”Ÿå¹´æœˆæ—¥),
          registrationDate: parseDate(record.ç™»éŒ²å¹´æœˆæ—¥),
          breederName: record.ç¹æ®–è€…å || null,
          ownerName: record.æ‰€æœ‰è€…å || null,
          brotherCount: parseInt(record.å…„å¼Ÿã®äººæ•°) || null,
          sisterCount: parseInt(record.å§‰å¦¹ã®äººæ•°) || null,
          notes: record.æ‘˜è¦ || null,
          notes2: record.æ‘˜è¦ï¼’ || null,
          otherNo: record.ä»–å›£ä½“No || null,
          oldCode: record.æ—§ã‚³ãƒ¼ãƒ‰ || null,
          // è¦ªã®æƒ…å ±ã¯åˆ¥é€”å‡¦ç†ï¼ˆãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ§‹ç¯‰ï¼‰
        },
      });
      successCount++;
    } catch (error) {
      console.error(`âŒ ã‚¨ãƒ©ãƒ¼ (ã‚­ãƒ¼: ${record.ã‚­ãƒ¼}):`, error);
      errorCount++;
    }
  }

  console.log(`\nâœ… ã‚¤ãƒ³ãƒãƒ¼ãƒˆå®Œäº†:`);
  console.log(`  æˆåŠŸ: ${successCount}ä»¶`);
  console.log(`  ã‚¨ãƒ©ãƒ¼: ${errorCount}ä»¶`);
}

/**
 * çŒ«ç¨®ã®å–å¾—ã¾ãŸã¯ä½œæˆ
 */
async function getOrCreateBreed(breedCode: string): Promise<string | null> {
  if (!breedCode) return null;

  try {
    const code = parseInt(breedCode);
    const breed = await prisma.breed.findFirst({
      where: { code: code },
    });

    if (breed) {
      return breed.id;
    }

    // æ–°ã—ã„çŒ«ç¨®ã‚’ä½œæˆ
    const newBreed = await prisma.breed.create({
      data: {
        code: code,
        name: `Breed_${code}`,
        description: "Imported from CSV",
      },
    });

    return newBreed.id;
  } catch (error) {
    console.error(`çŒ«ç¨®ä½œæˆã‚¨ãƒ©ãƒ¼ (${breedCode}):`, error);
    return null;
  }
}

/**
 * æ¯›è‰²ã®å–å¾—ã¾ãŸã¯ä½œæˆ
 */
async function getOrCreateCoatColor(colorCode: string): Promise<string | null> {
  if (!colorCode) return null;

  try {
    const code = parseInt(colorCode);
    const color = await prisma.coatColor.findFirst({
      where: { code: code },
    });

    if (color) {
      return color.id;
    }

    // æ–°ã—ã„æ¯›è‰²ã‚’ä½œæˆ
    const newColor = await prisma.coatColor.create({
      data: {
        code: code,
        name: `Color_${code}`,
        description: "Imported from CSV",
      },
    });

    return newColor.id;
  } catch (error) {
    console.error(`æ¯›è‰²ä½œæˆã‚¨ãƒ©ãƒ¼ (${colorCode}):`, error);
    return null;
  }
}

/**
 * æ—¥ä»˜ã®è§£æ
 */
function parseDate(dateStr: string): Date | null {
  if (!dateStr) return null;

  try {
    // YYYY.MM.DD å½¢å¼ã‚’æƒ³å®š
    const parts = dateStr.split(".");
    if (parts.length === 3) {
      const year = parseInt(parts[0]);
      const month = parseInt(parts[1]) - 1; // JSã®Dateã¯0ãƒ™ãƒ¼ã‚¹
      const day = parseInt(parts[2]);
      return new Date(year, month, day);
    }
    return null;
  } catch {
    return null;
  }
}

/**
 * ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œé–¢æ•°
 */
async function main() {
  const args = process.argv.slice(2);

  if (args.length === 0) {
    console.log(`
ğŸ± CSVãƒ‡ãƒ¼ã‚¿é¸æŠçš„ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ„ãƒ¼ãƒ«

ä½¿ç”¨æ–¹æ³•:
  # ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆå®Ÿè¡Œã›ãšã«ç¢ºèªã®ã¿ï¼‰
  npm run csv:preview

  # ç¯„å›²æŒ‡å®šã‚¤ãƒ³ãƒãƒ¼ãƒˆ
  npm run csv:import -- --start 701606 --end 701630

  # ç‰¹å®šã‚­ãƒ¼æŒ‡å®šã‚¤ãƒ³ãƒãƒ¼ãƒˆ  
  npm run csv:import -- --keys 701606,701610,701615

  # æœ€å¤§ä»¶æ•°åˆ¶é™
  npm run csv:import -- --start 701606 --end 701630 --max 10

ä¾‹:
  npm run csv:import -- --start 701606 --end 701630 --max 25
    `);
    process.exit(0);
  }

  const options: ImportOptions = {};

  // ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã®è§£æ
  for (let i = 0; i < args.length; i++) {
    switch (args[i]) {
      case "--start":
        options.keyStart = parseInt(args[++i]);
        break;
      case "--end":
        options.keyEnd = parseInt(args[++i]);
        break;
      case "--keys":
        options.specificKeys = args[++i]
          .split(",")
          .map((k) => parseInt(k.trim()));
        break;
      case "--max":
        options.maxRecords = parseInt(args[++i]);
        break;
      case "--preview":
        options.preview = true;
        break;
    }
  }

  try {
    await importSelectedPedigrees(options);
  } catch (error) {
    console.error("âŒ ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼:", error);
  } finally {
    await prisma.$disconnect();
  }
}

if (require.main === module) {
  // eslint-disable-next-line @typescript-eslint/no-floating-promises
  (async () => {
    try {
      await main();
      process.exit(0);
    } catch (e) {
      console.error(e);
      process.exit(1);
    }
  })();
}

export { importSelectedPedigrees };
`````

## File: backend/src/scripts/sync-prisma.mjs
`````javascript
// /appproject/backend/src/scripts/sync-prisma.mjs
// Prismaã‚¹ã‚­ãƒ¼ãƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã«è‡ªå‹•åŒæœŸã™ã‚‹ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
import fs from "fs";
import path from "path";
import chokidar from "chokidar";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// scripts/ã‹ã‚‰../../prisma/ã¸ã®ãƒ‘ã‚¹
const prismaDir = path.resolve(__dirname, "../../prisma");
const src = path.join(prismaDir, "schema.prisma");
const dst = path.join(prismaDir, "schema_prisma.txt");

function copyOnce() {
  if (!fs.existsSync(src)) {
    console.error(`[sync-prisma] not found: ${src}`);
    process.exit(1);
  }
  
  try {
    const data = fs.readFileSync(src, "utf8");
    
    // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ä»˜ãã§ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã«å‡ºåŠ›
    const timestamp = new Date().toISOString();
    const header = `// Prisma Schema - Last Updated: ${timestamp}\n// Auto-generated from schema.prisma\n\n`;
    const content = header + data;
    
    fs.writeFileSync(dst, content, "utf8");
    console.log(`[sync-prisma] copied -> ${path.relative(process.cwd(), dst)} (${new Date().toLocaleTimeString()})`);
  } catch (error) {
    console.error(`[sync-prisma] error: ${error.message}`);
  }
}

const once = process.argv.includes("--once");
if (once) {
  copyOnce();
  process.exit(0);
}

// watch mode
console.log(`[sync-prisma] watching: ${path.relative(process.cwd(), src)}`);
const watcher = chokidar.watch(src, { ignoreInitial: false, awaitWriteFinish: { stabilityThreshold: 200 } });

let busy = false;
watcher.on("change", () => {
  if (busy) return;
  busy = true;
  try {
    copyOnce();
  } finally {
    setTimeout(() => (busy = false), 150);
  }
});
watcher.on("add", copyOnce);
`````

## File: backend/src/scripts/test-auth-login.ts
`````typescript
import 'reflect-metadata';
import { Logger } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';

import { AppModule } from '../app.module';
import { AuthService } from '../auth/auth.service';

async function main() {
  const logger = new Logger('ManualLoginScript');
  const appContext = await NestFactory.createApplicationContext(AppModule, {
    logger: ['error', 'warn'],
  });

  try {
    const authService = appContext.get(AuthService);
    const result = await authService.login('admin@example.com', 'Passw0rd!');
    logger.log(`Login success: ${JSON.stringify(result)}`);
  } catch (error) {
    logger.error('Login failed', error instanceof Error ? error.stack : error);
  } finally {
    await appContext.close();
  }
}

main().catch((error) => {
   
  console.error('Unexpected error', error);
  process.exit(1);
});
`````

## File: backend/src/shift/dto/create-shift-template.dto.ts
`````typescript
import { IsString, IsInt, IsBoolean, IsOptional } from 'class-validator';

export class CreateShiftTemplateDto {
  @IsString()
  name: string;

  @IsString()
  startTime: string;

  @IsString()
  endTime: string;

  @IsInt()
  duration: number;

  @IsOptional()
  @IsString()
  color?: string;

  @IsOptional()
  @IsInt()
  breakTime?: number;

  @IsOptional()
  @IsBoolean()
  isActive?: boolean;

  @IsOptional()
  @IsInt()
  displayOrder?: number;
}
`````

## File: backend/src/shift/dto/create-shift.dto.ts
`````typescript
import {
  IsString,
  IsUUID,
  IsNotEmpty,
  IsOptional,
  Matches,
} from 'class-validator';

/**
 * ã‚·ãƒ•ãƒˆä½œæˆDTOï¼ˆæœ€å°å®Ÿè£…ï¼‰
 * ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã§ã‚¹ã‚¿ãƒƒãƒ•ã‚’ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã«é…ç½®ã™ã‚‹éš›ã«ä½¿ç”¨
 */
export class CreateShiftDto {
  /**
   * ã‚¹ã‚¿ãƒƒãƒ•IDï¼ˆå¿…é ˆï¼‰
   */
  @IsUUID('4', { message: 'æœ‰åŠ¹ãªã‚¹ã‚¿ãƒƒãƒ•IDã‚’æŒ‡å®šã—ã¦ãã ã•ã„' })
  @IsNotEmpty({ message: 'ã‚¹ã‚¿ãƒƒãƒ•IDã¯å¿…é ˆã§ã™' })
  staffId: string;

  /**
   * ã‚·ãƒ•ãƒˆæ—¥ä»˜ï¼ˆå¿…é ˆã€YYYY-MM-DDå½¢å¼ï¼‰
   */
  @IsString()
  @IsNotEmpty({ message: 'ã‚·ãƒ•ãƒˆæ—¥ä»˜ã¯å¿…é ˆã§ã™' })
  @Matches(/^\d{4}-\d{2}-\d{2}$/, {
    message: 'ã‚·ãƒ•ãƒˆæ—¥ä»˜ã¯YYYY-MM-DDå½¢å¼ã§æŒ‡å®šã—ã¦ãã ã•ã„',
  })
  shiftDate: string;

  /**
   * è¡¨ç¤ºåï¼ˆä»»æ„ã€æŒ‡å®šã—ãªã„å ´åˆã¯ã‚¹ã‚¿ãƒƒãƒ•åã‚’ä½¿ç”¨ï¼‰
   */
  @IsOptional()
  @IsString()
  displayName?: string | null;

  /**
   * å‚™è€ƒï¼ˆä»»æ„ï¼‰
   */
  @IsOptional()
  @IsString()
  notes?: string | null;
}
`````

## File: backend/src/shift/dto/get-shifts-query.dto.ts
`````typescript
import { IsString, IsOptional, IsUUID, Matches } from 'class-validator';

/**
 * ã‚·ãƒ•ãƒˆä¸€è¦§å–å¾—ç”¨ã‚¯ã‚¨ãƒªDTO
 */
export class GetShiftsQueryDto {
  /**
   * é–‹å§‹æ—¥ï¼ˆYYYY-MM-DDå½¢å¼ï¼‰
   */
  @IsOptional()
  @IsString()
  @Matches(/^\d{4}-\d{2}-\d{2}$/, {
    message: 'é–‹å§‹æ—¥ã¯YYYY-MM-DDå½¢å¼ã§æŒ‡å®šã—ã¦ãã ã•ã„',
  })
  startDate?: string;

  /**
   * çµ‚äº†æ—¥ï¼ˆYYYY-MM-DDå½¢å¼ï¼‰
   */
  @IsOptional()
  @IsString()
  @Matches(/^\d{4}-\d{2}-\d{2}$/, {
    message: 'çµ‚äº†æ—¥ã¯YYYY-MM-DDå½¢å¼ã§æŒ‡å®šã—ã¦ãã ã•ã„',
  })
  endDate?: string;

  /**
   * ã‚¹ã‚¿ãƒƒãƒ•IDã§ãƒ•ã‚£ãƒ«ã‚¿ï¼ˆä»»æ„ï¼‰
   */
  @IsOptional()
  @IsUUID('4', { message: 'æœ‰åŠ¹ãªã‚¹ã‚¿ãƒƒãƒ•IDã‚’æŒ‡å®šã—ã¦ãã ã•ã„' })
  staffId?: string;
}
`````

## File: backend/src/shift/dto/update-shift.dto.ts
`````typescript
import { ShiftStatus } from '@prisma/client';
import {
  IsString,
  IsUUID,
  IsOptional,
  Matches,
  IsEnum,
} from 'class-validator';

/**
 * ã‚·ãƒ•ãƒˆæ›´æ–°DTO
 */
export class UpdateShiftDto {
  /**
   * ã‚¹ã‚¿ãƒƒãƒ•IDï¼ˆå¤‰æ›´ã™ã‚‹å ´åˆï¼‰
   */
  @IsOptional()
  @IsUUID('4', { message: 'æœ‰åŠ¹ãªã‚¹ã‚¿ãƒƒãƒ•IDã‚’æŒ‡å®šã—ã¦ãã ã•ã„' })
  staffId?: string;

  /**
   * ã‚·ãƒ•ãƒˆæ—¥ä»˜ï¼ˆå¤‰æ›´ã™ã‚‹å ´åˆã€YYYY-MM-DDå½¢å¼ï¼‰
   */
  @IsOptional()
  @IsString()
  @Matches(/^\d{4}-\d{2}-\d{2}$/, {
    message: 'ã‚·ãƒ•ãƒˆæ—¥ä»˜ã¯YYYY-MM-DDå½¢å¼ã§æŒ‡å®šã—ã¦ãã ã•ã„',
  })
  shiftDate?: string;

  /**
   * è¡¨ç¤ºå
   */
  @IsOptional()
  @IsString()
  displayName?: string | null;

  /**
   * å‚™è€ƒ
   */
  @IsOptional()
  @IsString()
  notes?: string | null;

  /**
   * ã‚·ãƒ•ãƒˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
   */
  @IsOptional()
  @IsEnum(ShiftStatus, { message: 'æœ‰åŠ¹ãªã‚·ãƒ•ãƒˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’æŒ‡å®šã—ã¦ãã ã•ã„' })
  status?: ShiftStatus;
}
`````

## File: backend/src/shift/shift.controller.spec.ts
`````typescript
import { Test, TestingModule } from '@nestjs/testing';

import { getTestModuleImports, getTestModuleProviders } from '../test-utils/test-module-setup';

import { ShiftController } from './shift.controller';
import { ShiftService } from './shift.service';

describe('ShiftController', () => {
  let controller: ShiftController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      imports: getTestModuleImports(),
      controllers: [ShiftController],
      providers: [
        ...getTestModuleProviders(),
        {
          provide: ShiftService,
          useValue: {
            create: jest.fn(),
            findAll: jest.fn(),
            findOne: jest.fn(),
            update: jest.fn(),
            remove: jest.fn(),
            getCalendarShifts: jest.fn(),
          },
        },
      ],
    }).compile();

    controller = module.get<ShiftController>(ShiftController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
`````

## File: backend/src/shift/shift.controller.ts
`````typescript
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';

import { ApiResponse } from '../common/dto/api-response.dto';
import { ShiftResponseDto, CalendarShiftEvent } from '../common/types/shift.types';

import { CreateShiftDto } from './dto/create-shift.dto';
import { GetShiftsQueryDto } from './dto/get-shifts-query.dto';
import { UpdateShiftDto } from './dto/update-shift.dto';
import { ShiftService } from './shift.service';

@Controller('shifts')
export class ShiftController {
  constructor(private readonly shiftService: ShiftService) {}

  /**
   * ã‚·ãƒ•ãƒˆã‚’æ–°è¦ä½œæˆ
   */
  @Post()
  @HttpCode(HttpStatus.CREATED)
  async create(@Body() createShiftDto: CreateShiftDto): Promise<ApiResponse<ShiftResponseDto>> {
    const shift = await this.shiftService.create(createShiftDto);
    return ApiResponse.success(shift);
  }

  /**
   * ã‚·ãƒ•ãƒˆä¸€è¦§ã‚’å–å¾—
   */
  @Get()
  async findAll(@Query() query: GetShiftsQueryDto): Promise<ApiResponse<ShiftResponseDto[]>> {
    const shifts = await this.shiftService.findAll(query);
    return ApiResponse.success(shifts);
  }

  /**
   * ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼è¡¨ç¤ºç”¨ã®ã‚·ãƒ•ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
   */
  @Get('calendar')
  async getCalendarData(
    @Query() query: GetShiftsQueryDto,
  ): Promise<ApiResponse<CalendarShiftEvent[]>> {
    const events = await this.shiftService.getCalendarData(query);
    return ApiResponse.success(events);
  }

  /**
   * æŒ‡å®šIDã®ã‚·ãƒ•ãƒˆã‚’å–å¾—
   */
  @Get(':id')
  async findOne(@Param('id') id: string): Promise<ApiResponse<ShiftResponseDto>> {
    const shift = await this.shiftService.findOne(id);
    return ApiResponse.success(shift);
  }

  /**
   * ã‚·ãƒ•ãƒˆæƒ…å ±ã‚’æ›´æ–°
   */
  @Patch(':id')
  async update(
    @Param('id') id: string,
    @Body() updateShiftDto: UpdateShiftDto,
  ): Promise<ApiResponse<ShiftResponseDto>> {
    const shift = await this.shiftService.update(id, updateShiftDto);
    return ApiResponse.success(shift);
  }

  /**
   * ã‚·ãƒ•ãƒˆã‚’å‰Šé™¤
   */
  @Delete(':id')
  @HttpCode(HttpStatus.OK)
  async remove(@Param('id') id: string): Promise<ApiResponse<{ id: string }>> {
    await this.shiftService.remove(id);
    return ApiResponse.success({ id });
  }
}
`````

## File: backend/src/shift/shift.module.ts
`````typescript
import { Module } from '@nestjs/common';

import { PrismaModule } from '../prisma/prisma.module';

import { ShiftController } from './shift.controller';
import { ShiftService } from './shift.service';

@Module({
  imports: [PrismaModule],
  providers: [ShiftService],
  controllers: [ShiftController],
  exports: [ShiftService],
})
export class ShiftModule {}
`````

## File: backend/src/shift/shift.service.spec.ts
`````typescript
import { Test, TestingModule } from '@nestjs/testing';

import { PrismaService } from '../prisma/prisma.service';

import { ShiftService } from './shift.service';

describe('ShiftService', () => {
  let service: ShiftService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        ShiftService,
        {
          provide: PrismaService,
          useValue: {
            shift: {
              create: jest.fn(),
              findMany: jest.fn(),
              findUnique: jest.fn(),
              update: jest.fn(),
              delete: jest.fn(),
            },
            staff: {
              findUnique: jest.fn(),
            },
          },
        },
      ],
    }).compile();

    service = module.get<ShiftService>(ShiftService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
`````

## File: backend/src/shift/shift.service.ts
`````typescript
import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { Shift, Staff, Prisma } from '@prisma/client';

import {
  ShiftResponseDto,
  CalendarShiftEvent,
  // ShiftEntity, // Unused - keeping import for future use
} from '../common/types/shift.types';
import { PrismaService } from '../prisma/prisma.service';

import { CreateShiftDto } from './dto/create-shift.dto';
import { GetShiftsQueryDto } from './dto/get-shifts-query.dto';
import { UpdateShiftDto } from './dto/update-shift.dto';

@Injectable()
export class ShiftService {
  constructor(private prisma: PrismaService) {}

  /**
   * æ—¥ä»˜æ–‡å­—åˆ—ï¼ˆYYYY-MM-DDï¼‰ã‚’Dateã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›
   * ä¸æ­£ãªæ—¥ä»˜ã®å ´åˆã¯ã‚¨ãƒ©ãƒ¼ã‚’ã‚¹ãƒ­ãƒ¼
   */
  private parseDate(dateString: string): Date {
    const date = new Date(dateString + 'T00:00:00.000Z');
    if (isNaN(date.getTime())) {
      throw new BadRequestException(`Invalid date format: ${dateString}`);
    }
    return date;
  }

  /**
   * Shiftã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’ ShiftResponseDto ã«å¤‰æ›
   */
  private toResponseDto(shift: Shift & { staff: Staff }): ShiftResponseDto {
    return {
      id: shift.id,
      staffId: shift.staffId,
      staffName: shift.staff.name,
      staffColor: shift.staff.color,
      shiftDate: shift.shiftDate.toISOString().split('T')[0], // YYYY-MM-DD
      displayName: shift.displayName,
      status: shift.status,
      notes: shift.notes,
      createdAt: shift.createdAt.toISOString(),
      updatedAt: shift.updatedAt.toISOString(),
    };
  }

  /**
   * Shiftã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’ CalendarShiftEvent ã«å¤‰æ›
   */
  private toCalendarEvent(shift: Shift & { staff: Staff }): CalendarShiftEvent {
    const shiftDate = shift.shiftDate.toISOString().split('T')[0];

    return {
      id: shift.id,
      title: shift.staff.name,
      start: shiftDate,
      end: shiftDate,
      backgroundColor: shift.staff.color,
      borderColor: shift.staff.color,
      extendedProps: {
        shiftId: shift.id,
        staffId: shift.staffId,
        staffName: shift.staff.name,
        displayName: shift.displayName,
        notes: shift.notes,
      },
    };
  }

  /**
   * ã‚·ãƒ•ãƒˆã‚’æ–°è¦ä½œæˆ
   */
  async create(createShiftDto: CreateShiftDto): Promise<ShiftResponseDto> {
    // ã‚¹ã‚¿ãƒƒãƒ•ã®å­˜åœ¨ç¢ºèª
    const staff = await this.prisma.staff.findUnique({
      where: { id: createShiftDto.staffId },
    });

    if (!staff) {
      throw new NotFoundException(`Staff with ID ${createShiftDto.staffId} not found`);
    }

    if (!staff.isActive) {
      throw new BadRequestException(`Staff with ID ${createShiftDto.staffId} is not active`);
    }

    // æ—¥ä»˜ã‚’ãƒ‘ãƒ¼ã‚¹
    const shiftDate = this.parseDate(createShiftDto.shiftDate);

    // ã‚·ãƒ•ãƒˆã‚’ä½œæˆ
    const shift = await this.prisma.shift.create({
      data: {
        staffId: createShiftDto.staffId,
        shiftDate: shiftDate,
        displayName: createShiftDto.displayName || null,
        notes: createShiftDto.notes || null,
        status: 'SCHEDULED', // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
        mode: 'SIMPLE', // æœ€å°å®Ÿè£…ã§ã¯ç°¡æ˜“ãƒ¢ãƒ¼ãƒ‰
      },
      include: {
        staff: true,
      },
    });

    return this.toResponseDto(shift);
  }

  /**
   * ã‚·ãƒ•ãƒˆä¸€è¦§ã‚’å–å¾—
   */
  async findAll(query: GetShiftsQueryDto): Promise<ShiftResponseDto[]> {
    const where: Prisma.ShiftWhereInput = {};

    // æ—¥ä»˜ç¯„å›²ã§ãƒ•ã‚£ãƒ«ã‚¿
    if (query.startDate && query.endDate) {
      where.shiftDate = {
        gte: this.parseDate(query.startDate),
        lte: this.parseDate(query.endDate),
      };
    } else if (query.startDate) {
      where.shiftDate = {
        gte: this.parseDate(query.startDate),
      };
    } else if (query.endDate) {
      where.shiftDate = {
        lte: this.parseDate(query.endDate),
      };
    }

    // ã‚¹ã‚¿ãƒƒãƒ•IDã§ãƒ•ã‚£ãƒ«ã‚¿
    if (query.staffId) {
      where.staffId = query.staffId;
    }

    const shifts = await this.prisma.shift.findMany({
      where,
      include: {
        staff: true,
      },
      orderBy: { shiftDate: 'asc' },
    });

    return shifts.map((shift) => this.toResponseDto(shift));
  }

  /**
   * ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼è¡¨ç¤ºç”¨ã®ã‚·ãƒ•ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
   */
  async getCalendarData(query: GetShiftsQueryDto): Promise<CalendarShiftEvent[]> {
    const shifts = await this.prisma.shift.findMany({
      where: {
        ...(query.startDate &&
          query.endDate && {
            shiftDate: {
              gte: this.parseDate(query.startDate),
              lte: this.parseDate(query.endDate),
            },
          }),
        ...(query.staffId && { staffId: query.staffId }),
      },
      include: {
        staff: true,
      },
      orderBy: { shiftDate: 'asc' },
    });

    return shifts.map((shift) => this.toCalendarEvent(shift));
  }

  /**
   * æŒ‡å®šIDã®ã‚·ãƒ•ãƒˆã‚’å–å¾—
   */
  async findOne(id: string): Promise<ShiftResponseDto> {
    const shift = await this.prisma.shift.findUnique({
      where: { id },
      include: {
        staff: true,
      },
    });

    if (!shift) {
      throw new NotFoundException(`Shift with ID ${id} not found`);
    }

    return this.toResponseDto(shift);
  }

  /**
   * ã‚·ãƒ•ãƒˆæƒ…å ±ã‚’æ›´æ–°
   */
  async update(id: string, updateShiftDto: UpdateShiftDto): Promise<ShiftResponseDto> {
    // æ—¢å­˜ã‚·ãƒ•ãƒˆã®å­˜åœ¨ç¢ºèª
    await this.findOne(id);

    // ã‚¹ã‚¿ãƒƒãƒ•IDãŒå¤‰æ›´ã•ã‚Œã‚‹å ´åˆã€ã‚¹ã‚¿ãƒƒãƒ•ã®å­˜åœ¨ç¢ºèª
    if (updateShiftDto.staffId) {
      const staff = await this.prisma.staff.findUnique({
        where: { id: updateShiftDto.staffId },
      });

      if (!staff || !staff.isActive) {
        throw new BadRequestException(`Staff with ID ${updateShiftDto.staffId} is not available`);
      }
    }

    // æ›´æ–°ãƒ‡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰
    const updateData: Partial<Prisma.ShiftUncheckedUpdateInput> = {};

    if (updateShiftDto.staffId !== undefined) {
      updateData.staffId = updateShiftDto.staffId;
    }

    if (updateShiftDto.shiftDate !== undefined) {
      updateData.shiftDate = this.parseDate(updateShiftDto.shiftDate);
    }

    if (updateShiftDto.displayName !== undefined) {
      updateData.displayName = updateShiftDto.displayName;
    }

    if (updateShiftDto.notes !== undefined) {
      updateData.notes = updateShiftDto.notes;
    }

    if (updateShiftDto.status !== undefined) {
      updateData.status = updateShiftDto.status;
    }

    // ã‚·ãƒ•ãƒˆã‚’æ›´æ–°
    const shift = await this.prisma.shift.update({
      where: { id },
      data: updateData,
      include: {
        staff: true,
      },
    });

    return this.toResponseDto(shift);
  }

  /**
   * ã‚·ãƒ•ãƒˆã‚’å‰Šé™¤
   */
  async remove(id: string): Promise<void> {
    // å­˜åœ¨ç¢ºèª
    await this.findOne(id);

    // ç‰©ç†å‰Šé™¤
    await this.prisma.shift.delete({
      where: { id },
    });
  }
}
`````

## File: backend/src/staff/dto/create-staff.dto.ts
`````typescript
import { Type } from 'class-transformer';
import { IsString, IsEmail, IsOptional, IsBoolean, IsUUID, IsNotEmpty, Matches, IsArray, IsIn, ValidateNested, IsInt, Min, Max } from 'class-validator';

/**
 * å‹¤å‹™æ™‚é–“ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆDTO
 */
export class WorkTimeTemplateDto {
  @IsInt({ message: 'é–‹å§‹æ™‚é–“ã¯æ•´æ•°ã§æŒ‡å®šã—ã¦ãã ã•ã„' })
  @Min(0, { message: 'é–‹å§‹æ™‚é–“ã¯0ä»¥ä¸Šã§æŒ‡å®šã—ã¦ãã ã•ã„' })
  @Max(23, { message: 'é–‹å§‹æ™‚é–“ã¯23ä»¥ä¸‹ã§æŒ‡å®šã—ã¦ãã ã•ã„' })
  startHour: number;

  @IsInt({ message: 'çµ‚äº†æ™‚é–“ã¯æ•´æ•°ã§æŒ‡å®šã—ã¦ãã ã•ã„' })
  @Min(1, { message: 'çµ‚äº†æ™‚é–“ã¯1ä»¥ä¸Šã§æŒ‡å®šã—ã¦ãã ã•ã„' })
  @Max(24, { message: 'çµ‚äº†æ™‚é–“ã¯24ä»¥ä¸‹ã§æŒ‡å®šã—ã¦ãã ã•ã„' })
  endHour: number;
}

/**
 * ã‚¹ã‚¿ãƒƒãƒ•ä½œæˆDTO
 * æœ€å°å®Ÿè£…: åå‰ã®ã¿å¿…é ˆã€Emailã¯ä¸è¦
 */
export class CreateStaffDto {
  /**
   * ã‚¹ã‚¿ãƒƒãƒ•åï¼ˆå¿…é ˆï¼‰
   */
  @IsString()
  @IsNotEmpty({ message: 'åå‰ã¯å¿…é ˆã§ã™' })
  name: string;

  /**
   * ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ï¼ˆä»»æ„ã€è¨­å®šã™ã‚‹å ´åˆã¯æœ‰åŠ¹ãªãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ï¼‰
   */
  @IsOptional()
  @IsEmail({}, { message: 'æœ‰åŠ¹ãªãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„' })
  email?: string | null;

  /**
   * å½¹è·ï¼ˆä»»æ„ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: "ã‚¹ã‚¿ãƒƒãƒ•"ï¼‰
   */
  @IsOptional()
  @IsString()
  role?: string;

  /**
   * ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼è¡¨ç¤ºè‰²ï¼ˆä»»æ„ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: "#4dabf7"ï¼‰
   * 16é€²æ•°ã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰å½¢å¼
   */
  @IsOptional()
  @IsString()
  @Matches(/^#[0-9A-Fa-f]{6}$/, {
    message: 'ã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ã¯#000000å½¢å¼ã§æŒ‡å®šã—ã¦ãã ã•ã„',
  })
  color?: string;

  /**
   * ãƒ¦ãƒ¼ã‚¶ãƒ¼IDï¼ˆã‚·ã‚¹ãƒ†ãƒ å†…éƒ¨ç”¨ã€é€šå¸¸ã¯ä½¿ç”¨ã—ãªã„ï¼‰
   */
  @IsOptional()
  @IsUUID()
  userId?: string;

  /**
   * æœ‰åŠ¹ãƒ•ãƒ©ã‚°ï¼ˆä»»æ„ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: trueï¼‰
   */
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;

  /**
   * å‡ºå‹¤æ›œæ—¥ï¼ˆä»»æ„ï¼‰
   * ["mon", "tue", "wed", "thu", "fri", "sat", "sun"] ã®é…åˆ—
   */
  @IsOptional()
  @IsArray()
  @IsIn(['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'], { each: true })
  workingDays?: string[] | null;

  /**
   * å‹¤å‹™æ™‚é–“ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆï¼ˆä»»æ„ï¼‰
   */
  @IsOptional()
  @ValidateNested()
  @Type(() => WorkTimeTemplateDto)
  workTimeTemplate?: WorkTimeTemplateDto | null;
}
`````

## File: backend/src/staff/dto/update-staff.dto.ts
`````typescript
import { PartialType } from '@nestjs/mapped-types';

import { CreateStaffDto } from './create-staff.dto';

export class UpdateStaffDto extends PartialType(CreateStaffDto) {}
`````

## File: backend/src/staff/staff.controller.spec.ts
`````typescript
import { Test, TestingModule } from '@nestjs/testing';

import { getTestModuleImports, getTestModuleProviders } from '../test-utils/test-module-setup';

import { StaffController } from './staff.controller';
import { StaffService } from './staff.service';

describe('StaffController', () => {
  let controller: StaffController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      imports: getTestModuleImports(),
      controllers: [StaffController],
      providers: [
        ...getTestModuleProviders(),
        {
          provide: StaffService,
          useValue: {
            create: jest.fn(),
            findAll: jest.fn(),
            findOne: jest.fn(),
            update: jest.fn(),
            remove: jest.fn(),
          },
        },
      ],
    }).compile();

    controller = module.get<StaffController>(StaffController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
`````

## File: backend/src/staff/staff.controller.ts
`````typescript
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';

import { ApiResponse } from '../common/dto/api-response.dto';
import { StaffResponseDto, StaffListResponseDto } from '../common/types/staff.types';

import { CreateStaffDto } from './dto/create-staff.dto';
import { UpdateStaffDto } from './dto/update-staff.dto';
import { StaffService } from './staff.service';

@Controller('staff')
export class StaffController {
  constructor(private readonly staffService: StaffService) {}

  /**
   * ã‚¹ã‚¿ãƒƒãƒ•ã‚’æ–°è¦ä½œæˆ
   */
  @Post()
  @HttpCode(HttpStatus.CREATED)
  async create(@Body() createStaffDto: CreateStaffDto): Promise<ApiResponse<StaffResponseDto>> {
    const staff = await this.staffService.create(createStaffDto);
    return ApiResponse.success(staff);
  }

  /**
   * ã‚¹ã‚¿ãƒƒãƒ•ä¸€è¦§ã‚’å–å¾—
   */
  @Get()
  async findAll(): Promise<ApiResponse<StaffListResponseDto>> {
    const result = await this.staffService.findAll();
    return ApiResponse.success(result);
  }

  /**
   * æŒ‡å®šIDã®ã‚¹ã‚¿ãƒƒãƒ•ã‚’å–å¾—
   */
  @Get(':id')
  async findOne(@Param('id') id: string): Promise<ApiResponse<StaffResponseDto>> {
    const staff = await this.staffService.findOne(id);
    return ApiResponse.success(staff);
  }

  /**
   * ã‚¹ã‚¿ãƒƒãƒ•æƒ…å ±ã‚’æ›´æ–°
   */
  @Patch(':id')
  async update(
    @Param('id') id: string,
    @Body() updateStaffDto: UpdateStaffDto,
  ): Promise<ApiResponse<StaffResponseDto>> {
    const staff = await this.staffService.update(id, updateStaffDto);
    return ApiResponse.success(staff);
  }

  /**
   * ã‚¹ã‚¿ãƒƒãƒ•ã‚’å‰Šé™¤ï¼ˆè«–ç†å‰Šé™¤ï¼‰
   */
  @Delete(':id')
  @HttpCode(HttpStatus.OK)
  async remove(@Param('id') id: string): Promise<ApiResponse<StaffResponseDto>> {
    const staff = await this.staffService.remove(id);
    return ApiResponse.success(staff);
  }

  /**
   * å‰Šé™¤ã—ãŸã‚¹ã‚¿ãƒƒãƒ•ã‚’å¾©å…ƒ
   */
  @Patch(':id/restore')
  async restore(@Param('id') id: string): Promise<ApiResponse<StaffResponseDto>> {
    const staff = await this.staffService.restore(id);
    return ApiResponse.success(staff);
  }
}
`````

## File: backend/src/staff/staff.module.ts
`````typescript
import { Module } from '@nestjs/common';

import { PrismaModule } from '../prisma/prisma.module';

import { StaffController } from './staff.controller';
import { StaffService } from './staff.service';

@Module({
  imports: [PrismaModule],
  providers: [StaffService],
  controllers: [StaffController],
  exports: [StaffService],
})
export class StaffModule {}
`````

## File: backend/src/staff/staff.service.spec.ts
`````typescript
import { Test, TestingModule } from '@nestjs/testing';

import { PrismaService } from '../prisma/prisma.service';

import { StaffService } from './staff.service';

describe('StaffService', () => {
  let service: StaffService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        StaffService,
        {
          provide: PrismaService,
          useValue: {
            staff: {
              create: jest.fn(),
              findMany: jest.fn(),
              findUnique: jest.fn(),
              update: jest.fn(),
              delete: jest.fn(),
            },
          },
        },
      ],
    }).compile();

    service = module.get<StaffService>(StaffService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
`````

## File: backend/src/staff/staff.service.ts
`````typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { Staff, Prisma } from '@prisma/client';

import { StaffResponseDto, StaffListResponseDto, Weekday, WorkTimeTemplate } from '../common/types/staff.types';
import { PrismaService } from '../prisma/prisma.service';

import { CreateStaffDto } from './dto/create-staff.dto';
import { UpdateStaffDto } from './dto/update-staff.dto';

@Injectable()
export class StaffService {
  constructor(private prisma: PrismaService) {}

  /**
   * JSONãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’Weekday[]ã«å¤‰æ›
   */
  private parseWorkingDays(json: Prisma.JsonValue | null): Weekday[] | null {
    if (!json || !Array.isArray(json)) return null;
    const validDays: Weekday[] = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
    return json.filter((day): day is Weekday => validDays.includes(day as Weekday));
  }

  /**
   * JSONãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’WorkTimeTemplateã«å¤‰æ›
   */
  private parseWorkTimeTemplate(json: Prisma.JsonValue | null): WorkTimeTemplate | null {
    if (!json || typeof json !== 'object' || Array.isArray(json)) return null;
    const obj = json as Record<string, unknown>;
    if (typeof obj.startHour === 'number' && typeof obj.endHour === 'number') {
      return { startHour: obj.startHour, endHour: obj.endHour };
    }
    return null;
  }

  /**
   * Staffã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’ StaffResponseDto ã«å¤‰æ›
   */
  private toResponseDto(staff: Staff): StaffResponseDto {
    return {
      id: staff.id,
      name: staff.name,
      email: staff.email,
      role: staff.role,
      color: staff.color,
      isActive: staff.isActive,
      workingDays: this.parseWorkingDays(staff.workingDays),
      workTimeTemplate: this.parseWorkTimeTemplate(staff.workTimeTemplate),
      createdAt: staff.createdAt.toISOString(),
      updatedAt: staff.updatedAt.toISOString(),
    };
  }

  /**
   * ã‚¹ã‚¿ãƒƒãƒ•ã‚’æ–°è¦ä½œæˆ
   */
  async create(createStaffDto: CreateStaffDto): Promise<StaffResponseDto> {
    const staff = await this.prisma.staff.create({
      data: {
        name: createStaffDto.name,
        email: createStaffDto.email || null,
        role: createStaffDto.role || 'ã‚¹ã‚¿ãƒƒãƒ•',
        color: createStaffDto.color || '#4dabf7',
        userId: createStaffDto.userId || null,
        isActive: createStaffDto.isActive !== undefined ? createStaffDto.isActive : true,
        workingDays: createStaffDto.workingDays 
          ? (createStaffDto.workingDays as Prisma.InputJsonValue)
          : Prisma.JsonNull,
        workTimeTemplate: createStaffDto.workTimeTemplate 
          ? (createStaffDto.workTimeTemplate as unknown as Prisma.InputJsonValue)
          : Prisma.JsonNull,
      },
    });

    return this.toResponseDto(staff);
  }

  /**
   * ã‚¹ã‚¿ãƒƒãƒ•ä¸€è¦§ã‚’å–å¾—ï¼ˆæœ‰åŠ¹ãªã‚¹ã‚¿ãƒƒãƒ•ã®ã¿ï¼‰
   */
  async findAll(): Promise<StaffListResponseDto> {
    const staffList = await this.prisma.staff.findMany({
      where: { isActive: true },
      orderBy: { createdAt: 'desc' },
    });

    return {
      staffList: staffList.map((staff) => this.toResponseDto(staff)),
      total: staffList.length,
    };
  }

  /**
   * æŒ‡å®šIDã®ã‚¹ã‚¿ãƒƒãƒ•ã‚’å–å¾—
   */
  async findOne(id: string): Promise<StaffResponseDto> {
    const staff = await this.prisma.staff.findUnique({
      where: { id },
    });

    if (!staff) {
      throw new NotFoundException(`Staff with ID ${id} not found`);
    }

    return this.toResponseDto(staff);
  }

  /**
   * ã‚¹ã‚¿ãƒƒãƒ•æƒ…å ±ã‚’æ›´æ–°
   */
  async update(id: string, updateStaffDto: UpdateStaffDto): Promise<StaffResponseDto> {
    await this.findOne(id); // å­˜åœ¨ãƒã‚§ãƒƒã‚¯

    const staff = await this.prisma.staff.update({
      where: { id },
      data: {
        ...(updateStaffDto.name !== undefined && { name: updateStaffDto.name }),
        ...(updateStaffDto.email !== undefined && { email: updateStaffDto.email }),
        ...(updateStaffDto.role !== undefined && { role: updateStaffDto.role }),
        ...(updateStaffDto.color !== undefined && { color: updateStaffDto.color }),
        ...(updateStaffDto.isActive !== undefined && { isActive: updateStaffDto.isActive }),
        ...(updateStaffDto.workingDays !== undefined && { 
          workingDays: updateStaffDto.workingDays 
            ? (updateStaffDto.workingDays as Prisma.InputJsonValue)
            : Prisma.JsonNull
        }),
        ...(updateStaffDto.workTimeTemplate !== undefined && { 
          workTimeTemplate: updateStaffDto.workTimeTemplate 
            ? (updateStaffDto.workTimeTemplate as unknown as Prisma.InputJsonValue)
            : Prisma.JsonNull
        }),
      },
    });

    return this.toResponseDto(staff);
  }

  /**
   * ã‚¹ã‚¿ãƒƒãƒ•ã‚’å‰Šé™¤ï¼ˆè«–ç†å‰Šé™¤ï¼‰
   */
  async remove(id: string): Promise<StaffResponseDto> {
    await this.findOne(id); // å­˜åœ¨ãƒã‚§ãƒƒã‚¯

    const staff = await this.prisma.staff.update({
      where: { id },
      data: { isActive: false },
    });

    return this.toResponseDto(staff);
  }

  /**
   * å‰Šé™¤ã—ãŸã‚¹ã‚¿ãƒƒãƒ•ã‚’å¾©å…ƒ
   */
  async restore(id: string): Promise<StaffResponseDto> {
    const staff = await this.prisma.staff.findUnique({
      where: { id },
    });

    if (!staff) {
      throw new NotFoundException(`Staff with ID ${id} not found`);
    }

    const restoredStaff = await this.prisma.staff.update({
      where: { id },
      data: { isActive: true },
    });

    return this.toResponseDto(restoredStaff);
  }
}
`````

## File: backend/src/tags/dto/assign-tag.dto.ts
`````typescript
import { ApiProperty } from "@nestjs/swagger";
import { IsUUID } from "class-validator";

export class AssignTagDto {
  @ApiProperty({
    description: "ã‚¿ã‚°ID",
    example: "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee",
  })
  @IsUUID()
  tagId: string; // Updated example
}
`````

## File: backend/src/tags/dto/create-tag-automation-rule.dto.ts
`````typescript
import { ApiProperty, ApiPropertyOptional } from "@nestjs/swagger";
import { TagAutomationEventType, TagAutomationTriggerType } from "@prisma/client";
import {
  IsBoolean,
  IsEnum,
  IsInt,
  IsOptional,
  IsString,
  Max,
  Min,
} from "class-validator";

export class CreateTagAutomationRuleDto {
  @ApiPropertyOptional({ description: "ãƒ«ãƒ¼ãƒ«ã®ä¸€æ„ãªã‚­ãƒ¼ï¼ˆè‡ªå‹•ç”Ÿæˆå¯èƒ½ï¼‰" })
  @IsOptional()
  @IsString()
  key?: string;

  @ApiPropertyOptional({ description: "ãƒ«ãƒ¼ãƒ«åï¼ˆæœªå…¥åŠ›æ™‚ã¯è‡ªå‹•ç”Ÿæˆï¼‰" })
  @IsOptional()
  @IsString()
  name?: string;

  @ApiPropertyOptional({ description: "ãƒ«ãƒ¼ãƒ«ã®èª¬æ˜" })
  @IsOptional()
  @IsString()
  description?: string | null;

  @ApiProperty({
    enum: TagAutomationTriggerType,
    description: "ãƒˆãƒªã‚¬ãƒ¼ã‚¿ã‚¤ãƒ—",
    example: "EVENT",
  })
  @IsEnum(TagAutomationTriggerType)
  triggerType!: TagAutomationTriggerType;

  @ApiPropertyOptional({
    enum: TagAutomationEventType,
    description: "ã‚¤ãƒ™ãƒ³ãƒˆã‚¿ã‚¤ãƒ—",
    example: "PAGE_ACTION",
  })
  @IsOptional()
  @IsEnum(TagAutomationEventType)
  eventType?: TagAutomationEventType;

  @ApiPropertyOptional({ description: "é©ç”¨ç¯„å›²ï¼ˆã‚¹ã‚³ãƒ¼ãƒ—ï¼‰", example: "breeding" })
  @IsOptional()
  @IsString()
  scope?: string | null;

  @ApiPropertyOptional({ description: "ãƒ«ãƒ¼ãƒ«ãŒæœ‰åŠ¹ã‹ã©ã†ã‹", default: true })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;

  @ApiPropertyOptional({
    description: "å„ªå…ˆåº¦ï¼ˆ-100ã‹ã‚‰100ã€å¤§ãã„ã»ã©å„ªå…ˆï¼‰",
    minimum: -100,
    maximum: 100,
    default: 0,
  })
  @IsOptional()
  @IsInt()
  @Min(-100)
  @Max(100)
  priority?: number;

  @ApiPropertyOptional({
    description: "ãƒ«ãƒ¼ãƒ«è¨­å®šï¼ˆJSONï¼‰",
    example: { tagIds: ["tag-id-1", "tag-id-2"], actionType: "ASSIGN" },
  })
  @IsOptional()
  config?: Record<string, unknown> | null;
}
`````

## File: backend/src/tags/dto/create-tag-category.dto.ts
`````typescript
import { ApiProperty, ApiPropertyOptional } from "@nestjs/swagger";
import {
  IsArray,
  IsBoolean,
  IsHexColor,
  IsNumber,
  IsOptional,
  IsString,
  MinLength,
} from "class-validator";

export class CreateTagCategoryDto {
  @ApiPropertyOptional({ description: "ãƒ¦ãƒ‹ãƒ¼ã‚¯ã‚­ãƒ¼ (æœªæŒ‡å®šæ™‚ã¯åå‰ã‹ã‚‰ç”Ÿæˆ)", example: "cats_status" })
  @IsOptional()
  @IsString()
  key?: string;

  @ApiProperty({ description: "ã‚«ãƒ†ã‚´ãƒªå", example: "çŒ«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹" })
  @IsString()
  @MinLength(1)
  name: string;

  @ApiPropertyOptional({ description: "ã‚«ãƒ†ã‚´ãƒªã®èª¬æ˜" })
  @IsOptional()
  @IsString()
  description?: string;

  @ApiPropertyOptional({ description: "ã‚«ãƒ†ã‚´ãƒªã®ä»£è¡¨ã‚«ãƒ©ãƒ¼", example: "#6366F1" })
  @IsOptional()
  @IsHexColor()
  color?: string;

  @ApiPropertyOptional({ description: "ã‚«ãƒ†ã‚´ãƒªã«ä½¿ç”¨ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆã‚«ãƒ©ãƒ¼", example: "#111827" })
  @IsOptional()
  @IsHexColor()
  textColor?: string;

  @ApiPropertyOptional({ description: "è¡¨ç¤ºé †" })
  @IsOptional()
  @IsNumber()
  displayOrder?: number;

  @ApiPropertyOptional({ description: "åˆ©ç”¨ã™ã‚‹ã‚¹ã‚³ãƒ¼ãƒ—ä¸€è¦§", type: [String] })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  scopes?: string[];

  @ApiPropertyOptional({ description: "ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹", example: true })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
}
`````

## File: backend/src/tags/dto/create-tag-group.dto.ts
`````typescript
import { ApiProperty, ApiPropertyOptional } from "@nestjs/swagger";
import { IsBoolean, IsHexColor, IsNumber, IsOptional, IsString, IsUUID, MinLength } from "class-validator";

export class CreateTagGroupDto {
  @ApiProperty({ description: "æ‰€å±ã‚«ãƒ†ã‚´ãƒªID", example: "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee" })
  @IsUUID()
  categoryId!: string;

  @ApiProperty({ description: "ã‚°ãƒ«ãƒ¼ãƒ—å", example: "å±‹å†…ç®¡ç†" })
  @IsString()
  @MinLength(1)
  name!: string;

  @ApiPropertyOptional({ description: "ã‚°ãƒ«ãƒ¼ãƒ—ã®èª¬æ˜" })
  @IsOptional()
  @IsString()
  description?: string;

  @ApiPropertyOptional({ description: "è¡¨ç¤ºé †", example: 10 })
  @IsOptional()
  @IsNumber()
  displayOrder?: number;

  @ApiPropertyOptional({ description: "ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹", example: true })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;

  @ApiPropertyOptional({ description: "ã‚°ãƒ«ãƒ¼ãƒ—è¡¨ç¤ºç”¨ã®ã‚«ãƒ©ãƒ¼", example: "#3B82F6" })
  @IsOptional()
  @IsHexColor()
  color?: string;

  @ApiPropertyOptional({ description: "ã‚°ãƒ«ãƒ¼ãƒ—ã‚¿ã‚¤ãƒˆãƒ«ã®ãƒ†ã‚­ã‚¹ãƒˆã‚«ãƒ©ãƒ¼", example: "#111827" })
  @IsOptional()
  @IsHexColor()
  textColor?: string;
}
`````

## File: backend/src/tags/dto/create-tag.dto.ts
`````typescript
import { ApiProperty, ApiPropertyOptional } from "@nestjs/swagger";
import {
  IsBoolean,
  IsHexColor,
  IsNumber,
  IsObject,
  IsOptional,
  IsString,
  IsUUID,
  MinLength,
} from "class-validator";

export class CreateTagDto {
  @ApiProperty({ description: "ã‚¿ã‚°å", example: "Indoor" })
  @IsString()
  @MinLength(1)
  name: string;

  @ApiProperty({ description: "ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ID", example: "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee" })
  @IsUUID()
  groupId: string;

  @ApiPropertyOptional({ description: "ã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰", example: "#3B82F6" })
  @IsOptional()
  @IsHexColor()
  color?: string;

  @ApiPropertyOptional({ description: "ãƒ†ã‚­ã‚¹ãƒˆã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰", example: "#FFFFFF" })
  @IsOptional()
  @IsHexColor()
  textColor?: string;

  @ApiPropertyOptional({ description: "èª¬æ˜", example: "å®¤å†…é£¼ã„ã‚¿ã‚°" })
  @IsOptional()
  @IsString()
  description?: string;

  @ApiPropertyOptional({ description: "æ‰‹å‹•æ“ä½œã§åˆ©ç”¨å¯èƒ½ã‹", example: true })
  @IsOptional()
  @IsBoolean()
  allowsManual?: boolean;

  @ApiPropertyOptional({ description: "è‡ªå‹•ãƒ«ãƒ¼ãƒ«ã§åˆ©ç”¨å¯èƒ½ã‹", example: true })
  @IsOptional()
  @IsBoolean()
  allowsAutomation?: boolean;

  @ApiPropertyOptional({ description: "è¡¨ç¤ºé †", example: 10 })
  @IsOptional()
  @IsNumber()
  displayOrder?: number;

  @ApiPropertyOptional({ description: "ä»»æ„ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿", type: Object })
  @IsOptional()
  @IsObject()
  metadata?: Record<string, unknown>;

  @ApiPropertyOptional({ description: "ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹", example: true })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
}
`````

## File: backend/src/tags/dto/index.ts
`````typescript
export * from "./assign-tag.dto";
export * from "./create-tag.dto";
export * from "./update-tag.dto";
export * from "./create-tag-category.dto";
export * from "./update-tag-category.dto";
export * from "./reorder-tag-category.dto";
export * from "./reorder-tag.dto";
export * from "./create-tag-group.dto";
export * from "./update-tag-group.dto";
export * from "./reorder-tag-group.dto";
export * from "./create-tag-automation-rule.dto";
export * from "./update-tag-automation-rule.dto";
`````

## File: backend/src/tags/dto/reorder-tag-category.dto.ts
`````typescript
import { ApiProperty } from "@nestjs/swagger";
import { Type } from "class-transformer";
import { ArrayNotEmpty, IsArray, IsInt, IsUUID, ValidateNested } from "class-validator";

class TagCategoryOrderItemDto {
  @ApiProperty({ description: "ã‚«ãƒ†ã‚´ãƒªID", format: "uuid" })
  @IsUUID()
  id!: string;

  @ApiProperty({ description: "è¡¨ç¤ºé †", example: 10 })
  @IsInt()
  displayOrder!: number;
}

export class ReorderTagCategoriesDto {
  @ApiProperty({ type: [TagCategoryOrderItemDto] })
  @IsArray()
  @ArrayNotEmpty()
  @ValidateNested({ each: true })
  @Type(() => TagCategoryOrderItemDto)
  items!: TagCategoryOrderItemDto[];
}
`````

## File: backend/src/tags/dto/reorder-tag-group.dto.ts
`````typescript
import { ApiProperty } from "@nestjs/swagger";
import { Type } from "class-transformer";
import { ArrayNotEmpty, IsArray, IsInt, IsOptional, IsUUID, ValidateNested } from "class-validator";

class TagGroupOrderItemDto {
  @ApiProperty({ description: "ã‚°ãƒ«ãƒ¼ãƒ—ID", format: "uuid" })
  @IsUUID()
  id!: string;

  @ApiProperty({ description: "è¡¨ç¤ºé †", example: 10 })
  @IsInt()
  displayOrder!: number;

  @ApiProperty({ description: "ç§»å‹•å…ˆã‚«ãƒ†ã‚´ãƒªID", format: "uuid", required: false })
  @IsOptional()
  @IsUUID()
  categoryId?: string;
}

export class ReorderTagGroupDto {
  @ApiProperty({ type: [TagGroupOrderItemDto] })
  @IsArray()
  @ArrayNotEmpty()
  @ValidateNested({ each: true })
  @Type(() => TagGroupOrderItemDto)
  items!: TagGroupOrderItemDto[];
}
`````

## File: backend/src/tags/dto/reorder-tag.dto.ts
`````typescript
import { ApiProperty } from "@nestjs/swagger";
import { Type } from "class-transformer";
import { ArrayNotEmpty, IsArray, IsInt, IsOptional, IsUUID, ValidateNested } from "class-validator";

class TagOrderItemDto {
  @ApiProperty({ description: "ã‚¿ã‚°ID", format: "uuid" })
  @IsUUID()
  id!: string;

  @ApiProperty({ description: "è¡¨ç¤ºé †", example: 12 })
  @IsInt()
  displayOrder!: number;

  @ApiProperty({ description: "æ‰€å±ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ID", format: "uuid", required: false })
  @IsOptional()
  @IsUUID()
  groupId?: string;
}

export class ReorderTagsDto {
  @ApiProperty({ type: [TagOrderItemDto] })
  @IsArray()
  @ArrayNotEmpty()
  @ValidateNested({ each: true })
  @Type(() => TagOrderItemDto)
  items!: TagOrderItemDto[];
}
`````

## File: backend/src/tags/dto/update-tag-automation-rule.dto.ts
`````typescript
import { PartialType } from "@nestjs/swagger";

import { CreateTagAutomationRuleDto } from "./create-tag-automation-rule.dto";

export class UpdateTagAutomationRuleDto extends PartialType(CreateTagAutomationRuleDto) {}
`````

## File: backend/src/tags/dto/update-tag-category.dto.ts
`````typescript
import { PartialType } from "@nestjs/swagger";

import { CreateTagCategoryDto } from "./create-tag-category.dto";

export class UpdateTagCategoryDto extends PartialType(CreateTagCategoryDto) {}
`````

## File: backend/src/tags/dto/update-tag-group.dto.ts
`````typescript
import { PartialType } from "@nestjs/swagger";

import { CreateTagGroupDto } from "./create-tag-group.dto";

export class UpdateTagGroupDto extends PartialType(CreateTagGroupDto) {}
`````

## File: backend/src/tags/dto/update-tag.dto.ts
`````typescript
import { PartialType } from "@nestjs/swagger";

import { CreateTagDto } from "./create-tag.dto";

export class UpdateTagDto extends PartialType(CreateTagDto) {}
`````

## File: backend/src/tags/events/tag-automation.events.ts
`````typescript
import { TagAutomationEventType } from "@prisma/client";

/**
 * åŸºåº•ã‚¤ãƒ™ãƒ³ãƒˆãƒšã‚¤ãƒ­ãƒ¼ãƒ‰
 */
export interface BaseAutomationEvent {
  eventType: TagAutomationEventType;
  timestamp: Date;
  userId?: string;
  metadata?: Record<string, unknown>;
}

/**
 * äº¤é…äºˆå®šã‚¤ãƒ™ãƒ³ãƒˆ
 */
export interface BreedingPlannedEvent extends BaseAutomationEvent {
  eventType: 'BREEDING_PLANNED';
  breedingId: string;
  maleId: string;
  femaleId: string;
  plannedDate: Date;
}

/**
 * äº¤é…ç¢ºèªã‚¤ãƒ™ãƒ³ãƒˆ
 */
export interface BreedingConfirmedEvent extends BaseAutomationEvent {
  eventType: 'BREEDING_CONFIRMED';
  breedingId: string;
  maleId: string;
  femaleId: string;
  confirmedDate: Date;
}

/**
 * å¦Šå¨ ç¢ºèªã‚¤ãƒ™ãƒ³ãƒˆ
 */
export interface PregnancyConfirmedEvent extends BaseAutomationEvent {
  eventType: 'PREGNANCY_CONFIRMED';
  pregnancyCheckId: string;
  femaleId: string;
  maleId?: string;
  confirmedDate: Date;
}

/**
 * å­çŒ«ç™»éŒ²ã‚¤ãƒ™ãƒ³ãƒˆ
 */
export interface KittenRegisteredEvent extends BaseAutomationEvent {
  eventType: 'KITTEN_REGISTERED';
  kittenId: string;
  motherId?: string;
  fatherId?: string;
  birthDate?: Date;
}

/**
 * å¹´é½¢é–¾å€¤ã‚¤ãƒ™ãƒ³ãƒˆ
 */
export interface AgeThresholdEvent extends BaseAutomationEvent {
  eventType: 'AGE_THRESHOLD';
  catId: string;
  ageInMonths: number;
  thresholdMonths: number;
}

/**
 * ãƒšãƒ¼ã‚¸ãƒ»ã‚¢ã‚¯ã‚·ãƒ§ãƒ³é§†å‹•ã‚¤ãƒ™ãƒ³ãƒˆ
 * ä»»æ„ã®ãƒšãƒ¼ã‚¸ã§ä»»æ„ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãŒç™ºç”Ÿã—ãŸéš›ã®ã‚¤ãƒ™ãƒ³ãƒˆ
 */
export interface PageActionEvent extends BaseAutomationEvent {
  eventType: 'PAGE_ACTION';
  page: string; // 'cats', 'breeding', 'health', 'care', 'pedigree' ãªã©
  action: string; // 'create', 'update', 'delete', 'status_change' ãªã©
  targetId: string; // å¯¾è±¡ã®ãƒªã‚½ãƒ¼ã‚¹IDï¼ˆçŒ«IDã€äº¤é…è¨˜éŒ²IDãªã©ï¼‰
  targetType?: string; // 'cat', 'breeding', 'health_record' ãªã©
  additionalData?: Record<string, unknown>; // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å›ºæœ‰ã®è¿½åŠ ãƒ‡ãƒ¼ã‚¿
}

/**
 * ã‚«ã‚¹ã‚¿ãƒ ã‚¤ãƒ™ãƒ³ãƒˆ
 */
export interface CustomEvent extends BaseAutomationEvent {
  eventType: 'CUSTOM';
  customEventType: string;
  targetId: string;
  data: Record<string, unknown>;
}

/**
 * å…¨ã‚¤ãƒ™ãƒ³ãƒˆå‹ã®çµ±åˆ
 */
export type TagAutomationEvent =
  | BreedingPlannedEvent
  | BreedingConfirmedEvent
  | PregnancyConfirmedEvent
  | KittenRegisteredEvent
  | AgeThresholdEvent
  | PageActionEvent
  | CustomEvent;

/**
 * ã‚¤ãƒ™ãƒ³ãƒˆåã®å®šæ•°
 */
export const TAG_AUTOMATION_EVENTS = {
  BREEDING_PLANNED: 'tag.automation.breeding.planned',
  BREEDING_CONFIRMED: 'tag.automation.breeding.confirmed',
  PREGNANCY_CONFIRMED: 'tag.automation.pregnancy.confirmed',
  KITTEN_REGISTERED: 'tag.automation.kitten.registered',
  AGE_THRESHOLD: 'tag.automation.age.threshold',
  PAGE_ACTION: 'tag.automation.page.action',
  CUSTOM: 'tag.automation.custom',
} as const;
`````

## File: backend/src/tags/age-threshold-checker.service.ts
`````typescript
import { Injectable, Logger } from "@nestjs/common";
import { EventEmitter2 } from "@nestjs/event-emitter";
import { Cron, CronExpression } from "@nestjs/schedule";

import { PrismaService } from "../prisma/prisma.service";

import { TAG_AUTOMATION_EVENTS } from "./events/tag-automation.events";

/**
 * å¹´é½¢é–¾å€¤ãƒã‚§ãƒƒã‚¯ã‚µãƒ¼ãƒ“ã‚¹
 * 
 * å®šæœŸçš„ã«çŒ«ã®å¹´é½¢ã‚’ãƒã‚§ãƒƒã‚¯ã—ã€é–¾å€¤ã«é”ã—ãŸã‚‰ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«
 */
@Injectable()
export class AgeThresholdCheckerService {
  private readonly logger = new Logger(AgeThresholdCheckerService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly eventEmitter: EventEmitter2,
  ) {}

  /**
   * æ¯æ—¥åˆå‰0æ™‚ã«å¹´é½¢é–¾å€¤ã‚’ãƒã‚§ãƒƒã‚¯
   */
  @Cron(CronExpression.EVERY_DAY_AT_MIDNIGHT)
  async checkAgeThresholds() {
    this.logger.log("å¹´é½¢é–¾å€¤ãƒã‚§ãƒƒã‚¯é–‹å§‹");

    try {
      // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªå¹´é½¢é–¾å€¤ãƒ«ãƒ¼ãƒ«ã‚’å–å¾—
      const rules = await this.prisma.tagAutomationRule.findMany({
        where: {
          isActive: true,
          eventType: "AGE_THRESHOLD",
        },
      });

      if (rules.length === 0) {
        this.logger.log("ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªå¹´é½¢é–¾å€¤ãƒ«ãƒ¼ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“");
        return;
      }

      // ã™ã¹ã¦ã®åœ¨èˆçŒ«ã‚’å–å¾—
      const cats = await this.prisma.cat.findMany({
        where: {
          isInHouse: true,
        },
        select: {
          id: true,
          birthDate: true,
          motherId: true,
        },
      });

      this.logger.log(`${cats.length}åŒ¹ã®çŒ«ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™`);

      const today = new Date();
      let eventsEmitted = 0;

      for (const cat of cats) {
        const birthDate = new Date(cat.birthDate);
        const ageInDays = Math.floor((today.getTime() - birthDate.getTime()) / (1000 * 60 * 60 * 24));
        const ageInMonths = this.calculateAgeInMonths(birthDate, today);

        for (const rule of rules) {
          if (this.shouldTriggerRule(rule, ageInDays, ageInMonths, cat.motherId)) {
            this.logger.log(`çŒ«ID ${cat.id} ãŒãƒ«ãƒ¼ãƒ« "${rule.name}" ã®é–¾å€¤ã«åˆ°é”`);
            
            // ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«
            this.eventEmitter.emit(TAG_AUTOMATION_EVENTS.AGE_THRESHOLD, {
              eventType: "AGE_THRESHOLD" as const,
              catId: cat.id,
              ageInDays,
              ageInMonths,
              ruleId: rule.id,
            });

            eventsEmitted++;
          }
        }
      }

      this.logger.log(`å¹´é½¢é–¾å€¤ãƒã‚§ãƒƒã‚¯å®Œäº†: ${eventsEmitted}ä»¶ã®ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«`);
    } catch (error) {
      this.logger.error("å¹´é½¢é–¾å€¤ãƒã‚§ãƒƒã‚¯ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿ", error);
    }
  }

  /**
   * å¹´é½¢ã‚’æœˆå˜ä½ã§è¨ˆç®—
   */
  private calculateAgeInMonths(birthDate: Date, currentDate: Date): number {
    let months = (currentDate.getFullYear() - birthDate.getFullYear()) * 12;
    months += currentDate.getMonth() - birthDate.getMonth();
    
    // æ—¥ä»˜ã‚’è€ƒæ…®
    if (currentDate.getDate() < birthDate.getDate()) {
      months--;
    }
    
    return Math.max(0, months);
  }

  /**
   * ãƒ«ãƒ¼ãƒ«ãŒç™ºç«ã™ã¹ãã‹ã‚’åˆ¤å®š
   */
  private shouldTriggerRule(
    rule: { config: unknown },
    ageInDays: number,
    ageInMonths: number,
    motherId: string | null,
  ): boolean {
    const config = rule.config as Record<string, unknown> | null;
    if (!config) return false;

    // å­çŒ«ç”¨ã®æ—¥æ•°ãƒã‚§ãƒƒã‚¯ï¼ˆæ¯çŒ«IDãŒã‚ã‚‹å ´åˆï¼‰
    if (motherId && config.kitten) {
      const kittenConfig = config.kitten as Record<string, unknown>;
      const minDays = kittenConfig.minDays as number | undefined;
      const maxDays = kittenConfig.maxDays as number | undefined;

      if (minDays !== undefined && ageInDays < minDays) return false;
      if (maxDays !== undefined && ageInDays >= maxDays) return false;

      return true;
    }

    // æˆçŒ«ç”¨ã®æœˆæ•°ãƒã‚§ãƒƒã‚¯
    if (config.adult) {
      const adultConfig = config.adult as Record<string, unknown>;
      const minMonths = adultConfig.minMonths as number | undefined;
      const maxMonths = adultConfig.maxMonths as number | undefined;

      if (minMonths !== undefined && ageInMonths < minMonths) return false;
      if (maxMonths !== undefined && ageInMonths >= maxMonths) return false;

      return true;
    }

    return false;
  }

  /**
   * æ‰‹å‹•ã§å¹´é½¢ãƒã‚§ãƒƒã‚¯ã‚’å®Ÿè¡Œï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰
   */
  async manualCheck() {
    this.logger.log("æ‰‹å‹•å¹´é½¢é–¾å€¤ãƒã‚§ãƒƒã‚¯ã‚’å®Ÿè¡Œ");
    await this.checkAgeThresholds();
  }
}
`````

## File: backend/src/tags/tag-automation-execution.service.ts
`````typescript
import { Injectable, Logger } from "@nestjs/common";
import { EventEmitter2, OnEvent } from "@nestjs/event-emitter";
import type { Prisma } from "@prisma/client";
import {
  // TagAutomationEventType, // Unused - keeping import for future use
  // TagAutomationRunStatus, // Unused - keeping import for future use
  TagAssignmentAction,
  TagAssignmentSource,
} from "@prisma/client";

import { PrismaService } from "../prisma/prisma.service";

import {
  TAG_AUTOMATION_EVENTS,
  type TagAutomationEvent,
  type BreedingPlannedEvent,
  type BreedingConfirmedEvent,
  type PregnancyConfirmedEvent,
  type KittenRegisteredEvent,
  type AgeThresholdEvent,
  type PageActionEvent,
  type CustomEvent,
} from "./events/tag-automation.events";
import { TagAutomationService } from "./tag-automation.service";

interface RuleExecutionResult {
  ruleId: string;
  ruleName: string;
  success: boolean;
  tagsAssigned: number;
  error?: string;
}

@Injectable()
export class TagAutomationExecutionService {
  private readonly logger = new Logger(TagAutomationExecutionService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly automationService: TagAutomationService,
    private readonly eventEmitter: EventEmitter2,
  ) {}

  /**
   * ã‚¤ãƒ™ãƒ³ãƒˆã«åŸºã¥ã„ã¦ãƒ«ãƒ¼ãƒ«ã‚’å®Ÿè¡Œ
   */
  async executeRulesForEvent(event: TagAutomationEvent): Promise<RuleExecutionResult[]> {
    this.logger.log(`Executing rules for event: ${event.eventType}`);

    try {
      // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ«ãƒ¼ãƒ«ã‚’å–å¾—ï¼ˆã‚¤ãƒ™ãƒ³ãƒˆã‚¿ã‚¤ãƒ—ã§ãƒ•ã‚£ãƒ«ã‚¿ã€å„ªå…ˆåº¦é †ï¼‰
      const rulesResponse = await this.automationService.findRules({
        isActive: true,
        eventTypes: [event.eventType],
        includeRuns: false,
      });

      const rules = rulesResponse.data;

      if (rules.length === 0) {
        this.logger.debug(`No active rules found for event type: ${event.eventType}`);
        return [];
      }

      this.logger.log(`Found ${rules.length} active rules for event type: ${event.eventType}`);

      // å„ªå…ˆåº¦é †ã«ãƒ«ãƒ¼ãƒ«ã‚’å®Ÿè¡Œï¼ˆæ—¢ã«ã‚½ãƒ¼ãƒˆæ¸ˆã¿ï¼‰
      const results: RuleExecutionResult[] = [];

      for (const rule of rules) {
        try {
          const result = await this.executeRule(rule.id, event);
          results.push(result);
        } catch (error) {
          this.logger.error(
            `Failed to execute rule ${rule.id} (${rule.name}):`,
            error instanceof Error ? error.message : String(error),
          );
          results.push({
            ruleId: rule.id,
            ruleName: rule.name,
            success: false,
            tagsAssigned: 0,
            error: error instanceof Error ? error.message : String(error),
          });
        }
      }

      return results;
    } catch (error) {
      this.logger.error(
        `Error executing rules for event ${event.eventType}:`,
        error instanceof Error ? error.message : String(error),
      );
      throw error;
    }
  }

  /**
   * å€‹åˆ¥ãƒ«ãƒ¼ãƒ«ã®å®Ÿè¡Œ
   */
  private async executeRule(
    ruleId: string,
    event: TagAutomationEvent,
  ): Promise<RuleExecutionResult> {
    // ãƒ«ãƒ¼ãƒ«è©³ç´°ã‚’å–å¾—
    const ruleResponse = await this.automationService.findRuleById(ruleId);
    const rule = ruleResponse.data;

    this.logger.debug(`Executing rule: ${rule.name} (${ruleId})`);

    // å®Ÿè¡Œè¨˜éŒ²ã‚’ä½œæˆ
    const runResponse = await this.automationService.createRun(
      ruleId,
      event as unknown as Record<string, unknown>,
    );
    const run = runResponse.data;

    try {
      // å¯¾è±¡çŒ«ã‚’å–å¾—
      const targetCatIds = await this.getTargetCats(rule, event);

      if (targetCatIds.length === 0) {
        this.logger.debug(`No target cats found for rule: ${rule.name}`);
        await this.automationService.markRunCompleted(run.id);
        return {
          ruleId: rule.id,
          ruleName: rule.name,
          success: true,
          tagsAssigned: 0,
        };
      }

      // ä»˜ä¸ã™ã‚‹ã‚¿ã‚°ã‚’å–å¾—
      const tagIds = await this.getTagsToAssign(rule);

      if (tagIds.length === 0) {
        this.logger.warn(`No tags configured for rule: ${rule.name}`);
        await this.automationService.markRunCompleted(run.id);
        return {
          ruleId: rule.id,
          ruleName: rule.name,
          success: true,
          tagsAssigned: 0,
        };
      }

      // ã‚¿ã‚°ã‚’ä»˜ä¸
      let assignedCount = 0;
      for (const catId of targetCatIds) {
        for (const tagId of tagIds) {
          try {
            await this.assignTag(catId, tagId, rule.id, run.id);
            assignedCount++;
          } catch (error) {
            this.logger.warn(
              `Failed to assign tag ${tagId} to cat ${catId}:`,
              error instanceof Error ? error.message : String(error),
            );
          }
        }
      }

      // å®Ÿè¡Œå®Œäº†ã‚’è¨˜éŒ²
      await this.automationService.markRunCompleted(run.id);

      this.logger.log(`Rule ${rule.name} executed successfully. Assigned ${assignedCount} tags.`);

      return {
        ruleId: rule.id,
        ruleName: rule.name,
        success: true,
        tagsAssigned: assignedCount,
      };
    } catch (error) {
      // å®Ÿè¡Œå¤±æ•—ã‚’è¨˜éŒ²
      await this.automationService.markRunFailed(
        run.id,
        error instanceof Error ? error.message : String(error),
      );

      throw error;
    }
  }

  /**
   * å¯¾è±¡ã¨ãªã‚‹çŒ«ã®IDã‚’å–å¾—
   */
  private async getTargetCats(
    rule: { config?: Prisma.JsonValue },
    event: TagAutomationEvent,
  ): Promise<string[]> {
    const catIds: string[] = [];

    // ã‚¤ãƒ™ãƒ³ãƒˆã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦å¯¾è±¡çŒ«ã‚’ç‰¹å®š
    switch (event.eventType) {
      case 'BREEDING_PLANNED':
      case 'BREEDING_CONFIRMED':
        catIds.push((event as BreedingPlannedEvent).maleId, (event as BreedingPlannedEvent).femaleId);
        break;

      case 'PREGNANCY_CONFIRMED':
        catIds.push((event as PregnancyConfirmedEvent).femaleId);
        if ((event as PregnancyConfirmedEvent).maleId) {
          catIds.push((event as PregnancyConfirmedEvent).maleId!);
        }
        break;

      case 'KITTEN_REGISTERED':
        catIds.push((event as KittenRegisteredEvent).kittenId);
        if ((event as KittenRegisteredEvent).motherId) {
          catIds.push((event as KittenRegisteredEvent).motherId!);
        }
        if ((event as KittenRegisteredEvent).fatherId) {
          catIds.push((event as KittenRegisteredEvent).fatherId!);
        }
        break;

      case 'AGE_THRESHOLD':
        catIds.push((event as AgeThresholdEvent).catId);
        break;

      case 'PAGE_ACTION': {
        // PAGE_ACTIONã‚¤ãƒ™ãƒ³ãƒˆã®å‡¦ç†
        const pageEvent = event as PageActionEvent;
        
        // configã‹ã‚‰å¯¾è±¡çŒ«ã®é¸æŠæ–¹æ³•ã‚’å–å¾—
        const config = rule.config as Record<string, unknown> | null;
        const targetSelection = config?.['targetSelection'] as string | undefined;
        
        if (targetSelection === 'event_target' && pageEvent.targetType === 'cat') {
          // ã‚¤ãƒ™ãƒ³ãƒˆã§æŒ‡å®šã•ã‚ŒãŸçŒ«ã‚’å¯¾è±¡ã¨ã™ã‚‹
          catIds.push(pageEvent.targetId);
        } else if (targetSelection === 'specific_cats' && config?.['specificCatIds']) {
          // ç‰¹å®šã®çŒ«ãƒªã‚¹ãƒˆã‚’å¯¾è±¡ã¨ã™ã‚‹
          const specificCats = config['specificCatIds'] as string[];
          catIds.push(...specificCats);
        } else if (targetSelection === 'all_cats') {
          // å…¨çŒ«ã‚’å¯¾è±¡ã¨ã™ã‚‹ï¼ˆã‚¹ã‚³ãƒ¼ãƒ—ã‚„ãƒ•ã‚£ãƒ«ã‚¿ã‚’é©ç”¨å¯èƒ½ï¼‰
          const filters = config?.['filters'] as Record<string, unknown> | undefined;
          const allCats = await this.getAllCatsMatchingFilters(filters);
          catIds.push(...allCats.map(cat => cat.id));
        } else {
          // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: ã‚¤ãƒ™ãƒ³ãƒˆã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒçŒ«ã®å ´åˆã¯ãã‚Œã‚’ä½¿ç”¨
          if (pageEvent.targetType === 'cat') {
            catIds.push(pageEvent.targetId);
          }
        }
        break;
      }

      case 'CUSTOM':
        catIds.push((event as CustomEvent).targetId);
        break;
    }

    // configã«åŸºã¥ã„ã¦å¯¾è±¡ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼ˆå°†æ¥çš„ãªæ‹¡å¼µç”¨ï¼‰
    if (rule.config && typeof rule.config === 'object') {
      // ä¾‹: { "targetRole": "mother_only" } ãªã©ã®æ¡ä»¶ã§ãƒ•ã‚£ãƒ«ã‚¿
      // ä»Šã¯ã‚·ãƒ³ãƒ—ãƒ«ã«ã™ã¹ã¦ã®å¯¾è±¡ã‚’è¿”ã™
    }

    return [...new Set(catIds)]; // é‡è¤‡ã‚’å‰Šé™¤
  }

  /**
   * ä»˜ä¸ã™ã‚‹ã‚¿ã‚°ã®IDã‚’å–å¾—
   */
  private async getTagsToAssign(rule: {
    config?: Prisma.JsonValue;
  }): Promise<string[]> {
    // configã‹ã‚‰ã‚¿ã‚°IDã‚’å–å¾—
    if (!rule.config || typeof rule.config !== 'object') {
      return [];
    }

    const config = rule.config as { tagIds?: string[] };
    return config.tagIds ?? [];
  }

  /**
   * ã‚¿ã‚°ã‚’çŒ«ã«ä»˜ä¸
   */
  private async assignTag(
    catId: string,
    tagId: string,
    ruleId: string,
    automationRunId: string,
  ): Promise<void> {
    // æ—¢ã«ä»˜ä¸ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    const existing = await this.prisma.catTag.findUnique({
      where: {
        catId_tagId: {
          catId,
          tagId,
        },
      },
    });

    if (existing) {
      this.logger.debug(`Tag ${tagId} already assigned to cat ${catId}`);
      return;
    }

    // ã‚¿ã‚°ã‚’ä»˜ä¸
    await this.prisma.catTag.create({
      data: {
        catId,
        tagId,
      },
    });

    // å±¥æ­´ã‚’è¨˜éŒ²
    await this.automationService.recordAssignment({
      catId,
      tagId,
      action: TagAssignmentAction.ASSIGNED,
      source: TagAssignmentSource.AUTOMATION,
      ruleId,
      automationRunId,
      applyTagMutation: false, // æ—¢ã«ä»˜ä¸æ¸ˆã¿
    });

    this.logger.debug(`Assigned tag ${tagId} to cat ${catId} via rule ${ruleId}`);
  }

  /**
   * ãƒ•ã‚£ãƒ«ã‚¿ã«ä¸€è‡´ã™ã‚‹å…¨çŒ«ã‚’å–å¾—
   */
  private async getAllCatsMatchingFilters(
    filters?: Record<string, unknown>,
  ): Promise<Array<{ id: string }>> {
    const where: Prisma.CatWhereInput = {};

    if (filters) {
      // ãƒ•ã‚£ãƒ«ã‚¿æ¡ä»¶ã‚’é©ç”¨
      if (filters['breedId']) {
        where.breedId = filters['breedId'] as string;
      }
      if (filters['gender']) {
        where.gender = filters['gender'] as string;
      }
      // ä»–ã®ãƒ•ã‚£ãƒ«ã‚¿æ¡ä»¶ã‚‚å¿…è¦ã«å¿œã˜ã¦è¿½åŠ 
    }

    const cats = await this.prisma.cat.findMany({
      where,
      select: { id: true },
    });

    return cats;
  }

  /**
   * ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼: äº¤é…äºˆå®š
   */
  @OnEvent(TAG_AUTOMATION_EVENTS.BREEDING_PLANNED)
  async handleBreedingPlanned(event: BreedingPlannedEvent) {
    this.logger.log(`Handling BREEDING_PLANNED event: ${event.breedingId}`);
    await this.executeRulesForEvent(event);
  }

  /**
   * ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼: äº¤é…ç¢ºèª
   */
  @OnEvent(TAG_AUTOMATION_EVENTS.BREEDING_CONFIRMED)
  async handleBreedingConfirmed(event: BreedingConfirmedEvent) {
    this.logger.log(`Handling BREEDING_CONFIRMED event: ${event.breedingId}`);
    await this.executeRulesForEvent(event);
  }

  /**
   * ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼: å¦Šå¨ ç¢ºèª
   */
  @OnEvent(TAG_AUTOMATION_EVENTS.PREGNANCY_CONFIRMED)
  async handlePregnancyConfirmed(event: PregnancyConfirmedEvent) {
    this.logger.log(`Handling PREGNANCY_CONFIRMED event: ${event.pregnancyCheckId}`);
    await this.executeRulesForEvent(event);
  }

  /**
   * ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼: å­çŒ«ç™»éŒ²
   */
  @OnEvent(TAG_AUTOMATION_EVENTS.KITTEN_REGISTERED)
  async handleKittenRegistered(event: KittenRegisteredEvent) {
    this.logger.log(`Handling KITTEN_REGISTERED event: ${event.kittenId}`);
    await this.executeRulesForEvent(event);
  }

  /**
   * ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼: å¹´é½¢é–¾å€¤
   */
  @OnEvent(TAG_AUTOMATION_EVENTS.AGE_THRESHOLD)
  async handleAgeThreshold(event: AgeThresholdEvent) {
    this.logger.log(`Handling AGE_THRESHOLD event for cat: ${event.catId}`);
    await this.executeRulesForEvent(event);
  }

  /**
   * ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼: ãƒšãƒ¼ã‚¸ãƒ»ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
   */
  @OnEvent(TAG_AUTOMATION_EVENTS.PAGE_ACTION)
  async handlePageAction(event: PageActionEvent) {
    this.logger.log(`Handling PAGE_ACTION event: ${event.page}.${event.action}`);
    await this.executeRulesForEvent(event);
  }

  /**
   * ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼: ã‚«ã‚¹ã‚¿ãƒ 
   */
  @OnEvent(TAG_AUTOMATION_EVENTS.CUSTOM)
  async handleCustomEvent(event: CustomEvent) {
    this.logger.log(`Handling CUSTOM event: ${event.customEventType}`);
    await this.executeRulesForEvent(event);
  }
}
`````

## File: backend/src/tags/tag-automation.controller.ts
`````typescript
import {
  Body,
  Controller,
  Delete,
  Get,
  HttpCode,
  HttpStatus,
  Param,
  Patch,
  Post,
  Query,
  UseGuards,
} from "@nestjs/common";
import { EventEmitter2 } from "@nestjs/event-emitter";
import {
  ApiBearerAuth,
  ApiOperation,
  ApiParam,
  ApiQuery,
  ApiResponse,
  ApiTags,
} from "@nestjs/swagger";
import { TagAutomationEventType, TagAutomationRunStatus, TagAutomationTriggerType } from "@prisma/client";

import { JwtAuthGuard } from "../auth/jwt-auth.guard";

import { CreateTagAutomationRuleDto, UpdateTagAutomationRuleDto } from "./dto";
import { TAG_AUTOMATION_EVENTS } from "./events/tag-automation.events";
import { TagAutomationService } from "./tag-automation.service";

@ApiTags("Tag Automation")
@Controller("tags/automation")
@UseGuards(JwtAuthGuard)
@ApiBearerAuth()
export class TagAutomationController {
  constructor(
    private readonly tagAutomationService: TagAutomationService,
    private readonly eventEmitter: EventEmitter2,
  ) {}

  @Get("rules")
  @ApiOperation({ summary: "è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ä¸€è¦§ã®å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK, description: "ãƒ«ãƒ¼ãƒ«ä¸€è¦§ã‚’è¿”å´" })
  @ApiQuery({
    name: "active",
    required: false,
    description: "ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ«ãƒ¼ãƒ«ã®ã¿å–å¾—",
    type: Boolean,
  })
  @ApiQuery({
    name: "scope",
    required: false,
    description: "ã‚¹ã‚³ãƒ¼ãƒ—ã§ãƒ•ã‚£ãƒ«ã‚¿",
    type: String,
  })
  @ApiQuery({
    name: "triggerType",
    required: false,
    description: "ãƒˆãƒªã‚¬ãƒ¼ã‚¿ã‚¤ãƒ—ã§ãƒ•ã‚£ãƒ«ã‚¿",
    type: String,
  })
  @ApiQuery({
    name: "eventType",
    required: false,
    description: "ã‚¤ãƒ™ãƒ³ãƒˆã‚¿ã‚¤ãƒ—ã§ãƒ•ã‚£ãƒ«ã‚¿",
    type: String,
  })
  async findRules(
    @Query("active") active?: string,
    @Query("scope") scope?: string,
    @Query("triggerType") triggerType?: string,
    @Query("eventType") eventType?: string,
  ) {
    const activeFlag = active === "true" ? true : active === "false" ? false : undefined;

    return this.tagAutomationService.findRules({
      isActive: activeFlag,
      scope: scope || undefined,
      triggerTypes: triggerType ? [triggerType as TagAutomationTriggerType] : undefined,
      eventTypes: eventType ? [eventType as TagAutomationEventType] : undefined,
    });
  }

  @Get("rules/:id")
  @ApiOperation({ summary: "è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«è©³ç´°ã®å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK, description: "ãƒ«ãƒ¼ãƒ«è©³ç´°ã‚’è¿”å´" })
  @ApiResponse({ status: HttpStatus.NOT_FOUND, description: "ãƒ«ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“" })
  @ApiParam({ name: "id", description: "ãƒ«ãƒ¼ãƒ«ID" })
  @ApiQuery({
    name: "includeRuns",
    required: false,
    description: "å®Ÿè¡Œå±¥æ­´ã‚’å«ã‚ã‚‹",
    type: Boolean,
  })
  @ApiQuery({
    name: "includeHistoryCount",
    required: false,
    description: "ä»˜ä¸å±¥æ­´ä»¶æ•°ã‚’å«ã‚ã‚‹",
    type: Boolean,
  })
  async findRuleById(
    @Param("id") id: string,
    @Query("includeRuns") includeRuns?: string,
    @Query("includeHistoryCount") includeHistoryCount?: string,
  ) {
    const includeRunsFlag = includeRuns === "true";
    const includeHistoryCountFlag = includeHistoryCount === "true";

    return this.tagAutomationService.findRuleById(id, {
      includeRuns: includeRunsFlag,
      includeHistoryCount: includeHistoryCountFlag,
    });
  }

  @Post("rules")
  @ApiOperation({ summary: "è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ã®ä½œæˆ" })
  @ApiResponse({ status: HttpStatus.CREATED, description: "ãƒ«ãƒ¼ãƒ«ã‚’ä½œæˆã—ã¾ã—ãŸ" })
  @ApiResponse({ status: HttpStatus.BAD_REQUEST, description: "å…¥åŠ›ã‚¨ãƒ©ãƒ¼" })
  async createRule(@Body() dto: CreateTagAutomationRuleDto) {
    return this.tagAutomationService.createRule(dto);
  }

  @Patch("rules/:id")
  @ApiOperation({ summary: "è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ã®æ›´æ–°" })
  @ApiResponse({ status: HttpStatus.OK, description: "ãƒ«ãƒ¼ãƒ«ã‚’æ›´æ–°ã—ã¾ã—ãŸ" })
  @ApiResponse({ status: HttpStatus.NOT_FOUND, description: "ãƒ«ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“" })
  @ApiParam({ name: "id", description: "ãƒ«ãƒ¼ãƒ«ID" })
  async updateRule(@Param("id") id: string, @Body() dto: UpdateTagAutomationRuleDto) {
    return this.tagAutomationService.updateRule(id, dto);
  }

  @Delete("rules/:id")
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({ summary: "è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ã®å‰Šé™¤" })
  @ApiResponse({ status: HttpStatus.NO_CONTENT, description: "ãƒ«ãƒ¼ãƒ«ã‚’å‰Šé™¤ã—ã¾ã—ãŸ" })
  @ApiResponse({ status: HttpStatus.NOT_FOUND, description: "ãƒ«ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“" })
  @ApiParam({ name: "id", description: "ãƒ«ãƒ¼ãƒ«ID" })
  async deleteRule(@Param("id") id: string) {
    await this.tagAutomationService.deleteRule(id);
  }

  @Get("runs")
  @ApiOperation({ summary: "ãƒ«ãƒ¼ãƒ«å®Ÿè¡Œå±¥æ­´ã®å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK, description: "å®Ÿè¡Œå±¥æ­´ä¸€è¦§ã‚’è¿”å´" })
  @ApiQuery({
    name: "ruleId",
    required: false,
    description: "ãƒ«ãƒ¼ãƒ«IDã§ãƒ•ã‚£ãƒ«ã‚¿",
    type: String,
  })
  @ApiQuery({
    name: "status",
    required: false,
    description: "ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã§ãƒ•ã‚£ãƒ«ã‚¿ (PENDING, COMPLETED, FAILED)",
    type: String,
  })
  @ApiQuery({
    name: "limit",
    required: false,
    description: "å–å¾—ä»¶æ•°ã®ä¸Šé™",
    type: Number,
  })
  async findRuns(
    @Query("ruleId") ruleId?: string,
    @Query("status") status?: string,
    @Query("limit") limit?: string,
  ) {
    const limitNum = limit ? parseInt(limit, 10) : undefined;
    const statuses = status ? [status as TagAutomationRunStatus] : undefined;

    return this.tagAutomationService.findRuns({
      ruleId: ruleId || undefined,
      statuses,
      take: limitNum,
    });
  }

    @Post("rules/:id/execute")
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: "ãƒ«ãƒ¼ãƒ«ã‚’æ‰‹å‹•å®Ÿè¡Œï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰" })
  @ApiParam({ name: "id", description: "ãƒ«ãƒ¼ãƒ«ID" })
  @ApiResponse({
    status: HttpStatus.OK,
    description: "ãƒ«ãƒ¼ãƒ«å®Ÿè¡ŒæˆåŠŸ",
  })
  async executeRule(@Param("id") id: string, @Body() testPayload?: Record<string, unknown>) {
    // ãƒ«ãƒ¼ãƒ«ã‚’å–å¾—
    const ruleResponse = await this.tagAutomationService.findRuleById(id);
    const rule = ruleResponse.data;

    // ãƒ†ã‚¹ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºè¡Œ
    let eventName: string;
    let eventPayload: Record<string, unknown>;

    switch (rule.eventType) {
      case "BREEDING_PLANNED":
        eventName = TAG_AUTOMATION_EVENTS.BREEDING_PLANNED;
        eventPayload = {
          eventType: "BREEDING_PLANNED" as const,
          breedingId: testPayload?.breedingId || "test-breeding-id",
          maleId: testPayload?.maleId || "test-male-id",
          femaleId: testPayload?.femaleId || "test-female-id",
        };
        break;

      case "BREEDING_CONFIRMED":
        eventName = TAG_AUTOMATION_EVENTS.BREEDING_CONFIRMED;
        eventPayload = {
          eventType: "BREEDING_CONFIRMED" as const,
          breedingId: testPayload?.breedingId || "test-breeding-id",
          maleId: testPayload?.maleId || "test-male-id",
          femaleId: testPayload?.femaleId || "test-female-id",
        };
        break;

      case "PREGNANCY_CONFIRMED":
        eventName = TAG_AUTOMATION_EVENTS.PREGNANCY_CONFIRMED;
        eventPayload = {
          eventType: "PREGNANCY_CONFIRMED" as const,
          pregnancyCheckId: testPayload?.pregnancyCheckId || "test-pregnancy-id",
          femaleId: testPayload?.femaleId || "test-female-id",
          maleId: testPayload?.maleId as string | undefined,
        };
        break;

      case "KITTEN_REGISTERED":
        eventName = TAG_AUTOMATION_EVENTS.KITTEN_REGISTERED;
        eventPayload = {
          eventType: "KITTEN_REGISTERED" as const,
          kittenId: testPayload?.kittenId || "test-kitten-id",
          motherId: testPayload?.motherId as string | undefined,
          fatherId: testPayload?.fatherId as string | undefined,
        };
        break;

      case "AGE_THRESHOLD":
        eventName = TAG_AUTOMATION_EVENTS.AGE_THRESHOLD;
        eventPayload = {
          eventType: "AGE_THRESHOLD" as const,
          catId: testPayload?.catId || "test-cat-id",
          ageInMonths: testPayload?.ageInMonths || 12,
        };
        break;

      case "PAGE_ACTION":
        eventName = TAG_AUTOMATION_EVENTS.PAGE_ACTION;
        eventPayload = {
          eventType: "PAGE_ACTION" as const,
          page: testPayload?.page || (typeof rule.config === 'object' && rule.config !== null && 'page' in rule.config ? rule.config['page'] as string : "cats"),
          action: testPayload?.action || (typeof rule.config === 'object' && rule.config !== null && 'action' in rule.config ? rule.config['action'] as string : "create"),
          targetId: testPayload?.targetId || "test-target-id",
          targetType: testPayload?.targetType as string | undefined,
          additionalData: testPayload?.additionalData as Record<string, unknown> | undefined,
        };
        break;

      case "CUSTOM":
        eventName = TAG_AUTOMATION_EVENTS.CUSTOM;
        eventPayload = {
          eventType: "CUSTOM" as const,
          customEventType: testPayload?.customEventType || "test",
          targetId: testPayload?.targetId || "test-target-id",
          metadata: testPayload?.metadata as Record<string, unknown> | undefined,
        };
        break;

      default:
        return {
          success: false,
          message: `Unsupported event type: ${rule.eventType}`,
        };
    }

    // ã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œ
    this.eventEmitter.emit(eventName, eventPayload);

    return {
      success: true,
      message: `Test event emitted for rule: ${rule.name}`,
      eventType: rule.eventType,
      eventName,
      payload: eventPayload,
    };
  }
}
`````

## File: backend/src/tags/tag-automation.service.spec.ts
`````typescript
import { BadRequestException } from "@nestjs/common";
import {
  Prisma,
  TagAssignmentAction,
  TagAssignmentSource,
  TagAutomationEventType,
  TagAutomationTriggerType,
} from "@prisma/client";

import { PrismaService } from "../prisma/prisma.service";

import { TagAutomationService } from "./tag-automation.service";

describe("TagAutomationService", () => {
  let service: TagAutomationService;
  let prismaMock: {
    tagAutomationRule: {
      create: jest.Mock;
      update: jest.Mock;
      delete: jest.Mock;
      findMany: jest.Mock;
      findUnique: jest.Mock;
    };
    tagAutomationRun: {
      create: jest.Mock;
      update: jest.Mock;
      findMany: jest.Mock;
    };
    tagAssignmentHistory: {
      create: jest.Mock;
      findMany: jest.Mock;
    };
    catTag: {
      upsert: jest.Mock;
      deleteMany: jest.Mock;
    };
    $transaction: jest.Mock;
  };

  beforeEach(() => {
    prismaMock = {
      tagAutomationRule: {
        create: jest.fn(),
        update: jest.fn(),
        delete: jest.fn(),
        findMany: jest.fn(),
        findUnique: jest.fn(),
      },
      tagAutomationRun: {
        create: jest.fn(),
        update: jest.fn(),
        findMany: jest.fn(),
      },
      tagAssignmentHistory: {
        create: jest.fn(),
        findMany: jest.fn(),
      },
      catTag: {
        upsert: jest.fn(),
        deleteMany: jest.fn(),
      },
      $transaction: jest.fn((operations: Array<Promise<unknown>>) => Promise.all(operations)),
    };

    service = new TagAutomationService(prismaMock as unknown as PrismaService);
  });

  describe("createRule", () => {
    it("normalizes key when not provided", async () => {
      const rule = {
        id: "rule-1",
        key: "auto-tag-test-rule",
        name: "Auto Tag Test Rule",
        description: null,
        triggerType: TagAutomationTriggerType.EVENT,
        eventType: TagAutomationEventType.CUSTOM,
        scope: null,
        isActive: true,
        priority: 0,
        config: Prisma.JsonNull,
        createdAt: new Date(),
        updatedAt: new Date(),
      };
      prismaMock.tagAutomationRule.create.mockResolvedValue(rule);

      const result = await service.createRule({
        name: "Auto Tag Test Rule",
        triggerType: TagAutomationTriggerType.EVENT,
        eventType: TagAutomationEventType.CUSTOM,
      });

      expect(prismaMock.tagAutomationRule.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          key: expect.stringMatching(/^custom-\d+$/), // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ãƒ™ãƒ¼ã‚¹ã®ã‚­ãƒ¼ç”Ÿæˆã«å¯¾å¿œ
          name: "Auto Tag Test Rule",
          priority: 0,
        }),
      });
      expect(result.data).toEqual(rule);
    });

    it("throws BadRequestException on unique key violation", async () => {
      const error = new Prisma.PrismaClientKnownRequestError("Unique violation", {
        code: "P2002",
        clientVersion: "6.16.2",
      });
      prismaMock.tagAutomationRule.create.mockRejectedValue(error);

      await expect(
        service.createRule({
          key: "duplicate",
          name: "Duplicate",
          triggerType: TagAutomationTriggerType.EVENT,
          eventType: TagAutomationEventType.CUSTOM,
        }),
      ).rejects.toBeInstanceOf(BadRequestException);
    });
  });

  describe("recordAssignment", () => {
    it("records history and upserts cat tag when assigning", async () => {
      const historyRecord = {
        id: "history-1",
        catId: "cat-1",
        tagId: "tag-1",
        ruleId: null,
        automationRunId: null,
        action: TagAssignmentAction.ASSIGNED,
        source: TagAssignmentSource.AUTOMATION,
        reason: null,
        metadata: Prisma.JsonNull,
        createdAt: new Date(),
      };
      prismaMock.catTag.upsert.mockResolvedValue({});
      prismaMock.tagAssignmentHistory.create.mockReturnValue(Promise.resolve(historyRecord));

      const result = await service.recordAssignment({
        catId: "cat-1",
        tagId: "tag-1",
        action: TagAssignmentAction.ASSIGNED,
        applyTagMutation: true,
      });

      expect(prismaMock.catTag.upsert).toHaveBeenCalledWith({
        where: { catId_tagId: { catId: "cat-1", tagId: "tag-1" } },
        update: {},
        create: { catId: "cat-1", tagId: "tag-1" },
      });
      expect(prismaMock.$transaction).toHaveBeenCalled();
      expect(result.data).toEqual(historyRecord);
    });
  });
});
`````

## File: backend/src/tags/tag-automation.service.ts
`````typescript
import { BadRequestException, Injectable, NotFoundException } from "@nestjs/common";
import {
  Prisma,
  TagAutomationEventType,
  TagAutomationRunStatus,
  TagAutomationTriggerType,
  TagAssignmentAction,
  TagAssignmentSource,
} from "@prisma/client";

import { PrismaService } from "../prisma/prisma.service";

import {
  CreateTagAutomationRuleDto,
  UpdateTagAutomationRuleDto,
} from "./dto";

export interface FindAutomationRuleOptions {
  isActive?: boolean;
  triggerTypes?: TagAutomationTriggerType[];
  eventTypes?: TagAutomationEventType[];
  scope?: string | null;
  includeRuns?: boolean;
  runsLimit?: number;
  includeHistoryCount?: boolean;
}

export interface FindAutomationRunOptions {
  ruleId?: string;
  statuses?: TagAutomationRunStatus[];
  take?: number;
}

// Configå‹å®šç¾© - å‹å®‰å…¨æ€§ã®ãŸã‚
interface BaseConfig {
  actionType?: 'ADD' | 'REMOVE';
}

interface PageActionConfig extends BaseConfig {
  page?: string;
  action?: string;
}

interface AgeThresholdConfig extends BaseConfig {
  ageType?: 'months' | 'days';
  threshold?: number;
}

// TAG_ASSIGNEDã‚¤ãƒ™ãƒ³ãƒˆç”¨ã®è¨­å®šï¼ˆBaseConfig ã®ã¿ä½¿ç”¨ï¼‰
type TagAssignedConfig = BaseConfig;

type AutomationConfig = PageActionConfig | AgeThresholdConfig | TagAssignedConfig | Record<string, unknown>;

export interface RecordAssignmentOptions {
  catId: string;
  tagId: string;
  action: TagAssignmentAction;
  source?: TagAssignmentSource;
  ruleId?: string;
  automationRunId?: string;
  reason?: string | null;
  metadata?: Record<string, unknown> | null;
  applyTagMutation?: boolean;
}

@Injectable()
export class TagAutomationService {
  constructor(private readonly prisma: PrismaService) {}

  async findRules(options: FindAutomationRuleOptions = {}) {
    const {
      isActive,
      triggerTypes,
      eventTypes,
      scope,
      includeRuns = false,
      runsLimit,
      includeHistoryCount = false,
    } = options;

    const where: Prisma.TagAutomationRuleWhereInput = {
      ...(isActive !== undefined ? { isActive } : {}),
      ...(triggerTypes && triggerTypes.length ? { triggerType: { in: triggerTypes } } : {}),
      ...(eventTypes && eventTypes.length ? { eventType: { in: eventTypes } } : {}),
      ...(scope === null
        ? { scope: null }
        : scope
          ? { OR: [{ scope }, { scope: null }] }
          : {}),
    };

    const include: Prisma.TagAutomationRuleInclude = {};

    if (includeRuns) {
      include.runs = {
        orderBy: { createdAt: "desc" },
        ...(runsLimit ? { take: runsLimit } : {}),
      };
    }

    if (includeHistoryCount) {
      include._count = { select: { history: true } };
    }

    const data = await this.prisma.tagAutomationRule.findMany({
      where,
      orderBy: [
        { priority: "desc" },
        { createdAt: "asc" },
      ],
      include: Object.keys(include).length ? include : undefined,
    });

    return { success: true, data };
  }

  async findRuleById(id: string, options: Omit<FindAutomationRuleOptions, "isActive"> = {}) {
    const { includeRuns = false, runsLimit, includeHistoryCount = false } = options;

    const include: Prisma.TagAutomationRuleInclude = {};

    if (includeRuns) {
      include.runs = {
        orderBy: { createdAt: "desc" },
        ...(runsLimit ? { take: runsLimit } : {}),
      };
    }

    if (includeHistoryCount) {
      include._count = { select: { history: true } };
    }

    const rule = await this.prisma.tagAutomationRule.findUnique({
      where: { id },
      include: Object.keys(include).length ? include : undefined,
    });

    if (!rule) {
      throw new NotFoundException("ã‚¿ã‚°è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
    }

    return { success: true, data: rule };
  }

  async createRule(dto: CreateTagAutomationRuleDto) {
    // ã‚­ãƒ¼ã®è‡ªå‹•ç”Ÿæˆï¼ˆæœªæŒ‡å®šã®å ´åˆï¼‰
    const timestamp = Date.now();
    const eventTypeStr = dto.eventType || 'unknown';
    const key = dto.key 
      ? this.normalizeKey(dto.key) 
      : this.normalizeKey(`${eventTypeStr}-${timestamp}`);

    // åå‰ã®è‡ªå‹•ç”Ÿæˆï¼ˆæœªæŒ‡å®šã®å ´åˆï¼‰
    const name = dto.name || this.generateRuleName(dto);

    try {
      const rule = await this.prisma.tagAutomationRule.create({
        data: {
          key,
          name,
          description: dto.description ?? undefined,
          triggerType: dto.triggerType,
          eventType: dto.eventType ?? 'PAGE_ACTION', // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯PAGE_ACTION
          scope: dto.scope ?? undefined,
          isActive: dto.isActive ?? true,
          priority: 0, // å„ªå…ˆåº¦ã¯å›ºå®šå€¤ï¼ˆè¤‡æ•°ãƒãƒƒãƒæ™‚ã¯å…¨ã¦é©ç”¨ï¼‰
          ...(dto.config !== undefined
            ? { config: this.toJson(dto.config) ?? Prisma.JsonNull }
            : {}),
        },
      });

      return { success: true, data: rule };
    } catch (error) {
      if (this.isUniqueConstraintViolation(error)) {
        throw new BadRequestException("åŒã˜ã‚­ãƒ¼ã‚’æŒã¤è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ãŒæ—¢ã«å­˜åœ¨ã—ã¾ã™");
      }
      throw error;
    }
  }

  /**
   * ãƒ«ãƒ¼ãƒ«åã®è‡ªå‹•ç”Ÿæˆ
   */
  private generateRuleName(dto: CreateTagAutomationRuleDto): string {
    const config = (dto.config ?? {}) as AutomationConfig;
    
    // å‹ã‚¬ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¦å®‰å…¨ã«ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã«ã‚¢ã‚¯ã‚»ã‚¹
    const isPageActionConfig = (c: AutomationConfig): c is PageActionConfig => {
      return 'page' in c || 'action' in c;
    };
    
    const isAgeThresholdConfig = (c: AutomationConfig): c is AgeThresholdConfig => {
      return 'ageType' in c || 'threshold' in c;
    };
    
    const actionType = config.actionType === 'REMOVE' ? 'ã‚¿ã‚°å‰Šé™¤' : 'ã‚¿ã‚°ä»˜ä¸';
    
    switch (dto.eventType) {
      case 'PAGE_ACTION': {
        if (isPageActionConfig(config)) {
          const page = config.page ?? 'ä¸æ˜';
          const action = config.action ?? 'ä¸æ˜';
          return `${page} - ${action}æ™‚ â†’ ${actionType}`;
        }
        return `ãƒšãƒ¼ã‚¸ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ â†’ ${actionType}`;
      }
      case 'AGE_THRESHOLD': {
        if (isAgeThresholdConfig(config)) {
          const ageType = config.ageType === 'months' ? 'ãƒ¶æœˆ' : 'æ—¥';
          const threshold = config.threshold ?? 0;
          return `ç”Ÿå¾Œ${threshold}${ageType}é”æˆæ™‚ â†’ ${actionType}`;
        }
        return `å¹´é½¢é–¾å€¤ â†’ ${actionType}`;
      }
      case 'TAG_ASSIGNED': {
        return `ã‚¿ã‚°ä»˜ä¸æ™‚ â†’ ${actionType}`;
      }
      default:
        return `è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ« - ${actionType}`;
    }
  }

  async updateRule(id: string, dto: UpdateTagAutomationRuleDto) {
    const updateData: Prisma.TagAutomationRuleUpdateInput = {
      ...(dto.key ? { key: this.normalizeKey(dto.key) } : {}),
      ...(dto.name !== undefined ? { name: dto.name } : {}),
      ...(dto.description !== undefined ? { description: dto.description } : {}),
      ...(dto.triggerType !== undefined ? { triggerType: dto.triggerType } : {}),
      ...(dto.eventType !== undefined ? { eventType: dto.eventType } : {}),
      ...(dto.scope !== undefined ? { scope: dto.scope } : {}),
      ...(dto.isActive !== undefined ? { isActive: dto.isActive } : {}),
      ...(dto.priority !== undefined ? { priority: dto.priority } : {}),
      ...(dto.config !== undefined
        ? { config: this.toJson(dto.config) ?? Prisma.JsonNull }
        : {}),
    };

    try {
      const rule = await this.prisma.tagAutomationRule.update({
        where: { id },
        data: updateData,
      });
      return { success: true, data: rule };
    } catch (error) {
      if (this.isUniqueConstraintViolation(error)) {
        throw new BadRequestException("åŒã˜ã‚­ãƒ¼ã‚’æŒã¤è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ãŒæ—¢ã«å­˜åœ¨ã—ã¾ã™");
      }
      throw error;
    }
  }

  async setRuleActive(id: string, isActive: boolean) {
    const rule = await this.prisma.tagAutomationRule.update({
      where: { id },
      data: { isActive },
    });

    return { success: true, data: rule };
  }

  async deleteRule(id: string) {
    await this.prisma.tagAutomationRule.delete({ where: { id } });
    return { success: true };
  }

  async createRun(ruleId: string, eventPayload?: Record<string, unknown> | null) {
    const run = await this.prisma.tagAutomationRun.create({
      data: {
        ruleId,
        ...(eventPayload !== undefined
          ? { eventPayload: this.toJson(eventPayload) ?? Prisma.JsonNull }
          : {}),
        status: TagAutomationRunStatus.PENDING,
        startedAt: new Date(),
      },
    });

    return { success: true, data: run };
  }

  async markRunCompleted(runId: string, metadata?: { eventPayload?: Record<string, unknown> | null }) {
    const data: Prisma.TagAutomationRunUpdateInput = {
      status: TagAutomationRunStatus.COMPLETED,
      completedAt: new Date(),
      errorMessage: null,
    };

    if (metadata?.eventPayload !== undefined) {
      data.eventPayload = this.toJson(metadata.eventPayload) ?? Prisma.JsonNull;
    }

    const run = await this.prisma.tagAutomationRun.update({
      where: { id: runId },
      data,
    });

    return { success: true, data: run };
  }

  async markRunFailed(runId: string, errorMessage: string, options?: { eventPayload?: Record<string, unknown> | null }) {
    const data: Prisma.TagAutomationRunUpdateInput = {
      status: TagAutomationRunStatus.FAILED,
      completedAt: new Date(),
      errorMessage,
    };

    if (options?.eventPayload !== undefined) {
      data.eventPayload = this.toJson(options.eventPayload) ?? Prisma.JsonNull;
    }

    const run = await this.prisma.tagAutomationRun.update({
      where: { id: runId },
      data,
    });

    return { success: true, data: run };
  }

  async findRuns(options: FindAutomationRunOptions = {}) {
    const { ruleId, statuses, take } = options;

    const where: Prisma.TagAutomationRunWhereInput = {
      ...(ruleId ? { ruleId } : {}),
      ...(statuses && statuses.length ? { status: { in: statuses } } : {}),
    };

    const runs = await this.prisma.tagAutomationRun.findMany({
      where,
      orderBy: { createdAt: "desc" },
      ...(take ? { take } : {}),
    });

    return { success: true, data: runs };
  }

  async recordAssignment(options: RecordAssignmentOptions) {
    const {
      catId,
      tagId,
      action,
      source = TagAssignmentSource.AUTOMATION,
      ruleId,
      automationRunId,
      reason,
      metadata,
      applyTagMutation = false,
    } = options;

    const historyCreate = this.prisma.tagAssignmentHistory.create({
      data: {
        catId,
        tagId,
        action,
        source,
        reason: reason ?? undefined,
        ...(metadata !== undefined
          ? { metadata: this.toJson(metadata) ?? Prisma.JsonNull }
          : {}),
        ruleId: ruleId ?? undefined,
        automationRunId: automationRunId ?? undefined,
      },
    });

    if (!applyTagMutation) {
      const history = await historyCreate;
      return { success: true, data: history };
    }

    const operations: Prisma.PrismaPromise<unknown>[] = [];

    if (action === TagAssignmentAction.ASSIGNED) {
      operations.push(
        this.prisma.catTag.upsert({
          where: { catId_tagId: { catId, tagId } },
          update: {},
          create: { catId, tagId },
        }),
      );
    } else {
      operations.push(
        this.prisma.catTag.deleteMany({
          where: { catId, tagId },
        }),
      );
    }

    operations.push(historyCreate);

    const results = await this.prisma.$transaction(operations);
    const history = results[results.length - 1] as Awaited<typeof historyCreate>;

    return { success: true, data: history };
  }

  async getHistoryForCat(catId: string, options: { take?: number; tagId?: string } = {}) {
    const { take, tagId } = options;

    const history = await this.prisma.tagAssignmentHistory.findMany({
      where: {
        catId,
        ...(tagId ? { tagId } : {}),
      },
      orderBy: { createdAt: "desc" },
      ...(take ? { take } : {}),
      include: {
        tag: true,
        rule: true,
        automationRun: true,
      },
    });

    return { success: true, data: history };
  }

  private normalizeKey(value: string): string {
    return value
      .trim()
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/(^-|-$)/g, "");
  }

  private toJson(value?: Record<string, unknown> | null): Prisma.InputJsonValue | undefined {
    if (value === null || value === undefined) {
      return undefined;
    }
    return value as Prisma.InputJsonValue;
  }

  private isUniqueConstraintViolation(error: unknown): error is Prisma.PrismaClientKnownRequestError {
    return (
      error instanceof Prisma.PrismaClientKnownRequestError &&
      error.code === "P2002"
    );
  }
}
`````

## File: backend/src/tags/tag-categories.controller.ts
`````typescript
import {
  Body,
  Controller,
  Delete,
  Get,
  HttpCode,
  HttpStatus,
  Param,
  Patch,
  Post,
  Query,
  UseGuards,
} from "@nestjs/common";
import { ApiBearerAuth, ApiOperation, ApiParam, ApiQuery, ApiResponse, ApiTags } from "@nestjs/swagger";

import { JwtAuthGuard } from "../auth/jwt-auth.guard";

import { CreateTagCategoryDto } from "./dto/create-tag-category.dto";
import { ReorderTagCategoriesDto } from "./dto/reorder-tag-category.dto";
import { UpdateTagCategoryDto } from "./dto/update-tag-category.dto";
import { TagCategoriesService } from "./tag-categories.service";
import { TagsService } from "./tags.service";

@ApiTags("Tags")
@Controller("tags/categories")
export class TagCategoriesController {
  constructor(
    private readonly tagCategoriesService: TagCategoriesService,
    private readonly tagsService: TagsService,
  ) {}

  @Get()
  @ApiOperation({ summary: "ã‚¿ã‚°ã‚«ãƒ†ã‚´ãƒªä¸€è¦§ã®å–å¾—" })
  @ApiQuery({ name: "scope", required: false, description: "å¯¾è±¡ã‚¹ã‚³ãƒ¼ãƒ—", type: [String] })
  @ApiQuery({
    name: "includeInactive",
    required: false,
    description: "éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ†ã‚´ãƒªã‚’å«ã‚ã‚‹",
    type: Boolean,
  })
  findAll(
    @Query("scope") scope?: string | string[],
    @Query("includeInactive") includeInactive?: string,
  ) {
    const scopes = Array.isArray(scope) ? scope : scope ? [scope] : undefined;
    const includeInactiveFlag = includeInactive === "true";
    return this.tagsService.findAll({ scopes, includeInactive: includeInactiveFlag });
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Post()
  @ApiOperation({ summary: "ã‚¿ã‚°ã‚«ãƒ†ã‚´ãƒªã®ä½œæˆ" })
  @ApiResponse({ status: HttpStatus.CREATED })
  create(@Body() dto: CreateTagCategoryDto) {
    return this.tagCategoriesService.create(dto);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Patch("reorder")
  @ApiOperation({ summary: "ã‚¿ã‚°ã‚«ãƒ†ã‚´ãƒªã®ä¸¦ã³æ›¿ãˆ" })
  @ApiResponse({ status: HttpStatus.OK })
  reorder(@Body() dto: ReorderTagCategoriesDto) {
    return this.tagCategoriesService.reorder(dto.items);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Patch(":id")
  @ApiOperation({ summary: "ã‚¿ã‚°ã‚«ãƒ†ã‚´ãƒªã®æ›´æ–°" })
  @ApiResponse({ status: HttpStatus.OK })
  @ApiParam({ name: "id" })
  update(@Param("id") id: string, @Body() dto: UpdateTagCategoryDto) {
    return this.tagCategoriesService.update(id, dto);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Delete(":id")
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({ summary: "ã‚¿ã‚°ã‚«ãƒ†ã‚´ãƒªã®å‰Šé™¤" })
  @ApiParam({ name: "id" })
  async remove(@Param("id") id: string) {
    await this.tagCategoriesService.remove(id);
    return { success: true };
  }
}
`````

## File: backend/src/tags/tag-categories.service.ts
`````typescript
import { BadRequestException, Injectable } from "@nestjs/common";
import { Prisma, TagCategory } from "@prisma/client";

import { PrismaService } from "../prisma/prisma.service";

import { CreateTagCategoryDto } from "./dto/create-tag-category.dto";
import { UpdateTagCategoryDto } from "./dto/update-tag-category.dto";

interface FindManyOptions {
  scopes?: string[];
  includeGroups?: boolean;
  includeInactive?: boolean;
}

type TagCategoryWithGroups = Prisma.TagCategoryGetPayload<{
  include: {
    groups: {
      include: {
        tags: {
          include: {
            cats: {
              select: { catId: true };
            };
          };
        };
      };
    };
  };
}>;

@Injectable()
export class TagCategoriesService {
  constructor(private readonly prisma: PrismaService) {}

  async findMany(options: FindManyOptions & { includeGroups: true }): Promise<TagCategoryWithGroups[]>;
  async findMany(options?: FindManyOptions): Promise<TagCategory[]>;
  async findMany(options: FindManyOptions = {}) {
    const { scopes, includeGroups = false, includeInactive = false } = options;

    const whereClause: Prisma.TagCategoryWhereInput = {
      ...(includeInactive ? {} : { isActive: true }),
      ...((scopes && scopes.length > 0)
        ? {
            OR: [
              { scopes: { hasSome: scopes } },
              { scopes: { equals: [] as string[] } },
            ],
          }
        : {}),
    };

    const args: Prisma.TagCategoryFindManyArgs = {
      where: whereClause,
      orderBy: [
        { displayOrder: "asc" },
        { name: "asc" },
      ],
      include: includeGroups
        ? {
            groups: {
              where: includeInactive ? {} : { isActive: true },
              include: {
                tags: {
                  where: includeInactive ? {} : { isActive: true },
                  include: {
                    cats: {
                      select: { catId: true },
                    },
                  },
                  orderBy: [
                    { displayOrder: "asc" },
                    { name: "asc" },
                  ],
                },
              },
              orderBy: [
                { displayOrder: "asc" },
                { name: "asc" },
              ],
            },
          }
        : undefined,
    };

    if (includeGroups) {
      return this.prisma.tagCategory.findMany(args) as Promise<TagCategoryWithGroups[]>;
    }

    return this.prisma.tagCategory.findMany(args);
  }

  async create(dto: CreateTagCategoryDto) {
    const key = this.normalizeKey(dto.key ?? dto.name);
    const displayOrder = dto.displayOrder ?? (await this.getNextDisplayOrder());

    try {
      const data = await this.prisma.tagCategory.create({
        data: {
          key,
          name: dto.name,
          description: dto.description ?? undefined,
          color: dto.color ?? undefined,
          textColor: dto.textColor ?? undefined,
          displayOrder,
          scopes: dto.scopes ?? [],
          isActive: dto.isActive ?? true,
        },
      });
      return { success: true, data };
    } catch (error) {
      if (this.isUniqueConstraintViolation(error)) {
        throw new BadRequestException("åŒã˜ã‚­ãƒ¼ã‚’æŒã¤ã‚«ãƒ†ã‚´ãƒªãŒæ—¢ã«å­˜åœ¨ã—ã¾ã™");
      }
      throw error;
    }
  }

  async update(id: string, dto: UpdateTagCategoryDto) {
    const data = await this.prisma.tagCategory.update({
      where: { id },
      data: {
        ...(dto.key ? { key: this.normalizeKey(dto.key) } : {}),
        ...(dto.name !== undefined ? { name: dto.name } : {}),
        ...(dto.description !== undefined ? { description: dto.description } : {}),
        ...(dto.color !== undefined ? { color: dto.color } : {}),
        ...(dto.textColor !== undefined ? { textColor: dto.textColor } : {}),
        ...(dto.displayOrder !== undefined ? { displayOrder: dto.displayOrder } : {}),
        ...(dto.scopes !== undefined ? { scopes: dto.scopes } : {}),
        ...(dto.isActive !== undefined ? { isActive: dto.isActive } : {}),
      },
    });
    return { success: true, data };
  }

  async remove(id: string) {
    await this.prisma.tagCategory.delete({ where: { id } });
    return { success: true };
  }

  async reorder(items: Array<{ id: string; displayOrder: number }>) {
    if (!items.length) {
      return { success: true };
    }

    await this.prisma.$transaction(
      items.map(({ id, displayOrder }) =>
        this.prisma.tagCategory.update({ where: { id }, data: { displayOrder } }),
      ),
    );

    return { success: true };
  }

  private normalizeKey(value: string): string {
    return value
      .trim()
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/(^-|-$)/g, "");
  }

  private isUniqueConstraintViolation(error: unknown): error is Prisma.PrismaClientKnownRequestError {
    return (
      error instanceof Prisma.PrismaClientKnownRequestError &&
      error.code === "P2002"
    );
  }

  private async getNextDisplayOrder(): Promise<number> {
    const result = await this.prisma.tagCategory.aggregate({
      _max: { displayOrder: true },
    });
    return (result._max.displayOrder ?? -1) + 1;
  }
}
`````

## File: backend/src/tags/tag-groups.controller.ts
`````typescript
import {
  Body,
  Controller,
  Delete,
  HttpCode,
  HttpStatus,
  Param,
  Patch,
  Post,
  UseGuards,
} from "@nestjs/common";
import { ApiBearerAuth, ApiOperation, ApiParam, ApiResponse, ApiTags } from "@nestjs/swagger";

import { JwtAuthGuard } from "../auth/jwt-auth.guard";

import { CreateTagGroupDto, ReorderTagGroupDto, UpdateTagGroupDto } from "./dto";
import { TagGroupsService } from "./tag-groups.service";

@ApiTags("Tags")
@Controller("tags/groups")
export class TagGroupsController {
  constructor(private readonly tagGroupsService: TagGroupsService) {}

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Post()
  @ApiOperation({ summary: "ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ã®ä½œæˆ" })
  @ApiResponse({ status: HttpStatus.CREATED })
  create(@Body() dto: CreateTagGroupDto) {
    return this.tagGroupsService.create(dto);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Patch("reorder")
  @ApiOperation({ summary: "ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ã®ä¸¦ã³æ›¿ãˆ" })
  @ApiResponse({ status: HttpStatus.OK })
  reorder(@Body() dto: ReorderTagGroupDto) {
    return this.tagGroupsService.reorder(dto.items);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Patch(":id")
  @ApiOperation({ summary: "ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ã®æ›´æ–°" })
  @ApiResponse({ status: HttpStatus.OK })
  @ApiParam({ name: "id" })
  update(@Param("id") id: string, @Body() dto: UpdateTagGroupDto) {
    return this.tagGroupsService.update(id, dto);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Delete(":id")
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({ summary: "ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ã®å‰Šé™¤" })
  @ApiParam({ name: "id" })
  async remove(@Param("id") id: string) {
    await this.tagGroupsService.remove(id);
    return { success: true };
  }
}
`````

## File: backend/src/tags/tag-groups.service.ts
`````typescript
import { BadRequestException, Injectable } from "@nestjs/common";
import { Prisma } from "@prisma/client";

import { PrismaService } from "../prisma/prisma.service";

import { CreateTagGroupDto } from "./dto/create-tag-group.dto";
import { UpdateTagGroupDto } from "./dto/update-tag-group.dto";

@Injectable()
export class TagGroupsService {
  constructor(private readonly prisma: PrismaService) {}

  async create(dto: CreateTagGroupDto) {
    const displayOrder = dto.displayOrder ?? (await this.getNextDisplayOrder(dto.categoryId));

    try {
      const data = await this.prisma.tagGroup.create({
        data: {
          category: { connect: { id: dto.categoryId } },
          name: dto.name,
          description: dto.description ?? undefined,
          color: dto.color ?? undefined,
          textColor: dto.textColor ?? undefined,
          displayOrder,
          isActive: dto.isActive ?? true,
        },
      });
      return { success: true, data };
    } catch (error) {
      if (this.isUniqueConstraintViolation(error)) {
        throw new BadRequestException("åŒã˜åç§°ã®ã‚°ãƒ«ãƒ¼ãƒ—ãŒæ—¢ã«å­˜åœ¨ã—ã¾ã™");
      }
      throw error;
    }
  }

  async update(id: string, dto: UpdateTagGroupDto) {
    try {
      const data = await this.prisma.tagGroup.update({
        where: { id },
        data: {
          ...(dto.categoryId ? { category: { connect: { id: dto.categoryId } } } : {}),
          ...(dto.name !== undefined ? { name: dto.name } : {}),
          ...(dto.description !== undefined ? { description: dto.description } : {}),
          ...(dto.color !== undefined ? { color: dto.color } : {}),
          ...(dto.textColor !== undefined ? { textColor: dto.textColor } : {}),
          ...(dto.displayOrder !== undefined ? { displayOrder: dto.displayOrder } : {}),
          ...(dto.isActive !== undefined ? { isActive: dto.isActive } : {}),
        },
      });
      return { success: true, data };
    } catch (error) {
      if (this.isUniqueConstraintViolation(error)) {
        throw new BadRequestException("åŒã˜åç§°ã®ã‚°ãƒ«ãƒ¼ãƒ—ãŒæ—¢ã«å­˜åœ¨ã—ã¾ã™");
      }
      throw error;
    }
  }

  async remove(id: string) {
    await this.prisma.tagGroup.delete({ where: { id } });
    return { success: true };
  }

  async reorder(items: Array<{ id: string; displayOrder: number; categoryId?: string }>) {
    if (!items.length) {
      return { success: true };
    }

    await this.prisma.$transaction(
      items.map(({ id, displayOrder, categoryId }) =>
        this.prisma.tagGroup.update({
          where: { id },
          data: {
            displayOrder,
            ...(categoryId ? { category: { connect: { id: categoryId } } } : {}),
          },
        }),
      ),
    );

    return { success: true };
  }

  private async getNextDisplayOrder(categoryId: string): Promise<number> {
    const result = await this.prisma.tagGroup.aggregate({
      _max: { displayOrder: true },
      where: { categoryId },
    });
    return (result._max.displayOrder ?? -1) + 1;
  }

  private isUniqueConstraintViolation(error: unknown): error is Prisma.PrismaClientKnownRequestError {
    return error instanceof Prisma.PrismaClientKnownRequestError && error.code === "P2002";
  }
}
`````

## File: backend/src/tags/tags.controller.ts
`````typescript
import {
  Body,
  Controller,
  Delete,
  Get,
  HttpCode,
  HttpStatus,
  Param,
  Patch,
  Post,
  Query,
  UseGuards,
} from "@nestjs/common";
import {
  ApiBearerAuth,
  ApiOperation,
  ApiParam,
  ApiQuery,
  ApiResponse,
  ApiTags,
} from "@nestjs/swagger";

import { JwtAuthGuard } from "../auth/jwt-auth.guard";

import { AssignTagDto, CreateTagDto, ReorderTagsDto, UpdateTagDto } from "./dto";
import { TagsService } from "./tags.service";

@ApiTags("Tags")
@Controller("tags")
export class TagsController {
  constructor(private readonly tagsService: TagsService) {}

  @Get()
  @ApiOperation({ summary: "ã‚¿ã‚°ä¸€è¦§ã®å–å¾—" })
  @ApiResponse({ status: HttpStatus.OK })
  @ApiQuery({ name: "scope", required: false, description: "å¯¾è±¡ã‚¹ã‚³ãƒ¼ãƒ—", type: [String] })
  @ApiQuery({
    name: "includeInactive",
    required: false,
    description: "éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¿ã‚°ã‚’å«ã‚ã‚‹ã‹",
    type: Boolean,
  })
  findAll(
    @Query("scope") scope?: string | string[],
    @Query("includeInactive") includeInactive?: string,
  ) {
    const scopes = Array.isArray(scope) ? scope : scope ? [scope] : undefined;
    const includeInactiveFlag = includeInactive === "true";
    return this.tagsService.findAll({ scopes, includeInactive: includeInactiveFlag });
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Post()
  @ApiOperation({ summary: "ã‚¿ã‚°ã®ä½œæˆ" })
  @ApiResponse({ status: HttpStatus.CREATED })
  create(@Body() dto: CreateTagDto) {
    return this.tagsService.create(dto);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Patch("reorder")
  @ApiOperation({ summary: "ã‚¿ã‚°ã®ä¸¦ã³æ›¿ãˆ" })
  @ApiResponse({ status: HttpStatus.OK })
  reorder(@Body() dto: ReorderTagsDto) {
    return this.tagsService.reorder(dto.items);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Patch(":id")
  @ApiOperation({ summary: "ã‚¿ã‚°ã®æ›´æ–°" })
  @ApiResponse({ status: HttpStatus.OK })
  @ApiParam({ name: "id" })
  update(@Param("id") id: string, @Body() dto: UpdateTagDto) {
    return this.tagsService.update(id, dto);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Delete(":id")
  @ApiOperation({ summary: "ã‚¿ã‚°ã®å‰Šé™¤" })
  @ApiResponse({ status: HttpStatus.OK })
  @ApiParam({ name: "id" })
  remove(@Param("id") id: string) {
    return this.tagsService.remove(id);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Post("/cats/:id/tags")
  @ApiOperation({ summary: "çŒ«ã«ã‚¿ã‚°ã‚’ä»˜ä¸" })
  @ApiResponse({ status: HttpStatus.OK, description: "ä»˜ä¸æˆåŠŸï¼ˆé‡è¤‡æ™‚ã‚‚OKï¼‰" })
  @ApiParam({ name: "id" })
  @HttpCode(HttpStatus.OK)
  assign(@Param("id") catId: string, @Body() dto: AssignTagDto) {
    return this.tagsService.assignToCat(catId, dto.tagId);
  }

  @ApiBearerAuth()
  @UseGuards(JwtAuthGuard)
  @Delete("/cats/:id/tags/:tagId")
  @ApiOperation({ summary: "çŒ«ã‹ã‚‰ã‚¿ã‚°ã‚’å‰¥å¥ª" })
  @ApiResponse({ status: HttpStatus.OK })
  @ApiParam({ name: "id" })
  @ApiParam({ name: "tagId" })
  unassign(@Param("id") catId: string, @Param("tagId") tagId: string) {
    return this.tagsService.unassignFromCat(catId, tagId);
  }
}
`````

## File: backend/src/tags/tags.module.ts
`````typescript
import { Module } from "@nestjs/common";
import { ScheduleModule } from "@nestjs/schedule";

import { PrismaModule } from "../prisma/prisma.module";

import { AgeThresholdCheckerService } from "./age-threshold-checker.service";
import { TagAutomationExecutionService } from "./tag-automation-execution.service";
import { TagAutomationController } from "./tag-automation.controller";
import { TagAutomationService } from "./tag-automation.service";
import { TagCategoriesController } from "./tag-categories.controller";
import { TagCategoriesService } from "./tag-categories.service";
import { TagGroupsController } from "./tag-groups.controller";
import { TagGroupsService } from "./tag-groups.service";
import { TagsController } from "./tags.controller";
import { TagsService } from "./tags.service";

@Module({
  imports: [PrismaModule, ScheduleModule.forRoot()],
  controllers: [
    TagsController,
    TagCategoriesController,
    TagGroupsController,
    TagAutomationController,
  ],
  providers: [
    TagsService,
    TagCategoriesService,
    TagGroupsService,
    TagAutomationService,
    TagAutomationExecutionService,
    AgeThresholdCheckerService,
  ],
  exports: [
    TagsService,
    TagCategoriesService,
    TagGroupsService,
    TagAutomationService,
    TagAutomationExecutionService,
    AgeThresholdCheckerService,
  ],
})
export class TagsModule {}
`````

## File: backend/src/tags/tags.service.ts
`````typescript
import { Injectable } from "@nestjs/common";
import { Prisma } from "@prisma/client";

import { PrismaService } from "../prisma/prisma.service";

import { CreateTagDto, UpdateTagDto } from "./dto";
import { TagCategoriesService } from "./tag-categories.service";

@Injectable()
export class TagsService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly tagCategoriesService: TagCategoriesService,
  ) {}

  async findAll(options: { scopes?: string[]; includeInactive?: boolean } = {}) {
    const categories = await this.tagCategoriesService.findMany({
      scopes: options.scopes,
      includeGroups: true,
      includeInactive: options.includeInactive,
    });

    return {
      success: true,
      data: categories.map((category) => ({
        id: category.id,
        key: category.key,
        name: category.name,
        description: category.description ?? undefined,
        color: category.color ?? undefined,
        textColor: category.textColor ?? undefined,
        displayOrder: category.displayOrder,
        scopes: category.scopes,
        isActive: category.isActive,
        groups: (category.groups ?? []).map((group) => ({
          id: group.id,
          categoryId: group.categoryId,
          name: group.name,
          description: group.description ?? undefined,
          color: group.color ?? undefined,
          textColor: group.textColor ?? undefined,
          displayOrder: group.displayOrder,
          isActive: group.isActive,
          tags: (group.tags ?? []).map((tag) => ({
            id: tag.id,
            groupId: tag.groupId,
            name: tag.name,
            color: tag.color,
            textColor: tag.textColor,
            description: tag.description ?? undefined,
            displayOrder: tag.displayOrder,
            allowsManual: tag.allowsManual,
            allowsAutomation: tag.allowsAutomation,
            metadata: tag.metadata ?? undefined,
            isActive: tag.isActive,
            usageCount: tag.cats.length,
          })),
        })),
      })),
    };
  }

  async create(dto: CreateTagDto) {
    const displayOrder = dto.displayOrder ?? (await this.getNextDisplayOrder(dto.groupId));
    const data = await this.prisma.tag.create({
      data: {
        group: { connect: { id: dto.groupId } },
        name: dto.name,
        color: dto.color ?? undefined,
        textColor: dto.textColor ?? undefined,
        description: dto.description ?? undefined,
        displayOrder,
        ...(dto.allowsManual !== undefined ? { allowsManual: dto.allowsManual } : {}),
        ...(dto.allowsAutomation !== undefined
          ? { allowsAutomation: dto.allowsAutomation }
          : {}),
        metadata: this.toJson(dto.metadata),
        ...(dto.isActive !== undefined ? { isActive: dto.isActive } : {}),
      },
      include: this.defaultTagInclude(),
    });

    return { success: true, data };
  }

  async update(id: string, dto: UpdateTagDto) {
    const updateData: Prisma.TagUpdateInput = {
      ...(dto.name !== undefined ? { name: dto.name } : {}),
      ...(dto.color !== undefined ? { color: dto.color } : {}),
  ...(dto.textColor !== undefined ? { textColor: dto.textColor } : {}),
      ...(dto.description !== undefined ? { description: dto.description } : {}),
      ...(dto.displayOrder !== undefined ? { displayOrder: dto.displayOrder } : {}),
      ...(dto.metadata !== undefined
        ? { metadata: this.toJson(dto.metadata) ?? Prisma.JsonNull }
        : {}),
      ...(dto.groupId ? { group: { connect: { id: dto.groupId } } } : {}),
      ...(dto.allowsManual !== undefined ? { allowsManual: dto.allowsManual } : {}),
      ...(dto.allowsAutomation !== undefined
        ? { allowsAutomation: dto.allowsAutomation }
        : {}),
      ...(dto.isActive !== undefined ? { isActive: dto.isActive } : {}),
    };

    const data = await this.prisma.tag.update({
      where: { id },
      data: updateData,
      include: this.defaultTagInclude(),
    });

    return { success: true, data };
  }

  async remove(id: string) {
    await this.prisma.tag.delete({ where: { id } });
    return { success: true };
  }

  async reorder(items: Array<{ id: string; displayOrder: number; groupId?: string }>) {
    if (!items.length) {
      return { success: true };
    }

    await this.prisma.$transaction(
      items.map(({ id, displayOrder, groupId }) =>
        this.prisma.tag.update({
          where: { id },
          data: {
            displayOrder,
            ...(groupId ? { group: { connect: { id: groupId } } } : {}),
          },
        }),
      ),
    );

    return { success: true };
  }

  async assignToCat(catId: string, tagId: string) {
    try {
      await this.prisma.catTag.create({ data: { catId, tagId } });
    } catch {
      // Unique constraint (already assigned) -> return success idempotently
    }
    return { success: true };
  }

  async unassignFromCat(catId: string, tagId: string) {
    await this.prisma.catTag.delete({
      where: { catId_tagId: { catId, tagId } },
    });
    return { success: true };
  }

  private defaultTagInclude(): Prisma.TagInclude {
    return {
      cats: {
        select: { catId: true },
      },
    };
  }

  private toJson(value?: Record<string, unknown> | null): Prisma.InputJsonValue | undefined {
    if (value === null || value === undefined) {
      return undefined;
    }

    return value as Prisma.InputJsonValue;
  }

  private async getNextDisplayOrder(groupId: string): Promise<number> {
    const result = await this.prisma.tag.aggregate({
      _max: { displayOrder: true },
      where: { groupId },
    });
    return (result._max.displayOrder ?? -1) + 1;
  }
}
`````

## File: backend/src/tenant-settings/dto/tag-color-defaults.dto.ts
`````typescript
import { ApiProperty } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { IsHexColor, IsOptional, ValidateNested } from 'class-validator';

/**
 * ã‚«ãƒ©ãƒ¼è¨­å®šï¼ˆèƒŒæ™¯è‰²ã¨ãƒ†ã‚­ã‚¹ãƒˆè‰²ï¼‰
 */
export class ColorSettingDto {
  @ApiProperty({
    description: 'èƒŒæ™¯ã‚«ãƒ©ãƒ¼ï¼ˆ16é€²æ•°ã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ï¼‰',
    example: '#6366F1',
  })
  @IsHexColor()
  color: string;

  @ApiProperty({
    description: 'ãƒ†ã‚­ã‚¹ãƒˆã‚«ãƒ©ãƒ¼ï¼ˆ16é€²æ•°ã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ï¼‰',
    example: '#111827',
  })
  @IsHexColor()
  textColor: string;
}

/**
 * ã‚«ãƒ©ãƒ¼è¨­å®šï¼ˆéƒ¨åˆ†æ›´æ–°ç”¨ï¼‰
 */
export class PartialColorSettingDto {
  @ApiProperty({
    description: 'èƒŒæ™¯ã‚«ãƒ©ãƒ¼ï¼ˆ16é€²æ•°ã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ï¼‰',
    example: '#6366F1',
    required: false,
  })
  @IsOptional()
  @IsHexColor()
  color?: string;

  @ApiProperty({
    description: 'ãƒ†ã‚­ã‚¹ãƒˆã‚«ãƒ©ãƒ¼ï¼ˆ16é€²æ•°ã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ï¼‰',
    example: '#111827',
    required: false,
  })
  @IsOptional()
  @IsHexColor()
  textColor?: string;
}

/**
 * ã‚¿ã‚°ã‚«ãƒ©ãƒ¼ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šDTO
 */
export class TagColorDefaultsDto {
  @ApiProperty({
    description: 'ã‚«ãƒ†ã‚´ãƒªã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ©ãƒ¼è¨­å®š',
    type: ColorSettingDto,
    required: false,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => ColorSettingDto)
  category?: ColorSettingDto;

  @ApiProperty({
    description: 'ã‚°ãƒ«ãƒ¼ãƒ—ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ©ãƒ¼è¨­å®š',
    type: ColorSettingDto,
    required: false,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => ColorSettingDto)
  group?: ColorSettingDto;

  @ApiProperty({
    description: 'ã‚¿ã‚°ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ©ãƒ¼è¨­å®š',
    type: ColorSettingDto,
    required: false,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => ColorSettingDto)
  tag?: ColorSettingDto;
}

/**
 * ã‚¿ã‚°ã‚«ãƒ©ãƒ¼ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šæ›´æ–°DTO
 * éƒ¨åˆ†æ›´æ–°ã‚’ã‚µãƒãƒ¼ãƒˆ
 */
export class UpdateTagColorDefaultsDto {
  @ApiProperty({
    description: 'ã‚«ãƒ†ã‚´ãƒªã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ©ãƒ¼è¨­å®šï¼ˆéƒ¨åˆ†æ›´æ–°å¯èƒ½ï¼‰',
    type: PartialColorSettingDto,
    required: false,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => PartialColorSettingDto)
  category?: PartialColorSettingDto;

  @ApiProperty({
    description: 'ã‚°ãƒ«ãƒ¼ãƒ—ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ©ãƒ¼è¨­å®šï¼ˆéƒ¨åˆ†æ›´æ–°å¯èƒ½ï¼‰',
    type: PartialColorSettingDto,
    required: false,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => PartialColorSettingDto)
  group?: PartialColorSettingDto;

  @ApiProperty({
    description: 'ã‚¿ã‚°ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ©ãƒ¼è¨­å®šï¼ˆéƒ¨åˆ†æ›´æ–°å¯èƒ½ï¼‰',
    type: PartialColorSettingDto,
    required: false,
  })
  @IsOptional()
  @ValidateNested()
  @Type(() => PartialColorSettingDto)
  tag?: PartialColorSettingDto;
}
`````

## File: backend/src/tenant-settings/tenant-settings.controller.ts
`````typescript
import {
  Controller,
  Get,
  Put,
  Body,
  UseGuards,
  HttpCode,
  HttpStatus,
  BadRequestException,
} from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiBearerAuth } from '@nestjs/swagger';
import { UserRole } from '@prisma/client';

import type { RequestUser } from '../auth/auth.types';
import { GetUser } from '../auth/get-user.decorator';
import { JwtAuthGuard } from '../auth/jwt-auth.guard';
import { RoleGuard } from '../auth/role.guard';
import { Roles } from '../auth/roles.decorator';

import { TagColorDefaultsDto, UpdateTagColorDefaultsDto } from './dto/tag-color-defaults.dto';
import { TenantSettingsService } from './tenant-settings.service';

/**
 * ãƒ†ãƒŠãƒ³ãƒˆè¨­å®šã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©
 * 
 * ãƒ†ãƒŠãƒ³ãƒˆå˜ä½ã®å„ç¨®è¨­å®šã‚’ç®¡ç†ã™ã‚‹ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’æä¾›ã—ã¾ã™ã€‚
 * ç¾åœ¨ã¯ã‚¿ã‚°ã‚«ãƒ©ãƒ¼ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚
 */
@ApiTags('tenant-settings')
@Controller('tenant-settings')
@UseGuards(JwtAuthGuard, RoleGuard)
@ApiBearerAuth()
export class TenantSettingsController {
  constructor(private readonly tenantSettingsService: TenantSettingsService) {}

  /**
   * ã‚¿ã‚°ã‚«ãƒ©ãƒ¼ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’å–å¾—
   * 
   * TENANT_ADMIN ã¾ãŸã¯ USERï¼ˆè‡ªãƒ†ãƒŠãƒ³ãƒˆã®ã¿ï¼‰ãŒã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
   */
  @Get('tag-color-defaults')
  @Roles(UserRole.TENANT_ADMIN, UserRole.USER, UserRole.ADMIN, UserRole.SUPER_ADMIN)
  @ApiOperation({
    summary: 'ã‚¿ã‚°ã‚«ãƒ©ãƒ¼ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’å–å¾—',
    description: 'ãƒ†ãƒŠãƒ³ãƒˆã®ã‚¿ã‚°ã‚«ãƒ©ãƒ¼ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’å–å¾—ã—ã¾ã™ã€‚è¨­å®šãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¿”ã—ã¾ã™ã€‚',
  })
  @ApiResponse({
    status: 200,
    description: 'ã‚¿ã‚°ã‚«ãƒ©ãƒ¼ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’è¿”å´',
    type: TagColorDefaultsDto,
  })
  @ApiResponse({ status: 401, description: 'èªè¨¼ãŒå¿…è¦ã§ã™' })
  @ApiResponse({ status: 404, description: 'ãƒ†ãƒŠãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“' })
  async getTagColorDefaults(@GetUser() user: RequestUser): Promise<TagColorDefaultsDto> {
    if (!user.tenantId) {
      throw new BadRequestException('ãƒ†ãƒŠãƒ³ãƒˆæƒ…å ±ãŒä¸è¶³ã—ã¦ã„ã¾ã™');
    }
    return this.tenantSettingsService.getTagColorDefaults(user.tenantId);
  }

  /**
   * ã‚¿ã‚°ã‚«ãƒ©ãƒ¼ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’æ›´æ–°
   * 
   * TENANT_ADMINï¼ˆè‡ªãƒ†ãƒŠãƒ³ãƒˆã®ã¿ï¼‰ãŒã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
   */
  @Put('tag-color-defaults')
  @Roles(UserRole.TENANT_ADMIN, UserRole.ADMIN, UserRole.SUPER_ADMIN)
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'ã‚¿ã‚°ã‚«ãƒ©ãƒ¼ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’æ›´æ–°',
    description: 'ãƒ†ãƒŠãƒ³ãƒˆã®ã‚¿ã‚°ã‚«ãƒ©ãƒ¼ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’æ›´æ–°ã—ã¾ã™ã€‚éƒ¨åˆ†æ›´æ–°ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚',
  })
  @ApiResponse({
    status: 200,
    description: 'ã‚¿ã‚°ã‚«ãƒ©ãƒ¼ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šãŒæ›´æ–°ã•ã‚Œã¾ã—ãŸ',
    type: TagColorDefaultsDto,
  })
  @ApiResponse({ status: 400, description: 'ä¸æ­£ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆ' })
  @ApiResponse({ status: 401, description: 'èªè¨¼ãŒå¿…è¦ã§ã™' })
  @ApiResponse({ status: 403, description: 'æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“' })
  @ApiResponse({ status: 404, description: 'ãƒ†ãƒŠãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“' })
  async updateTagColorDefaults(
    @GetUser() user: RequestUser,
    @Body() dto: UpdateTagColorDefaultsDto,
  ): Promise<TagColorDefaultsDto> {
    if (!user.tenantId) {
      throw new BadRequestException('ãƒ†ãƒŠãƒ³ãƒˆæƒ…å ±ãŒä¸è¶³ã—ã¦ã„ã¾ã™');
    }
    return this.tenantSettingsService.updateTagColorDefaults(user.tenantId, dto);
  }
}
`````

## File: backend/src/tenant-settings/tenant-settings.module.ts
`````typescript
import { Module } from '@nestjs/common';

import { PrismaModule } from '../prisma/prisma.module';

import { TenantSettingsController } from './tenant-settings.controller';
import { TenantSettingsService } from './tenant-settings.service';

/**
 * ãƒ†ãƒŠãƒ³ãƒˆè¨­å®šãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
 * 
 * ãƒ†ãƒŠãƒ³ãƒˆå˜ä½ã®å„ç¨®è¨­å®šã‚’ç®¡ç†ã™ã‚‹æ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™ã€‚
 */
@Module({
  imports: [PrismaModule],
  controllers: [TenantSettingsController],
  providers: [TenantSettingsService],
  exports: [TenantSettingsService],
})
export class TenantSettingsModule {}
`````

## File: backend/src/tenant-settings/tenant-settings.service.ts
`````typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { Prisma } from '@prisma/client';

import { PrismaService } from '../prisma/prisma.service';

import type { TagColorDefaultsDto, UpdateTagColorDefaultsDto } from './dto/tag-color-defaults.dto';

// ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¨åŒæœŸ
// å‚ç…§: frontend/src/app/tags/page.tsx ã® DEFAULT_*_COLOR å®šæ•°
const FRONTEND_DEFAULTS: TagColorDefaultsDto = {
  category: {
    color: '#6366F1',
    textColor: '#111827',
  },
  group: {
    color: '#3B82F6',
    textColor: '#111827',
  },
  tag: {
    color: '#3B82F6',
    textColor: '#FFFFFF',
  },
};

interface ColorSetting {
  color: string;
  textColor: string;
}

interface StoredDefaults {
  category?: ColorSetting;
  group?: ColorSetting;
  tag?: ColorSetting;
}

/**
 * ãƒ†ãƒŠãƒ³ãƒˆè¨­å®šã‚µãƒ¼ãƒ“ã‚¹
 * 
 * ãƒ†ãƒŠãƒ³ãƒˆå˜ä½ã®å„ç¨®è¨­å®šã‚’ç®¡ç†ã—ã¾ã™ã€‚
 * ç¾åœ¨ã¯ã‚¿ã‚°ã‚«ãƒ©ãƒ¼ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚
 */
@Injectable()
export class TenantSettingsService {
  constructor(private readonly prisma: PrismaService) {}

  /**
   * ã‚¿ã‚°ã‚«ãƒ©ãƒ¼ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’å–å¾—
   * 
   * @param tenantId ãƒ†ãƒŠãƒ³ãƒˆID
   * @returns ã‚¿ã‚°ã‚«ãƒ©ãƒ¼ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šï¼ˆè¨­å®šãŒãªã„å ´åˆã¯ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¿”ã™ï¼‰
   */
  async getTagColorDefaults(tenantId: string): Promise<TagColorDefaultsDto> {
    // è¨­å®šã¨ãƒ†ãƒŠãƒ³ãƒˆã‚’åŒæ™‚ã«å–å¾—
    const settings = await this.prisma.tenantSettings.findUnique({
      where: { tenantId },
      include: { tenant: true },
    });

    if (settings) {
      // ãƒ†ãƒŠãƒ³ãƒˆãŒå­˜åœ¨ã—ãªã„å ´åˆï¼ˆå¤–éƒ¨ã‚­ãƒ¼åˆ¶ç´„ã«ã‚ˆã‚Šé€šå¸¸ã¯ç™ºç”Ÿã—ãªã„ï¼‰
      if (!settings.tenant) {
        throw new NotFoundException('ãƒ†ãƒŠãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
      }
      // è¨­å®šãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯ãã‚Œã‚’è¿”ã™
      if (settings.tagColorDefaults) {
        return this.mergeWithDefaults(settings.tagColorDefaults as StoredDefaults);
      }
    } else {
      // è¨­å®šãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ãƒ†ãƒŠãƒ³ãƒˆã®å­˜åœ¨ã®ã¿ç¢ºèª
      const tenant = await this.prisma.tenant.findUnique({
        where: { id: tenantId },
      });
      if (!tenant) {
        throw new NotFoundException('ãƒ†ãƒŠãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
      }
    }

    // è¨­å®šãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¿”ã™
    return FRONTEND_DEFAULTS;
  }

  /**
   * ã‚¿ã‚°ã‚«ãƒ©ãƒ¼ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’æ›´æ–°
   * 
   * @param tenantId ãƒ†ãƒŠãƒ³ãƒˆID
   * @param dto æ›´æ–°å†…å®¹ï¼ˆéƒ¨åˆ†æ›´æ–°ã‚’ã‚µãƒãƒ¼ãƒˆï¼‰
   * @returns æ›´æ–°å¾Œã®ã‚¿ã‚°ã‚«ãƒ©ãƒ¼ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š
   */
  async updateTagColorDefaults(
    tenantId: string,
    dto: UpdateTagColorDefaultsDto,
  ): Promise<TagColorDefaultsDto> {
    // æ—¢å­˜ã®è¨­å®šã‚’å–å¾—
    const existingSettings = await this.prisma.tenantSettings.findUnique({
      where: { tenantId },
    });

    // æ—¢å­˜ã®è¨­å®šã¨ãƒãƒ¼ã‚¸
    const currentDefaults = existingSettings?.tagColorDefaults
      ? (existingSettings.tagColorDefaults as StoredDefaults)
      : {};

    const updatedDefaults: StoredDefaults = {
      category: {
        color: dto.category?.color ?? currentDefaults.category?.color ?? FRONTEND_DEFAULTS.category?.color ?? '#6366F1',
        textColor: dto.category?.textColor ?? currentDefaults.category?.textColor ?? FRONTEND_DEFAULTS.category?.textColor ?? '#111827',
      },
      group: {
        color: dto.group?.color ?? currentDefaults.group?.color ?? FRONTEND_DEFAULTS.group?.color ?? '#3B82F6',
        textColor: dto.group?.textColor ?? currentDefaults.group?.textColor ?? FRONTEND_DEFAULTS.group?.textColor ?? '#111827',
      },
      tag: {
        color: dto.tag?.color ?? currentDefaults.tag?.color ?? FRONTEND_DEFAULTS.tag?.color ?? '#3B82F6',
        textColor: dto.tag?.textColor ?? currentDefaults.tag?.textColor ?? FRONTEND_DEFAULTS.tag?.textColor ?? '#FFFFFF',
      },
    };

    try {
      // è¨­å®šã‚’æ›´æ–°ï¼ˆupsertï¼‰
      // å¤–éƒ¨ã‚­ãƒ¼åˆ¶ç´„ã«ã‚ˆã‚Šã€å­˜åœ¨ã—ãªã„ãƒ†ãƒŠãƒ³ãƒˆIDã«å¯¾ã—ã¦ã¯è‡ªå‹•çš„ã«å¤±æ•—ã™ã‚‹
      const updated = await this.prisma.tenantSettings.upsert({
        where: { tenantId },
        create: {
          tenantId,
          tagColorDefaults: updatedDefaults as Prisma.InputJsonValue,
        },
        update: {
          tagColorDefaults: updatedDefaults as Prisma.InputJsonValue,
        },
      });

      return this.mergeWithDefaults(updated.tagColorDefaults as StoredDefaults);
    } catch (error) {
      // Prisma ã®å¤–éƒ¨ã‚­ãƒ¼åˆ¶ç´„ã‚¨ãƒ©ãƒ¼ã‚’ã‚­ãƒ£ãƒƒãƒ
      if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2003') {
        throw new NotFoundException('ãƒ†ãƒŠãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
      }
      throw error;
    }
  }

  /**
   * ã‚¹ãƒˆã‚¢ã•ã‚ŒãŸè¨­å®šã¨ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ãƒãƒ¼ã‚¸
   * 
   * @param stored ã‚¹ãƒˆã‚¢ã•ã‚ŒãŸè¨­å®š
   * @returns ãƒãƒ¼ã‚¸å¾Œã®è¨­å®š
   */
  private mergeWithDefaults(stored: StoredDefaults): TagColorDefaultsDto {
    return {
      category: {
        color: stored.category?.color ?? FRONTEND_DEFAULTS.category?.color ?? '#6366F1',
        textColor: stored.category?.textColor ?? FRONTEND_DEFAULTS.category?.textColor ?? '#111827',
      },
      group: {
        color: stored.group?.color ?? FRONTEND_DEFAULTS.group?.color ?? '#3B82F6',
        textColor: stored.group?.textColor ?? FRONTEND_DEFAULTS.group?.textColor ?? '#111827',
      },
      tag: {
        color: stored.tag?.color ?? FRONTEND_DEFAULTS.tag?.color ?? '#3B82F6',
        textColor: stored.tag?.textColor ?? FRONTEND_DEFAULTS.tag?.textColor ?? '#FFFFFF',
      },
    };
  }
}
`````

## File: backend/src/tenants/dto/create-tenant.dto.ts
`````typescript
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsString, IsNotEmpty, IsOptional, MaxLength, Matches } from 'class-validator';

/**
 * ãƒ†ãƒŠãƒ³ãƒˆä½œæˆDTO
 */
export class CreateTenantDto {
  @ApiProperty({
    description: 'ãƒ†ãƒŠãƒ³ãƒˆå',
    example: 'ã‚µãƒ³ãƒ—ãƒ«ãƒ†ãƒŠãƒ³ãƒˆ',
  })
  @IsString()
  @IsNotEmpty({ message: 'ãƒ†ãƒŠãƒ³ãƒˆåã¯å¿…é ˆã§ã™' })
  @MaxLength(100, { message: 'ãƒ†ãƒŠãƒ³ãƒˆåã¯100æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„' })
  name: string;

  @ApiPropertyOptional({
    description: 'ãƒ†ãƒŠãƒ³ãƒˆã‚¹ãƒ©ãƒƒã‚°ï¼ˆæœªå…¥åŠ›ã®å ´åˆã¯è‡ªå‹•ç”Ÿæˆï¼‰',
    example: 'sample-tenant',
  })
  @IsOptional()
  @IsNotEmpty({ message: 'ã‚¹ãƒ©ãƒƒã‚°ã‚’æŒ‡å®šã™ã‚‹å ´åˆã¯ç©ºæ–‡å­—åˆ—ã«ã§ãã¾ã›ã‚“' })
  @IsString()
  @MaxLength(100, { message: 'ã‚¹ãƒ©ãƒƒã‚°ã¯100æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„' })
  @Matches(/^[a-z0-9]+(-[a-z0-9]+)*$/, { message: 'ã‚¹ãƒ©ãƒƒã‚°ã¯åŠè§’è‹±å°æ–‡å­—ã¾ãŸã¯æ•°å­—ã§å§‹ã¾ã‚Šã€ãƒã‚¤ãƒ•ãƒ³ã§åŒºåˆ‡ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼ˆé€£ç¶šãƒ»å…ˆé ­ãƒ»æœ«å°¾ã®ãƒã‚¤ãƒ•ãƒ³ã¯ä¸å¯ï¼‰' })
  slug?: string;
}
`````

## File: backend/src/tenants/dto/invitation.dto.ts
`````typescript
import { ApiProperty } from '@nestjs/swagger';
import { UserRole } from '@prisma/client';
import { IsEmail, IsEnum, IsString, IsNotEmpty, MinLength, MaxLength } from 'class-validator';

/**
 * SuperAdmin ãŒãƒ†ãƒŠãƒ³ãƒˆç®¡ç†è€…ã‚’æ‹›å¾…ã™ã‚‹ãŸã‚ã® DTO
 */
export class InviteTenantAdminDto {
  @ApiProperty({ description: 'æ‹›å¾…ã™ã‚‹ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹', example: 'admin@example.com' })
  @IsEmail({}, { message: 'æœ‰åŠ¹ãªãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„' })
  @IsNotEmpty({ message: 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯å¿…é ˆã§ã™' })
  email: string;

  @ApiProperty({ description: 'ãƒ†ãƒŠãƒ³ãƒˆå', example: 'Sample Tenant' })
  @IsString()
  @IsNotEmpty({ message: 'ãƒ†ãƒŠãƒ³ãƒˆåã¯å¿…é ˆã§ã™' })
  @MinLength(2, { message: 'ãƒ†ãƒŠãƒ³ãƒˆåã¯2æ–‡å­—ä»¥ä¸Šã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™' })
  @MaxLength(100, { message: 'ãƒ†ãƒŠãƒ³ãƒˆåã¯100æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„' })
  tenantName: string;

  @ApiProperty({ 
    description: 'ãƒ†ãƒŠãƒ³ãƒˆã‚¹ãƒ©ãƒƒã‚°ï¼ˆURLè­˜åˆ¥å­ï¼‰', 
    example: 'sample-tenant',
    required: false 
  })
  @IsString()
  @MinLength(2, { message: 'ã‚¹ãƒ©ãƒƒã‚°ã¯2æ–‡å­—ä»¥ä¸Šã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™' })
  @MaxLength(50, { message: 'ã‚¹ãƒ©ãƒƒã‚°ã¯50æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„' })
  tenantSlug?: string;
}

/**
 * ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†è€…ãŒãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’æ‹›å¾…ã™ã‚‹ãŸã‚ã® DTO
 */
export class InviteUserDto {
  @ApiProperty({ description: 'æ‹›å¾…ã™ã‚‹ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹', example: 'user@example.com' })
  @IsEmail({}, { message: 'æœ‰åŠ¹ãªãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„' })
  @IsNotEmpty({ message: 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯å¿…é ˆã§ã™' })
  email: string;

  @ApiProperty({ 
    description: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«', 
    enum: UserRole,
    default: UserRole.USER 
  })
  @IsEnum(UserRole, { message: 'æœ‰åŠ¹ãªãƒ­ãƒ¼ãƒ«ã‚’æŒ‡å®šã—ã¦ãã ã•ã„' })
  role: UserRole;
}

/**
 * æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²ã‚’å®Œäº†ã™ã‚‹ãŸã‚ã® DTO
 */
export class CompleteInvitationDto {
  @ApiProperty({ description: 'æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³' })
  @IsString()
  @IsNotEmpty({ message: 'ãƒˆãƒ¼ã‚¯ãƒ³ã¯å¿…é ˆã§ã™' })
  token: string;

  @ApiProperty({ description: 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰', minLength: 8 })
  @IsString()
  @IsNotEmpty({ message: 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯å¿…é ˆã§ã™' })
  @MinLength(8, { message: 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯8æ–‡å­—ä»¥ä¸Šã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™' })
  password: string;

  @ApiProperty({ description: 'å', required: false })
  @IsString()
  firstName?: string;

  @ApiProperty({ description: 'å§“', required: false })
  @IsString()
  lastName?: string;
}
`````

## File: backend/src/tenants/dto/update-tenant.dto.ts
`````typescript
import { ApiPropertyOptional } from '@nestjs/swagger';
import { IsString, IsOptional, IsBoolean, MaxLength, Matches } from 'class-validator';

/**
 * ãƒ†ãƒŠãƒ³ãƒˆæ›´æ–°DTO
 */
export class UpdateTenantDto {
  @ApiPropertyOptional({
    description: 'ãƒ†ãƒŠãƒ³ãƒˆå',
    example: 'æ›´æ–°å¾Œãƒ†ãƒŠãƒ³ãƒˆå',
  })
  @IsOptional()
  @IsString()
  @MaxLength(100, { message: 'ãƒ†ãƒŠãƒ³ãƒˆåã¯100æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„' })
  name?: string;

  @ApiPropertyOptional({
    description: 'ãƒ†ãƒŠãƒ³ãƒˆã‚¹ãƒ©ãƒƒã‚°',
    example: 'updated-tenant',
  })
  @IsOptional()
  @IsString()
  @MaxLength(100, { message: 'ã‚¹ãƒ©ãƒƒã‚°ã¯100æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„' })
  @Matches(/^[a-z0-9]+(-[a-z0-9]+)*$/, { message: 'ã‚¹ãƒ©ãƒƒã‚°ã¯åŠè§’è‹±å°æ–‡å­—ã¾ãŸã¯æ•°å­—ã§å§‹ã¾ã‚Šã€ãƒã‚¤ãƒ•ãƒ³ã§åŒºåˆ‡ã‚‹ã“ã¨ãŒã§ãã¾ã™' })
  slug?: string;

  @ApiPropertyOptional({
    description: 'æœ‰åŠ¹/ç„¡åŠ¹ãƒ•ãƒ©ã‚°',
    example: true,
  })
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
}
`````

## File: backend/src/tenants/tenants.controller.ts
`````typescript
import { 
  Controller, 
  Get,
  Post, 
  Patch,
  Delete,
  Body, 
  Param, 
  UseGuards,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiBearerAuth } from '@nestjs/swagger';
import { UserRole } from '@prisma/client';

import type { RequestUser } from '../auth/auth.types';
import { GetUser } from '../auth/get-user.decorator';
import { JwtAuthGuard } from '../auth/jwt-auth.guard';
import { RoleGuard } from '../auth/role.guard';
import { Roles } from '../auth/roles.decorator';
import { Public } from '../common/decorators/public.decorator';
import { TenantScopedGuard } from '../common/guards/tenant-scoped.guard';

import { CreateTenantDto } from './dto/create-tenant.dto';
import { 
  InviteTenantAdminDto, 
  InviteUserDto, 
  CompleteInvitationDto 
} from './dto/invitation.dto';
import { UpdateTenantDto } from './dto/update-tenant.dto';
import { TenantsService } from './tenants.service';

/**
 * ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©
 * 
 * ãƒ†ãƒŠãƒ³ãƒˆä½œæˆã€ãƒ¦ãƒ¼ã‚¶ãƒ¼æ‹›å¾…ã€æ‹›å¾…å®Œäº†ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’æä¾›ã—ã¾ã™ã€‚
 */
@ApiTags('tenants')
@Controller('tenants')
export class TenantsController {
  constructor(private readonly tenantsService: TenantsService) {}

  /**
   * ãƒ†ãƒŠãƒ³ãƒˆä¸€è¦§å–å¾—
   * SUPER_ADMIN ã®ã¿ãŒã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
   */
  @Get()
  @UseGuards(JwtAuthGuard, RoleGuard)
  @Roles(UserRole.SUPER_ADMIN)
  @ApiBearerAuth()
  @ApiOperation({ 
    summary: 'ãƒ†ãƒŠãƒ³ãƒˆä¸€è¦§å–å¾—',
    description: 'SuperAdminã®ã¿ãŒå®Ÿè¡Œå¯èƒ½ã€‚å…¨ãƒ†ãƒŠãƒ³ãƒˆã®ä¸€è¦§ã‚’å–å¾—ã—ã¾ã™ã€‚' 
  })
  @ApiResponse({ status: 200, description: 'ãƒ†ãƒŠãƒ³ãƒˆä¸€è¦§ã‚’è¿”å´' })
  @ApiResponse({ status: 401, description: 'èªè¨¼ãŒå¿…è¦ã§ã™' })
  @ApiResponse({ status: 403, description: 'æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“' })
  async listTenants() {
    return this.tenantsService.listTenants();
  }

  /**
   * ãƒ†ãƒŠãƒ³ãƒˆä½œæˆ
   * SUPER_ADMIN ã®ã¿ãŒã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
   */
  @Post()
  @UseGuards(JwtAuthGuard, RoleGuard)
  @Roles(UserRole.SUPER_ADMIN)
  @ApiBearerAuth()
  @HttpCode(HttpStatus.CREATED)
  @ApiOperation({ 
    summary: 'ãƒ†ãƒŠãƒ³ãƒˆä½œæˆ',
    description: 'SuperAdminã®ã¿ãŒå®Ÿè¡Œå¯èƒ½ã€‚æ–°ã—ã„ãƒ†ãƒŠãƒ³ãƒˆã‚’ä½œæˆã—ã¾ã™ã€‚' 
  })
  @ApiResponse({ status: 201, description: 'ãƒ†ãƒŠãƒ³ãƒˆãŒä½œæˆã•ã‚Œã¾ã—ãŸ' })
  @ApiResponse({ status: 400, description: 'ä¸æ­£ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆ' })
  @ApiResponse({ status: 403, description: 'æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“' })
  @ApiResponse({ status: 409, description: 'ã‚¹ãƒ©ãƒƒã‚°ãŒæ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™' })
  async createTenant(@Body() dto: CreateTenantDto) {
    return this.tenantsService.createTenant(dto);
  }

  /**
   * ãƒ†ãƒŠãƒ³ãƒˆè©³ç´°å–å¾—
   * SUPER_ADMIN ã¾ãŸã¯ TENANT_ADMINï¼ˆè‡ªãƒ†ãƒŠãƒ³ãƒˆã®ã¿ï¼‰ãŒã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
   */
  @Get(':id')
  @UseGuards(JwtAuthGuard, RoleGuard)
  @Roles(UserRole.SUPER_ADMIN, UserRole.TENANT_ADMIN)
  @ApiBearerAuth()
  @ApiOperation({ 
    summary: 'ãƒ†ãƒŠãƒ³ãƒˆè©³ç´°å–å¾—',
    description: 'SuperAdminã¾ãŸã¯ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†è€…ï¼ˆè‡ªãƒ†ãƒŠãƒ³ãƒˆã®ã¿ï¼‰ãŒå®Ÿè¡Œå¯èƒ½ã€‚æŒ‡å®šIDã®ãƒ†ãƒŠãƒ³ãƒˆè©³ç´°ã‚’å–å¾—ã—ã¾ã™ã€‚' 
  })
  @ApiResponse({ status: 200, description: 'ãƒ†ãƒŠãƒ³ãƒˆè©³ç´°ã‚’è¿”å´' })
  @ApiResponse({ status: 401, description: 'èªè¨¼ãŒå¿…è¦ã§ã™' })
  @ApiResponse({ status: 403, description: 'æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“' })
  @ApiResponse({ status: 404, description: 'ãƒ†ãƒŠãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“' })
  async getTenantById(
    @Param('id') id: string,
    @GetUser() user: RequestUser,
  ) {
    return this.tenantsService.getTenantById(id, user);
  }

  /**
   * ãƒ†ãƒŠãƒ³ãƒˆæ›´æ–°
   * SUPER_ADMIN ã®ã¿ãŒã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
   */
  @Patch(':id')
  @UseGuards(JwtAuthGuard, RoleGuard)
  @Roles(UserRole.SUPER_ADMIN)
  @ApiBearerAuth()
  @ApiOperation({ 
    summary: 'ãƒ†ãƒŠãƒ³ãƒˆæ›´æ–°',
    description: 'SuperAdminã®ã¿ãŒå®Ÿè¡Œå¯èƒ½ã€‚æŒ‡å®šIDã®ãƒ†ãƒŠãƒ³ãƒˆã‚’æ›´æ–°ã—ã¾ã™ã€‚' 
  })
  @ApiResponse({ status: 200, description: 'ãƒ†ãƒŠãƒ³ãƒˆãŒæ›´æ–°ã•ã‚Œã¾ã—ãŸ' })
  @ApiResponse({ status: 401, description: 'èªè¨¼ãŒå¿…è¦ã§ã™' })
  @ApiResponse({ status: 403, description: 'æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“' })
  @ApiResponse({ status: 404, description: 'ãƒ†ãƒŠãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“' })
  @ApiResponse({ status: 409, description: 'ã‚¹ãƒ©ãƒƒã‚°ãŒæ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™' })
  async updateTenant(
    @Param('id') id: string,
    @Body() dto: UpdateTenantDto,
    @GetUser() user: RequestUser,
  ) {
    return this.tenantsService.updateTenant(id, dto, user);
  }

  /**
   * SuperAdmin ãŒãƒ†ãƒŠãƒ³ãƒˆç®¡ç†è€…ã‚’æ‹›å¾…
   */
  @Post('invite-admin')
  @UseGuards(JwtAuthGuard, RoleGuard)
  @Roles(UserRole.SUPER_ADMIN)
  @ApiBearerAuth()
  @HttpCode(HttpStatus.CREATED)
  @ApiOperation({ 
    summary: 'ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†è€…ã‚’æ‹›å¾…',
    description: 'SuperAdminã®ã¿ãŒå®Ÿè¡Œå¯èƒ½ã€‚æ–°ã—ã„ãƒ†ãƒŠãƒ³ãƒˆã‚’ä½œæˆã—ã€ç®¡ç†è€…ã‚’æ‹›å¾…ã—ã¾ã™ã€‚' 
  })
  @ApiResponse({ status: 201, description: 'æ‹›å¾…ãŒæ­£å¸¸ã«ä½œæˆã•ã‚Œã¾ã—ãŸ' })
  @ApiResponse({ status: 400, description: 'ä¸æ­£ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆ' })
  @ApiResponse({ status: 403, description: 'æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“' })
  @ApiResponse({ status: 409, description: 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¾ãŸã¯ã‚¹ãƒ©ãƒƒã‚°ãŒæ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™' })
  async inviteTenantAdmin(@Body() dto: InviteTenantAdminDto) {
    return this.tenantsService.inviteTenantAdmin(dto);
  }

  /**
   * ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†è€…ãŒãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’æ‹›å¾…
   */
  @Post(':tenantId/users/invite')
  @UseGuards(JwtAuthGuard, RoleGuard, TenantScopedGuard)
  @Roles(UserRole.TENANT_ADMIN)
  @ApiBearerAuth()
  @HttpCode(HttpStatus.CREATED)
  @ApiOperation({ 
    summary: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’æ‹›å¾…',
    description: 'ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†è€…ãŒè‡ªåˆ†ã®ãƒ†ãƒŠãƒ³ãƒˆã«ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’æ‹›å¾…ã—ã¾ã™ã€‚' 
  })
  @ApiResponse({ status: 201, description: 'æ‹›å¾…ãŒæ­£å¸¸ã«ä½œæˆã•ã‚Œã¾ã—ãŸ' })
  @ApiResponse({ status: 400, description: 'ä¸æ­£ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆ' })
  @ApiResponse({ status: 403, description: 'æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“' })
  @ApiResponse({ status: 404, description: 'ãƒ†ãƒŠãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“' })
  @ApiResponse({ status: 409, description: 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒæ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™' })
  async inviteUser(
    @Param('tenantId') tenantId: string,
    @Body() dto: InviteUserDto,
  ) {
    return this.tenantsService.inviteUser(tenantId, dto);
  }

  /**
   * æ‹›å¾…å®Œäº†ï¼ˆãƒˆãƒ¼ã‚¯ãƒ³ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²ï¼‰
   */
  @Post('complete-invitation')
  @Public()
  @HttpCode(HttpStatus.CREATED)
  @ApiOperation({ 
    summary: 'æ‹›å¾…å®Œäº†',
    description: 'æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½¿ç”¨ã—ã¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²ã‚’å®Œäº†ã—ã¾ã™ã€‚èªè¨¼ä¸è¦ã€‚' 
  })
  @ApiResponse({ status: 201, description: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²ãŒå®Œäº†ã—ã¾ã—ãŸ' })
  @ApiResponse({ status: 400, description: 'ä¸æ­£ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆã¾ãŸã¯ç„¡åŠ¹ãªãƒˆãƒ¼ã‚¯ãƒ³' })
  @ApiResponse({ status: 409, description: 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒæ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™' })
  async completeInvitation(@Body() dto: CompleteInvitationDto) {
    return this.tenantsService.completeInvitation(dto);
  }

  /**
   * ãƒ†ãƒŠãƒ³ãƒˆå‰Šé™¤
   * SUPER_ADMIN ã®ã¿ãŒã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
   * æ‰€å±ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã„ã‚‹å ´åˆã¯å‰Šé™¤ä¸å¯
   */
  @Delete(':id')
  @UseGuards(JwtAuthGuard, RoleGuard)
  @Roles(UserRole.SUPER_ADMIN)
  @ApiBearerAuth()
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ 
    summary: 'ãƒ†ãƒŠãƒ³ãƒˆå‰Šé™¤',
    description: 'SuperAdminã®ã¿ãŒå®Ÿè¡Œå¯èƒ½ã€‚æŒ‡å®šIDã®ãƒ†ãƒŠãƒ³ãƒˆã‚’å‰Šé™¤ã—ã¾ã™ã€‚æ‰€å±ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã„ã‚‹å ´åˆã¯å‰Šé™¤ã§ãã¾ã›ã‚“ã€‚' 
  })
  @ApiResponse({ status: 200, description: 'ãƒ†ãƒŠãƒ³ãƒˆãŒå‰Šé™¤ã•ã‚Œã¾ã—ãŸ' })
  @ApiResponse({ status: 401, description: 'èªè¨¼ãŒå¿…è¦ã§ã™' })
  @ApiResponse({ status: 403, description: 'æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“' })
  @ApiResponse({ status: 404, description: 'ãƒ†ãƒŠãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“' })
  @ApiResponse({ status: 409, description: 'æ‰€å±ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå­˜åœ¨ã™ã‚‹ãŸã‚å‰Šé™¤ã§ãã¾ã›ã‚“' })
  async deleteTenant(
    @Param('id') id: string,
    @GetUser() user: RequestUser,
  ) {
    return this.tenantsService.deleteTenant(id, user);
  }
}
`````

## File: backend/src/tenants/tenants.module.ts
`````typescript
import { Module } from '@nestjs/common';

import { AuthModule } from '../auth/auth.module';
import { EmailModule } from '../email/email.module';
import { PrismaModule } from '../prisma/prisma.module';

import { TenantsController } from './tenants.controller';
import { TenantsService } from './tenants.service';

/**
 * ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
 * 
 * ãƒãƒ«ãƒãƒ†ãƒŠãƒ³ãƒˆç’°å¢ƒã§ã®ãƒ†ãƒŠãƒ³ãƒˆä½œæˆã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼æ‹›å¾…æ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™ã€‚
 */
@Module({
  imports: [PrismaModule, AuthModule, EmailModule],
  controllers: [TenantsController],
  providers: [TenantsService],
  exports: [TenantsService],
})
export class TenantsModule {}
`````

## File: backend/src/tenants/tenants.service.spec.ts
`````typescript
import { BadRequestException, ConflictException, ForbiddenException, NotFoundException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { Test, TestingModule } from '@nestjs/testing';
import { UserRole } from '@prisma/client';

import type { RequestUser } from '../auth/auth.types';
import { PasswordService } from '../auth/password.service';
import { EmailService } from '../email/email.service';
import { PrismaService } from '../prisma/prisma.service';

import { CreateTenantDto } from './dto/create-tenant.dto';
import { InviteTenantAdminDto, InviteUserDto, CompleteInvitationDto } from './dto/invitation.dto';
import { TenantsService } from './tenants.service';

describe('TenantsService', () => {
  let service: TenantsService;
  let _prisma: PrismaService;
  let _passwordService: PasswordService;

  const mockPrismaService = {
    user: {
      findUnique: jest.fn(),
      create: jest.fn(),
    },
    tenant: {
      findUnique: jest.fn(),
      findMany: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
    },
    invitationToken: {
      findUnique: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
      deleteMany: jest.fn(),
    },
    $transaction: jest.fn(),
  };

  const mockPasswordService = {
    validatePasswordStrength: jest.fn(),
    hashPassword: jest.fn(),
  };

  const mockJwtService = {
    signAsync: jest.fn(),
  };

  const mockEmailService = {
    sendInvitationEmail: jest.fn().mockResolvedValue(true),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TenantsService,
        {
          provide: PrismaService,
          useValue: mockPrismaService,
        },
        {
          provide: PasswordService,
          useValue: mockPasswordService,
        },
        {
          provide: JwtService,
          useValue: mockJwtService,
        },
        {
          provide: EmailService,
          useValue: mockEmailService,
        },
      ],
    }).compile();

    service = module.get<TenantsService>(TenantsService);
    _prisma = module.get<PrismaService>(PrismaService);
    _passwordService = module.get<PasswordService>(PasswordService);

    // Reset mocks
    jest.clearAllMocks();
  });

  describe('inviteTenantAdmin', () => {
    const dto: InviteTenantAdminDto = {
      email: 'admin@example.com',
      tenantName: 'Test Tenant',
      tenantSlug: 'test-tenant',
    };

    it('ãƒ†ãƒŠãƒ³ãƒˆã¨æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æ­£å¸¸ã«ä½œæˆ', async () => {
      mockPrismaService.user.findUnique.mockResolvedValue(null);
      mockPrismaService.tenant.findUnique.mockResolvedValue(null);
      mockPrismaService.$transaction.mockImplementation(async (callback) => {
        return callback({
          tenant: {
            create: jest.fn().mockResolvedValue({
              id: 'tenant-1',
              name: dto.tenantName,
              slug: dto.tenantSlug,
            }),
          },
          invitationToken: {
            create: jest.fn().mockResolvedValue({
              id: 'invitation-1',
              token: 'test-token',
              email: dto.email,
            }),
          },
        });
      });

      const result = await service.inviteTenantAdmin(dto);

      expect(result.success).toBe(true);
      expect(result.tenantId).toBeDefined();
      expect(result.invitationToken).toBeDefined();
    });

    it('ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒæ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹å ´åˆã‚¨ãƒ©ãƒ¼', async () => {
      mockPrismaService.user.findUnique.mockResolvedValue({ id: 'user-1' });

      await expect(service.inviteTenantAdmin(dto)).rejects.toThrow(ConflictException);
      await expect(service.inviteTenantAdmin(dto)).rejects.toThrow(
        'ã“ã®ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯æ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™',
      );
    });

    it('ã‚¹ãƒ©ãƒƒã‚°ãŒæ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹å ´åˆã‚¨ãƒ©ãƒ¼', async () => {
      mockPrismaService.user.findUnique.mockResolvedValue(null);
      mockPrismaService.tenant.findUnique.mockResolvedValue({ id: 'tenant-1' });

      await expect(service.inviteTenantAdmin(dto)).rejects.toThrow(ConflictException);
      await expect(service.inviteTenantAdmin(dto)).rejects.toThrow(
        'ã“ã®ã‚¹ãƒ©ãƒƒã‚°ã¯æ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™',
      );
    });
  });

  describe('inviteUser', () => {
    const tenantId = 'tenant-1';
    const dto: InviteUserDto = {
      email: 'user@example.com',
      role: UserRole.USER,
    };

    it('ãƒ¦ãƒ¼ã‚¶ãƒ¼æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æ­£å¸¸ã«ä½œæˆ', async () => {
      mockPrismaService.tenant.findUnique.mockResolvedValue({
        id: tenantId,
        isActive: true,
      });
      mockPrismaService.user.findUnique.mockResolvedValue(null);
      mockPrismaService.invitationToken.create.mockResolvedValue({
        id: 'invitation-1',
        token: 'test-token',
      });

      const result = await service.inviteUser(tenantId, dto);

      expect(result.success).toBe(true);
      expect(result.invitationToken).toBeDefined();
    });

    it('ãƒ†ãƒŠãƒ³ãƒˆãŒå­˜åœ¨ã—ãªã„å ´åˆã‚¨ãƒ©ãƒ¼', async () => {
      mockPrismaService.tenant.findUnique.mockResolvedValue(null);

      await expect(service.inviteUser(tenantId, dto)).rejects.toThrow(NotFoundException);
      await expect(service.inviteUser(tenantId, dto)).rejects.toThrow(
        'ãƒ†ãƒŠãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“',
      );
    });

    it('ãƒ†ãƒŠãƒ³ãƒˆãŒç„¡åŠ¹åŒ–ã•ã‚Œã¦ã„ã‚‹å ´åˆã‚¨ãƒ©ãƒ¼', async () => {
      mockPrismaService.tenant.findUnique.mockResolvedValue({
        id: tenantId,
        isActive: false,
      });

      await expect(service.inviteUser(tenantId, dto)).rejects.toThrow(BadRequestException);
      await expect(service.inviteUser(tenantId, dto)).rejects.toThrow(
        'ã“ã®ãƒ†ãƒŠãƒ³ãƒˆã¯ç„¡åŠ¹åŒ–ã•ã‚Œã¦ã„ã¾ã™',
      );
    });

    it('TENANT_ADMINã‚’æ‹›å¾…ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã‚¨ãƒ©ãƒ¼', async () => {
      mockPrismaService.tenant.findUnique.mockResolvedValue({
        id: tenantId,
        isActive: true,
      });
      mockPrismaService.user.findUnique.mockResolvedValue(null);

      const adminDto = { ...dto, role: UserRole.TENANT_ADMIN };

      await expect(service.inviteUser(tenantId, adminDto)).rejects.toThrow(BadRequestException);
    });
  });

  describe('completeInvitation', () => {
    const dto: CompleteInvitationDto = {
      token: 'valid-token',
      password: 'SecurePassword123!',
      firstName: 'Test',
      lastName: 'User',
    };

    it('æ‹›å¾…å®Œäº†ã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆã«æˆåŠŸ', async () => {
      const invitation = {
        id: 'invitation-1',
        email: 'user@example.com',
        role: UserRole.USER,
        tenantId: 'tenant-1',
        usedAt: null,
        expiresAt: new Date(Date.now() + 86400000), // 24æ™‚é–“å¾Œ
        tenant: { id: 'tenant-1', isActive: true },
      };

      mockPrismaService.invitationToken.findUnique.mockResolvedValue(invitation);
      mockPrismaService.user.findUnique.mockResolvedValue(null);
      mockPasswordService.validatePasswordStrength.mockReturnValue({ isValid: true, errors: [] });
      mockPasswordService.hashPassword.mockResolvedValue('hashed-password');
      mockJwtService.signAsync.mockResolvedValue('test-jwt-token');
      mockPrismaService.$transaction.mockImplementation(async (callback) => {
        return callback({
          user: {
            create: jest.fn().mockResolvedValue({
              id: 'user-1',
              email: invitation.email,
              tenantId: invitation.tenantId,
            }),
          },
          invitationToken: {
            update: jest.fn(),
          },
        });
      });

      const result = await service.completeInvitation(dto);

      expect(result.success).toBe(true);
      expect(result.userId).toBeDefined();
      expect(result.tenantId).toBe('tenant-1');
      expect(result.access_token).toBe('test-jwt-token');
    });

    it('ç„¡åŠ¹ãªãƒˆãƒ¼ã‚¯ãƒ³ã®å ´åˆã‚¨ãƒ©ãƒ¼', async () => {
      mockPrismaService.invitationToken.findUnique.mockResolvedValue(null);

      await expect(service.completeInvitation(dto)).rejects.toThrow(BadRequestException);
      await expect(service.completeInvitation(dto)).rejects.toThrow('ç„¡åŠ¹ãªæ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ã§ã™');
    });

    it('æ—¢ã«ä½¿ç”¨æ¸ˆã¿ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®å ´åˆã‚¨ãƒ©ãƒ¼', async () => {
      mockPrismaService.invitationToken.findUnique.mockResolvedValue({
        usedAt: new Date(),
      });

      await expect(service.completeInvitation(dto)).rejects.toThrow(BadRequestException);
      await expect(service.completeInvitation(dto)).rejects.toThrow(
        'ã“ã®æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ã¯æ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™',
      );
    });

    it('æœŸé™åˆ‡ã‚Œã®ãƒˆãƒ¼ã‚¯ãƒ³ã®å ´åˆã‚¨ãƒ©ãƒ¼', async () => {
      mockPrismaService.invitationToken.findUnique.mockResolvedValue({
        usedAt: null,
        expiresAt: new Date(Date.now() - 86400000), // 24æ™‚é–“å‰
        tenant: { isActive: true },
      });

      await expect(service.completeInvitation(dto)).rejects.toThrow(BadRequestException);
      await expect(service.completeInvitation(dto)).rejects.toThrow(
        'æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ‰åŠ¹æœŸé™ãŒåˆ‡ã‚Œã¦ã„ã¾ã™',
      );
    });
  });

  describe('listTenants', () => {
    it('å…¨ãƒ†ãƒŠãƒ³ãƒˆã®ä¸€è¦§ã‚’æ­£å¸¸ã«å–å¾—', async () => {
      const mockTenants = [
        {
          id: 'tenant-1',
          name: 'Test Tenant 1',
          slug: 'test-tenant-1',
          isActive: true,
          createdAt: new Date(),
          updatedAt: new Date(),
        },
        {
          id: 'tenant-2',
          name: 'Test Tenant 2',
          slug: 'test-tenant-2',
          isActive: false,
          createdAt: new Date(),
          updatedAt: new Date(),
        },
      ];

      mockPrismaService.tenant.findMany.mockResolvedValue(mockTenants);

      const result = await service.listTenants();

      expect(result.success).toBe(true);
      expect(result.data).toEqual(mockTenants);
      expect(result.count).toBe(2);
      expect(mockPrismaService.tenant.findMany).toHaveBeenCalledWith({
        select: {
          id: true,
          name: true,
          slug: true,
          isActive: true,
          createdAt: true,
          updatedAt: true,
        },
        orderBy: { createdAt: 'desc' },
      });
    });

    it('ãƒ†ãƒŠãƒ³ãƒˆãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ç©ºã®é…åˆ—ã‚’è¿”ã™', async () => {
      mockPrismaService.tenant.findMany.mockResolvedValue([]);

      const result = await service.listTenants();

      expect(result.success).toBe(true);
      expect(result.data).toEqual([]);
      expect(result.count).toBe(0);
    });
  });

  describe('createTenant', () => {
    it('æ˜ç¤ºçš„ãªã‚¹ãƒ©ãƒƒã‚°ã§ãƒ†ãƒŠãƒ³ãƒˆã‚’æ­£å¸¸ã«ä½œæˆ', async () => {
      const dto: CreateTenantDto = {
        name: 'Test Tenant',
        slug: 'test-tenant',
      };

      mockPrismaService.tenant.findUnique.mockResolvedValue(null);
      mockPrismaService.tenant.create.mockResolvedValue({
        id: 'tenant-1',
        name: dto.name,
        slug: dto.slug,
      });

      const result = await service.createTenant(dto);

      expect(result.success).toBe(true);
      expect(result.data.id).toBe('tenant-1');
      expect(result.data.name).toBe(dto.name);
      expect(result.data.slug).toBe(dto.slug);
      expect(mockPrismaService.tenant.create).toHaveBeenCalledWith({
        data: {
          name: dto.name,
          slug: dto.slug,
          isActive: true,
        },
      });
    });

    it('è‡ªå‹•ç”Ÿæˆã•ã‚ŒãŸã‚¹ãƒ©ãƒƒã‚°ã§ãƒ†ãƒŠãƒ³ãƒˆã‚’æ­£å¸¸ã«ä½œæˆ', async () => {
      const dto: CreateTenantDto = {
        name: 'My New Tenant',
        // slug ã¯æœªæŒ‡å®š
      };

      mockPrismaService.tenant.findUnique.mockResolvedValue(null);
      mockPrismaService.tenant.create.mockResolvedValue({
        id: 'tenant-2',
        name: dto.name,
        slug: 'my-new-tenant',
      });

      const result = await service.createTenant(dto);

      expect(result.success).toBe(true);
      expect(result.data.id).toBe('tenant-2');
      expect(result.data.name).toBe(dto.name);
      expect(result.data.slug).toBe('my-new-tenant');
    });

    it('æ—¥æœ¬èªã®ã¿ã®ãƒ†ãƒŠãƒ³ãƒˆåï¼ˆã‚¹ãƒ©ãƒƒã‚°ç”Ÿæˆä¸å¯ï¼‰ã®å ´åˆã‚¨ãƒ©ãƒ¼', async () => {
      const dto: CreateTenantDto = {
        name: 'ã‚µãƒ³ãƒ—ãƒ«ãƒ†ãƒŠãƒ³ãƒˆ',
        // slug ã¯æœªæŒ‡å®š â†’ æ—¥æœ¬èªã‹ã‚‰ç”Ÿæˆã§ããªã„
      };

      await expect(service.createTenant(dto)).rejects.toThrow(BadRequestException);
      await expect(service.createTenant(dto)).rejects.toThrow(
        'ãƒ†ãƒŠãƒ³ãƒˆåã‹ã‚‰ã‚¹ãƒ©ãƒƒã‚°ã‚’ç”Ÿæˆã§ãã¾ã›ã‚“ã§ã—ãŸ',
      );
    });

    it('ã‚¹ãƒ©ãƒƒã‚°ãŒæ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹å ´åˆã‚¨ãƒ©ãƒ¼', async () => {
      const dto: CreateTenantDto = {
        name: 'Another Tenant',
        slug: 'existing-slug',
      };

      mockPrismaService.tenant.findUnique.mockResolvedValue({
        id: 'existing-tenant',
        slug: 'existing-slug',
      });

      await expect(service.createTenant(dto)).rejects.toThrow(ConflictException);
      await expect(service.createTenant(dto)).rejects.toThrow(
        'ã“ã®ã‚¹ãƒ©ãƒƒã‚°ã¯æ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™',
      );
    });

    it('ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ§‹é€ ãŒæ­£ã—ã„å½¢å¼ã§ã‚ã‚‹ã“ã¨', async () => {
      const dto: CreateTenantDto = {
        name: 'Response Test',
        slug: 'response-test',
      };

      mockPrismaService.tenant.findUnique.mockResolvedValue(null);
      mockPrismaService.tenant.create.mockResolvedValue({
        id: 'tenant-3',
        name: dto.name,
        slug: dto.slug,
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      const result = await service.createTenant(dto);

      // ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ§‹é€ ã‚’æ¤œè¨¼
      expect(result).toHaveProperty('success', true);
      expect(result).toHaveProperty('data');
      expect(result.data).toHaveProperty('id');
      expect(result.data).toHaveProperty('name');
      expect(result.data).toHaveProperty('slug');
      // ä½™åˆ†ãªãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯å«ã¾ã‚Œãªã„ã“ã¨ã‚’ç¢ºèª
      expect(Object.keys(result.data)).toHaveLength(3);
    });
  });

  describe('getTenantById', () => {
    const tenantId = 'tenant-1';

    const superAdminUser: RequestUser = {
      userId: 'super-admin-1',
      email: 'superadmin@example.com',
      role: UserRole.SUPER_ADMIN,
      tenantId: undefined,
    };

    const tenantAdminUser: RequestUser = {
      userId: 'tenant-admin-1',
      email: 'tenantadmin@example.com',
      role: UserRole.TENANT_ADMIN,
      tenantId: 'tenant-1',
    };

    it('SUPER_ADMIN ã¯æŒ‡å®š ID ã®ãƒ†ãƒŠãƒ³ãƒˆã‚’æ­£å¸¸ã«å–å¾—ã§ãã‚‹', async () => {
      const mockTenant = {
        id: tenantId,
        name: 'Test Tenant',
        slug: 'test-tenant',
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date(),
        _count: { users: 5 },
      };

      mockPrismaService.tenant.findUnique.mockResolvedValue(mockTenant);

      const result = await service.getTenantById(tenantId, superAdminUser);

      expect(result.success).toBe(true);
      expect(result.data).toEqual(mockTenant);
      expect(mockPrismaService.tenant.findUnique).toHaveBeenCalledWith({
        where: { id: tenantId },
        select: {
          id: true,
          name: true,
          slug: true,
          isActive: true,
          createdAt: true,
          updatedAt: true,
          _count: {
            select: {
              users: true,
            },
          },
        },
      });
    });

    it('TENANT_ADMIN ã¯è‡ªãƒ†ãƒŠãƒ³ãƒˆã®æƒ…å ±ã‚’å–å¾—ã§ãã‚‹', async () => {
      const mockTenant = {
        id: tenantId,
        name: 'Test Tenant',
        slug: 'test-tenant',
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date(),
        _count: { users: 3 },
      };

      mockPrismaService.tenant.findUnique.mockResolvedValue(mockTenant);

      const result = await service.getTenantById(tenantId, tenantAdminUser);

      expect(result.success).toBe(true);
      expect(result.data).toEqual(mockTenant);
    });

    it('TENANT_ADMIN ã¯ä»–ã®ãƒ†ãƒŠãƒ³ãƒˆã®æƒ…å ±ã«ã¯ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã„', async () => {
      await expect(
        service.getTenantById('tenant-2', tenantAdminUser),
      ).rejects.toThrow(ForbiddenException);
      await expect(
        service.getTenantById('tenant-2', tenantAdminUser),
      ).rejects.toThrow('ä»–ã®ãƒ†ãƒŠãƒ³ãƒˆã®æƒ…å ±ã«ã¯ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“');
    });

    it('ãƒ†ãƒŠãƒ³ãƒˆã«æ‰€å±ã—ã¦ã„ãªã„ TENANT_ADMIN ã¯ã‚¨ãƒ©ãƒ¼', async () => {
      const noTenantAdminUser: RequestUser = {
        userId: 'tenant-admin-2',
        email: 'tenantadmin2@example.com',
        role: UserRole.TENANT_ADMIN,
        tenantId: undefined,
      };

      await expect(
        service.getTenantById(tenantId, noTenantAdminUser),
      ).rejects.toThrow(ForbiddenException);
      await expect(
        service.getTenantById(tenantId, noTenantAdminUser),
      ).rejects.toThrow('ãƒ†ãƒŠãƒ³ãƒˆã«æ‰€å±ã—ã¦ã„ã¾ã›ã‚“');
    });

    it('ãƒ†ãƒŠãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ NotFoundException ã‚’ã‚¹ãƒ­ãƒ¼', async () => {
      mockPrismaService.tenant.findUnique.mockResolvedValue(null);

      await expect(service.getTenantById(tenantId, superAdminUser)).rejects.toThrow(NotFoundException);
      await expect(service.getTenantById(tenantId, superAdminUser)).rejects.toThrow('ãƒ†ãƒŠãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    });
  });

  describe('updateTenant', () => {
    const tenantId = 'tenant-1';
    
    const superAdminUser: RequestUser = {
      userId: 'super-admin-1',
      email: 'superadmin@example.com',
      role: UserRole.SUPER_ADMIN,
      tenantId: undefined,
    };

    const tenantAdminUser: RequestUser = {
      userId: 'tenant-admin-1',
      email: 'tenantadmin@example.com',
      role: UserRole.TENANT_ADMIN,
      tenantId: 'tenant-1',
    };

    beforeEach(() => {
      mockPrismaService.tenant.findUnique.mockReset();
      mockPrismaService.tenant.update.mockReset();
    });

    it('SUPER_ADMIN ãŒãƒ†ãƒŠãƒ³ãƒˆåã‚’æ­£å¸¸ã«æ›´æ–°ã§ãã‚‹', async () => {
      const existingTenant = {
        id: tenantId,
        name: 'Original Name',
        slug: 'original-slug',
        isActive: true,
      };

      mockPrismaService.tenant.findUnique.mockResolvedValue(existingTenant);
      mockPrismaService.tenant.update.mockResolvedValue({
        ...existingTenant,
        name: 'Updated Name',
        updatedAt: new Date(),
      });

      const result = await service.updateTenant(tenantId, { name: 'Updated Name' }, superAdminUser);

      expect(result.success).toBe(true);
      expect(result.data.name).toBe('Updated Name');
      expect(mockPrismaService.tenant.update).toHaveBeenCalledWith({
        where: { id: tenantId },
        data: { name: 'Updated Name' },
        select: expect.any(Object),
      });
    });

    it('ã‚¹ãƒ©ãƒƒã‚°å¤‰æ›´æ™‚ã«é‡è¤‡ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã†', async () => {
      const existingTenant = {
        id: tenantId,
        name: 'Test Tenant',
        slug: 'test-tenant',
        isActive: true,
      };

      mockPrismaService.tenant.findUnique
        .mockResolvedValueOnce(existingTenant) // å¯¾è±¡ãƒ†ãƒŠãƒ³ãƒˆ
        .mockResolvedValueOnce({ id: 'other-tenant', slug: 'new-slug' }); // é‡è¤‡ã‚¹ãƒ©ãƒƒã‚°

      await expect(
        service.updateTenant(tenantId, { slug: 'new-slug' }, superAdminUser)
      ).rejects.toThrow(ConflictException);
    });

    it('ãƒ†ãƒŠãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼', async () => {
      mockPrismaService.tenant.findUnique.mockResolvedValue(null);

      await expect(
        service.updateTenant(tenantId, { name: 'Updated' }, superAdminUser)
      ).rejects.toThrow(NotFoundException);
    });

    it('TENANT_ADMIN ã¯æ›´æ–°ã§ããªã„', async () => {
      await expect(
        service.updateTenant(tenantId, { name: 'Updated' }, tenantAdminUser)
      ).rejects.toThrow(ForbiddenException);
    });

    it('isActive ã‚’ false ã«æ›´æ–°ã§ãã‚‹', async () => {
      const existingTenant = {
        id: tenantId,
        name: 'Test Tenant',
        slug: 'test-tenant',
        isActive: true,
      };

      mockPrismaService.tenant.findUnique.mockResolvedValue(existingTenant);
      mockPrismaService.tenant.update.mockResolvedValue({
        ...existingTenant,
        isActive: false,
        updatedAt: new Date(),
      });

      const result = await service.updateTenant(tenantId, { isActive: false }, superAdminUser);

      expect(result.success).toBe(true);
      expect(result.data.isActive).toBe(false);
    });
  });

  describe('deleteTenant', () => {
    const tenantId = 'tenant-1';

    const superAdminUser: RequestUser = {
      userId: 'super-admin-1',
      email: 'superadmin@example.com',
      role: UserRole.SUPER_ADMIN,
      tenantId: undefined,
    };

    const tenantAdminUser: RequestUser = {
      userId: 'tenant-admin-1',
      email: 'tenantadmin@example.com',
      role: UserRole.TENANT_ADMIN,
      tenantId: 'tenant-1',
    };

    const adminUser: RequestUser = {
      userId: 'admin-1',
      email: 'admin@example.com',
      role: UserRole.ADMIN,
      tenantId: 'tenant-1',
    };

    it('SUPER_ADMIN ãŒãƒ†ãƒŠãƒ³ãƒˆã‚’æ­£å¸¸ã«å‰Šé™¤ã§ãã‚‹', async () => {
      const emptyTenant = {
        id: tenantId,
        name: 'Test Tenant',
        slug: 'test-tenant',
        isActive: true,
        _count: {
          users: 0,
        },
      };

      mockPrismaService.tenant.findUnique.mockResolvedValue(emptyTenant);
      mockPrismaService.invitationToken.deleteMany.mockResolvedValue({ count: 2 });
      mockPrismaService.tenant.delete.mockResolvedValue({
        id: tenantId,
        name: 'Test Tenant',
        slug: 'test-tenant',
      });

      const result = await service.deleteTenant(tenantId, superAdminUser);

      expect(result.success).toBe(true);
      expect(result.message).toBe('ãƒ†ãƒŠãƒ³ãƒˆã‚’å‰Šé™¤ã—ã¾ã—ãŸ');
      expect(mockPrismaService.invitationToken.deleteMany).toHaveBeenCalledWith({
        where: { tenantId },
      });
      expect(mockPrismaService.tenant.delete).toHaveBeenCalledWith({
        where: { id: tenantId },
      });
    });

    it('æ‰€å±ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå­˜åœ¨ã™ã‚‹å ´åˆã« ConflictException ãŒã‚¹ãƒ­ãƒ¼ã•ã‚Œã‚‹', async () => {
      const tenantWithUsers = {
        id: tenantId,
        name: 'Test Tenant',
        slug: 'test-tenant',
        isActive: true,
        _count: {
          users: 3,
        },
      };

      mockPrismaService.tenant.findUnique.mockResolvedValue(tenantWithUsers);

      await expect(
        service.deleteTenant(tenantId, superAdminUser),
      ).rejects.toThrow(ConflictException);
      await expect(
        service.deleteTenant(tenantId, superAdminUser),
      ).rejects.toThrow('ã“ã®ãƒ†ãƒŠãƒ³ãƒˆã«ã¯3äººã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ‰€å±ã—ã¦ã„ã‚‹ãŸã‚å‰Šé™¤ã§ãã¾ã›ã‚“');

      expect(mockPrismaService.tenant.delete).not.toHaveBeenCalled();
      expect(mockPrismaService.invitationToken.deleteMany).not.toHaveBeenCalled();
    });

    it('å­˜åœ¨ã—ãªã„ãƒ†ãƒŠãƒ³ãƒˆ ID ã‚’æŒ‡å®šã—ãŸå ´åˆã« NotFoundException ãŒã‚¹ãƒ­ãƒ¼ã•ã‚Œã‚‹', async () => {
      mockPrismaService.tenant.findUnique.mockResolvedValue(null);

      await expect(
        service.deleteTenant('non-existent-tenant', superAdminUser),
      ).rejects.toThrow(NotFoundException);
      await expect(
        service.deleteTenant('non-existent-tenant', superAdminUser),
      ).rejects.toThrow('ãƒ†ãƒŠãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');

      expect(mockPrismaService.tenant.delete).not.toHaveBeenCalled();
      expect(mockPrismaService.invitationToken.deleteMany).not.toHaveBeenCalled();
    });

    it('SUPER_ADMIN ä»¥å¤–ã®ãƒ­ãƒ¼ãƒ«ãŒå‰Šé™¤ã—ã‚ˆã†ã¨ã—ãŸå ´åˆã« ForbiddenException ãŒã‚¹ãƒ­ãƒ¼ã•ã‚Œã‚‹', async () => {
      await expect(
        service.deleteTenant(tenantId, tenantAdminUser),
      ).rejects.toThrow(ForbiddenException);
      await expect(
        service.deleteTenant(tenantId, tenantAdminUser),
      ).rejects.toThrow('ãƒ†ãƒŠãƒ³ãƒˆã‚’å‰Šé™¤ã™ã‚‹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“');

      expect(mockPrismaService.tenant.findUnique).not.toHaveBeenCalled();
      expect(mockPrismaService.tenant.delete).not.toHaveBeenCalled();
      expect(mockPrismaService.invitationToken.deleteMany).not.toHaveBeenCalled();
    });

    it('ADMIN ãƒ­ãƒ¼ãƒ«ãŒå‰Šé™¤ã—ã‚ˆã†ã¨ã—ãŸå ´åˆã« ForbiddenException ãŒã‚¹ãƒ­ãƒ¼ã•ã‚Œã‚‹', async () => {
      await expect(
        service.deleteTenant(tenantId, adminUser),
      ).rejects.toThrow(ForbiddenException);
      await expect(
        service.deleteTenant(tenantId, adminUser),
      ).rejects.toThrow('ãƒ†ãƒŠãƒ³ãƒˆã‚’å‰Šé™¤ã™ã‚‹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“');

      expect(mockPrismaService.tenant.findUnique).not.toHaveBeenCalled();
      expect(mockPrismaService.tenant.delete).not.toHaveBeenCalled();
      expect(mockPrismaService.invitationToken.deleteMany).not.toHaveBeenCalled();
    });

    it('é–¢é€£ã™ã‚‹æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ãŒæ­£ã—ãå‰Šé™¤ã•ã‚Œã‚‹', async () => {
      const emptyTenant = {
        id: tenantId,
        name: 'Test Tenant',
        slug: 'test-tenant',
        isActive: true,
        _count: {
          users: 0,
        },
      };

      mockPrismaService.tenant.findUnique.mockResolvedValue(emptyTenant);
      mockPrismaService.invitationToken.deleteMany.mockResolvedValue({ count: 5 });
      mockPrismaService.tenant.delete.mockResolvedValue({
        id: tenantId,
        name: 'Test Tenant',
        slug: 'test-tenant',
      });

      await service.deleteTenant(tenantId, superAdminUser);

      expect(mockPrismaService.invitationToken.deleteMany).toHaveBeenCalledTimes(1);
      expect(mockPrismaService.invitationToken.deleteMany).toHaveBeenCalledWith({
        where: { tenantId },
      });
    });
  });
});
`````

## File: backend/src/tenants/tenants.service.ts
`````typescript
import { randomBytes, randomUUID } from 'crypto';

import { 
  Injectable, 
  BadRequestException, 
  NotFoundException,
  ConflictException,
  ForbiddenException,
  Logger 
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { UserRole } from '@prisma/client';

import type { RequestUser } from '../auth/auth.types';
import { PasswordService } from '../auth/password.service';
import { EmailService } from '../email/email.service';
import { PrismaService } from '../prisma/prisma.service';

import { CreateTenantDto } from './dto/create-tenant.dto';
import { 
  InviteTenantAdminDto, 
  InviteUserDto, 
  CompleteInvitationDto 
} from './dto/invitation.dto';
import { UpdateTenantDto } from './dto/update-tenant.dto';

/**
 * ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†ã‚µãƒ¼ãƒ“ã‚¹
 * 
 * ãƒãƒ«ãƒãƒ†ãƒŠãƒ³ãƒˆç’°å¢ƒã§ã®ãƒ†ãƒŠãƒ³ãƒˆä½œæˆã€ãƒ¦ãƒ¼ã‚¶ãƒ¼æ‹›å¾…ã€æ‹›å¾…å®Œäº†ã‚’ç®¡ç†ã—ã¾ã™ã€‚
 */
@Injectable()
export class TenantsService {
  private readonly logger = new Logger(TenantsService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly passwordService: PasswordService,
    private readonly jwt: JwtService,
    private readonly emailService: EmailService,
  ) {}

  /**
   * ãƒ†ãƒŠãƒ³ãƒˆä¸€è¦§ã‚’å–å¾—
   * 
   * @returns å…¨ãƒ†ãƒŠãƒ³ãƒˆã®ä¸€è¦§
   */
  async listTenants() {
    const tenants = await this.prisma.tenant.findMany({
      select: {
        id: true,
        name: true,
        slug: true,
        isActive: true,
        createdAt: true,
        updatedAt: true,
      },
      orderBy: { createdAt: 'desc' },
    });

    return {
      success: true,
      data: tenants,
      count: tenants.length,
    };
  }

  /**
   * ãƒ†ãƒŠãƒ³ãƒˆã‚’ä½œæˆ
   * 
   * @param dto ãƒ†ãƒŠãƒ³ãƒˆä½œæˆDTO
   * @returns ä½œæˆã•ã‚ŒãŸãƒ†ãƒŠãƒ³ãƒˆ
   * @throws BadRequestException ã‚¹ãƒ©ãƒƒã‚°ã‚’ç”Ÿæˆã§ããªã‹ã£ãŸå ´åˆ
   * @throws ConflictException ã‚¹ãƒ©ãƒƒã‚°ãŒæ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹å ´åˆ
   */
  async createTenant(dto: CreateTenantDto): Promise<{
    success: true;
    data: { id: string; name: string; slug: string };
  }> {
    // ãƒ†ãƒŠãƒ³ãƒˆã‚¹ãƒ©ãƒƒã‚°ã®ç”Ÿæˆï¼ˆæœªæŒ‡å®šã®å ´åˆï¼‰
    const slug = dto.slug || this.generateSlug(dto.name);

    // ç”Ÿæˆã•ã‚ŒãŸã‚¹ãƒ©ãƒƒã‚°ãŒç©ºã®å ´åˆã¯ã‚¨ãƒ©ãƒ¼
    if (!slug) {
      throw new BadRequestException('ãƒ†ãƒŠãƒ³ãƒˆåã‹ã‚‰ã‚¹ãƒ©ãƒƒã‚°ã‚’ç”Ÿæˆã§ãã¾ã›ã‚“ã§ã—ãŸã€‚åŠè§’è‹±å°æ–‡å­—ãƒ»æ•°å­—ãƒ»ãƒã‚¤ãƒ•ãƒ³ã§æ§‹æˆã•ã‚Œã‚‹ã‚¹ãƒ©ãƒƒã‚°ã‚’æ˜ç¤ºçš„ã«æŒ‡å®šã—ã¦ãã ã•ã„ï¼ˆä¾‹: sample-tenantï¼‰');
    }

    // ã‚¹ãƒ©ãƒƒã‚°ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
    const existingTenant = await this.prisma.tenant.findUnique({
      where: { slug },
    });

    if (existingTenant) {
      throw new ConflictException('ã“ã®ã‚¹ãƒ©ãƒƒã‚°ã¯æ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™');
    }

    // ãƒ†ãƒŠãƒ³ãƒˆä½œæˆ
    const tenant = await this.prisma.tenant.create({
      data: {
        name: dto.name,
        slug,
        isActive: true,
      },
    });

    this.logger.log({
      message: 'Tenant created',
      tenantId: tenant.id,
      tenantName: tenant.name,
      timestamp: new Date().toISOString(),
    });

    return {
      success: true,
      data: {
        id: tenant.id,
        name: tenant.name,
        slug: tenant.slug,
      },
    };
  }

  /**
   * æŒ‡å®š ID ã®ãƒ†ãƒŠãƒ³ãƒˆã‚’å–å¾—
   * 
   * - SUPER_ADMIN: ã™ã¹ã¦ã®ãƒ†ãƒŠãƒ³ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
   * - TENANT_ADMIN: è‡ªãƒ†ãƒŠãƒ³ãƒˆã®ã¿ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
   * 
   * @param tenantId ãƒ†ãƒŠãƒ³ãƒˆ ID
   * @param currentUser ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±
   * @returns ãƒ†ãƒŠãƒ³ãƒˆè©³ç´°
   * @throws NotFoundException ãƒ†ãƒŠãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆ
   * @throws ForbiddenException ã‚¢ã‚¯ã‚»ã‚¹æ¨©ãŒãªã„å ´åˆ
   */
  async getTenantById(tenantId: string, currentUser: RequestUser) {
    // TENANT_ADMIN ã®å ´åˆã€è‡ªãƒ†ãƒŠãƒ³ãƒˆã®ã¿ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
    if (currentUser.role === UserRole.TENANT_ADMIN) {
      if (!currentUser.tenantId) {
        throw new ForbiddenException('ãƒ†ãƒŠãƒ³ãƒˆã«æ‰€å±ã—ã¦ã„ã¾ã›ã‚“');
      }
      if (currentUser.tenantId !== tenantId) {
        throw new ForbiddenException('ä»–ã®ãƒ†ãƒŠãƒ³ãƒˆã®æƒ…å ±ã«ã¯ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“');
      }
    }

    const tenant = await this.prisma.tenant.findUnique({
      where: { id: tenantId },
      select: {
        id: true,
        name: true,
        slug: true,
        isActive: true,
        createdAt: true,
        updatedAt: true,
        _count: {
          select: {
            users: true,
          },
        },
      },
    });

    if (!tenant) {
      throw new NotFoundException('ãƒ†ãƒŠãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    }

    return {
      success: true,
      data: tenant,
    };
  }

  /**
   * SuperAdmin ãŒãƒ†ãƒŠãƒ³ãƒˆç®¡ç†è€…ã‚’æ‹›å¾…
   * 
   * æ–°ã—ã„ãƒ†ãƒŠãƒ³ãƒˆã‚’ä½œæˆã—ã€ç®¡ç†è€…æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç”Ÿæˆã—ã¾ã™ã€‚
   */
  async inviteTenantAdmin(dto: InviteTenantAdminDto): Promise<{
    success: true;
    tenantId: string;
    invitationToken: string;
    message: string;
  }> {
    const email = dto.email.trim().toLowerCase();

    // ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
    const existingUser = await this.prisma.user.findUnique({
      where: { email },
    });

    if (existingUser) {
      throw new ConflictException('ã“ã®ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯æ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™');
    }

    // ãƒ†ãƒŠãƒ³ãƒˆã‚¹ãƒ©ãƒƒã‚°ã®ç”Ÿæˆï¼ˆæœªæŒ‡å®šã®å ´åˆï¼‰
    const slug = dto.tenantSlug || this.generateSlug(dto.tenantName);

    // ã‚¹ãƒ©ãƒƒã‚°ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
    const existingTenant = await this.prisma.tenant.findUnique({
      where: { slug },
    });

    if (existingTenant) {
      throw new ConflictException('ã“ã®ã‚¹ãƒ©ãƒƒã‚°ã¯æ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™');
    }

    // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã§ãƒ†ãƒŠãƒ³ãƒˆã¨æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½œæˆ
    const result = await this.prisma.$transaction(async (tx) => {
      // ãƒ†ãƒŠãƒ³ãƒˆä½œæˆ
      const tenant = await tx.tenant.create({
        data: {
          name: dto.tenantName,
          slug,
          isActive: true,
        },
      });

      // æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆï¼ˆæœ‰åŠ¹æœŸé™: 7æ—¥é–“ï¼‰
      const token = randomBytes(32).toString('hex');
      const expiresAt = new Date();
      expiresAt.setDate(expiresAt.getDate() + 7);

      const invitation = await tx.invitationToken.create({
        data: {
          email,
          token,
          role: UserRole.TENANT_ADMIN,
          tenantId: tenant.id,
          expiresAt,
        },
      });

      return { tenant, invitation };
    });

    this.logger.log({
      message: 'Tenant admin invitation created',
      tenantId: result.tenant.id,
      email,
      timestamp: new Date().toISOString(),
    });

    // æ‹›å¾…ãƒ¡ãƒ¼ãƒ«ã‚’é€ä¿¡
    const emailSent = await this.emailService.sendInvitationEmail(
      email,
      result.invitation.token,
      result.tenant.name,
      UserRole.TENANT_ADMIN,
    );

    if (!emailSent) {
      this.logger.warn(`Failed to send invitation email to ${email}, but invitation was created successfully`);
    }

    // é–‹ç™ºç’°å¢ƒã§ã¯å®‰å…¨ãªå½¢å¼ã§ãƒˆãƒ¼ã‚¯ãƒ³æƒ…å ±ã‚’å‡ºåŠ›
    if (process.env.NODE_ENV !== 'production') {
      const tokenPreview = `${result.invitation.token.substring(0, 8)}...`;
      this.logger.log(`Invitation token created for ${email} (preview: ${tokenPreview})`);
      this.logger.log(`Invitation URL: http://localhost:3000/accept-invitation?token=${result.invitation.token}`);
    }

    return {
      success: true,
      tenantId: result.tenant.id,
      invitationToken: result.invitation.token,
      message: emailSent ? 'æ‹›å¾…ãƒ¡ãƒ¼ãƒ«ã‚’é€ä¿¡ã—ã¾ã—ãŸ' : 'æ‹›å¾…ã‚’ä½œæˆã—ã¾ã—ãŸãŒã€ãƒ¡ãƒ¼ãƒ«é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ',
    };
  }

  /**
   * ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†è€…ãŒãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’æ‹›å¾…
   */
  async inviteUser(
    tenantId: string,
    dto: InviteUserDto,
  ): Promise<{
    success: true;
    invitationToken: string;
    message: string;
  }> {
    const email = dto.email.trim().toLowerCase();

    // ãƒ†ãƒŠãƒ³ãƒˆã®å­˜åœ¨ç¢ºèª
    const tenant = await this.prisma.tenant.findUnique({
      where: { id: tenantId },
    });

    if (!tenant) {
      throw new NotFoundException('ãƒ†ãƒŠãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    }

    if (!tenant.isActive) {
      throw new BadRequestException('ã“ã®ãƒ†ãƒŠãƒ³ãƒˆã¯ç„¡åŠ¹åŒ–ã•ã‚Œã¦ã„ã¾ã™');
    }

    // ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
    const existingUser = await this.prisma.user.findUnique({
      where: { email },
    });

    if (existingUser) {
      throw new ConflictException('ã“ã®ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯æ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™');
    }

    // TENANT_ADMIN ã¯æ‹›å¾…ã§ããªã„ï¼ˆSUPER_ADMIN ã®ã¿å¯èƒ½ï¼‰
    if (dto.role === UserRole.TENANT_ADMIN || dto.role === UserRole.SUPER_ADMIN) {
      throw new BadRequestException('ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†è€…ã¾ãŸã¯ã‚¹ãƒ¼ãƒ‘ãƒ¼ç®¡ç†è€…ã‚’æ‹›å¾…ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“');
    }

    // æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆï¼ˆæœ‰åŠ¹æœŸé™: 7æ—¥é–“ï¼‰
    const token = randomBytes(32).toString('hex');
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 7);

    const invitation = await this.prisma.invitationToken.create({
      data: {
        email,
        token,
        role: dto.role,
        tenantId,
        expiresAt,
      },
    });

    this.logger.log({
      message: 'User invitation created',
      tenantId,
      email,
      role: dto.role,
      timestamp: new Date().toISOString(),
    });

    // æ‹›å¾…ãƒ¡ãƒ¼ãƒ«ã‚’é€ä¿¡
    const emailSent = await this.emailService.sendInvitationEmail(
      email,
      invitation.token,
      tenant.name,
      dto.role,
    );

    if (!emailSent) {
      this.logger.warn(`Failed to send invitation email to ${email}, but invitation was created successfully`);
    }

    // é–‹ç™ºç’°å¢ƒã§ã¯å®‰å…¨ãªå½¢å¼ã§ãƒˆãƒ¼ã‚¯ãƒ³æƒ…å ±ã‚’å‡ºåŠ›
    if (process.env.NODE_ENV !== 'production') {
      const tokenPreview = `${invitation.token.substring(0, 8)}...`;
      this.logger.log(`Invitation token created for ${email} (preview: ${tokenPreview})`);
      this.logger.log(`Invitation URL: http://localhost:3000/accept-invitation?token=${invitation.token}`);
    }

    return {
      success: true,
      invitationToken: invitation.token,
      message: emailSent ? 'æ‹›å¾…ãƒ¡ãƒ¼ãƒ«ã‚’é€ä¿¡ã—ã¾ã—ãŸ' : 'æ‹›å¾…ã‚’ä½œæˆã—ã¾ã—ãŸãŒã€ãƒ¡ãƒ¼ãƒ«é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ',
    };
  }

  /**
   * æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²ã‚’å®Œäº†
   */
  async completeInvitation(dto: CompleteInvitationDto): Promise<{
    success: true;
    userId: string;
    tenantId: string;
    access_token: string;
    message: string;
  }> {
    // ãƒˆãƒ¼ã‚¯ãƒ³ã®æ¤œè¨¼
    const invitation = await this.prisma.invitationToken.findUnique({
      where: { token: dto.token },
      include: { tenant: true },
    });

    if (!invitation) {
      throw new BadRequestException('ç„¡åŠ¹ãªæ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ã§ã™');
    }

    // ãƒˆãƒ¼ã‚¯ãƒ³ã®ä½¿ç”¨æ¸ˆã¿ãƒã‚§ãƒƒã‚¯
    if (invitation.usedAt) {
      throw new BadRequestException('ã“ã®æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ã¯æ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™');
    }

    // ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ‰åŠ¹æœŸé™ãƒã‚§ãƒƒã‚¯
    if (new Date() > invitation.expiresAt) {
      throw new BadRequestException('æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ‰åŠ¹æœŸé™ãŒåˆ‡ã‚Œã¦ã„ã¾ã™');
    }

    // ãƒ†ãƒŠãƒ³ãƒˆã®æœ‰åŠ¹æ€§ãƒã‚§ãƒƒã‚¯
    if (!invitation.tenant.isActive) {
      throw new BadRequestException('ã“ã®ãƒ†ãƒŠãƒ³ãƒˆã¯ç„¡åŠ¹åŒ–ã•ã‚Œã¦ã„ã¾ã™');
    }

    // ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
    const existingUser = await this.prisma.user.findUnique({
      where: { email: invitation.email },
    });

    if (existingUser) {
      throw new ConflictException('ã“ã®ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯æ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™');
    }

    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¼·åº¦ãƒã‚§ãƒƒã‚¯
    const validation = this.passwordService.validatePasswordStrength(dto.password);
    if (!validation.isValid) {
      throw new BadRequestException({
        message: 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒè¦ä»¶ã‚’æº€ãŸã—ã¦ã„ã¾ã›ã‚“',
        errors: validation.errors,
      });
    }

    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥åŒ–
    const passwordHash = await this.passwordService.hashPassword(dto.password);

    // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆã¨æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ä½¿ç”¨æ¸ˆã¿ãƒãƒ¼ã‚¯
    const result = await this.prisma.$transaction(async (tx) => {
      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆ
      const user = await tx.user.create({
        data: {
          email: invitation.email,
          passwordHash,
          role: invitation.role,
          tenantId: invitation.tenantId,
          firstName: dto.firstName,
          lastName: dto.lastName,
          clerkId: `local_${randomUUID()}`,
          isActive: true,
          failedLoginAttempts: 0,
        },
      });

      // æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½¿ç”¨æ¸ˆã¿ã«ãƒãƒ¼ã‚¯
      await tx.invitationToken.update({
        where: { id: invitation.id },
        data: { usedAt: new Date() },
      });

      return user;
    });

    this.logger.log({
      message: 'Invitation completed, user created',
      userId: result.id,
      tenantId: result.tenantId,
      email: result.email,
      role: result.role,
      timestamp: new Date().toISOString(),
    });

    // JWT ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆ
    const accessToken = await this.jwt.signAsync(
      {
        sub: result.id,
        email: result.email,
        role: result.role,
        tenantId: result.tenantId,
        jti: randomUUID(),
      },
      {
        expiresIn: '15m',
        secret: process.env.JWT_SECRET,
      },
    );

    return {
      success: true,
      userId: result.id,
      tenantId: result.tenantId!,
      access_token: accessToken,
      message: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²ãŒå®Œäº†ã—ã¾ã—ãŸ',
    };
  }

  /**
   * ãƒ†ãƒŠãƒ³ãƒˆåã‹ã‚‰ã‚¹ãƒ©ãƒƒã‚°ã‚’ç”Ÿæˆ
   * 
   * @private
   */
  private generateSlug(name: string): string {
    return name
      .toLowerCase()
      .replace(/[^a-z0-9\s-]/g, '') // è‹±æ•°å­—ã¨ã‚¹ãƒšãƒ¼ã‚¹ã€ãƒã‚¤ãƒ•ãƒ³ã®ã¿
      .replace(/\s+/g, '-') // ã‚¹ãƒšãƒ¼ã‚¹ã‚’ãƒã‚¤ãƒ•ãƒ³ã«
      .replace(/-+/g, '-') // é€£ç¶šã™ã‚‹ãƒã‚¤ãƒ•ãƒ³ã‚’1ã¤ã«
      .replace(/^-|-$/g, ''); // å…ˆé ­ã¨æœ«å°¾ã®ãƒã‚¤ãƒ•ãƒ³ã‚’å‰Šé™¤
  }

  /**
   * ãƒ†ãƒŠãƒ³ãƒˆã‚’æ›´æ–°
   * SUPER_ADMIN ã®ã¿ãŒå®Ÿè¡Œå¯èƒ½
   * 
   * @param tenantId ãƒ†ãƒŠãƒ³ãƒˆ ID
   * @param dto æ›´æ–° DTO
   * @param currentUser ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±
   * @returns æ›´æ–°å¾Œã®ãƒ†ãƒŠãƒ³ãƒˆ
   * @throws NotFoundException ãƒ†ãƒŠãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆ
   * @throws ConflictException ã‚¹ãƒ©ãƒƒã‚°ãŒé‡è¤‡ã—ã¦ã„ã‚‹å ´åˆ
   */
  async updateTenant(tenantId: string, dto: UpdateTenantDto, currentUser: RequestUser) {
    // SUPER_ADMIN ã®ã¿æ›´æ–°å¯èƒ½
    if (currentUser.role !== UserRole.SUPER_ADMIN) {
      throw new ForbiddenException('ãƒ†ãƒŠãƒ³ãƒˆã‚’æ›´æ–°ã™ã‚‹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“');
    }

    // ãƒ†ãƒŠãƒ³ãƒˆã®å­˜åœ¨ç¢ºèª
    const tenant = await this.prisma.tenant.findUnique({
      where: { id: tenantId },
    });

    if (!tenant) {
      throw new NotFoundException('ãƒ†ãƒŠãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    }

    // ã‚¹ãƒ©ãƒƒã‚°å¤‰æ›´æ™‚ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
    if (dto.slug && dto.slug !== tenant.slug) {
      const existingTenant = await this.prisma.tenant.findUnique({
        where: { slug: dto.slug },
      });

      if (existingTenant) {
        throw new ConflictException('ã“ã®ã‚¹ãƒ©ãƒƒã‚°ã¯æ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™');
      }
    }

    // æ›´æ–°ãƒ‡ãƒ¼ã‚¿ã®æ§‹ç¯‰
    const updateData: { name?: string; slug?: string; isActive?: boolean } = {};
    if (dto.name !== undefined) updateData.name = dto.name;
    if (dto.slug !== undefined) updateData.slug = dto.slug;
    if (dto.isActive !== undefined) updateData.isActive = dto.isActive;

    // ãƒ†ãƒŠãƒ³ãƒˆæ›´æ–°
    const updatedTenant = await this.prisma.tenant.update({
      where: { id: tenantId },
      data: updateData,
      select: {
        id: true,
        name: true,
        slug: true,
        isActive: true,
        createdAt: true,
        updatedAt: true,
      },
    });

    this.logger.log({
      message: 'Tenant updated',
      tenantId: updatedTenant.id,
      updatedFields: Object.keys(updateData),
      timestamp: new Date().toISOString(),
    });

    return {
      success: true,
      data: updatedTenant,
    };
  }

  /**
   * ãƒ†ãƒŠãƒ³ãƒˆã‚’å‰Šé™¤
   * SUPER_ADMIN ã®ã¿ãŒå®Ÿè¡Œå¯èƒ½
   * æ‰€å±ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã„ã‚‹å ´åˆã¯å‰Šé™¤ä¸å¯
   * 
   * @param tenantId ãƒ†ãƒŠãƒ³ãƒˆ ID
   * @param currentUser ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±
   * @returns å‰Šé™¤çµæœ
   * @throws NotFoundException ãƒ†ãƒŠãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆ
   * @throws ForbiddenException æ¨©é™ãŒãªã„å ´åˆ
   * @throws ConflictException æ‰€å±ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå­˜åœ¨ã™ã‚‹å ´åˆ
   */
  async deleteTenant(tenantId: string, currentUser: RequestUser) {
    // SUPER_ADMIN ã®ã¿å‰Šé™¤å¯èƒ½
    if (currentUser.role !== UserRole.SUPER_ADMIN) {
      throw new ForbiddenException('ãƒ†ãƒŠãƒ³ãƒˆã‚’å‰Šé™¤ã™ã‚‹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“');
    }

    // ãƒ†ãƒŠãƒ³ãƒˆã®å­˜åœ¨ç¢ºèªã¨æ‰€å±ãƒ¦ãƒ¼ã‚¶ãƒ¼æ•°ã‚’å–å¾—
    const tenant = await this.prisma.tenant.findUnique({
      where: { id: tenantId },
      include: {
        _count: {
          select: {
            users: true,
          },
        },
      },
    });

    if (!tenant) {
      throw new NotFoundException('ãƒ†ãƒŠãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    }

    // æ‰€å±ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã„ã‚‹å ´åˆã¯å‰Šé™¤ä¸å¯
    if (tenant._count.users > 0) {
      throw new ConflictException(
        `ã“ã®ãƒ†ãƒŠãƒ³ãƒˆã«ã¯${tenant._count.users}äººã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ‰€å±ã—ã¦ã„ã‚‹ãŸã‚å‰Šé™¤ã§ãã¾ã›ã‚“ã€‚å…ˆã«ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å‰Šé™¤ã—ã¦ãã ã•ã„ã€‚`
      );
    }

    // é–¢é€£ã™ã‚‹æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å‰Šé™¤
    await this.prisma.invitationToken.deleteMany({
      where: { tenantId },
    });

    // ãƒ†ãƒŠãƒ³ãƒˆå‰Šé™¤
    await this.prisma.tenant.delete({
      where: { id: tenantId },
    });

    this.logger.log({
      message: 'Tenant deleted',
      tenantId,
      deletedBy: currentUser.userId,
      timestamp: new Date().toISOString(),
    });

    return {
      success: true,
      message: 'ãƒ†ãƒŠãƒ³ãƒˆã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
    };
  }
}
`````

## File: backend/src/test-utils/test-module-setup.ts
`````typescript
import { CanActivate } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { APP_GUARD } from '@nestjs/core';

/**
 * No-op guard for unit tests that don't need real rate limiting or authentication
 * ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã§ä½¿ç”¨ã™ã‚‹ãƒ€ãƒŸãƒ¼ã‚¬ãƒ¼ãƒ‰
 */
export class NoopGuard implements CanActivate {
  canActivate(): boolean {
    return true;
  }
}

/**
 * Common test module configuration for controller tests
 * ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãƒ†ã‚¹ãƒˆç”¨ã®å…±é€šãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«è¨­å®š
 * 
 * Usage:
 * ```typescript
 * import { getTestModuleImports, getTestModuleProviders } from '../test-utils/test-module-setup';
 * 
 * const module: TestingModule = await Test.createTestingModule({
 *   imports: getTestModuleImports(),
 *   controllers: [YourController],
 *   providers: [
 *     ...getTestModuleProviders(),
 *     { provide: YourService, useValue: mockYourService },
 *   ],
 * }).compile();
 * ```
 */

/**
 * Get common module imports for test modules
 * ãƒ†ã‚¹ãƒˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ç”¨ã®å…±é€šã‚¤ãƒ³ãƒãƒ¼ãƒˆ
 */
export function getTestModuleImports() {
  return [
    ConfigModule.forRoot({
      isGlobal: true,
    }),
  ];
}

/**
 * Get common providers for test modules
 * ãƒ†ã‚¹ãƒˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ç”¨ã®å…±é€šãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼
 */
export function getTestModuleProviders() {
  return [
    {
      provide: APP_GUARD,
      useClass: NoopGuard,
    },
  ];
}
`````

## File: backend/src/upload/upload.module.ts
`````typescript
import { Module } from "@nestjs/common";

@Module({
  controllers: [],
  providers: [],
})
export class UploadModule {}
`````

## File: backend/src/users/dto/invite-user.dto.ts
`````typescript
import { ApiProperty } from '@nestjs/swagger';
import { UserRole } from '@prisma/client';
import { IsEmail, IsEnum, IsNotEmpty, IsUUID } from 'class-validator';

/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼æ‹›å¾… DTO
 * 
 * SUPER_ADMIN: ä»»æ„ã®ãƒ†ãƒŠãƒ³ãƒˆã« TENANT_ADMIN / ADMIN / USER ã‚’æ‹›å¾…å¯èƒ½
 * TENANT_ADMIN: è‡ªãƒ†ãƒŠãƒ³ãƒˆã«ã®ã¿ ADMIN / USER ã‚’æ‹›å¾…å¯èƒ½
 */
export class InviteUserDto {
  @ApiProperty({ 
    description: 'æ‹›å¾…ã™ã‚‹ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹', 
    example: 'user@example.com' 
  })
  @IsEmail({}, { message: 'æœ‰åŠ¹ãªãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„' })
  @IsNotEmpty({ message: 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯å¿…é ˆã§ã™' })
  email: string;

  @ApiProperty({ 
    description: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«', 
    enum: UserRole,
    example: UserRole.USER 
  })
  @IsEnum(UserRole, { message: 'æœ‰åŠ¹ãªãƒ­ãƒ¼ãƒ«ã‚’æŒ‡å®šã—ã¦ãã ã•ã„' })
  role: UserRole;

  @ApiProperty({ 
    description: 'æ‹›å¾…å…ˆãƒ†ãƒŠãƒ³ãƒˆ ID', 
    example: '123e4567-e89b-12d3-a456-426614174000' 
  })
  @IsUUID('4', { message: 'æœ‰åŠ¹ãªãƒ†ãƒŠãƒ³ãƒˆ ID ã‚’æŒ‡å®šã—ã¦ãã ã•ã„' })
  @IsNotEmpty({ message: 'ãƒ†ãƒŠãƒ³ãƒˆ ID ã¯å¿…é ˆã§ã™' })
  tenantId: string;
}
`````

## File: backend/src/users/dto/update-profile.dto.ts
`````typescript
import { ApiPropertyOptional } from '@nestjs/swagger';
import { IsEmail, IsOptional, IsString, MaxLength } from 'class-validator';

/**
 * ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«æ›´æ–° DTO
 * 
 * èªè¨¼ã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè‡ªèº«ã®ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«æƒ…å ±ã‚’æ›´æ–°ã™ã‚‹ãŸã‚ã®DTO
 * ã™ã¹ã¦ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ï¼ˆæ›´æ–°ã—ãŸã„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ã¿é€ä¿¡å¯èƒ½ï¼‰
 */
export class UpdateProfileDto {
  @ApiPropertyOptional({
    description: 'å',
    example: 'å¤ªéƒ',
    maxLength: 100,
  })
  @IsOptional()
  @IsString({ message: 'åã¯æ–‡å­—åˆ—ã§å…¥åŠ›ã—ã¦ãã ã•ã„' })
  @MaxLength(100, { message: 'åã¯100æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„' })
  firstName?: string;

  @ApiPropertyOptional({
    description: 'å§“',
    example: 'å±±ç”°',
    maxLength: 100,
  })
  @IsOptional()
  @IsString({ message: 'å§“ã¯æ–‡å­—åˆ—ã§å…¥åŠ›ã—ã¦ãã ã•ã„' })
  @MaxLength(100, { message: 'å§“ã¯100æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„' })
  lastName?: string;

  @ApiPropertyOptional({
    description: 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹',
    example: 'user@example.com',
  })
  @IsOptional()
  @IsEmail({}, { message: 'æœ‰åŠ¹ãªãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„' })
  email?: string;
}
`````

## File: backend/src/users/dto/update-user-role.dto.ts
`````typescript
import { ApiProperty } from '@nestjs/swagger';
import { UserRole } from '@prisma/client';
import { IsEnum } from 'class-validator';

/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«å¤‰æ›´ DTO
 * 
 * SUPER_ADMIN: ä»»æ„ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ­ãƒ¼ãƒ«ã‚’å¤‰æ›´å¯èƒ½ï¼ˆè‡ªåˆ†è‡ªèº«ã¨SUPER_ADMINé™æ ¼ã¯ä¸å¯ï¼‰
 * TENANT_ADMIN: è‡ªãƒ†ãƒŠãƒ³ãƒˆã® ADMIN â†” USER ã®ã¿å¤‰æ›´å¯èƒ½
 */
export class UpdateUserRoleDto {
  @ApiProperty({ 
    description: 'æ–°ã—ã„ãƒ­ãƒ¼ãƒ«', 
    enum: UserRole,
    example: UserRole.ADMIN 
  })
  @IsEnum(UserRole, { message: 'æœ‰åŠ¹ãªãƒ­ãƒ¼ãƒ«ã‚’æŒ‡å®šã—ã¦ãã ã•ã„' })
  role: UserRole;
}
`````

## File: backend/src/users/users.controller.ts
`````typescript
import { 
  Controller, 
  Get, 
  Post,
  Patch,
  Delete,
  Body,
  Param,
  Query, 
  UseGuards,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiBearerAuth, ApiQuery, ApiParam } from '@nestjs/swagger';
import { UserRole } from '@prisma/client';

import type { RequestUser } from '../auth/auth.types';
import { GetUser } from '../auth/get-user.decorator';
import { JwtAuthGuard } from '../auth/jwt-auth.guard';
import { RoleGuard } from '../auth/role.guard';
import { Roles } from '../auth/roles.decorator';

import { InviteUserDto } from './dto/invite-user.dto';
import { UpdateProfileDto } from './dto/update-profile.dto';
import { UpdateUserRoleDto } from './dto/update-user-role.dto';
import { UsersService } from './users.service';

/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç†ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©
 * 
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§å–å¾—ãªã©ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’æä¾›ã—ã¾ã™ã€‚
 */
@ApiTags('users')
@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  /**
   * ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§å–å¾—
   * 
   * - SUPER_ADMIN: å…¨ãƒ†ãƒŠãƒ³ãƒˆã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å–å¾—å¯èƒ½ï¼ˆtenantId ã§ãƒ•ã‚£ãƒ«ã‚¿å¯èƒ½ï¼‰
   * - TENANT_ADMIN: è‡ªãƒ†ãƒŠãƒ³ãƒˆã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã¿å–å¾—å¯èƒ½
   */
  @Get()
  @UseGuards(JwtAuthGuard, RoleGuard)
  @Roles(UserRole.SUPER_ADMIN, UserRole.TENANT_ADMIN)
  @ApiBearerAuth()
  @ApiOperation({ 
    summary: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§å–å¾—',
    description: 'SUPER_ADMINã¯å…¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ã€TENANT_ADMINã¯è‡ªãƒ†ãƒŠãƒ³ãƒˆã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å–å¾—ã—ã¾ã™ã€‚' 
  })
  @ApiQuery({ 
    name: 'tenantId', 
    required: false, 
    description: 'ãƒ†ãƒŠãƒ³ãƒˆ ID ã§ãƒ•ã‚£ãƒ«ã‚¿ï¼ˆSUPER_ADMIN ã®ã¿æœ‰åŠ¹ï¼‰' 
  })
  @ApiResponse({ status: 200, description: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§ã‚’è¿”å´' })
  @ApiResponse({ status: 401, description: 'èªè¨¼ãŒå¿…è¦ã§ã™' })
  @ApiResponse({ status: 403, description: 'æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“' })
  async listUsers(
    @GetUser() user: RequestUser,
    @Query('tenantId') tenantId?: string,
  ) {
    return this.usersService.listUsers(user, tenantId);
  }

  /**
   * è‡ªèº«ã®ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«å–å¾—
   * 
   * JWTã§èªè¨¼ã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼è‡ªèº«ã®ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«æƒ…å ±ã‚’å–å¾—ã—ã¾ã™ã€‚
   */
  @Get('me')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @ApiOperation({ 
    summary: 'è‡ªèº«ã®ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«å–å¾—',
    description: 'JWTã§èªè¨¼ã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼è‡ªèº«ã®ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«æƒ…å ±ã‚’å–å¾—ã—ã¾ã™ã€‚' 
  })
  @ApiResponse({ status: 200, description: 'ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«æƒ…å ±ã‚’è¿”å´' })
  @ApiResponse({ status: 401, description: 'èªè¨¼ãŒå¿…è¦ã§ã™' })
  @ApiResponse({ status: 404, description: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“' })
  async getMe(@GetUser() user: RequestUser) {
    return this.usersService.getProfile(user);
  }

  /**
   * è‡ªèº«ã®ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«æ›´æ–°
   * 
   * JWTã§èªè¨¼ã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼è‡ªèº«ã®ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«æƒ…å ±ã‚’æ›´æ–°ã—ã¾ã™ã€‚
   * å„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ï¼ˆæ›´æ–°ã—ãŸã„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ã¿é€ä¿¡å¯èƒ½ï¼‰ã€‚
   * ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒå¤‰æ›´ã•ã‚Œã‚‹å ´åˆã¯é‡è¤‡ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã„ã¾ã™ã€‚
   */
  @Patch('me')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @ApiOperation({ 
    summary: 'è‡ªèº«ã®ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«æ›´æ–°',
    description: 'JWTã§èªè¨¼ã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼è‡ªèº«ã®ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«æƒ…å ±ã‚’æ›´æ–°ã—ã¾ã™ã€‚å„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ã§ã™ã€‚' 
  })
  @ApiResponse({ status: 200, description: 'ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ãŒæ›´æ–°ã•ã‚Œã¾ã—ãŸ' })
  @ApiResponse({ status: 400, description: 'æ›´æ–°ã™ã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“' })
  @ApiResponse({ status: 401, description: 'èªè¨¼ãŒå¿…è¦ã§ã™' })
  @ApiResponse({ status: 409, description: 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒæ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™' })
  async updateMe(
    @GetUser() user: RequestUser,
    @Body() dto: UpdateProfileDto,
  ) {
    return this.usersService.updateProfile(user, dto);
  }

  /**
   * åˆå› SUPER_ADMIN æ˜‡æ ¼
   * 
   * DB ä¸Šã« SUPER_ADMIN ãŒå­˜åœ¨ã—ãªã„å ´åˆã®ã¿ã€ç¾åœ¨ã®ãƒ­ã‚°ã‚¤ãƒ³ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ SUPER_ADMIN ã«æ˜‡æ ¼ã—ã¾ã™ã€‚
   */
  @Post('promote-to-superadmin-once')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @ApiOperation({ 
    summary: 'åˆå› SUPER_ADMIN æ˜‡æ ¼',
    description: 'SUPER_ADMIN ãŒã¾ã å­˜åœ¨ã—ãªã„å ´åˆã®ã¿ã€ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ SUPER_ADMIN ã«æ˜‡æ ¼ã—ã¾ã™ã€‚' 
  })
  @ApiResponse({ status: 200, description: 'æ˜‡æ ¼æˆåŠŸ' })
  @ApiResponse({ status: 401, description: 'èªè¨¼ãŒå¿…è¦ã§ã™' })
  @ApiResponse({ status: 403, description: 'SUPER_ADMIN ã¯ã™ã§ã«å­˜åœ¨ã—ã¾ã™' })
  async promoteToSuperAdminOnce(@GetUser() user: RequestUser) {
    return this.usersService.promoteToSuperAdminOnce(user);
  }

  /**
   * ãƒ¦ãƒ¼ã‚¶ãƒ¼æ‹›å¾…
   * 
   * - SUPER_ADMIN: ä»»æ„ã®ãƒ†ãƒŠãƒ³ãƒˆã« TENANT_ADMIN / ADMIN / USER ã‚’æ‹›å¾…å¯èƒ½
   * - TENANT_ADMIN: è‡ªãƒ†ãƒŠãƒ³ãƒˆã«ã®ã¿ ADMIN / USER ã‚’æ‹›å¾…å¯èƒ½
   */
  @Post('invite')
  @UseGuards(JwtAuthGuard, RoleGuard)
  @Roles(UserRole.SUPER_ADMIN, UserRole.TENANT_ADMIN)
  @ApiBearerAuth()
  @HttpCode(HttpStatus.CREATED)
  @ApiOperation({ 
    summary: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼æ‹›å¾…',
    description: 'SUPER_ADMINã¯ä»»æ„ã®ãƒ†ãƒŠãƒ³ãƒˆã€TENANT_ADMINã¯è‡ªãƒ†ãƒŠãƒ³ãƒˆã«ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’æ‹›å¾…ã—ã¾ã™ã€‚' 
  })
  @ApiResponse({ status: 201, description: 'æ‹›å¾…ãŒä½œæˆã•ã‚Œã¾ã—ãŸ' })
  @ApiResponse({ status: 401, description: 'èªè¨¼ãŒå¿…è¦ã§ã™' })
  @ApiResponse({ status: 403, description: 'æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“' })
  @ApiResponse({ status: 404, description: 'ãƒ†ãƒŠãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“' })
  @ApiResponse({ status: 409, description: 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒæ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™' })
  async inviteUser(
    @GetUser() user: RequestUser,
    @Body() dto: InviteUserDto,
  ) {
    return this.usersService.inviteUser(user, dto);
  }

  /**
   * ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«å¤‰æ›´
   * 
   * - SUPER_ADMIN: ä»»æ„ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ­ãƒ¼ãƒ«ã‚’å¤‰æ›´å¯èƒ½ï¼ˆè‡ªåˆ†è‡ªèº«ã¨ SUPER_ADMIN é™æ ¼ã¯ä¸å¯ï¼‰
   * - TENANT_ADMIN: è‡ªãƒ†ãƒŠãƒ³ãƒˆã® ADMIN â†” USER ã®ã¿å¤‰æ›´å¯èƒ½
   */
  @Patch(':id/role')
  @UseGuards(JwtAuthGuard, RoleGuard)
  @Roles(UserRole.SUPER_ADMIN, UserRole.TENANT_ADMIN)
  @ApiBearerAuth()
  @ApiOperation({ 
    summary: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«å¤‰æ›´',
    description: 'SUPER_ADMINã¯ä»»æ„ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã€TENANT_ADMINã¯è‡ªãƒ†ãƒŠãƒ³ãƒˆã®ADMIN/USERã®ãƒ­ãƒ¼ãƒ«ã‚’å¤‰æ›´ã—ã¾ã™ã€‚' 
  })
  @ApiParam({ name: 'id', description: 'å¯¾è±¡ãƒ¦ãƒ¼ã‚¶ãƒ¼ ID' })
  @ApiResponse({ status: 200, description: 'ãƒ­ãƒ¼ãƒ«ãŒæ›´æ–°ã•ã‚Œã¾ã—ãŸ' })
  @ApiResponse({ status: 401, description: 'èªè¨¼ãŒå¿…è¦ã§ã™' })
  @ApiResponse({ status: 403, description: 'æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“' })
  @ApiResponse({ status: 404, description: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“' })
  async updateUserRole(
    @GetUser() user: RequestUser,
    @Param('id') id: string,
    @Body() dto: UpdateUserRoleDto,
  ) {
    return this.usersService.updateUserRole(user, id, dto);
  }

  /**
   * ãƒ¦ãƒ¼ã‚¶ãƒ¼å‰Šé™¤
   * 
   * - SUPER_ADMIN: ä»»æ„ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å‰Šé™¤å¯èƒ½ï¼ˆè‡ªåˆ†è‡ªèº«ã¨ä»–ã® SUPER_ADMIN ã¯å‰Šé™¤ä¸å¯ï¼‰
   * - TENANT_ADMIN: è‡ªãƒ†ãƒŠãƒ³ãƒˆã® ADMIN / USER ã®ã¿å‰Šé™¤å¯èƒ½
   */
  @Delete(':id')
  @UseGuards(JwtAuthGuard, RoleGuard)
  @Roles(UserRole.SUPER_ADMIN, UserRole.TENANT_ADMIN)
  @ApiBearerAuth()
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ 
    summary: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼å‰Šé™¤',
    description: 'SUPER_ADMINã¯ä»»æ„ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ï¼ˆè‡ªåˆ†ã¨ä»–ã®SUPER_ADMINã‚’é™¤ãï¼‰ã€TENANT_ADMINã¯è‡ªãƒ†ãƒŠãƒ³ãƒˆã®ADMIN/USERã‚’å‰Šé™¤ã—ã¾ã™ã€‚' 
  })
  @ApiParam({ name: 'id', description: 'å¯¾è±¡ãƒ¦ãƒ¼ã‚¶ãƒ¼ ID' })
  @ApiResponse({ status: 200, description: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå‰Šé™¤ã•ã‚Œã¾ã—ãŸ' })
  @ApiResponse({ status: 401, description: 'èªè¨¼ãŒå¿…è¦ã§ã™' })
  @ApiResponse({ status: 403, description: 'æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“' })
  @ApiResponse({ status: 404, description: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“' })
  async deleteUser(
    @GetUser() user: RequestUser,
    @Param('id') id: string,
  ) {
    return this.usersService.deleteUser(user, id);
  }
}
`````

## File: backend/src/users/users.module.ts
`````typescript
import { Module } from "@nestjs/common";

import { EmailModule } from "../email/email.module";
import { PrismaModule } from "../prisma/prisma.module";

import { UsersController } from "./users.controller";
import { UsersService } from "./users.service";

@Module({
  imports: [PrismaModule, EmailModule],
  controllers: [UsersController],
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {}
`````

## File: backend/src/users/users.service.spec.ts
`````typescript
import { 
  ForbiddenException,
  ConflictException,
  NotFoundException,
  BadRequestException,
} from '@nestjs/common';
import { Test, TestingModule } from '@nestjs/testing';
import { UserRole } from '@prisma/client';

import type { RequestUser } from '../auth/auth.types';
import { EmailService } from '../email/email.service';
import { PrismaService } from '../prisma/prisma.service';

import { InviteUserDto } from './dto/invite-user.dto';
import { UpdateUserRoleDto } from './dto/update-user-role.dto';
import { UsersService } from './users.service';

describe('UsersService', () => {
  let service: UsersService;

  // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å†…ã§ä½¿ç”¨ã•ã‚Œã‚‹ãƒ¢ãƒƒã‚¯
  const mockTxUser = {
    count: jest.fn(),
    update: jest.fn(),
  };

  const mockPrismaService = {
    user: {
      findMany: jest.fn(),
      findUnique: jest.fn(),
      findFirst: jest.fn(),
      count: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
    },
    tenant: {
      findUnique: jest.fn(),
    },
    invitationToken: {
      create: jest.fn(),
    },
    $transaction: jest.fn((callback: (tx: { user: typeof mockTxUser }) => Promise<unknown>) => {
      return callback({ user: mockTxUser });
    }),
  };

  const mockEmailService = {
    sendInvitationEmail: jest.fn().mockResolvedValue(true),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        UsersService,
        {
          provide: PrismaService,
          useValue: mockPrismaService,
        },
        {
          provide: EmailService,
          useValue: mockEmailService,
        },
      ],
    }).compile();

    service = module.get<UsersService>(UsersService);

    jest.clearAllMocks();
    // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ¢ãƒƒã‚¯ã‚‚ã‚¯ãƒªã‚¢
    mockTxUser.count.mockClear();
    mockTxUser.update.mockClear();
    mockPrismaService.tenant.findUnique.mockClear();
    mockPrismaService.user.findUnique.mockClear();
    mockPrismaService.user.findFirst.mockClear();
    mockPrismaService.invitationToken.create.mockClear();
    mockEmailService.sendInvitationEmail.mockClear();
  });

  describe('listUsers', () => {
    const mockUsers = [
      {
        id: 'user-1',
        email: 'user1@example.com',
        firstName: 'User',
        lastName: 'One',
        role: UserRole.USER,
        isActive: true,
        tenantId: 'tenant-1',
        createdAt: new Date(),
        updatedAt: new Date(),
        lastLoginAt: null,
      },
      {
        id: 'user-2',
        email: 'user2@example.com',
        firstName: 'User',
        lastName: 'Two',
        role: UserRole.USER,
        isActive: true,
        tenantId: 'tenant-1',
        createdAt: new Date(),
        updatedAt: new Date(),
        lastLoginAt: null,
      },
    ];

    describe('SUPER_ADMIN ã¨ã—ã¦', () => {
      const superAdminUser: RequestUser = {
        userId: 'super-admin-1',
        email: 'superadmin@example.com',
        role: UserRole.SUPER_ADMIN,
        tenantId: undefined,
      };

      it('å…¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å–å¾—ã§ãã‚‹', async () => {
        mockPrismaService.user.findMany.mockResolvedValue(mockUsers);

        const result = await service.listUsers(superAdminUser);

        expect(result.success).toBe(true);
        expect(result.data).toEqual(mockUsers);
        expect(result.count).toBe(2);
        expect(mockPrismaService.user.findMany).toHaveBeenCalledWith({
          where: undefined,
          select: expect.any(Object),
          orderBy: { createdAt: 'desc' },
        });
      });

      it('tenantId ã§ãƒ•ã‚£ãƒ«ã‚¿ã§ãã‚‹', async () => {
        mockPrismaService.user.findMany.mockResolvedValue(mockUsers);

        const result = await service.listUsers(superAdminUser, 'tenant-1');

        expect(result.success).toBe(true);
        expect(mockPrismaService.user.findMany).toHaveBeenCalledWith({
          where: { tenantId: 'tenant-1' },
          select: expect.any(Object),
          orderBy: { createdAt: 'desc' },
        });
      });
    });

    describe('TENANT_ADMIN ã¨ã—ã¦', () => {
      const tenantAdminUser: RequestUser = {
        userId: 'tenant-admin-1',
        email: 'tenantadmin@example.com',
        role: UserRole.TENANT_ADMIN,
        tenantId: 'tenant-1',
      };

      it('è‡ªãƒ†ãƒŠãƒ³ãƒˆã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å–å¾—ã§ãã‚‹', async () => {
        mockPrismaService.user.findMany.mockResolvedValue(mockUsers);

        const result = await service.listUsers(tenantAdminUser);

        expect(result.success).toBe(true);
        expect(result.data).toEqual(mockUsers);
        expect(result.count).toBe(2);
        expect(mockPrismaService.user.findMany).toHaveBeenCalledWith({
          where: { tenantId: 'tenant-1' },
          select: expect.any(Object),
          orderBy: { createdAt: 'desc' },
        });
      });

      it('è‡ªãƒ†ãƒŠãƒ³ãƒˆã® tenantId ã‚’æŒ‡å®šã—ã¦ã‚‚å–å¾—ã§ãã‚‹', async () => {
        mockPrismaService.user.findMany.mockResolvedValue(mockUsers);

        const result = await service.listUsers(tenantAdminUser, 'tenant-1');

        expect(result.success).toBe(true);
        expect(result.count).toBe(2);
      });

      it('ä»–ã®ãƒ†ãƒŠãƒ³ãƒˆ ID ã‚’æŒ‡å®šã™ã‚‹ã¨ã‚¨ãƒ©ãƒ¼', async () => {
        await expect(
          service.listUsers(tenantAdminUser, 'tenant-2'),
        ).rejects.toThrow(ForbiddenException);
        await expect(
          service.listUsers(tenantAdminUser, 'tenant-2'),
        ).rejects.toThrow('ä»–ã®ãƒ†ãƒŠãƒ³ãƒˆã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§ã«ã¯ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“');
      });

      it('ãƒ†ãƒŠãƒ³ãƒˆã«æ‰€å±ã—ã¦ã„ãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼', async () => {
        const noTenantAdminUser: RequestUser = {
          userId: 'tenant-admin-2',
          email: 'tenantadmin2@example.com',
          role: UserRole.TENANT_ADMIN,
          tenantId: undefined,
        };

        await expect(service.listUsers(noTenantAdminUser)).rejects.toThrow(
          ForbiddenException,
        );
        await expect(service.listUsers(noTenantAdminUser)).rejects.toThrow(
          'ãƒ†ãƒŠãƒ³ãƒˆã«æ‰€å±ã—ã¦ã„ã¾ã›ã‚“',
        );
      });
    });

    describe('æ¨©é™ã®ãªã„ãƒ­ãƒ¼ãƒ«ã¨ã—ã¦', () => {
      it('USER ãƒ­ãƒ¼ãƒ«ã¯ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã„', async () => {
        const regularUser: RequestUser = {
          userId: 'user-1',
          email: 'user@example.com',
          role: UserRole.USER,
          tenantId: 'tenant-1',
        };

        await expect(service.listUsers(regularUser)).rejects.toThrow(
          ForbiddenException,
        );
        await expect(service.listUsers(regularUser)).rejects.toThrow(
          'ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§ã®å–å¾—æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“',
        );
      });

      it('ADMIN ãƒ­ãƒ¼ãƒ«ã¯ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã„', async () => {
        const adminUser: RequestUser = {
          userId: 'admin-1',
          email: 'admin@example.com',
          role: UserRole.ADMIN,
          tenantId: 'tenant-1',
        };

        await expect(service.listUsers(adminUser)).rejects.toThrow(
          ForbiddenException,
        );
        await expect(service.listUsers(adminUser)).rejects.toThrow(
          'ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§ã®å–å¾—æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“',
        );
      });

      it('ãƒ­ãƒ¼ãƒ«ãŒæœªè¨­å®šã®å ´åˆã¯ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã„', async () => {
        const noRoleUser: RequestUser = {
          userId: 'user-no-role',
          email: 'norole@example.com',
          role: undefined,
          tenantId: 'tenant-1',
        };

        await expect(service.listUsers(noRoleUser)).rejects.toThrow(
          ForbiddenException,
        );
        await expect(service.listUsers(noRoleUser)).rejects.toThrow(
          'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“',
        );
      });
    });
  });

  describe('promoteToSuperAdminOnce', () => {
    const regularUser: RequestUser = {
      userId: 'user-1',
      email: 'user@example.com',
      role: UserRole.USER,
      tenantId: 'tenant-1',
    };

    describe('SUPER_ADMIN ãŒã¾ã å­˜åœ¨ã—ãªã„å ´åˆ', () => {
      it('ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ SUPER_ADMIN ã«æ˜‡æ ¼ã§ãã‚‹', async () => {
        mockTxUser.count.mockResolvedValue(0);
        mockTxUser.update.mockResolvedValue({
          id: regularUser.userId,
          email: regularUser.email,
          role: UserRole.SUPER_ADMIN,
        });

        const result = await service.promoteToSuperAdminOnce(regularUser);

        expect(result.success).toBe(true);
        expect(result.data.id).toBe(regularUser.userId);
        expect(result.data.email).toBe(regularUser.email);
        expect(result.data.role).toBe(UserRole.SUPER_ADMIN);

        expect(mockTxUser.count).toHaveBeenCalledWith({
          where: { role: UserRole.SUPER_ADMIN },
        });
        expect(mockTxUser.update).toHaveBeenCalledWith({
          where: { id: regularUser.userId },
          data: { role: UserRole.SUPER_ADMIN },
          select: {
            id: true,
            email: true,
            role: true,
          },
        });
      });
    });

    describe('SUPER_ADMIN ãŒã™ã§ã«å­˜åœ¨ã™ã‚‹å ´åˆ', () => {
      it('ForbiddenException ã‚’æŠ•ã’ã‚‹', async () => {
        mockTxUser.count.mockResolvedValue(1);

        await expect(service.promoteToSuperAdminOnce(regularUser)).rejects.toThrow(
          ForbiddenException,
        );
        await expect(service.promoteToSuperAdminOnce(regularUser)).rejects.toThrow(
          'SUPER_ADMINã¯ã™ã§ã«å­˜åœ¨ã—ã¾ã™',
        );
      });

      it('prisma.user.update ãŒå‘¼ã°ã‚Œãªã„ã“ã¨ã‚’ç¢ºèª', async () => {
        mockTxUser.count.mockResolvedValue(2);

        await expect(service.promoteToSuperAdminOnce(regularUser)).rejects.toThrow(
          ForbiddenException,
        );

        expect(mockTxUser.update).not.toHaveBeenCalled();
      });
    });
  });

  describe('inviteUser', () => {
    const superAdminUser: RequestUser = {
      userId: 'super-admin-1',
      email: 'superadmin@example.com',
      role: UserRole.SUPER_ADMIN,
      tenantId: undefined,
    };

    const tenantAdminUser: RequestUser = {
      userId: 'tenant-admin-1',
      email: 'tenantadmin@example.com',
      role: UserRole.TENANT_ADMIN,
      tenantId: 'tenant-1',
    };

    const mockTenant = {
      id: 'tenant-1',
      name: 'Test Tenant',
      slug: 'test-tenant',
      isActive: true,
    };

    const mockInvitation = {
      id: 'invitation-1',
      email: 'newuser@example.com',
      token: 'mock-token-123',
      role: UserRole.USER,
      tenantId: 'tenant-1',
      expiresAt: new Date(),
    };

    describe('SUPER_ADMIN ã¨ã—ã¦', () => {
      it('ä»»æ„ã®ãƒ†ãƒŠãƒ³ãƒˆã«ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’æ‹›å¾…ã§ãã‚‹', async () => {
        const dto: InviteUserDto = {
          email: 'newuser@example.com',
          role: UserRole.USER,
          tenantId: 'tenant-1',
        };

        mockPrismaService.tenant.findUnique.mockResolvedValue(mockTenant);
        mockPrismaService.user.findUnique.mockResolvedValue(null);
        mockPrismaService.invitationToken.create.mockResolvedValue(mockInvitation);

        const result = await service.inviteUser(superAdminUser, dto);

        expect(result.success).toBe(true);
        expect(result.tenantId).toBe('tenant-1');
        expect(result.message).toBe('æ‹›å¾…ãƒ¡ãƒ¼ãƒ«ã‚’é€ä¿¡ã—ã¾ã—ãŸ');
        expect(mockPrismaService.tenant.findUnique).toHaveBeenCalledWith({
          where: { id: 'tenant-1' },
        });
        expect(mockPrismaService.invitationToken.create).toHaveBeenCalled();
        expect(mockEmailService.sendInvitationEmail).toHaveBeenCalledWith(
          'newuser@example.com',
          'mock-token-123',
          'Test Tenant',
          UserRole.USER,
        );
      });

      it('TENANT_ADMIN ã‚’æ‹›å¾…ã§ãã‚‹', async () => {
        const dto: InviteUserDto = {
          email: 'newadmin@example.com',
          role: UserRole.TENANT_ADMIN,
          tenantId: 'tenant-1',
        };

        mockPrismaService.tenant.findUnique.mockResolvedValue(mockTenant);
        mockPrismaService.user.findUnique.mockResolvedValue(null);
        mockPrismaService.invitationToken.create.mockResolvedValue({
          ...mockInvitation,
          role: UserRole.TENANT_ADMIN,
        });

        const result = await service.inviteUser(superAdminUser, dto);

        expect(result.success).toBe(true);
      });
    });

    describe('TENANT_ADMIN ã¨ã—ã¦', () => {
      it('è‡ªãƒ†ãƒŠãƒ³ãƒˆã« ADMIN ã‚’æ‹›å¾…ã§ãã‚‹', async () => {
        const dto: InviteUserDto = {
          email: 'newadmin@example.com',
          role: UserRole.ADMIN,
          tenantId: 'tenant-1',
        };

        mockPrismaService.tenant.findUnique.mockResolvedValue(mockTenant);
        mockPrismaService.user.findUnique.mockResolvedValue(null);
        mockPrismaService.invitationToken.create.mockResolvedValue({
          ...mockInvitation,
          role: UserRole.ADMIN,
        });

        const result = await service.inviteUser(tenantAdminUser, dto);

        expect(result.success).toBe(true);
        expect(result.tenantId).toBe('tenant-1');
      });

      it('è‡ªãƒ†ãƒŠãƒ³ãƒˆã« USER ã‚’æ‹›å¾…ã§ãã‚‹', async () => {
        const dto: InviteUserDto = {
          email: 'newuser@example.com',
          role: UserRole.USER,
          tenantId: 'tenant-1',
        };

        mockPrismaService.tenant.findUnique.mockResolvedValue(mockTenant);
        mockPrismaService.user.findUnique.mockResolvedValue(null);
        mockPrismaService.invitationToken.create.mockResolvedValue(mockInvitation);

        const result = await service.inviteUser(tenantAdminUser, dto);

        expect(result.success).toBe(true);
      });

      it('TENANT_ADMIN ã‚’æ‹›å¾…ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ 403', async () => {
        const dto: InviteUserDto = {
          email: 'newadmin@example.com',
          role: UserRole.TENANT_ADMIN,
          tenantId: 'tenant-1',
        };

        await expect(service.inviteUser(tenantAdminUser, dto)).rejects.toThrow(
          ForbiddenException,
        );
        await expect(service.inviteUser(tenantAdminUser, dto)).rejects.toThrow(
          'SUPER_ADMIN ã¾ãŸã¯ TENANT_ADMIN ã‚’æ‹›å¾…ã™ã‚‹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“',
        );
      });

      it('SUPER_ADMIN ã‚’æ‹›å¾…ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ 403', async () => {
        const dto: InviteUserDto = {
          email: 'newsuperadmin@example.com',
          role: UserRole.SUPER_ADMIN,
          tenantId: 'tenant-1',
        };

        await expect(service.inviteUser(tenantAdminUser, dto)).rejects.toThrow(
          ForbiddenException,
        );
        await expect(service.inviteUser(tenantAdminUser, dto)).rejects.toThrow(
          'SUPER_ADMIN ã¾ãŸã¯ TENANT_ADMIN ã‚’æ‹›å¾…ã™ã‚‹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“',
        );
      });

      it('ä»–ãƒ†ãƒŠãƒ³ãƒˆã«æ‹›å¾…ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ 403', async () => {
        const dto: InviteUserDto = {
          email: 'newuser@example.com',
          role: UserRole.USER,
          tenantId: 'tenant-2',
        };

        await expect(service.inviteUser(tenantAdminUser, dto)).rejects.toThrow(
          ForbiddenException,
        );
        await expect(service.inviteUser(tenantAdminUser, dto)).rejects.toThrow(
          'ä»–ã®ãƒ†ãƒŠãƒ³ãƒˆã«ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’æ‹›å¾…ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“',
        );
      });
    });

    describe('å…±é€šã‚¨ãƒ©ãƒ¼ã‚±ãƒ¼ã‚¹', () => {
      it('æ—¢å­˜ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã„ã‚‹å ´åˆã¯ 409', async () => {
        const dto: InviteUserDto = {
          email: 'existing@example.com',
          role: UserRole.USER,
          tenantId: 'tenant-1',
        };

        mockPrismaService.tenant.findUnique.mockResolvedValue(mockTenant);
        mockPrismaService.user.findUnique.mockResolvedValue({
          id: 'existing-user',
          email: 'existing@example.com',
        });

        await expect(service.inviteUser(superAdminUser, dto)).rejects.toThrow(
          ConflictException,
        );
        await expect(service.inviteUser(superAdminUser, dto)).rejects.toThrow(
          'ã“ã®ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯æ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™',
        );
      });

      it('ãƒ†ãƒŠãƒ³ãƒˆãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ 404', async () => {
        const dto: InviteUserDto = {
          email: 'newuser@example.com',
          role: UserRole.USER,
          tenantId: 'non-existent-tenant',
        };

        mockPrismaService.tenant.findUnique.mockResolvedValue(null);

        await expect(service.inviteUser(superAdminUser, dto)).rejects.toThrow(
          NotFoundException,
        );
        await expect(service.inviteUser(superAdminUser, dto)).rejects.toThrow(
          'æŒ‡å®šã•ã‚ŒãŸãƒ†ãƒŠãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“',
        );
      });
    });
  });

  describe('updateUserRole', () => {
    const superAdminUser: RequestUser = {
      userId: 'super-admin-1',
      email: 'superadmin@example.com',
      role: UserRole.SUPER_ADMIN,
      tenantId: undefined,
    };

    const tenantAdminUser: RequestUser = {
      userId: 'tenant-admin-1',
      email: 'tenantadmin@example.com',
      role: UserRole.TENANT_ADMIN,
      tenantId: 'tenant-1',
    };

    const mockUser = {
      id: 'user-1',
      email: 'user@example.com',
      role: UserRole.USER,
      tenantId: 'tenant-1',
    };

    const mockAdmin = {
      id: 'admin-1',
      email: 'admin@example.com',
      role: UserRole.ADMIN,
      tenantId: 'tenant-1',
    };

    const mockSuperAdmin = {
      id: 'super-admin-2',
      email: 'superadmin2@example.com',
      role: UserRole.SUPER_ADMIN,
      tenantId: undefined,
    };

    const mockTenantAdmin = {
      id: 'tenant-admin-2',
      email: 'tenantadmin2@example.com',
      role: UserRole.TENANT_ADMIN,
      tenantId: 'tenant-1',
    };

    describe('SUPER_ADMIN ã¨ã—ã¦', () => {
      it('ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ­ãƒ¼ãƒ«ã‚’å¤‰æ›´ã§ãã‚‹', async () => {
        const dto: UpdateUserRoleDto = { role: UserRole.ADMIN };

        mockPrismaService.user.findUnique.mockResolvedValue(mockUser);
        mockPrismaService.user.update.mockResolvedValue({
          ...mockUser,
          role: UserRole.ADMIN,
        });

        const result = await service.updateUserRole(superAdminUser, 'user-1', dto);

        expect(result.success).toBe(true);
        expect(result.data.role).toBe(UserRole.ADMIN);
        expect(result.message).toBe('ãƒ­ãƒ¼ãƒ«ã‚’æ›´æ–°ã—ã¾ã—ãŸ');
      });

      it('SUPER_ADMIN ã‚’é™æ ¼ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ 403', async () => {
        const dto: UpdateUserRoleDto = { role: UserRole.ADMIN };

        mockPrismaService.user.findUnique.mockResolvedValue(mockSuperAdmin);

        await expect(
          service.updateUserRole(superAdminUser, 'super-admin-2', dto),
        ).rejects.toThrow(ForbiddenException);
        await expect(
          service.updateUserRole(superAdminUser, 'super-admin-2', dto),
        ).rejects.toThrow('SUPER_ADMIN ã‚’é™æ ¼ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“');
      });

      it('è‡ªåˆ†è‡ªèº«ã®ãƒ­ãƒ¼ãƒ«ã‚’å¤‰æ›´ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ 403', async () => {
        const dto: UpdateUserRoleDto = { role: UserRole.ADMIN };

        mockPrismaService.user.findUnique.mockResolvedValue({
          id: 'super-admin-1',
          email: 'superadmin@example.com',
          role: UserRole.SUPER_ADMIN,
        });

        await expect(
          service.updateUserRole(superAdminUser, 'super-admin-1', dto),
        ).rejects.toThrow(ForbiddenException);
        await expect(
          service.updateUserRole(superAdminUser, 'super-admin-1', dto),
        ).rejects.toThrow('è‡ªåˆ†è‡ªèº«ã®ãƒ­ãƒ¼ãƒ«ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“');
      });
    });

    describe('TENANT_ADMIN ã¨ã—ã¦', () => {
      it('è‡ªãƒ†ãƒŠãƒ³ãƒˆã® ADMIN ã‚’ USER ã«å¤‰æ›´ã§ãã‚‹', async () => {
        const dto: UpdateUserRoleDto = { role: UserRole.USER };

        mockPrismaService.user.findUnique.mockResolvedValue(mockAdmin);
        mockPrismaService.user.update.mockResolvedValue({
          ...mockAdmin,
          role: UserRole.USER,
        });

        const result = await service.updateUserRole(tenantAdminUser, 'admin-1', dto);

        expect(result.success).toBe(true);
        expect(result.data.role).toBe(UserRole.USER);
      });

      it('è‡ªãƒ†ãƒŠãƒ³ãƒˆã® USER ã‚’ ADMIN ã«å¤‰æ›´ã§ãã‚‹', async () => {
        const dto: UpdateUserRoleDto = { role: UserRole.ADMIN };

        mockPrismaService.user.findUnique.mockResolvedValue(mockUser);
        mockPrismaService.user.update.mockResolvedValue({
          ...mockUser,
          role: UserRole.ADMIN,
        });

        const result = await service.updateUserRole(tenantAdminUser, 'user-1', dto);

        expect(result.success).toBe(true);
        expect(result.data.role).toBe(UserRole.ADMIN);
      });

      it('ä»–ãƒ†ãƒŠãƒ³ãƒˆã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å¤‰æ›´ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ 403', async () => {
        const dto: UpdateUserRoleDto = { role: UserRole.ADMIN };

        const otherTenantUser = {
          ...mockUser,
          tenantId: 'tenant-2',
        };
        mockPrismaService.user.findUnique.mockResolvedValue(otherTenantUser);

        await expect(
          service.updateUserRole(tenantAdminUser, 'user-1', dto),
        ).rejects.toThrow(ForbiddenException);
        await expect(
          service.updateUserRole(tenantAdminUser, 'user-1', dto),
        ).rejects.toThrow('ä»–ã®ãƒ†ãƒŠãƒ³ãƒˆã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ­ãƒ¼ãƒ«ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“');
      });

      it('SUPER_ADMIN ã‚’å¤‰æ›´ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ 403', async () => {
        const dto: UpdateUserRoleDto = { role: UserRole.ADMIN };

        const superAdminInTenant = {
          ...mockSuperAdmin,
          tenantId: 'tenant-1',
        };
        mockPrismaService.user.findUnique.mockResolvedValue(superAdminInTenant);

        await expect(
          service.updateUserRole(tenantAdminUser, 'super-admin-2', dto),
        ).rejects.toThrow(ForbiddenException);
        await expect(
          service.updateUserRole(tenantAdminUser, 'super-admin-2', dto),
        ).rejects.toThrow(
          'SUPER_ADMIN ã¾ãŸã¯ TENANT_ADMIN ã®ãƒ­ãƒ¼ãƒ«ã‚’å¤‰æ›´ã™ã‚‹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“',
        );
      });

      it('TENANT_ADMIN ã‚’å¤‰æ›´ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ 403', async () => {
        const dto: UpdateUserRoleDto = { role: UserRole.USER };

        mockPrismaService.user.findUnique.mockResolvedValue(mockTenantAdmin);

        await expect(
          service.updateUserRole(tenantAdminUser, 'tenant-admin-2', dto),
        ).rejects.toThrow(ForbiddenException);
        await expect(
          service.updateUserRole(tenantAdminUser, 'tenant-admin-2', dto),
        ).rejects.toThrow(
          'SUPER_ADMIN ã¾ãŸã¯ TENANT_ADMIN ã®ãƒ­ãƒ¼ãƒ«ã‚’å¤‰æ›´ã™ã‚‹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“',
        );
      });

      it('SUPER_ADMIN ã«å¤‰æ›´ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ 403', async () => {
        const dto: UpdateUserRoleDto = { role: UserRole.SUPER_ADMIN };

        mockPrismaService.user.findUnique.mockResolvedValue(mockUser);

        await expect(
          service.updateUserRole(tenantAdminUser, 'user-1', dto),
        ).rejects.toThrow(ForbiddenException);
        await expect(
          service.updateUserRole(tenantAdminUser, 'user-1', dto),
        ).rejects.toThrow('SUPER_ADMIN ã¾ãŸã¯ TENANT_ADMIN ã«å¤‰æ›´ã™ã‚‹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“');
      });

      it('TENANT_ADMIN ã«å¤‰æ›´ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ 403', async () => {
        const dto: UpdateUserRoleDto = { role: UserRole.TENANT_ADMIN };

        mockPrismaService.user.findUnique.mockResolvedValue(mockUser);

        await expect(
          service.updateUserRole(tenantAdminUser, 'user-1', dto),
        ).rejects.toThrow(ForbiddenException);
        await expect(
          service.updateUserRole(tenantAdminUser, 'user-1', dto),
        ).rejects.toThrow('SUPER_ADMIN ã¾ãŸã¯ TENANT_ADMIN ã«å¤‰æ›´ã™ã‚‹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“');
      });
    });

    describe('å…±é€šã‚¨ãƒ©ãƒ¼ã‚±ãƒ¼ã‚¹', () => {
      it('ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ 404', async () => {
        const dto: UpdateUserRoleDto = { role: UserRole.ADMIN };

        mockPrismaService.user.findUnique.mockResolvedValue(null);

        await expect(
          service.updateUserRole(superAdminUser, 'non-existent-user', dto),
        ).rejects.toThrow(NotFoundException);
        await expect(
          service.updateUserRole(superAdminUser, 'non-existent-user', dto),
        ).rejects.toThrow('æŒ‡å®šã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
      });
    });
  });

  describe('getProfile', () => {
    const regularUser: RequestUser = {
      userId: 'user-1',
      email: 'user@example.com',
      role: UserRole.USER,
      tenantId: 'tenant-1',
    };

    const mockUserProfile = {
      id: 'user-1',
      email: 'user@example.com',
      firstName: 'User',
      lastName: 'Test',
      role: UserRole.USER,
    };

    it('ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå­˜åœ¨ã™ã‚‹å ´åˆã€ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«æƒ…å ±ã‚’æ­£å¸¸ã«å–å¾—ã§ãã‚‹', async () => {
      mockPrismaService.user.findUnique.mockResolvedValue(mockUserProfile);

      const result = await service.getProfile(regularUser);

      expect(result.success).toBe(true);
      expect(result.data).toEqual(mockUserProfile);
      expect(mockPrismaService.user.findUnique).toHaveBeenCalledWith({
        where: { id: regularUser.userId },
        select: {
          id: true,
          email: true,
          firstName: true,
          lastName: true,
          role: true,
        },
      });
    });

    it('ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå­˜åœ¨ã—ãªã„å ´åˆã€NotFoundException ãŒã‚¹ãƒ­ãƒ¼ã•ã‚Œã‚‹', async () => {
      mockPrismaService.user.findUnique.mockResolvedValue(null);

      await expect(service.getProfile(regularUser)).rejects.toThrow(
        NotFoundException,
      );
      await expect(service.getProfile(regularUser)).rejects.toThrow(
        'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“',
      );
    });
  });

  describe('updateProfile', () => {
    const regularUser: RequestUser = {
      userId: 'user-1',
      email: 'user@example.com',
      role: UserRole.USER,
      tenantId: 'tenant-1',
    };

    const mockUpdatedUser = {
      id: 'user-1',
      email: 'newemail@example.com',
      firstName: 'NewFirst',
      lastName: 'NewLast',
      role: UserRole.USER,
    };

    it('firstName, lastName, email ã‚’æ­£å¸¸ã«æ›´æ–°ã§ãã‚‹', async () => {
      const dto = {
        firstName: 'NewFirst',
        lastName: 'NewLast',
        email: 'newemail@example.com',
      };

      mockPrismaService.user.findFirst.mockResolvedValue(null);
      mockPrismaService.user.update.mockResolvedValue(mockUpdatedUser);

      const result = await service.updateProfile(regularUser, dto);

      expect(result.success).toBe(true);
      expect(result.data).toEqual(mockUpdatedUser);
      expect(result.message).toBe('ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã‚’æ›´æ–°ã—ã¾ã—ãŸ');
      expect(mockPrismaService.user.update).toHaveBeenCalledWith({
        where: { id: regularUser.userId },
        data: {
          firstName: 'NewFirst',
          lastName: 'NewLast',
          email: 'newemail@example.com',
        },
        select: {
          id: true,
          email: true,
          firstName: true,
          lastName: true,
          role: true,
        },
      });
    });

    it('firstName ã®ã¿ã‚’æ›´æ–°ã§ãã‚‹', async () => {
      const dto = { firstName: 'NewFirst' };

      mockPrismaService.user.update.mockResolvedValue({
        ...mockUpdatedUser,
        firstName: 'NewFirst',
      });

      const result = await service.updateProfile(regularUser, dto);

      expect(result.success).toBe(true);
      expect(mockPrismaService.user.update).toHaveBeenCalledWith({
        where: { id: regularUser.userId },
        data: { firstName: 'NewFirst' },
        select: expect.any(Object),
      });
    });

    it('ç©ºã®DTOã®å ´åˆã€BadRequestException ãŒã‚¹ãƒ­ãƒ¼ã•ã‚Œã‚‹', async () => {
      const dto = {};

      await expect(service.updateProfile(regularUser, dto)).rejects.toThrow(
        BadRequestException,
      );
      await expect(service.updateProfile(regularUser, dto)).rejects.toThrow(
        'æ›´æ–°ã™ã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“',
      );
    });

    it('æ—¢å­˜ã®ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æŒ‡å®šã—ãŸå ´åˆã€ConflictException ãŒã‚¹ãƒ­ãƒ¼ã•ã‚Œã‚‹', async () => {
      const dto = { email: 'existing@example.com' };

      mockPrismaService.user.findFirst.mockResolvedValue({
        id: 'other-user',
        email: 'existing@example.com',
      });

      await expect(service.updateProfile(regularUser, dto)).rejects.toThrow(
        ConflictException,
      );
      await expect(service.updateProfile(regularUser, dto)).rejects.toThrow(
        'ã“ã®ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯æ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™',
      );
    });

    it('ç©ºã®ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æŒ‡å®šã—ãŸå ´åˆã€BadRequestException ãŒã‚¹ãƒ­ãƒ¼ã•ã‚Œã‚‹', async () => {
      const dto = { email: '' };

      await expect(service.updateProfile(regularUser, dto)).rejects.toThrow(
        BadRequestException,
      );
      await expect(service.updateProfile(regularUser, dto)).rejects.toThrow(
        'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ç©ºã«ã§ãã¾ã›ã‚“',
      );
    });

    it('ç©ºç™½ã®ã¿ã®ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æŒ‡å®šã—ãŸå ´åˆã€BadRequestException ãŒã‚¹ãƒ­ãƒ¼ã•ã‚Œã‚‹', async () => {
      const dto = { email: '   ' };

      await expect(service.updateProfile(regularUser, dto)).rejects.toThrow(
        BadRequestException,
      );
      await expect(service.updateProfile(regularUser, dto)).rejects.toThrow(
        'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ç©ºã«ã§ãã¾ã›ã‚“',
      );
    });

    it('ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒæ­£è¦åŒ–ã•ã‚Œã‚‹ï¼ˆtrim + toLowerCaseï¼‰', async () => {
      const dto = { email: '  Test@Example.COM  ' };

      mockPrismaService.user.findFirst.mockResolvedValue(null);
      mockPrismaService.user.update.mockResolvedValue({
        ...mockUpdatedUser,
        email: 'test@example.com',
      });

      await service.updateProfile(regularUser, dto);

      expect(mockPrismaService.user.update).toHaveBeenCalledWith({
        where: { id: regularUser.userId },
        data: { email: 'test@example.com' },
        select: expect.any(Object),
      });
    });

    it('ç©ºæ–‡å­—åˆ—ã§ firstName/lastName ã‚’å‰Šé™¤ã§ãã‚‹', async () => {
      const dto = { firstName: '', lastName: '' };

      mockPrismaService.user.update.mockResolvedValue({
        ...mockUpdatedUser,
        firstName: '',
        lastName: '',
      });

      const result = await service.updateProfile(regularUser, dto);

      expect(result.success).toBe(true);
      expect(mockPrismaService.user.update).toHaveBeenCalledWith({
        where: { id: regularUser.userId },
        data: { firstName: '', lastName: '' },
        select: expect.any(Object),
      });
    });
  });

  describe('deleteUser', () => {
    const superAdminUser: RequestUser = {
      userId: 'super-admin-1',
      email: 'superadmin@example.com',
      role: UserRole.SUPER_ADMIN,
      tenantId: undefined,
    };

    const tenantAdminUser: RequestUser = {
      userId: 'tenant-admin-1',
      email: 'tenantadmin@example.com',
      role: UserRole.TENANT_ADMIN,
      tenantId: 'tenant-1',
    };

    const mockUser = {
      id: 'user-1',
      email: 'user@example.com',
      role: UserRole.USER,
      tenantId: 'tenant-1',
    };

    const mockAdmin = {
      id: 'admin-1',
      email: 'admin@example.com',
      role: UserRole.ADMIN,
      tenantId: 'tenant-1',
    };

    const mockSuperAdmin = {
      id: 'super-admin-2',
      email: 'superadmin2@example.com',
      role: UserRole.SUPER_ADMIN,
      tenantId: undefined,
    };

    const mockTenantAdmin = {
      id: 'tenant-admin-2',
      email: 'tenantadmin2@example.com',
      role: UserRole.TENANT_ADMIN,
      tenantId: 'tenant-1',
    };

    describe('SUPER_ADMIN ã¨ã—ã¦', () => {
      it('è‡ªåˆ†è‡ªèº«ã‚’å‰Šé™¤ã—ã‚ˆã†ã¨ã—ãŸå ´åˆã¯æ‹’å¦ã•ã‚Œã‚‹', async () => {
        mockPrismaService.user.findUnique.mockResolvedValue({
          id: 'super-admin-1',
          email: 'superadmin@example.com',
          role: UserRole.SUPER_ADMIN,
          tenantId: undefined,
        });

        await expect(
          service.deleteUser(superAdminUser, 'super-admin-1'),
        ).rejects.toThrow(ForbiddenException);
        await expect(
          service.deleteUser(superAdminUser, 'super-admin-1'),
        ).rejects.toThrow('è‡ªåˆ†è‡ªèº«ã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“');

        expect(mockPrismaService.user.delete).not.toHaveBeenCalled();
      });

      it('ä»–ã® SUPER_ADMIN ã‚’å‰Šé™¤ã—ã‚ˆã†ã¨ã—ãŸå ´åˆã¯æ‹’å¦ã•ã‚Œã‚‹', async () => {
        mockPrismaService.user.findUnique.mockResolvedValue(mockSuperAdmin);

        await expect(
          service.deleteUser(superAdminUser, 'super-admin-2'),
        ).rejects.toThrow(ForbiddenException);
        await expect(
          service.deleteUser(superAdminUser, 'super-admin-2'),
        ).rejects.toThrow('SUPER_ADMIN ã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“');

        expect(mockPrismaService.user.delete).not.toHaveBeenCalled();
      });

      it('TENANT_ADMIN ã‚’å‰Šé™¤ã§ãã‚‹', async () => {
        mockPrismaService.user.findUnique.mockResolvedValue(mockTenantAdmin);
        mockPrismaService.user.delete.mockResolvedValue(mockTenantAdmin);

        const result = await service.deleteUser(superAdminUser, 'tenant-admin-2');

        expect(result.success).toBe(true);
        expect(result.message).toBe('ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å‰Šé™¤ã—ã¾ã—ãŸ');
        expect(mockPrismaService.user.delete).toHaveBeenCalledWith({
          where: { id: 'tenant-admin-2' },
        });
      });

      it('ADMIN ã‚’å‰Šé™¤ã§ãã‚‹', async () => {
        mockPrismaService.user.findUnique.mockResolvedValue(mockAdmin);
        mockPrismaService.user.delete.mockResolvedValue(mockAdmin);

        const result = await service.deleteUser(superAdminUser, 'admin-1');

        expect(result.success).toBe(true);
        expect(result.message).toBe('ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å‰Šé™¤ã—ã¾ã—ãŸ');
        expect(mockPrismaService.user.delete).toHaveBeenCalledWith({
          where: { id: 'admin-1' },
        });
      });

      it('USER ã‚’å‰Šé™¤ã§ãã‚‹', async () => {
        mockPrismaService.user.findUnique.mockResolvedValue(mockUser);
        mockPrismaService.user.delete.mockResolvedValue(mockUser);

        const result = await service.deleteUser(superAdminUser, 'user-1');

        expect(result.success).toBe(true);
        expect(result.message).toBe('ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å‰Šé™¤ã—ã¾ã—ãŸ');
        expect(mockPrismaService.user.delete).toHaveBeenCalledWith({
          where: { id: 'user-1' },
        });
      });
    });

    describe('TENANT_ADMIN ã¨ã—ã¦', () => {
      it('è‡ªãƒ†ãƒŠãƒ³ãƒˆã® ADMIN ã‚’å‰Šé™¤ã§ãã‚‹', async () => {
        mockPrismaService.user.findUnique.mockResolvedValue(mockAdmin);
        mockPrismaService.user.delete.mockResolvedValue(mockAdmin);

        const result = await service.deleteUser(tenantAdminUser, 'admin-1');

        expect(result.success).toBe(true);
        expect(result.message).toBe('ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å‰Šé™¤ã—ã¾ã—ãŸ');
        expect(mockPrismaService.user.delete).toHaveBeenCalledWith({
          where: { id: 'admin-1' },
        });
      });

      it('è‡ªãƒ†ãƒŠãƒ³ãƒˆã® USER ã‚’å‰Šé™¤ã§ãã‚‹', async () => {
        mockPrismaService.user.findUnique.mockResolvedValue(mockUser);
        mockPrismaService.user.delete.mockResolvedValue(mockUser);

        const result = await service.deleteUser(tenantAdminUser, 'user-1');

        expect(result.success).toBe(true);
        expect(result.message).toBe('ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å‰Šé™¤ã—ã¾ã—ãŸ');
        expect(mockPrismaService.user.delete).toHaveBeenCalledWith({
          where: { id: 'user-1' },
        });
      });

      it('SUPER_ADMIN ã‚’å‰Šé™¤ã—ã‚ˆã†ã¨ã—ãŸå ´åˆã¯æ‹’å¦ã•ã‚Œã‚‹', async () => {
        const superAdminInTenant = {
          ...mockSuperAdmin,
          tenantId: 'tenant-1',
        };
        mockPrismaService.user.findUnique.mockResolvedValue(superAdminInTenant);

        await expect(
          service.deleteUser(tenantAdminUser, 'super-admin-2'),
        ).rejects.toThrow(ForbiddenException);
        await expect(
          service.deleteUser(tenantAdminUser, 'super-admin-2'),
        ).rejects.toThrow('SUPER_ADMIN ã¾ãŸã¯ TENANT_ADMIN ã‚’å‰Šé™¤ã™ã‚‹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“');

        expect(mockPrismaService.user.delete).not.toHaveBeenCalled();
      });

      it('TENANT_ADMIN ã‚’å‰Šé™¤ã—ã‚ˆã†ã¨ã—ãŸå ´åˆã¯æ‹’å¦ã•ã‚Œã‚‹', async () => {
        mockPrismaService.user.findUnique.mockResolvedValue(mockTenantAdmin);

        await expect(
          service.deleteUser(tenantAdminUser, 'tenant-admin-2'),
        ).rejects.toThrow(ForbiddenException);
        await expect(
          service.deleteUser(tenantAdminUser, 'tenant-admin-2'),
        ).rejects.toThrow('SUPER_ADMIN ã¾ãŸã¯ TENANT_ADMIN ã‚’å‰Šé™¤ã™ã‚‹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“');

        expect(mockPrismaService.user.delete).not.toHaveBeenCalled();
      });

      it('ä»–ãƒ†ãƒŠãƒ³ãƒˆã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å‰Šé™¤ã—ã‚ˆã†ã¨ã—ãŸå ´åˆã¯æ‹’å¦ã•ã‚Œã‚‹', async () => {
        const otherTenantUser = {
          ...mockUser,
          tenantId: 'tenant-2',
        };
        mockPrismaService.user.findUnique.mockResolvedValue(otherTenantUser);

        await expect(
          service.deleteUser(tenantAdminUser, 'user-1'),
        ).rejects.toThrow(ForbiddenException);
        await expect(
          service.deleteUser(tenantAdminUser, 'user-1'),
        ).rejects.toThrow('ä»–ã®ãƒ†ãƒŠãƒ³ãƒˆã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“');

        expect(mockPrismaService.user.delete).not.toHaveBeenCalled();
      });
    });

    describe('å…±é€šã‚¨ãƒ©ãƒ¼ã‚±ãƒ¼ã‚¹', () => {
      it('å­˜åœ¨ã—ãªã„ãƒ¦ãƒ¼ã‚¶ãƒ¼ ID ã‚’æŒ‡å®šã—ãŸå ´åˆã¯ã‚¨ãƒ©ãƒ¼', async () => {
        mockPrismaService.user.findUnique.mockResolvedValue(null);

        await expect(
          service.deleteUser(superAdminUser, 'non-existent-user'),
        ).rejects.toThrow(NotFoundException);
        await expect(
          service.deleteUser(superAdminUser, 'non-existent-user'),
        ).rejects.toThrow('æŒ‡å®šã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');

        expect(mockPrismaService.user.delete).not.toHaveBeenCalled();
      });

      it('ãƒ­ãƒ¼ãƒ«ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã‚¢ã‚¯ã‚»ã‚¹æ‹’å¦', async () => {
        const userWithoutRole: RequestUser = {
          userId: 'user-1',
          email: 'user@example.com',
          role: undefined as any,
          tenantId: 'tenant-1',
        };

        await expect(
          service.deleteUser(userWithoutRole, 'user-2'),
        ).rejects.toThrow(ForbiddenException);
        await expect(
          service.deleteUser(userWithoutRole, 'user-2'),
        ).rejects.toThrow('ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');

        expect(mockPrismaService.user.findUnique).not.toHaveBeenCalled();
        expect(mockPrismaService.user.delete).not.toHaveBeenCalled();
      });

      it('ADMIN ã¾ãŸã¯ USER ãƒ­ãƒ¼ãƒ«ã®å ´åˆã¯ã‚¢ã‚¯ã‚»ã‚¹æ‹’å¦', async () => {
        const adminUser: RequestUser = {
          userId: 'admin-1',
          email: 'admin@example.com',
          role: UserRole.ADMIN,
          tenantId: 'tenant-1',
        };

        mockPrismaService.user.findUnique.mockResolvedValue(mockUser);

        await expect(
          service.deleteUser(adminUser, 'user-1'),
        ).rejects.toThrow(ForbiddenException);
        await expect(
          service.deleteUser(adminUser, 'user-1'),
        ).rejects.toThrow('ãƒ¦ãƒ¼ã‚¶ãƒ¼å‰Šé™¤ã®æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“');

        expect(mockPrismaService.user.delete).not.toHaveBeenCalled();
      });
    });
  });
});
`````

## File: backend/src/users/users.service.ts
`````typescript
import { randomBytes } from 'crypto';

import { 
  Injectable, 
  Logger, 
  ForbiddenException,
  ConflictException,
  NotFoundException,
  BadRequestException,
} from '@nestjs/common';
import { UserRole } from '@prisma/client';

import type { RequestUser } from '../auth/auth.types';
import { EmailService } from '../email/email.service';
import { PrismaService } from '../prisma/prisma.service';

import { InviteUserDto } from './dto/invite-user.dto';
import { UpdateProfileDto } from './dto/update-profile.dto';
import { UpdateUserRoleDto } from './dto/update-user-role.dto';

/** æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ã®ãƒã‚¤ãƒˆã‚µã‚¤ã‚º */
const INVITATION_TOKEN_BYTES = 32;
/** æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ‰åŠ¹æœŸé™ï¼ˆæ—¥æ•°ï¼‰ */
const INVITATION_EXPIRY_DAYS = 7;

export interface PromoteToSuperAdminResponse {
  success: true;
  data: {
    id: string;
    email: string;
    role: UserRole;
  };
}

/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«æƒ…å ±ã®å…±é€šå‹
 */
export interface UserProfileData {
  id: string;
  email: string;
  firstName: string | null;
  lastName: string | null;
  role: UserRole;
}

/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç†ã‚µãƒ¼ãƒ“ã‚¹
 * 
 * ãƒãƒ«ãƒãƒ†ãƒŠãƒ³ãƒˆç’°å¢ƒã§ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§å–å¾—æ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™ã€‚
 */
@Injectable()
export class UsersService {
  private readonly logger = new Logger(UsersService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly emailService: EmailService,
  ) {}

  /**
   * æŒ‡å®šã•ã‚ŒãŸãƒ­ãƒ¼ãƒ«ãŒé«˜æ¨©é™ãƒ­ãƒ¼ãƒ«ï¼ˆSUPER_ADMIN, TENANT_ADMINï¼‰ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
   * 
   * @private
   */
  private isPrivilegedRole(role: UserRole): boolean {
    return role === UserRole.SUPER_ADMIN || role === UserRole.TENANT_ADMIN;
  }

  /**
   * ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§ã‚’å–å¾—
   * 
   * - SUPER_ADMIN: å…¨ãƒ†ãƒŠãƒ³ãƒˆã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å–å¾—å¯èƒ½
   * - TENANT_ADMIN: è‡ªãƒ†ãƒŠãƒ³ãƒˆã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã¿å–å¾—å¯èƒ½
   * 
   * @param currentUser ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±
   * @param tenantId ãƒ•ã‚£ãƒ«ã‚¿ã™ã‚‹ãƒ†ãƒŠãƒ³ãƒˆ IDï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
   * @returns ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§
   */
  async listUsers(currentUser: RequestUser, tenantId?: string) {
    // ãƒ­ãƒ¼ãƒ«ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã‚¢ã‚¯ã‚»ã‚¹æ‹’å¦
    if (!currentUser.role) {
      throw new ForbiddenException('ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');
    }

    // SUPER_ADMIN ã®å ´åˆ
    if (currentUser.role === UserRole.SUPER_ADMIN) {
      const users = await this.prisma.user.findMany({
        where: tenantId ? { tenantId } : undefined,
        select: {
          id: true,
          email: true,
          firstName: true,
          lastName: true,
          role: true,
          isActive: true,
          tenantId: true,
          createdAt: true,
          updatedAt: true,
          lastLoginAt: true,
        },
        orderBy: { createdAt: 'desc' },
      });

      this.logger.log({
        message: 'Users listed by SUPER_ADMIN',
        userId: currentUser.userId,
        tenantId: tenantId ?? 'all',
        count: users.length,
      });

      return {
        success: true,
        data: users,
        count: users.length,
      };
    }

    // TENANT_ADMIN ã®å ´åˆ
    if (currentUser.role === UserRole.TENANT_ADMIN) {
      // è‡ªãƒ†ãƒŠãƒ³ãƒˆã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã¿å–å¾—å¯èƒ½
      const userTenantId = currentUser.tenantId;

      if (!userTenantId) {
        throw new ForbiddenException('ãƒ†ãƒŠãƒ³ãƒˆã«æ‰€å±ã—ã¦ã„ã¾ã›ã‚“');
      }

      // ä»–ã®ãƒ†ãƒŠãƒ³ãƒˆ ID ãŒæŒ‡å®šã•ã‚ŒãŸå ´åˆã¯ã‚¨ãƒ©ãƒ¼
      if (tenantId && tenantId !== userTenantId) {
        throw new ForbiddenException('ä»–ã®ãƒ†ãƒŠãƒ³ãƒˆã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§ã«ã¯ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“');
      }

      const users = await this.prisma.user.findMany({
        where: { tenantId: userTenantId },
        select: {
          id: true,
          email: true,
          firstName: true,
          lastName: true,
          role: true,
          isActive: true,
          tenantId: true,
          createdAt: true,
          updatedAt: true,
          lastLoginAt: true,
        },
        orderBy: { createdAt: 'desc' },
      });

      this.logger.log({
        message: 'Users listed by TENANT_ADMIN',
        userId: currentUser.userId,
        tenantId: userTenantId,
        count: users.length,
      });

      return {
        success: true,
        data: users,
        count: users.length,
      };
    }

    // ãã‚Œä»¥å¤–ã®ãƒ­ãƒ¼ãƒ«ã®å ´åˆã¯ã‚¢ã‚¯ã‚»ã‚¹æ‹’å¦
    throw new ForbiddenException('ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§ã®å–å¾—æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“');
  }

  /**
   * åˆå› SUPER_ADMIN æ˜‡æ ¼
   * 
   * DB ä¸Šã« SUPER_ADMIN ãŒå­˜åœ¨ã—ãªã„å ´åˆã®ã¿ã€ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ SUPER_ADMIN ã«æ˜‡æ ¼ã—ã¾ã™ã€‚
   * 
   * @param currentUser ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±
   * @returns æ˜‡æ ¼å¾Œã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±
   * @throws ForbiddenException SUPER_ADMIN ãŒã™ã§ã«å­˜åœ¨ã™ã‚‹å ´åˆ
   */
  async promoteToSuperAdminOnce(currentUser: RequestUser): Promise<PromoteToSuperAdminResponse> {
    // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã§ç«¶åˆçŠ¶æ…‹ã‚’é˜²æ­¢
    const updatedUser = await this.prisma.$transaction(async (tx) => {
      const superAdminCount = await tx.user.count({
        where: { role: UserRole.SUPER_ADMIN },
      });

      if (superAdminCount > 0) {
        this.logger.warn({
          message: 'promoteToSuperAdminOnce: ã™ã§ã«SUPER_ADMINãŒå­˜åœ¨ã™ã‚‹ãŸã‚æ‹’å¦',
          requestedByUserId: currentUser.userId,
          requestedByEmail: currentUser.email,
        });
        throw new ForbiddenException('SUPER_ADMINã¯ã™ã§ã«å­˜åœ¨ã—ã¾ã™');
      }

      return tx.user.update({
        where: { id: currentUser.userId },
        data: { role: UserRole.SUPER_ADMIN },
        select: {
          id: true,
          email: true,
          role: true,
        },
      });
    });

    this.logger.log({
      message: 'promoteToSuperAdminOnce: SUPER_ADMINã‚’åˆå›ä½œæˆ',
      userId: updatedUser.id,
      email: updatedUser.email,
    });

    return {
      success: true,
      data: {
        id: updatedUser.id,
        email: updatedUser.email,
        role: updatedUser.role,
      },
    };
  }

  /**
   * ãƒ¦ãƒ¼ã‚¶ãƒ¼æ‹›å¾…
   * 
   * æ¨©é™ãƒã‚§ãƒƒã‚¯ãƒ«ãƒ¼ãƒ«:
   * - SUPER_ADMIN: ä»»æ„ã®ãƒ†ãƒŠãƒ³ãƒˆã« TENANT_ADMIN / ADMIN / USER ã‚’æ‹›å¾…å¯èƒ½
   * - TENANT_ADMIN: è‡ªãƒ†ãƒŠãƒ³ãƒˆ (currentUser.tenantId === dto.tenantId) ã«ã®ã¿ ADMIN / USER ã‚’æ‹›å¾…å¯èƒ½
   *   - SUPER_ADMIN, TENANT_ADMIN ãƒ­ãƒ¼ãƒ«ã¸ã®æ‹›å¾…ã¯ ForbiddenException
   * 
   * @param currentUser ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±
   * @param dto æ‹›å¾…æƒ…å ±
   * @returns æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³æƒ…å ±
   */
  async inviteUser(
    currentUser: RequestUser,
    dto: InviteUserDto,
  ): Promise<{
    success: true;
    invitationToken: string;
    tenantId: string;
    message: string;
  }> {
    // ãƒ­ãƒ¼ãƒ«ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã‚¢ã‚¯ã‚»ã‚¹æ‹’å¦
    if (!currentUser.role) {
      throw new ForbiddenException('ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');
    }

    const email = dto.email.trim().toLowerCase();

    // SUPER_ADMIN ã®å ´åˆ
    if (currentUser.role === UserRole.SUPER_ADMIN) {
      // SUPER_ADMIN ã¯ä»»æ„ã®ãƒ†ãƒŠãƒ³ãƒˆã«ä»»æ„ã®ãƒ­ãƒ¼ãƒ«ã‚’æ‹›å¾…å¯èƒ½
      return this.createInvitation(email, dto.role, dto.tenantId, currentUser);
    }

    // TENANT_ADMIN ã®å ´åˆ
    if (currentUser.role === UserRole.TENANT_ADMIN) {
      // ãƒ†ãƒŠãƒ³ãƒˆã«æ‰€å±ã—ã¦ã„ãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼
      if (!currentUser.tenantId) {
        throw new ForbiddenException('ãƒ†ãƒŠãƒ³ãƒˆã«æ‰€å±ã—ã¦ã„ã¾ã›ã‚“');
      }

      // ä»–ã®ãƒ†ãƒŠãƒ³ãƒˆã¸ã®æ‹›å¾…ã¯ç¦æ­¢
      if (currentUser.tenantId !== dto.tenantId) {
        throw new ForbiddenException('ä»–ã®ãƒ†ãƒŠãƒ³ãƒˆã«ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’æ‹›å¾…ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“');
      }

      // SUPER_ADMIN, TENANT_ADMIN ãƒ­ãƒ¼ãƒ«ã¸ã®æ‹›å¾…ã¯ç¦æ­¢
      if (this.isPrivilegedRole(dto.role)) {
        throw new ForbiddenException('SUPER_ADMIN ã¾ãŸã¯ TENANT_ADMIN ã‚’æ‹›å¾…ã™ã‚‹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“');
      }

      return this.createInvitation(email, dto.role, dto.tenantId, currentUser);
    }

    // ãã‚Œä»¥å¤–ã®ãƒ­ãƒ¼ãƒ«ã®å ´åˆã¯ã‚¢ã‚¯ã‚»ã‚¹æ‹’å¦
    throw new ForbiddenException('ãƒ¦ãƒ¼ã‚¶ãƒ¼æ‹›å¾…ã®æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“');
  }

  /**
   * æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½œæˆã™ã‚‹å†…éƒ¨ãƒ¡ã‚½ãƒƒãƒ‰
   * 
   * @private
   */
  private async createInvitation(
    email: string,
    role: UserRole,
    tenantId: string,
    currentUser: RequestUser,
  ): Promise<{
    success: true;
    invitationToken: string;
    tenantId: string;
    message: string;
  }> {
    // ãƒ†ãƒŠãƒ³ãƒˆã®å­˜åœ¨ç¢ºèª
    const tenant = await this.prisma.tenant.findUnique({
      where: { id: tenantId },
    });

    if (!tenant) {
      throw new NotFoundException('æŒ‡å®šã•ã‚ŒãŸãƒ†ãƒŠãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    }

    // ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
    const existingUser = await this.prisma.user.findUnique({
      where: { email },
    });

    if (existingUser) {
      throw new ConflictException('ã“ã®ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯æ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™');
    }

    // æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆ
    const token = randomBytes(INVITATION_TOKEN_BYTES).toString('hex');
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + INVITATION_EXPIRY_DAYS);

    const invitation = await this.prisma.invitationToken.create({
      data: {
        email,
        token,
        role,
        tenantId,
        expiresAt,
      },
    });

    this.logger.log({
      message: 'User invitation created',
      tenantId,
      email,
      role,
      invitedBy: currentUser.userId,
      timestamp: new Date().toISOString(),
    });

    // æ‹›å¾…ãƒ¡ãƒ¼ãƒ«ã‚’é€ä¿¡
    const emailSent = await this.emailService.sendInvitationEmail(
      email,
      invitation.token,
      tenant.name,
      role,
    );

    if (!emailSent) {
      this.logger.warn(`Failed to send invitation email to ${email}, but invitation was created successfully`);
    }

    return {
      success: true,
      invitationToken: invitation.token,
      tenantId,
      message: emailSent ? 'æ‹›å¾…ãƒ¡ãƒ¼ãƒ«ã‚’é€ä¿¡ã—ã¾ã—ãŸ' : 'æ‹›å¾…ã‚’ä½œæˆã—ã¾ã—ãŸãŒã€ãƒ¡ãƒ¼ãƒ«é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ',
    };
  }

  /**
   * ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«å¤‰æ›´
   * 
   * æ¨©é™ãƒã‚§ãƒƒã‚¯ãƒ«ãƒ¼ãƒ«:
   * - SUPER_ADMIN:
   *   - ä»»æ„ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ­ãƒ¼ãƒ«ã‚’å¤‰æ›´å¯èƒ½
   *   - ãŸã ã—ã€SUPER_ADMIN ã‚’ SUPER_ADMIN ä»¥å¤–ã«é™æ ¼ã™ã‚‹æ“ä½œã¯ ForbiddenException
   *   - è‡ªåˆ†è‡ªèº«ã®ãƒ­ãƒ¼ãƒ«å¤‰æ›´ã‚‚ç¦æ­¢
   * - TENANT_ADMIN:
   *   - å¯¾è±¡ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè‡ªãƒ†ãƒŠãƒ³ãƒˆæ‰€å±ã§ã‚ã‚‹ã“ã¨ (user.tenantId === currentUser.tenantId)
   *   - å¤‰æ›´å¯èƒ½ãªãƒ­ãƒ¼ãƒ«: ADMIN â†” USER ã®ã¿
   *   - SUPER_ADMIN, TENANT_ADMIN ã¸ã®å¤‰æ›´ã¯ ForbiddenException
   *   - SUPER_ADMIN, TENANT_ADMIN ã®ãƒ­ãƒ¼ãƒ«å¤‰æ›´ã‚‚ ForbiddenException
   * 
   * @param currentUser ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±
   * @param userId å¯¾è±¡ãƒ¦ãƒ¼ã‚¶ãƒ¼ ID
   * @param dto æ–°ã—ã„ãƒ­ãƒ¼ãƒ«æƒ…å ±
   * @returns æ›´æ–°å¾Œã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±
   */
  async updateUserRole(
    currentUser: RequestUser,
    userId: string,
    dto: UpdateUserRoleDto,
  ): Promise<{
    success: true;
    data: {
      id: string;
      email: string;
      role: UserRole;
    };
    message: string;
  }> {
    // ãƒ­ãƒ¼ãƒ«ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã‚¢ã‚¯ã‚»ã‚¹æ‹’å¦
    if (!currentUser.role) {
      throw new ForbiddenException('ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');
    }

    // å¯¾è±¡ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å–å¾—
    const targetUser = await this.prisma.user.findUnique({
      where: { id: userId },
      select: {
        id: true,
        email: true,
        role: true,
        tenantId: true,
      },
    });

    if (!targetUser) {
      throw new NotFoundException('æŒ‡å®šã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    }

    // SUPER_ADMIN ã®å ´åˆ
    if (currentUser.role === UserRole.SUPER_ADMIN) {
      // è‡ªåˆ†è‡ªèº«ã®ãƒ­ãƒ¼ãƒ«å¤‰æ›´ã¯ç¦æ­¢
      if (currentUser.userId === userId) {
        throw new ForbiddenException('è‡ªåˆ†è‡ªèº«ã®ãƒ­ãƒ¼ãƒ«ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“');
      }

      // SUPER_ADMIN ã‚’é™æ ¼ã™ã‚‹ã“ã¨ã¯ç¦æ­¢
      if (targetUser.role === UserRole.SUPER_ADMIN && dto.role !== UserRole.SUPER_ADMIN) {
        throw new ForbiddenException('SUPER_ADMIN ã‚’é™æ ¼ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“');
      }

      // ãƒ­ãƒ¼ãƒ«æ›´æ–°
      const updatedUser = await this.prisma.user.update({
        where: { id: userId },
        data: { role: dto.role },
        select: {
          id: true,
          email: true,
          role: true,
        },
      });

      this.logger.log({
        message: 'User role updated by SUPER_ADMIN',
        targetUserId: userId,
        oldRole: targetUser.role,
        newRole: dto.role,
        updatedBy: currentUser.userId,
      });

      return {
        success: true,
        data: updatedUser,
        message: 'ãƒ­ãƒ¼ãƒ«ã‚’æ›´æ–°ã—ã¾ã—ãŸ',
      };
    }

    // TENANT_ADMIN ã®å ´åˆ
    if (currentUser.role === UserRole.TENANT_ADMIN) {
      // ãƒ†ãƒŠãƒ³ãƒˆã«æ‰€å±ã—ã¦ã„ãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼
      if (!currentUser.tenantId) {
        throw new ForbiddenException('ãƒ†ãƒŠãƒ³ãƒˆã«æ‰€å±ã—ã¦ã„ã¾ã›ã‚“');
      }

      // å¯¾è±¡ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒä»–ãƒ†ãƒŠãƒ³ãƒˆã®å ´åˆã¯ã‚¨ãƒ©ãƒ¼
      if (targetUser.tenantId !== currentUser.tenantId) {
        throw new ForbiddenException('ä»–ã®ãƒ†ãƒŠãƒ³ãƒˆã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ­ãƒ¼ãƒ«ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“');
      }

      // å¯¾è±¡ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒ SUPER_ADMIN ã¾ãŸã¯ TENANT_ADMIN ã®å ´åˆã¯å¤‰æ›´ä¸å¯
      if (this.isPrivilegedRole(targetUser.role)) {
        throw new ForbiddenException('SUPER_ADMIN ã¾ãŸã¯ TENANT_ADMIN ã®ãƒ­ãƒ¼ãƒ«ã‚’å¤‰æ›´ã™ã‚‹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“');
      }

      // SUPER_ADMIN, TENANT_ADMIN ã¸ã®å¤‰æ›´ã¯ç¦æ­¢
      if (this.isPrivilegedRole(dto.role)) {
        throw new ForbiddenException('SUPER_ADMIN ã¾ãŸã¯ TENANT_ADMIN ã«å¤‰æ›´ã™ã‚‹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“');
      }

      // ãƒ­ãƒ¼ãƒ«æ›´æ–°ï¼ˆADMIN â†” USER ã®ã¿è¨±å¯ï¼‰
      const updatedUser = await this.prisma.user.update({
        where: { id: userId },
        data: { role: dto.role },
        select: {
          id: true,
          email: true,
          role: true,
        },
      });

      this.logger.log({
        message: 'User role updated by TENANT_ADMIN',
        targetUserId: userId,
        oldRole: targetUser.role,
        newRole: dto.role,
        updatedBy: currentUser.userId,
        tenantId: currentUser.tenantId,
      });

      return {
        success: true,
        data: updatedUser,
        message: 'ãƒ­ãƒ¼ãƒ«ã‚’æ›´æ–°ã—ã¾ã—ãŸ',
      };
    }

    // ãã‚Œä»¥å¤–ã®ãƒ­ãƒ¼ãƒ«ã®å ´åˆã¯ã‚¢ã‚¯ã‚»ã‚¹æ‹’å¦
    throw new ForbiddenException('ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«å¤‰æ›´ã®æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“');
  }

  /**
   * èªè¨¼ã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã‚’å–å¾—
   * 
   * @param currentUser ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±
   * @returns ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«æƒ…å ±
   */
  async getProfile(currentUser: RequestUser): Promise<{
    success: true;
    data: UserProfileData;
  }> {
    const user = await this.prisma.user.findUnique({
      where: { id: currentUser.userId },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        role: true,
      },
    });

    if (!user) {
      throw new NotFoundException('ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    }

    this.logger.log({
      message: 'Profile retrieved',
      userId: user.id,
    });

    return {
      success: true,
      data: user,
    };
  }

  /**
   * èªè¨¼ã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã‚’æ›´æ–°
   * 
   * @param currentUser ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±
   * @param dto æ›´æ–°ã™ã‚‹ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«æƒ…å ±
   * @returns æ›´æ–°å¾Œã®ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«æƒ…å ±
   */
  async updateProfile(
    currentUser: RequestUser,
    dto: UpdateProfileDto,
  ): Promise<{
    success: true;
    data: UserProfileData;
    message: string;
  }> {
    // æ›´æ–°å¯¾è±¡ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼
    if (dto.firstName === undefined && dto.lastName === undefined && dto.email === undefined) {
      throw new BadRequestException('æ›´æ–°ã™ã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“');
    }

    // æ›´æ–°ãƒ‡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰
    const updateData: {
      firstName?: string;
      lastName?: string;
      email?: string;
    } = {};

    // firstName/lastName ã¯ç©ºæ–‡å­—åˆ—ã‚‚è¨±å¯ï¼ˆåå‰ã‚’æ¶ˆã™å ´åˆï¼‰
    if (dto.firstName !== undefined) {
      updateData.firstName = dto.firstName;
    }
    if (dto.lastName !== undefined) {
      updateData.lastName = dto.lastName;
    }
    if (dto.email !== undefined) {
      const trimmedEmail = dto.email.trim().toLowerCase();
      if (trimmedEmail === '') {
        throw new BadRequestException('ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ç©ºã«ã§ãã¾ã›ã‚“');
      }
      // ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
      const existingUser = await this.prisma.user.findFirst({
        where: {
          email: trimmedEmail,
          NOT: { id: currentUser.userId },
        },
      });

      if (existingUser) {
        throw new ConflictException('ã“ã®ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯æ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™');
      }
      updateData.email = trimmedEmail;
    }

    const updatedUser = await this.prisma.user.update({
      where: { id: currentUser.userId },
      data: updateData,
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        role: true,
      },
    });

    this.logger.log({
      message: 'Profile updated',
      userId: updatedUser.id,
      updatedFields: Object.keys(updateData),
    });

    return {
      success: true,
      data: updatedUser,
      message: 'ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã‚’æ›´æ–°ã—ã¾ã—ãŸ',
    };
  }

  /**
   * ãƒ¦ãƒ¼ã‚¶ãƒ¼å‰Šé™¤
   * 
   * æ¨©é™ãƒã‚§ãƒƒã‚¯ãƒ«ãƒ¼ãƒ«:
   * - SUPER_ADMIN:
   *   - ä»»æ„ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å‰Šé™¤å¯èƒ½
   *   - ãŸã ã—ã€è‡ªåˆ†è‡ªèº«ã¨ä»–ã® SUPER_ADMIN ã¯å‰Šé™¤ä¸å¯
   * - TENANT_ADMIN:
   *   - è‡ªãƒ†ãƒŠãƒ³ãƒˆã® ADMIN / USER ã®ã¿å‰Šé™¤å¯èƒ½
   *   - SUPER_ADMIN, TENANT_ADMIN ã¯å‰Šé™¤ä¸å¯
   * 
   * @param currentUser ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±
   * @param userId å¯¾è±¡ãƒ¦ãƒ¼ã‚¶ãƒ¼ ID
   * @returns å‰Šé™¤çµæœ
   */
  async deleteUser(
    currentUser: RequestUser,
    userId: string,
  ): Promise<{
    success: true;
    message: string;
  }> {
    // ãƒ­ãƒ¼ãƒ«ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã‚¢ã‚¯ã‚»ã‚¹æ‹’å¦
    if (!currentUser.role) {
      throw new ForbiddenException('ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');
    }

    // å¯¾è±¡ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å–å¾—
    const targetUser = await this.prisma.user.findUnique({
      where: { id: userId },
      select: {
        id: true,
        email: true,
        role: true,
        tenantId: true,
      },
    });

    if (!targetUser) {
      throw new NotFoundException('æŒ‡å®šã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    }

    // SUPER_ADMIN ã®å ´åˆ
    if (currentUser.role === UserRole.SUPER_ADMIN) {
      // è‡ªåˆ†è‡ªèº«ã®å‰Šé™¤ã¯ç¦æ­¢
      if (currentUser.userId === userId) {
        throw new ForbiddenException('è‡ªåˆ†è‡ªèº«ã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“');
      }

      // ä»–ã® SUPER_ADMIN ã®å‰Šé™¤ã¯ç¦æ­¢
      if (targetUser.role === UserRole.SUPER_ADMIN) {
        throw new ForbiddenException('SUPER_ADMIN ã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“');
      }

      // ãƒ¦ãƒ¼ã‚¶ãƒ¼å‰Šé™¤
      await this.prisma.user.delete({
        where: { id: userId },
      });

      this.logger.log({
        message: 'User deleted by SUPER_ADMIN',
        targetUserId: userId,
        targetEmail: targetUser.email,
        deletedBy: currentUser.userId,
      });

      return {
        success: true,
        message: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
      };
    }

    // TENANT_ADMIN ã®å ´åˆ
    if (currentUser.role === UserRole.TENANT_ADMIN) {
      // ãƒ†ãƒŠãƒ³ãƒˆã«æ‰€å±ã—ã¦ã„ãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼
      if (!currentUser.tenantId) {
        throw new ForbiddenException('ãƒ†ãƒŠãƒ³ãƒˆã«æ‰€å±ã—ã¦ã„ã¾ã›ã‚“');
      }

      // å¯¾è±¡ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒä»–ãƒ†ãƒŠãƒ³ãƒˆã®å ´åˆã¯ã‚¨ãƒ©ãƒ¼
      if (targetUser.tenantId !== currentUser.tenantId) {
        throw new ForbiddenException('ä»–ã®ãƒ†ãƒŠãƒ³ãƒˆã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“');
      }

      // å¯¾è±¡ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒ SUPER_ADMIN ã¾ãŸã¯ TENANT_ADMIN ã®å ´åˆã¯å‰Šé™¤ä¸å¯
      if (this.isPrivilegedRole(targetUser.role)) {
        throw new ForbiddenException('SUPER_ADMIN ã¾ãŸã¯ TENANT_ADMIN ã‚’å‰Šé™¤ã™ã‚‹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“');
      }

      // ãƒ¦ãƒ¼ã‚¶ãƒ¼å‰Šé™¤
      await this.prisma.user.delete({
        where: { id: userId },
      });

      this.logger.log({
        message: 'User deleted by TENANT_ADMIN',
        targetUserId: userId,
        targetEmail: targetUser.email,
        deletedBy: currentUser.userId,
        tenantId: currentUser.tenantId,
      });

      return {
        success: true,
        message: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
      };
    }

    // ãã‚Œä»¥å¤–ã®ãƒ­ãƒ¼ãƒ«ã®å ´åˆã¯ã‚¢ã‚¯ã‚»ã‚¹æ‹’å¦
    throw new ForbiddenException('ãƒ¦ãƒ¼ã‚¶ãƒ¼å‰Šé™¤ã®æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“');
  }
}
`````

## File: backend/src/app.controller.spec.ts
`````typescript
import { Test, TestingModule } from '@nestjs/testing';

import { AppController } from './app.controller';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return API information', () => {
      const result = appController.getHello();
      expect(result).toHaveProperty('message');
      expect(result).toHaveProperty('version');
      expect(result.message).toBe('ğŸ± Cat Management System API');
    });

    it('should return health status', () => {
      const result = appController.getHealth();
      expect(result).toHaveProperty('status', 'ok');
      expect(result).toHaveProperty('timestamp');
      expect(result).toHaveProperty('service');
    });
  });
});
`````

## File: backend/src/app.controller.ts
`````typescript
import { Controller, Get } from "@nestjs/common";

type HelloResponse = {
  message: string;
  version: string;
  documentation: string;
  health: string;
  timestamp: string;
  endpoints: {
    cats: string;
    pedigrees: string;
    breeds: string;
    coatColors: string;
  };
};

type HealthResponse = {
  status: string;
  timestamp: string;
  service: string;
  version: string;
};

@Controller()
export class AppController {
  @Get()
  getHello(): HelloResponse {
    return {
      message: "ğŸ± Cat Management System API",
      version: "1.0.0",
      documentation: "/api/docs",
      health: "/health",
      timestamp: new Date().toISOString(),
      endpoints: {
        cats: "/api/v1/cats",
        pedigrees: "/api/v1/pedigrees",
        breeds: "/api/v1/breeds",
        coatColors: "/api/v1/coat-colors",
      },
    };
  }

  @Get("health")
  getHealth(): HealthResponse {
    return {
      status: "ok",
      timestamp: new Date().toISOString(),
      service: "Cat Management System API",
      version: "1.0.0",
    };
  }
}
`````

## File: backend/test/utils/create-test-app.ts
`````typescript
import { INestApplication, ValidationPipe } from '@nestjs/common';
import { TestingModule } from '@nestjs/testing';

import { TransformResponseInterceptor } from '../../src/common/interceptors/transform-response.interceptor';
import { PerformanceMonitoringInterceptor } from '../../src/common/interceptors/performance-monitoring.interceptor';
import { EnhancedGlobalExceptionFilter } from '../../src/common/filters/enhanced-global-exception.filter';

export async function createTestApp(moduleRef: TestingModule): Promise<INestApplication> {
  const app = moduleRef.createNestApplication();

  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      transform: true,
      forbidNonWhitelisted: true,
    }),
  );

  app.useGlobalInterceptors(
    new TransformResponseInterceptor(),
    new PerformanceMonitoringInterceptor(),
  );

  app.useGlobalFilters(new EnhancedGlobalExceptionFilter());

  app.setGlobalPrefix('api/v1');

  await app.init();

  return app;
}
`````

## File: backend/test/auth-breeding.e2e-spec.ts
`````typescript
import { INestApplication } from "@nestjs/common";
import { Test } from "@nestjs/testing";
import request from "supertest";
import { AppModule } from "../src/app.module";
import { createTestApp } from "./utils/create-test-app";

describe("Auth -> Breeding (e2e)", () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = await createTestApp(moduleRef);
  });

  afterAll(async () => {
    await app.close();
  });

  it("register, login, create breeding", async () => {
    const email = `breeding_test_${Date.now()}_${Math.random().toString(36).substring(7)}@example.com`;
    const password = "Secret123!";

    // register
    const registerRes = await request(app.getHttpServer()).post("/api/v1/auth/register").send({ email, password });
    expect(registerRes.status).toBe(201);

    // login
    const loginRes = await request(app.getHttpServer()).post("/api/v1/auth/login").send({ email, password });
    expect(loginRes.status).toBe(201);

    const token = loginRes.body.data.access_token as string;
    expect(token).toBeDefined();

    // create breeding (needs mother/father cat; here we expect 400/404 if not present)
    // Note: breeding endpoint needs both CSRF token AND JWT token
    const breedingRes = await request(app.getHttpServer())
      .post("/api/v1/breeding")
      .set("Authorization", `Bearer ${token}`)
      .send({
        femaleId: "00000000-0000-0000-0000-000000000000",
        maleId: "00000000-0000-0000-0000-000000000000",
        breedingDate: "2025-08-01",
      });
    
    // Accept 201/400/404 since cats may not exist; at least auth works
    if (![201, 400, 404].includes(breedingRes.status)) {
      throw new Error(`Unexpected status: ${breedingRes.status}`);
    }
  });
});
`````

## File: backend/test/auth-jwt.e2e-spec.ts
`````typescript
import { INestApplication, ValidationPipe } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import request from 'supertest';
import { AppModule } from '../src/app.module';
import { JwtService } from '@nestjs/jwt';

describe('Auth JWT & Rate Limiting (e2e)', () => {
  let app: INestApplication;
  let jwtService: JwtService;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    app.useGlobalPipes(new ValidationPipe({ whitelist: true, transform: true }));
    app.setGlobalPrefix('api/v1');
    await app.init();

    jwtService = app.get<JwtService>(JwtService);
  });

  afterAll(async () => {
    await app.close();
  });

  describe('JWT Authentication', () => {
    it('should reject requests without token', async () => {
      await request(app.getHttpServer())
        .get('/api/v1/cats')
        .expect(401);
    });

    it('should reject requests with invalid token', async () => {
      await request(app.getHttpServer())
        .get('/api/v1/cats')
        .set('Authorization', 'Bearer invalid-token-123')
        .expect(401);
    });

    it('should reject requests with malformed Authorization header', async () => {
      const email = `jwt_test_${Date.now()}@example.com`;
      const password = 'Password123!';

      const res = await request(app.getHttpServer())
        .post('/api/v1/auth/register')
        .send({ email, password });
      expect(res.status).toBe(201);

      const loginRes = await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({ email, password });
      expect(loginRes.status).toBe(201);

      const token = loginRes.body.data.access_token;

      // Missing "Bearer" prefix
      await request(app.getHttpServer())
        .get('/api/v1/cats')
        .set('Authorization', token)
        .expect(401);
    });

    it('should accept valid JWT token', async () => {
      const email = `jwt_valid_${Date.now()}@example.com`;
      const password = 'Password123!';

      const res = await request(app.getHttpServer())
        .post('/api/v1/auth/register')
        .send({ email, password });
      expect(res.status).toBe(201);

      const loginRes = await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({ email, password });
      expect(loginRes.status).toBe(201);

      const token = loginRes.body.data.access_token;
      expect(token).toBeDefined();

      // Should successfully access protected route
      await request(app.getHttpServer())
        .get('/api/v1/cats')
        .set('Authorization', `Bearer ${token}`)
        .expect(200);
    });

    it('should include user info in JWT payload', async () => {
      const email = `jwt_payload_${Date.now()}@example.com`;
      const password = 'Password123!';

      const registerRes = await request(app.getHttpServer())
        .post('/api/v1/auth/register')
        .send({ email, password });
      expect(registerRes.status).toBe(201);

      const token = registerRes.body.data.access_token;
      const decoded = jwtService.decode(token) as any;

      expect(decoded).toHaveProperty('sub');
      expect(decoded).toHaveProperty('email');
      expect(decoded).toHaveProperty('role');
      expect(decoded.email).toBe(email.toLowerCase().trim());
    });

    it('should refresh token after login', async () => {
      const email = `jwt_refresh_${Date.now()}@example.com`;
      const password = 'Password123!';

      // First login
      const res = await request(app.getHttpServer())
        .post('/api/v1/auth/register')
        .send({ email, password });
      expect(res.status).toBe(201);

      const login1Res = await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({ email, password });
      expect(login1Res.status).toBe(201);

      const token1 = login1Res.body.data.access_token;

      // Second login should generate new token
      const login2Res = await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({ email, password });
      expect(login2Res.status).toBe(201);

      const token2 = login2Res.body.data.access_token;

      // Tokens should be different
      expect(token1).not.toBe(token2);

      // Both tokens should be valid
      await request(app.getHttpServer())
        .get('/api/v1/cats')
        .set('Authorization', `Bearer ${token1}`)
        .expect(200);

      await request(app.getHttpServer())
        .get('/api/v1/cats')
        .set('Authorization', `Bearer ${token2}`)
        .expect(200);
    });
  });

  describe('Rate Limiting', () => {
    it('should enforce rate limit on login (20/min)', async () => {
      const email = `ratelimit_login_${Date.now()}@example.com`;
      const password = 'Password123!';

      // Register user
      const res = await request(app.getHttpServer())
        .post('/api/v1/auth/register')
        .send({ email, password });
      expect(res.status).toBe(201);

      // Make 20 login requests
      for (let i = 0; i < 20; i++) {
        const res2 = await request(app.getHttpServer())
          .post('/api/v1/auth/login')
          .send({ email, password });
        expect(res2.status).toBe(201);
      }

      // 21st request should be rate limited
      const res3 = await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({ email, password });
      expect(res3.status).toBe(429);
    }, 30000);

    it('should enforce rate limit on register (5/min)', async () => {
      const baseEmail = `ratelimit_register_${Date.now()}`;
      const password = 'Password123!';

      // Make 5 registration requests
      for (let i = 0; i < 5; i++) {
        const res = await request(app.getHttpServer())
          .post('/api/v1/auth/register')
          .send({ email: `${baseEmail}_${i}@example.com`, password });
        expect(res.status).toBe(201);
      }

      // 6th request should be rate limited
      const res2 = await request(app.getHttpServer())
        .post('/api/v1/auth/register')
        .send({ email: `${baseEmail}_6@example.com`, password });
      expect(res2.status).toBe(429);
    }, 20000);

    it('should have separate rate limit counters per endpoint', async () => {
      const email = `ratelimit_separate_${Date.now()}@example.com`;
      const password = 'Password123!';

      // Register user (counts toward register limit)
      const res = await request(app.getHttpServer())
        .post('/api/v1/auth/register')
        .send({ email, password });
      expect(res.status).toBe(201);

      // Login should have independent counter
      for (let i = 0; i < 5; i++) {
        const res2 = await request(app.getHttpServer())
          .post('/api/v1/auth/login')
          .send({ email, password });
        expect(res2.status).toBe(201);
      }

      // Should still be able to login (not affected by register limit)
      const res3 = await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({ email, password });
      expect(res3.status).toBe(201);
    }, 15000);
  });

  describe('Security Headers', () => {
    it('should include security headers (Helmet)', async () => {
      const res = await request(app.getHttpServer())
        .get('/api/v1/health')
        .expect(200);

      // Helmet security headers
      expect(res.headers).toHaveProperty('x-content-type-options');
      expect(res.headers['x-content-type-options']).toBe('nosniff');
      
      expect(res.headers).toHaveProperty('x-frame-options');
      
      // Strict-Transport-Security for HTTPS
      expect(res.headers).toHaveProperty('strict-transport-security');
    });

    it('should set proper CORS headers', async () => {
      const email = `cors_test_${Date.now()}@example.com`;
      const password = 'Password123!';

      const res = await request(app.getHttpServer())
        .post('/api/v1/auth/register')
        .set('Origin', 'http://localhost:3000')
        .send({ email, password });
      expect(res.status).toBe(201);

      expect(res.headers).toHaveProperty('access-control-allow-origin');
    });
  });

  describe('Login Failure Tracking', () => {
    it('should track failed login attempts', async () => {
      const email = `failed_login_${Date.now()}@example.com`;
      const correctPassword = 'CorrectPassword123!';
      const wrongPassword = 'WrongPassword123!';

      // Register user
      const res = await request(app.getHttpServer())
        .post('/api/v1/auth/register')
        .send({ email, password: correctPassword });
      expect(res.status).toBe(201);

      // Make failed login attempts
      for (let i = 0; i < 3; i++) {
        const res2 = await request(app.getHttpServer())
          .post('/api/v1/auth/login')
          .send({ email, password: wrongPassword });
        expect(res2.status).toBe(401);
      }

      // Correct password should still work (account not locked yet)
      const res3 = await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({ email, password: correctPassword });
      expect(res3.status).toBe(201);
    });

    it('should return proper error message for wrong password', async () => {
      const email = `wrong_password_${Date.now()}@example.com`;
      const password = 'CorrectPassword123!';

      const res = await request(app.getHttpServer())
        .post('/api/v1/auth/register')
        .send({ email, password });
      expect(res.status).toBe(201);

      const res2 = await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({ email, password: 'WrongPassword!' });
      expect(res2.status).toBe(401);

      expect(res2.body).toHaveProperty('message');
    });

    it('should return same error for non-existent user (security)', async () => {
      const nonExistentEmail = `nonexistent_${Date.now()}@example.com`;

      const res = await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({ email: nonExistentEmail, password: 'SomePassword123!' });
      expect(res.status).toBe(401);

      expect(res.body).toHaveProperty('message');
    });
  });

  describe('Input Validation', () => {
    it('should validate email format on registration', async () => {
      const res = await request(app.getHttpServer())
        .post('/api/v1/auth/register')
        .send({ email: 'invalid-email', password: 'Password123!' });
      expect(res.status).toBe(400);
    });

    it('should enforce password requirements', async () => {
      const email = `password_req_${Date.now()}@example.com`;

      // Too short
      const res = await request(app.getHttpServer())
        .post('/api/v1/auth/register')
        .send({ email, password: 'Ab1!' });
      expect(res.status).toBe(400);

      // No uppercase
      const res2 = await request(app.getHttpServer())
        .post('/api/v1/auth/register')
        .send({ email, password: 'password123!' });
      expect(res2.status).toBe(400);

      // No lowercase
      const res3 = await request(app.getHttpServer()).post("/api/v1/auth/register").send({ email, password: 'PASSWORD123!' });
      expect(res3.status).toBe(400);

      // No number
      const res4 = await request(app.getHttpServer()).post("/api/v1/auth/register").send({ email, password: 'PasswordABC!' });
      expect(res4.status).toBe(400);
    });

    it('should trim and lowercase email', async () => {
      const emailRaw = `  Trim_Test_${Date.now()}@EXAMPLE.COM  `;
      const password = 'Password123!';

      // Register with messy email
      const res = await request(app.getHttpServer()).post("/api/v1/auth/register").send({ email: emailRaw, password });
      expect(res.status).toBe(201);

      // Login with cleaned email should work
      const cleanEmail = emailRaw.trim().toLowerCase();
      const res2 = await request(app.getHttpServer()).post("/api/v1/auth/login").send({ email: cleanEmail, password });
      expect(res2.status).toBe(201);

      // Login with different casing should also work
      const res3 = await request(app.getHttpServer()).post("/api/v1/auth/login").send({ email: emailRaw.toUpperCase(), password });
      expect(res3.status).toBe(201);
    });
  });
});
`````

## File: backend/test/auth-password-reset.e2e-spec.ts
`````typescript
import { INestApplication, ValidationPipe } from '@nestjs/common';
import request from 'supertest';
import { Test } from '@nestjs/testing';
import { AppModule } from '../src/app.module';
import { ThrottlerStorageService, ThrottlerStorage } from '@nestjs/throttler';
import { PrismaService } from '../src/prisma/prisma.service';

describe('Auth Password Reset (e2e)', () => {
  let app: INestApplication;
  let prisma: PrismaService;
  let throttlerStorage: ThrottlerStorageService;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    app.useGlobalPipes(new ValidationPipe({ whitelist: true, transform: true }));
    app.setGlobalPrefix('api/v1');
    await app.init();

    prisma = app.get<PrismaService>(PrismaService);
  throttlerStorage = app.get<ThrottlerStorageService>(ThrottlerStorage);
  });

  afterAll(async () => {
    await app.close();
  });

  afterEach(() => {
    const storage = throttlerStorage.storage;
    for (const key of Object.keys(storage)) {
      delete storage[key];
    }
  });

  describe('POST /auth/request-password-reset', () => {
    it('should accept password reset request for existing user', async () => {
      // 1. Register a user first
      const email = `reset_test_${Date.now()}@example.com`;
      const password = 'OldPassword123!';

      const res = await request(app.getHttpServer()).post('/api/v1/auth/register').send({ email, password });
      expect(res.status).toBe(201);

      // 2. Request password reset
      const resetRes = await request(app.getHttpServer()).post('/api/v1/auth/request-password-reset').send({ email });
      expect(resetRes.status).toBe(201);

      expect(resetRes.body).toHaveProperty('message');
      expect(resetRes.body.message).toContain('ãƒªã‚»ãƒƒãƒˆ');

      // 3. Verify token is stored in database
      const user = await prisma.user.findUnique({
        where: { email: email.toLowerCase().trim() },
        select: { resetPasswordToken: true, resetPasswordExpires: true },
      });

      expect(user).toBeDefined();
      expect(user!.resetPasswordToken).not.toBeNull();
      expect(user!.resetPasswordExpires).not.toBeNull();
      expect(user!.resetPasswordExpires!.getTime()).toBeGreaterThan(Date.now());
    });

    it('should accept request for non-existing user (security)', async () => {
      // Should not reveal whether user exists
      const nonExistentEmail = `nonexistent_${Date.now()}@example.com`;

      const res = await request(app.getHttpServer()).post('/api/v1/auth/request-password-reset').send({ email: nonExistentEmail });
      expect(res.status).toBe(201);

      expect(res.body.message).toContain('ãƒªã‚»ãƒƒãƒˆ');
    });

    it('should validate email format', async () => {
      const res = await request(app.getHttpServer()).post('/api/v1/auth/request-password-reset').send({ email: 'invalid-email' });
      expect(res.status).toBe(400);
    });

    it('should enforce rate limiting (3 requests/min)', async () => {
      const email = `ratelimit_${Date.now()}@example.com`;

      // Make 4 rapid requests
      for (let i = 0; i < 3; i++) {
        const res = await request(app.getHttpServer()).post('/api/v1/auth/request-password-reset').send({ email });
        expect(res.status).toBe(201);
      }

      // 4th request should be rate limited
      const res2 = await request(app.getHttpServer()).post('/api/v1/auth/request-password-reset').send({ email });
      expect(res2.status).toBe(429);
    }, 10000);
  });

  describe('POST /auth/reset-password', () => {
    it('should reset password with valid token', async () => {
      // 1. Register user
      const email = `reset_valid_${Date.now()}@example.com`;
      const oldPassword = 'OldPassword123!';
      const newPassword = 'NewPassword456!';

      const res = await request(app.getHttpServer()).post('/api/v1/auth/register').send({ email, password: oldPassword });
      expect(res.status).toBe(201);

      // 2. Request password reset
      const resetRequestRes = await request(app.getHttpServer()).post('/api/v1/auth/request-password-reset').send({ email });
      expect(resetRequestRes.status).toBe(201);

      // 3. Get token from response (development environment)
      const token = resetRequestRes.body.token;
      expect(token).toBeDefined();

      // 4. Reset password
      const res2 = await request(app.getHttpServer()).post('/api/v1/auth/reset-password').send({ token, newPassword });
      expect(res2.status).toBe(201);

      // 5. Verify old password doesn't work
      const res3 = await request(app.getHttpServer()).post('/api/v1/auth/login').send({ email, password: oldPassword });
      expect(res3.status).toBe(401);

      // 6. Verify new password works
      const loginRes = await request(app.getHttpServer()).post('/api/v1/auth/login').send({ email, password: newPassword });
      expect(loginRes.status).toBe(201);

      expect(loginRes.body.data).toHaveProperty('access_token');

      // 7. Verify token is cleared
      const updatedUser = await prisma.user.findUnique({
        where: { email: email.toLowerCase().trim() },
        select: { resetPasswordToken: true, resetPasswordExpires: true },
      });

      expect(updatedUser!.resetPasswordToken).toBeNull();
      expect(updatedUser!.resetPasswordExpires).toBeNull();
    });

    it('should reject invalid token', async () => {
      const res = await request(app.getHttpServer()).post('/api/v1/auth/reset-password').send({
          token: 'invalid-token-123',
          newPassword: 'NewPassword123!',
        });
      expect(res.status).toBe(400);
    });

    it('should reject expired token', async () => {
      // 1. Register user
      const email = `reset_expired_${Date.now()}@example.com`;
      const password = 'OldPassword123!';

      const res = await request(app.getHttpServer()).post('/api/v1/auth/register').send({ email, password });
      expect(res.status).toBe(201);

      // 2. Request password reset
      const res2 = await request(app.getHttpServer()).post('/api/v1/auth/request-password-reset').send({ email });
      expect(res2.status).toBe(201);

      // 3. Manually expire the token
      const user = await prisma.user.findUnique({
        where: { email: email.toLowerCase().trim() },
        select: { resetPasswordToken: true },
      });

      await prisma.user.update({
        where: { email: email.toLowerCase().trim() },
        data: {
          resetPasswordExpires: new Date(Date.now() - 1000), // Expired 1 second ago
        },
      });

      // 4. Try to reset with expired token
      const res3 = await request(app.getHttpServer()).post('/api/v1/auth/reset-password').send({
          token: user!.resetPasswordToken!,
          newPassword: 'NewPassword123!',
        });
      expect(res3.status).toBe(400);
    });

    it('should reject weak passwords', async () => {
      const email = `reset_weak_${Date.now()}@example.com`;
      const password = 'OldPassword123!';

      const res = await request(app.getHttpServer()).post('/api/v1/auth/register').send({ email, password });
      expect(res.status).toBe(201);

      const res2 = await request(app.getHttpServer()).post('/api/v1/auth/request-password-reset').send({ email });
      expect(res2.status).toBe(201);

      const user = await prisma.user.findUnique({
        where: { email: email.toLowerCase().trim() },
        select: { resetPasswordToken: true },
      });

      // Try with weak password
      const res3 = await request(app.getHttpServer()).post('/api/v1/auth/reset-password').send({
          token: user!.resetPasswordToken!,
          newPassword: '123', // Too weak
        });
      expect(res3.status).toBe(400);
    });

    it('should prevent token reuse', async () => {
      // 1. Register user
      const email = `reset_reuse_${Date.now()}@example.com`;
      const password = 'OldPassword123!';
      const newPassword = 'NewPassword123!';

      const res = await request(app.getHttpServer()).post('/api/v1/auth/register').send({ email, password });
      expect(res.status).toBe(201);

      // 2. Request reset
      const resetRequestRes = await request(app.getHttpServer()).post('/api/v1/auth/request-password-reset').send({ email });
      expect(resetRequestRes.status).toBe(201);

      // 3. Get token from response
      const token = resetRequestRes.body.token;
      expect(token).toBeDefined();

      // 4. Use token once
      const res2 = await request(app.getHttpServer()).post('/api/v1/auth/reset-password').send({ token, newPassword });
      expect(res2.status).toBe(201);

      // 5. Try to reuse same token
      const res3 = await request(app.getHttpServer()).post('/api/v1/auth/reset-password').send({ token, newPassword: 'AnotherPassword123!' });
      expect(res3.status).toBe(400);
    });

    it('should enforce rate limiting (3 requests/min)', async () => {
      const token = 'some-token-' + Date.now();

      // Make 3 rapid requests (at the limit)
      for (let i = 0; i < 3; i++) {
        const res = await request(app.getHttpServer())
          .post('/api/v1/auth/reset-password')
          .send({ token: `${token}-${i}`, newPassword: 'NewPassword123!' });
        
        // Should get 400 for invalid token, not 429
        expect([400, 429]).toContain(res.status);
      }

      // Additional requests should be rate limited or continue to fail
      // Note: Rate limiting behavior may vary based on implementation
      const finalRes = await request(app.getHttpServer())
        .post('/api/v1/auth/reset-password')
        .send({ token: `${token}-final`, newPassword: 'NewPassword123!' });
      
      // Accept either 400 (invalid token) or 429 (rate limited)
      expect([400, 429]).toContain(finalRes.status);
    }, 10000);
  });

  describe('Integration: Full Password Reset Flow', () => {
    it('should complete full password reset workflow', async () => {
      const email = `fullflow_${Date.now()}@example.com`;
      const originalPassword = 'Original123!';
      const newPassword = 'New456Password!';

      // 1. User registration
      const registerRes = await request(app.getHttpServer()).post('/api/v1/auth/register').send({ email, password: originalPassword });
      expect(registerRes.status).toBe(201);

      expect(registerRes.body.data).toHaveProperty('id');
      expect(registerRes.body.data).toHaveProperty('email');

      // 2. User can login with original password
      const loginRes1 = await request(app.getHttpServer()).post('/api/v1/auth/login').send({ email, password: originalPassword });
      expect(loginRes1.status).toBe(201);

      expect(loginRes1.body.data).toHaveProperty('access_token');

      // 3. User requests password reset
      const resetRequestRes = await request(app.getHttpServer()).post('/api/v1/auth/request-password-reset').send({ email });
      expect(resetRequestRes.status).toBe(201);

      expect(resetRequestRes.body.message).toContain('ãƒªã‚»ãƒƒãƒˆ');

      // 4. Retrieve token from response (development environment)
      const token = resetRequestRes.body.token;
      expect(token).toBeDefined();

      // 5. User resets password
      const resetRes = await request(app.getHttpServer()).post('/api/v1/auth/reset-password').send({
          token,
          newPassword,
        });
      expect(resetRes.status).toBe(201);

      expect(resetRes.body.message).toContain('ãƒªã‚»ãƒƒãƒˆ');

      // 6. Old password should no longer work
      const res = await request(app.getHttpServer()).post('/api/v1/auth/login').send({ email, password: originalPassword });
      expect(res.status).toBe(401);

      // 7. New password should work
      const loginRes2 = await request(app.getHttpServer()).post('/api/v1/auth/login').send({ email, password: newPassword });
      expect(loginRes2.status).toBe(201);

      expect(loginRes2.body.data).toHaveProperty('access_token');
      expect(loginRes2.body.data.access_token).not.toBe(
        loginRes1.body.data.access_token,
      );

      // 8. Token should be cleared from database
      const finalUser = await prisma.user.findUnique({
        where: { email: email.toLowerCase().trim() },
        select: {
          resetPasswordToken: true,
          resetPasswordExpires: true,
        },
      });

      expect(finalUser!.resetPasswordToken).toBeNull();
      expect(finalUser!.resetPasswordExpires).toBeNull();
    });
  });
});
`````

## File: backend/test/auth-register.e2e-spec.ts
`````typescript
import { INestApplication } from "@nestjs/common";
import { Test } from "@nestjs/testing";
import request from 'supertest';
import { AppModule } from "../src/app.module";
import { createTestApp } from "./utils/create-test-app";

describe("Auth register (e2e)", () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = await createTestApp(moduleRef);
  });

  afterAll(async () => {
    await app.close();
  });

  it("registers then rejects duplicate email with 409/400", async () => {
    const emailRaw = `register_dup_${Date.now()}_${Math.random().toString(36).substring(7)}@Example.com `;
    const email = emailRaw; // server should normalize
    const password = "Secret123!";

    // first register
    const res1 = await request(app.getHttpServer())
      .post("/api/v1/auth/register")
      .send({ email, password });
    if (![201, 200].includes(res1.status)) {
      throw new Error(`unexpected status: ${res1.status}`);
    }

    // duplicate register should fail (409 or 400 as BadRequest)
    const res2 = await request(app.getHttpServer())
      .post("/api/v1/auth/register")
      .send({ 
        email: emailRaw.toUpperCase(), 
        password 
      });
    if (![409, 400].includes(res2.status)) {
      throw new Error(`expected 409/400, got ${res2.status}`);
    }
  });
});
`````

## File: backend/test/auth-seed-user.e2e-spec.ts
`````typescript
import { INestApplication, ValidationPipe } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import request from 'supertest';
import { AppModule } from '../src/app.module';

/**
 * ã‚·ãƒ¼ãƒ‰ãƒ¦ãƒ¼ã‚¶ãƒ¼ã§ã®ãƒ­ã‚°ã‚¤ãƒ³ç¢ºèªE2Eãƒ†ã‚¹ãƒˆ
 * 
 * ã“ã®ãƒ†ã‚¹ãƒˆã¯ã€seed.ts ã§ä½œæˆã•ã‚ŒãŸãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®adminãƒ¦ãƒ¼ã‚¶ãƒ¼ã§
 * ãƒ­ã‚°ã‚¤ãƒ³ã§ãã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã™ã€‚
 * 
 * å‰ææ¡ä»¶:
 * - ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãŒåˆæœŸåŒ–æ¸ˆã¿ï¼ˆmigrate + seedå®Ÿè¡Œæ¸ˆã¿ï¼‰
 * - ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚·ãƒ¼ãƒ‰ãƒ¦ãƒ¼ã‚¶ãƒ¼: admin@example.com / Passw0rd!
 */
describe('Auth with Seed User (e2e)', () => {
  let app: INestApplication;

  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚·ãƒ¼ãƒ‰ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±
  const SEED_ADMIN_EMAIL = process.env.ADMIN_EMAIL || 'admin@example.com';
  const SEED_ADMIN_PASSWORD = process.env.ADMIN_PASSWORD || 'Passw0rd!';

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    app.useGlobalPipes(new ValidationPipe({ whitelist: true, transform: true }));
    app.setGlobalPrefix('api/v1');
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  describe('Login with seed user', () => {
    it('should login successfully with default seed admin user without CSRF token', async () => {
      const res = await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({
          email: SEED_ADMIN_EMAIL,
          password: SEED_ADMIN_PASSWORD,
        });

      // CSRFãƒˆãƒ¼ã‚¯ãƒ³ãªã—ã§ãƒ­ã‚°ã‚¤ãƒ³ã§ãã‚‹ã“ã¨ã‚’ç¢ºèª
      expect(res.status).toBe(201);
      expect(res.body).toHaveProperty('success', true);
      expect(res.body).toHaveProperty('data');
      expect(res.body.data).toHaveProperty('access_token');
      expect(res.body.data).toHaveProperty('user');
      
      const { user, access_token } = res.body.data;
      
      // ãƒˆãƒ¼ã‚¯ãƒ³ãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã‚’ç¢ºèª
      expect(typeof access_token).toBe('string');
      expect(access_token.length).toBeGreaterThan(0);
      
      // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã®ç¢ºèª
      expect(user.email).toBe(SEED_ADMIN_EMAIL.toLowerCase());
      expect(user.role).toBeDefined();
    });

    it('should access protected endpoints with JWT token from seed user login', async () => {
      // ã¾ãšãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—
      const loginRes = await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({
          email: SEED_ADMIN_EMAIL,
          password: SEED_ADMIN_PASSWORD,
        });

      expect(loginRes.status).toBe(201);
      const token = loginRes.body.data.access_token;
      expect(token).toBeDefined();

      // ä¿è­·ã•ã‚ŒãŸã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆï¼ˆ/api/v1/catsï¼‰ã«ã‚¢ã‚¯ã‚»ã‚¹
      const protectedRes = await request(app.getHttpServer())
        .get('/api/v1/cats')
        .set('Authorization', `Bearer ${token}`);

      // èªè¨¼ãŒæˆåŠŸã—ã€ãƒªã‚½ãƒ¼ã‚¹ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã“ã¨ã‚’ç¢ºèª
      expect(protectedRes.status).toBe(200);
      expect(protectedRes.body).toHaveProperty('success');
    });

    it('should return 401 for login with incorrect password', async () => {
      const res = await request(app.getHttpServer())
        .post('/api/v1/auth/login')
        .send({
          email: SEED_ADMIN_EMAIL,
          password: 'WrongPassword123!',
        });

      expect(res.status).toBe(401);
    });
  });
});
`````

## File: backend/test/breeding-ng-rules.e2e-spec.ts
`````typescript
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import request from 'supertest';

import { AppModule } from '../src/app.module';
import { createTestApp } from './utils/create-test-app';

describe('Breeding NG Rules API (e2e)', () => {
  let app: INestApplication;
  let authToken: string;
  let createdRuleId: string;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = await createTestApp(moduleRef);

    const email = `breeding_ng_rules_${Date.now()}@example.com`;
    const password = 'NgRulesTest123!';

    const res = await request(app.getHttpServer()).post('/api/v1/auth/register').send({ email, password });
    expect(res.status).toBe(201);

    const loginRes = await request(app.getHttpServer()).post('/api/v1/auth/login').send({ email, password });
    expect(loginRes.status).toBe(201);

    authToken = loginRes.body.data.access_token;
  });

  afterAll(async () => {
    await app.close();
  });

  it('should create a new NG rule', async () => {
    const res = await request(app.getHttpServer())
      .post('/api/v1/breeding/ng-rules')
      .set('Authorization', `Bearer ${authToken}`)
      .send({
        name: 'åŒä¸€ã‚¿ã‚°ç¦æ­¢',
        description: 'åŒã˜ã‚¿ã‚°åŒå£«ã®äº¤é…ã‚’ç¦æ­¢',
        type: 'TAG_COMBINATION',
        maleConditions: ['Champion'],
        femaleConditions: ['Champion'],
      });
    expect(res.status).toBe(201);

    expect(res.body.success).toBe(true);
    expect(res.body.data).toMatchObject({
      name: 'åŒä¸€ã‚¿ã‚°ç¦æ­¢',
      type: 'TAG_COMBINATION',
      active: true,
    });

    createdRuleId = res.body.data.id;
    expect(createdRuleId).toBeDefined();
  });

  it('should list NG rules including the created one', async () => {
    const res = await request(app.getHttpServer())
      .get('/api/v1/breeding/ng-rules')
      .set('Authorization', `Bearer ${authToken}`)
      .expect(200);

    expect(res.body.success).toBe(true);
    const found = res.body.data.find((rule: { id: string }) => rule.id === createdRuleId);
    expect(found).toBeDefined();
  });

  it('should update an existing NG rule', async () => {
    const res = await request(app.getHttpServer())
      .patch(`/api/v1/breeding/ng-rules/${createdRuleId}`)
      .set('Authorization', `Bearer ${authToken}`)
      .send({
        description: 'æ¡ä»¶ã‚’æ›´æ–°',
        maleConditions: ['GrandChampion'],
        femaleConditions: ['Champion'],
        active: false,
      });
    expect(res.status).toBe(200);

    expect(res.body.success).toBe(true);
    expect(res.body.data).toMatchObject({
      id: createdRuleId,
      description: 'æ¡ä»¶ã‚’æ›´æ–°',
      maleConditions: ['GrandChampion'],
      femaleConditions: ['Champion'],
      active: false,
    });
  });

  it('should delete the NG rule', async () => {
    const res = await request(app.getHttpServer())
      .delete(`/api/v1/breeding/ng-rules/${createdRuleId}`)
      .set('Authorization', `Bearer ${authToken}`);
    expect(res.status).toBe(200);

    expect(res.body.success).toBe(true);

    const listRes = await request(app.getHttpServer())
      .get('/api/v1/breeding/ng-rules')
      .set('Authorization', `Bearer ${authToken}`)
      .expect(200);

    const found = listRes.body.data.find((rule: { id: string }) => rule.id === createdRuleId);
    expect(found).toBeUndefined();
  });
});
`````

## File: backend/test/breeds-coat-colors.e2e-spec.ts
`````typescript
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { randomUUID } from 'crypto';
import request from 'supertest';
import { UserRole } from '@prisma/client';

import { AppModule } from '../src/app.module';
import { PrismaService } from '../src/prisma/prisma.service';
import { createTestApp } from './utils/create-test-app';

const httpStatus = {
  ok: 200,
  created: 201,
  badRequest: 400,
  notFound: 404,
};

const reserveUniqueCode = async (
  usedCodes: Set<number>,
  fetchExisting: (code: number) => Promise<unknown | null>,
) => {
  const maxAttempts = 500;
  for (let attempt = 0; attempt < maxAttempts; attempt += 1) {
    const candidate = 1000 + Math.floor(Math.random() * 9000);
    if (usedCodes.has(candidate)) {
      continue;
    }
    const exists = await fetchExisting(candidate);
    if (!exists) {
      usedCodes.add(candidate);
      return candidate;
    }
    usedCodes.add(candidate);
  }
  throw new Error('Unable to allocate a unique code within test constraints');
};

describe('Breeds & Coat Colors API (e2e)', () => {
  let app: INestApplication;
  let prisma: PrismaService;
  let adminToken: string;
  const createdBreedIds: string[] = [];
  const createdCoatColorIds: string[] = [];
  const usedBreedCodes = new Set<number>();
  const usedCoatColorCodes = new Set<number>();

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = await createTestApp(moduleRef);
    prisma = app.get(PrismaService);

    const [existingBreeds, existingColors] = await Promise.all([
      prisma.breed.findMany({ select: { code: true } }),
      prisma.coatColor.findMany({ select: { code: true } }),
    ]);

    existingBreeds.forEach(({ code }) => usedBreedCodes.add(code));
    existingColors.forEach(({ code }) => usedCoatColorCodes.add(code));

    const email = `coverage_admin_${Date.now()}@example.com`;
    const password = 'AdminCoverage123!';

    const res2 = await request(app.getHttpServer()).post('/api/v1/auth/register').send({ email, password });
    expect(res2.status).toBe(httpStatus.created);

    await prisma.user.update({
      where: { email },
      data: { role: UserRole.ADMIN },
    });

    const loginRes = await request(app.getHttpServer()).post('/api/v1/auth/login').send({ email, password });
    expect(loginRes.status).toBe(httpStatus.created);

    adminToken = loginRes.body.data.access_token;
  });

  afterAll(async () => {
    if (createdCoatColorIds.length > 0) {
      await prisma.coatColor.deleteMany({ where: { id: { in: createdCoatColorIds } } });
    }
    if (createdBreedIds.length > 0) {
      await prisma.breed.deleteMany({ where: { id: { in: createdBreedIds } } });
    }
    await app.close();
  });

  describe('Breeds endpoints', () => {
    let createdBreedId: string;

    const buildBreedPayload = async (
      overrides: Partial<{ code: number; name: string; description?: string }> = {},
    ) => ({
      code:
        overrides.code ??
        (await reserveUniqueCode(usedBreedCodes, (code: number) =>
          prisma.breed.findUnique({ where: { code } }),
        )),
      name: overrides.name ?? `Integration Breed ${randomUUID()}`,
      description: overrides.description ?? 'Integration coverage test breed',
    });

    it('allows admin to create a breed', async () => {
  const payload = await buildBreedPayload();

      const res = await request(app.getHttpServer())
        .post('/api/v1/breeds')
        .set('Authorization', `Bearer ${adminToken}`)
        .send(payload);

      expect(res.status).toBe(httpStatus.created);
      expect(res.body.success).toBe(true);
      expect(res.body.data).toMatchObject({
        name: payload.name,
        code: payload.code,
        description: payload.description,
      });

      createdBreedId = res.body.data.id;
      createdBreedIds.push(createdBreedId);
    });

    it('lists breeds with pagination and search support', async () => {
      const searchableBreed = await buildBreedPayload({
        name: `Integration Search Breed ${randomUUID()}`,
      });

  const createRes = await request(app.getHttpServer())
        .post('/api/v1/breeds')
        .set('Authorization', `Bearer ${adminToken}`)
        .send(searchableBreed);

      expect(createRes.status).toBe(httpStatus.created);
      createdBreedIds.push(createRes.body.data.id);

      const res = await request(app.getHttpServer())
        .get('/api/v1/breeds')
        .set('Authorization', `Bearer ${adminToken}`)
        .query({ page: 1, limit: 5, search: 'Search' })
        .expect(httpStatus.ok);

      expect(res.body.success).toBe(true);
      expect(Array.isArray(res.body.data)).toBe(true);
      expect(res.body.meta).toMatchObject({
        page: 1,
        limit: 5,
        total: expect.any(Number),
        totalPages: expect.any(Number),
      });
      expect(res.body.data.some((breed: any) => breed.name === searchableBreed.name)).toBe(true);
    });

    it('retrieves breed details including counts', async () => {
      const res = await request(app.getHttpServer())
        .get(`/api/v1/breeds/${createdBreedId}`)
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(httpStatus.ok);

      expect(res.body.success).toBe(true);
      expect(res.body.data.id).toBe(createdBreedId);
      expect(res.body.data._count).toBeDefined();
      expect(res.body.data._count.cats).toBeGreaterThanOrEqual(0);
    });

    it('updates breed metadata', async () => {
      const updatedDescription = 'Updated description for coverage checks';

      const res = await request(app.getHttpServer())
        .patch(`/api/v1/breeds/${createdBreedId}`)
        .set('Authorization', `Bearer ${adminToken}`)
        .send({ description: updatedDescription });

      expect(res.status).toBe(httpStatus.ok);
      expect(res.body.success).toBe(true);
      expect(res.body.data.description).toBe(updatedDescription);
    });

    it('returns breed statistics', async () => {
      const res = await request(app.getHttpServer())
        .get('/api/v1/breeds/statistics')
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(httpStatus.ok);

      expect(res.body.success).toBe(true);
      expect(res.body.data).toMatchObject({
        totalBreeds: expect.any(Number),
        mostPopularBreeds: expect.any(Array),
        breedDistribution: expect.any(Array),
      });
    });

    it('responds with 404 for missing breed', async () => {
      const res = await request(app.getHttpServer())
        .get(`/api/v1/breeds/${randomUUID()}`)
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(httpStatus.notFound);

      expect(res.body.success).toBe(false);
      expect(res.body.error.code).toBe('NOT_FOUND');
    });
  });

  describe('Coat color endpoints', () => {
    let createdCoatColorId: string;

    const buildCoatColorPayload = async (
      overrides: Partial<{ code: number; name: string; description?: string }> = {},
    ) => ({
      code:
        overrides.code ??
        (await reserveUniqueCode(usedCoatColorCodes, (code: number) =>
          prisma.coatColor.findUnique({ where: { code } }),
        )),
      name: overrides.name ?? `Integration Coat Color ${randomUUID()}`,
      description: overrides.description ?? 'Integration coverage test coat color',
    });

    it('allows admin to create a coat color', async () => {
  const payload = await buildCoatColorPayload();

      const res = await request(app.getHttpServer())
        .post('/api/v1/coat-colors')
        .set('Authorization', `Bearer ${adminToken}`)
        .send(payload);

      expect(res.status).toBe(httpStatus.created);
      expect(res.body.success).toBe(true);
      expect(res.body.data).toMatchObject({
        name: payload.name,
        code: payload.code,
      });

      createdCoatColorId = res.body.data.id;
      createdCoatColorIds.push(createdCoatColorId);
    });

    it('lists coat colors with pagination and search support', async () => {
      const searchableColor = await buildCoatColorPayload({
        name: `Integration Search Color ${randomUUID()}`,
      });

  const createRes = await request(app.getHttpServer())
        .post('/api/v1/coat-colors')
        .set('Authorization', `Bearer ${adminToken}`)
        .send(searchableColor);

      expect(createRes.status).toBe(httpStatus.created);
      createdCoatColorIds.push(createRes.body.data.id);

      const res = await request(app.getHttpServer())
        .get('/api/v1/coat-colors')
        .set('Authorization', `Bearer ${adminToken}`)
        .query({ page: 1, limit: 5, search: 'Search' })
        .expect(httpStatus.ok);

      expect(res.body.success).toBe(true);
      expect(Array.isArray(res.body.data)).toBe(true);
      expect(res.body.meta).toMatchObject({
        page: 1,
        limit: 5,
        total: expect.any(Number),
        totalPages: expect.any(Number),
      });
      expect(res.body.data.some((color: any) => color.name === searchableColor.name)).toBe(true);
    });

    it('retrieves coat color details including counts', async () => {
      const res = await request(app.getHttpServer())
        .get(`/api/v1/coat-colors/${createdCoatColorId}`)
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(httpStatus.ok);

      expect(res.body.success).toBe(true);
      expect(res.body.data.id).toBe(createdCoatColorId);
      expect(res.body.data._count).toBeDefined();
    });

    it('updates coat color description', async () => {
      const updatedDescription = 'Updated coat color description for coverage';

      const res = await request(app.getHttpServer())
        .patch(`/api/v1/coat-colors/${createdCoatColorId}`)
        .set('Authorization', `Bearer ${adminToken}`)
        .send({ description: updatedDescription });

      expect(res.status).toBe(httpStatus.ok);
      expect(res.body.success).toBe(true);
      expect(res.body.data.description).toBe(updatedDescription);
    });

    it('returns coat color statistics', async () => {
      const res = await request(app.getHttpServer())
        .get('/api/v1/coat-colors/statistics')
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(httpStatus.ok);

      expect(res.body.success).toBe(true);
      expect(res.body.data).toMatchObject({
        totalColors: expect.any(Number),
        mostPopularColors: expect.any(Array),
        colorDistribution: expect.any(Array),
      });
    });

    it('responds with 404 for missing coat color', async () => {
      const res = await request(app.getHttpServer())
        .get(`/api/v1/coat-colors/${randomUUID()}`)
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(httpStatus.notFound);

      expect(res.body.success).toBe(false);
      expect(res.body.error.code).toBe('NOT_FOUND');
    });
  });
});
`````

## File: backend/test/care-and-tags.e2e-spec.ts
`````typescript
import { INestApplication, ValidationPipe } from "@nestjs/common";
import { Test } from "@nestjs/testing";
import { Server } from "http";
import request from "supertest";
import { AppModule } from "../src/app.module";

describe("Care & Tags flows (e2e)", () => {
  let app: INestApplication;
  let server: Server;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();
    app = moduleRef.createNestApplication();
    app.useGlobalPipes(
      new ValidationPipe({ whitelist: true, transform: true }),
    );
    app.setGlobalPrefix("api/v1");
    await app.init();
    server = app.getHttpServer();
  });

  afterAll(async () => {
    await app.close();
  });

  it("care schedule: create -> complete (happy path with seed cat)", async () => {
    const email = `e2e_${Date.now()}@example.com`;
  const password = "Secret123!";

    // register & login
    const registerRes = await request(app.getHttpServer()).post('/api/v1/auth/register').send({ email, password });
    expect(registerRes.status).toBe(201);
    const login = await request(app.getHttpServer()).post('/api/v1/auth/login').send({ email, password });
    expect(login.status).toBe(201);
    const token = login.body.data.access_token as string;

    // create a cat owned by the registered user (avoid seed dependency)
    const catRes = await request(server)
      .post("/api/v1/cats")
      .set("Authorization", `Bearer ${token}`)
      .send({
        registrationNumber: `REG-${Date.now()}`,
        name: "E2E Kitty",
        gender: "FEMALE",
        birthDate: "2024-01-01T00:00:00.000Z",
      });
    expect(catRes.status).toBe(201);
    const catId =
      catRes.body.id ??
      catRes.body.data?.id ??
      catRes.body?.data?.cat?.id ??
      catRes.body?.cat?.id ??
      catRes.body?.data?.catId;
    expect(catId).toBeDefined();

    // create schedule
    const createRes = await request(server)
      .post("/api/v1/care/schedules")
      .set("Authorization", `Bearer ${token}`)
      .send({
        catIds: [catId],
        name: "å¹´æ¬¡å¥åº·è¨ºæ–­",
        careType: "HEALTH_CHECK",
        scheduledDate: "2025-09-01",
        description: "å¹´æ¬¡å¥è¨º",
      });
    expect(createRes.status).toBe(201);
    const scheduleId = createRes.body.data.id as string;
    expect(scheduleId).toBeDefined();

    // complete schedule
    const completeRes = await request(server)
      .patch(`/api/v1/care/schedules/${scheduleId}/complete`)
      .set("Authorization", `Bearer ${token}`)
      .send({ completedDate: "2025-09-02", notes: "è‰¯å¥½" });
    expect(completeRes.status).toBe(200);
  });

  it("tags: create -> assign -> unassign", async () => {
    const email = `e2e_${Date.now()}@example.com`;
    const password = "Secret123!";

    // register & login
    const registerRes = await request(app.getHttpServer()).post('/api/v1/auth/register').send({ email, password });
    expect(registerRes.status).toBe(201);
    const login = await request(app.getHttpServer()).post('/api/v1/auth/login').send({ email, password });
    expect(login.status).toBe(201);
    const token = login.body.data.access_token as string;

    // Get CSRF token for authenticated requests

    // create tag category
    const categoryRes = await request(server)
      .post("/api/v1/tags/categories")
      .set("Authorization", `Bearer ${token}`)
      .send({ name: "Test Category", key: `test_category_${Date.now()}` });
    expect(categoryRes.status).toBe(201);
    const categoryId = categoryRes.body.data.id as string;
    expect(categoryId).toBeDefined();

    // create tag group
    const groupRes = await request(server)
      .post("/api/v1/tags/groups")
      .set("Authorization", `Bearer ${token}`)
      .send({ categoryId, name: "Test Group" });
    expect(groupRes.status).toBe(201);
    const groupId = groupRes.body.data.id as string;
    expect(groupId).toBeDefined();

    // create tag
    const tagName = `tag_${Date.now()}`;
    const tagRes = await request(server)
      .post("/api/v1/tags")
      .set("Authorization", `Bearer ${token}`)
      .send({ name: tagName, groupId, color: "#3B82F6" });
    expect(tagRes.status).toBe(201);
    const tagId = tagRes.body.data.id as string;
    expect(tagId).toBeDefined();

    // create a cat (avoid dependency on existing data)
    const catRes = await request(server)
      .post("/api/v1/cats")
      .set("Authorization", `Bearer ${token}`)
      .send({
        registrationNumber: `REG-${Date.now()}`,
        name: "E2E Tag Cat",
        gender: "FEMALE",
        birthDate: "2024-01-01T00:00:00.000Z",
      });
    expect(catRes.status).toBe(201);
    const catId =
      catRes.body.id ??
      catRes.body.data?.id ??
      catRes.body?.data?.cat?.id ??
      catRes.body?.cat?.id ??
      catRes.body?.data?.catId;
    expect(catId).toBeDefined();

    // assign
    const assignRes = await request(server)
      .post(`/api/v1/tags/cats/${catId}/tags`)
      .set("Authorization", `Bearer ${token}`)
      .send({ tagId });
    expect(assignRes.status).toBe(200);

    // unassign
    const unassignRes = await request(server)
      .delete(`/api/v1/tags/cats/${catId}/tags/${tagId}`)
      .set("Authorization", `Bearer ${token}`)
    expect(unassignRes.status).toBe(200);
  });
});
`````

## File: backend/test/care-tags.e2e-spec.ts
`````typescript
import { INestApplication } from "@nestjs/common";
import { Test } from "@nestjs/testing";
import request from "supertest";
import { AppModule } from "../src/app.module";
import { createTestApp } from "./utils/create-test-app";

describe("Care & Tags flows (e2e)", () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = await createTestApp(moduleRef);
  });

  afterAll(async () => {
    await app.close();
  });

  it("tags: register -> login -> create cat -> create tag -> assign/unassign", async () => {
    const email = `care_${Date.now()}@example.com`;
  const password = "Secret123!";

    // register
    const registerRes = await request(app.getHttpServer()).post("/api/v1/auth/register").send({ email, password });
    expect(registerRes.status).toBe(201);

    // login
    const login = await request(app.getHttpServer()).post("/api/v1/auth/login").send({ email, password });
    expect(login.status).toBe(201);
    const token = login.body.data.access_token as string;

    // create a cat (owned by the registered user)
    const catRes = await request(app.getHttpServer())
      .post("/api/v1/cats")
      .set("Authorization", `Bearer ${token}`)
      .send({
        registrationNumber: `REG-${Date.now()}`,
        name: "E2E Kitty",
        gender: "FEMALE",
        birthDate: "2024-01-01T00:00:00.000Z",
      });
    expect(catRes.status).toBe(201);
    const catId =
      catRes.body.id ??
      catRes.body.data?.id ??
      catRes.body?.data?.cat?.id ??
      catRes.body?.cat?.id ??
      catRes.body?.data?.catId;

    // create a tag category first
    const categoryRes = await request(app.getHttpServer())
      .post("/api/v1/tags/categories")
      .set("Authorization", `Bearer ${token}`)
      .send({ name: "Test Category", key: `test_category_${Date.now()}` });
    expect(categoryRes.status).toBe(201);
    const categoryId = categoryRes.body.data.id as string;

    // create a tag group
    const groupRes = await request(app.getHttpServer())
      .post("/api/v1/tags/groups")
      .set("Authorization", `Bearer ${token}`)
      .send({ categoryId, name: "Test Group" });
    expect(groupRes.status).toBe(201);
    const groupId = groupRes.body.data.id as string;

    // create a tag (auth required)
    const tagRes = await request(app.getHttpServer())
      .post("/api/v1/tags")
      .set("Authorization", `Bearer ${token}`)
      .send({ name: `indoor-${Date.now()}`, groupId, color: "#00AA88" });
    expect(tagRes.status).toBe(201);
    const tagId = tagRes.body.data.id as string;

    // assign tag to cat
    const assignRes = await request(app.getHttpServer())
      .post(`/api/v1/tags/cats/${catId}/tags`)
      .set("Authorization", `Bearer ${token}`)
      .send({ tagId });
    if (!assignRes.body.success) throw new Error("assign failed");

    // unassign tag from cat
    const unassignRes = await request(app.getHttpServer())
      .delete(`/api/v1/tags/cats/${catId}/tags/${tagId}`)
      .set("Authorization", `Bearer ${token}`)
    expect(unassignRes.status).toBe(200);
    if (!unassignRes.body.success) throw new Error("unassign failed");
  });

  it("care: register -> login -> create cat -> create schedule -> complete", async () => {
    const email = `care2_${Date.now()}@example.com`;
  const password = "Secret123!";

    // register & login
    const res = await request(app.getHttpServer()).post("/api/v1/auth/register").send({ email, password });
    expect(res.status).toBe(201);
    const login = await request(app.getHttpServer()).post("/api/v1/auth/login").send({ email, password });
    expect(login.status).toBe(201);
    const token = login.body.data.access_token as string;

    // Get CSRF token for authenticated requests

    // create a cat
    const catRes = await request(app.getHttpServer())
      .post("/api/v1/cats")
      .set("Authorization", `Bearer ${token}`)
      .send({
        registrationNumber: `REG-${Date.now()}`,
        name: "E2E Care Cat",
        gender: "FEMALE",
        birthDate: "2024-01-01T00:00:00.000Z",
      });
    expect(catRes.status).toBe(201);
    const catId =
      catRes.body.id ??
      catRes.body.data?.id ??
      catRes.body?.data?.cat?.id ??
      catRes.body?.cat?.id ??
      catRes.body?.data?.catId;

    // create care schedule
    const schedCreate = await request(app.getHttpServer())
      .post("/api/v1/care/schedules")
      .set("Authorization", `Bearer ${token}`)
      .send({
        catIds: [catId],
        name: "Annual Health Check",
        careType: "HEALTH_CHECK",
        scheduledDate: "2025-09-01",
        description: "Annual check",
      });
    expect(schedCreate.status).toBe(201);
    const scheduleId = schedCreate.body.data.id as string;

    // complete it with next schedule
    const completeRes = await request(app.getHttpServer())
      .patch(`/api/v1/care/schedules/${scheduleId}/complete`)
      .set("Authorization", `Bearer ${token}`)
      .send({
        completedDate: "2025-09-01",
        nextScheduledDate: "2026-09-01",
        notes: "All good",
      });
    expect(completeRes.status).toBe(200);
    if (!completeRes.body.success) throw new Error("complete failed");

    // fetch schedules list for the cat
    const list = await request(app.getHttpServer())
      .get(`/api/v1/care/schedules?catId=${catId}`)
    expect(list.status).toBe(200);
    expect(list.body.data?.length).toBeGreaterThan(0);
  });
});
`````

## File: backend/test/cats.e2e-spec.ts
`````typescript
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import request from 'supertest';
import { randomUUID } from 'crypto';

import { AppModule } from '../src/app.module';
import { createTestApp } from './utils/create-test-app';

interface CatPayload {
  registrationNumber: string;
  name: string;
  gender: 'MALE' | 'FEMALE';
  birthDate: string;
  weight?: number;
  microchipNumber?: string;
  notes?: string;
  breedId?: string;
  colorId?: string;
  fatherId?: string;
  motherId?: string;
}

function buildCatPayload(overrides: Partial<CatPayload> = {}): CatPayload {
  return {
    registrationNumber: `CAT-${randomUUID()}`,
    name: 'Test Cat',
    gender: 'MALE',
    birthDate: '2024-01-01',
    ...overrides,
  };
}

describe('Cats API (e2e)', () => {
  let app: INestApplication;
  let authToken: string;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = await createTestApp(moduleRef);

    const email = `cats_test_${Date.now()}@example.com`;
    const password = 'CatsTest123!';

    const res = await request(app.getHttpServer()).post('/api/v1/auth/register').send({ email, password });
    expect(res.status).toBe(201);

    const loginRes = await request(app.getHttpServer()).post('/api/v1/auth/login').send({ email, password });
    expect(loginRes.status).toBe(201);

    authToken = loginRes.body.data.access_token;
  });

  describe('GET /api/v1/cats', () => {
    it('should return paginated list of cats', async () => {
      const res = await request(app.getHttpServer())
        .get('/api/v1/cats')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      expect(res.body.success).toBe(true);
      expect(Array.isArray(res.body.data)).toBe(true);
      expect(res.body.meta).toMatchObject({
        page: expect.any(Number),
        limit: expect.any(Number),
        total: expect.any(Number),
        totalPages: expect.any(Number),
      });
    });

    it('should reject request without authentication', async () => {
      const res = await request(app.getHttpServer())
        .get('/api/v1/cats')
        .expect(401);

      expect(res.body.success).toBe(false);
      expect(res.body.error.code).toBe('UNAUTHORIZED');
    });

    it('should respond within 1 second (performance check)', async () => {
      const startTime = Date.now();

      const res = await request(app.getHttpServer())
        .get('/api/v1/cats')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      expect(res.body.success).toBe(true);
      const duration = Date.now() - startTime;
      expect(duration).toBeLessThan(1000);
    });
  });

  describe('POST /api/v1/cats', () => {
    it('should create a new cat with valid data', async () => {
      const catData = buildCatPayload();

      const res = await request(app.getHttpServer())
        .post('/api/v1/cats')
        .set('Authorization', `Bearer ${authToken}`)
        .send(catData)
        .expect(201);

      expect(res.body.success).toBe(true);
      expect(res.body.data).toMatchObject({
        registrationNumber: catData.registrationNumber,
        name: catData.name,
        gender: catData.gender,
      });
      expect(res.body.data.id).toBeDefined();
    });

    it('should validate required fields', async () => {
      const res = await request(app.getHttpServer())
        .post('/api/v1/cats')
        .set('Authorization', `Bearer ${authToken}`)
        .send({})
        .expect(400);

      expect(res.body.success).toBe(false);
      expect(res.body.error.code).toBe('BAD_REQUEST');
      expect(res.body.error.details).toEqual(
        expect.arrayContaining([
          expect.stringContaining('name'),
          expect.stringContaining('gender'),
          expect.stringContaining('birthDate'),
        ]),
      );
    });

    it('should validate gender enum', async () => {
      const invalidPayload = {
        ...buildCatPayload(),
        gender: 'INVALID_GENDER' as unknown as 'MALE',
      };

      const res = await request(app.getHttpServer())
        .post('/api/v1/cats')
        .set('Authorization', `Bearer ${authToken}`)
        .send(invalidPayload)
        .expect(400);

      expect(res.body.success).toBe(false);
      expect(res.body.error.code).toBe('BAD_REQUEST');
    });

    it('should validate date format', async () => {
      const res = await request(app.getHttpServer())
        .post('/api/v1/cats')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          ...buildCatPayload(),
          birthDate: 'invalid-date',
        })
        .expect(400);

      expect(res.body.success).toBe(false);
      expect(res.body.error.code).toBe('BAD_REQUEST');
    });

    it('should handle unique registration number constraint', async () => {
      const registrationNumber = `UNIQUE-${randomUUID()}`;

      await request(app.getHttpServer())
        .post('/api/v1/cats')
        .set('Authorization', `Bearer ${authToken}`)
        .send(buildCatPayload({ registrationNumber }))
        .expect(201);

      const duplicateRes = await request(app.getHttpServer())
        .post('/api/v1/cats')
        .set('Authorization', `Bearer ${authToken}`)
        .send(buildCatPayload({ registrationNumber, name: 'Duplicate Cat' }))
        .expect(409);

      expect(duplicateRes.body.success).toBe(false);
      expect(duplicateRes.body.error.code).toBe('CONFLICT');
      expect(duplicateRes.body.error.message).toContain('registration number');
    });

    it('should handle unique microchip number constraint', async () => {
      const microchipNumber = `${randomUUID().replace(/-/g, '').substring(0, 15)}`;
      const registrationNumber1 = `CAT-${randomUUID()}`;
      const registrationNumber2 = `CAT-${randomUUID()}`;

      await request(app.getHttpServer())
        .post('/api/v1/cats')
        .set('Authorization', `Bearer ${authToken}`)
        .send({ ...buildCatPayload({ registrationNumber: registrationNumber1 }), microchipNumber })
        .expect(201);

      const duplicateRes = await request(app.getHttpServer())
        .post('/api/v1/cats')
        .set('Authorization', `Bearer ${authToken}`)
        .send({ ...buildCatPayload({ registrationNumber: registrationNumber2, name: 'Duplicate Cat' }), microchipNumber })
        .expect(409);

      expect(duplicateRes.body.success).toBe(false);
      expect(duplicateRes.body.error.code).toBe('CONFLICT');
      expect(duplicateRes.body.error.message).toContain('microchip');
    });

    it('should create multiple cats successfully', async () => {
      const payloads = [buildCatPayload(), buildCatPayload(), buildCatPayload()];

      for (const payload of payloads) {
        const res = await request(app.getHttpServer())
          .post('/api/v1/cats')
          .set('Authorization', `Bearer ${authToken}`)
          .send(payload)
          .expect(201);

        expect(res.body.success).toBe(true);
        expect(res.body.data.name).toBe(payload.name);
      }
    });
  });

  describe('GET /api/v1/cats/:id', () => {
    let createdCatId: string;

    beforeAll(async () => {
      const res = await request(app.getHttpServer())
        .post('/api/v1/cats')
        .set('Authorization', `Bearer ${authToken}`)
        .send(buildCatPayload({ name: 'Get By ID Test' }))
        .expect(201);

      createdCatId = res.body.data.id;
    });

    it('should get cat by valid ID', async () => {
      const res = await request(app.getHttpServer())
        .get(`/api/v1/cats/${createdCatId}`)
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      expect(res.body.success).toBe(true);
      expect(res.body.data.id).toBe(createdCatId);
      expect(res.body.data.name).toBe('Get By ID Test');
    });

    it('should return 404 for non-existent ID', async () => {
      const missingId = randomUUID();
      const res = await request(app.getHttpServer())
        .get(`/api/v1/cats/${missingId}`)
        .set('Authorization', `Bearer ${authToken}`)
        .expect(404);

      expect(res.body.success).toBe(false);
      expect(res.body.error.code).toBe('NOT_FOUND');
      expect(res.body.error.message).toContain(missingId);
    });

    it('should return 400 for invalid UUID format', async () => {
      const res = await request(app.getHttpServer())
        .get('/api/v1/cats/invalid-uuid')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(400);

      expect(res.body.success).toBe(false);
      expect(res.body.error.code).toBe('BAD_REQUEST');
      expect(res.body.error.message).toContain('uuid');
    });
  });

  describe('PATCH /api/v1/cats/:id', () => {
    let catId: string;

    beforeEach(async () => {
      const res = await request(app.getHttpServer())
        .post('/api/v1/cats')
        .set('Authorization', `Bearer ${authToken}`)
        .send(buildCatPayload({ name: 'Original Name' }))
        .expect(201);

      catId = res.body.data.id;
    });

    it('should update cat with valid data', async () => {
      const updateData = {
        name: 'Updated Name',
        description: 'Updated description',
      };

      const res = await request(app.getHttpServer())
        .patch(`/api/v1/cats/${catId}`)
        .set('Authorization', `Bearer ${authToken}`)
        .send(updateData)
        .expect(200);

      expect(res.body.success).toBe(true);
      expect(res.body.data.name).toBe(updateData.name);
      expect(res.body.data.description).toBe(updateData.description);
    });

    it('should allow partial updates', async () => {
      const res = await request(app.getHttpServer())
        .patch(`/api/v1/cats/${catId}`)
        .set('Authorization', `Bearer ${authToken}`)
        .send({ name: 'Only Name Updated' })
        .expect(200);

      expect(res.body.success).toBe(true);
      expect(res.body.data.name).toBe('Only Name Updated');
    });

    it('should return 404 for non-existent cat', async () => {
      const missingId = randomUUID();
      const res = await request(app.getHttpServer())
        .patch(`/api/v1/cats/${missingId}`)
        .set('Authorization', `Bearer ${authToken}`)
        .send({ name: 'New Name' })
        .expect(404);

      expect(res.body.success).toBe(false);
      expect(res.body.error.code).toBe('NOT_FOUND');
      expect(res.body.error.message).toContain(missingId);
    });

    it('should validate updated data', async () => {
      const res = await request(app.getHttpServer())
        .patch(`/api/v1/cats/${catId}`)
        .set('Authorization', `Bearer ${authToken}`)
        .send({ gender: 'INVALID_GENDER' })
        .expect(400);

      expect(res.body.success).toBe(false);
      expect(res.body.error.code).toBe('BAD_REQUEST');
    });
  });

  describe('DELETE /api/v1/cats/:id', () => {
    let catId: string;

    beforeEach(async () => {
      const res = await request(app.getHttpServer())
        .post('/api/v1/cats')
        .set('Authorization', `Bearer ${authToken}`)
        .send(buildCatPayload({ name: 'To Be Deleted' }))
        .expect(201);

      catId = res.body.data.id;
    });

    it('should delete cat successfully', async () => {
      const res = await request(app.getHttpServer())
        .delete(`/api/v1/cats/${catId}`)
        .set('Authorization', `Bearer ${authToken}`)
      expect(res.status).toBe(200);

      expect(res.body.success).toBe(true);

      const verifyRes = await request(app.getHttpServer())
        .get(`/api/v1/cats/${catId}`)
        .set('Authorization', `Bearer ${authToken}`)
        .expect(404);

      expect(verifyRes.body.success).toBe(false);
      expect(verifyRes.body.error.code).toBe('NOT_FOUND');
    });

    it('should return 404 when deleting non-existent cat', async () => {
      const missingId = randomUUID();
      const res = await request(app.getHttpServer())
        .delete(`/api/v1/cats/${missingId}`)
        .set('Authorization', `Bearer ${authToken}`)
      expect(res.status).toBe(404);

      expect(res.body.success).toBe(false);
      expect(res.body.error.code).toBe('NOT_FOUND');
      expect(res.body.error.message).toContain(missingId);
    });

    it('should return 400 for invalid UUID', async () => {
      const res = await request(app.getHttpServer())
        .delete('/api/v1/cats/invalid-id')
        .set('Authorization', `Bearer ${authToken}`)
      expect(res.status).toBe(400);

      expect(res.body.success).toBe(false);
      expect(res.body.error.code).toBe('BAD_REQUEST');
      expect(res.body.error.message).toContain('uuid');
    });
  });

  describe('Performance Tests', () => {
    it('should handle bulk create efficiently', async () => {
      const startTime = Date.now();
      const responses = [];

      for (let i = 0; i < 10; i++) {
        const res = await request(app.getHttpServer())
          .post('/api/v1/cats')
          .set('Authorization', `Bearer ${authToken}`)
          .send(buildCatPayload())
          .expect(201);
        responses.push(res);
      }

      responses.forEach((res) => expect(res.body.success).toBe(true));

      const duration = Date.now() - startTime;
      expect(duration).toBeLessThan(5000);
    }, 10000);

    it('should list cats efficiently with pagination', async () => {
      const startTime = Date.now();

      const res = await request(app.getHttpServer())
        .get('/api/v1/cats')
        .query({ page: 1, limit: 50 })
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      expect(res.body.success).toBe(true);

      const duration = Date.now() - startTime;
      expect(duration).toBeLessThan(1000);
    });
  });

  describe('Error Handling', () => {
    it('should return structured error response', async () => {
      const res = await request(app.getHttpServer())
        .post('/api/v1/cats')
        .set('Authorization', `Bearer ${authToken}`)
        .send({ gender: 'INVALID' })
        .expect(400);

      expect(res.body.success).toBe(false);
      expect(res.body.error).toMatchObject({
        code: 'BAD_REQUEST',
        statusCode: 400,
      });
      expect(Array.isArray(res.body.error.details) || typeof res.body.error.details === 'undefined').toBe(true);
    });

    it('should handle database errors gracefully', async () => {
      const res = await request(app.getHttpServer())
        .post('/api/v1/cats')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          ...buildCatPayload(),
          breedId: 'invalid-uuid',
        })
        .expect(400);

      expect(res.body.success).toBe(false);
      expect(res.body.error.code).toBe('BAD_REQUEST');
    });
  });
});
`````

## File: backend/test/pedigree.e2e-spec.ts
`````typescript
import { INestApplication, NotFoundException } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { randomUUID } from 'crypto';
import request from 'supertest';

import { AppModule } from '../src/app.module';
import { PrismaService } from '../src/prisma/prisma.service';
import { PedigreeService } from '../src/pedigree/pedigree.service';
import { CreatePedigreeDto } from '../src/pedigree/dto/create-pedigree.dto';
import { createTestApp } from './utils/create-test-app';

const httpStatus = {
  ok: 200,
  created: 201,
  forbidden: 403,
  notFound: 404,
};

describe('Pedigree module (integration)', () => {
  let app: INestApplication;
  let prisma: PrismaService;
  let pedigreeService: PedigreeService;
  const createdPedigreeIds: string[] = [];
  const createdBreedIds: string[] = [];
  const createdCoatColorIds: string[] = [];
  const createdGenderIds: string[] = [];

  const buildCreateDto = (overrides: Partial<CreatePedigreeDto> = {}) => {
    const base: Partial<CreatePedigreeDto> = {
      pedigreeId: overrides.pedigreeId ?? `PED-${Date.now()}-${randomUUID()}`,
      catName: overrides.catName ?? `Coverage Cat ${randomUUID()}`,
    };

    const cleanedOverrides = Object.fromEntries(
      Object.entries(overrides).filter(([, value]) => value !== undefined),
    ) as Partial<CreatePedigreeDto>;

    return {
      ...base,
      ...cleanedOverrides,
    } as CreatePedigreeDto;
  };

  const registerPedigree = async (overrides: Partial<CreatePedigreeDto> = {}) => {
    const dto = buildCreateDto(overrides);
    const result = await pedigreeService.create(dto);
    createdPedigreeIds.push(result.data.id);
    return result.data;
  };

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = await createTestApp(moduleRef);
    prisma = app.get(PrismaService);
    pedigreeService = app.get(PedigreeService);
  });

  afterAll(async () => {
    if (createdPedigreeIds.length > 0) {
      await prisma.pedigree.deleteMany({
        where: { id: { in: createdPedigreeIds } },
      });
    }

    if (createdBreedIds.length > 0) {
      await prisma.breed.deleteMany({ where: { id: { in: createdBreedIds } } });
    }

    if (createdCoatColorIds.length > 0) {
      await prisma.coatColor.deleteMany({ where: { id: { in: createdCoatColorIds } } });
    }

    if (createdGenderIds.length > 0) {
      await prisma.gender.deleteMany({ where: { id: { in: createdGenderIds } } });
    }

    await app.close();
  });

  describe('read operations via HTTP', () => {
    it('creates pedigrees via service and exposes them through list and detail endpoints', async () => {
      const created = await registerPedigree({ title: 'Integration Pedigree' });

      const listRes = await request(app.getHttpServer())
        .get('/api/v1/pedigrees')
        .query({ search: 'Integration' })
        .expect(httpStatus.ok);

      expect(listRes.body.success).toBe(true);
      expect(Array.isArray(listRes.body.data)).toBe(true);
      expect(listRes.body.data.some((item: any) => item.id === created.id)).toBe(true);
      expect(listRes.body.meta).toMatchObject({
        page: 1,
        total: expect.any(Number),
        limit: expect.any(Number),
        totalPages: expect.any(Number),
      });

      const byIdRes = await request(app.getHttpServer())
        .get(`/api/v1/pedigrees/${created.id}`)
        .expect(httpStatus.ok);

      expect(byIdRes.body.success).toBe(true);
      expect(byIdRes.body.data.id).toBe(created.id);
      expect(byIdRes.body.data.catName).toBe(created.catName);

      const byPedigreeIdRes = await request(app.getHttpServer())
        .get(`/api/v1/pedigrees/pedigree-id/${created.pedigreeId}`)
        .expect(httpStatus.ok);

      expect(byPedigreeIdRes.body.success).toBe(true);
      expect(byPedigreeIdRes.body.data.id).toBe(created.id);
    });

    it('returns family tree and family projections for stored pedigrees', async () => {
      const created = await registerPedigree({ title: 'Family Tree Pedigree' });

      const familyTreeRes = await request(app.getHttpServer())
        .get(`/api/v1/pedigrees/${created.id}/family-tree`)
        .expect(httpStatus.ok);

      expect(familyTreeRes.body.success).toBe(true);
      expect(familyTreeRes.body.data.id).toBe(created.id);

      const familyRes = await request(app.getHttpServer())
        .get(`/api/v1/pedigrees/${created.id}/family`)
        .query({ generations: 2 })
        .expect(httpStatus.ok);

      expect(familyRes.body.success).toBe(true);
      expect(familyRes.body.data.id).toBe(created.id);
    });
  });

  describe('write operations via service', () => {
    it('updates an existing pedigree and persists changes', async () => {
      const created = await registerPedigree({ title: 'Update target' });

      const updated = await pedigreeService.update(created.id, { notes: 'Updated note for coverage' });

      expect(updated.success).toBe(true);
      expect(updated.data.notes).toBe('Updated note for coverage');

      const verifyRes = await request(app.getHttpServer())
        .get(`/api/v1/pedigrees/${created.id}`)
        .expect(httpStatus.ok);

      expect(verifyRes.body.data.notes).toBe('Updated note for coverage');
    });

    it('removes a pedigree and the endpoint responds with not found afterwards', async () => {
      const created = await registerPedigree({ title: 'Delete target' });

      const removal = await pedigreeService.remove(created.id);

      expect(removal.success).toBe(true);

      const notFoundRes = await request(app.getHttpServer())
        .get(`/api/v1/pedigrees/${created.id}`)
        .expect(httpStatus.notFound);

      expect(notFoundRes.body.success).toBe(false);
      expect(notFoundRes.body.error.code).toBe('NOT_FOUND');

      // remove id to avoid afterAll attempting to delete again
      const index = createdPedigreeIds.indexOf(created.id);
      if (index !== -1) {
        createdPedigreeIds.splice(index, 1);
      }
    });
  });

  describe('authorization and error handling', () => {
    it('rejects pedigree creation via HTTP without admin role', async () => {
      const payload = buildCreateDto({ title: 'Forbidden attempt' });

      const res = await request(app.getHttpServer())
        .post('/api/v1/pedigrees')
        .send(payload);
      expect(res.status).toBe(httpStatus.forbidden);

      expect(res.body.success).toBe(false);
      expect(res.body.error.code).toBe('FORBIDDEN');
    });

    it('returns not found for pedigree lookups by id and pedigree id', async () => {
      const missingId = randomUUID();
      const missingPedigreeId = `PED-MISSING-${Date.now()}`;

      const byIdRes = await request(app.getHttpServer())
        .get(`/api/v1/pedigrees/${missingId}`)
        .expect(httpStatus.notFound);

      expect(byIdRes.body.success).toBe(false);
      expect(byIdRes.body.error.code).toBe('NOT_FOUND');

      const byPedigreeIdRes = await request(app.getHttpServer())
        .get(`/api/v1/pedigrees/pedigree-id/${missingPedigreeId}`)
        .expect(httpStatus.notFound);

      expect(byPedigreeIdRes.body.success).toBe(false);
      expect(byPedigreeIdRes.body.error.code).toBe('NOT_FOUND');
    });

    it('propagates not found errors from service update and removal', async () => {
      const missingId = randomUUID();

      await expect(
        pedigreeService.update(missingId, { notes: 'never persisted' }),
      ).rejects.toBeInstanceOf(NotFoundException);

      await expect(pedigreeService.remove(missingId)).rejects.toBeInstanceOf(NotFoundException);
    });

    it('returns not found for family and descendant endpoints when pedigree does not exist', async () => {
      const missingId = randomUUID();

      const familyTreeRes = await request(app.getHttpServer())
        .get(`/api/v1/pedigrees/${missingId}/family-tree`)
        .expect(httpStatus.notFound);

      expect(familyTreeRes.body.success).toBe(false);

      const familyRes = await request(app.getHttpServer())
        .get(`/api/v1/pedigrees/${missingId}/family`)
        .expect(httpStatus.notFound);

      expect(familyRes.body.success).toBe(false);

      const descendantsRes = await request(app.getHttpServer())
        .get(`/api/v1/pedigrees/${missingId}/descendants`)
        .expect(httpStatus.notFound);

      expect(descendantsRes.body.success).toBe(false);
    });
  });

  describe('advanced list and relation projections', () => {
    it('filters pedigrees by codes and attributes', async () => {
      let breed = await prisma.breed.findFirst();

      if (!breed) {
        const code = 100000 + Math.floor(Math.random() * 900000);
        breed = await prisma.breed.create({
          data: {
            code,
            name: `Test Breed ${code}`,
          },
        });
        createdBreedIds.push(breed.id);
      }

      let color = await prisma.coatColor.findFirst();

      if (!color) {
        const code = 100000 + Math.floor(Math.random() * 900000);
        color = await prisma.coatColor.create({
          data: {
            code,
            name: `Test Coat ${code}`,
          },
        });
        createdCoatColorIds.push(color.id);
      }

      let gender = await prisma.gender.findFirst();

      if (!gender) {
        const code = 100000 + Math.floor(Math.random() * 900000);
        gender = await prisma.gender.create({
          data: {
            code,
            name: `Test Gender ${code}`,
          },
        });
        createdGenderIds.push(gender.id);
      }

      const created = await registerPedigree({
        title: 'Filter coverage pedigree',
        eyeColor: 'Amber',
      });

      await prisma.pedigree.update({
        where: { id: created.id },
        data: {
          breedCode: breed.code,
          coatColorCode: color.code,
          genderCode: gender.code,
          eyeColor: 'Amber',
        },
      });

      const listRes = await request(app.getHttpServer())
        .get('/api/v1/pedigrees')
        .query({
          breedId: String(breed.code),
          coatColorId: String(color.code),
          gender: String(gender.code),
          eyeColor: 'Amber',
          page: 1,
          limit: 5,
          sortBy: 'createdAt',
          sortOrder: 'asc',
        })
        .expect(httpStatus.ok);

      expect(listRes.body.success).toBe(true);
      expect(listRes.body.data.some((item: any) => item.id === created.id)).toBe(true);
      expect(listRes.body.meta).toMatchObject({ total: expect.any(Number), page: 1, limit: 5 });
    });

    it('returns descendants list for an existing pedigree', async () => {
      const parent = await registerPedigree({ title: 'Descendant root', catName: `Parent Cat ${randomUUID()}` });

      const child = await prisma.pedigree.create({
        data: {
          pedigreeId: `PED-CHILD-${Date.now()}-${randomUUID()}`,
          catName: `Child Cat ${randomUUID()}`,
          fatherCatName: parent.catName,
        },
      });

      createdPedigreeIds.push(child.id);

      const res = await request(app.getHttpServer())
        .get(`/api/v1/pedigrees/${parent.id}/descendants`)
        .expect(httpStatus.ok);

      expect(res.body.success).toBe(true);
      expect(res.body.data.pedigree.id).toBe(parent.id);
      expect(Array.isArray(res.body.data.children)).toBe(true);
    });
  });
});
`````

## File: backend/test/setup-e2e.ts
`````typescript
import { config } from 'dotenv';
import { resolve } from 'path';

// E2Eãƒ†ã‚¹ãƒˆå®Ÿè¡Œå‰ã«.env.testãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€
const envTestPath = resolve(__dirname, '../.env.test');
config({ path: envTestPath });
`````

## File: backend/test/tenants.e2e-spec.ts
`````typescript
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication, ValidationPipe } from '@nestjs/common';
import request from 'supertest';
import { UserRole } from '@prisma/client';

import { AppModule } from '../src/app.module';
import { PrismaService } from '../src/prisma/prisma.service';

describe('Tenants (e2e)', () => {
  let app: INestApplication;
  let prisma: PrismaService;
  let superAdminToken: string;
  let tenantAdminToken: string;
  let createdTenantId: string;
  let invitationToken: string;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    app.useGlobalPipes(
      new ValidationPipe({
        whitelist: true,
        forbidNonWhitelisted: true,
        transform: true,
      }),
    );

    await app.init();
    prisma = app.get<PrismaService>(PrismaService);

    // ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    await prisma.invitationToken.deleteMany({});
    await prisma.user.deleteMany({
      where: {
        email: {
          in: [
            'superadmin@test.com',
            'tenantadmin@test.com',
            'newuser@test.com',
          ],
        },
      },
    });
    await prisma.tenant.deleteMany({
      where: {
        slug: {
          in: ['test-tenant', 'test-tenant-2'],
        },
      },
    });

    // SuperAdmin ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ä½œæˆ
    await prisma.user.create({
      data: {
        email: 'superadmin@test.com',
        clerkId: 'test_superadmin',
        role: UserRole.SUPER_ADMIN,
        passwordHash: '$2a$10$TEST_HASH', // ãƒ€ãƒŸãƒ¼ãƒãƒƒã‚·ãƒ¥
        isActive: true,
      },
    });

    // SuperAdmin ã¨ã—ã¦ãƒ­ã‚°ã‚¤ãƒ³ï¼ˆç°¡æ˜“çš„ãªãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆï¼‰
    await request(app.getHttpServer())
      .post('/auth/register')
      .send({
        email: 'superadmin2@test.com',
        password: 'SuperSecure123!',
      });

    // ä½œæˆã—ãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ­ãƒ¼ãƒ«ã‚’ SUPER_ADMIN ã«å¤‰æ›´
    await prisma.user.update({
      where: { email: 'superadmin2@test.com' },
      data: { role: UserRole.SUPER_ADMIN },
    });

    // å†åº¦ãƒ­ã‚°ã‚¤ãƒ³
    const loginResponse2 = await request(app.getHttpServer())
      .post('/auth/login')
      .send({
        email: 'superadmin2@test.com',
        password: 'SuperSecure123!',
      });

    superAdminToken = loginResponse2.body.data.access_token;
  });

  afterAll(async () => {
    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    await prisma.invitationToken.deleteMany({});
    await prisma.user.deleteMany({
      where: {
        email: {
          in: [
            'superadmin@test.com',
            'superadmin2@test.com',
            'tenantadmin@test.com',
            'newuser@test.com',
          ],
        },
      },
    });
    await prisma.tenant.deleteMany({
      where: {
        slug: {
          in: ['test-tenant', 'test-tenant-2'],
        },
      },
    });

    await app.close();
  });

  describe('POST /tenants/invite-admin', () => {
    it('SUPER_ADMIN ãŒãƒ†ãƒŠãƒ³ãƒˆç®¡ç†è€…ã‚’æ‹›å¾…ã§ãã‚‹', async () => {
      const response = await request(app.getHttpServer())
        .post('/tenants/invite-admin')
        .set('Authorization', `Bearer ${superAdminToken}`)
        .send({
          email: 'tenantadmin@test.com',
          tenantName: 'Test Tenant',
          tenantSlug: 'test-tenant',
        })
        .expect(201);

      expect(response.body.success).toBe(true);
      expect(response.body.tenantId).toBeDefined();
      expect(response.body.invitationToken).toBeDefined();

      createdTenantId = response.body.tenantId;
      invitationToken = response.body.invitationToken;
    });

    it('èªè¨¼ãªã—ã§ã¯ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã„', async () => {
      await request(app.getHttpServer())
        .post('/tenants/invite-admin')
        .send({
          email: 'test@test.com',
          tenantName: 'Test',
        })
        .expect(401);
    });
  });

  describe('POST /tenants/complete-invitation', () => {
    it('æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²ã‚’å®Œäº†ã§ãã‚‹', async () => {
      const response = await request(app.getHttpServer())
        .post('/tenants/complete-invitation')
        .send({
          token: invitationToken,
          password: 'SecurePassword123!',
          firstName: 'Tenant',
          lastName: 'Admin',
        })
        .expect(201);

      expect(response.body.success).toBe(true);
      expect(response.body.userId).toBeDefined();
      expect(response.body.tenantId).toBe(createdTenantId);

      // ä½œæˆã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ç¢ºèª
      const user = await prisma.user.findUnique({
        where: { email: 'tenantadmin@test.com' },
      });

      expect(user).toBeDefined();
      expect(user!.role).toBe(UserRole.TENANT_ADMIN);
      expect(user!.tenantId).toBe(createdTenantId);
    });

    it('ç„¡åŠ¹ãªãƒˆãƒ¼ã‚¯ãƒ³ã§ã¯ã‚¨ãƒ©ãƒ¼', async () => {
      await request(app.getHttpServer())
        .post('/tenants/complete-invitation')
        .send({
          token: 'invalid-token',
          password: 'SecurePassword123!',
        })
        .expect(400);
    });

    it('æ—¢ã«ä½¿ç”¨æ¸ˆã¿ã®ãƒˆãƒ¼ã‚¯ãƒ³ã§ã¯ã‚¨ãƒ©ãƒ¼', async () => {
      await request(app.getHttpServer())
        .post('/tenants/complete-invitation')
        .send({
          token: invitationToken,
          password: 'SecurePassword123!',
        })
        .expect(400);
    });
  });

  describe('POST /tenants/:tenantId/users/invite', () => {
    beforeAll(async () => {
      // TENANT_ADMIN ã§ãƒ­ã‚°ã‚¤ãƒ³
      const loginResponse = await request(app.getHttpServer())
        .post('/auth/login')
        .send({
          email: 'tenantadmin@test.com',
          password: 'SecurePassword123!',
        });

      tenantAdminToken = loginResponse.body.data.access_token;
    });

    it('TENANT_ADMIN ãŒè‡ªåˆ†ã®ãƒ†ãƒŠãƒ³ãƒˆã«ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’æ‹›å¾…ã§ãã‚‹', async () => {
      const response = await request(app.getHttpServer())
        .post(`/tenants/${createdTenantId}/users/invite`)
        .set('Authorization', `Bearer ${tenantAdminToken}`)
        .send({
          email: 'newuser@test.com',
          role: UserRole.USER,
        })
        .expect(201);

      expect(response.body.success).toBe(true);
      expect(response.body.invitationToken).toBeDefined();
    });

    it('ä»–ã®ãƒ†ãƒŠãƒ³ãƒˆã«ã¯æ‹›å¾…ã§ããªã„', async () => {
      // åˆ¥ã®ãƒ†ãƒŠãƒ³ãƒˆã‚’ä½œæˆ
      const anotherTenant = await prisma.tenant.create({
        data: {
          name: 'Another Tenant',
          slug: 'test-tenant-2',
        },
      });

      await request(app.getHttpServer())
        .post(`/tenants/${anotherTenant.id}/users/invite`)
        .set('Authorization', `Bearer ${tenantAdminToken}`)
        .send({
          email: 'user@test.com',
          role: UserRole.USER,
        })
        .expect(403);
    });
  });
});
`````

## File: backend/test/users-promote-superadmin.e2e-spec.ts
`````typescript
import { INestApplication, ValidationPipe } from '@nestjs/common';
import { Test, TestingModule } from '@nestjs/testing';
import request from 'supertest';
import { UserRole } from '@prisma/client';

import { AppModule } from '../src/app.module';
import { PrismaService } from '../src/prisma/prisma.service';

describe('Users promote-to-superadmin-once (e2e)', () => {
  let app: INestApplication;
  let prisma: PrismaService;

  // ãƒ†ã‚¹ãƒˆç”¨ã®ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ç”Ÿæˆ
  const testEmailPrefix = `promote_test_${Date.now()}`;
  const testEmail1 = `${testEmailPrefix}_1@example.com`;
  const testEmail2 = `${testEmailPrefix}_2@example.com`;
  const testPassword = 'SecurePass123!';

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    app.useGlobalPipes(
      new ValidationPipe({
        whitelist: true,
        forbidNonWhitelisted: true,
        transform: true,
      }),
    );

    await app.init();
    prisma = app.get<PrismaService>(PrismaService);

    // ãƒ†ã‚¹ãƒˆå‰ã«ãƒ†ã‚¹ãƒˆç”¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    await prisma.user.deleteMany({
      where: {
        email: {
          in: [testEmail1, testEmail2],
        },
      },
    });

    // ãƒ†ã‚¹ãƒˆå‰ã«æ—¢å­˜ã® SUPER_ADMIN ã‚’ä¸€æ™‚çš„ã« USER ã«é™æ ¼
    // æ³¨æ„: ã“ã®ãƒ†ã‚¹ãƒˆã¯å˜ç‹¬ã§å®Ÿè¡Œã™ã‚‹ã‹ã€ä»–ã®ãƒ†ã‚¹ãƒˆã¨å¹²æ¸‰ã—ãªã„ã‚ˆã†ã«æ³¨æ„ãŒå¿…è¦
    await prisma.user.updateMany({
      where: { role: UserRole.SUPER_ADMIN },
      data: { role: UserRole.USER },
    });
  });

  afterAll(async () => {
    if (prisma) {
      // ãƒ†ã‚¹ãƒˆãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
      await prisma.user.deleteMany({
        where: {
          email: {
            in: [testEmail1, testEmail2],
          },
        },
      });
    }

    if (app) {
      await app.close();
    }
  });

  describe('POST /users/promote-to-superadmin-once', () => {
    it('æœªèªè¨¼ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã„ï¼ˆ401ï¼‰', async () => {
      await request(app.getHttpServer())
        .post('/users/promote-to-superadmin-once')
        .expect(401);
    });

    it('SUPER_ADMIN ãŒå­˜åœ¨ã—ãªã„å ´åˆã€èªè¨¼æ¸ˆã¿ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯æ˜‡æ ¼ã§ãã‚‹', async () => {
      // ãƒ¦ãƒ¼ã‚¶ãƒ¼1ã‚’ç™»éŒ²
      await request(app.getHttpServer())
        .post('/auth/register')
        .send({
          email: testEmail1,
          password: testPassword,
        })
        .expect((res) => {
          if (![200, 201].includes(res.status)) {
            throw new Error(`Registration failed: ${res.status}`);
          }
        });

      // ãƒ¦ãƒ¼ã‚¶ãƒ¼1ã§ãƒ­ã‚°ã‚¤ãƒ³
      const loginResponse = await request(app.getHttpServer())
        .post('/auth/login')
        .send({
          email: testEmail1,
          password: testPassword,
        });

      const accessToken = loginResponse.body.data?.access_token;
      if (!accessToken) {
        throw new Error('Failed to get access token');
      }

      // æ˜‡æ ¼ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
      const promoteResponse = await request(app.getHttpServer())
        .post('/users/promote-to-superadmin-once')
        .set('Authorization', `Bearer ${accessToken}`)
        .expect(201);

      expect(promoteResponse.body.success).toBe(true);
      expect(promoteResponse.body.data.role).toBe(UserRole.SUPER_ADMIN);
      expect(promoteResponse.body.data.email).toBe(testEmail1);

      // DB ã§ãƒ­ãƒ¼ãƒ«ãŒæ›´æ–°ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
      const updatedUser = await prisma.user.findUnique({
        where: { email: testEmail1 },
      });
      expect(updatedUser?.role).toBe(UserRole.SUPER_ADMIN);
    });

    it('SUPER_ADMIN ãŒæ—¢ã«å­˜åœ¨ã™ã‚‹å ´åˆã€åˆ¥ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯æ˜‡æ ¼ã§ããªã„ï¼ˆ403ï¼‰', async () => {
      // ãƒ¦ãƒ¼ã‚¶ãƒ¼2ã‚’ç™»éŒ²
      await request(app.getHttpServer())
        .post('/auth/register')
        .send({
          email: testEmail2,
          password: testPassword,
        })
        .expect((res) => {
          if (![200, 201].includes(res.status)) {
            throw new Error(`Registration failed: ${res.status}`);
          }
        });

      // ãƒ¦ãƒ¼ã‚¶ãƒ¼2ã§ãƒ­ã‚°ã‚¤ãƒ³
      const loginResponse = await request(app.getHttpServer())
        .post('/auth/login')
        .send({
          email: testEmail2,
          password: testPassword,
        });

      const accessToken = loginResponse.body.data?.access_token;
      if (!accessToken) {
        throw new Error('Failed to get access token');
      }

      // æ˜‡æ ¼ãƒªã‚¯ã‚¨ã‚¹ãƒˆï¼ˆã™ã§ã« SUPER_ADMIN ãŒå­˜åœ¨ã™ã‚‹ã®ã§ 403ï¼‰
      const promoteResponse = await request(app.getHttpServer())
        .post('/users/promote-to-superadmin-once')
        .set('Authorization', `Bearer ${accessToken}`)
        .expect(403);

      expect(promoteResponse.body.message).toContain('SUPER_ADMIN');
    });

    it('æ˜‡æ ¼æ¸ˆã¿ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯å†åº¦æ˜‡æ ¼ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ã‚‹ã¨ 403 ã‚’å—ã‘ã‚‹', async () => {
      // ãƒ¦ãƒ¼ã‚¶ãƒ¼1ï¼ˆã™ã§ã« SUPER_ADMINï¼‰ã§ãƒ­ã‚°ã‚¤ãƒ³
      const loginResponse = await request(app.getHttpServer())
        .post('/auth/login')
        .send({
          email: testEmail1,
          password: testPassword,
        });

      const accessToken = loginResponse.body.data?.access_token;
      if (!accessToken) {
        throw new Error('Failed to get access token');
      }

      // å†åº¦æ˜‡æ ¼ãƒªã‚¯ã‚¨ã‚¹ãƒˆï¼ˆã™ã§ã« SUPER_ADMIN ãŒå­˜åœ¨ã™ã‚‹ã®ã§ 403ï¼‰
      await request(app.getHttpServer())
        .post('/users/promote-to-superadmin-once')
        .set('Authorization', `Bearer ${accessToken}`)
        .expect(403);
    });

    it('æ˜‡æ ¼å¾Œã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ SUPER_ADMIN å°‚ç”¨ API ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹', async () => {
      // ãƒ¦ãƒ¼ã‚¶ãƒ¼1ï¼ˆSUPER_ADMINï¼‰ã§ãƒ­ã‚°ã‚¤ãƒ³
      const loginResponse = await request(app.getHttpServer())
        .post('/auth/login')
        .send({
          email: testEmail1,
          password: testPassword,
        });

      const accessToken = loginResponse.body.data?.access_token;
      if (!accessToken) {
        throw new Error('Failed to get access token');
      }

      // SUPER_ADMIN å°‚ç”¨ã®ãƒ†ãƒŠãƒ³ãƒˆä¸€è¦§ API ã«ã‚¢ã‚¯ã‚»ã‚¹
      const tenantsResponse = await request(app.getHttpServer())
        .get('/tenants')
        .set('Authorization', `Bearer ${accessToken}`)
        .expect(200);

      expect(tenantsResponse.body.success).toBe(true);
    });
  });
});
`````

## File: backend/.env.example
`````
###############################################
# MyCats Pro Backend - ç’°å¢ƒå¤‰æ•°ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ (æœ€å°æ§‹æˆ)
# 1. ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ .env ã‚’ä½œæˆã—ã¦ãã ã•ã„
# 2. ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã¯ `pnpm run generate-secrets` ã§ç”Ÿæˆã—ã¦ãã ã•ã„
# 3. Git ã«ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã‚’ã‚³ãƒŸãƒƒãƒˆã—ãªã„ã§ãã ã•ã„
###############################################

# ===== åŸºæœ¬è¨­å®š (å¿…é ˆ) =====
NODE_ENV=development
PORT=3004

# PostgreSQL æ¥ç¶šURL
# ä¾‹: postgresql://USER:PASSWORD@HOST:PORT/DATABASE?schema=public
DATABASE_URL=""

# ===== ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆ (å¿…é ˆ) =====
# ç”Ÿæˆã‚³ãƒãƒ³ãƒ‰: pnpm run generate-secrets
JWT_SECRET=""
JWT_REFRESH_SECRET=""
CSRF_TOKEN_SECRET=""

# ===== ãƒˆãƒ¼ã‚¯ãƒ³æœ‰åŠ¹æœŸé™ï¼ˆå¿…è¦ã«å¿œã˜ã¦å¤‰æ›´ï¼‰ =====
JWT_EXPIRES_IN=15m
JWT_REFRESH_EXPIRES_IN=7d

# ===== ã‚ªãƒ—ã‚·ãƒ§ãƒ³è¨­å®š (å¿…è¦æ™‚ã®ã¿ã‚¢ãƒ³ã‚³ãƒ¡ãƒ³ãƒˆ) =====
# CORS_ORIGIN=
# LOG_LEVEL=info
# PASSWORD_MIN_LENGTH=8
# CSRF_TOKEN_TTL_SECONDS=600
# ARGON2_MEMORY_COST=65536
# ARGON2_TIME_COST=3
# ARGON2_PARALLELISM=4
# THROTTLE_TTL=60000
# THROTTLE_LIMIT=100
# AUTH_DISABLED=0
# ADMIN_EMAIL=
# ADMIN_PASSWORD=
# ADMIN_FORCE_UPDATE=0
# HEALTH_CHECK_DATABASE=true
# HEALTH_CHECK_MEMORY_THRESHOLD=0.9
# SENTRY_DSN=
# SENTRY_TRACES_SAMPLE_RATE=0.1
# SENTRY_PROFILES_SAMPLE_RATE=0.1

# ===== Google Cloud Storage (ã‚®ãƒ£ãƒ©ãƒªãƒ¼æ©Ÿèƒ½) =====
# GCS_BUCKET_NAME=mycats-pro-gallery
# GCS_PROJECT_ID=my-cats-pro
# æœ¬ç•ªç’°å¢ƒã§ã¯ GOOGLE_APPLICATION_CREDENTIALS ãŒè‡ªå‹•è¨­å®šã•ã‚Œã‚‹ï¼ˆCloud Runï¼‰
`````

## File: backend/AGENTS.md
`````markdown
# backend/AGENTS ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³

## 0. ç›®çš„ã¨é©ç”¨ç¯„å›²

- æœ¬æ›¸ã¯ `backend/` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§å‹•ä½œã™ã‚‹ NestJS 10 + Prisma 6 + PostgreSQL 15 å‘ã‘ã®å°‚ç”¨é‹ç”¨ã‚¬ã‚¤ãƒ‰ã§ã™ã€‚
- ãƒ«ãƒ¼ãƒˆ `AGENTS.md` ã®å…±é€šè¦ç´„ã« **è¿½åŠ è¦ä»¶** ã‚’ä¸ãˆã‚‹ã‚‚ã®ã§ã™ã€‚ç«¶åˆã—ãŸå ´åˆã¯æœ¬æ›¸ã®è¨˜è¿°ã‚’å„ªå…ˆã—ã¤ã¤ã€å·®åˆ†ç†ç”±ã‚’ PR ã§æ˜ç¤ºã—ã¦ãã ã•ã„ã€‚
- å¯¾è±¡èª­è€…: API / ãƒãƒƒãƒ / Prisma ã‚¹ã‚­ãƒ¼ãƒã‚’æ”¹ä¿®ã™ã‚‹ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã€‚

---

## 1. ã‚¯ã‚¤ãƒƒã‚¯ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹

### 1-1. ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— & å®Ÿè¡Œ

- ä¾å­˜åŒæœŸ: ãƒ«ãƒ¼ãƒˆã§ `pnpm install` â†’ `pnpm setup`ã€‚å€‹åˆ¥å®Ÿè¡Œã¯ `pnpm --filter backend install` ã‚’è¨±å¯ã€‚
- é–‹ç™ºã‚µãƒ¼ãƒãƒ¼: `pnpm dev`ï¼ˆãƒ«ãƒ¼ãƒˆï¼‰ã§ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ â†’ ãƒ•ãƒ­ãƒ³ãƒˆã®é †ã«èµ·å‹•ã€‚å˜ä½“ã§å‹•ã‹ã™å ´åˆã¯ `pnpm --filter backend run start:dev`ã€‚
- æœ¬ç•ªãƒ“ãƒ«ãƒ‰: `pnpm --filter backend run build` ã§ `dist/` ã‚’å†ç”Ÿæˆã€‚`start:prod` ã¯ `dist/main` ã‚’ Node.js ã§ç›´æ¥èµ·å‹•ã€‚
- Prisma åŒæœŸ: `pnpm --filter backend run prisma:generate` ã‚’ **ã‚¹ã‚­ãƒ¼ãƒæ›´æ–°ã”ã¨ã«å¿…ãš** å®Ÿè¡Œã€‚

### 1-2. å“è³ªã‚²ãƒ¼ãƒˆï¼ˆBackend ã‚¹ã‚³ãƒ¼ãƒ—ï¼‰

| ãƒ•ã‚§ãƒ¼ã‚º | ã‚³ãƒãƒ³ãƒ‰ | å‚™è€ƒ |
| --- | --- | --- |
| Lint | `pnpm --filter backend run lint` | eslint + prettierã€è‡ªå‹•ä¿®æ­£ã‚ã‚Š |
| å‹ãƒã‚§ãƒƒã‚¯ | `pnpm --filter backend run type-check` | `tsconfig.json` ã«å¯¾ã™ã‚‹ `tsc --noEmit` |
| Unit | `pnpm --filter backend run test` | Jestã€‚mock ã¯ `@nestjs/testing` ã‚’åˆ©ç”¨ |
| E2E | `pnpm --filter backend run test:e2e` | å®Ÿè¡Œå‰ã« `.env.test` ã‚’èª­ã¿è¾¼ã¿ã€`prisma migrate reset --force` ã‚’è‡ªå‹•å®Ÿè¡Œ |
| Build | `pnpm --filter backend run build` | `scripts/ensure-dev-build.mjs` ãŒ `node_modules/.prisma` å…¥ã‚Šã‚’ä¿è­· |

### 1-3. DB ã‚ªãƒšãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

- ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ä½œæˆ: `pnpm --filter backend run prisma:migrate`ï¼ˆ= `prisma migrate dev`ï¼‰ã€‚é–‹ç™ºä¸­ã®ã¿ä½¿ç”¨ã€‚
- æœ¬ç•ªé©ç”¨: `pnpm --filter backend run prisma:deploy`ã€‚CI/CD ã§ã‚‚åŒä¸€ã‚³ãƒãƒ³ãƒ‰ã‚’ä½¿ç”¨ã—ã€ãƒ€ã‚¦ãƒ³ã‚¿ã‚¤ãƒ ã‚’é¿ã‘ã‚‹ã€‚
- ã‚¹ã‚­ãƒ¼ãƒå·®ç•°ç¢ºèª: `pnpm --filter backend run prisma:status`ã€‚
- ã‚·ãƒ¼ãƒ‰: `pnpm --filter backend run seed`ã€‚PostgreSQL 15+ å‰æã§ç®¡ç†è€…ãƒ­ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã€‚

---

## 2. ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£åŸå‰‡ï¼ˆNestJS ãƒ¬ã‚¤ãƒ¤ãƒªãƒ³ã‚°ï¼‰

1. **Controller â†’ Service â†’ Repository/PrismaService** ã®å¢ƒç•Œã‚’å³å®ˆã—ã€Controller ã‹ã‚‰ Prisma ã‚’ç›´æ¥å‘¼ã³å‡ºã•ãªã„ã€‚
2. DTO / Entity / Presenter ã¯ `src/modules/<domain>/dto` ç­‰ã§æ•´ç†ã—ã€`class-validator` + `class-transformer` ã‚’çµ„ã¿åˆã‚ã›ã¦ I/O ã‚’å‹å®‰å…¨åŒ–ã€‚
3. DI ã‚³ãƒ³ãƒ†ãƒŠ: `@Injectable()` ã‚’ä»˜ä¸ã—ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¨ã™ã‚‹ã€‚å¾ªç’°ä¾å­˜ãŒã‚ã‚‹å ´åˆã®ã¿ `forwardRef()`ã€‚
4. ã‚¨ãƒ©ãƒ¼å‡¦ç†: `HttpException` ç³»ï¼ˆ`BadRequestException`, `ForbiddenException`, ...ï¼‰ã§çµ±ä¸€ã—ã€æ—¥æœ¬èªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿”å´ã€‚
5. Config: `@nestjs/config` ã®ã‚¹ã‚­ãƒ¼ãƒã« `zod` ã‚’çµ„ã¿åˆã‚ã›ã€å¿…é ˆç’°å¢ƒå¤‰æ•°ï¼ˆ`DATABASE_URL`, `JWT_SECRET`, `REDIS_URL` ç­‰ï¼‰ã‚’äº‹å‰æ¤œè¨¼ã€‚
6. ãƒ­ã‚®ãƒ³ã‚°: `nestjs-pino` ã‚’å…±é€š Logger ã¨ã—ã€PII ã‚’é™¤å»ã—ãŸæ§‹é€ åŒ–ãƒ­ã‚°ã‚’å‡ºåŠ›ã€‚
7. ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«/Bulk: `@nestjs/schedule` ã‚’ä½¿ç”¨ã™ã‚‹å‡¦ç†ã¯å°‚ç”¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’åˆ‡ã‚Šå‡ºã—ã€`CronExpression` ã‚’ `enum` åŒ–ã—ã¦é‡è¤‡ã‚’é˜²ãã€‚

> å‚è€ƒ: [NestJS Prisma ãƒ¬ã‚·ãƒ”](https://docs.nestjs.com/recipes/prisma) ã¯ PrismaService ã‚’ `PrismaClient` ã‹ã‚‰æ‹¡å¼µã—ã€`tsconfig.build.json` ã«ç”Ÿæˆç‰©ã‚’å«ã‚ã‚‹ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã‚’æ˜ç¤ºã€‚

---

## 3. API è¨­è¨ˆ & ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³

- DTO å‘½å: `CreateCatDto`, `UpdateShiftDto` ã®ã‚ˆã†ã«å‹•è© + å¯¾è±¡ + `Dto`ã€‚
- ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
   - æ–‡å­—åˆ—: `@IsString()` + `@IsNotEmpty()` ã‚’åŸºæœ¬ã«ã€ID ã¯ `@IsUUID()`ã€‚
   - æ—¥æ™‚è¨ˆç®—ã¯ `Zod` ã§ã‚µãƒ¼ãƒãƒ¼å´å†æ¤œè¨¼ã—ã€DTO ã§ã¯ ISO8601 æ–‡å­—åˆ—ã‚’å—ã‘å–ã‚‹ã€‚
- ãƒ¬ã‚¹ãƒãƒ³ã‚¹: `ClassSerializerInterceptor` ã§éš ã™ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼ˆ`passwordHash` ç­‰ï¼‰ã‚’ `@Exclude()`ã€‚
- èªè¨¼: `@nestjs/passport` + JWTï¼ˆ`@nestjs/jwt`ï¼‰ã§ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç™ºè¡Œã€‚CSRF ä¿è­·ãŒå¿…è¦ãªãƒ•ã‚©ãƒ¼ãƒ ã¯ `csurf` ã‚’ `cookie-parser` ã¨ä½µç”¨ã€‚
- ãƒ¬ãƒ¼ãƒˆåˆ¶å¾¡: å…¬é–‹ API ã¯ `@nestjs/throttler` ã§ `/auth/*` ã«å€‹åˆ¥è¨­å®šã€‚
- Swagger: `pnpm --filter backend run swagger:gen` ã§ `openapi.json` ã‚’å†ç”Ÿæˆã—ã€ãƒ•ãƒ­ãƒ³ãƒˆã¨åŒæœŸã€‚

---

## 4. Prisma / ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹æŒ‡é‡

1. **å‹ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆ**: ã‚¹ã‚­ãƒ¼ãƒæ›´æ–° â†’ `prisma generate` â†’ DTO/Service å®Ÿè£… â†’ ãƒ†ã‚¹ãƒˆã®é †åºã§ä½œæ¥­ã€‚
2. Query æœ€é©åŒ–:
   - å¿…è¦ãªãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ã¿ `select` / `include` ã§å–å¾—ã—ã€N+1 ã‚’é˜²æ­¢ã€‚
   - è¤‡é›‘ãªãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¯ `Prisma.transaction` ã‚„ `Prisma.$transaction` ã‚’åˆ©ç”¨ã€‚
3. ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³:
   - é–‹ç™º: `prisma migrate dev` ã§ `migration.sql` ã‚’è‡ªå‹•ç”Ÿæˆã€‚
   - æœ¬ç•ª: `prisma migrate deploy` ã§æ‰‹å‹•å…¥åŠ›ãªã—ã«é©ç”¨ï¼ˆ[NestJS Prisma Starter README](https://github.com/notiz-dev/nestjs-prisma-starter/blob/master/README.md) å‚ç…§ï¼‰ã€‚
4. ç”Ÿæˆç‰©ã®æ‰±ã„:
   - `node_modules/.prisma` ã‚’ Git ç„¡è¦–ã—ã€`dist/` ã¸å«ã‚ã‚‹ãŸã‚ `tsconfig.build.json` ã® include ãƒ‘ã‚¹ã« `prisma/generated` ã‚’è¿½åŠ æ¸ˆã¿ã‹ç¢ºèªã€‚
5. Connection Pool / ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥:
   - é«˜ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯ç’°å¢ƒã§ã¯ Prisma Accelerate (connection pooling + global cache) ã‚’æ¡ç”¨ã—ã€`prisma-examples/accelerate/*` ã®æ§‹æˆã‚’å‚è€ƒã« `DATABASE_URL` ã‚’ `prisma://` ã«åˆ‡ã‚Šæ›¿ãˆã€‚
6. ç›£è¦–: `prisma:status` ã‚’ CI ã§å®Ÿè¡Œã—ã€ã‚¹ã‚­ãƒ¼ãƒãƒ‰ãƒªãƒ•ãƒˆæ¤œçŸ¥ã‚’ç¾©å‹™åŒ–ã€‚

> å‚è€ƒ: [NestJS Prisma Starter](https://github.com/notiz-dev/nestjs-prisma-starter/blob/master/README.md) ã¯ devâ†’prod ã§ `migrate dev` ã¨ `migrate deploy` ã‚’ä½¿ã„åˆ†ã‘ã‚‹æ‰‹é †ã‚„ `prisma generate --watch` ã‚’æ¨å¥¨ã€‚
>
> å‚è€ƒ: [Prisma Examples README](https://raw.githubusercontent.com/prisma/prisma-examples/latest/README.md) ã® Accelerate/Optimize ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§æ¥ç¶šãƒ—ãƒ¼ãƒ«ã¨ã‚¯ã‚¨ãƒªæœ€é©åŒ–ã®æ¨å¥¨æ§‹æˆãŒå…¬é–‹ã€‚

---

## 5. PostgreSQL é‹ç”¨ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

- ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°åˆæœŸå€¤ï¼ˆPostgreSQL 18 doc ã‚ˆã‚Šï¼‰
   - `shared_buffers`: å°‚ç”¨ã‚µãƒ¼ãƒãƒ¼ã§ã¯ RAM ã® 25% ç¨‹åº¦ã‚’ç›®å®‰ã«è¨­å®šã€‚40% ã‚’è¶…ãˆãªã„ã€‚
   - `work_mem`: è¤‡é›‘ãªãƒãƒƒã‚·ãƒ¥/ã‚½ãƒ¼ãƒˆãŒå¤šã„å ´åˆã¯ 4MB â†’ 16MB ã¸æ®µéšçš„ã«å¢—ã‚„ã—ã€`hash_mem_multiplier` ã¨ä½µã›ã¦ç›£è¦–ã€‚
   - `maintenance_work_mem`: VACUUM/ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½œæˆæ™‚ã®ãƒãƒƒãƒ•ã‚¡ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ 64MB ã‹ã‚‰æ¥­å‹™ã«å¿œã˜ã¦æ‹¡å¼µã€‚
   - `autovacuum_work_mem`: `maintenance_work_mem` ã¨ç‹¬ç«‹åˆ¶å¾¡ã—ã€ãƒ¯ãƒ¼ã‚«ãƒ¼æ•° Ã— ãƒ¡ãƒ¢ãƒªãŒç‰©ç† RAM ã‚’è¶…ãˆãªã„ã‚ˆã†ã«ã™ã‚‹ã€‚
- I/O
   - `bgwriter_*` ã¨ `effective_io_concurrency` ã‚’èª¿æ•´ã—ã€ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆæ™‚ã®ã‚¹ãƒ‘ã‚¤ã‚¯ã‚’æŠ‘åˆ¶ã€‚
   - `temp_file_limit` ã‚’è¨­å®šã—ã€èª¤ã£ãŸã‚¯ã‚¨ãƒªã®ç„¡åˆ¶é™ä¸€æ™‚é ˜åŸŸç¢ºä¿ã‚’é˜»æ­¢ã€‚
- ç›£æŸ»: `pg_stat_statements` ã‚’ã‚ªãƒ³ã«ã—ã€`prisma optimize` æ¨å¥¨äº‹é …ï¼ˆå…¨ä»¶èµ°æŸ», éã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹åˆ—ãƒ•ã‚£ãƒ«ã‚¿ãªã©ï¼‰ã‚’å®šæœŸãƒ¬ãƒ“ãƒ¥ãƒ¼ã€‚

> å‚è€ƒ: [PostgreSQL 19.4 Resource Consumption](https://www.postgresql.org/docs/current/runtime-config-resource.html) ã¯ãƒ¡ãƒ¢ãƒªãƒ»I/O ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ¨å¥¨å¸¯åŸŸã‚’æç¤ºã€‚

---

## 6. ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ / å¯è¦³æ¸¬æ€§

- `/health/live` `/health/ready` ã‚’ `@nestjs/terminus` ã§å®Ÿè£…ã—ã€HTTP + Prisma + Redis + ãƒ‡ã‚£ã‚¹ã‚¯ã®ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ã‚’ç™»éŒ²ã€‚
- Terminus ã® `gracefulShutdownTimeoutMs` ã§ãƒ­ãƒ¼ãƒªãƒ³ã‚°ãƒ‡ãƒ—ãƒ­ã‚¤ã«ãŠã‘ã‚‹ã‚¼ãƒ­ãƒ€ã‚¦ãƒ³ã‚¿ã‚¤ãƒ ã‚’ç¢ºä¿ã€‚
- `nestjs-pino` ã¨ Sentry (`@sentry/node`) ã‚’çµ±åˆã—ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆ ID ã‚’ `AsyncLocalStorage` ã§ä¼æ’­ã€‚

> å‚è€ƒ: [NestJS Terminus ã‚¬ã‚¤ãƒ‰](https://docs.nestjs.com/recipes/terminus) ã¯ãƒ˜ãƒ«ã‚¹ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ã¨ graceful shutdown ã®è¨­å®šä¾‹ã‚’æç¤ºã€‚

---

## 7. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ & ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹

- HTTP ãƒ˜ãƒƒãƒ€ãƒ¼: `helmet` ã‚’å…¨ãƒ«ãƒ¼ãƒˆã«é©ç”¨ã—ã€`crossOriginResourcePolicy` ã‚’ `same-site`ã€‚
- èªè¨¼æƒ…å ±: `argon2` ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒãƒƒã‚·ãƒ¥ã«ä½¿ç”¨ã€‚`bcryptjs` ã¯äº’æ›ç”¨ãƒ¬ã‚¬ã‚·ãƒ¼ã®ã¿ã€‚
- CSRF: Cookie ãƒ™ãƒ¼ã‚¹èªè¨¼ãƒ‘ã‚¹ã¯ `csurf` ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ hidden input ã§å¾€å¾©ã€‚
- Secrets ç®¡ç†: ãƒ«ãƒ¼ãƒˆã® `pnpm run generate-secrets` ã§ç’°å¢ƒä¾å­˜ã®ã‚­ãƒ¼ã‚’ç”Ÿæˆã—ã€`.env` ã¨ã®å·®åˆ†ã‚’ `git update-index --assume-unchanged` ã§ä¿è­·ã€‚
- å…¥åŠ›ãƒ•ã‚¡ã‚¤ãƒ«: `multer` ã‚’ä½¿ã†å ´åˆã€ãƒ•ã‚¡ã‚¤ãƒ«ç¨®åˆ¥ãƒ›ãƒ¯ã‚¤ãƒˆãƒªã‚¹ãƒˆ + ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚µã‚¤ã‚ºåˆ¶é™ã‚’å¿…é ˆã€‚

---

## 8. ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

- Unit: Service / Guard / Pipe ã”ã¨ã« `*.spec.ts` ä½œæˆã€‚Prisma ä¾å­˜éƒ¨ã¯ `@nestjs/testing` + `PrismaService` ã®ãƒ¢ãƒƒã‚¯ï¼ˆ`jest.mock`ï¼‰ã§ä»£æ›¿ã€‚
- Integration/E2E: `test/*.e2e-spec.ts` ã‚’ `test:e2e` ã§ç›´åˆ—å®Ÿè¡Œã€‚å„ã‚±ãƒ¼ã‚¹å†’é ­ã§ `await prisma.$transaction([prisma.model.deleteMany(), ...])` ã—ã¦ãƒ‡ãƒ¼ã‚¿æ±šæŸ“ã‚’é˜²ãã€‚
- ã‚³ãƒ¼ãƒ‰ã‚«ãƒãƒ¬ãƒƒã‚¸: global 70% ä»¥ä¸Šã€‚é‡è¦ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã¯ 90% è¶…ã‚’ç›®æ¨™ã€‚

---

## 9. é–‹ç™ºãƒ•ãƒ­ãƒ¼ ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

1. å¤‰æ›´ç¯„å›²ã® `CODE_GUIDE.md` ãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèªï¼ˆç¾çŠ¶ backend é…ä¸‹ã¯æœªå®šç¾©ï¼‰ã€‚
2. ä½œæ¥­å‰ã« `pnpm lint` + `pnpm backend:build` ã®æœ€æ–°çµæœã‚’æŠŠæ¡ã€‚
3. **å‹ â†’ å®Ÿè£… â†’ ãƒ†ã‚¹ãƒˆ â†’ Prisma migrate â†’ ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ** ã®é †ã§æ›´æ–°ã€‚
4. å¤‰æ›´å¾Œã¯æœ€ä½ã§ã‚‚ `pnpm lint`, `pnpm backend:build`, `pnpm --filter backend run test` ã‚’ PASS ã•ã›ã‚‹ã€‚
5. Prisma å¤‰æ›´æ™‚ã¯ `pnpm db:migrate` + `pnpm db:seed` ã§å·®åˆ†ã‚’å†ç¾ã€‚
6. PR ã«ã¯:
   - å¤‰æ›´ç†ç”±ã¨å½±éŸ¿ç¯„å›²
   - æ–°è¦/æ›´æ–°ã‚³ãƒãƒ³ãƒ‰ã®å®Ÿè¡Œãƒ­ã‚°
   - æ—¢çŸ¥ã®æœªå¯¾å¿œäº‹é …ï¼ˆä¾‹: è¿½åŠ ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ¡ˆï¼‰
   ã‚’æ—¥æœ¬èªã§æ·»ä»˜ã€‚

---

## 10. å‚è€ƒãƒªãƒ³ã‚¯

- NestJS å…¬å¼: [Prisma ãƒ¬ã‚·ãƒ”](https://docs.nestjs.com/recipes/prisma), [Terminus / Health Checks](https://docs.nestjs.com/recipes/terminus)
- Prisma: [NestJS Prisma Starter README](https://github.com/notiz-dev/nestjs-prisma-starter/blob/master/README.md), [Prisma Examples README](https://raw.githubusercontent.com/prisma/prisma-examples/latest/README.md)
- PostgreSQL: [Resource Consumption (19.4)](https://www.postgresql.org/docs/current/runtime-config-resource.html)

ä»¥ä¸Šã®æ–¹é‡ã‹ã‚‰é€¸è„±ã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã¯ã€æ ¹æ‹ ã¨ãƒªã‚¹ã‚¯ç·©å’Œç­–ã‚’ PR èª¬æ˜ã¾ãŸã¯ `docs/` é…ä¸‹ã®è¨­è¨ˆè³‡æ–™ã«æ®‹ã—ã¦ãã ã•ã„ã€‚
`````

## File: backend/docker-entrypoint.sh
`````bash
#!/bin/sh
set -e

if [ -n "$INSTANCE_CONNECTION_NAME" ] && ! echo "$DATABASE_URL" | grep -q "cloudsql"; then
	echo "Configuring Cloud SQL socket connection..."
	NEW_DATABASE_URL="$(node <<'EOF'
const urlInput = process.env.DATABASE_URL;
const instance = process.env.INSTANCE_CONNECTION_NAME;
if (!urlInput || !instance) {
	console.log(urlInput ?? '');
	process.exit(0);
}

try {
	const url = new URL(urlInput);
	url.hostname = 'localhost';
	if (!url.port) {
		url.port = '5432';
	}

	const params = url.searchParams;
		for (const key of Array.from(params.keys())) {
			if (key.toLowerCase() === 'host') {
				params.delete(key);
			}
			if (key.toLowerCase() === 'sslmode') {
				params.delete(key);
			}
		}

		params.set('host', `/cloudsql/${instance}`);
		params.set('sslmode', 'disable');

		console.log(url.toString());
} catch (err) {
	console.error('Failed to rewrite DATABASE_URL for Cloud SQL connection:', err);
	process.exit(1);
}
EOF
		)"
		export DATABASE_URL="$NEW_DATABASE_URL"
			if [ -z "$PGSSLMODE" ]; then
				export PGSSLMODE=disable
			fi
fi

echo "Running database migrations..."
npx prisma migrate deploy --schema=./prisma/schema.prisma

echo "Seeding database..."
node dist/prisma/seed.js

echo "Starting application..."
exec node dist/main.js
`````

## File: backend/eslint.config.mjs
`````javascript
/**
 * ESLintè¨­å®šãƒ•ã‚¡ã‚¤ãƒ« (ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰)
 * NestJS + TypeScript + Prisma ç”¨ãƒ•ãƒ©ãƒƒãƒˆè¨­å®š
 * 
 * è¨­å®šæ–¹é‡:
 * - ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã®å‹å®‰å…¨æ€§ã‚’é‡è¦–
 * - NestJS/Prisma ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã«æº–æ‹ 
 * - ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã¯æŸ”è»Ÿãªãƒ«ãƒ¼ãƒ«é©ç”¨
 * - æ®µéšçš„ãªå“è³ªæ”¹å–„ã‚’ã‚µãƒãƒ¼ãƒˆ
 */

import js from '@eslint/js';
import tseslint from 'typescript-eslint';
import importX from 'eslint-plugin-import-x';
import prettier from 'eslint-config-prettier';

export default [
  // === åŸºæœ¬è¨­å®š ===
  js.configs.recommended,
  ...tseslint.configs.recommended,
  prettier,
  
  // === ãƒ¡ã‚¤ãƒ³è¨­å®š ===
  {
    name: 'backend-main-config',
    files: ['src/**/*.ts', 'src/**/*.js'],
    languageOptions: {
      ecmaVersion: 2020,
      sourceType: 'module',
      parserOptions: {
        project: './tsconfig.eslint.json', // ESLintå°‚ç”¨tsconfigä½¿ç”¨
        tsconfigRootDir: import.meta.dirname
      },
      globals: {
        node: true,
        jest: true
      }
    },
    plugins: {
      'import-x': importX,
    },
    rules: {
      // === TypeScript Rules ===
      // ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã§ã¯å‹å®‰å…¨æ€§ã‚’ã‚ˆã‚Šé‡è¦–
      '@typescript-eslint/no-explicit-any': 'error', // å³æ ¼åŒ–: productionã§ã¯ any ã‚’ç¦æ­¢
      '@typescript-eslint/no-unused-vars': ['warn', { 
        argsIgnorePattern: '^_',
        varsIgnorePattern: '^_'
      }],
      '@typescript-eslint/explicit-function-return-type': 'off',
      '@typescript-eslint/explicit-module-boundary-types': 'off',
      '@typescript-eslint/no-empty-function': 'off',
      
      // TypeScript unsafe operations - æ®µéšçš„æ”¹å–„
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-return': 'warn',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/require-await': 'off', // NestJSã§ã¯éåŒæœŸãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãŒå¤šç”¨ã•ã‚Œã‚‹
      '@typescript-eslint/no-floating-promises': 'warn',
      '@typescript-eslint/no-misused-promises': 'warn',
      '@typescript-eslint/prefer-promise-reject-errors': 'warn',
      
      // === Import/Export Rules ===
      'import-x/order': ['warn', {
        'groups': ['builtin', 'external', 'internal', 'parent', 'sibling', 'index'],
        'newlines-between': 'always',
        'alphabetize': { 'order': 'asc', 'caseInsensitive': true }
      }],
      'import-x/no-duplicates': 'error',
      'import-x/no-unresolved': 'warn',
      
      // === NestJS/Node.js Specific ===
      'no-console': 'off', // ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã§ã¯ãƒ­ã‚°å‡ºåŠ›ãŒé‡è¦
      'no-process-env': 'off', // ç’°å¢ƒå¤‰æ•°ã®ä½¿ç”¨ã¯å¿…è¦
    },
    settings: {
      'import-x/resolver': {
        typescript: {
          alwaysTryTypes: true,
          project: './tsconfig.eslint.json'
        },
        node: true
      }
    }
  },
  
  // === ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«å°‚ç”¨è¨­å®š ===
  {
    name: 'backend-test-config',
    files: ['test/**/*.ts', 'src/**/*.spec.ts', 'src/**/*.test.ts'],
    languageOptions: {
      parserOptions: {
        project: './tsconfig.eslint.json',
        tsconfigRootDir: import.meta.dirname
      },
      globals: {
        jest: true
      }
    },
    rules: {
      // ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã§ã¯å‹åˆ¶ç´„ã‚’ç·©å’Œ
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'off',
      '@typescript-eslint/no-unsafe-member-access': 'off',
      '@typescript-eslint/no-unsafe-call': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-argument': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      'no-console': 'off', // ãƒ†ã‚¹ãƒˆæ™‚ã®ãƒ‡ãƒãƒƒã‚°ç”¨
    }
  },
  
  // === ã‚¹ã‚¯ãƒªãƒ—ãƒˆãƒ•ã‚¡ã‚¤ãƒ«å°‚ç”¨è¨­å®š ===
  {
    name: 'backend-scripts-config',
    files: ['src/scripts/**/*.ts', 'src/scripts/**/*.mjs'],
    rules: {
      // ã‚¹ã‚¯ãƒªãƒ—ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã§ã¯åˆ¶ç´„ã‚’ç·©å’Œ
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'off',
      '@typescript-eslint/no-unsafe-member-access': 'off',
      '@typescript-eslint/no-unsafe-call': 'off',
      '@typescript-eslint/no-misused-promises': 'off', // csv-parserã®.on("data")ã§èª¤æ¤œçŸ¥ã•ã‚Œã‚‹ãŸã‚
      '@typescript-eslint/prefer-promise-reject-errors': 'off', // ã™ã§ã«Errorã‚’ä¿è¨¼ã—ã¦ã„ã‚‹ãŒESLintãŒèªè­˜ã—ãªã„ãŸã‚
      'no-console': 'off', // ã‚¹ã‚¯ãƒªãƒ—ãƒˆã§ã®ãƒ­ã‚°å‡ºåŠ›ã¯è¨±å¯
    }
  },
  
  // === é™¤å¤–è¨­å®š ===
  {
    name: 'backend-ignores',
    ignores: [
      'dist/**', 
      'node_modules/**', 
      'coverage/**',
      'prisma/migrations/**',
      '**/*.d.ts',
      '*.config.js',
      '*.config.mjs'
    ]
  }
];
`````

## File: backend/GEMINI.md
`````markdown
# backend GEMINI ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³

## 0. ç›®çš„ã¨å‚ç…§

- æœ¬ãƒ•ã‚¡ã‚¤ãƒ«ã¯ `backend/AGENTS.md` ã‚’ Gemini ç³» LLM ãŒå¿ å®Ÿã«è§£é‡ˆã§ãã‚‹ã‚ˆã†å†æ§‹æˆã—ãŸã‚‚ã®ã§ã™ã€‚NestJS / Prisma ä½œæ¥­æ™‚ã¯å¸¸ã« `AGENTS.md` ã¨å†…å®¹ã‚’åŒæœŸã—ã¦ãã ã•ã„ã€‚
- å‚ç…§ã—ãŸ Gemini å…¬å¼æƒ…å ±ï¼ˆæœ€çµ‚æ›´æ–° 2025-11-18 UTCï¼‰:
  - [Gemini API ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://ai.google.dev/gemini-api/docs)
  - [ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆè¨­è¨ˆæˆ¦ç•¥](https://ai.google.dev/gemini-api/docs/prompting-strategies)
- å…¬å¼ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã«è¿½å¾“ã—ãŸè¿½åŠ ãƒ«ãƒ¼ãƒ«ã¯ã€æ ¹æ‹  URL ã¨æ—¥ä»˜ã‚’è¿½è¨˜ã—ãŸä¸Šã§ `AGENTS.md` ã¸ã‚‚åæ˜ ã™ã‚‹ã“ã¨ã€‚

## 1. Gemini ã§ backend ã‚¿ã‚¹ã‚¯ã‚’æ‰±ã†éš›ã®æ³¨æ„

1. **ã‚·ã‚¹ãƒ†ãƒ æŒ‡ç¤ºã®å›ºå®š**: ã€Œæ—¥æœ¬èª UIã€ã€Œå‹å®‰å…¨ã€ã€ŒNestJS ãƒ¬ã‚¤ãƒ¤ãƒªãƒ³ã‚°ã€ãªã©å¿…é ˆè¦ä»¶ã‚’ system ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ã¾ã¨ã‚ã€ä»¥é™ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æŒ‡ç¤ºã§ä¸Šæ›¸ãã•ã‚Œãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚
2. **æ§‹é€ åŒ–ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ**: `<context>` ã«é–¢é€£ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆController/Service/Prismaï¼‰ã®æŠœç²‹ã‚’åˆ—æŒ™ã—ã€`<task>` ã«ç›®çš„ã€`<constraints>` ã«å“è³ªã‚²ãƒ¼ãƒˆã‚„ç¦æ­¢äº‹é …ã‚’åˆ—æŒ™ã™ã‚‹å½¢å¼ã‚’æ¨å¥¨ã€‚
3. **few-shot ã§ã® API ãƒ—ãƒ©ãƒ³**: `Gemini 2.5/3` ã¯è¨ˆç”»â†’å®Ÿè£…â†’æ¤œè¨¼ãƒ•ãƒ­ãƒ¼ãŒæ¨å¥¨ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€`Plan â†’ Implement â†’ Validate` ã® 3 ã‚¹ãƒ†ãƒƒãƒ—ä¾‹ã‚’æç¤ºã—ã€Prisma ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã‚’å¿…ãšåˆ—æŒ™ã€‚
4. **æ¸©åº¦è¨­å®š**: ã‚³ãƒ¼ãƒ‰ç”Ÿæˆã¯ `temperature=0.3`ã€œ`0.5`ã€`topK=1`ã€`topP=0.4` ç¨‹åº¦ã‹ã‚‰é–‹å§‹ã€‚Gemini 3 ç³»ã¯æ¸©åº¦ 1.0 å›ºå®šæ¨å¥¨ã®ãŸã‚ã€ç¢ºå®šå‡ºåŠ›ãŒå¿…è¦ãªå ´åˆã¯ `gemini-2.5 pro` ã‚’åˆ©ç”¨ã€‚
5. **å®‰å…¨ãƒ•ã‚£ãƒ«ã‚¿**: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è³‡æ ¼æƒ…å ±ã‚„å®Ÿé‹ç”¨ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã‚’é¿ã‘ã‚‹ãŸã‚ã€ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã«ã¯ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ï¼ˆä¾‹: `<REDACTED>`ï¼‰ã‚’ä½¿ç”¨ã—ã€ãƒ•ã‚¡ã‚¤ãƒ«å…¥å‡ºåŠ›ã¯ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‘ã‚¹å‚ç…§ã‚’æ˜ç¤ºã€‚
6. **æ¤œè¨¼ã‚¹ãƒ†ãƒƒãƒ—**: å…¬å¼ã‚¬ã‚¤ãƒ‰ãŒæ¨å¥¨ã™ã‚‹è‡ªå·±æ‰¹åˆ¤ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ç”¨ã„ã€ã€Œä¾é ¼ã®æ„å›³ / æ—¥æœ¬èªãƒ­ã‚° / å“è³ªã‚²ãƒ¼ãƒˆã€ã®ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã‚’å›ç­”å‰ã«èµ°ã‚‰ã›ã‚‹ã€‚

---

ä»¥ä¸‹ã¯ 2025-11-24 æ™‚ç‚¹ã® `backend/AGENTS.md` ã®å…¨æ–‡ã‚’è¤‡è£½ã—ãŸã‚‚ã®ã§ã™ã€‚å·®åˆ†æ›´æ–°æ™‚ã¯ä¸¡ãƒ•ã‚¡ã‚¤ãƒ«ã‚’åŒæ™‚ã«ä¿®æ­£ã—ã¦ãã ã•ã„ã€‚

# backend/AGENTS ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³

## 0. ç›®çš„ã¨é©ç”¨ç¯„å›²

- æœ¬æ›¸ã¯ `backend/` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§å‹•ä½œã™ã‚‹ NestJS 10 + Prisma 6 + PostgreSQL 15 å‘ã‘ã®å°‚ç”¨é‹ç”¨ã‚¬ã‚¤ãƒ‰ã§ã™ã€‚
- ãƒ«ãƒ¼ãƒˆ `AGENTS.md` ã®å…±é€šè¦ç´„ã« **è¿½åŠ è¦ä»¶** ã‚’ä¸ãˆã‚‹ã‚‚ã®ã§ã™ã€‚ç«¶åˆã—ãŸå ´åˆã¯æœ¬æ›¸ã®è¨˜è¿°ã‚’å„ªå…ˆã—ã¤ã¤ã€å·®åˆ†ç†ç”±ã‚’ PR ã§æ˜ç¤ºã—ã¦ãã ã•ã„ã€‚
- å¯¾è±¡èª­è€…: API / ãƒãƒƒãƒ / Prisma ã‚¹ã‚­ãƒ¼ãƒã‚’æ”¹ä¿®ã™ã‚‹ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã€‚

---

## 1. ã‚¯ã‚¤ãƒƒã‚¯ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹

### 1-1. ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— & å®Ÿè¡Œ

- ä¾å­˜åŒæœŸ: ãƒ«ãƒ¼ãƒˆã§ `pnpm install` â†’ `pnpm setup`ã€‚å€‹åˆ¥å®Ÿè¡Œã¯ `pnpm --filter backend install` ã‚’è¨±å¯ã€‚
- é–‹ç™ºã‚µãƒ¼ãƒãƒ¼: `pnpm dev`ï¼ˆãƒ«ãƒ¼ãƒˆï¼‰ã§ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ â†’ ãƒ•ãƒ­ãƒ³ãƒˆã®é †ã«èµ·å‹•ã€‚å˜ä½“ã§å‹•ã‹ã™å ´åˆã¯ `pnpm --filter backend run start:dev`ã€‚
- æœ¬ç•ªãƒ“ãƒ«ãƒ‰: `pnpm --filter backend run build` ã§ `dist/` ã‚’å†ç”Ÿæˆã€‚`start:prod` ã¯ `dist/main` ã‚’ Node.js ã§ç›´æ¥èµ·å‹•ã€‚
- Prisma åŒæœŸ: `pnpm --filter backend run prisma:generate` ã‚’ **ã‚¹ã‚­ãƒ¼ãƒæ›´æ–°ã”ã¨ã«å¿…ãš** å®Ÿè¡Œã€‚

### 1-2. å“è³ªã‚²ãƒ¼ãƒˆï¼ˆBackend ã‚¹ã‚³ãƒ¼ãƒ—ï¼‰

| ãƒ•ã‚§ãƒ¼ã‚º | ã‚³ãƒãƒ³ãƒ‰ | å‚™è€ƒ |
| --- | --- | --- |
| Lint | `pnpm --filter backend run lint` | eslint + prettierã€è‡ªå‹•ä¿®æ­£ã‚ã‚Š |
| å‹ãƒã‚§ãƒƒã‚¯ | `pnpm --filter backend run type-check` | `tsconfig.json` ã«å¯¾ã™ã‚‹ `tsc --noEmit` |
| Unit | `pnpm --filter backend run test` | Jestã€‚mock ã¯ `@nestjs/testing` ã‚’åˆ©ç”¨ |
| E2E | `pnpm --filter backend run test:e2e` | å®Ÿè¡Œå‰ã« `.env.test` ã‚’èª­ã¿è¾¼ã¿ã€`prisma migrate reset --force` ã‚’è‡ªå‹•å®Ÿè¡Œ |
| Build | `pnpm --filter backend run build` | `scripts/ensure-dev-build.mjs` ãŒ `node_modules/.prisma` å…¥ã‚Šã‚’ä¿è­· |

### 1-3. DB ã‚ªãƒšãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

- ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ä½œæˆ: `pnpm --filter backend run prisma:migrate`ï¼ˆ= `prisma migrate dev`ï¼‰ã€‚é–‹ç™ºä¸­ã®ã¿ä½¿ç”¨ã€‚
- æœ¬ç•ªé©ç”¨: `pnpm --filter backend run prisma:deploy`ã€‚CI/CD ã§ã‚‚åŒä¸€ã‚³ãƒãƒ³ãƒ‰ã‚’ä½¿ç”¨ã—ã€ãƒ€ã‚¦ãƒ³ã‚¿ã‚¤ãƒ ã‚’é¿ã‘ã‚‹ã€‚
- ã‚¹ã‚­ãƒ¼ãƒå·®ç•°ç¢ºèª: `pnpm --filter backend run prisma:status`ã€‚
- ã‚·ãƒ¼ãƒ‰: `pnpm --filter backend run seed`ã€‚PostgreSQL 15+ å‰æã§ç®¡ç†è€…ãƒ­ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã€‚

---

## 2. ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£åŸå‰‡ï¼ˆNestJS ãƒ¬ã‚¤ãƒ¤ãƒªãƒ³ã‚°ï¼‰

1. **Controller â†’ Service â†’ Repository/PrismaService** ã®å¢ƒç•Œã‚’å³å®ˆã—ã€Controller ã‹ã‚‰ Prisma ã‚’ç›´æ¥å‘¼ã³å‡ºã•ãªã„ã€‚
2. DTO / Entity / Presenter ã¯ `src/modules/<domain>/dto` ç­‰ã§æ•´ç†ã—ã€`class-validator` + `class-transformer` ã‚’çµ„ã¿åˆã‚ã›ã¦ I/O ã‚’å‹å®‰å…¨åŒ–ã€‚
3. DI ã‚³ãƒ³ãƒ†ãƒŠ: `@Injectable()` ã‚’ä»˜ä¸ã—ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¨ã™ã‚‹ã€‚å¾ªç’°ä¾å­˜ãŒã‚ã‚‹å ´åˆã®ã¿ `forwardRef()`ã€‚
4. ã‚¨ãƒ©ãƒ¼å‡¦ç†: `HttpException` ç³»ï¼ˆ`BadRequestException`, `ForbiddenException`, ...ï¼‰ã§çµ±ä¸€ã—ã€æ—¥æœ¬èªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿”å´ã€‚
5. Config: `@nestjs/config` ã®ã‚¹ã‚­ãƒ¼ãƒã« `zod` ã‚’çµ„ã¿åˆã‚ã›ã€å¿…é ˆç’°å¢ƒå¤‰æ•°ï¼ˆ`DATABASE_URL`, `JWT_SECRET`, `REDIS_URL` ç­‰ï¼‰ã‚’äº‹å‰æ¤œè¨¼ã€‚
6. ãƒ­ã‚®ãƒ³ã‚°: `nestjs-pino` ã‚’å…±é€š Logger ã¨ã—ã€PII ã‚’é™¤å»ã—ãŸæ§‹é€ åŒ–ãƒ­ã‚°ã‚’å‡ºåŠ›ã€‚
7. ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«/Bulk: `@nestjs/schedule` ã‚’ä½¿ç”¨ã™ã‚‹å‡¦ç†ã¯å°‚ç”¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’åˆ‡ã‚Šå‡ºã—ã€`CronExpression` ã‚’ `enum` åŒ–ã—ã¦é‡è¤‡ã‚’é˜²ãã€‚

> å‚è€ƒ: [NestJS Prisma ãƒ¬ã‚·ãƒ”](https://docs.nestjs.com/recipes/prisma) ã¯ PrismaService ã‚’ `PrismaClient` ã‹ã‚‰æ‹¡å¼µã—ã€`tsconfig.build.json` ã«ç”Ÿæˆç‰©ã‚’å«ã‚ã‚‹ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã‚’æ˜ç¤ºã€‚

---

## 3. API è¨­è¨ˆ & ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³

- DTO å‘½å: `CreateCatDto`, `UpdateShiftDto` ã®ã‚ˆã†ã«å‹•è© + å¯¾è±¡ + `Dto`ã€‚
- ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
   - æ–‡å­—åˆ—: `@IsString()` + `@IsNotEmpty()` ã‚’åŸºæœ¬ã«ã€ID ã¯ `@IsUUID()`ã€‚
   - æ—¥æ™‚è¨ˆç®—ã¯ `Zod` ã§ã‚µãƒ¼ãƒãƒ¼å´å†æ¤œè¨¼ã—ã€DTO ã§ã¯ ISO8601 æ–‡å­—åˆ—ã‚’å—ã‘å–ã‚‹ã€‚
- ãƒ¬ã‚¹ãƒãƒ³ã‚¹: `ClassSerializerInterceptor` ã§éš ã™ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼ˆ`passwordHash` ç­‰ï¼‰ã‚’ `@Exclude()`ã€‚
- èªè¨¼: `@nestjs/passport` + JWTï¼ˆ`@nestjs/jwt`ï¼‰ã§ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç™ºè¡Œã€‚CSRF ä¿è­·ãŒå¿…è¦ãªãƒ•ã‚©ãƒ¼ãƒ ã¯ `csurf` ã‚’ `cookie-parser` ã¨ä½µç”¨ã€‚
- ãƒ¬ãƒ¼ãƒˆåˆ¶å¾¡: å…¬é–‹ API ã¯ `@nestjs/throttler` ã§ `/auth/*` ã«å€‹åˆ¥è¨­å®šã€‚
- Swagger: `pnpm --filter backend run swagger:gen` ã§ `openapi.json` ã‚’å†ç”Ÿæˆã—ã€ãƒ•ãƒ­ãƒ³ãƒˆã¨åŒæœŸã€‚

---

## 4. Prisma / ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹æŒ‡é‡

1. **å‹ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆ**: ã‚¹ã‚­ãƒ¼ãƒæ›´æ–° â†’ `prisma generate` â†’ DTO/Service å®Ÿè£… â†’ ãƒ†ã‚¹ãƒˆã®é †åºã§ä½œæ¥­ã€‚
2. Query æœ€é©åŒ–:
   - å¿…è¦ãªãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ã¿ `select` / `include` ã§å–å¾—ã—ã€N+1 ã‚’é˜²æ­¢ã€‚
   - è¤‡é›‘ãªãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¯ `Prisma.transaction` ã‚„ `Prisma.$transaction` ã‚’åˆ©ç”¨ã€‚
3. ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³:
   - é–‹ç™º: `prisma migrate dev` ã§ `migration.sql` ã‚’è‡ªå‹•ç”Ÿæˆã€‚
   - æœ¬ç•ª: `prisma migrate deploy` ã§æ‰‹å‹•å…¥åŠ›ãªã—ã«é©ç”¨ï¼ˆ[NestJS Prisma Starter README](https://github.com/notiz-dev/nestjs-prisma-starter/blob/master/README.md) å‚ç…§ï¼‰ã€‚
4. ç”Ÿæˆç‰©ã®æ‰±ã„:
   - `node_modules/.prisma` ã‚’ Git ç„¡è¦–ã—ã€`dist/` ã¸å«ã‚ã‚‹ãŸã‚ `tsconfig.build.json` ã® include ãƒ‘ã‚¹ã« `prisma/generated` ã‚’è¿½åŠ æ¸ˆã¿ã‹ç¢ºèªã€‚
5. Connection Pool / ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥:
   - é«˜ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯ç’°å¢ƒã§ã¯ Prisma Accelerate (connection pooling + global cache) ã‚’æ¡ç”¨ã—ã€`prisma-examples/accelerate/*` ã®æ§‹æˆã‚’å‚è€ƒã« `DATABASE_URL` ã‚’ `prisma://` ã«åˆ‡ã‚Šæ›¿ãˆã€‚
6. ç›£è¦–: `prisma:status` ã‚’ CI ã§å®Ÿè¡Œã—ã€ã‚¹ã‚­ãƒ¼ãƒãƒ‰ãƒªãƒ•ãƒˆæ¤œçŸ¥ã‚’ç¾©å‹™åŒ–ã€‚

> å‚è€ƒ: [NestJS Prisma Starter](https://github.com/notiz-dev/nestjs-prisma-starter/blob/master/README.md) ã¯ devâ†’prod ã§ `migrate dev` ã¨ `migrate deploy` ã‚’ä½¿ã„åˆ†ã‘ã‚‹æ‰‹é †ã‚„ `prisma generate --watch` ã‚’æ¨å¥¨ã€‚
>
> å‚è€ƒ: [Prisma Examples README](https://raw.githubusercontent.com/prisma/prisma-examples/latest/README.md) ã® Accelerate/Optimize ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§æ¥ç¶šãƒ—ãƒ¼ãƒ«ã¨ã‚¯ã‚¨ãƒªæœ€é©åŒ–ã®æ¨å¥¨æ§‹æˆãŒå…¬é–‹ã€‚

---

## 5. PostgreSQL é‹ç”¨ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

- ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°åˆæœŸå€¤ï¼ˆPostgreSQL 18 doc ã‚ˆã‚Šï¼‰
   - `shared_buffers`: å°‚ç”¨ã‚µãƒ¼ãƒãƒ¼ã§ã¯ RAM ã® 25% ç¨‹åº¦ã‚’ç›®å®‰ã«è¨­å®šã€‚40% ã‚’è¶…ãˆãªã„ã€‚
   - `work_mem`: è¤‡é›‘ãªãƒãƒƒã‚·ãƒ¥/ã‚½ãƒ¼ãƒˆãŒå¤šã„å ´åˆã¯ 4MB â†’ 16MB ã¸æ®µéšçš„ã«å¢—ã‚„ã—ã€`hash_mem_multiplier` ã¨ä½µã›ã¦ç›£è¦–ã€‚
   - `maintenance_work_mem`: VACUUM/ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½œæˆæ™‚ã®ãƒãƒƒãƒ•ã‚¡ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ 64MB ã‹ã‚‰æ¥­å‹™ã«å¿œã˜ã¦æ‹¡å¼µã€‚
   - `autovacuum_work_mem`: `maintenance_work_mem` ã¨ç‹¬ç«‹åˆ¶å¾¡ã—ã€ãƒ¯ãƒ¼ã‚«ãƒ¼æ•° Ã— ãƒ¡ãƒ¢ãƒªãŒç‰©ç† RAM ã‚’è¶…ãˆãªã„ã‚ˆã†ã«ã™ã‚‹ã€‚
- I/O
   - `bgwriter_*` ã¨ `effective_io_concurrency` ã‚’èª¿æ•´ã—ã€ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆæ™‚ã®ã‚¹ãƒ‘ã‚¤ã‚¯ã‚’æŠ‘åˆ¶ã€‚
   - `temp_file_limit` ã‚’è¨­å®šã—ã€èª¤ã£ãŸã‚¯ã‚¨ãƒªã®ç„¡åˆ¶é™ä¸€æ™‚é ˜åŸŸç¢ºä¿ã‚’é˜»æ­¢ã€‚
- ç›£æŸ»: `pg_stat_statements` ã‚’ã‚ªãƒ³ã«ã—ã€`prisma optimize` æ¨å¥¨äº‹é …ï¼ˆå…¨ä»¶èµ°æŸ», éã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹åˆ—ãƒ•ã‚£ãƒ«ã‚¿ãªã©ï¼‰ã‚’å®šæœŸãƒ¬ãƒ“ãƒ¥ãƒ¼ã€‚

> å‚è€ƒ: [PostgreSQL 19.4 Resource Consumption](https://www.postgresql.org/docs/current/runtime-config-resource.html) ã¯ãƒ¡ãƒ¢ãƒªãƒ»I/O ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ¨å¥¨å¸¯åŸŸã‚’æç¤ºã€‚

---

## 6. ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ / å¯è¦³æ¸¬æ€§

- `/health/live` `/health/ready` ã‚’ `@nestjs/terminus` ã§å®Ÿè£…ã—ã€HTTP + Prisma + Redis + ãƒ‡ã‚£ã‚¹ã‚¯ã®ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ã‚’ç™»éŒ²ã€‚
- Terminus ã® `gracefulShutdownTimeoutMs` ã§ãƒ­ãƒ¼ãƒªãƒ³ã‚°ãƒ‡ãƒ—ãƒ­ã‚¤ã«ãŠã‘ã‚‹ã‚¼ãƒ­ãƒ€ã‚¦ãƒ³ã‚¿ã‚¤ãƒ ã‚’ç¢ºä¿ã€‚
- `nestjs-pino` ã¨ Sentry (`@sentry/node`) ã‚’çµ±åˆã—ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆ ID ã‚’ `AsyncLocalStorage` ã§ä¼æ’­ã€‚

> å‚è€ƒ: [NestJS Terminus ã‚¬ã‚¤ãƒ‰](https://docs.nestjs.com/recipes/terminus) ã¯ãƒ˜ãƒ«ã‚¹ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ã¨ graceful shutdown ã®è¨­å®šä¾‹ã‚’æç¤ºã€‚

---

## 7. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ & ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹

- HTTP ãƒ˜ãƒƒãƒ€ãƒ¼: `helmet` ã‚’å…¨ãƒ«ãƒ¼ãƒˆã«é©ç”¨ã—ã€`crossOriginResourcePolicy` ã‚’ `same-site`ã€‚
- èªè¨¼æƒ…å ±: `argon2` ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒãƒƒã‚·ãƒ¥ã«ä½¿ç”¨ã€‚`bcryptjs` ã¯äº’æ›ç”¨ãƒ¬ã‚¬ã‚·ãƒ¼ã®ã¿ã€‚
- CSRF: Cookie ãƒ™ãƒ¼ã‚¹èªè¨¼ãƒ‘ã‚¹ã¯ `csurf` ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ hidden input ã§å¾€å¾©ã€‚
- Secrets ç®¡ç†: ãƒ«ãƒ¼ãƒˆã® `pnpm run generate-secrets` ã§ç’°å¢ƒä¾å­˜ã®ã‚­ãƒ¼ã‚’ç”Ÿæˆã—ã€`.env` ã¨ã®å·®åˆ†ã‚’ `git update-index --assume-unchanged` ã§ä¿è­·ã€‚
- å…¥åŠ›ãƒ•ã‚¡ã‚¤ãƒ«: `multer` ã‚’ä½¿ã†å ´åˆã€ãƒ•ã‚¡ã‚¤ãƒ«ç¨®åˆ¥ãƒ›ãƒ¯ã‚¤ãƒˆãƒªã‚¹ãƒˆ + ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚µã‚¤ã‚ºåˆ¶é™ã‚’å¿…é ˆã€‚

---

## 8. ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

- Unit: Service / Guard / Pipe ã”ã¨ã« `*.spec.ts` ä½œæˆã€‚Prisma ä¾å­˜éƒ¨ã¯ `@nestjs/testing` + `PrismaService` ã®ãƒ¢ãƒƒã‚¯ï¼ˆ`jest.mock`ï¼‰ã§ä»£æ›¿ã€‚
- Integration/E2E: `test/*.e2e-spec.ts` ã‚’ `test:e2e` ã§ç›´åˆ—å®Ÿè¡Œã€‚å„ã‚±ãƒ¼ã‚¹å†’é ­ã§ `await prisma.$transaction([prisma.model.deleteMany(), ...])` ã—ã¦ãƒ‡ãƒ¼ã‚¿æ±šæŸ“ã‚’é˜²ãã€‚
- ã‚³ãƒ¼ãƒ‰ã‚«ãƒãƒ¬ãƒƒã‚¸: global 70% ä»¥ä¸Šã€‚é‡è¦ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã¯ 90% è¶…ã‚’ç›®æ¨™ã€‚

---

## 9. é–‹ç™ºãƒ•ãƒ­ãƒ¼ ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

1. å¤‰æ›´ç¯„å›²ã® `CODE_GUIDE.md` ãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèªï¼ˆç¾çŠ¶ backend é…ä¸‹ã¯æœªå®šç¾©ï¼‰ã€‚
2. ä½œæ¥­å‰ã« `pnpm lint` + `pnpm backend:build` ã®æœ€æ–°çµæœã‚’æŠŠæ¡ã€‚
3. **å‹ â†’ å®Ÿè£… â†’ ãƒ†ã‚¹ãƒˆ â†’ Prisma migrate â†’ ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ** ã®é †ã§æ›´æ–°ã€‚
4. å¤‰æ›´å¾Œã¯æœ€ä½ã§ã‚‚ `pnpm lint`, `pnpm backend:build`, `pnpm --filter backend run test` ã‚’ PASS ã•ã›ã‚‹ã€‚
5. Prisma å¤‰æ›´æ™‚ã¯ `pnpm db:migrate` + `pnpm db:seed` ã§å·®åˆ†ã‚’å†ç¾ã€‚
6. PR ã«ã¯:
   - å¤‰æ›´ç†ç”±ã¨å½±éŸ¿ç¯„å›²
   - æ–°è¦/æ›´æ–°ã‚³ãƒãƒ³ãƒ‰ã®å®Ÿè¡Œãƒ­ã‚°
   - æ—¢çŸ¥ã®æœªå¯¾å¿œäº‹é …ï¼ˆä¾‹: è¿½åŠ ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ¡ˆï¼‰
   ã‚’æ—¥æœ¬èªã§æ·»ä»˜ã€‚

---

## 10. å‚è€ƒãƒªãƒ³ã‚¯

- NestJS å…¬å¼: [Prisma ãƒ¬ã‚·ãƒ”](https://docs.nestjs.com/recipes/prisma), [Terminus / Health Checks](https://docs.nestjs.com/recipes/terminus)
- Prisma: [NestJS Prisma Starter README](https://github.com/notiz-dev/nestjs-prisma-starter/blob/master/README.md), [Prisma Examples README](https://raw.githubusercontent.com/prisma/prisma-examples/latest/README.md)
- PostgreSQL: [Resource Consumption (19.4)](https://www.postgresql.org/docs/current/runtime-config-resource.html)

ä»¥ä¸Šã®æ–¹é‡ã‹ã‚‰é€¸è„±ã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã¯ã€æ ¹æ‹ ã¨ãƒªã‚¹ã‚¯ç·©å’Œç­–ã‚’ PR èª¬æ˜ã¾ãŸã¯ `docs/` é…ä¸‹ã®è¨­è¨ˆè³‡æ–™ã«æ®‹ã—ã¦ãã ã•ã„ã€‚
`````

## File: backend/nest-cli.json
`````json
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "entryFile": "main",
  "compilerOptions": {
    "deleteOutDir": true,
    "tsConfigPath": "tsconfig.build.json",
    "webpack": false,
    "assets": [
      {
        "include": "pedigree/pdf/positions.json",
        "outDir": "dist"
      },
      {
        "include": "pedigree/pdf/\u8840\u7d71\u66f8\u898b\u672c.png",
        "outDir": "dist"
      },
      {
        "include": "pedigree/pdf/backgrounds/**/*",
        "outDir": "dist"
      }
    ],
    "watchAssets": false
  }
}
`````

## File: backend/openapi.json
`````json
{
  "openapi": "3.0.0",
  "paths": {
    "/api/v1/master/genders": {
      "get": {
        "operationId": "MasterDataController_getGenders",
        "summary": "æ€§åˆ¥ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆèªè¨¼ä¸è¦ï¼‰",
        "parameters": [],
        "responses": {
          "200": {
            "description": "æ€§åˆ¥ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’è¿”å´"
          }
        },
        "tags": [
          "Master Data"
        ]
      }
    },
    "/api/v1/auth/login": {
      "post": {
        "operationId": "AuthController_login",
        "summary": "ãƒ­ã‚°ã‚¤ãƒ³ï¼ˆJWTç™ºè¡Œï¼‰",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LoginDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Auth"
        ]
      }
    },
    "/api/v1/auth/register": {
      "post": {
        "operationId": "AuthController_register",
        "summary": "ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²ï¼ˆãƒ¡ãƒ¼ãƒ«ï¼‹ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼‰",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LoginDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Auth"
        ]
      }
    },
    "/api/v1/auth/set-password": {
      "post": {
        "operationId": "AuthController_setPassword",
        "summary": "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰è¨­å®š/å¤‰æ›´ï¼ˆè¦JWTï¼‰",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LoginDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Auth"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/auth/change-password": {
      "post": {
        "operationId": "AuthController_changePassword",
        "summary": "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¤‰æ›´ï¼ˆç¾åœ¨ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ç¢ºèªå¿…è¦ï¼‰",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChangePasswordDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Auth"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/auth/request-password-reset": {
      "post": {
        "operationId": "AuthController_requestPasswordReset",
        "summary": "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆè¦æ±‚",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RequestPasswordResetDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "ãƒªã‚»ãƒƒãƒˆæ‰‹é †ã‚’ãƒ¡ãƒ¼ãƒ«ã§é€ä¿¡"
          }
        },
        "tags": [
          "Auth"
        ]
      }
    },
    "/api/v1/auth/reset-password": {
      "post": {
        "operationId": "AuthController_resetPassword",
        "summary": "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆå®Ÿè¡Œ",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ResetPasswordDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã—ãŸ"
          },
          "400": {
            "description": "ç„¡åŠ¹ã¾ãŸã¯æœŸé™åˆ‡ã‚Œã®ãƒˆãƒ¼ã‚¯ãƒ³"
          }
        },
        "tags": [
          "Auth"
        ]
      }
    },
    "/api/v1/auth/refresh": {
      "post": {
        "operationId": "AuthController_refresh",
        "summary": "ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã§ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³å†å–å¾—",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RefreshTokenDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Auth"
        ]
      }
    },
    "/api/v1/auth/logout": {
      "post": {
        "operationId": "AuthController_logout",
        "summary": "ãƒ­ã‚°ã‚¢ã‚¦ãƒˆï¼ˆãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³å‰Šé™¤ï¼‰",
        "parameters": [],
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Auth"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/cats": {
      "post": {
        "operationId": "CatsController_create",
        "summary": "çŒ«ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateCatDto"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "çŒ«ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«ä½œæˆã•ã‚Œã¾ã—ãŸ"
          },
          "400": {
            "description": "ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§ã™"
          }
        },
        "tags": [
          "Cats"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "get": {
        "operationId": "CatsController_findAll",
        "summary": "çŒ«ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œç´¢ãƒ»ä¸€è¦§å–å¾—",
        "parameters": [
          {
            "name": "page",
            "required": false,
            "in": "query",
            "description": "ãƒšãƒ¼ã‚¸ç•ªå·",
            "schema": {
              "default": 1,
              "example": 1,
              "type": "number"
            }
          },
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "description": "1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•°",
            "schema": {
              "default": 10,
              "example": 10,
              "type": "number"
            }
          },
          {
            "name": "search",
            "required": false,
            "in": "query",
            "description": "æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "breedId",
            "required": false,
            "in": "query",
            "description": "å“ç¨®ID",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "coatColorId",
            "required": false,
            "in": "query",
            "description": "æ¯›è‰²ID",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "gender",
            "required": false,
            "in": "query",
            "description": "æ€§åˆ¥",
            "schema": {
              "enum": [
                "MALE",
                "FEMALE",
                "NEUTER",
                "SPAY",
                "1",
                "2",
                "3",
                "4"
              ],
              "type": "string"
            }
          },
          {
            "name": "ageMin",
            "required": false,
            "in": "query",
            "description": "æœ€å°å¹´é½¢",
            "schema": {
              "type": "number"
            }
          },
          {
            "name": "ageMax",
            "required": false,
            "in": "query",
            "description": "æœ€å¤§å¹´é½¢",
            "schema": {
              "type": "number"
            }
          },
          {
            "name": "sortBy",
            "required": false,
            "in": "query",
            "description": "ã‚½ãƒ¼ãƒˆé …ç›®",
            "schema": {
              "default": "createdAt",
              "example": "createdAt",
              "type": "string"
            }
          },
          {
            "name": "sortOrder",
            "required": false,
            "in": "query",
            "description": "ã‚½ãƒ¼ãƒˆé †",
            "schema": {
              "default": "desc",
              "example": "desc",
              "type": "string"
            }
          },
          {
            "name": "status",
            "required": false,
            "in": "query",
            "description": "ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹",
            "schema": {}
          }
        ],
        "responses": {
          "200": {
            "description": "çŒ«ãƒ‡ãƒ¼ã‚¿ã®ä¸€è¦§"
          }
        },
        "tags": [
          "Cats"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/cats/statistics": {
      "get": {
        "operationId": "CatsController_getStatistics",
        "summary": "çŒ«ãƒ‡ãƒ¼ã‚¿ã®çµ±è¨ˆæƒ…å ±ã‚’å–å¾—",
        "parameters": [],
        "responses": {
          "200": {
            "description": "çµ±è¨ˆæƒ…å ±"
          }
        },
        "tags": [
          "Cats"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/cats/{id}": {
      "get": {
        "operationId": "CatsController_findOne",
        "summary": "IDã§çŒ«ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "description": "çŒ«ãƒ‡ãƒ¼ã‚¿ã®ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "çŒ«ãƒ‡ãƒ¼ã‚¿"
          },
          "404": {
            "description": "çŒ«ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
          }
        },
        "tags": [
          "Cats"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "patch": {
        "operationId": "CatsController_update",
        "summary": "çŒ«ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "description": "çŒ«ãƒ‡ãƒ¼ã‚¿ã®ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateCatDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "çŒ«ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«æ›´æ–°ã•ã‚Œã¾ã—ãŸ"
          },
          "400": {
            "description": "ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§ã™"
          },
          "404": {
            "description": "çŒ«ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
          }
        },
        "tags": [
          "Cats"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "delete": {
        "operationId": "CatsController_remove",
        "summary": "çŒ«ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "description": "çŒ«ãƒ‡ãƒ¼ã‚¿ã®ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "çŒ«ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«å‰Šé™¤ã•ã‚Œã¾ã—ãŸ"
          },
          "404": {
            "description": "çŒ«ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
          }
        },
        "tags": [
          "Cats"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/cats/{id}/breeding-history": {
      "get": {
        "operationId": "CatsController_getBreedingHistory",
        "summary": "çŒ«ã®ç¹æ®–å±¥æ­´ã‚’å–å¾—",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "description": "çŒ«ãƒ‡ãƒ¼ã‚¿ã®ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "ç¹æ®–å±¥æ­´"
          },
          "404": {
            "description": "çŒ«ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
          }
        },
        "tags": [
          "Cats"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/cats/{id}/care-history": {
      "get": {
        "operationId": "CatsController_getCareHistory",
        "summary": "çŒ«ã®ã‚±ã‚¢å±¥æ­´ã‚’å–å¾—",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "description": "çŒ«ãƒ‡ãƒ¼ã‚¿ã®ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "ã‚±ã‚¢å±¥æ­´"
          },
          "404": {
            "description": "çŒ«ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
          }
        },
        "tags": [
          "Cats"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/cats/genders": {
      "get": {
        "operationId": "CatsController_getGenders",
        "summary": "æ€§åˆ¥ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—",
        "parameters": [],
        "responses": {
          "200": {
            "description": "æ€§åˆ¥ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’è¿”å´"
          }
        },
        "tags": [
          "Cats"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/pedigrees": {
      "post": {
        "operationId": "PedigreeController_create",
        "summary": "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆï¼ˆç®¡ç†è€…ã®ã¿ï¼‰",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreatePedigreeDto"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«ä½œæˆã•ã‚Œã¾ã—ãŸ"
          },
          "400": {
            "description": "ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§ã™"
          },
          "403": {
            "description": "ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™"
          }
        },
        "tags": [
          "Pedigrees"
        ]
      },
      "get": {
        "operationId": "PedigreeController_findAll",
        "summary": "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œç´¢ãƒ»ä¸€è¦§å–å¾—",
        "parameters": [
          {
            "name": "page",
            "required": false,
            "in": "query",
            "description": "ãƒšãƒ¼ã‚¸ç•ªå·",
            "schema": {
              "default": 1,
              "example": 1,
              "type": "number"
            }
          },
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "description": "1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•°",
            "schema": {
              "default": 10,
              "example": 10,
              "type": "number"
            }
          },
          {
            "name": "search",
            "required": false,
            "in": "query",
            "description": "æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "breedId",
            "required": false,
            "in": "query",
            "description": "å“ç¨®ID",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "coatColorId",
            "required": false,
            "in": "query",
            "description": "æ¯›è‰²ID",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "gender",
            "required": false,
            "in": "query",
            "description": "æ€§åˆ¥ (1: ã‚ªã‚¹, 2: ãƒ¡ã‚¹)",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "catName2",
            "required": false,
            "in": "query",
            "description": "ã‚­ãƒ£ãƒƒãƒ†ãƒªãƒ¼å",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "eyeColor",
            "required": false,
            "in": "query",
            "description": "ç›®ã®è‰²",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sortBy",
            "required": false,
            "in": "query",
            "description": "ã‚½ãƒ¼ãƒˆé …ç›®",
            "schema": {
              "default": "createdAt",
              "example": "createdAt",
              "type": "string"
            }
          },
          {
            "name": "sortOrder",
            "required": false,
            "in": "query",
            "description": "ã‚½ãƒ¼ãƒˆé †",
            "schema": {
              "default": "desc",
              "example": "desc",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®ä¸€è¦§"
          }
        },
        "tags": [
          "Pedigrees"
        ]
      }
    },
    "/api/v1/pedigrees/pedigree-id/{pedigreeId}": {
      "get": {
        "operationId": "PedigreeController_findByPedigreeId",
        "summary": "è¡€çµ±æ›¸ç•ªå·ã§è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—",
        "parameters": [
          {
            "name": "pedigreeId",
            "required": true,
            "in": "path",
            "description": "è¡€çµ±æ›¸ç•ªå·",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿"
          },
          "404": {
            "description": "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
          }
        },
        "tags": [
          "Pedigrees"
        ]
      }
    },
    "/api/v1/pedigrees/{id}": {
      "get": {
        "operationId": "PedigreeController_findOne",
        "summary": "IDã§è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "description": "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿"
          },
          "404": {
            "description": "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
          }
        },
        "tags": [
          "Pedigrees"
        ]
      },
      "patch": {
        "operationId": "PedigreeController_update",
        "summary": "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "description": "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdatePedigreeDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«æ›´æ–°ã•ã‚Œã¾ã—ãŸ"
          },
          "400": {
            "description": "ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§ã™"
          },
          "403": {
            "description": "ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™"
          },
          "404": {
            "description": "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
          }
        },
        "tags": [
          "Pedigrees"
        ]
      },
      "delete": {
        "operationId": "PedigreeController_remove",
        "summary": "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "description": "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«å‰Šé™¤ã•ã‚Œã¾ã—ãŸ"
          },
          "403": {
            "description": "ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™"
          },
          "404": {
            "description": "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
          }
        },
        "tags": [
          "Pedigrees"
        ]
      }
    },
    "/api/v1/pedigrees/{id}/family-tree": {
      "get": {
        "operationId": "PedigreeController_getFamilyTree",
        "summary": "è¡€çµ±æ›¸ã®å®¶ç³»å›³ã‚’å–å¾—",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "description": "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "å®¶ç³»å›³ãƒ‡ãƒ¼ã‚¿"
          },
          "404": {
            "description": "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
          }
        },
        "tags": [
          "Pedigrees"
        ]
      }
    },
    "/api/v1/pedigrees/{id}/family": {
      "get": {
        "operationId": "PedigreeController_getFamily",
        "summary": "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®å®¶ç³»å›³ã‚’å–å¾—",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "description": "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®ID",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "generations",
            "required": false,
            "in": "query",
            "description": "å–å¾—ã™ã‚‹ä¸–ä»£æ•°",
            "schema": {
              "example": 3,
              "type": "number"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "å®¶ç³»å›³ãƒ‡ãƒ¼ã‚¿"
          },
          "404": {
            "description": "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
          }
        },
        "tags": [
          "Pedigrees"
        ]
      }
    },
    "/api/v1/pedigrees/{id}/descendants": {
      "get": {
        "operationId": "PedigreeController_getDescendants",
        "summary": "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®å­å­«ã‚’å–å¾—",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "description": "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "å­å­«ãƒ‡ãƒ¼ã‚¿"
          },
          "404": {
            "description": "è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
          }
        },
        "tags": [
          "Pedigrees"
        ]
      }
    },
    "/api/v1/breeds": {
      "post": {
        "operationId": "BreedsController_create",
        "summary": "å“ç¨®ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆï¼ˆç®¡ç†è€…ã®ã¿ï¼‰",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateBreedDto"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "å“ç¨®ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«ä½œæˆã•ã‚Œã¾ã—ãŸ"
          },
          "400": {
            "description": "ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§ã™"
          },
          "403": {
            "description": "ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™"
          }
        },
        "tags": [
          "Breeds"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "get": {
        "operationId": "BreedsController_findAll",
        "summary": "å“ç¨®ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œç´¢ãƒ»ä¸€è¦§å–å¾—",
        "parameters": [
          {
            "name": "page",
            "required": false,
            "in": "query",
            "description": "ãƒšãƒ¼ã‚¸ç•ªå·",
            "schema": {
              "default": 1,
              "example": 1,
              "type": "number"
            }
          },
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "description": "1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•°",
            "schema": {
              "default": 50,
              "example": 50,
              "type": "number"
            }
          },
          {
            "name": "search",
            "required": false,
            "in": "query",
            "description": "æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sortBy",
            "required": false,
            "in": "query",
            "description": "ã‚½ãƒ¼ãƒˆé …ç›®",
            "schema": {
              "default": "name",
              "example": "name",
              "type": "string"
            }
          },
          {
            "name": "sortOrder",
            "required": false,
            "in": "query",
            "description": "ã‚½ãƒ¼ãƒˆé †",
            "schema": {
              "default": "asc",
              "example": "asc",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "å“ç¨®ãƒ‡ãƒ¼ã‚¿ã®ä¸€è¦§"
          }
        },
        "tags": [
          "Breeds"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/breeds/statistics": {
      "get": {
        "operationId": "BreedsController_getStatistics",
        "summary": "å“ç¨®ãƒ‡ãƒ¼ã‚¿ã®çµ±è¨ˆæƒ…å ±ã‚’å–å¾—",
        "parameters": [],
        "responses": {
          "200": {
            "description": "çµ±è¨ˆæƒ…å ±"
          }
        },
        "tags": [
          "Breeds"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/breeds/{id}": {
      "get": {
        "operationId": "BreedsController_findOne",
        "summary": "IDã§å“ç¨®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "description": "å“ç¨®ãƒ‡ãƒ¼ã‚¿ã®ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "å“ç¨®ãƒ‡ãƒ¼ã‚¿"
          },
          "404": {
            "description": "å“ç¨®ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
          }
        },
        "tags": [
          "Breeds"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "patch": {
        "operationId": "BreedsController_update",
        "summary": "å“ç¨®ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "description": "å“ç¨®ãƒ‡ãƒ¼ã‚¿ã®ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateBreedDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "å“ç¨®ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«æ›´æ–°ã•ã‚Œã¾ã—ãŸ"
          },
          "400": {
            "description": "ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§ã™"
          },
          "403": {
            "description": "ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™"
          },
          "404": {
            "description": "å“ç¨®ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
          }
        },
        "tags": [
          "Breeds"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "delete": {
        "operationId": "BreedsController_remove",
        "summary": "å“ç¨®ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "description": "å“ç¨®ãƒ‡ãƒ¼ã‚¿ã®ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "å“ç¨®ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«å‰Šé™¤ã•ã‚Œã¾ã—ãŸ"
          },
          "403": {
            "description": "ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™"
          },
          "404": {
            "description": "å“ç¨®ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
          }
        },
        "tags": [
          "Breeds"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/coat-colors": {
      "post": {
        "operationId": "CoatColorsController_create",
        "summary": "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆï¼ˆç®¡ç†è€…ã®ã¿ï¼‰",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateCoatColorDto"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«ä½œæˆã•ã‚Œã¾ã—ãŸ"
          },
          "400": {
            "description": "ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§ã™"
          },
          "403": {
            "description": "ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™"
          }
        },
        "tags": [
          "Coat Colors"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "get": {
        "operationId": "CoatColorsController_findAll",
        "summary": "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œç´¢ãƒ»ä¸€è¦§å–å¾—",
        "parameters": [
          {
            "name": "page",
            "required": false,
            "in": "query",
            "description": "ãƒšãƒ¼ã‚¸ç•ªå·",
            "schema": {
              "default": 1,
              "example": 1,
              "type": "number"
            }
          },
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "description": "1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•°",
            "schema": {
              "default": 50,
              "example": 50,
              "type": "number"
            }
          },
          {
            "name": "search",
            "required": false,
            "in": "query",
            "description": "æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sortBy",
            "required": false,
            "in": "query",
            "description": "ã‚½ãƒ¼ãƒˆé …ç›®",
            "schema": {
              "default": "name",
              "example": "name",
              "type": "string"
            }
          },
          {
            "name": "sortOrder",
            "required": false,
            "in": "query",
            "description": "ã‚½ãƒ¼ãƒˆé †",
            "schema": {
              "default": "asc",
              "example": "asc",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã®ä¸€è¦§"
          }
        },
        "tags": [
          "Coat Colors"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/coat-colors/statistics": {
      "get": {
        "operationId": "CoatColorsController_getStatistics",
        "summary": "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã®çµ±è¨ˆæƒ…å ±ã‚’å–å¾—",
        "parameters": [],
        "responses": {
          "200": {
            "description": "çµ±è¨ˆæƒ…å ±"
          }
        },
        "tags": [
          "Coat Colors"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/coat-colors/{id}": {
      "get": {
        "operationId": "CoatColorsController_findOne",
        "summary": "IDã§æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "description": "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã®ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿"
          },
          "404": {
            "description": "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
          }
        },
        "tags": [
          "Coat Colors"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "patch": {
        "operationId": "CoatColorsController_update",
        "summary": "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "description": "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã®ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateCoatColorDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«æ›´æ–°ã•ã‚Œã¾ã—ãŸ"
          },
          "400": {
            "description": "ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§ã™"
          },
          "403": {
            "description": "ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™"
          },
          "404": {
            "description": "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
          }
        },
        "tags": [
          "Coat Colors"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "delete": {
        "operationId": "CoatColorsController_remove",
        "summary": "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "description": "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã®ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«å‰Šé™¤ã•ã‚Œã¾ã—ãŸ"
          },
          "403": {
            "description": "ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™"
          },
          "404": {
            "description": "æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
          }
        },
        "tags": [
          "Coat Colors"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/breeding": {
      "get": {
        "operationId": "BreedingController_findAll",
        "summary": "äº¤é…è¨˜éŒ²ä¸€è¦§ã®å–å¾—",
        "parameters": [
          {
            "name": "page",
            "required": false,
            "in": "query",
            "schema": {
              "example": 1,
              "type": "number"
            }
          },
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "schema": {
              "example": 20,
              "type": "number"
            }
          },
          {
            "name": "femaleId",
            "required": false,
            "in": "query",
            "description": "ãƒ¡ã‚¹çŒ«ID",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "maleId",
            "required": false,
            "in": "query",
            "description": "ã‚ªã‚¹çŒ«ID",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dateFrom",
            "required": false,
            "in": "query",
            "description": "é–‹å§‹æ—¥(YYYY-MM-DD)",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dateTo",
            "required": false,
            "in": "query",
            "description": "çµ‚äº†æ—¥(YYYY-MM-DD)",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sortBy",
            "required": false,
            "in": "query",
            "schema": {
              "example": "createdAt",
              "type": "string"
            }
          },
          {
            "name": "sortOrder",
            "required": false,
            "in": "query",
            "schema": {
              "example": "desc",
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Breeding"
        ]
      },
      "post": {
        "operationId": "BreedingController_create",
        "summary": "äº¤é…è¨˜éŒ²ã®æ–°è¦ä½œæˆ",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateBreedingDto"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": ""
          }
        },
        "tags": [
          "Breeding"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/breeding/ng-rules": {
      "get": {
        "operationId": "BreedingController_findNgRules",
        "summary": "NGãƒšã‚¢ãƒ«ãƒ¼ãƒ«ä¸€è¦§ã®å–å¾—",
        "parameters": [],
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Breeding"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "post": {
        "operationId": "BreedingController_createNgRule",
        "summary": "NGãƒšã‚¢ãƒ«ãƒ¼ãƒ«ã®ä½œæˆ",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateBreedingNgRuleDto"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": ""
          }
        },
        "tags": [
          "Breeding"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/breeding/ng-rules/{id}": {
      "patch": {
        "operationId": "BreedingController_updateNgRule",
        "summary": "NGãƒšã‚¢ãƒ«ãƒ¼ãƒ«ã®æ›´æ–°",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateBreedingNgRuleDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Breeding"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "delete": {
        "operationId": "BreedingController_removeNgRule",
        "summary": "NGãƒšã‚¢ãƒ«ãƒ¼ãƒ«ã®å‰Šé™¤",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Breeding"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/breeding/test": {
      "get": {
        "operationId": "BreedingController_test",
        "summary": "ãƒ†ã‚¹ãƒˆ",
        "parameters": [],
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Breeding"
        ]
      }
    },
    "/api/v1/breeding/pregnancy-checks": {
      "get": {
        "operationId": "BreedingController_findAllPregnancyChecks",
        "summary": "å¦Šå¨ ãƒã‚§ãƒƒã‚¯ä¸€è¦§ã®å–å¾—",
        "parameters": [
          {
            "name": "motherId",
            "required": false,
            "in": "query",
            "description": "æ¯è¦ªã®çŒ«ID",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "status",
            "required": false,
            "in": "query",
            "description": "å¦Šå¨ çŠ¶æ…‹",
            "schema": {
              "enum": [
                "CONFIRMED",
                "SUSPECTED",
                "NEGATIVE",
                "ABORTED"
              ],
              "type": "string"
            }
          },
          {
            "name": "page",
            "required": false,
            "in": "query",
            "description": "ãƒšãƒ¼ã‚¸ç•ªå·",
            "schema": {
              "default": 1,
              "type": "number"
            }
          },
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "description": "1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•°",
            "schema": {
              "default": 20,
              "type": "number"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Breeding"
        ]
      },
      "post": {
        "operationId": "BreedingController_createPregnancyCheck",
        "summary": "å¦Šå¨ ãƒã‚§ãƒƒã‚¯ã®æ–°è¦ä½œæˆ",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreatePregnancyCheckDto"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": ""
          }
        },
        "tags": [
          "Breeding"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/breeding/pregnancy-checks/{id}": {
      "patch": {
        "operationId": "BreedingController_updatePregnancyCheck",
        "summary": "å¦Šå¨ ãƒã‚§ãƒƒã‚¯ã®æ›´æ–°",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdatePregnancyCheckDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Breeding"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "delete": {
        "operationId": "BreedingController_removePregnancyCheck",
        "summary": "å¦Šå¨ ãƒã‚§ãƒƒã‚¯ã®å‰Šé™¤",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Breeding"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/breeding/birth-plans": {
      "get": {
        "operationId": "BreedingController_findAllBirthPlans",
        "summary": "å‡ºç”£è¨ˆç”»ä¸€è¦§ã®å–å¾—",
        "parameters": [
          {
            "name": "motherId",
            "required": false,
            "in": "query",
            "description": "æ¯è¦ªã®çŒ«ID",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "status",
            "required": false,
            "in": "query",
            "description": "å‡ºç”£çŠ¶æ…‹",
            "schema": {
              "enum": [
                "EXPECTED",
                "BORN",
                "ABORTED",
                "STILLBORN"
              ],
              "type": "string"
            }
          },
          {
            "name": "page",
            "required": false,
            "in": "query",
            "description": "ãƒšãƒ¼ã‚¸ç•ªå·",
            "schema": {
              "default": 1,
              "type": "number"
            }
          },
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "description": "1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•°",
            "schema": {
              "default": 20,
              "type": "number"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Breeding"
        ]
      },
      "post": {
        "operationId": "BreedingController_createBirthPlan",
        "summary": "å‡ºç”£è¨ˆç”»ã®æ–°è¦ä½œæˆ",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateBirthPlanDto"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": ""
          }
        },
        "tags": [
          "Breeding"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/breeding/birth-plans/{id}": {
      "patch": {
        "operationId": "BreedingController_updateBirthPlan",
        "summary": "å‡ºç”£è¨ˆç”»ã®æ›´æ–°",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateBirthPlanDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Breeding"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "delete": {
        "operationId": "BreedingController_removeBirthPlan",
        "summary": "å‡ºç”£è¨ˆç”»ã®å‰Šé™¤",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Breeding"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/breeding/kitten-dispositions/{birthRecordId}": {
      "get": {
        "operationId": "BreedingController_findAllKittenDispositions",
        "summary": "å‡ºç”£è¨˜éŒ²ã®å­çŒ«å‡¦é‡ä¸€è¦§å–å¾—",
        "parameters": [
          {
            "name": "birthRecordId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Breeding"
        ]
      }
    },
    "/api/v1/breeding/kitten-dispositions": {
      "post": {
        "operationId": "BreedingController_createKittenDisposition",
        "summary": "å­çŒ«å‡¦é‡ã®ç™»éŒ²",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateKittenDispositionDto"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": ""
          }
        },
        "tags": [
          "Breeding"
        ]
      }
    },
    "/api/v1/breeding/kitten-dispositions/{id}": {
      "patch": {
        "operationId": "BreedingController_updateKittenDisposition",
        "summary": "å­çŒ«å‡¦é‡ã®æ›´æ–°",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateKittenDispositionDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Breeding"
        ]
      },
      "delete": {
        "operationId": "BreedingController_removeKittenDisposition",
        "summary": "å­çŒ«å‡¦é‡ã®å‰Šé™¤",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Breeding"
        ]
      }
    },
    "/api/v1/breeding/birth-plans/{id}/complete": {
      "post": {
        "operationId": "BreedingController_completeBirthRecord",
        "summary": "å‡ºç”£è¨˜éŒ²ã®å®Œäº†",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Breeding"
        ]
      }
    },
    "/api/v1/care/schedules": {
      "get": {
        "operationId": "CareController_findSchedules",
        "summary": "ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ä¸€è¦§ã®å–å¾—",
        "parameters": [
          {
            "name": "page",
            "required": false,
            "in": "query",
            "schema": {
              "example": 1,
              "type": "number"
            }
          },
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "schema": {
              "example": 20,
              "type": "number"
            }
          },
          {
            "name": "catId",
            "required": false,
            "in": "query",
            "description": "çŒ«ID",
            "schema": {
              "example": "e7b6a7a7-2d7f-4b2f-9f3a-1c2b3d4e5f60",
              "type": "string"
            }
          },
          {
            "name": "careType",
            "required": false,
            "in": "query",
            "description": "ã‚±ã‚¢ç¨®åˆ¥",
            "schema": {
              "example": "VACCINATION",
              "enum": [
                "VACCINATION",
                "HEALTH_CHECK",
                "GROOMING",
                "DENTAL_CARE",
                "MEDICATION",
                "SURGERY",
                "OTHER"
              ],
              "type": "string"
            }
          },
          {
            "name": "dateFrom",
            "required": false,
            "in": "query",
            "description": "é–‹å§‹æ—¥ (YYYY-MM-DD)",
            "schema": {
              "example": "2025-08-01",
              "type": "string"
            }
          },
          {
            "name": "dateTo",
            "required": false,
            "in": "query",
            "description": "çµ‚äº†æ—¥ (YYYY-MM-DD)",
            "schema": {
              "example": "2025-08-31",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CareScheduleListResponseDto"
                }
              }
            }
          }
        },
        "tags": [
          "Care"
        ]
      },
      "post": {
        "operationId": "CareController_addSchedule",
        "summary": "ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®è¿½åŠ ",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateCareScheduleDto"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CareScheduleResponseDto"
                }
              }
            }
          }
        },
        "tags": [
          "Care"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/care/schedules/{id}/complete": {
      "patch": {
        "operationId": "CareController_complete",
        "summary": "ã‚±ã‚¢å®Œäº†å‡¦ç†ï¼ˆPATCH/PUTå¯¾å¿œï¼‰",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CompleteCareDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CareCompleteResponseDto"
                }
              }
            }
          }
        },
        "tags": [
          "Care"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/care/schedules/{id}": {
      "patch": {
        "operationId": "CareController_updateSchedule",
        "summary": "ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æ›´æ–°",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "description": "ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateCareScheduleDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CareScheduleResponseDto"
                }
              }
            }
          }
        },
        "tags": [
          "Care"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "delete": {
        "operationId": "CareController_deleteSchedule",
        "summary": "ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å‰Šé™¤",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "description": "ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "å‰Šé™¤æˆåŠŸ"
          }
        },
        "tags": [
          "Care"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/care/medical-records": {
      "get": {
        "operationId": "CareController_findMedicalRecords",
        "summary": "åŒ»ç™‚è¨˜éŒ²ä¸€è¦§ã®å–å¾—",
        "parameters": [
          {
            "name": "page",
            "required": false,
            "in": "query",
            "schema": {
              "example": 1,
              "type": "number"
            }
          },
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "schema": {
              "example": 20,
              "type": "number"
            }
          },
          {
            "name": "catId",
            "required": false,
            "in": "query",
            "description": "çŒ«ID",
            "schema": {
              "example": "e7b6a7a7-2d7f-4b2f-9f3a-1c2b3d4e5f60",
              "type": "string"
            }
          },
          {
            "name": "scheduleId",
            "required": false,
            "in": "query",
            "description": "ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ID",
            "schema": {
              "example": "a6f7e52f-4a3b-4a76-9870-1234567890ab",
              "type": "string"
            }
          },
          {
            "name": "visitType",
            "required": false,
            "in": "query",
            "schema": {
              "example": "CHECKUP",
              "enum": [
                "CHECKUP",
                "EMERGENCY",
                "SURGERY",
                "FOLLOW_UP",
                "VACCINATION",
                "OTHER"
              ],
              "type": "string"
            }
          },
          {
            "name": "status",
            "required": false,
            "in": "query",
            "schema": {
              "example": "TREATING",
              "enum": [
                "TREATING",
                "COMPLETED"
              ],
              "type": "string"
            }
          },
          {
            "name": "dateFrom",
            "required": false,
            "in": "query",
            "description": "å—è¨ºé–‹å§‹æ—¥",
            "schema": {
              "example": "2025-08-01",
              "type": "string"
            }
          },
          {
            "name": "dateTo",
            "required": false,
            "in": "query",
            "description": "å—è¨ºçµ‚äº†æ—¥",
            "schema": {
              "example": "2025-08-31",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MedicalRecordListResponseDto"
                }
              }
            }
          }
        },
        "tags": [
          "Care"
        ]
      },
      "post": {
        "operationId": "CareController_addMedicalRecord",
        "summary": "åŒ»ç™‚è¨˜éŒ²ã®è¿½åŠ ",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateMedicalRecordDto"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MedicalRecordResponseDto"
                }
              }
            }
          }
        },
        "tags": [
          "Care"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/tags": {
      "get": {
        "operationId": "TagsController_findAll",
        "summary": "ã‚¿ã‚°ä¸€è¦§ã®å–å¾—",
        "parameters": [
          {
            "name": "includeInactive",
            "required": false,
            "in": "query",
            "description": "éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¿ã‚°ã‚’å«ã‚ã‚‹ã‹",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "scope",
            "required": false,
            "in": "query",
            "description": "å¯¾è±¡ã‚¹ã‚³ãƒ¼ãƒ—",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Tags"
        ]
      },
      "post": {
        "operationId": "TagsController_create",
        "summary": "ã‚¿ã‚°ã®ä½œæˆ",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateTagDto"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": ""
          }
        },
        "tags": [
          "Tags"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/tags/reorder": {
      "patch": {
        "operationId": "TagsController_reorder",
        "summary": "ã‚¿ã‚°ã®ä¸¦ã³æ›¿ãˆ",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ReorderTagsDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Tags"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/tags/{id}": {
      "patch": {
        "operationId": "TagsController_update",
        "summary": "ã‚¿ã‚°ã®æ›´æ–°",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateTagDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Tags"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "delete": {
        "operationId": "TagsController_remove",
        "summary": "ã‚¿ã‚°ã®å‰Šé™¤",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Tags"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/tags/cats/{id}/tags": {
      "post": {
        "operationId": "TagsController_assign",
        "summary": "çŒ«ã«ã‚¿ã‚°ã‚’ä»˜ä¸",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AssignTagDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "ä»˜ä¸æˆåŠŸï¼ˆé‡è¤‡æ™‚ã‚‚OKï¼‰"
          }
        },
        "tags": [
          "Tags"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/tags/cats/{id}/tags/{tagId}": {
      "delete": {
        "operationId": "TagsController_unassign",
        "summary": "çŒ«ã‹ã‚‰ã‚¿ã‚°ã‚’å‰¥å¥ª",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "tagId",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Tags"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/tags/categories": {
      "get": {
        "operationId": "TagCategoriesController_findAll",
        "summary": "ã‚¿ã‚°ã‚«ãƒ†ã‚´ãƒªä¸€è¦§ã®å–å¾—",
        "parameters": [
          {
            "name": "includeInactive",
            "required": false,
            "in": "query",
            "description": "éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ†ã‚´ãƒªã‚’å«ã‚ã‚‹",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "scope",
            "required": false,
            "in": "query",
            "description": "å¯¾è±¡ã‚¹ã‚³ãƒ¼ãƒ—",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Tags"
        ]
      },
      "post": {
        "operationId": "TagCategoriesController_create",
        "summary": "ã‚¿ã‚°ã‚«ãƒ†ã‚´ãƒªã®ä½œæˆ",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateTagCategoryDto"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": ""
          }
        },
        "tags": [
          "Tags"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/tags/categories/reorder": {
      "patch": {
        "operationId": "TagCategoriesController_reorder",
        "summary": "ã‚¿ã‚°ã‚«ãƒ†ã‚´ãƒªã®ä¸¦ã³æ›¿ãˆ",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ReorderTagCategoriesDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Tags"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/tags/categories/{id}": {
      "patch": {
        "operationId": "TagCategoriesController_update",
        "summary": "ã‚¿ã‚°ã‚«ãƒ†ã‚´ãƒªã®æ›´æ–°",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateTagCategoryDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Tags"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "delete": {
        "operationId": "TagCategoriesController_remove",
        "summary": "ã‚¿ã‚°ã‚«ãƒ†ã‚´ãƒªã®å‰Šé™¤",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": ""
          }
        },
        "tags": [
          "Tags"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/tags/groups": {
      "post": {
        "operationId": "TagGroupsController_create",
        "summary": "ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ã®ä½œæˆ",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateTagGroupDto"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": ""
          }
        },
        "tags": [
          "Tags"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/tags/groups/reorder": {
      "patch": {
        "operationId": "TagGroupsController_reorder",
        "summary": "ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ã®ä¸¦ã³æ›¿ãˆ",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ReorderTagGroupDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Tags"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/tags/groups/{id}": {
      "patch": {
        "operationId": "TagGroupsController_update",
        "summary": "ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ã®æ›´æ–°",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateTagGroupDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": ""
          }
        },
        "tags": [
          "Tags"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "delete": {
        "operationId": "TagGroupsController_remove",
        "summary": "ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ã®å‰Šé™¤",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": ""
          }
        },
        "tags": [
          "Tags"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/tags/automation/rules": {
      "get": {
        "operationId": "TagAutomationController_findRules",
        "summary": "è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ä¸€è¦§ã®å–å¾—",
        "parameters": [
          {
            "name": "active",
            "required": false,
            "in": "query",
            "description": "ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ«ãƒ¼ãƒ«ã®ã¿å–å¾—",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "scope",
            "required": false,
            "in": "query",
            "description": "ã‚¹ã‚³ãƒ¼ãƒ—ã§ãƒ•ã‚£ãƒ«ã‚¿",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "triggerType",
            "required": false,
            "in": "query",
            "description": "ãƒˆãƒªã‚¬ãƒ¼ã‚¿ã‚¤ãƒ—ã§ãƒ•ã‚£ãƒ«ã‚¿",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "eventType",
            "required": false,
            "in": "query",
            "description": "ã‚¤ãƒ™ãƒ³ãƒˆã‚¿ã‚¤ãƒ—ã§ãƒ•ã‚£ãƒ«ã‚¿",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "ãƒ«ãƒ¼ãƒ«ä¸€è¦§ã‚’è¿”å´"
          }
        },
        "tags": [
          "Tag Automation"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "post": {
        "operationId": "TagAutomationController_createRule",
        "summary": "è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ã®ä½œæˆ",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateTagAutomationRuleDto"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "ãƒ«ãƒ¼ãƒ«ã‚’ä½œæˆã—ã¾ã—ãŸ"
          },
          "400": {
            "description": "å…¥åŠ›ã‚¨ãƒ©ãƒ¼"
          }
        },
        "tags": [
          "Tag Automation"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/tags/automation/rules/{id}": {
      "get": {
        "operationId": "TagAutomationController_findRuleById",
        "summary": "è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«è©³ç´°ã®å–å¾—",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "description": "ãƒ«ãƒ¼ãƒ«ID",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "includeRuns",
            "required": false,
            "in": "query",
            "description": "å®Ÿè¡Œå±¥æ­´ã‚’å«ã‚ã‚‹",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "includeHistoryCount",
            "required": false,
            "in": "query",
            "description": "ä»˜ä¸å±¥æ­´ä»¶æ•°ã‚’å«ã‚ã‚‹",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "ãƒ«ãƒ¼ãƒ«è©³ç´°ã‚’è¿”å´"
          },
          "404": {
            "description": "ãƒ«ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
          }
        },
        "tags": [
          "Tag Automation"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "patch": {
        "operationId": "TagAutomationController_updateRule",
        "summary": "è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ã®æ›´æ–°",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "description": "ãƒ«ãƒ¼ãƒ«ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateTagAutomationRuleDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "ãƒ«ãƒ¼ãƒ«ã‚’æ›´æ–°ã—ã¾ã—ãŸ"
          },
          "404": {
            "description": "ãƒ«ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
          }
        },
        "tags": [
          "Tag Automation"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      },
      "delete": {
        "operationId": "TagAutomationController_deleteRule",
        "summary": "è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ã®å‰Šé™¤",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "description": "ãƒ«ãƒ¼ãƒ«ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "ãƒ«ãƒ¼ãƒ«ã‚’å‰Šé™¤ã—ã¾ã—ãŸ"
          },
          "404": {
            "description": "ãƒ«ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
          }
        },
        "tags": [
          "Tag Automation"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/tags/automation/runs": {
      "get": {
        "operationId": "TagAutomationController_findRuns",
        "summary": "ãƒ«ãƒ¼ãƒ«å®Ÿè¡Œå±¥æ­´ã®å–å¾—",
        "parameters": [
          {
            "name": "ruleId",
            "required": false,
            "in": "query",
            "description": "ãƒ«ãƒ¼ãƒ«IDã§ãƒ•ã‚£ãƒ«ã‚¿",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "status",
            "required": false,
            "in": "query",
            "description": "ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã§ãƒ•ã‚£ãƒ«ã‚¿ (PENDING, COMPLETED, FAILED)",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "description": "å–å¾—ä»¶æ•°ã®ä¸Šé™",
            "schema": {
              "type": "number"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "å®Ÿè¡Œå±¥æ­´ä¸€è¦§ã‚’è¿”å´"
          }
        },
        "tags": [
          "Tag Automation"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/tags/automation/rules/{id}/execute": {
      "post": {
        "operationId": "TagAutomationController_executeRule",
        "summary": "ãƒ«ãƒ¼ãƒ«ã‚’æ‰‹å‹•å®Ÿè¡Œï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "description": "ãƒ«ãƒ¼ãƒ«ID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "ãƒ«ãƒ¼ãƒ«å®Ÿè¡ŒæˆåŠŸ"
          }
        },
        "tags": [
          "Tag Automation"
        ],
        "security": [
          {
            "bearer": []
          }
        ]
      }
    },
    "/api/v1/health": {
      "get": {
        "operationId": "HealthController_check",
        "parameters": [],
        "responses": {
          "200": {
            "description": ""
          }
        }
      }
    },
    "/api/v1/staff": {
      "post": {
        "operationId": "StaffController_create",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateStaffDto"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": ""
          }
        }
      },
      "get": {
        "operationId": "StaffController_findAll",
        "parameters": [],
        "responses": {
          "200": {
            "description": ""
          }
        }
      }
    },
    "/api/v1/staff/{id}": {
      "get": {
        "operationId": "StaffController_findOne",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          }
        }
      },
      "patch": {
        "operationId": "StaffController_update",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateStaffDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": ""
          }
        }
      },
      "delete": {
        "operationId": "StaffController_remove",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          }
        }
      }
    },
    "/api/v1/staff/{id}/restore": {
      "patch": {
        "operationId": "StaffController_restore",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          }
        }
      }
    },
    "/api/v1/shifts": {
      "post": {
        "operationId": "ShiftController_create",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateShiftDto"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": ""
          }
        }
      },
      "get": {
        "operationId": "ShiftController_findAll",
        "parameters": [],
        "responses": {
          "200": {
            "description": ""
          }
        }
      }
    },
    "/api/v1/shifts/calendar": {
      "get": {
        "operationId": "ShiftController_getCalendarData",
        "parameters": [],
        "responses": {
          "200": {
            "description": ""
          }
        }
      }
    },
    "/api/v1/shifts/{id}": {
      "get": {
        "operationId": "ShiftController_findOne",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          }
        }
      },
      "patch": {
        "operationId": "ShiftController_update",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateShiftDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": ""
          }
        }
      },
      "delete": {
        "operationId": "ShiftController_remove",
        "parameters": [
          {
            "name": "id",
            "required": true,
            "in": "path",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": ""
          }
        }
      }
    }
  },
  "info": {
    "title": "Cat Management System API",
    "description": "API for managing cat breeding and care records",
    "version": "1.0",
    "contact": {}
  },
  "tags": [],
  "servers": [],
  "components": {
    "securitySchemes": {
      "bearer": {
        "scheme": "bearer",
        "bearerFormat": "JWT",
        "type": "http"
      }
    },
    "schemas": {
      "LoginDto": {
        "type": "object",
        "properties": {
          "email": {
            "type": "string",
            "description": "ãƒ­ã‚°ã‚¤ãƒ³ã«ä½¿ç”¨ã™ã‚‹ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹",
            "example": "user@example.com"
          },
          "password": {
            "type": "string",
            "description": "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ (8æ–‡å­—ä»¥ä¸Šæ¨å¥¨)",
            "example": "SecurePassword123!",
            "minLength": 6
          }
        },
        "required": [
          "email",
          "password"
        ]
      },
      "ChangePasswordDto": {
        "type": "object",
        "properties": {
          "currentPassword": {
            "type": "string",
            "description": "ç¾åœ¨ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰",
            "example": "oldPassword123!"
          },
          "newPassword": {
            "type": "string",
            "description": "æ–°ã—ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼ˆ8æ–‡å­—ä»¥ä¸Šã€å¤§æ–‡å­—ãƒ»å°æ–‡å­—ãƒ»æ•°å­—ãƒ»ç‰¹æ®Šæ–‡å­—ã‚’å«ã‚€ï¼‰",
            "example": "NewSecurePassword123!",
            "minLength": 8
          }
        },
        "required": [
          "currentPassword",
          "newPassword"
        ]
      },
      "RequestPasswordResetDto": {
        "type": "object",
        "properties": {
          "email": {
            "type": "string",
            "description": "ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹",
            "example": "user@example.com"
          }
        },
        "required": [
          "email"
        ]
      },
      "ResetPasswordDto": {
        "type": "object",
        "properties": {
          "token": {
            "type": "string",
            "description": "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆãƒˆãƒ¼ã‚¯ãƒ³",
            "example": "a1b2c3d4e5f6..."
          },
          "newPassword": {
            "type": "string",
            "description": "æ–°ã—ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰",
            "example": "NewSecurePassword123!"
          }
        },
        "required": [
          "token",
          "newPassword"
        ]
      },
      "RefreshTokenDto": {
        "type": "object",
        "properties": {
          "refreshToken": {
            "type": "string",
            "description": "ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ (Cookieåˆ©ç”¨æ™‚ã¯çœç•¥å¯)",
            "example": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
          }
        }
      },
      "CreateCatDto": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "çŒ«ã®åå‰",
            "example": "Alpha"
          },
          "gender": {
            "type": "string",
            "description": "æ€§åˆ¥",
            "enum": [
              "MALE",
              "FEMALE",
              "NEUTER",
              "SPAY"
            ],
            "example": "MALE"
          },
          "birthDate": {
            "type": "string",
            "description": "ç”Ÿå¹´æœˆæ—¥",
            "example": "2024-05-01"
          },
          "breedId": {
            "type": "string",
            "description": "å“ç¨®ID"
          },
          "coatColorId": {
            "type": "string",
            "description": "æ¯›è‰²ID"
          },
          "microchipNumber": {
            "type": "string",
            "description": "ãƒã‚¤ã‚¯ãƒ­ãƒãƒƒãƒ—ç•ªå·"
          },
          "registrationNumber": {
            "type": "string",
            "description": "ç™»éŒ²ç•ªå·"
          },
          "description": {
            "type": "string",
            "description": "èª¬æ˜ãƒ»å‚™è€ƒ"
          },
          "isInHouse": {
            "type": "boolean",
            "description": "æ–½è¨­å†…ã«åœ¨èˆã—ã¦ã„ã‚‹ã‹"
          },
          "fatherId": {
            "type": "string",
            "description": "çˆ¶çŒ«ã®ID"
          },
          "motherId": {
            "type": "string",
            "description": "æ¯çŒ«ã®ID"
          },
          "tagIds": {
            "description": "ã‚¿ã‚°IDé…åˆ—",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "name",
          "gender",
          "birthDate"
        ]
      },
      "UpdateCatDto": {
        "type": "object",
        "properties": {}
      },
      "CreatePedigreeDto": {
        "type": "object",
        "properties": {
          "pedigreeId": {
            "type": "string",
            "description": "è¡€çµ±æ›¸ç•ªå·",
            "example": "700545"
          },
          "title": {
            "type": "string",
            "description": "ã‚¿ã‚¤ãƒˆãƒ«",
            "example": "Champion"
          },
          "catName": {
            "type": "string",
            "description": "çŒ«ã®åå‰",
            "example": "Jolly Tokuichi"
          },
          "catName2": {
            "type": "string",
            "description": "ã‚­ãƒ£ãƒƒãƒ†ãƒªãƒ¼å",
            "example": "Jolly Tokuichi"
          },
          "breedCode": {
            "type": "number",
            "description": "å“ç¨®ã‚³ãƒ¼ãƒ‰",
            "example": 92
          },
          "genderCode": {
            "type": "number",
            "description": "æ€§åˆ¥ã‚³ãƒ¼ãƒ‰ (1: ã‚ªã‚¹, 2: ãƒ¡ã‚¹)",
            "example": 1
          },
          "eyeColor": {
            "type": "string",
            "description": "ç›®ã®è‰²",
            "example": "Gold"
          },
          "coatColorCode": {
            "type": "number",
            "description": "æ¯›è‰²ã‚³ãƒ¼ãƒ‰",
            "example": 190
          },
          "birthDate": {
            "type": "string",
            "description": "ç”Ÿå¹´æœˆæ—¥",
            "example": "2019-01-05"
          },
          "breederName": {
            "type": "string",
            "description": "ãƒ–ãƒªãƒ¼ãƒ€ãƒ¼å",
            "example": "Hayato Inami"
          },
          "ownerName": {
            "type": "string",
            "description": "ã‚ªãƒ¼ãƒŠãƒ¼å",
            "example": "Hayato Inami"
          },
          "registrationDate": {
            "type": "string",
            "description": "ç™»éŒ²å¹´æœˆæ—¥",
            "example": "2022-02-22"
          },
          "brotherCount": {
            "type": "number",
            "description": "å…„å¼Ÿã®äººæ•°",
            "example": 2
          },
          "sisterCount": {
            "type": "number",
            "description": "å§‰å¦¹ã®äººæ•°",
            "example": 2
          },
          "notes": {
            "type": "string",
            "description": "å‚™è€ƒ"
          },
          "notes2": {
            "type": "string",
            "description": "å‚™è€ƒï¼’"
          },
          "otherNo": {
            "type": "string",
            "description": "ä»–å›£ä½“No",
            "example": "921901-700545"
          },
          "fatherTitle": {
            "type": "string",
            "description": "çˆ¶è¦ªã‚¿ã‚¤ãƒˆãƒ«"
          },
          "fatherCatName": {
            "type": "string",
            "description": "çˆ¶è¦ªå"
          },
          "fatherCatName2": {
            "type": "string",
            "description": "çˆ¶è¦ªã‚­ãƒ£ãƒƒãƒ†ãƒªãƒ¼å"
          },
          "fatherCoatColor": {
            "type": "string",
            "description": "çˆ¶è¦ªæ¯›è‰²"
          },
          "fatherEyeColor": {
            "type": "string",
            "description": "çˆ¶è¦ªç›®ã®è‰²"
          },
          "fatherJCU": {
            "type": "string",
            "description": "çˆ¶è¦ªJCUç•ªå·"
          },
          "fatherOtherCode": {
            "type": "string",
            "description": "çˆ¶è¦ªä»–å›£ä½“ã‚³ãƒ¼ãƒ‰"
          },
          "motherTitle": {
            "type": "string",
            "description": "æ¯è¦ªã‚¿ã‚¤ãƒˆãƒ«"
          },
          "motherCatName": {
            "type": "string",
            "description": "æ¯è¦ªå"
          },
          "motherCatName2": {
            "type": "string",
            "description": "æ¯è¦ªã‚­ãƒ£ãƒƒãƒ†ãƒªãƒ¼å"
          },
          "motherCoatColor": {
            "type": "string",
            "description": "æ¯è¦ªæ¯›è‰²"
          },
          "motherEyeColor": {
            "type": "string",
            "description": "æ¯è¦ªç›®ã®è‰²"
          },
          "motherJCU": {
            "type": "string",
            "description": "æ¯è¦ªJCUç•ªå·"
          },
          "motherOtherCode": {
            "type": "string",
            "description": "æ¯è¦ªä»–å›£ä½“ã‚³ãƒ¼ãƒ‰"
          },
          "ffTitle": {
            "type": "string",
            "description": "çˆ¶æ–¹ç¥–çˆ¶ã‚¿ã‚¤ãƒˆãƒ«"
          },
          "ffCatName": {
            "type": "string",
            "description": "çˆ¶æ–¹ç¥–çˆ¶å"
          },
          "ffCatColor": {
            "type": "string",
            "description": "çˆ¶æ–¹ç¥–çˆ¶æ¯›è‰²"
          },
          "ffjcu": {
            "type": "string",
            "description": "çˆ¶æ–¹ç¥–çˆ¶JCU"
          },
          "fmTitle": {
            "type": "string",
            "description": "çˆ¶æ–¹ç¥–æ¯ã‚¿ã‚¤ãƒˆãƒ«"
          },
          "fmCatName": {
            "type": "string",
            "description": "çˆ¶æ–¹ç¥–æ¯å"
          },
          "fmCatColor": {
            "type": "string",
            "description": "çˆ¶æ–¹ç¥–æ¯æ¯›è‰²"
          },
          "fmjcu": {
            "type": "string",
            "description": "çˆ¶æ–¹ç¥–æ¯JCU"
          },
          "mfTitle": {
            "type": "string",
            "description": "æ¯æ–¹ç¥–çˆ¶ã‚¿ã‚¤ãƒˆãƒ«"
          },
          "mfCatName": {
            "type": "string",
            "description": "æ¯æ–¹ç¥–çˆ¶å"
          },
          "mfCatColor": {
            "type": "string",
            "description": "æ¯æ–¹ç¥–çˆ¶æ¯›è‰²"
          },
          "mfjcu": {
            "type": "string",
            "description": "æ¯æ–¹ç¥–çˆ¶JCU"
          },
          "mmTitle": {
            "type": "string",
            "description": "æ¯æ–¹ç¥–æ¯ã‚¿ã‚¤ãƒˆãƒ«"
          },
          "mmCatName": {
            "type": "string",
            "description": "æ¯æ–¹ç¥–æ¯å"
          },
          "mmCatColor": {
            "type": "string",
            "description": "æ¯æ–¹ç¥–æ¯æ¯›è‰²"
          },
          "mmjcu": {
            "type": "string",
            "description": "æ¯æ–¹ç¥–æ¯JCU"
          },
          "fffTitle": {
            "type": "string",
            "description": "çˆ¶çˆ¶çˆ¶ã‚¿ã‚¤ãƒˆãƒ«"
          },
          "fffCatName": {
            "type": "string",
            "description": "çˆ¶çˆ¶çˆ¶å"
          },
          "fffCatColor": {
            "type": "string",
            "description": "çˆ¶çˆ¶çˆ¶æ¯›è‰²"
          },
          "fffjcu": {
            "type": "string",
            "description": "çˆ¶çˆ¶çˆ¶JCU"
          },
          "ffmTitle": {
            "type": "string",
            "description": "çˆ¶çˆ¶æ¯ã‚¿ã‚¤ãƒˆãƒ«"
          },
          "ffmCatName": {
            "type": "string",
            "description": "çˆ¶çˆ¶æ¯å"
          },
          "ffmCatColor": {
            "type": "string",
            "description": "çˆ¶çˆ¶æ¯æ¯›è‰²"
          },
          "ffmjcu": {
            "type": "string",
            "description": "çˆ¶çˆ¶æ¯JCU"
          },
          "fmfTitle": {
            "type": "string",
            "description": "çˆ¶æ¯çˆ¶ã‚¿ã‚¤ãƒˆãƒ«"
          },
          "fmfCatName": {
            "type": "string",
            "description": "çˆ¶æ¯çˆ¶å"
          },
          "fmfCatColor": {
            "type": "string",
            "description": "çˆ¶æ¯çˆ¶æ¯›è‰²"
          },
          "fmfjcu": {
            "type": "string",
            "description": "çˆ¶æ¯çˆ¶JCU"
          },
          "fmmTitle": {
            "type": "string",
            "description": "çˆ¶æ¯æ¯ã‚¿ã‚¤ãƒˆãƒ«"
          },
          "fmmCatName": {
            "type": "string",
            "description": "çˆ¶æ¯æ¯å"
          },
          "fmmCatColor": {
            "type": "string",
            "description": "çˆ¶æ¯æ¯æ¯›è‰²"
          },
          "fmmjcu": {
            "type": "string",
            "description": "çˆ¶æ¯æ¯JCU"
          },
          "mffTitle": {
            "type": "string",
            "description": "æ¯çˆ¶çˆ¶ã‚¿ã‚¤ãƒˆãƒ«"
          },
          "mffCatName": {
            "type": "string",
            "description": "æ¯çˆ¶çˆ¶å"
          },
          "mffCatColor": {
            "type": "string",
            "description": "æ¯çˆ¶çˆ¶æ¯›è‰²"
          },
          "mffjcu": {
            "type": "string",
            "description": "æ¯çˆ¶çˆ¶JCU"
          },
          "mfmTitle": {
            "type": "string",
            "description": "æ¯çˆ¶æ¯ã‚¿ã‚¤ãƒˆãƒ«"
          },
          "mfmCatName": {
            "type": "string",
            "description": "æ¯çˆ¶æ¯å"
          },
          "mfmCatColor": {
            "type": "string",
            "description": "æ¯çˆ¶æ¯æ¯›è‰²"
          },
          "mfmjcu": {
            "type": "string",
            "description": "æ¯çˆ¶æ¯JCU"
          },
          "mmfTitle": {
            "type": "string",
            "description": "æ¯æ¯çˆ¶ã‚¿ã‚¤ãƒˆãƒ«"
          },
          "mmfCatName": {
            "type": "string",
            "description": "æ¯æ¯çˆ¶å"
          },
          "mmfCatColor": {
            "type": "string",
            "description": "æ¯æ¯çˆ¶æ¯›è‰²"
          },
          "mmfjcu": {
            "type": "string",
            "description": "æ¯æ¯çˆ¶JCU"
          },
          "mmmTitle": {
            "type": "string",
            "description": "æ¯æ¯æ¯ã‚¿ã‚¤ãƒˆãƒ«"
          },
          "mmmCatName": {
            "type": "string",
            "description": "æ¯æ¯æ¯å"
          },
          "mmmCatColor": {
            "type": "string",
            "description": "æ¯æ¯æ¯æ¯›è‰²"
          },
          "mmmjcu": {
            "type": "string",
            "description": "æ¯æ¯æ¯JCU"
          },
          "oldCode": {
            "type": "string",
            "description": "æ—§ã‚³ãƒ¼ãƒ‰"
          }
        },
        "required": [
          "pedigreeId"
        ]
      },
      "UpdatePedigreeDto": {
        "type": "object",
        "properties": {}
      },
      "CreateBreedDto": {
        "type": "object",
        "properties": {
          "code": {
            "type": "number",
            "description": "å“ç¨®ã‚³ãƒ¼ãƒ‰"
          },
          "name": {
            "type": "string",
            "description": "å“ç¨®å"
          },
          "description": {
            "type": "string",
            "description": "å“ç¨®ã®èª¬æ˜"
          }
        },
        "required": [
          "code",
          "name"
        ]
      },
      "UpdateBreedDto": {
        "type": "object",
        "properties": {}
      },
      "CreateCoatColorDto": {
        "type": "object",
        "properties": {
          "code": {
            "type": "number",
            "description": "æ¯›è‰²ã‚³ãƒ¼ãƒ‰"
          },
          "name": {
            "type": "string",
            "description": "æ¯›è‰²å"
          },
          "description": {
            "type": "string",
            "description": "æ¯›è‰²ã®èª¬æ˜"
          }
        },
        "required": [
          "code",
          "name"
        ]
      },
      "UpdateCoatColorDto": {
        "type": "object",
        "properties": {}
      },
      "CreateBreedingDto": {
        "type": "object",
        "properties": {
          "femaleId": {
            "type": "string",
            "description": "ãƒ¡ã‚¹çŒ«ã®ID",
            "example": "11111111-1111-1111-1111-111111111111"
          },
          "maleId": {
            "type": "string",
            "description": "ã‚ªã‚¹çŒ«ã®ID",
            "example": "22222222-2222-2222-2222-222222222222"
          },
          "breedingDate": {
            "type": "string",
            "description": "äº¤é…æ—¥",
            "example": "2025-08-01"
          },
          "expectedDueDate": {
            "type": "string",
            "description": "å‡ºç”£äºˆå®šæ—¥ (YYYY-MM-DD)",
            "example": "2025-10-01"
          },
          "notes": {
            "type": "string",
            "description": "ãƒ¡ãƒ¢",
            "example": "åˆå›ã®äº¤é…ã€‚"
          }
        },
        "required": [
          "femaleId",
          "maleId",
          "breedingDate"
        ]
      },
      "CreateBreedingNgRuleDto": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "ãƒ«ãƒ¼ãƒ«å",
            "example": "è¿‘è¦ªäº¤é…é˜²æ­¢"
          },
          "description": {
            "type": "string",
            "description": "èª¬æ˜",
            "example": "è¡€çµ±æ›¸ä»˜ãåŒå£«ã®äº¤é…ã‚’é¿ã‘ã‚‹"
          },
          "type": {
            "type": "string",
            "enum": [
              "TAG_COMBINATION",
              "INDIVIDUAL_PROHIBITION",
              "GENERATION_LIMIT"
            ],
            "example": "TAG_COMBINATION"
          },
          "active": {
            "type": "boolean",
            "description": "æœ‰åŠ¹ãƒ•ãƒ©ã‚°",
            "default": true
          },
          "maleConditions": {
            "description": "ã‚ªã‚¹å´ã®ã‚¿ã‚°æ¡ä»¶",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "femaleConditions": {
            "description": "ãƒ¡ã‚¹å´ã®ã‚¿ã‚°æ¡ä»¶",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "maleNames": {
            "description": "ç¦æ­¢ã™ã‚‹ã‚ªã‚¹çŒ«ã®åå‰",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "femaleNames": {
            "description": "ç¦æ­¢ã™ã‚‹ãƒ¡ã‚¹çŒ«ã®åå‰",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "generationLimit": {
            "type": "number",
            "description": "ä¸–ä»£åˆ¶é™ (è¦ªç­‰)",
            "minimum": 1
          }
        },
        "required": [
          "name",
          "type"
        ]
      },
      "UpdateBreedingNgRuleDto": {
        "type": "object",
        "properties": {}
      },
      "CreatePregnancyCheckDto": {
        "type": "object",
        "properties": {
          "motherId": {
            "type": "string",
            "description": "å¦Šå¨ ãƒã‚§ãƒƒã‚¯å¯¾è±¡ã®çŒ«ID"
          },
          "fatherId": {
            "type": "string",
            "description": "çˆ¶çŒ«ã®ID"
          },
          "matingDate": {
            "type": "string",
            "description": "äº¤é…æ—¥"
          },
          "checkDate": {
            "type": "string",
            "description": "å¦Šå¨ ãƒã‚§ãƒƒã‚¯æ—¥"
          },
          "status": {
            "type": "string",
            "description": "å¦Šå¨ çŠ¶æ…‹",
            "enum": [
              "CONFIRMED",
              "SUSPECTED",
              "NEGATIVE",
              "ABORTED"
            ]
          },
          "notes": {
            "type": "string",
            "description": "ãƒ¡ãƒ¢"
          }
        },
        "required": [
          "motherId",
          "checkDate",
          "status"
        ]
      },
      "UpdatePregnancyCheckDto": {
        "type": "object",
        "properties": {
          "fatherId": {
            "type": "string",
            "description": "çˆ¶çŒ«ã®ID"
          },
          "matingDate": {
            "type": "string",
            "description": "äº¤é…æ—¥"
          },
          "checkDate": {
            "type": "string",
            "description": "å¦Šå¨ ãƒã‚§ãƒƒã‚¯æ—¥"
          },
          "status": {
            "type": "string",
            "description": "å¦Šå¨ çŠ¶æ…‹",
            "enum": [
              "CONFIRMED",
              "SUSPECTED",
              "NEGATIVE",
              "ABORTED"
            ]
          },
          "notes": {
            "type": "string",
            "description": "ãƒ¡ãƒ¢"
          }
        }
      },
      "CreateBirthPlanDto": {
        "type": "object",
        "properties": {
          "motherId": {
            "type": "string",
            "description": "å‡ºç”£äºˆå®šã®æ¯è¦ªçŒ«ID"
          },
          "fatherId": {
            "type": "string",
            "description": "çˆ¶çŒ«ã®ID"
          },
          "matingDate": {
            "type": "string",
            "description": "äº¤é…æ—¥"
          },
          "expectedBirthDate": {
            "type": "string",
            "description": "å‡ºç”£äºˆå®šæ—¥"
          },
          "actualBirthDate": {
            "type": "string",
            "description": "å®Ÿéš›ã®å‡ºç”£æ—¥"
          },
          "status": {
            "type": "string",
            "description": "å‡ºç”£çŠ¶æ…‹",
            "enum": [
              "EXPECTED",
              "BORN",
              "ABORTED",
              "STILLBORN"
            ]
          },
          "expectedKittens": {
            "type": "number",
            "description": "äºˆæƒ³ã•ã‚Œã‚‹å­çŒ«ã®æ•°"
          },
          "actualKittens": {
            "type": "number",
            "description": "å®Ÿéš›ã®å­çŒ«ã®æ•°"
          },
          "notes": {
            "type": "string",
            "description": "ãƒ¡ãƒ¢"
          }
        },
        "required": [
          "motherId",
          "expectedBirthDate",
          "status"
        ]
      },
      "UpdateBirthPlanDto": {
        "type": "object",
        "properties": {
          "fatherId": {
            "type": "string",
            "description": "çˆ¶çŒ«ã®ID"
          },
          "matingDate": {
            "type": "string",
            "description": "äº¤é…æ—¥"
          },
          "expectedBirthDate": {
            "type": "string",
            "description": "å‡ºç”£äºˆå®šæ—¥"
          },
          "actualBirthDate": {
            "type": "string",
            "description": "å®Ÿéš›ã®å‡ºç”£æ—¥"
          },
          "status": {
            "type": "string",
            "description": "å‡ºç”£çŠ¶æ…‹",
            "enum": [
              "EXPECTED",
              "BORN",
              "ABORTED",
              "STILLBORN"
            ]
          },
          "expectedKittens": {
            "type": "number",
            "description": "äºˆæƒ³ã•ã‚Œã‚‹å­çŒ«ã®æ•°"
          },
          "actualKittens": {
            "type": "number",
            "description": "å®Ÿéš›ã®å­çŒ«ã®æ•°"
          },
          "notes": {
            "type": "string",
            "description": "ãƒ¡ãƒ¢"
          }
        }
      },
      "SaleInfoDto": {
        "type": "object",
        "properties": {
          "buyer": {
            "type": "string",
            "description": "è­²æ¸¡å…ˆï¼ˆå€‹äººå/æ¥­è€…åï¼‰"
          },
          "price": {
            "type": "number",
            "description": "è­²æ¸¡é‡‘é¡"
          },
          "saleDate": {
            "type": "string",
            "description": "è­²æ¸¡æ—¥"
          },
          "notes": {
            "type": "string",
            "description": "ãƒ¡ãƒ¢"
          }
        },
        "required": [
          "buyer",
          "price",
          "saleDate"
        ]
      },
      "CreateKittenDispositionDto": {
        "type": "object",
        "properties": {
          "birthRecordId": {
            "type": "string",
            "description": "å‡ºç”£è¨˜éŒ²ID"
          },
          "kittenId": {
            "type": "string",
            "description": "å­çŒ«IDï¼ˆé¤Šæˆã®å ´åˆã®ã¿ï¼‰"
          },
          "name": {
            "type": "string",
            "description": "å­çŒ«å"
          },
          "gender": {
            "type": "string",
            "description": "æ€§åˆ¥"
          },
          "disposition": {
            "type": "string",
            "description": "å‡¦é‡ã‚¿ã‚¤ãƒ—",
            "enum": [
              "TRAINING",
              "SALE",
              "DECEASED"
            ]
          },
          "trainingStartDate": {
            "type": "string",
            "description": "é¤Šæˆé–‹å§‹æ—¥ï¼ˆé¤Šæˆã®å ´åˆï¼‰"
          },
          "saleInfo": {
            "description": "è­²æ¸¡æƒ…å ±ï¼ˆå‡ºè·ã®å ´åˆï¼‰",
            "allOf": [
              {
                "$ref": "#/components/schemas/SaleInfoDto"
              }
            ]
          },
          "deathDate": {
            "type": "string",
            "description": "æ­»äº¡æ—¥ï¼ˆæ­»äº¡ã®å ´åˆï¼‰"
          },
          "deathReason": {
            "type": "string",
            "description": "æ­»äº¡ç†ç”±ï¼ˆæ­»äº¡ã®å ´åˆï¼‰"
          },
          "notes": {
            "type": "string",
            "description": "ãƒ¡ãƒ¢"
          }
        },
        "required": [
          "birthRecordId",
          "name",
          "gender",
          "disposition"
        ]
      },
      "UpdateKittenDispositionDto": {
        "type": "object",
        "properties": {
          "kittenId": {
            "type": "string",
            "description": "å­çŒ«IDï¼ˆé¤Šæˆã®å ´åˆã®ã¿ï¼‰"
          },
          "name": {
            "type": "string",
            "description": "å­çŒ«å"
          },
          "gender": {
            "type": "string",
            "description": "æ€§åˆ¥"
          },
          "disposition": {
            "type": "string",
            "description": "å‡¦é‡ã‚¿ã‚¤ãƒ—"
          },
          "trainingStartDate": {
            "type": "string",
            "description": "é¤Šæˆé–‹å§‹æ—¥ï¼ˆé¤Šæˆã®å ´åˆï¼‰"
          },
          "saleInfo": {
            "description": "è­²æ¸¡æƒ…å ±ï¼ˆå‡ºè·ã®å ´åˆï¼‰",
            "allOf": [
              {
                "$ref": "#/components/schemas/SaleInfoDto"
              }
            ]
          },
          "deathDate": {
            "type": "string",
            "description": "æ­»äº¡æ—¥ï¼ˆæ­»äº¡ã®å ´åˆï¼‰"
          },
          "deathReason": {
            "type": "string",
            "description": "æ­»äº¡ç†ç”±ï¼ˆæ­»äº¡ã®å ´åˆï¼‰"
          },
          "notes": {
            "type": "string",
            "description": "ãƒ¡ãƒ¢"
          }
        }
      },
      "CareScheduleCatDto": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "example": "e7b6a7a7-2d7f-4b2f-9f3a-1c2b3d4e5f60"
          },
          "name": {
            "type": "string",
            "example": "ãƒ¬ã‚ª"
          }
        },
        "required": [
          "id",
          "name"
        ]
      },
      "CareScheduleReminderDto": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "example": "f1e2d3c4-b5a6-7890-1234-56789abcdef0"
          },
          "timingType": {
            "type": "string",
            "enum": [
              "ABSOLUTE",
              "RELATIVE"
            ],
            "example": "ABSOLUTE"
          },
          "remindAt": {
            "type": "string",
            "example": "2025-08-01T09:00:00.000Z"
          },
          "offsetValue": {
            "type": "number",
            "example": 2
          },
          "offsetUnit": {
            "type": "string",
            "enum": [
              "MINUTE",
              "HOUR",
              "DAY",
              "WEEK",
              "MONTH"
            ],
            "example": "DAY"
          },
          "relativeTo": {
            "type": "string",
            "enum": [
              "START_DATE",
              "END_DATE",
              "CUSTOM_DATE"
            ],
            "example": "START_DATE"
          },
          "channel": {
            "type": "string",
            "enum": [
              "IN_APP",
              "EMAIL",
              "SMS",
              "PUSH"
            ],
            "example": "IN_APP"
          },
          "repeatFrequency": {
            "type": "string",
            "enum": [
              "NONE",
              "DAILY",
              "WEEKLY",
              "MONTHLY",
              "YEARLY",
              "CUSTOM"
            ],
            "example": "NONE"
          },
          "repeatInterval": {
            "type": "number",
            "example": 1
          },
          "repeatCount": {
            "type": "number",
            "example": 5
          },
          "repeatUntil": {
            "type": "string",
            "example": "2025-12-31T00:00:00.000Z"
          },
          "notes": {
            "type": "string",
            "example": "å‰æ—¥9æ™‚ã«é€šçŸ¥"
          },
          "isActive": {
            "type": "boolean",
            "example": true
          }
        },
        "required": [
          "id",
          "timingType",
          "channel",
          "isActive"
        ]
      },
      "CareScheduleTagDto": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "example": "a1b2c3d4-5678-90ab-cdef-1234567890ab"
          },
          "slug": {
            "type": "string",
            "example": "vaccination"
          },
          "label": {
            "type": "string",
            "example": "ãƒ¯ã‚¯ãƒãƒ³"
          },
          "level": {
            "type": "number",
            "example": 1
          },
          "parentId": {
            "type": "string",
            "example": "parent-tag-id"
          }
        },
        "required": [
          "id",
          "slug",
          "label",
          "level"
        ]
      },
      "CareScheduleItemDto": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "example": "a6f7e52f-4a3b-4a76-9870-1234567890ab"
          },
          "name": {
            "type": "string",
            "example": "å¹´æ¬¡å¥åº·è¨ºæ–­"
          },
          "title": {
            "type": "string",
            "example": "å¹´æ¬¡å¥åº·è¨ºæ–­"
          },
          "description": {
            "type": "string",
            "example": "æ¯å¹´ã®å®šæœŸå¥è¨º"
          },
          "scheduleDate": {
            "type": "string",
            "example": "2025-09-01T00:00:00.000Z"
          },
          "endDate": {
            "type": "string",
            "example": "2025-09-01T01:00:00.000Z"
          },
          "timezone": {
            "type": "string",
            "example": "Asia/Tokyo"
          },
          "scheduleType": {
            "type": "string",
            "enum": [
              "BREEDING",
              "CARE",
              "APPOINTMENT",
              "REMINDER",
              "MAINTENANCE"
            ],
            "example": "CARE"
          },
          "status": {
            "type": "string",
            "enum": [
              "PENDING",
              "IN_PROGRESS",
              "COMPLETED",
              "CANCELLED"
            ],
            "example": "PENDING"
          },
          "careType": {
            "type": "string",
            "enum": [
              "VACCINATION",
              "HEALTH_CHECK",
              "GROOMING",
              "DENTAL_CARE",
              "MEDICATION",
              "SURGERY",
              "OTHER"
            ],
            "example": "HEALTH_CHECK",
            "nullable": true
          },
          "priority": {
            "type": "string",
            "enum": [
              "LOW",
              "MEDIUM",
              "HIGH",
              "URGENT"
            ],
            "example": "MEDIUM"
          },
          "recurrenceRule": {
            "type": "string",
            "example": "FREQ=YEARLY;INTERVAL=1"
          },
          "assignedTo": {
            "type": "string",
            "example": "f3a2c1d7-1234-5678-90ab-cdef12345678"
          },
          "cat": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/CareScheduleCatDto"
              }
            ]
          },
          "cats": {
            "description": "å¯¾è±¡çŒ«ã®é…åˆ—",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CareScheduleCatDto"
            }
          },
          "reminders": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CareScheduleReminderDto"
            }
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CareScheduleTagDto"
            }
          },
          "createdAt": {
            "type": "string",
            "example": "2025-08-01T00:00:00.000Z"
          },
          "updatedAt": {
            "type": "string",
            "example": "2025-08-15T12:34:56.000Z"
          }
        },
        "required": [
          "id",
          "name",
          "title",
          "description",
          "scheduleDate",
          "scheduleType",
          "status",
          "careType",
          "priority",
          "assignedTo",
          "cat",
          "cats",
          "reminders",
          "tags",
          "createdAt",
          "updatedAt"
        ]
      },
      "CareScheduleMetaDto": {
        "type": "object",
        "properties": {
          "total": {
            "type": "number",
            "example": 42
          },
          "page": {
            "type": "number",
            "example": 1
          },
          "limit": {
            "type": "number",
            "example": 20
          },
          "totalPages": {
            "type": "number",
            "example": 3
          }
        },
        "required": [
          "total",
          "page",
          "limit",
          "totalPages"
        ]
      },
      "CareScheduleListResponseDto": {
        "type": "object",
        "properties": {
          "success": {
            "type": "boolean",
            "example": true
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CareScheduleItemDto"
            }
          },
          "meta": {
            "$ref": "#/components/schemas/CareScheduleMetaDto"
          }
        },
        "required": [
          "success",
          "data",
          "meta"
        ]
      },
      "ScheduleReminderDto": {
        "type": "object",
        "properties": {
          "timingType": {
            "type": "string",
            "enum": [
              "ABSOLUTE",
              "RELATIVE"
            ]
          },
          "remindAt": {
            "type": "string",
            "description": "æŒ‡å®šæ—¥æ™‚ (ISO8601)",
            "example": "2025-08-01T09:00:00.000Z"
          },
          "offsetValue": {
            "type": "number",
            "description": "ç›¸å¯¾ãƒªãƒã‚¤ãƒ³ãƒ‰ã®å€¤",
            "example": 2
          },
          "offsetUnit": {
            "type": "string",
            "enum": [
              "MINUTE",
              "HOUR",
              "DAY",
              "WEEK",
              "MONTH"
            ],
            "example": "DAY"
          },
          "relativeTo": {
            "type": "string",
            "enum": [
              "START_DATE",
              "END_DATE",
              "CUSTOM_DATE"
            ],
            "example": "START_DATE"
          },
          "channel": {
            "type": "string",
            "enum": [
              "IN_APP",
              "EMAIL",
              "SMS",
              "PUSH"
            ],
            "example": "IN_APP"
          },
          "repeatFrequency": {
            "type": "string",
            "enum": [
              "NONE",
              "DAILY",
              "WEEKLY",
              "MONTHLY",
              "YEARLY",
              "CUSTOM"
            ],
            "example": "NONE"
          },
          "repeatInterval": {
            "type": "number",
            "description": "ç¹°ã‚Šè¿”ã—é–“éš”",
            "example": 1
          },
          "repeatCount": {
            "type": "number",
            "description": "ç¹°ã‚Šè¿”ã—å›æ•°",
            "example": 5
          },
          "repeatUntil": {
            "type": "string",
            "description": "ç¹°ã‚Šè¿”ã—çµ‚äº†æ—¥æ™‚",
            "example": "2025-12-31T00:00:00.000Z"
          },
          "notes": {
            "type": "string",
            "description": "å‚™è€ƒ",
            "example": "å‰æ—¥9æ™‚ã«é€šçŸ¥"
          },
          "isActive": {
            "type": "boolean",
            "description": "æœ‰åŠ¹ãƒ•ãƒ©ã‚°",
            "example": true
          }
        },
        "required": [
          "timingType",
          "channel"
        ]
      },
      "CreateCareScheduleDto": {
        "type": "object",
        "properties": {
          "catIds": {
            "description": "å¯¾è±¡çŒ«IDã®é…åˆ—",
            "example": [
              "e7b6a7a7-2d7f-4b2f-9f3a-1c2b3d4e5f60"
            ],
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "name": {
            "type": "string",
            "description": "ã‚±ã‚¢å",
            "example": "å¹´æ¬¡å¥åº·è¨ºæ–­"
          },
          "careType": {
            "type": "string",
            "description": "ã‚±ã‚¢ç¨®åˆ¥",
            "enum": [
              "VACCINATION",
              "HEALTH_CHECK",
              "GROOMING",
              "DENTAL_CARE",
              "MEDICATION",
              "SURGERY",
              "OTHER"
            ],
            "example": "HEALTH_CHECK"
          },
          "scheduledDate": {
            "type": "string",
            "description": "äºˆå®šæ—¥ (ISO8601)",
            "example": "2025-09-01"
          },
          "endDate": {
            "type": "string",
            "description": "çµ‚äº†æ—¥æ™‚ (ISO8601)",
            "example": "2025-09-01T10:00:00.000Z"
          },
          "timezone": {
            "type": "string",
            "description": "ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³",
            "example": "Asia/Tokyo"
          },
          "description": {
            "type": "string",
            "description": "ã‚±ã‚¢å/è©³ç´°",
            "example": "å¥åº·è¨ºæ–­ (å¹´1å›)"
          },
          "priority": {
            "type": "string",
            "enum": [
              "LOW",
              "MEDIUM",
              "HIGH",
              "URGENT"
            ],
            "example": "MEDIUM"
          },
          "recurrenceRule": {
            "type": "string",
            "description": "RRULEå½¢å¼ãªã©ã®ç¹°ã‚Šè¿”ã—ãƒ«ãƒ¼ãƒ«",
            "example": "FREQ=YEARLY;INTERVAL=1"
          },
          "reminders": {
            "description": "ãƒªãƒã‚¤ãƒ³ãƒ€ãƒ¼è¨­å®š",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScheduleReminderDto"
            }
          },
          "careTagIds": {
            "description": "é–¢é€£ã‚±ã‚¢ã‚¿ã‚°ID (æœ€å¤§3éšå±¤)",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "catIds",
          "name",
          "careType",
          "scheduledDate"
        ]
      },
      "CareScheduleResponseDto": {
        "type": "object",
        "properties": {
          "success": {
            "type": "boolean",
            "example": true
          },
          "data": {
            "$ref": "#/components/schemas/CareScheduleItemDto"
          }
        },
        "required": [
          "success",
          "data"
        ]
      },
      "CompleteCareMedicalRecordDto": {
        "type": "object",
        "properties": {}
      },
      "CompleteCareDto": {
        "type": "object",
        "properties": {
          "completedDate": {
            "type": "string",
            "description": "å®Œäº†æ—¥ (YYYY-MM-DD)",
            "example": "2025-08-10"
          },
          "nextScheduledDate": {
            "type": "string",
            "description": "æ¬¡å›äºˆå®šæ—¥ (YYYY-MM-DD)",
            "example": "2026-08-10"
          },
          "notes": {
            "type": "string",
            "description": "ãƒ¡ãƒ¢",
            "example": "ä½“èª¿è‰¯å¥½ã€‚æ¬¡å›ã¯ãƒ¯ã‚¯ãƒãƒ³Aã€‚"
          },
          "medicalRecord": {
            "$ref": "#/components/schemas/CompleteCareMedicalRecordDto"
          }
        }
      },
      "CareCompleteResponseDto": {
        "type": "object",
        "properties": {
          "success": {
            "type": "boolean",
            "example": true
          },
          "data": {
            "type": "object",
            "example": {
              "scheduleId": "a6f7e52f-4a3b-4a76-9870-1234567890ab",
              "recordId": "bcdef123-4567-890a-bcde-f1234567890a",
              "medicalRecordId": "f1234567-89ab-cdef-0123-456789abcdef"
            }
          }
        },
        "required": [
          "success",
          "data"
        ]
      },
      "MedicalRecordSymptomDto": {
        "type": "object",
        "properties": {
          "label": {
            "type": "string",
            "example": "ãã—ã‚ƒã¿"
          },
          "note": {
            "type": "string",
            "example": "1é€±é–“ç¶™ç¶š"
          }
        },
        "required": [
          "label"
        ]
      },
      "MedicalRecordMedicationDto": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "example": "æŠ—ç”Ÿç‰©è³ª"
          },
          "dosage": {
            "type": "string",
            "example": "æœæ™©1éŒ "
          }
        },
        "required": [
          "name"
        ]
      },
      "MedicalRecordCatDto": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "example": "e7b6a7a7-2d7f-4b2f-9f3a-1c2b3d4e5f60"
          },
          "name": {
            "type": "string",
            "example": "ãƒŸã‚±"
          }
        },
        "required": [
          "id",
          "name"
        ]
      },
      "MedicalRecordScheduleDto": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "example": "a6f7e52f-4a3b-4a76-9870-1234567890ab"
          },
          "name": {
            "type": "string",
            "example": "ãƒ¯ã‚¯ãƒãƒ³æ¥ç¨®"
          }
        },
        "required": [
          "id",
          "name"
        ]
      },
      "MedicalRecordTagDto": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "example": "tag-123"
          },
          "slug": {
            "type": "string",
            "example": "vaccination"
          },
          "label": {
            "type": "string",
            "example": "ãƒ¯ã‚¯ãƒãƒ³"
          },
          "level": {
            "type": "number",
            "example": 1
          },
          "parentId": {
            "type": "string",
            "example": "parent-tag"
          }
        },
        "required": [
          "id",
          "slug",
          "label",
          "level"
        ]
      },
      "MedicalRecordAttachmentDto": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "example": "https://cdn.example.com/xray.png"
          },
          "description": {
            "type": "string",
            "example": "èƒ¸éƒ¨ãƒ¬ãƒ³ãƒˆã‚²ãƒ³"
          },
          "fileName": {
            "type": "string",
            "example": "xray.png"
          },
          "fileType": {
            "type": "string",
            "example": "image/png"
          },
          "fileSize": {
            "type": "number",
            "example": 204800
          },
          "capturedAt": {
            "type": "string",
            "example": "2025-08-10T09:30:00.000Z"
          }
        },
        "required": [
          "url"
        ]
      },
      "MedicalRecordItemDto": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "example": "bcdef123-4567-890a-bcde-f1234567890a"
          },
          "visitDate": {
            "type": "string",
            "example": "2025-08-10T00:00:00.000Z"
          },
          "visitType": {
            "type": "string",
            "enum": [
              "CHECKUP",
              "EMERGENCY",
              "SURGERY",
              "FOLLOW_UP",
              "VACCINATION",
              "OTHER"
            ],
            "example": "CHECKUP",
            "nullable": true
          },
          "hospitalName": {
            "type": "string",
            "example": "ã­ã“ã‚¯ãƒªãƒ‹ãƒƒã‚¯æ±äº¬"
          },
          "symptom": {
            "type": "string",
            "example": "ãã—ã‚ƒã¿ãŒæ­¢ã¾ã‚‰ãªã„"
          },
          "symptomDetails": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MedicalRecordSymptomDto"
            }
          },
          "diseaseName": {
            "type": "string",
            "example": "çŒ«é¢¨é‚ª"
          },
          "diagnosis": {
            "type": "string",
            "example": "çŒ«é¢¨é‚ªã®å…†å€™"
          },
          "treatmentPlan": {
            "type": "string",
            "example": "æŠ—ç”Ÿç‰©è³ªã‚’5æ—¥é–“æŠ•ä¸"
          },
          "medications": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MedicalRecordMedicationDto"
            }
          },
          "followUpDate": {
            "type": "string",
            "example": "2025-08-13T00:00:00.000Z"
          },
          "status": {
            "type": "string",
            "enum": [
              "TREATING",
              "COMPLETED"
            ],
            "example": "TREATING"
          },
          "notes": {
            "type": "string",
            "example": "é£Ÿæ¬²ã¯æˆ»ã£ã¦ããŸ"
          },
          "cat": {
            "$ref": "#/components/schemas/MedicalRecordCatDto"
          },
          "schedule": {
            "nullable": true,
            "allOf": [
              {
                "$ref": "#/components/schemas/MedicalRecordScheduleDto"
              }
            ]
          },
          "tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MedicalRecordTagDto"
            }
          },
          "attachments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MedicalRecordAttachmentDto"
            }
          },
          "recordedBy": {
            "type": "string",
            "example": "f3a2c1d7-1234-5678-90ab-cdef12345678"
          },
          "createdAt": {
            "type": "string",
            "example": "2025-08-10T09:30:00.000Z"
          },
          "updatedAt": {
            "type": "string",
            "example": "2025-08-15T12:34:56.000Z"
          }
        },
        "required": [
          "id",
          "visitDate",
          "visitType",
          "status",
          "cat",
          "tags",
          "attachments",
          "recordedBy",
          "createdAt",
          "updatedAt"
        ]
      },
      "MedicalRecordMetaDto": {
        "type": "object",
        "properties": {
          "total": {
            "type": "number",
            "example": 42
          },
          "page": {
            "type": "number",
            "example": 1
          },
          "limit": {
            "type": "number",
            "example": 20
          },
          "totalPages": {
            "type": "number",
            "example": 3
          }
        },
        "required": [
          "total",
          "page",
          "limit",
          "totalPages"
        ]
      },
      "MedicalRecordListResponseDto": {
        "type": "object",
        "properties": {
          "success": {
            "type": "boolean",
            "example": true
          },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MedicalRecordItemDto"
            }
          },
          "meta": {
            "$ref": "#/components/schemas/MedicalRecordMetaDto"
          }
        },
        "required": [
          "success",
          "data",
          "meta"
        ]
      },
      "MedicalRecordAttachmentInputDto": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "example": "https://cdn.example.com/xray.png"
          },
          "description": {
            "type": "string",
            "example": "èƒ¸éƒ¨ãƒ¬ãƒ³ãƒˆã‚²ãƒ³"
          },
          "fileName": {
            "type": "string",
            "example": "xray.png"
          },
          "fileType": {
            "type": "string",
            "example": "image/png"
          },
          "fileSize": {
            "type": "number",
            "example": 204800
          },
          "capturedAt": {
            "type": "string",
            "example": "2025-08-10T09:30:00.000Z"
          }
        },
        "required": [
          "url"
        ]
      },
      "CreateMedicalRecordDto": {
        "type": "object",
        "properties": {
          "catId": {
            "type": "string",
            "description": "çŒ«ID",
            "example": "e7b6a7a7-2d7f-4b2f-9f3a-1c2b3d4e5f60"
          },
          "scheduleId": {
            "type": "string",
            "description": "ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ID",
            "example": "a6f7e52f-4a3b-4a76-9870-1234567890ab"
          },
          "visitDate": {
            "type": "string",
            "description": "å—è¨ºæ—¥",
            "example": "2025-08-10"
          },
          "visitType": {
            "type": "string",
            "enum": [
              "CHECKUP",
              "EMERGENCY",
              "SURGERY",
              "FOLLOW_UP",
              "VACCINATION",
              "OTHER"
            ],
            "example": "CHECKUP"
          },
          "hospitalName": {
            "type": "string",
            "example": "ã­ã“ã‚¯ãƒªãƒ‹ãƒƒã‚¯æ±äº¬"
          },
          "symptom": {
            "type": "string",
            "example": "ãã—ã‚ƒã¿ãŒæ­¢ã¾ã‚‰ãªã„"
          },
          "symptomDetails": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MedicalRecordSymptomDto"
            }
          },
          "diseaseName": {
            "type": "string",
            "example": "çŒ«é¢¨é‚ª"
          },
          "diagnosis": {
            "type": "string",
            "example": "çŒ«é¢¨é‚ªã®å…†å€™"
          },
          "treatmentPlan": {
            "type": "string",
            "example": "æŠ—ç”Ÿç‰©è³ªã‚’5æ—¥é–“æŠ•ä¸"
          },
          "medications": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MedicalRecordMedicationDto"
            }
          },
          "followUpDate": {
            "type": "string",
            "example": "2025-08-13"
          },
          "status": {
            "type": "string",
            "example": "TREATING",
            "enum": [
              "TREATING",
              "COMPLETED"
            ],
            "default": "TREATING"
          },
          "notes": {
            "type": "string",
            "example": "é£Ÿæ¬²ã‚‚æˆ»ã‚Šã¤ã¤ã‚ã‚Š"
          },
          "careTagIds": {
            "description": "é–¢é€£ã‚±ã‚¢ã‚¿ã‚°ID",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "attachments": {
            "description": "æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ«",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MedicalRecordAttachmentInputDto"
            }
          }
        },
        "required": [
          "catId",
          "visitDate"
        ]
      },
      "MedicalRecordResponseDto": {
        "type": "object",
        "properties": {
          "success": {
            "type": "boolean",
            "example": true
          },
          "data": {
            "$ref": "#/components/schemas/MedicalRecordItemDto"
          }
        },
        "required": [
          "success",
          "data"
        ]
      },
      "CreateTagDto": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "ã‚¿ã‚°å",
            "example": "Indoor"
          },
          "groupId": {
            "type": "string",
            "description": "ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ID",
            "example": "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee"
          },
          "color": {
            "type": "string",
            "description": "ã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰",
            "example": "#3B82F6"
          },
          "textColor": {
            "type": "string",
            "description": "ãƒ†ã‚­ã‚¹ãƒˆã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰",
            "example": "#FFFFFF"
          },
          "description": {
            "type": "string",
            "description": "èª¬æ˜",
            "example": "å®¤å†…é£¼ã„ã‚¿ã‚°"
          },
          "allowsManual": {
            "type": "boolean",
            "description": "æ‰‹å‹•æ“ä½œã§åˆ©ç”¨å¯èƒ½ã‹",
            "example": true
          },
          "allowsAutomation": {
            "type": "boolean",
            "description": "è‡ªå‹•ãƒ«ãƒ¼ãƒ«ã§åˆ©ç”¨å¯èƒ½ã‹",
            "example": true
          },
          "displayOrder": {
            "type": "number",
            "description": "è¡¨ç¤ºé †",
            "example": 10
          },
          "metadata": {
            "type": "object",
            "description": "ä»»æ„ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿"
          },
          "isActive": {
            "type": "boolean",
            "description": "ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹",
            "example": true
          }
        },
        "required": [
          "name",
          "groupId"
        ]
      },
      "TagOrderItemDto": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "ã‚¿ã‚°ID",
            "format": "uuid"
          },
          "displayOrder": {
            "type": "number",
            "description": "è¡¨ç¤ºé †",
            "example": 12
          },
          "groupId": {
            "type": "string",
            "description": "æ‰€å±ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ID",
            "format": "uuid"
          }
        },
        "required": [
          "id",
          "displayOrder"
        ]
      },
      "ReorderTagsDto": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TagOrderItemDto"
            }
          }
        },
        "required": [
          "items"
        ]
      },
      "UpdateTagDto": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "ã‚¿ã‚°å",
            "example": "Indoor"
          },
          "groupId": {
            "type": "string",
            "description": "ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ID",
            "example": "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee"
          },
          "color": {
            "type": "string",
            "description": "ã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰",
            "example": "#3B82F6"
          },
          "textColor": {
            "type": "string",
            "description": "ãƒ†ã‚­ã‚¹ãƒˆã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰",
            "example": "#FFFFFF"
          },
          "description": {
            "type": "string",
            "description": "èª¬æ˜",
            "example": "å®¤å†…é£¼ã„ã‚¿ã‚°"
          },
          "allowsManual": {
            "type": "boolean",
            "description": "æ‰‹å‹•æ“ä½œã§åˆ©ç”¨å¯èƒ½ã‹",
            "example": true
          },
          "allowsAutomation": {
            "type": "boolean",
            "description": "è‡ªå‹•ãƒ«ãƒ¼ãƒ«ã§åˆ©ç”¨å¯èƒ½ã‹",
            "example": true
          },
          "displayOrder": {
            "type": "number",
            "description": "è¡¨ç¤ºé †",
            "example": 10
          },
          "metadata": {
            "type": "object",
            "description": "ä»»æ„ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿"
          },
          "isActive": {
            "type": "boolean",
            "description": "ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹",
            "example": true
          }
        }
      },
      "AssignTagDto": {
        "type": "object",
        "properties": {
          "tagId": {
            "type": "string",
            "description": "ã‚¿ã‚°ID",
            "example": "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee"
          }
        },
        "required": [
          "tagId"
        ]
      },
      "CreateTagCategoryDto": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "ãƒ¦ãƒ‹ãƒ¼ã‚¯ã‚­ãƒ¼ (æœªæŒ‡å®šæ™‚ã¯åå‰ã‹ã‚‰ç”Ÿæˆ)",
            "example": "cats_status"
          },
          "name": {
            "type": "string",
            "description": "ã‚«ãƒ†ã‚´ãƒªå",
            "example": "çŒ«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹"
          },
          "description": {
            "type": "string",
            "description": "ã‚«ãƒ†ã‚´ãƒªã®èª¬æ˜"
          },
          "color": {
            "type": "string",
            "description": "ã‚«ãƒ†ã‚´ãƒªã®ä»£è¡¨ã‚«ãƒ©ãƒ¼",
            "example": "#6366F1"
          },
          "textColor": {
            "type": "string",
            "description": "ã‚«ãƒ†ã‚´ãƒªã«ä½¿ç”¨ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆã‚«ãƒ©ãƒ¼",
            "example": "#111827"
          },
          "displayOrder": {
            "type": "number",
            "description": "è¡¨ç¤ºé †"
          },
          "scopes": {
            "description": "åˆ©ç”¨ã™ã‚‹ã‚¹ã‚³ãƒ¼ãƒ—ä¸€è¦§",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "isActive": {
            "type": "boolean",
            "description": "ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹",
            "example": true
          }
        },
        "required": [
          "name"
        ]
      },
      "TagCategoryOrderItemDto": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "ã‚«ãƒ†ã‚´ãƒªID",
            "format": "uuid"
          },
          "displayOrder": {
            "type": "number",
            "description": "è¡¨ç¤ºé †",
            "example": 10
          }
        },
        "required": [
          "id",
          "displayOrder"
        ]
      },
      "ReorderTagCategoriesDto": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TagCategoryOrderItemDto"
            }
          }
        },
        "required": [
          "items"
        ]
      },
      "UpdateTagCategoryDto": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "ãƒ¦ãƒ‹ãƒ¼ã‚¯ã‚­ãƒ¼ (æœªæŒ‡å®šæ™‚ã¯åå‰ã‹ã‚‰ç”Ÿæˆ)",
            "example": "cats_status"
          },
          "name": {
            "type": "string",
            "description": "ã‚«ãƒ†ã‚´ãƒªå",
            "example": "çŒ«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹"
          },
          "description": {
            "type": "string",
            "description": "ã‚«ãƒ†ã‚´ãƒªã®èª¬æ˜"
          },
          "color": {
            "type": "string",
            "description": "ã‚«ãƒ†ã‚´ãƒªã®ä»£è¡¨ã‚«ãƒ©ãƒ¼",
            "example": "#6366F1"
          },
          "textColor": {
            "type": "string",
            "description": "ã‚«ãƒ†ã‚´ãƒªã«ä½¿ç”¨ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆã‚«ãƒ©ãƒ¼",
            "example": "#111827"
          },
          "displayOrder": {
            "type": "number",
            "description": "è¡¨ç¤ºé †"
          },
          "scopes": {
            "description": "åˆ©ç”¨ã™ã‚‹ã‚¹ã‚³ãƒ¼ãƒ—ä¸€è¦§",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "isActive": {
            "type": "boolean",
            "description": "ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹",
            "example": true
          }
        }
      },
      "CreateTagGroupDto": {
        "type": "object",
        "properties": {
          "categoryId": {
            "type": "string",
            "description": "æ‰€å±ã‚«ãƒ†ã‚´ãƒªID",
            "example": "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee"
          },
          "name": {
            "type": "string",
            "description": "ã‚°ãƒ«ãƒ¼ãƒ—å",
            "example": "å±‹å†…ç®¡ç†"
          },
          "description": {
            "type": "string",
            "description": "ã‚°ãƒ«ãƒ¼ãƒ—ã®èª¬æ˜"
          },
          "displayOrder": {
            "type": "number",
            "description": "è¡¨ç¤ºé †",
            "example": 10
          },
          "isActive": {
            "type": "boolean",
            "description": "ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹",
            "example": true
          },
          "color": {
            "type": "string",
            "description": "ã‚°ãƒ«ãƒ¼ãƒ—è¡¨ç¤ºç”¨ã®ã‚«ãƒ©ãƒ¼",
            "example": "#3B82F6"
          },
          "textColor": {
            "type": "string",
            "description": "ã‚°ãƒ«ãƒ¼ãƒ—ã‚¿ã‚¤ãƒˆãƒ«ã®ãƒ†ã‚­ã‚¹ãƒˆã‚«ãƒ©ãƒ¼",
            "example": "#111827"
          }
        },
        "required": [
          "categoryId",
          "name"
        ]
      },
      "TagGroupOrderItemDto": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "ã‚°ãƒ«ãƒ¼ãƒ—ID",
            "format": "uuid"
          },
          "displayOrder": {
            "type": "number",
            "description": "è¡¨ç¤ºé †",
            "example": 10
          },
          "categoryId": {
            "type": "string",
            "description": "ç§»å‹•å…ˆã‚«ãƒ†ã‚´ãƒªID",
            "format": "uuid"
          }
        },
        "required": [
          "id",
          "displayOrder"
        ]
      },
      "ReorderTagGroupDto": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TagGroupOrderItemDto"
            }
          }
        },
        "required": [
          "items"
        ]
      },
      "UpdateTagGroupDto": {
        "type": "object",
        "properties": {
          "categoryId": {
            "type": "string",
            "description": "æ‰€å±ã‚«ãƒ†ã‚´ãƒªID",
            "example": "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee"
          },
          "name": {
            "type": "string",
            "description": "ã‚°ãƒ«ãƒ¼ãƒ—å",
            "example": "å±‹å†…ç®¡ç†"
          },
          "description": {
            "type": "string",
            "description": "ã‚°ãƒ«ãƒ¼ãƒ—ã®èª¬æ˜"
          },
          "displayOrder": {
            "type": "number",
            "description": "è¡¨ç¤ºé †",
            "example": 10
          },
          "isActive": {
            "type": "boolean",
            "description": "ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹",
            "example": true
          },
          "color": {
            "type": "string",
            "description": "ã‚°ãƒ«ãƒ¼ãƒ—è¡¨ç¤ºç”¨ã®ã‚«ãƒ©ãƒ¼",
            "example": "#3B82F6"
          },
          "textColor": {
            "type": "string",
            "description": "ã‚°ãƒ«ãƒ¼ãƒ—ã‚¿ã‚¤ãƒˆãƒ«ã®ãƒ†ã‚­ã‚¹ãƒˆã‚«ãƒ©ãƒ¼",
            "example": "#111827"
          }
        }
      },
      "CreateTagAutomationRuleDto": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "ãƒ«ãƒ¼ãƒ«ã®ä¸€æ„ãªã‚­ãƒ¼ï¼ˆè‡ªå‹•ç”Ÿæˆå¯èƒ½ï¼‰"
          },
          "name": {
            "type": "string",
            "description": "ãƒ«ãƒ¼ãƒ«å"
          },
          "description": {
            "type": "string",
            "description": "ãƒ«ãƒ¼ãƒ«ã®èª¬æ˜"
          },
          "triggerType": {
            "type": "string",
            "enum": [
              "EVENT",
              "SCHEDULE",
              "MANUAL"
            ],
            "description": "ãƒˆãƒªã‚¬ãƒ¼ã‚¿ã‚¤ãƒ—",
            "example": "EVENT"
          },
          "eventType": {
            "type": "string",
            "enum": [
              "BREEDING_PLANNED",
              "BREEDING_CONFIRMED",
              "PREGNANCY_CONFIRMED",
              "KITTEN_REGISTERED",
              "AGE_THRESHOLD",
              "PAGE_ACTION",
              "CUSTOM"
            ],
            "description": "ã‚¤ãƒ™ãƒ³ãƒˆã‚¿ã‚¤ãƒ—",
            "example": "BREEDING_PLANNED"
          },
          "scope": {
            "type": "string",
            "description": "é©ç”¨ç¯„å›²ï¼ˆã‚¹ã‚³ãƒ¼ãƒ—ï¼‰",
            "example": "breeding"
          },
          "isActive": {
            "type": "boolean",
            "description": "ãƒ«ãƒ¼ãƒ«ãŒæœ‰åŠ¹ã‹ã©ã†ã‹",
            "default": true
          },
          "priority": {
            "type": "number",
            "description": "å„ªå…ˆåº¦ï¼ˆ-100ã‹ã‚‰100ã€å¤§ãã„ã»ã©å„ªå…ˆï¼‰",
            "minimum": -100,
            "maximum": 100,
            "default": 0
          },
          "config": {
            "type": "object",
            "description": "ãƒ«ãƒ¼ãƒ«è¨­å®šï¼ˆJSONï¼‰",
            "example": {
              "tagIds": [
                "tag-id-1",
                "tag-id-2"
              ]
            }
          }
        },
        "required": [
          "name",
          "triggerType",
          "eventType"
        ]
      },
      "UpdateTagAutomationRuleDto": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "ãƒ«ãƒ¼ãƒ«ã®ä¸€æ„ãªã‚­ãƒ¼ï¼ˆè‡ªå‹•ç”Ÿæˆå¯èƒ½ï¼‰"
          },
          "name": {
            "type": "string",
            "description": "ãƒ«ãƒ¼ãƒ«å"
          },
          "description": {
            "type": "string",
            "description": "ãƒ«ãƒ¼ãƒ«ã®èª¬æ˜"
          },
          "triggerType": {
            "type": "string",
            "enum": [
              "EVENT",
              "SCHEDULE",
              "MANUAL"
            ],
            "description": "ãƒˆãƒªã‚¬ãƒ¼ã‚¿ã‚¤ãƒ—",
            "example": "EVENT"
          },
          "eventType": {
            "type": "string",
            "enum": [
              "BREEDING_PLANNED",
              "BREEDING_CONFIRMED",
              "PREGNANCY_CONFIRMED",
              "KITTEN_REGISTERED",
              "AGE_THRESHOLD",
              "PAGE_ACTION",
              "CUSTOM"
            ],
            "description": "ã‚¤ãƒ™ãƒ³ãƒˆã‚¿ã‚¤ãƒ—",
            "example": "BREEDING_PLANNED"
          },
          "scope": {
            "type": "string",
            "description": "é©ç”¨ç¯„å›²ï¼ˆã‚¹ã‚³ãƒ¼ãƒ—ï¼‰",
            "example": "breeding"
          },
          "isActive": {
            "type": "boolean",
            "description": "ãƒ«ãƒ¼ãƒ«ãŒæœ‰åŠ¹ã‹ã©ã†ã‹",
            "default": true
          },
          "priority": {
            "type": "number",
            "description": "å„ªå…ˆåº¦ï¼ˆ-100ã‹ã‚‰100ã€å¤§ãã„ã»ã©å„ªå…ˆï¼‰",
            "minimum": -100,
            "maximum": 100,
            "default": 0
          },
          "config": {
            "type": "object",
            "description": "ãƒ«ãƒ¼ãƒ«è¨­å®šï¼ˆJSONï¼‰",
            "example": {
              "tagIds": [
                "tag-id-1",
                "tag-id-2"
              ]
            }
          }
        }
      },
      "CreateStaffDto": {
        "type": "object",
        "properties": {}
      },
      "UpdateStaffDto": {
        "type": "object",
        "properties": {}
      },
      "CreateShiftDto": {
        "type": "object",
        "properties": {}
      },
      "UpdateShiftDto": {
        "type": "object",
        "properties": {}
      }
    }
  }
}
`````

## File: backend/SEED_USER_GUIDE.md
`````markdown
# ã‚·ãƒ¼ãƒ‰ãƒ¦ãƒ¼ã‚¶ãƒ¼ã§ã®ãƒ­ã‚°ã‚¤ãƒ³ç¢ºèªã‚¬ã‚¤ãƒ‰

## æ¦‚è¦

æœ¬ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯ã€é–‹ç™ºãƒ»æ¤œè¨¼ç’°å¢ƒã§å³åº§ã«ãƒ­ã‚°ã‚¤ãƒ³ãƒ†ã‚¹ãƒˆã‚’è¡Œãˆã‚‹ã‚ˆã†ã€ã‚·ãƒ¼ãƒ‰ã‚¹ã‚¯ãƒªãƒ—ãƒˆã§ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®Adminãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ä½œæˆã—ã¾ã™ã€‚

## ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚·ãƒ¼ãƒ‰ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±

### Adminãƒ¦ãƒ¼ã‚¶ãƒ¼ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰

- **Email**: `admin@example.com`
- **Password**: `Passw0rd!`
- **Role**: `ADMIN`
- **èª¬æ˜**: ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®ç®¡ç†æ¨©é™ã‚’æŒã¤ãƒ¦ãƒ¼ã‚¶ãƒ¼

## ã‚·ãƒ¼ãƒ‰ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ä½œæˆæ–¹æ³•

### 1. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®åˆæœŸåŒ–ã¨ã‚·ãƒ¼ãƒ‰å®Ÿè¡Œ

```bash
cd backend

# ç’°å¢ƒå¤‰æ•°ã‚’è¨­å®šï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ - ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä½¿ã†å ´åˆã¯ä¸è¦ï¼‰
# export ADMIN_EMAIL="admin@example.com"
# export ADMIN_PASSWORD="Passw0rd!"

# ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¨ã‚·ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œ
pnpm prisma:deploy
pnpm seed
```

### 2. ã‚·ãƒ¼ãƒ‰çµæœã®ç¢ºèª

ã‚·ãƒ¼ãƒ‰ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯å®Ÿè¡Œå¾Œã«ä»¥ä¸‹ã®ã‚ˆã†ãªå‡ºåŠ›ã‚’è¡¨ç¤ºã—ã¾ã™:

```
Seeding database...
â¡ï¸ Syncing breed master data...
âœ… Synced 100 breed records
â¡ï¸ Syncing coat color master data...
âœ… Synced 50 coat color records
â¡ï¸ Syncing gender master data...
âœ… Synced 3 gender records
Seed complete âœ…
Admin: { email: 'admin@example.com', password: 'Passw0rd!', id: '...', action: 'created' }
...
```

## ãƒ­ã‚°ã‚¤ãƒ³ç¢ºèªæ‰‹é †

### æ–¹æ³•1: E2Eãƒ†ã‚¹ãƒˆã§ç¢ºèª

```bash
cd backend
pnpm test:e2e
```

ç‰¹ã« `auth-seed-user.e2e-spec.ts` ãƒ†ã‚¹ãƒˆãŒã€ã‚·ãƒ¼ãƒ‰ãƒ¦ãƒ¼ã‚¶ãƒ¼ã§ã®ãƒ­ã‚°ã‚¤ãƒ³ã‚’ç¢ºèªã—ã¾ã™ã€‚

### æ–¹æ³•2: æ‰‹å‹•APIãƒªã‚¯ã‚¨ã‚¹ãƒˆã§ç¢ºèª

#### cURLã‚’ä½¿ç”¨:

```bash
# ãƒ­ã‚°ã‚¤ãƒ³ãƒªã‚¯ã‚¨ã‚¹ãƒˆï¼ˆCSRFãƒˆãƒ¼ã‚¯ãƒ³ä¸è¦ï¼‰
curl -X POST http://localhost:3004/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "admin@example.com",
    "password": "Passw0rd!"
  }'
```

æˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹ä¾‹:
```json
{
  "success": true,
  "data": {
    "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "user": {
      "userId": "...",
      "email": "admin@example.com",
      "role": "ADMIN",
      "firstName": "Admin",
      "lastName": "User"
    }
  }
}
```

#### ä¿è­·ã•ã‚ŒãŸã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹:

```bash
# ä¸Šè¨˜ã§å–å¾—ã—ãŸaccess_tokenã‚’ä½¿ç”¨
TOKEN="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."

curl -X GET http://localhost:3004/api/v1/cats \
  -H "Authorization: Bearer $TOKEN"
```

### æ–¹æ³•3: ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‹ã‚‰ç¢ºèª

1. ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’èµ·å‹•:
   ```bash
   cd frontend
   pnpm dev
   ```

2. ãƒ–ãƒ©ã‚¦ã‚¶ã§ http://localhost:3000 ã«ã‚¢ã‚¯ã‚»ã‚¹

3. ãƒ­ã‚°ã‚¤ãƒ³ç”»é¢ã§ä»¥ä¸‹ã®æƒ…å ±ã‚’å…¥åŠ›:
   - Email: `admin@example.com`
   - Password: `Passw0rd!`

4. ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸå¾Œã€ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã“ã¨ã‚’ç¢ºèª

## ã‚«ã‚¹ã‚¿ãƒ ã‚·ãƒ¼ãƒ‰ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ä½œæˆ

ç’°å¢ƒå¤‰æ•°ã‚’ä½¿ç”¨ã—ã¦ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä¸Šæ›¸ãã§ãã¾ã™:

```bash
# .env ãƒ•ã‚¡ã‚¤ãƒ«ã«è¿½åŠ ã€ã¾ãŸã¯ç’°å¢ƒå¤‰æ•°ã¨ã—ã¦è¨­å®š
ADMIN_EMAIL=custom@example.com
ADMIN_PASSWORD=CustomPass123!
ADMIN_FORCE_UPDATE=1  # æ—¢å­˜ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚‚å¼·åˆ¶æ›´æ–°

# ã‚·ãƒ¼ãƒ‰å®Ÿè¡Œ
pnpm seed
```

## æ³¨æ„äº‹é …

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

- **æœ¬ç•ªç’°å¢ƒã§ã¯å¿…ãšãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å¤‰æ›´ã—ã¦ãã ã•ã„**
- ã‚·ãƒ¼ãƒ‰ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯é–‹ç™ºãƒ»ãƒ†ã‚¹ãƒˆç’°å¢ƒå°‚ç”¨ã§ã™
- æœ¬ç•ªãƒ‡ãƒ—ãƒ­ã‚¤å‰ã«å¼·å›ºãªãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã«å¤‰æ›´ã—ã€ç’°å¢ƒå¤‰æ•°ã§ç®¡ç†ã—ã¦ãã ã•ã„

### CSRFæ’¤å»ã«ã¤ã„ã¦

**é‡è¦**: æœ¬ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã¯CSRFä¿è­·ã‚’å®Œå…¨ã«æ’¤å»ã—ã¾ã—ãŸã€‚

- `/api/v1/auth/login` ã‚„ `/api/v1/auth/register` ãªã©ã®èªè¨¼ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¯ã€CSRFãƒˆãƒ¼ã‚¯ãƒ³ãªã—ã§ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ã§ã™
- JWTèªè¨¼ãƒ™ãƒ¼ã‚¹ã®ãŸã‚ã€CSRFãƒˆãƒ¼ã‚¯ãƒ³ã®å–å¾—ã¯ä¸è¦ã§ã™
- ã™ã¹ã¦ã®APIãƒªã‚¯ã‚¨ã‚¹ãƒˆã¯ `Authorization: Bearer <token>` ãƒ˜ãƒƒãƒ€ãƒ¼ã§èªè¨¼ã—ã¾ã™

### ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

#### ãƒ­ã‚°ã‚¤ãƒ³ãŒ403ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹

- âœ… **è§£æ±ºæ¸ˆ**: CSRFé–¢é€£ã®403ã‚¨ãƒ©ãƒ¼ã¯æ’¤å»ã«ã‚ˆã‚Šè§£æ¶ˆã•ã‚Œã¾ã—ãŸ
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãŒæ­£ã—ãåˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ä»¥ä¸‹ã‚’å®Ÿè¡Œ:
  ```bash
  cd backend
  pnpm prisma:deploy
  pnpm seed
  ```

#### ãƒ­ã‚°ã‚¤ãƒ³ãŒ401ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹

- ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¾ãŸã¯ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒé–“é•ã£ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™
- ã‚·ãƒ¼ãƒ‰ãŒæ­£ã—ãå®Ÿè¡Œã•ã‚ŒãŸã‹ç¢ºèªã—ã¦ãã ã•ã„
- ç’°å¢ƒå¤‰æ•° `ADMIN_EMAIL` / `ADMIN_PASSWORD` ã®å€¤ã‚’ç¢ºèªã—ã¦ãã ã•ã„

#### JWTãƒˆãƒ¼ã‚¯ãƒ³ãŒç„¡åŠ¹

- ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ‰åŠ¹æœŸé™ãŒåˆ‡ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ15åˆ†ï¼‰
- `/api/v1/auth/refresh` ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã§æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—ã—ã¦ãã ã•ã„

## é–¢é€£ãƒ•ã‚¡ã‚¤ãƒ«

- ã‚·ãƒ¼ãƒ‰ã‚¹ã‚¯ãƒªãƒ—ãƒˆ: `backend/src/prisma/seed.ts`
- ã‚·ãƒ¼ãƒ‰ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ã‚°ã‚¤ãƒ³ãƒ†ã‚¹ãƒˆ: `backend/test/auth-seed-user.e2e-spec.ts`
- èªè¨¼ã‚µãƒ¼ãƒ“ã‚¹: `backend/src/auth/auth.service.ts`
- èªè¨¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼: `backend/src/auth/auth.controller.ts`
`````

## File: backend/tsconfig.build.json
`````json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src",
    "incremental": false,
    "tsBuildInfoFile": "./dist/tsconfig.build.tsbuildinfo"
  },
  "include": ["src/**/*"],
  "exclude": [
    "test",
    "src/**/*.spec.ts",
    "src/**/*.test.ts",
    "src/**/*.e2e-spec.ts",
    "src/scripts/**"
  ]
}
`````

## File: backend/tsconfig.eslint.json
`````json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "noEmit": true
  },
  "include": [
    "src/**/*",
    "test/**/*",
    "src/scripts/**/*"
  ],
  "exclude": [
    "node_modules",
    "dist"
  ]
}
`````

## File: backend/tsconfig.json
`````json
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "incremental": true,
    "tsBuildInfoFile": "../../.tmp/backend.tsbuildinfo",
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2020",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "skipLibCheck": true,
    "strictNullChecks": true,
    "noImplicitAny": true,
    "strictBindCallApply": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "types": ["node", "jest"]
  },
  "include": ["src/**/*", "test/**/*"],
  "exclude": [
    "node_modules",
    "dist",
    "src/scripts/csv-preview.ts",
    "src/scripts/selective-csv-import.ts",
    "src/scripts/check-*.ts",
    "src/scripts/build-*.ts",
    "src/scripts/rename-*.ts",
    "**/*.bak.ts"
  ],
  "watchOptions": {
    "watchFile": "useFsEvents",
    "watchDirectory": "useFsEvents"
  }
}
`````

## File: database/init/01-init.sh
`````bash
#!/bin/bash
set -e

echo "ğŸ”„ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆæœŸåŒ–ã‚’é–‹å§‹..."

# UUIDã‚¨ã‚¯ã‚¹ãƒ†ãƒ³ã‚·ãƒ§ãƒ³ã‚’æœ‰åŠ¹åŒ–
psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" <<-EOSQL
    -- Enable UUID extension
    CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
    
    -- Enable pg_trgm for text search
    CREATE EXTENSION IF NOT EXISTS pg_trgm;
EOSQL

echo "âœ… æ‹¡å¼µæ©Ÿèƒ½ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å®Œäº†"

# ã‚·ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Œã°å®Ÿè¡Œ
if [ -f /docker-entrypoint-initdb.d/seed-cats-data.sql ]; then
    echo "ğŸŒ± ã‚·ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­..."
    psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" < /docker-entrypoint-initdb.d/seed-cats-data.sql
    echo "âœ… ã‚·ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿å®Œäº†"
fi

# ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½œæˆ
psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" <<-EOSQL
    -- Create indexes for better performance (if tables exist)
    DO \$\$
    BEGIN
        IF EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'cats') THEN
            CREATE INDEX IF NOT EXISTS idx_cats_owner_id ON cats("ownerId");
            CREATE INDEX IF NOT EXISTS idx_cats_is_in_house ON cats("isInHouse");
            CREATE INDEX IF NOT EXISTS idx_cats_registration_number ON cats("registrationNumber");
            CREATE INDEX IF NOT EXISTS idx_cats_mother_id ON cats("motherId");
            CREATE INDEX IF NOT EXISTS idx_cats_father_id ON cats("fatherId");
            CREATE INDEX IF NOT EXISTS idx_cats_birth_date ON cats("birthDate");
        END IF;

        IF EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'breeding_records') THEN
            CREATE INDEX IF NOT EXISTS idx_breeding_records_male_id ON breeding_records("maleId");
            CREATE INDEX IF NOT EXISTS idx_breeding_records_female_id ON breeding_records("femaleId");
            CREATE INDEX IF NOT EXISTS idx_breeding_records_date ON breeding_records("breedingDate");
        END IF;

        IF EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'birth_plans') THEN
            CREATE INDEX IF NOT EXISTS idx_birth_plans_mother_id ON birth_plans("motherId");
            CREATE INDEX IF NOT EXISTS idx_birth_plans_father_id ON birth_plans("fatherId");
            CREATE INDEX IF NOT EXISTS idx_birth_plans_status ON birth_plans(status);
            CREATE INDEX IF NOT EXISTS idx_birth_plans_expected_date ON birth_plans("expectedBirthDate");
        END IF;

        IF EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'care_records') THEN
            CREATE INDEX IF NOT EXISTS idx_care_records_cat_id ON care_records("catId");
            CREATE INDEX IF NOT EXISTS idx_care_records_care_date ON care_records("careDate");
            CREATE INDEX IF NOT EXISTS idx_care_records_type ON care_records("careType");
        END IF;

        IF EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'schedules') THEN
            CREATE INDEX IF NOT EXISTS idx_schedules_assigned_to ON schedules("assignedTo");
            CREATE INDEX IF NOT EXISTS idx_schedules_cat_id ON schedules("catId");
            CREATE INDEX IF NOT EXISTS idx_schedules_schedule_date ON schedules("scheduleDate");
        END IF;

        IF EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'pedigrees') THEN
            CREATE INDEX IF NOT EXISTS idx_pedigrees_cat_id ON pedigrees("catId");
            CREATE INDEX IF NOT EXISTS idx_pedigrees_call_name ON pedigrees("callName");
        END IF;
    END
    \$\$;
EOSQL

echo "âœ… ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ä½œæˆå®Œäº†"
echo "ğŸ‰ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆæœŸåŒ–ãŒå®Œäº†ã—ã¾ã—ãŸ"
`````

## File: database/init/02-seed-cats.sql
`````sql
-- åœ¨èˆçŒ«ãƒ‡ãƒ¼ã‚¿ã®ã‚·ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ (è‡ªå‹•ç”Ÿæˆ: 2025-11-05T15:08:56.680Z)
-- ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ç¾åœ¨ã®åœ¨èˆçŒ«ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ç”Ÿæˆã•ã‚Œã¾ã—ãŸ

-- åœ¨èˆçŒ«ãƒ‡ãƒ¼ã‚¿
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('98396d6f-6794-44ed-99e4-c1324f0879bc', 'Adam', 'MALE', '2023-12-21T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, NULL, NULL, '2025-11-02T14:28:51.541Z', '2025-11-02T14:28:51.541Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('303051fc-926d-402d-a8b2-6e5238618d36', 'Amila', 'FEMALE', '2025-02-02T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, NULL, NULL, '2025-11-02T14:31:59.569Z', '2025-11-02T14:31:59.569Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('92e6770b-a9da-49d9-89ed-044a0ceb443a', 'Bibi', 'FEMALE', '2023-04-05T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, NULL, NULL, '2025-11-02T14:32:22.985Z', '2025-11-02T14:32:22.985Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('ffbd187c-e71e-49f7-b004-23939cf94754', 'Bibi1å·', 'MALE', '2025-11-05T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, 'ca75f2c0-a275-45a6-83b4-71ff06c8ee3b', '92e6770b-a9da-49d9-89ed-044a0ceb443a', '2025-11-05T14:33:38.070Z', '2025-11-05T14:33:38.070Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('8145680e-54c8-472b-a5ce-2d38854f660b', 'Bibi2å·', 'MALE', '2025-11-05T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, 'ca75f2c0-a275-45a6-83b4-71ff06c8ee3b', '92e6770b-a9da-49d9-89ed-044a0ceb443a', '2025-11-05T14:33:38.075Z', '2025-11-05T14:33:38.075Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('1a82b59e-22c7-42b5-bc0b-97d9a8c9cb79', 'Bibi3å·', 'MALE', '2025-11-05T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, 'ca75f2c0-a275-45a6-83b4-71ff06c8ee3b', '92e6770b-a9da-49d9-89ed-044a0ceb443a', '2025-11-05T14:33:38.086Z', '2025-11-05T14:33:38.086Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('b24a7ccd-b6a9-4814-9b45-1313cb751e09', 'Bibi4å·', 'MALE', '2025-11-05T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, 'ca75f2c0-a275-45a6-83b4-71ff06c8ee3b', '92e6770b-a9da-49d9-89ed-044a0ceb443a', '2025-11-05T14:33:38.100Z', '2025-11-05T14:33:38.100Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('079f903d-de2a-449c-ab82-d1d384c83515', 'Bibi5å·', 'MALE', '2025-11-05T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, 'ca75f2c0-a275-45a6-83b4-71ff06c8ee3b', '92e6770b-a9da-49d9-89ed-044a0ceb443a', '2025-11-05T14:33:38.104Z', '2025-11-05T14:33:38.104Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('66ae0dae-6bcb-46de-831f-d832313dfb00', 'Boss', 'MALE', '2024-03-16T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, NULL, NULL, '2025-11-02T14:29:25.203Z', '2025-11-02T14:29:25.203Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('a4116bbd-3c6f-4ac9-8200-e2fcd6f99b50', 'Calan', 'MALE', '2023-12-21T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, NULL, NULL, '2025-11-02T14:29:59.939Z', '2025-11-02T14:29:59.939Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('8d65be6d-f98d-4ea6-aaa3-59b0e652ed68', 'Calina', 'FEMALE', '2023-04-05T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, NULL, NULL, '2025-11-02T14:32:51.503Z', '2025-11-02T14:32:51.503Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('ad4f5424-e3a5-4c06-a824-c986acbd4444', 'Demi', 'FEMALE', '2022-02-02T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, NULL, NULL, '2025-11-02T14:33:15.983Z', '2025-11-02T14:33:15.983Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('b6952040-8d0f-49b4-961a-7a9233380ad4', 'Desiya', 'MALE', '2024-03-16T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, NULL, NULL, '2025-11-02T14:30:25.400Z', '2025-11-02T14:30:25.400Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('ca75f2c0-a275-45a6-83b4-71ff06c8ee3b', 'Evan', 'MALE', '2023-04-05T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, NULL, NULL, '2025-11-02T14:30:55.115Z', '2025-11-02T14:30:55.115Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('101bd144-3731-43fe-94cb-c2a221d6d72e', 'Eve', 'FEMALE', '2024-03-16T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, NULL, NULL, '2025-11-02T14:33:42.125Z', '2025-11-02T14:33:42.125Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('e3298f9e-efd0-4f06-a0f8-fab1774e1540', 'Eve1å·', 'MALE', '2025-11-05T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, 'a4116bbd-3c6f-4ac9-8200-e2fcd6f99b50', '101bd144-3731-43fe-94cb-c2a221d6d72e', '2025-11-05T14:22:04.598Z', '2025-11-05T14:22:04.598Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('494f0444-5703-4b9e-830b-02f92bcde780', 'Eve1å·', 'MALE', '2025-11-05T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, 'a4116bbd-3c6f-4ac9-8200-e2fcd6f99b50', '101bd144-3731-43fe-94cb-c2a221d6d72e', '2025-11-05T14:39:37.575Z', '2025-11-05T14:39:37.575Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('9682f4a9-8615-4827-8588-f2d7ff6c9a0f', 'Eve1å·', 'MALE', '2025-11-05T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, 'a4116bbd-3c6f-4ac9-8200-e2fcd6f99b50', '101bd144-3731-43fe-94cb-c2a221d6d72e', '2025-11-05T14:38:05.186Z', '2025-11-05T14:38:05.186Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('589b3b8f-5391-43eb-afff-fe79614dc242', 'Eve2å·', 'MALE', '2025-11-05T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, 'a4116bbd-3c6f-4ac9-8200-e2fcd6f99b50', '101bd144-3731-43fe-94cb-c2a221d6d72e', '2025-11-05T14:22:04.594Z', '2025-11-05T14:22:04.594Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('3a4465ff-cf50-4bf4-96db-365c96bc39e1', 'Eve2å·', 'MALE', '2025-11-05T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, 'a4116bbd-3c6f-4ac9-8200-e2fcd6f99b50', '101bd144-3731-43fe-94cb-c2a221d6d72e', '2025-11-05T14:39:37.581Z', '2025-11-05T14:39:37.581Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('e3439fcf-b88e-4c8f-ab1d-cbafe179a0dc', 'Eve2å·', 'MALE', '2025-11-05T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, 'a4116bbd-3c6f-4ac9-8200-e2fcd6f99b50', '101bd144-3731-43fe-94cb-c2a221d6d72e', '2025-11-05T14:38:05.206Z', '2025-11-05T14:38:05.206Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('9dff2299-9ee8-4f28-a3a7-e898486298ce', 'Eve3å·', 'MALE', '2025-11-05T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, 'a4116bbd-3c6f-4ac9-8200-e2fcd6f99b50', '101bd144-3731-43fe-94cb-c2a221d6d72e', '2025-11-05T14:22:04.609Z', '2025-11-05T14:22:04.609Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('103f331a-27bd-4ac1-9854-c041614ae71d', 'Eve3å·', 'MALE', '2025-11-05T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, 'a4116bbd-3c6f-4ac9-8200-e2fcd6f99b50', '101bd144-3731-43fe-94cb-c2a221d6d72e', '2025-11-05T14:39:37.587Z', '2025-11-05T14:39:37.587Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('f4090a80-f5bf-454f-82b3-34f208c26df2', 'Eve3å·', 'MALE', '2025-11-05T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, 'a4116bbd-3c6f-4ac9-8200-e2fcd6f99b50', '101bd144-3731-43fe-94cb-c2a221d6d72e', '2025-11-05T14:38:05.215Z', '2025-11-05T14:38:05.215Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('638fcf75-b623-4972-9d2f-ea7839169331', 'Eve4å·', 'MALE', '2025-11-05T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, 'a4116bbd-3c6f-4ac9-8200-e2fcd6f99b50', '101bd144-3731-43fe-94cb-c2a221d6d72e', '2025-11-05T14:38:05.222Z', '2025-11-05T14:38:05.222Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('17e5d954-7855-4c76-adf5-01af1c72179e', 'Eve4å·', 'MALE', '2025-11-05T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, 'a4116bbd-3c6f-4ac9-8200-e2fcd6f99b50', '101bd144-3731-43fe-94cb-c2a221d6d72e', '2025-11-05T14:39:37.602Z', '2025-11-05T14:39:37.602Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('889d3545-4c8e-4912-a344-9c8be8f77170', 'Eve4å·', 'MALE', '2025-11-05T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, 'a4116bbd-3c6f-4ac9-8200-e2fcd6f99b50', '101bd144-3731-43fe-94cb-c2a221d6d72e', '2025-11-05T14:22:04.621Z', '2025-11-05T14:22:04.621Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('c7996ec7-9fee-4933-93f4-dae38e6ffe9f', 'Eve5å·', 'MALE', '2025-11-05T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, 'a4116bbd-3c6f-4ac9-8200-e2fcd6f99b50', '101bd144-3731-43fe-94cb-c2a221d6d72e', '2025-11-05T14:39:37.611Z', '2025-11-05T14:39:37.611Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('522f8648-2849-430a-84be-75e1e58e7f72', 'Eve5å·', 'MALE', '2025-11-05T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, 'a4116bbd-3c6f-4ac9-8200-e2fcd6f99b50', '101bd144-3731-43fe-94cb-c2a221d6d72e', '2025-11-05T14:22:04.629Z', '2025-11-05T14:22:04.629Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('53c52876-39f8-41d4-92b5-e64f77dcd656', 'Eve5å·', 'MALE', '2025-11-05T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, 'a4116bbd-3c6f-4ac9-8200-e2fcd6f99b50', '101bd144-3731-43fe-94cb-c2a221d6d72e', '2025-11-05T14:38:05.250Z', '2025-11-05T14:38:05.250Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('5b543c94-b7a1-4f62-bb53-b01a11c02e93', 'Famy', 'FEMALE', '2024-03-16T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, NULL, NULL, '2025-11-02T14:34:15.015Z', '2025-11-02T14:34:15.015Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('f0a1e04c-222b-417f-bc24-c96705b9308a', 'Faran', 'MALE', '2023-04-05T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, NULL, NULL, '2025-11-02T14:31:28.906Z', '2025-11-02T14:31:28.906Z') ON CONFLICT (id) DO NOTHING;
INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", "microchipNumber", "registrationNumber", "description", "isInHouse", "fatherId", "motherId", "createdAt", "updatedAt") VALUES ('d35c3e43-dcc6-4cc1-bcc2-238ee67dae8f', 'Matt', 'MALE', '2024-03-16T00:00:00.000Z', NULL, NULL, NULL, NULL, NULL, true, NULL, NULL, '2025-11-02T14:18:37.743Z', '2025-11-02T14:18:37.743Z') ON CONFLICT (id) DO NOTHING;
`````

## File: docs/deployment/CUSTOM_DOMAIN_SETUP.md
`````markdown
# ã‚«ã‚¹ã‚¿ãƒ ãƒ‰ãƒ¡ã‚¤ãƒ³è¨­å®šã‚¬ã‚¤ãƒ‰ (nekoya.co.jp)

ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ã€GCPä¸Šã®Cloud Runã‚µãƒ¼ãƒ“ã‚¹ã«ã‚«ã‚¹ã‚¿ãƒ ãƒ‰ãƒ¡ã‚¤ãƒ³ `nekoya.co.jp` ã‚’è¨­å®šã™ã‚‹æ‰‹é †ã‚’èª¬æ˜ã—ã¾ã™ã€‚

## å‰ææ¡ä»¶

- âœ… ãƒ‰ãƒ¡ã‚¤ãƒ³ `nekoya.co.jp` ã‚’ãŠåå‰.comã§å–å¾—æ¸ˆã¿
- âœ… GCPãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ `my-cats-pro` ãŒç¨¼åƒä¸­
- âœ… Cloud Runã‚µãƒ¼ãƒ“ã‚¹ (backend/frontend) ãŒãƒ‡ãƒ—ãƒ­ã‚¤æ¸ˆã¿

## ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

```
[ãŠåå‰.com DNS] â†’ [Google Load Balancer] â†’ [Cloud Run Services]
                         â†“
                   [Google Managed SSL]
```

### URLè¨­è¨ˆ
- `https://nekoya.co.jp` â†’ ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰
- `https://api.nekoya.co.jp` â†’ ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰API

---

## ã‚¹ãƒ†ãƒƒãƒ—1: é™çš„IPã‚¢ãƒ‰ãƒ¬ã‚¹ã®äºˆç´„

```bash
# ã‚°ãƒ­ãƒ¼ãƒãƒ«é™çš„IPã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’äºˆç´„
gcloud compute addresses create mycats-pro-lb-ip \
  --ip-version=IPV4 \
  --global

# IPã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ç¢ºèª
gcloud compute addresses describe mycats-pro-lb-ip --global --format="get(address)"
```

**ã“ã®IPã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ãƒ¡ãƒ¢ã—ã¦ãã ã•ã„** (ä¾‹: `34.120.123.45`)

---

## ã‚¹ãƒ†ãƒƒãƒ—2: Serverless NEGã®ä½œæˆ

Cloud Runã‚µãƒ¼ãƒ“ã‚¹ã¸ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚’è»¢é€ã™ã‚‹ãŸã‚ã®Network Endpoint Group (NEG) ã‚’ä½œæˆã—ã¾ã™ã€‚

### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ç”¨NEG

```bash
gcloud compute network-endpoint-groups create mycats-frontend-neg \
  --region=asia-northeast1 \
  --network-endpoint-type=SERVERLESS \
  --cloud-run-service=mycats-pro-frontend
```

### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ç”¨NEG

```bash
gcloud compute network-endpoint-groups create mycats-backend-neg \
  --region=asia-northeast1 \
  --network-endpoint-type=SERVERLESS \
  --cloud-run-service=mycats-pro-backend
```

---

## ã‚¹ãƒ†ãƒƒãƒ—3: ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒ“ã‚¹ã®ä½œæˆ

### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ç”¨ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒ“ã‚¹

```bash
gcloud compute backend-services create mycats-frontend-backend \
  --global \
  --load-balancing-scheme=EXTERNAL_MANAGED

gcloud compute backend-services add-backend mycats-frontend-backend \
  --global \
  --network-endpoint-group=mycats-frontend-neg \
  --network-endpoint-group-region=asia-northeast1
```

### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰APIç”¨ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒ“ã‚¹

```bash
gcloud compute backend-services create mycats-backend-backend \
  --global \
  --load-balancing-scheme=EXTERNAL_MANAGED

gcloud compute backend-services add-backend mycats-backend-backend \
  --global \
  --network-endpoint-group=mycats-backend-neg \
  --network-endpoint-group-region=asia-northeast1
```

---

## ã‚¹ãƒ†ãƒƒãƒ—4: URLãƒãƒƒãƒ—ã®ä½œæˆ

ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚’ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã™ã‚‹URLãƒãƒƒãƒ—ã‚’ä½œæˆã—ã¾ã™ã€‚

```bash
# URLãƒãƒƒãƒ—ã‚’ä½œæˆ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰)
gcloud compute url-maps create mycats-lb-urlmap \
  --default-service=mycats-frontend-backend

# /api/* ã‚’ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«æŒ¯ã‚Šåˆ†ã‘ã‚‹ãƒ‘ã‚¹ãƒãƒƒãƒãƒ£ãƒ¼ã‚’è¿½åŠ 
gcloud compute url-maps add-path-matcher mycats-lb-urlmap \
  --path-matcher-name=api-matcher \
  --default-service=mycats-frontend-backend \
  --backend-service-path-rules="/api/*=mycats-backend-backend"
```

---

## ã‚¹ãƒ†ãƒƒãƒ—5: SSLè¨¼æ˜æ›¸ã®ä½œæˆ

Google Managed SSLè¨¼æ˜æ›¸ã‚’ä½œæˆã—ã¾ã™ã€‚

```bash
# ãƒ¡ã‚¤ãƒ³ãƒ‰ãƒ¡ã‚¤ãƒ³ç”¨SSLè¨¼æ˜æ›¸
gcloud compute ssl-certificates create mycats-ssl-cert \
  --domains=nekoya.co.jp,www.nekoya.co.jp,api.nekoya.co.jp \
  --global
```

**æ³¨æ„**: SSLè¨¼æ˜æ›¸ã®ãƒ—ãƒ­ãƒ“ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°ã«ã¯ **15åˆ†ã€œ24æ™‚é–“** ã‹ã‹ã‚Šã¾ã™ã€‚DNSè¨­å®šå®Œäº†å¾Œã«è‡ªå‹•çš„ã«ç™ºè¡Œã•ã‚Œã¾ã™ã€‚

---

## ã‚¹ãƒ†ãƒƒãƒ—6: HTTPSãƒ—ãƒ­ã‚­ã‚·ã®ä½œæˆ

```bash
gcloud compute target-https-proxies create mycats-https-proxy \
  --url-map=mycats-lb-urlmap \
  --ssl-certificates=mycats-ssl-cert
```

---

## ã‚¹ãƒ†ãƒƒãƒ—7: è»¢é€ãƒ«ãƒ¼ãƒ«ã®ä½œæˆ

```bash
gcloud compute forwarding-rules create mycats-https-forwarding-rule \
  --global \
  --load-balancing-scheme=EXTERNAL_MANAGED \
  --address=mycats-pro-lb-ip \
  --target-https-proxy=mycats-https-proxy \
  --ports=443
```

---

## ã‚¹ãƒ†ãƒƒãƒ—8: HTTP â†’ HTTPS ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆè¨­å®š

```bash
# HTTPãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆç”¨URLãƒãƒƒãƒ—
gcloud compute url-maps import mycats-http-redirect \
  --global \
  --source=- <<EOF
kind: compute#urlMap
name: mycats-http-redirect
defaultUrlRedirect:
  httpsRedirect: true
  redirectResponseCode: MOVED_PERMANENTLY_DEFAULT
EOF

# HTTPãƒ—ãƒ­ã‚­ã‚·
gcloud compute target-http-proxies create mycats-http-proxy \
  --url-map=mycats-http-redirect

# HTTPè»¢é€ãƒ«ãƒ¼ãƒ«
gcloud compute forwarding-rules create mycats-http-forwarding-rule \
  --global \
  --load-balancing-scheme=EXTERNAL_MANAGED \
  --address=mycats-pro-lb-ip \
  --target-http-proxy=mycats-http-proxy \
  --ports=80
```

---

## ã‚¹ãƒ†ãƒƒãƒ—9: ãŠåå‰.comã§DNSè¨­å®š

### 9-1. ãŠåå‰.comã«ãƒ­ã‚°ã‚¤ãƒ³

https://www.onamae.com/ ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã€ç®¡ç†ç”»é¢ã«ãƒ­ã‚°ã‚¤ãƒ³

### 9-2. DNSè¨­å®šç”»é¢ã¸ç§»å‹•

1. ãƒ‰ãƒ¡ã‚¤ãƒ³ä¸€è¦§ã‹ã‚‰ `nekoya.co.jp` ã‚’é¸æŠ
2. ã€ŒDNSé–¢é€£æ©Ÿèƒ½ã®è¨­å®šã€ã‚’ã‚¯ãƒªãƒƒã‚¯
3. ã€ŒDNSãƒ¬ã‚³ãƒ¼ãƒ‰è¨­å®šã‚’åˆ©ç”¨ã™ã‚‹ã€ã‚’é¸æŠ

### 9-3. Aãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’è¿½åŠ 

ä»¥ä¸‹ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ï¼š

| ãƒ›ã‚¹ãƒˆå | TYPE | TTL | VALUE |
|---------|------|-----|-------|
| (ç©ºæ¬„) | A | 3600 | `<ã‚¹ãƒ†ãƒƒãƒ—1ã§å–å¾—ã—ãŸIP>` |
| www | A | 3600 | `<ã‚¹ãƒ†ãƒƒãƒ—1ã§å–å¾—ã—ãŸIP>` |
| api | A | 3600 | `<ã‚¹ãƒ†ãƒƒãƒ—1ã§å–å¾—ã—ãŸIP>` |

**ä¾‹**:
```
nekoya.co.jp.     A    3600    34.120.123.45
www.nekoya.co.jp. A    3600    34.120.123.45
api.nekoya.co.jp. A    3600    34.120.123.45
```

### 9-4. è¨­å®šã‚’ä¿å­˜

ã€Œè¿½åŠ ã€â†’ã€Œç¢ºèªç”»é¢ã¸é€²ã‚€ã€â†’ã€Œè¨­å®šã™ã‚‹ã€

---

## ã‚¹ãƒ†ãƒƒãƒ—10: SSLè¨¼æ˜æ›¸ã®ãƒ—ãƒ­ãƒ“ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°ç¢ºèª

DNSè¨­å®šå¾Œã€SSLè¨¼æ˜æ›¸ãŒè‡ªå‹•çš„ã«ãƒ—ãƒ­ãƒ“ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°ã•ã‚Œã¾ã™ã€‚

```bash
# SSLè¨¼æ˜æ›¸ã®çŠ¶æ…‹ã‚’ç¢ºèª
gcloud compute ssl-certificates describe mycats-ssl-cert --global

# çŠ¶æ…‹ãŒ ACTIVE ã«ãªã‚‹ã¾ã§å¾…æ©Ÿ
watch -n 60 'gcloud compute ssl-certificates describe mycats-ssl-cert --global --format="get(managed.status)"'
```

**ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**:
- `PROVISIONING` â†’ ãƒ—ãƒ­ãƒ“ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°ä¸­ (DNSåæ˜ å¾…ã¡)
- `ACTIVE` â†’ è¨¼æ˜æ›¸ç™ºè¡Œå®Œäº† âœ…

---

## ã‚¹ãƒ†ãƒƒãƒ—11: Cloud Runã‚µãƒ¼ãƒ“ã‚¹ã®ç’°å¢ƒå¤‰æ•°æ›´æ–°

ç‹¬è‡ªãƒ‰ãƒ¡ã‚¤ãƒ³ä½¿ç”¨ã«ä¼´ã„ã€CORSè¨­å®šã‚’æ›´æ–°ã—ã¾ã™ã€‚

### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰

```bash
gcloud run services update mycats-pro-backend \
  --region=asia-northeast1 \
  --set-env-vars="CORS_ORIGIN=https://nekoya.co.jp,https://www.nekoya.co.jp"
```

### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰

```bash
# æ¬¡å›ãƒ‡ãƒ—ãƒ­ã‚¤æ™‚ã«cloudbuild.yamlã§ä»¥ä¸‹ã‚’è¨­å®š
# _NEXT_PUBLIC_API_URL=https://api.nekoya.co.jp/api/v1
```

---

## ã‚¹ãƒ†ãƒƒãƒ—12: å‹•ä½œç¢ºèª

### DNSãŒæ­£ã—ãè§£æ±ºã•ã‚Œã‚‹ã‹ç¢ºèª

```bash
nslookup nekoya.co.jp
nslookup api.nekoya.co.jp
```

### HTTPSã‚¢ã‚¯ã‚»ã‚¹ç¢ºèª

```bash
# ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰
curl -I https://nekoya.co.jp

# ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰API
curl -I https://api.nekoya.co.jp/api/v1/health
```

### ãƒ–ãƒ©ã‚¦ã‚¶ã§ã‚¢ã‚¯ã‚»ã‚¹

- https://nekoya.co.jp
- https://api.nekoya.co.jp/api/v1/health

---

## ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### SSLè¨¼æ˜æ›¸ãŒ `FAILED_NOT_VISIBLE` ã®å ´åˆ

**åŸå› **: DNSãƒ¬ã‚³ãƒ¼ãƒ‰ãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ãªã„

**è§£æ±º**:
```bash
# DNSã®ä¼æ’­ã‚’ç¢ºèª
dig nekoya.co.jp +short
dig api.nekoya.co.jp +short

# ãŠåå‰.comã®è¨­å®šã‚’å†ç¢ºèª
```

### 502 Bad Gateway ã‚¨ãƒ©ãƒ¼

**åŸå› **: Cloud Runã‚µãƒ¼ãƒ“ã‚¹ãŒå¿œç­”ã—ã¦ã„ãªã„

**è§£æ±º**:
```bash
# Cloud Runã‚µãƒ¼ãƒ“ã‚¹ã®çŠ¶æ…‹ç¢ºèª
gcloud run services describe mycats-pro-frontend --region=asia-northeast1
gcloud run services describe mycats-pro-backend --region=asia-northeast1

# ãƒ­ã‚°ç¢ºèª
gcloud run services logs read mycats-pro-backend --region=asia-northeast1 --limit=100
```

### CORSã‚¨ãƒ©ãƒ¼

**åŸå› **: ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®CORSè¨­å®šãŒå¤ã„ãƒ‰ãƒ¡ã‚¤ãƒ³ã®ã¾ã¾

**è§£æ±º**:
```bash
# CORSè¨­å®šã‚’æ›´æ–° (ã‚¹ãƒ†ãƒƒãƒ—11å‚ç…§)
gcloud run services update mycats-pro-backend \
  --region=asia-northeast1 \
  --set-env-vars="CORS_ORIGIN=https://nekoya.co.jp,https://www.nekoya.co.jp"
```

---

## å‚è€ƒè³‡æ–™

- [Google Cloud Load Balancing - Serverless NEG](https://cloud.google.com/load-balancing/docs/https/setup-global-ext-https-serverless)
- [Google Managed SSL certificates](https://cloud.google.com/load-balancing/docs/ssl-certificates/google-managed-certs)
- [Cloud Run custom domains](https://cloud.google.com/run/docs/mapping-custom-domains)

---

## ã¾ã¨ã‚

ä»¥ä¸‹ã®ãƒªã‚½ãƒ¼ã‚¹ãŒä½œæˆã•ã‚Œã¾ã™ï¼š

- âœ… é™çš„IP: `mycats-pro-lb-ip`
- âœ… SSLè¨¼æ˜æ›¸: `mycats-ssl-cert`
- âœ… ãƒ­ãƒ¼ãƒ‰ãƒãƒ©ãƒ³ã‚µãƒ¼: `mycats-lb-urlmap`
- âœ… Serverless NEG: `mycats-frontend-neg`, `mycats-backend-neg`

**å®Œäº†å¾Œã®URL**:
- `https://nekoya.co.jp` â†’ ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰
- `https://api.nekoya.co.jp/api/v1` â†’ ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰API
`````

## File: docs/deployment/DOMAIN_AND_EMAIL_SETUP.md
`````markdown
# ç‹¬è‡ªãƒ‰ãƒ¡ã‚¤ãƒ³ + ãƒ¡ãƒ¼ãƒ«é€ä¿¡æ©Ÿèƒ½ ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æ‰‹é †

## ğŸ“‹ æ¦‚è¦

ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ã€GCPä¸Šã§ç¨¼åƒã™ã‚‹mycats-proãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ä»¥ä¸‹ã‚’è¨­å®šã™ã‚‹å®Œå…¨ã‚¬ã‚¤ãƒ‰ã§ã™ï¼š

1. **ç‹¬è‡ªãƒ‰ãƒ¡ã‚¤ãƒ³è¨­å®š** (`nekoya.co.jp`)
2. **SSLè¨¼æ˜æ›¸** (Google Managed)
3. **ãƒ¡ãƒ¼ãƒ«é€ä¿¡æ©Ÿèƒ½** (Resend)

## ğŸ¯ ç›®æ¨™ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

```
[ãŠåå‰.com DNS]
    â†“
[Google Load Balancer + SSL]
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  https://nekoya.co.jp                â”‚ â†’ Cloud Run (Frontend)
â”‚  https://api.nekoya.co.jp/api/v1     â”‚ â†’ Cloud Run (Backend)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
[Resend API] â†’ ãƒ¡ãƒ¼ãƒ«é€ä¿¡
```

---

## âš™ï¸ äº‹å‰æº–å‚™

### 1. å¿…è¦ãªã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ»ãƒªã‚½ãƒ¼ã‚¹

- âœ… ãŠåå‰.comã‚¢ã‚«ã‚¦ãƒ³ãƒˆ (ãƒ‰ãƒ¡ã‚¤ãƒ³ `nekoya.co.jp` å–å¾—æ¸ˆã¿)
- âœ… GCPãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ `my-cats-pro` (Cloud Runç¨¼åƒä¸­)
- âœ… Resendã‚¢ã‚«ã‚¦ãƒ³ãƒˆ (https://resend.com)

### 2. å¿…è¦ãªãƒ„ãƒ¼ãƒ«

```bash
# gcloud CLI
gcloud version

# ç¾åœ¨ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç¢ºèª
gcloud config get-value project  # â†’ my-cats-pro
```

---

## ğŸš€ ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æ‰‹é †

### ãƒ‘ã‚¿ãƒ¼ãƒ³A: è‡ªå‹•ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— (æ¨å¥¨)

ã™ã¹ã¦ã®æ‰‹é †ã‚’è‡ªå‹•åŒ–ã—ãŸã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

```bash
# ã‚¹ã‚¯ãƒªãƒ—ãƒˆã«å®Ÿè¡Œæ¨©é™ã‚’ä»˜ä¸
chmod +x scripts/setup-custom-domain.sh
chmod +x scripts/setup-domain-and-email.sh

# ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—å®Ÿè¡Œ
./scripts/setup-domain-and-email.sh
```

ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒä»¥ä¸‹ã‚’å®Ÿè¡Œã—ã¾ã™ï¼š
1. é™çš„IPã‚¢ãƒ‰ãƒ¬ã‚¹ã®äºˆç´„
2. Serverless NEGã®ä½œæˆ
3. Load Balancerã®è¨­å®š
4. SSLè¨¼æ˜æ›¸ã®ä½œæˆ
5. Resend APIã‚­ãƒ¼ã®ç™»éŒ²
6. Cloud Runã‚µãƒ¼ãƒ“ã‚¹ã®ç’°å¢ƒå¤‰æ•°æ›´æ–°

---

### ãƒ‘ã‚¿ãƒ¼ãƒ³B: æ‰‹å‹•ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

#### ã‚¹ãƒ†ãƒƒãƒ—1: GCP Load Balancerã®è¨­å®š

è©³ç´°ã¯ [docs/deployment/CUSTOM_DOMAIN_SETUP.md](docs/deployment/CUSTOM_DOMAIN_SETUP.md) ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

**æ¦‚è¦**:
1. é™çš„IPã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’äºˆç´„
2. Serverless NEG (Network Endpoint Group) ã‚’ä½œæˆ
3. ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒ“ã‚¹ã‚’ä½œæˆ
4. URLãƒãƒƒãƒ—ã‚’ä½œæˆ
5. SSLè¨¼æ˜æ›¸ã‚’ä½œæˆ
6. HTTPSãƒ—ãƒ­ã‚­ã‚·ã‚’ä½œæˆ
7. è»¢é€ãƒ«ãƒ¼ãƒ«ã‚’ä½œæˆ
8. HTTPâ†’HTTPSãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã‚’è¨­å®š

#### ã‚¹ãƒ†ãƒƒãƒ—2: ãŠåå‰.comã§DNSè¨­å®š

1. ãŠåå‰.comç®¡ç†ç”»é¢ã«ãƒ­ã‚°ã‚¤ãƒ³
2. `nekoya.co.jp` ã®DNSè¨­å®šç”»é¢ã¸ç§»å‹•
3. ä»¥ä¸‹ã®Aãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’è¿½åŠ :

| ãƒ›ã‚¹ãƒˆå | TYPE | TTL | VALUE |
|---------|------|-----|-------|
| (ç©ºæ¬„) | A | 3600 | `<ã‚¹ãƒ†ãƒƒãƒ—1ã§å–å¾—ã—ãŸIP>` |
| www | A | 3600 | `<ã‚¹ãƒ†ãƒƒãƒ—1ã§å–å¾—ã—ãŸIP>` |
| api | A | 3600 | `<ã‚¹ãƒ†ãƒƒãƒ—1ã§å–å¾—ã—ãŸIP>` |

#### ã‚¹ãƒ†ãƒƒãƒ—3: Resendã®è¨­å®š

è©³ç´°ã¯ [docs/EMAIL_INTEGRATION_GUIDE.md](docs/EMAIL_INTEGRATION_GUIDE.md) ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

**æ¦‚è¦**:
1. Resendã‚¢ã‚«ã‚¦ãƒ³ãƒˆä½œæˆ
2. ãƒ‰ãƒ¡ã‚¤ãƒ³ `nekoya.co.jp` ã‚’è¿½åŠ 
3. è¡¨ç¤ºã•ã‚Œã‚‹DNSãƒ¬ã‚³ãƒ¼ãƒ‰ (TXT, MX) ã‚’ãŠåå‰.comã«è¿½åŠ 
4. ãƒ‰ãƒ¡ã‚¤ãƒ³æ¤œè¨¼å®Œäº†ã‚’å¾…ã¤
5. APIã‚­ãƒ¼ã‚’ä½œæˆ
6. Secret Managerã«ç™»éŒ²

```bash
# APIã‚­ãƒ¼ã‚’Secret Managerã«ç™»éŒ²
echo -n "re_your_actual_api_key" | \
  gcloud secrets versions add RESEND_API_KEY_production \
    --data-file=- \
    --project=my-cats-pro

# æ¨©é™ä»˜ä¸
gcloud secrets add-iam-policy-binding RESEND_API_KEY_production \
  --member="serviceAccount:cloud-run-backend@my-cats-pro.iam.gserviceaccount.com" \
  --role="roles/secretmanager.secretAccessor" \
  --project=my-cats-pro
```

#### ã‚¹ãƒ†ãƒƒãƒ—4: Cloud Runã‚µãƒ¼ãƒ“ã‚¹ã®æ›´æ–°

```bash
# ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒ“ã‚¹ã‚’æ›´æ–°
gcloud run services update mycats-pro-backend \
  --region=asia-northeast1 \
  --update-secrets=RESEND_API_KEY=RESEND_API_KEY_production:latest \
  --set-env-vars="EMAIL_FROM=noreply@nekoya.co.jp,EMAIL_FROM_NAME=MyCats Pro,CORS_ORIGIN=https://nekoya.co.jp,https://www.nekoya.co.jp" \
  --project=my-cats-pro
```

---

## âœ… å‹•ä½œç¢ºèª

### 1. DNSè§£æ±ºã®ç¢ºèª

```bash
nslookup nekoya.co.jp
nslookup api.nekoya.co.jp
```

### 2. SSLè¨¼æ˜æ›¸ã®çŠ¶æ…‹ç¢ºèª

```bash
gcloud compute ssl-certificates describe mycats-ssl-cert --global

# çŠ¶æ…‹ãŒ ACTIVE ã«ãªã‚‹ã¾ã§å¾…æ©Ÿ (15åˆ†ã€œ24æ™‚é–“)
watch -n 60 'gcloud compute ssl-certificates describe mycats-ssl-cert --global --format="get(managed.status)"'
```

### 3. HTTPSã‚¢ã‚¯ã‚»ã‚¹ç¢ºèª

```bash
# ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰
curl -I https://nekoya.co.jp

# ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰API
curl https://api.nekoya.co.jp/api/v1/health
```

### 4. ãƒ¡ãƒ¼ãƒ«é€ä¿¡ãƒ†ã‚¹ãƒˆ

ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«ãƒ†ã‚¹ãƒˆç”¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’è¿½åŠ ã—ã¦ç¢ºèª:

```bash
curl -X POST https://api.nekoya.co.jp/api/v1/test/send-email \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -d '{"to":"your-email@example.com","subject":"ãƒ†ã‚¹ãƒˆ","message":"ãƒ¡ãƒ¼ãƒ«é€ä¿¡ãƒ†ã‚¹ãƒˆã§ã™"}'
```

ã¾ãŸã¯ã€ãƒ­ã‚°ã§ç¢ºèª:

```bash
gcloud run services logs read mycats-pro-backend \
  --region=asia-northeast1 \
  --limit=50 | grep -i email
```

---

## ğŸ“Š è¨­å®šä¸€è¦§

### GCPãƒªã‚½ãƒ¼ã‚¹

| ãƒªã‚½ãƒ¼ã‚¹ | åå‰ | ç”¨é€” |
|---------|------|------|
| é™çš„IP | `mycats-pro-lb-ip` | Load Balancerç”¨ã‚°ãƒ­ãƒ¼ãƒãƒ«IP |
| SSLè¨¼æ˜æ›¸ | `mycats-ssl-cert` | nekoya.co.jp, www, apiç”¨ |
| Serverless NEG | `mycats-frontend-neg` | ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã¸ã®ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚° |
| Serverless NEG | `mycats-backend-neg` | ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã¸ã®ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚° |
| Backend Service | `mycats-frontend-backend` | ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ |
| Backend Service | `mycats-backend-backend` | ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰API |
| URL Map | `mycats-lb-urlmap` | ãƒˆãƒ©ãƒ•ã‚£ãƒƒã‚¯ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚° |
| HTTPS Proxy | `mycats-https-proxy` | HTTPSçµ‚ç«¯ |
| HTTP Proxy | `mycats-http-proxy` | HTTPãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ |

### Secret Manager

| ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆå | ç”¨é€” |
|---------------|------|
| `RESEND_API_KEY_production` | Resend APIèªè¨¼ |
| `DATABASE_URL_production` | PostgreSQLæ¥ç¶šæ–‡å­—åˆ— |
| `JWT_SECRET_production` | JWTã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ç½²å |
| `JWT_REFRESH_SECRET_production` | JWTãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ç½²å |
| `CSRF_TOKEN_SECRET_production` | CSRFä¿è­· |

### ç’°å¢ƒå¤‰æ•° (Cloud Run Backend)

| å¤‰æ•°å | å€¤ |
|-------|-----|
| `NODE_ENV` | `production` |
| `CORS_ORIGIN` | `https://nekoya.co.jp,https://www.nekoya.co.jp` |
| `EMAIL_FROM` | `noreply@nekoya.co.jp` |
| `EMAIL_FROM_NAME` | `MyCats Pro` |

---

## ğŸ”§ æ¬¡å›ãƒ‡ãƒ—ãƒ­ã‚¤æ™‚ã®è¨­å®š

GitHub Actionsã¾ãŸã¯Cloud Buildã§ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹éš›ã¯ã€ä»¥ä¸‹ã®ç½®æ›å¤‰æ•°ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„:

```yaml
_RESEND_API_KEY_SECRET_NAME: RESEND_API_KEY_production
_RESEND_API_KEY_SECRET_VERSION: latest
_EMAIL_FROM: noreply@nekoya.co.jp
_EMAIL_FROM_NAME: MyCats Pro
_CORS_ORIGIN: https://nekoya.co.jp,https://www.nekoya.co.jp
_NEXT_PUBLIC_API_URL: https://api.nekoya.co.jp/api/v1
```

---

## ğŸ› ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### SSLè¨¼æ˜æ›¸ãŒ `PROVISIONING` ã®ã¾ã¾

**åŸå› **: DNSè¨­å®šãŒåæ˜ ã•ã‚Œã¦ã„ãªã„

**è§£æ±º**:
```bash
# DNSä¼æ’­ã‚’ç¢ºèª
dig nekoya.co.jp +short
dig api.nekoya.co.jp +short

# ãŠåå‰.comã®è¨­å®šã‚’å†ç¢ºèª
```

### 502 Bad Gateway ã‚¨ãƒ©ãƒ¼

**åŸå› **: Cloud Runã‚µãƒ¼ãƒ“ã‚¹ãŒå¿œç­”ã—ã¦ã„ãªã„

**è§£æ±º**:
```bash
# ã‚µãƒ¼ãƒ“ã‚¹ã®çŠ¶æ…‹ç¢ºèª
gcloud run services describe mycats-pro-backend --region=asia-northeast1

# ãƒ­ã‚°ç¢ºèª
gcloud run services logs read mycats-pro-backend --region=asia-northeast1 --limit=100
```

### ãƒ¡ãƒ¼ãƒ«ãŒé€ä¿¡ã•ã‚Œãªã„

**åŸå› 1**: RESEND_API_KEYãŒè¨­å®šã•ã‚Œã¦ã„ãªã„

```bash
# ç’°å¢ƒå¤‰æ•°ã‚’ç¢ºèª
gcloud run services describe mycats-pro-backend \
  --region=asia-northeast1 \
  --format="get(spec.template.spec.containers[0].env)"
```

**åŸå› 2**: Resendãƒ‰ãƒ¡ã‚¤ãƒ³æ¤œè¨¼ãŒæœªå®Œäº†

- Resendãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã§ã€ŒDomain Statusã€ã‚’ç¢ºèª
- ãŠåå‰.comã§TXT/MXãƒ¬ã‚³ãƒ¼ãƒ‰ãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª

---

## ğŸ“š é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- [ã‚«ã‚¹ã‚¿ãƒ ãƒ‰ãƒ¡ã‚¤ãƒ³è¨­å®šã‚¬ã‚¤ãƒ‰](docs/deployment/CUSTOM_DOMAIN_SETUP.md)
- [ãƒ¡ãƒ¼ãƒ«é€ä¿¡æ©Ÿèƒ½å®Ÿè£…ã‚¬ã‚¤ãƒ‰](docs/EMAIL_INTEGRATION_GUIDE.md)
- [GCPãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆã‚¬ã‚¤ãƒ‰](docs/deployment/GCP_DEPLOYMENT_GUIDE.md)
- [CI/CDãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆãƒ•ãƒ­ãƒ¼](docs/CICD_DEPLOYMENT_FLOW.md)

---

## ğŸ“ ã¾ã¨ã‚

å®Œäº†å¾Œã€ä»¥ä¸‹ã®URLã§ã‚µãƒ¼ãƒ“ã‚¹ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™:

- **ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰**: https://nekoya.co.jp
- **ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰API**: https://api.nekoya.co.jp/api/v1
- **ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯**: https://api.nekoya.co.jp/api/v1/health

ãƒ¡ãƒ¼ãƒ«é€ä¿¡æ©Ÿèƒ½ã¯ä»¥ä¸‹ã§åˆ©ç”¨å¯èƒ½:
- ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆ
- ã‚¦ã‚§ãƒ«ã‚«ãƒ ãƒ¡ãƒ¼ãƒ«
- çŒ«ç™»éŒ²ç¢ºèªãƒ¡ãƒ¼ãƒ«
- ã‚«ã‚¹ã‚¿ãƒ é€šçŸ¥

ã™ã¹ã¦ã®è¨­å®šãŒå®Œäº†ã™ã‚‹ã¨ã€ãƒ—ãƒ­ãƒ•ã‚§ãƒƒã‚·ãƒ§ãƒŠãƒ«ãªã‚«ã‚¹ã‚¿ãƒ ãƒ‰ãƒ¡ã‚¤ãƒ³ã¨ãƒ¡ãƒ¼ãƒ«é€ä¿¡æ©Ÿèƒ½ã‚’å‚™ãˆãŸæœ¬ç•ªç’°å¢ƒãŒæ•´ã„ã¾ã™ã€‚
`````

## File: docs/deployment/GCP_DEPLOYMENT_GUIDE.md
`````markdown
# GCP ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆã‚¬ã‚¤ãƒ‰

MyCats Pro ã‚’ Google Cloud ç’°å¢ƒã¸å®‰å…¨ã«ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹ãŸã‚ã®çµ±åˆã‚¬ã‚¤ãƒ‰ã§ã™ã€‚Cloud Run + Cloud SQL + Artifact Registry ã‚’å‰æã¨ã—ã€å¾“æ¥ã®ã‚ªãƒ³ãƒ—ãƒ¬ï¼Docker æ‰‹é †ã¯å»ƒæ­¢ã—ã¾ã—ãŸã€‚

---

## 1. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦

| é …ç›® | å€¤ |
| --- | --- |
| GCP ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ | `my-cats-pro` |
| ãƒªãƒ¼ã‚¸ãƒ§ãƒ³ | `asia-northeast1` (æ±äº¬) |
| æœ¬ç•ªãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ | Cloud SQL / PostgreSQL 15 (`mycats-prod-db`) |
| ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆãƒ¬ã‚¸ã‚¹ãƒˆãƒª | `asia-northeast1-docker.pkg.dev/my-cats-pro/mycats-pro` |
| æœ¬ç•ªã‚µãƒ¼ãƒ“ã‚¹ | Cloud Run (`mycats-pro-backend`, `mycats-pro-frontend`) |
| CI/CD | Cloud Build (`cloudbuild.yaml`) |

---

## 2. åŸºç›¤ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

### 2.1 æœ‰åŠ¹åŒ–æ¸ˆã¿ API

- Cloud SQL Admin API (`sqladmin.googleapis.com`)
- Cloud Run API (`run.googleapis.com`)
- Artifact Registry API (`artifactregistry.googleapis.com`)
- Cloud Build API (`cloudbuild.googleapis.com`)
- Secret Manager API (`secretmanager.googleapis.com`)
- Compute Engine / Cloud Billing API

ç¢ºèªã‚³ãƒãƒ³ãƒ‰:

```bash
gcloud services list --enabled | grep -E "sqladmin|run|artifact|cloudbuild|secret"
```

### 2.2 Secret Manager

| ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆ | ç”¨é€” |
| --- | --- |
| `DATABASE_URL` | Cloud SQL æ¥ç¶šæ–‡å­—åˆ— (`sslmode=require` æ¨å¥¨) |
| `DB_PASSWORD` | DB ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ |
| `JWT_SECRET` | ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ç½²åã‚­ãƒ¼ |
| `JWT_REFRESH_SECRET` | ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ç½²åã‚­ãƒ¼ |

```bash
# æœ€æ–°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®å–å¾—ä¾‹
gcloud secrets versions access latest --secret=DATABASE_URL
```

### 2.3 Cloud SQL

- ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹: `mycats-prod-db` (db-f1-micro, `asia-northeast1-b`)
- DB å: `mycats_production`
- ãƒ¦ãƒ¼ã‚¶ãƒ¼: `mycats_prod`
- è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—: æœ‰åŠ¹ (03:00 JST)

```bash
# æ¥ç¶šãƒ†ã‚¹ãƒˆ
gcloud sql connect mycats-prod-db --user=mycats_prod --database=mycats_production
```

### 2.4 Artifact Registry

```text
asia-northeast1-docker.pkg.dev/my-cats-pro/mycats-pro/backend:TAG
asia-northeast1-docker.pkg.dev/my-cats-pro/mycats-pro/frontend:TAG
```

### 2.5 IAM æ¨©é™

Cloud Build ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ (`$PROJECT_NUMBER@cloudbuild.gserviceaccount.com`) ã«ä»¥ä¸‹ã‚’ä»˜ä¸ã—ã¾ã™ã€‚

- `roles/run.admin`
- `roles/iam.serviceAccountUser`
- `roles/artifactregistry.writer`
- `roles/cloudsql.client`
- `roles/secretmanager.secretAccessor`

Cloud Run å®Ÿè¡Œã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«ã¯ `roles/secretmanager.secretAccessor` ã¨ `roles/cloudsql.client` ã‚’å‰²ã‚Šå½“ã¦ã¦ãã ã•ã„ã€‚

---

## 3. ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³

### 3.1 äº‹å‰ãƒã‚§ãƒƒã‚¯

```bash
git pull origin main
pnpm install --frozen-lockfile
pnpm -w run lint
pnpm -w run test:e2e -- --passWithNoTests
pnpm --filter backend run build
pnpm --filter frontend run build
pnpm -w run db:generate
```

### 3.2 Cloud Build ãƒˆãƒªã‚¬ãƒ¼

`cloudbuild.yaml` ã«å®šç¾©æ¸ˆã¿ã€‚main ãƒ–ãƒ©ãƒ³ãƒ push ã§è‡ªå‹•å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚

æ‰‹å‹•å®Ÿè¡Œä¾‹:

```bash
gcloud builds submit --config cloudbuild.yaml --substitutions _LOCATION="asia-northeast1",_REPO_NAME="mycats-pro",_BACKEND_SERVICE_NAME="mycats-pro-backend",_FRONTEND_SERVICE_NAME="mycats-pro-frontend",_NEXT_PUBLIC_API_URL="https://backend.example.com/api/v1",_CORS_ORIGIN="https://frontend.example.com"
```

### 3.3 Cloud Run æ›´æ–°

Cloud Build ãŒä»¥ä¸‹ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚

1. Backend / Frontend ã® Docker ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’ãƒ“ãƒ«ãƒ‰ã—ã¦ Artifact Registry ã« push
2. `DATABASE_URL` ãªã©ã® Secret ã‚’ãƒã‚¦ãƒ³ãƒˆ
3. `--add-cloudsql-instances` ã§ Cloud SQL ã‚’ã‚¢ã‚¿ãƒƒãƒ
4. `PORT=8080` ã§èµ·å‹• (Cloud Run äºˆç´„å€¤ã«ä¸Šæ›¸ãã—ãªã„)

---

## 4. Cloud Run ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

| ã‚«ãƒ†ã‚´ãƒª | ç¢ºèªé …ç›® |
| --- | --- |
| ç’°å¢ƒå¤‰æ•° | `PORT` ã‚„ `K_SERVICE` ç­‰ã®äºˆç´„å¤‰æ•°ã‚’ä¸Šæ›¸ãã—ãªã„ |
| Dockerfile | `EXPOSE 8080`ã€`process.env.PORT` ã‚’å‚ç…§ã€Prisma ç”Ÿæˆæ¸ˆã¿ã€`prisma/` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ã‚³ãƒ”ãƒ¼ |
| Backend | `prisma` ã¯ dependenciesã€`npx prisma generate` å®Ÿè¡Œã€ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å«ã‚ã‚‹ |
| Frontend | `NEXT_PUBLIC_*` ã‚’ `--set-env-vars` çµŒç”±ã§æ¸¡ã™ã€`next build` ãŒãƒ­ãƒ¼ã‚«ãƒ«ã§æˆåŠŸã™ã‚‹ |
| Cloud Build | æœªä½¿ç”¨ã®ç½®æ›å¤‰æ•°ã‚’å‰Šé™¤ã€Secret Manager ã®å‚ç…§åã‚’ç¢ºèªã€Cloud SQL æ¥ç¶šåã‚’ `PROJECT:REGION:INSTANCE` å½¢å¼ã§è¨­å®š |
| Secret Manager | `DATABASE_URL`, `JWT_SECRET`, `JWT_REFRESH_SECRET` ãŒæœ€æ–°ã€Cloud Build/Run ã« `secretAccessor` æ¨©é™ã‚’ä»˜ä¸ |
| Cloud SQL | ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç¨¼åƒä¸­ã€DB/ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆæ¸ˆã¿ã€Cloud Run ã‹ã‚‰ã®æ¥ç¶šã‚’è¨±å¯ |
| IAM | Cloud Build ã« Run/Admin/Artifact/Secret/SQL æ¨©é™ã€Cloud Run ã« Secret/SQL æ¨©é™ |

---

## 5. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

Cloud Build ã® `Migrate Database` ã‚¹ãƒ†ãƒƒãƒ—ã§ `pnpm prisma migrate deploy` ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚æ‰‹å‹•ã§é©ç”¨ã™ã‚‹å ´åˆã¯ä»¥ä¸‹ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

```bash
export DATABASE_URL=$(gcloud secrets versions access latest --secret=DATABASE_URL)
cd backend
pnpm prisma migrate deploy
```

---

## 6. ãƒ‡ãƒ—ãƒ­ã‚¤å¾Œæ¤œè¨¼

```bash
# Cloud Build çŠ¶æ…‹
gcloud builds list --limit=5

# Cloud Run ã‚µãƒ¼ãƒ“ã‚¹ URL
gcloud run services describe mycats-pro-backend \
  --region=asia-northeast1 --format="value(status.url)"

gcloud run services describe mycats-pro-frontend \
  --region=asia-northeast1 --format="value(status.url)"

# ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
curl -f "$BACKEND_URL"/health
curl -f "$FRONTEND_URL"

# ãƒ­ã‚°ç¢ºèª
gcloud run services logs read mycats-pro-backend --region=asia-northeast1 --limit 100
```

---

## 7. é‹ç”¨ãƒ»ç›£è¦–ãƒã‚¤ãƒ³ãƒˆ

| é …ç›® | ã‚³ãƒãƒ³ãƒ‰ä¾‹ |
| --- | --- |
| ã‚µãƒ¼ãƒ“ã‚¹ç¨¼åƒç¢ºèª | `gcloud run services list --region=asia-northeast1` |
| ãƒ­ã‚°ç›£è¦– | `gcloud run services logs read <service> --tail` |
| Cloud SQL çŠ¶æ…‹ | `gcloud sql instances describe mycats-prod-db` |
| ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ | `curl -f "$BACKEND_URL"/health` |
| ç›£è¦–ãƒ«ãƒ¼ãƒ« | Cloud Monitoring ã§ãƒ¬ã‚¤ãƒ†ãƒ³ã‚· (<500ms) / ã‚¨ãƒ©ãƒ¼ç‡ (<1%) ã‚’é€šçŸ¥ |

è©³ç´°ãªç›£è¦–ãƒ»ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ»éšœå®³å¯¾å¿œã¯ `docs/operations.md` ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

---

## 8. ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

| ç—‡çŠ¶ | åŸå›  | å¯¾å¿œ |
| --- | --- | --- |
| `PORT environment variable is reserved` | Cloud Run äºˆç´„å¤‰æ•°ã‚’ä¸Šæ›¸ã | `cloudbuild.yaml` ã‹ã‚‰ `PORT` ã®æ‰‹å‹•è¨­å®šã‚’å‰Šé™¤ã™ã‚‹ |
| `prisma: command not found` | Prisma ãŒ devDependencies ã«ã‚ã‚‹ | `prisma` ã‚’ `dependencies` ã«ç§»å‹•ã—ã€Dockerfile ã§ `npx prisma generate` å®Ÿè¡Œ |
| `Error: P1001 Can't reach database` | Cloud SQL æ¥ç¶šè¨­å®šãƒŸã‚¹ | æ¥ç¶šåã€IAM æ¨©é™ã€Secret ã‚’ç¢ºèªã—ã€Cloud SQL Proxy çµŒç”±ã§ãƒ†ã‚¹ãƒˆ |
| `Cannot find module '@prisma/client'` | Prisma Client æœªç”Ÿæˆ | Dockerfile ã« `RUN pnpm prisma generate` ã‚’è¿½åŠ  |
| Cloud Build å¤±æ•— | Cloud SQL/Secret æ¨©é™ä¸è¶³ | `gcloud projects add-iam-policy-binding` ã§æ¨©é™ã‚’å†ä»˜ä¸ã—ã€å†å®Ÿè¡Œ |
| Cloud Run 500 | ç’°å¢ƒå¤‰æ•°ä¸è¶³ | `gcloud run services describe` ã§è¨­å®šã‚’ç¢ºèªã—ã€`cloudbuild.yaml` ã® substitutions ã‚’æ›´æ–° |

---

## 9. é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- `cloudbuild.yaml` (CI/CD å®šç¾©)
- `docs/operations.md` (ç›£è¦–ãƒ»éšœå®³å¯¾å¿œãƒ©ãƒ³ãƒ–ãƒƒã‚¯)
- `docs/system-design.md` (ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£)
- `docs/api-specification.md`
- `TROUBLESHOOTING.md` (å…±é€šãƒˆãƒ©ãƒ–ãƒ«å¯¾å‡¦)

---

**æœ€çµ‚æ›´æ–°**: 2025-11-17
`````

## File: docs/diagrams/project-overview.md
`````markdown
# ï¿½ï¸ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“å›³

## ğŸ“¦ C4 Container æ§‹æˆ

å®Ÿè£…æ¸ˆã¿ã¯é€šå¸¸è‰²ã€å°å…¥äºˆå®šå€™è£œã¯ã‚°ãƒ¬ãƒ¼ã§è¡¨ç¤ºã—ã¦ã„ã¾ã™ã€‚

```mermaid
C4Container
title MyCats - Project Overview

Person(user, "User", "Breeder / Admin / Vet")

Container_Boundary(fe, "Frontend") {
  Container(next, "Next.js App", "Next.js 15, React 19, Mantine, Tailwind", "SSR/SPA UI")
}

Container_Boundary(be, "Backend") {
  Container(api, "NestJS API", "NestJS 10", "REST JSON API v1")
  Container(prisma, "Prisma ORM", "Prisma Client 6.14", "DB access layer")
}

ContainerDb(db, "PostgreSQL", "PostgreSQL 15", "Primary database")

System_Ext(nginx, "Nginx (Reverse Proxy)", "Routing/SSL")
System_Ext(swagger, "Swagger UI (Dev)", "OpenAPI Docs (development only)")

Container_Ext(redis, "Redis (Planned)", "Redis 7", "Caching / Rate limiting (planned)")
System_Ext(mail, "Mail Service (Planned)", "Notifications (planned)")
System_Ext(obj, "Object Storage (Planned)", "Images/Files (planned)")

Rel(user, next, "Uses", "HTTPS")
Rel(nginx, next, "Routes")
Rel(nginx, api, "Routes")
Rel(next, api, "Calls", "JSON/HTTPS")
Rel(api, prisma, "Uses")
Rel_Back(prisma, db, "Reads/Writes", "SQL")
Rel(api, swagger, "Exposes", "OpenAPI")
Rel(api, redis, "Caching / Rate limit", "planned")
Rel(api, mail, "Sends notifications", "planned")
Rel(api, obj, "Uploads / Downloads", "planned")

UpdateElementStyle(redis, $bgColor="#eeeeee", $borderColor="#999999", $fontColor="#555555")
UpdateElementStyle(mail, $bgColor="#eeeeee", $borderColor="#999999", $fontColor="#555555")
UpdateElementStyle(obj, $bgColor="#eeeeee", $borderColor="#999999", $fontColor="#555555")
```

---

## ğŸ—ºï¸ æ©Ÿèƒ½ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ï¼ˆå®Ÿè£…æ¸ˆã¿ / å°å…¥äºˆå®šå€™è£œï¼‰

```mermaid
mindmap
  root((MyCats æ©Ÿèƒ½ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹))
    èªè¨¼
      å®Ÿè£…æ¸ˆã¿
        ãƒ­ã‚°ã‚¤ãƒ³
        ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
        ç™»éŒ²
      è¨ˆç”»
        ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆ
        å€‹åˆ¥ãƒ¬ãƒ¼ãƒˆåˆ¶é™
    çŒ«
      å®Ÿè£…æ¸ˆã¿
        çµ±è¨ˆ
        ç¹æ®–å±¥æ­´
        ã‚±ã‚¢å±¥æ­´
      è¨ˆç”»
        æ¤œç´¢æ‹¡å¼µãƒ»ä¸¦ã³æ›¿ãˆãƒ—ãƒªã‚»ãƒƒãƒˆ
        ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
    è¡€çµ±
      å®Ÿè£…æ¸ˆã¿
        è¡€çµ±æ›¸ç•ªå·æ¤œç´¢
        ç›´ç³»ãƒ„ãƒªãƒ¼
        å­å­«ä¸€è¦§
      è¨ˆç”»
        å®¶ç³»å›³å¯è¦–åŒ–å¼·åŒ–
        ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆRedisï¼‰
    ã‚±ã‚¢
      å®Ÿè£…æ¸ˆã¿
        ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ä¸€è¦§
        å®Œäº†ãƒãƒ¼ã‚¯ï¼ˆPATCH/PUTï¼‰
      è¨ˆç”»
        é€šçŸ¥ï¼ˆãƒ¡ãƒ¼ãƒ«ï¼‰
        æ¬¡å›è‡ªå‹•ç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯æ‹¡å¼µ
    ç¹æ®–
      å®Ÿè£…æ¸ˆã¿
        è¨˜éŒ²ä¸€è¦§/ç™»éŒ²
      è¨ˆç”»
        è¿‘è¦ªäº¤é…æ¤œå‡º
        ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«é€£æº
    ãƒã‚¹ã‚¿
      å®Ÿè£…æ¸ˆã¿
        çŒ«ç¨®CRUDï¼ˆç®¡ç†è€…ï¼‰
        æ¯›è‰²CRUDï¼ˆç®¡ç†è€…ï¼‰
        ã‚¿ã‚°ä½œæˆ/å‰Šé™¤
      è¨ˆç”»
        CSVä¸€æ‹¬ã‚¤ãƒ³ãƒãƒ¼ãƒˆUI
    å…±é€š/é‹ç”¨
      å®Ÿè£…æ¸ˆã¿
        Swaggerï¼ˆé–‹ç™ºï¼‰
        çµ±ä¸€ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
      è¨ˆç”»
        ç›£è¦–/ãƒ­ã‚°é›†ç´„
        ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°/æœ¬ç•ªã‚¹ã‚±ãƒ¼ãƒ«
```

æ³¨: å®Ÿè£…çŠ¶æ³ã¯ `docs/api-specification.md` ã¨ã‚³ãƒ¼ãƒ‰ã®ç¾çŠ¶ã‹ã‚‰è¦ç´„ã—ã¦ã„ã¾ã™ã€‚è©³ç´°ã¯å½“è©²ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’ã”ç¢ºèªãã ã•ã„ã€‚

---

## ğŸ” äº’æ›ç‰ˆï¼ˆæ¨™æº–Mermaid Flowchartï¼‰

Mermaidã®C4 / mindmapãŒãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã•ã‚Œãªã„ç’°å¢ƒå‘ã‘ã®ç°¡æ˜“å›³ã§ã™ã€‚

### ã‚·ã‚¹ãƒ†ãƒ ä¿¯ç°ï¼ˆäº’æ›ï¼‰

```mermaid
graph TD
  user[User] --> nginx[Nginx (Reverse Proxy)]
  nginx --> next[Next.js App]
  nginx --> api[NestJS API]
  next --> api
  api --> prisma[Prisma ORM]
  prisma --> db[(PostgreSQL)]
  api -. planned .-> redis[(Redis - planned)]
  api -. planned .-> mail[Mail Service - planned]
  api -. planned .-> storage[Object Storage - planned]
  api --> swagger[Swagger UI (Dev)]

  subgraph Frontend
    next
  end
  subgraph Backend
    api
    prisma
  end
  subgraph Data
    db
    redis
  end
  subgraph External
    nginx
    mail
    storage
    swagger
  end

  style redis fill:#eeeeee,stroke:#999999,color:#555555
  style mail fill:#eeeeee,stroke:#999999,color:#555555
  style storage fill:#eeeeee,stroke:#999999,color:#555555
```

### æ©Ÿèƒ½ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ï¼ˆäº’æ›ï¼‰

```mermaid
graph TB
  classDef done fill:#c8e6c9,stroke:#2e7d32,color:#1b5e20
  classDef plan fill:#eeeeee,stroke:#999999,color:#555555

  subgraph èªè¨¼
    login[ãƒ­ã‚°ã‚¤ãƒ³]:::done
    refresh[ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥]:::done
    register[ç™»éŒ²]:::done
    reset[ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆ]:::plan
    rate[å€‹åˆ¥ãƒ¬ãƒ¼ãƒˆåˆ¶é™]:::plan
  end

  subgraph çŒ«
    stats[çµ±è¨ˆ]:::done
    breedingHist[ç¹æ®–å±¥æ­´]:::done
    careHist[ã‚±ã‚¢å±¥æ­´]:::done
    search[æ¤œç´¢æ‹¡å¼µ/ä¸¦ã³æ›¿ãˆ]:::plan
    upload[ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰]:::plan
  end

  subgraph è¡€çµ±
    pedId[è¡€çµ±æ›¸ç•ªå·æ¤œç´¢]:::done
    direct[ç›´ç³»ãƒ„ãƒªãƒ¼]:::done
    descendants[å­å­«ä¸€è¦§]:::done
    treeViz[å®¶ç³»å›³å¯è¦–åŒ–å¼·åŒ–]:::plan
    cache[ã‚­ãƒ£ãƒƒã‚·ãƒ¥(Redis)]:::plan
  end

  subgraph ã‚±ã‚¢
    careList[ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ä¸€è¦§]:::done
    careComplete[å®Œäº†ãƒãƒ¼ã‚¯(PATCH/PUT)]:::done
    careNotify[é€šçŸ¥(ãƒ¡ãƒ¼ãƒ«)]:::plan
    careNext[æ¬¡å›è‡ªå‹•ç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯]:::plan
  end

  subgraph ç¹æ®–
    breedingList[è¨˜éŒ²ä¸€è¦§/ç™»éŒ²]:::done
    consanguine[è¿‘è¦ªäº¤é…æ¤œå‡º]:::plan
    scheduleLink[ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«é€£æº]:::plan
  end

  subgraph ãƒã‚¹ã‚¿
    breedsCRUD[çŒ«ç¨®CRUD(ç®¡ç†è€…)]:::done
    colorsCRUD[æ¯›è‰²CRUD(ç®¡ç†è€…)]:::done
    tags[ã‚¿ã‚°ä½œæˆ/å‰Šé™¤]:::done
    csvUI[CSVä¸€æ‹¬ã‚¤ãƒ³ãƒãƒ¼ãƒˆUI]:::plan
  end

  subgraph å…±é€š/é‹ç”¨
    swaggerDev[Swagger(é–‹ç™º)]:::done
    errorHandling[çµ±ä¸€ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°]:::done
    monitoring[ç›£è¦–/ãƒ­ã‚°é›†ç´„]:::plan
    scale[ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°/æœ¬ç•ªã‚¹ã‚±ãƒ¼ãƒ«]:::plan
  end
```

è¡¨ç¤ºã•ã‚Œãªã„å ´åˆã¯ã€VS Codeã®ã€ŒMarkdown: Enable Mermaidã€ã‚’æœ‰åŠ¹åŒ–ã€ã¾ãŸã¯æœ€æ–°ç‰ˆã®VS Code/æ‹¡å¼µæ©Ÿèƒ½ã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚
`````

## File: docs/diagrams/system-architecture.md
`````markdown
# ğŸ“Š ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆå›³

## ğŸ—ï¸ å…¨ä½“ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆæ¦‚è¦å›³

```mermaid
graph TB
    subgraph "ãƒ¦ãƒ¼ã‚¶ãƒ¼"
        U1[ãƒ–ãƒªãƒ¼ãƒ€ãƒ¼]
        U2[ç®¡ç†è€…]
        U3[ç£åŒ»å¸«]
    end
    
    subgraph "ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰å±¤"
        FE[Next.js Frontend<br/>Port: 3000]
        UI[Mantine UI<br/>ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ]
    end
    
    subgraph "ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰å±¤"
        API[NestJS API Server<br/>Port: 3004]
        AUTH[èªè¨¼ã‚µãƒ¼ãƒ“ã‚¹<br/>JWT]
        VALID[ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³<br/>Class Validator]
    end
    
    subgraph "ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯å±¤"
        CAT[çŒ«ç®¡ç†ã‚µãƒ¼ãƒ“ã‚¹]
        PED[è¡€çµ±ç®¡ç†ã‚µãƒ¼ãƒ“ã‚¹]
        BREED[ç¹æ®–ç®¡ç†ã‚µãƒ¼ãƒ“ã‚¹]
        CARE[ã‚±ã‚¢ç®¡ç†ã‚µãƒ¼ãƒ“ã‚¹]
        TAG[ã‚¿ã‚°ç®¡ç†ã‚µãƒ¼ãƒ“ã‚¹]
    end
    
    subgraph "ãƒ‡ãƒ¼ã‚¿å±¤"
        ORM[Prisma ORM]
        DB[(PostgreSQL<br/>Database)]
        CACHE[(Redis Cache<br/>â€»å°†æ¥å®Ÿè£…)]
    end
    
    subgraph "å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹"
        MAIL[ãƒ¡ãƒ¼ãƒ«é€šçŸ¥<br/>â€»å°†æ¥å®Ÿè£…]
        FILE[ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸<br/>â€»å°†æ¥å®Ÿè£…]
    end
    
    U1 --> FE
    U2 --> FE
    U3 --> FE
    
    FE --> UI
    FE --> API
    
    API --> AUTH
    API --> VALID
    AUTH --> CAT
    AUTH --> PED
    AUTH --> BREED
    AUTH --> CARE
    AUTH --> TAG
    
    CAT --> ORM
    PED --> ORM
    BREED --> ORM
    CARE --> ORM
    TAG --> ORM
    
    ORM --> DB
    ORM --> CACHE
    
    CARE --> MAIL
    CAT --> FILE
```

### ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ§‹æˆå›³

```mermaid
graph LR
    subgraph "ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ"
        PC[PC ãƒ–ãƒ©ã‚¦ã‚¶]
        MOBILE[ãƒ¢ãƒã‚¤ãƒ« ãƒ–ãƒ©ã‚¦ã‚¶]
    end
    
    subgraph "Webã‚µãƒ¼ãƒãƒ¼"
        NGINX[Nginx<br/>ãƒªãƒãƒ¼ã‚¹ãƒ—ãƒ­ã‚­ã‚·]
    end
    
    subgraph "ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚µãƒ¼ãƒãƒ¼"
        NEXT[Next.js<br/>:3000]
        NEST[NestJS<br/>:3004]
    end
    
    subgraph "ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚µãƒ¼ãƒãƒ¼"
        POSTGRES[(PostgreSQL<br/>:5432)]
    end
    
    PC --> NGINX
    MOBILE --> NGINX
    
    NGINX --> NEXT
    NGINX --> NEST
    
    NEXT --> NEST
    NEST --> POSTGRES
```

## ğŸ”§ ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆæ§‹æˆ

### é–‹ç™ºç’°å¢ƒæ§‹æˆ

```mermaid
graph TB
    subgraph "é–‹ç™ºè€…PC"
        DEV_FE[Next.js Dev Server<br/>localhost:3000]
        DEV_BE[NestJS Dev Server<br/>localhost:3004]
        DEV_DB[(PostgreSQL<br/>localhost:5432)]
    end
    
    DEV_FE --> DEV_BE
    DEV_BE --> DEV_DB
    
    DEV_FE -.-> |Hot Reload| DEV_FE
    DEV_BE -.-> |Watch Mode| DEV_BE
```

### ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°ç’°å¢ƒæ§‹æˆ

```mermaid
graph TB
    subgraph "ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°ã‚µãƒ¼ãƒãƒ¼"
        STG_NGINX[Nginx]
        STG_FE[Next.js Build<br/>:3000]
        STG_BE[NestJS Production<br/>:3004]
        STG_DB[(PostgreSQL<br/>:5432)]
    end
    
    STG_NGINX --> STG_FE
    STG_NGINX --> STG_BE
    STG_FE --> STG_BE
    STG_BE --> STG_DB
```

### æœ¬ç•ªç’°å¢ƒæ§‹æˆï¼ˆå°†æ¥ï¼‰

```mermaid
graph TB
    subgraph "Load Balancer"
        LB[ALB / Nginx]
    end
    
    subgraph "Web Tier"
        WEB1[Web Server 1]
        WEB2[Web Server 2]
    end
    
    subgraph "App Tier"
        APP1[App Server 1]
        APP2[App Server 2]
    end
    
    subgraph "Cache Tier"
        REDIS[(Redis Cluster)]
    end
    
    subgraph "Database Tier"
        DB_MASTER[(PostgreSQL<br/>Master)]
        DB_SLAVE[(PostgreSQL<br/>Read Replica)]
    end
    
    subgraph "Storage"
        S3[Object Storage<br/>Images/Files]
    end
    
    LB --> WEB1
    LB --> WEB2
    
    WEB1 --> APP1
    WEB2 --> APP2
    
    APP1 --> REDIS
    APP2 --> REDIS
    
    APP1 --> DB_MASTER
    APP2 --> DB_MASTER
    APP1 --> DB_SLAVE
    APP2 --> DB_SLAVE
    
    APP1 --> S3
    APP2 --> S3
```

## ğŸ›¡ï¸ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ§‹æˆ

### èªè¨¼ãƒ»èªå¯ãƒ•ãƒ­ãƒ¼

```mermaid
sequenceDiagram
    participant U as User
    participant F as Frontend
    participant A as Auth API
    participant B as Business API
    participant D as Database
    
    U->>F: ãƒ­ã‚°ã‚¤ãƒ³è¦æ±‚
    F->>A: èªè¨¼æƒ…å ±é€ä¿¡
    A->>D: ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¤œè¨¼
    D-->>A: èªè¨¼çµæœ
    A-->>F: JWT Tokenç™ºè¡Œ
    
    Note over F: Tokenã‚’ãƒ¡ãƒ¢ãƒªã«ä¿å­˜
    
    U->>F: APIè¦æ±‚
    F->>B: Request + JWT
    B->>B: Tokenæ¤œè¨¼
    B->>D: èªå¯æ¸ˆã¿ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹
    D-->>B: ãƒ‡ãƒ¼ã‚¿è¿”å´
    B-->>F: ãƒ¬ã‚¹ãƒãƒ³ã‚¹
    F-->>U: ç”»é¢è¡¨ç¤º
```

### ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡

```mermaid
graph TB
    subgraph "ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«"
        ADMIN[ç®¡ç†è€…<br/>å…¨ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹]
        BREEDER[ãƒ–ãƒªãƒ¼ãƒ€ãƒ¼<br/>è‡ªåˆ†ã®ãƒ‡ãƒ¼ã‚¿ã®ã¿]
        VET[ç£åŒ»å¸«<br/>å¥åº·ãƒ‡ãƒ¼ã‚¿ã®ã¿]
        VIEWER[é–²è¦§è€…<br/>å‚ç…§ã®ã¿]
    end
    
    subgraph "ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™"
        CAT_CRUD[çŒ«ãƒ‡ãƒ¼ã‚¿ CRUD]
        PED_CRUD[è¡€çµ±ãƒ‡ãƒ¼ã‚¿ CRUD]
        CARE_CRUD[ã‚±ã‚¢ãƒ‡ãƒ¼ã‚¿ CRUD]
        BREED_CRUD[ç¹æ®–ãƒ‡ãƒ¼ã‚¿ CRUD]
        
        CAT_READ[çŒ«ãƒ‡ãƒ¼ã‚¿ å‚ç…§]
        PED_READ[è¡€çµ±ãƒ‡ãƒ¼ã‚¿ å‚ç…§]
        CARE_READ[ã‚±ã‚¢ãƒ‡ãƒ¼ã‚¿ å‚ç…§]
        BREED_READ[ç¹æ®–ãƒ‡ãƒ¼ã‚¿ å‚ç…§]
    end
    
    ADMIN --> CAT_CRUD
    ADMIN --> PED_CRUD
    ADMIN --> CARE_CRUD
    ADMIN --> BREED_CRUD
    
    BREEDER --> CAT_CRUD
    BREEDER --> PED_CRUD
    BREEDER --> CARE_CRUD
    BREEDER --> BREED_CRUD
    
    VET --> CAT_READ
    VET --> CARE_CRUD
    
    VIEWER --> CAT_READ
    VIEWER --> PED_READ
    VIEWER --> CARE_READ
    VIEWER --> BREED_READ
```

## ğŸ“Š ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼å›³

### çŒ«ç™»éŒ²ãƒ•ãƒ­ãƒ¼

```mermaid
graph TD
    A[çŒ«æƒ…å ±å…¥åŠ›] --> B[ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³]
    B --> C[APIé€ä¿¡]
    C --> D[ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³]
    D --> E[é‡è¤‡ãƒã‚§ãƒƒã‚¯]
    E --> F[ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ä¿å­˜]
    F --> G[è¡€çµ±æ›¸è‡ªå‹•ä½œæˆ]
    G --> H[ãƒ¬ã‚¹ãƒãƒ³ã‚¹è¿”å´]
    H --> I[ç”»é¢æ›´æ–°]
    
    E -.-> |é‡è¤‡ã‚¨ãƒ©ãƒ¼| J[ã‚¨ãƒ©ãƒ¼è¡¨ç¤º]
    D -.-> |ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼| J
    
    style A fill:#e1f5fe
    style I fill:#c8e6c9
    style J fill:#ffcdd2
```

### è¡€çµ±æ¤œç´¢ãƒ•ãƒ­ãƒ¼

```mermaid
graph TD
    A[æ¤œç´¢æ¡ä»¶å…¥åŠ›] --> B[ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰å‰å‡¦ç†]
    B --> C[APIè¦æ±‚]
    C --> D[ã‚¯ã‚¨ãƒªæ§‹ç¯‰]
    D --> E[ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¤œç´¢]
    E --> F[è¡€çµ±é–¢ä¿‚æ§‹ç¯‰]
    F --> G[å®¶ç³»å›³ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ]
    G --> H[ãƒ¬ã‚¹ãƒãƒ³ã‚¹è¿”å´]
    H --> I[å®¶ç³»å›³è¡¨ç¤º]
    
    E --> |ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç¢ºèª| K[Redis Cache]
    K -.-> |ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆ| G
    K -.-> |ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒŸã‚¹| E
    
    style A fill:#e1f5fe
    style I fill:#c8e6c9
```

### ç¹æ®–ç®¡ç†ãƒ•ãƒ­ãƒ¼

```mermaid
graph TD
    A[äº¤é…è¨ˆç”»å…¥åŠ›] --> B[è¡€çµ±é©åˆæ€§ãƒã‚§ãƒƒã‚¯]
    B --> C[è¿‘è¦ªäº¤é…è­¦å‘Š]
    C --> D[äº¤é…è¨˜éŒ²ä¿å­˜]
    D --> E[å¦Šå¨ æœŸé–“è¨ˆç®—]
    E --> F[å‡ºç”£äºˆå®šæ—¥è¨­å®š]
    F --> G[ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«è‡ªå‹•ä½œæˆ]
    G --> H[é€šçŸ¥ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«è¨­å®š]
    H --> I[å®Œäº†é€šçŸ¥]
    
    B -.-> |ä¸é©åˆ| J[è­¦å‘Šè¡¨ç¤º]
    C -.-> |è¿‘è¦ªäº¤é…æ¤œå‡º| K[ã‚¢ãƒ©ãƒ¼ãƒˆè¡¨ç¤º]
    
    style A fill:#e1f5fe
    style I fill:#c8e6c9
    style J fill:#fff3e0
    style K fill:#ffcdd2
```

## ğŸ”„ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ»ç½å®³å¾©æ—§

### ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ§‹æˆ

```mermaid
graph TB
    subgraph "æœ¬ç•ªã‚·ã‚¹ãƒ†ãƒ "
        PROD_DB[(æœ¬ç•ªDB)]
        PROD_FILES[ã‚¢ãƒ—ãƒªãƒ•ã‚¡ã‚¤ãƒ«]
    end
    
    subgraph "ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸"
        BACKUP_DB[(DBãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—<br/>æ—¥æ¬¡ãƒ»é€±æ¬¡)]
        BACKUP_FILES[ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—<br/>æ—¥æ¬¡)]
        BACKUP_CONFIG[è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«<br/>å¤‰æ›´æ™‚)]
    end
    
    subgraph "ã‚ªãƒ•ã‚µã‚¤ãƒˆã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸"
        OFFSITE_DB[(ãƒªãƒ¢ãƒ¼ãƒˆDBãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—<br/>é€±æ¬¡)]
        OFFSITE_FILES[ãƒªãƒ¢ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«<br/>é€±æ¬¡)]
    end
    
    PROD_DB -.-> |pg_dump| BACKUP_DB
    PROD_FILES -.-> |tar/rsync| BACKUP_FILES
    PROD_FILES -.-> |git| BACKUP_CONFIG
    
    BACKUP_DB -.-> |è»¢é€| OFFSITE_DB
    BACKUP_FILES -.-> |è»¢é€| OFFSITE_FILES
```

### ç½å®³å¾©æ—§æ‰‹é †

```mermaid
graph TD
    A[éšœå®³æ¤œçŸ¥] --> B[éšœå®³ãƒ¬ãƒ™ãƒ«åˆ¤å®š]
    B --> C{å¾©æ—§æ–¹æ³•é¸æŠ}
    
    C -->|ãƒ¬ãƒ™ãƒ«1<br/>ã‚¢ãƒ—ãƒªå†èµ·å‹•| D[ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å†èµ·å‹•]
    C -->|ãƒ¬ãƒ™ãƒ«2<br/>ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯| E[å‰ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯]
    C -->|ãƒ¬ãƒ™ãƒ«3<br/>ãƒ‡ãƒ¼ã‚¿å¾©æ—§| F[ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰DBå¾©æ—§]
    C -->|ãƒ¬ãƒ™ãƒ«4<br/>ã‚·ã‚¹ãƒ†ãƒ å†æ§‹ç¯‰| G[ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“å†æ§‹ç¯‰]
    
    D --> H[å‹•ä½œç¢ºèª]
    E --> H
    F --> H
    G --> H
    
    H --> I{æ­£å¸¸?}
    I -->|Yes| J[å¾©æ—§å®Œäº†]
    I -->|No| K[ä¸Šä½ãƒ¬ãƒ™ãƒ«å¾©æ—§å®Ÿè¡Œ]
    K --> C
    
    style A fill:#ffcdd2
    style J fill:#c8e6c9
```

## ğŸ“± å°†æ¥æ‹¡å¼µæ§‹æˆ

### ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹åŒ–ï¼ˆå°†æ¥ï¼‰

```mermaid
graph TB
    subgraph "API Gateway"
        GW[API Gateway<br/>èªè¨¼ãƒ»ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°]
    end
    
    subgraph "ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹"
        USER_SVC[ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç†<br/>ã‚µãƒ¼ãƒ“ã‚¹]
        CAT_SVC[çŒ«ç®¡ç†<br/>ã‚µãƒ¼ãƒ“ã‚¹]
        PED_SVC[è¡€çµ±ç®¡ç†<br/>ã‚µãƒ¼ãƒ“ã‚¹]
        BREED_SVC[ç¹æ®–ç®¡ç†<br/>ã‚µãƒ¼ãƒ“ã‚¹]
        CARE_SVC[ã‚±ã‚¢ç®¡ç†<br/>ã‚µãƒ¼ãƒ“ã‚¹]
        NOTIFY_SVC[é€šçŸ¥<br/>ã‚µãƒ¼ãƒ“ã‚¹]
    end
    
    subgraph "ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆã‚¢"
        USER_DB[(ãƒ¦ãƒ¼ã‚¶ãƒ¼DB)]
        CAT_DB[(çŒ«ãƒ‡ãƒ¼ã‚¿DB)]
        PED_DB[(è¡€çµ±DB)]
        BREED_DB[(ç¹æ®–DB)]
        CARE_DB[(ã‚±ã‚¢DB)]
    end
    
    subgraph "å…±é€šã‚µãƒ¼ãƒ“ã‚¹"
        MESSAGE_Q[ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚­ãƒ¥ãƒ¼]
        CONFIG_SVC[è¨­å®šç®¡ç†]
        LOG_SVC[ãƒ­ã‚°é›†ç´„]
    end
    
    GW --> USER_SVC
    GW --> CAT_SVC
    GW --> PED_SVC
    GW --> BREED_SVC
    GW --> CARE_SVC
    
    USER_SVC --> USER_DB
    CAT_SVC --> CAT_DB
    PED_SVC --> PED_DB
    BREED_SVC --> BREED_DB
    CARE_SVC --> CARE_DB
    
    CARE_SVC --> MESSAGE_Q
    MESSAGE_Q --> NOTIFY_SVC
    
    USER_SVC --> CONFIG_SVC
    CAT_SVC --> CONFIG_SVC
    PED_SVC --> CONFIG_SVC
    
    USER_SVC --> LOG_SVC
    CAT_SVC --> LOG_SVC
    PED_SVC --> LOG_SVC
```

---

**å›³è¡¨ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 1.0  
**æœ€çµ‚æ›´æ–°æ—¥**: 2025å¹´8æœˆ9æ—¥  
**ä½œæˆè€…**: ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆãƒãƒ¼ãƒ 
`````

## File: docs/api-specification.md
`````markdown
# ğŸ”Œ APIä»•æ§˜æ›¸

## ğŸ“‹ APIæ¦‚è¦

**ãƒ™ãƒ¼ã‚¹URL**: `http://localhost:3004/api/v1`  
**èªè¨¼æ–¹å¼**: JWT Bearer Token  
**ãƒ‡ãƒ¼ã‚¿å½¢å¼**: JSON  
**æ–‡å­—ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°**: UTF-8

### å…±é€šãƒ¬ã‚¹ãƒãƒ³ã‚¹ä»•æ§˜ï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«é©ç”¨ï¼‰

- æˆåŠŸæ™‚: `{ success: true, data: <payload>, meta?: <pagination> }`
- å¤±æ•—æ™‚: `{ success: false, error: { code, message, details? }, timestamp, path }`
- å‚™è€ƒ: NestJS ã® Global Interceptor/Exception Filter ã«ã‚ˆã‚Šå…¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¸è‡ªå‹•é©ç”¨ã€‚
  - TransformResponseInterceptor: ä»»æ„ã®æˆ»ã‚Šå€¤ã‚’ `{ success: true, data }` ã¸çµ±ä¸€ã€‚`{ data, meta }` æ§‹é€ ã¯ `meta` ã‚’ä¿æŒã€‚
  - GlobalExceptionFilter: ä¾‹å¤–ã‚’ `{ success: false, error: ... }` ã¸çµ±ä¸€ã€‚Prisma ã®ä»£è¡¨çš„ãªã‚¨ãƒ©ãƒ¼ï¼ˆP2002/2025/2003/2014ï¼‰ã‚’HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã¨ã‚³ãƒ¼ãƒ‰ã¸ãƒãƒƒãƒ”ãƒ³ã‚°ã€‚

## ğŸ” èªè¨¼

### èªè¨¼ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ

å…±é€šãƒãƒªã‚·ãƒ¼:

- emailã¯å—ä¿¡æ™‚ã« trim + lowercase ã§æ­£è¦åŒ–ã—ã¾ã™ï¼ˆå¤§æ–‡å­—å°æ–‡å­—ãƒ»å‰å¾Œç©ºç™½ã®å·®ç•°ã‚’è¨±å®¹ï¼‰ã€‚
- ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¤œç´¢ã¯ unique åˆ¶ç´„ã«å¾“ã„ findUnique(email) ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
- ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯å¼·åº¦æ¤œè¨¼å¾Œã« Argon2 ã§ãƒãƒƒã‚·ãƒ¥åŒ–ä¿å­˜ã—ã¾ã™ï¼ˆæ—§bcryptã‹ã‚‰ã¯ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸæ™‚ã«è‡ªå‹•ç§»è¡Œï¼‰ã€‚

#### POST /auth/login

ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ã‚°ã‚¤ãƒ³

##### ãƒªã‚¯ã‚¨ã‚¹ãƒˆ: POST /auth/login

```json
{ "email": "user@example.com", "password": "password123" }
```

##### ãƒ¬ã‚¹ãƒãƒ³ã‚¹: POST /auth/login

```json
{
  "success": true,
  "data": {
    "access_token": "<jwt>",
    "refresh_token": "<jwt>",
    "user": { "id": "user-123", "email": "user@example.com", "role": "breeder" }
  }
}
```

#### POST /auth/refresh

ãƒˆãƒ¼ã‚¯ãƒ³ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥

##### ãƒªã‚¯ã‚¨ã‚¹ãƒˆ: POST /auth/refresh

```json
{ "refresh_token": "<jwt>" }
```

##### ãƒ¬ã‚¹ãƒãƒ³ã‚¹: POST /auth/refresh

```json
{
  "success": true,
  "data": {
    "access_token": "<jwt>",
    "refresh_token": "<jwt>"
  }
}
```

#### POST /auth/register

ãƒãƒªã‚·ãƒ¼:

- ãƒ¡ãƒ¼ãƒ«ã¯æ­£è¦åŒ–å¾Œã«ä¸€æ„åˆ¶ç´„ã§é‡è¤‡ã‚’æ¤œå‡ºã—ã€æ—¢å­˜ã®å ´åˆ 409(CONFLICT) ã‚’è¿”ã—ã¾ã™ã€‚
- ä½œæˆæ™‚ã«å†…éƒ¨ç”¨ã® clerkId ã‚’è‡ªå‹•æ¡ç•ªï¼ˆä¾‹: `local_<uuid>`ï¼‰ã€‚

##### ãƒªã‚¯ã‚¨ã‚¹ãƒˆ: POST /auth/register

```json
{ "email": "User@example.com ", "password": "Secret123!" }
```

##### ãƒ¬ã‚¹ãƒãƒ³ã‚¹: POST /auth/register

```json
{ "success": true, "data": { "id": "user-123", "email": "user@example.com" } }
```

ã‚¨ãƒ©ãƒ¼ä¾‹:

- 409 CONFLICT: æ—¢ã«ç™»éŒ²æ¸ˆã¿ã®ãƒ¡ãƒ¼ãƒ«
- 400 BAD_REQUEST: ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¼·åº¦ä¸è¶³

#### POST /auth/request-password-reset

#### POST /auth/set-password

ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰è¨­å®šï¼ˆåˆå›/å†è¨­å®šãƒªãƒ³ã‚¯çµŒç”±ãªã©ï¼‰

#### POST /auth/change-password

ãƒ­ã‚°ã‚¤ãƒ³ä¸­ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¤‰æ›´

#### POST /auth/logout

ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã®ç„¡åŠ¹åŒ–ã¨ã‚µã‚¤ãƒ³ã‚¢ã‚¦ãƒˆå‡¦ç†

ãƒãƒªã‚·ãƒ¼: ãƒ¡ãƒ¼ãƒ«ã®å­˜åœ¨æœ‰ç„¡ã«é–¢ã‚ã‚‰ãšæˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ï¼ˆåˆ©ç”¨è€…æ¨æ¸¬é˜²æ­¢ï¼‰ã€‚

##### ãƒªã‚¯ã‚¨ã‚¹ãƒˆ: POST /auth/request-password-reset

```json
{ "email": "user@example.com" }
```

## ğŸ± çŒ«ç®¡ç†API

### GET /cats

çŒ«ä¸€è¦§å–å¾—

#### ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿: GET /cats

| ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ | å‹     | å¿…é ˆ | èª¬æ˜                            |
| ---------- | ------ | ---- | ------------------------------- |
| page       | number | -    | ãƒšãƒ¼ã‚¸ç•ªå·ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 1ï¼‰     |
| limit      | number | -    | å–å¾—ä»¶æ•°ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 20ï¼‰      |
| search     | string | -    | åå‰ã§ã®æ¤œç´¢                    |
| breed_id   | string | -    | çŒ«ç¨®ã§ã®ãƒ•ã‚£ãƒ«ã‚¿                |
| gender     | string | -    | æ€§åˆ¥ã§ã®ãƒ•ã‚£ãƒ«ã‚¿ï¼ˆmale/femaleï¼‰ |
| status     | string | -    | ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã§ã®ãƒ•ã‚£ãƒ«ã‚¿          |

#### ãƒ¬ã‚¹ãƒãƒ³ã‚¹: GET /cats

```json
{
  "success": true,
  "data": [
    {
      "id": "cat-123",
      "name": "ã¿ã‘",
      "birth_date": "2023-06-15",
      "gender": "female",
      "breed": {
        "id": "breed-001",
        "name_ja": "æ—¥æœ¬çŒ«",
        "name_en": "Japanese Bobtail"
      },
      "coat_color": {
        "id": "color-001",
        "name_ja": "ä¸‰æ¯›",
        "name_en": "Calico"
      },
      "status": "active",
      "microchip_id": "392123456789012",
      "created_at": "2024-01-15T10:30:00Z"
    }
  ],
  "meta": {
    "total": 156,
    "page": 1,
    "limit": 20,
    "total_pages": 8
  }
}
```

### POST /cats

çŒ«æ–°è¦ç™»éŒ²

#### ãƒªã‚¯ã‚¨ã‚¹ãƒˆ: POST /cats

```json
{
  "name": "ãŸã¾",
  "birth_date": "2024-03-20",
  "gender": "male",
  "breed_id": "breed-002",
  "coat_color_id": "color-005",
  "microchip_id": "392123456789013",
  "notes": "æ€§æ ¼ã¯äººæ‡ã£ã“ã„"
}
```

#### ãƒ¬ã‚¹ãƒãƒ³ã‚¹: POST /cats

```json
{
  "success": true,
  "data": {
    "id": "cat-124",
    "name": "ãŸã¾",
    "birth_date": "2024-03-20",
    "gender": "male",
    // ... ä»–ã®çŒ«æƒ…å ±
    "created_at": "2024-08-09T10:30:00Z"
  }
}
```

### GET /cats/:id

çŒ«è©³ç´°å–å¾—

#### ãƒ¬ã‚¹ãƒãƒ³ã‚¹: GET /cats/:id

```json
{
  "success": true,
  "data": {
    "id": "cat-123",
    "name": "ã¿ã‘",
    "birth_date": "2023-06-15",
    "gender": "female",
    "breed": {
      /* breed info */
    },
    "coat_color": {
      /* coat color info */
    },
    "pedigree": {
      "id": "ped-123",
      "registration_number": "JCR2023-001234",
      "father": {
        /* father cat info */
      },
      "mother": {
        /* mother cat info */
      }
    },
    "care_schedules": [
      {
        "id": "care-001",
        "care_type": "vaccination",
        "scheduled_date": "2024-09-01",
        "status": "pending"
      }
    ],
    "tags": [
      {
        "id": "tag-001",
        "name": "äººæ‡ã£ã“ã„",
        "category": "personality",
        "color": "#ff6b6b"
      }
    ]
  }
}
```

### PUT /cats/:id

çŒ«æƒ…å ±æ›´æ–°

#### ãƒªã‚¯ã‚¨ã‚¹ãƒˆ: PUT /cats/:id

```json
{
  "name": "ã¿ã‘ã¡ã‚ƒã‚“",
  "notes": "æ›´æ–°ã•ã‚ŒãŸãƒ¡ãƒ¢",
  "status": "active"
}
```

### DELETE /cats/:id

### GET /cats/statistics

çµ±è¨ˆæƒ…å ±ã®å–å¾—ï¼ˆå®Ÿè£…ã‚ã‚Šï¼‰

### GET /cats/:id/breeding-history

å€‹ä½“ã®ç¹æ®–å±¥æ­´ï¼ˆå®Ÿè£…ã‚ã‚Šï¼‰

### GET /cats/:id/care-history

å€‹ä½“ã®ã‚±ã‚¢å±¥æ­´ï¼ˆå®Ÿè£…ã‚ã‚Šï¼‰

çŒ«æƒ…å ±å‰Šé™¤ï¼ˆè«–ç†å‰Šé™¤ï¼‰

## ğŸ“œ è¡€çµ±æ›¸ç®¡ç†API

### GET /pedigrees

è¡€çµ±æ›¸ä¸€è¦§å–å¾—

#### ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿: GET /pedigrees

| ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ | å‹     | å¿…é ˆ | èª¬æ˜                     |
| ---------- | ------ | ---- | ------------------------ |
| page       | number | -    | ãƒšãƒ¼ã‚¸ç•ªå·               |
| limit      | number | -    | å–å¾—ä»¶æ•°                 |
| search     | string | -    | è¡€çµ±æ›¸ç•ªå·ãƒ»çŒ«åã§ã®æ¤œç´¢ |
| generation | number | -    | ä¸–ä»£ã§ã®çµã‚Šè¾¼ã¿         |

#### ãƒ¬ã‚¹ãƒãƒ³ã‚¹: GET /pedigrees

```json
{
  "success": true,
  "data": [
    {
      "id": "ped-123",
      "cat": {
        "id": "cat-123",
        "name": "ã¿ã‘"
      },
      "registration_number": "JCR2023-001234",
      "father": {
        "id": "cat-100",
        "name": "çˆ¶çŒ«å¤ªéƒ",
        "registration_number": "JCR2021-005678"
      },
      "mother": {
        "id": "cat-101",
        "name": "æ¯çŒ«èŠ±å­",
        "registration_number": "JCR2022-001111"
      },
      "generation": 3,
      "created_at": "2024-01-15T10:30:00Z"
    }
  ],
  "meta": {
    /* pagination info */
  }
}
```

### POST /pedigrees

è¡€çµ±æ›¸æ–°è¦ç™»éŒ²

#### ãƒªã‚¯ã‚¨ã‚¹ãƒˆ: POST /pedigrees

```json
{
  "cat_id": "cat-123",
  "registration_number": "JCR2024-002345",
  "father_id": "cat-100",
  "mother_id": "cat-101",
  "breeder_name": "å±±ç”°ãƒ–ãƒªãƒ¼ãƒ€ãƒ¼",
  "registration_date": "2024-08-01"
}
```

### GET /pedigrees/:id/family-tree

å®¶ç³»å›³å–å¾—ï¼ˆæŒ‡å®šä¸–ä»£ã¾ã§ï¼‰

#### ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿: GET /pedigrees/:id/family-tree

| ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿  | å‹     | å¿…é ˆ | èª¬æ˜                        |
| ----------- | ------ | ---- | --------------------------- |
| generations | number | -    | å–å¾—ä¸–ä»£æ•°ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 3ï¼‰ |

#### ãƒ¬ã‚¹ãƒãƒ³ã‚¹: GET /pedigrees/:id/family-tree

### GET /pedigrees/pedigree-id/:pedigreeId

è¡€çµ±æ›¸ç•ªå·ã‹ã‚‰æ¤œç´¢ï¼ˆå®Ÿè£…ã‚ã‚Šï¼‰

### GET /pedigrees/:id/family

ç›´ç³»ã®è¦ªæƒ…å ±ãƒ„ãƒªãƒ¼ï¼ˆå®Ÿè£…ã‚ã‚Šï¼‰

### GET /pedigrees/:id/descendants

å­å­«ä¸€è¦§ï¼ˆå®Ÿè£…ã‚ã‚Šï¼‰

```json
{
  "success": true,
  "data": {
    "root": {
      "id": "cat-123",
      "name": "ã¿ã‘",
      "generation": 0
    },
    "ancestors": [
      {
        "id": "cat-100",
        "name": "çˆ¶çŒ«å¤ªéƒ",
        "generation": 1,
        "relationship": "father",
        "parent_id": "cat-123"
      },
      {
        "id": "cat-101",
        "name": "æ¯çŒ«èŠ±å­",
        "generation": 1,
        "relationship": "mother",
        "parent_id": "cat-123"
      }
      // ... ç¥–çˆ¶æ¯ä¸–ä»£ä»¥é™
    ]
  }
}
```

## ğŸ’• ç¹æ®–ç®¡ç†API

### GET /breeding

ç¹æ®–è¨˜éŒ²ä¸€è¦§å–å¾—

#### ãƒ¬ã‚¹ãƒãƒ³ã‚¹: GET /breeding

```json
{
  "success": true,
  "data": [
    {
      "id": "breed-001",
      "mother": {
        "id": "cat-101",
        "name": "æ¯çŒ«èŠ±å­"
      },
      "father": {
        "id": "cat-100",
        "name": "çˆ¶çŒ«å¤ªéƒ"
      },
      "mating_date": "2024-06-01",
      "expected_birth_date": "2024-08-01",
      "actual_birth_date": "2024-08-03",
      "kitten_count": 4,
      "status": "completed",
      "notes": "é †èª¿ãªå‡ºç”£ã§ã—ãŸ"
    }
  ],
  "meta": {
    /* pagination info */
  }
}
```

### POST /breeding

ç¹æ®–è¨˜éŒ²æ–°è¦ç™»éŒ²

#### ãƒªã‚¯ã‚¨ã‚¹ãƒˆ: POST /breeding

```json
{
  "mother_id": "cat-101",
  "father_id": "cat-100",
  "mating_date": "2024-06-01",
  "expected_birth_date": "2024-08-01",
  "notes": "åˆå›äº¤é…"
}
```

## ğŸ¥ ã‚±ã‚¢ç®¡ç†API

### GET /care/schedules

ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ä¸€è¦§å–å¾—

#### ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿: GET /care/schedules

| ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ | å‹     | å¿…é ˆ | èª¬æ˜                   |
| ---------- | ------ | ---- | ---------------------- |
| cat_id     | string | -    | ç‰¹å®šã®çŒ«ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ« |
| care_type  | string | -    | ã‚±ã‚¢ç¨®åˆ¥ã§ã®ãƒ•ã‚£ãƒ«ã‚¿   |
| status     | string | -    | ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã§ã®ãƒ•ã‚£ãƒ«ã‚¿ |
| date_from  | string | -    | é–‹å§‹æ—¥ï¼ˆYYYY-MM-DDï¼‰   |
| date_to    | string | -    | çµ‚äº†æ—¥ï¼ˆYYYY-MM-DDï¼‰   |

#### ãƒ¬ã‚¹ãƒãƒ³ã‚¹: GET /care/schedules

```json
{
  "success": true,
  "data": [
    {
      "id": "care-001",
      "cat": {
        "id": "cat-123",
        "name": "ã¿ã‘"
      },
      "care_type": "vaccination",
      "care_name": "3ç¨®æ··åˆãƒ¯ã‚¯ãƒãƒ³",
      "scheduled_date": "2024-09-01",
      "completed_date": null,
      "status": "pending",
      "notes": "å¹´1å›ã®å®šæœŸæ¥ç¨®",
      "reminder_sent": false
    }
  ],
  "meta": {
    /* pagination info */
  }
}
```

### POST /care/schedules

ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«æ–°è¦ç™»éŒ²

#### ãƒªã‚¯ã‚¨ã‚¹ãƒˆ: POST /care/schedules

```json
{
  "cat_id": "cat-123",
  "care_type": "vaccination",
  "care_name": "3ç¨®æ··åˆãƒ¯ã‚¯ãƒãƒ³",
  "scheduled_date": "2024-09-01",
  "notes": "å¹´1å›ã®å®šæœŸæ¥ç¨®"
}
```

### PATCH/PUT /care/schedules/:id/completeï¼ˆå®Ÿè£…ã‚ã‚Šï¼‰

ã‚±ã‚¢å®Œäº†ãƒãƒ¼ã‚¯ï¼ˆPATCH/PUTã©ã¡ã‚‰ã§ã‚‚å¯ï¼‰

#### ãƒªã‚¯ã‚¨ã‚¹ãƒˆ: PUT /care/schedules/:id/complete

```json
{
  "completed_date": "2024-08-09",
  "notes": "å•é¡Œãªãå®Œäº†",
  "next_scheduled_date": "2025-08-09"
}
```

## ğŸ·ï¸ ã‚¿ã‚°ãƒ»ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿API

### GET /tags

### POST /tagsï¼ˆå®Ÿè£…ã‚ã‚Šï¼‰

ã‚¿ã‚°ã®ä½œæˆï¼ˆèªè¨¼å¿…é ˆï¼‰

### DELETE /tags/:idï¼ˆå®Ÿè£…ã‚ã‚Šï¼‰

ã‚¿ã‚°ã®å‰Šé™¤ï¼ˆèªè¨¼å¿…é ˆï¼‰

ã‚¿ã‚°ä¸€è¦§å–å¾—

#### ãƒ¬ã‚¹ãƒãƒ³ã‚¹: GET /tags

```json
{
  "success": true,
  "data": [
    {
      "id": "tag-001",
      "name": "äººæ‡ã£ã“ã„",
      "category": "personality",
      "color": "#ff6b6b",
      "description": "äººã«è‰¯ãæ‡ãæ€§æ ¼",
      "usage_count": 23
    }
  ]
}
```

### GET /breeds

### POST /breedsï¼ˆå®Ÿè£…ã‚ã‚Šãƒ»ç®¡ç†è€…ã®ã¿ï¼‰

### PATCH /breeds/:idï¼ˆå®Ÿè£…ã‚ã‚Šãƒ»ç®¡ç†è€…ã®ã¿ï¼‰

### DELETE /breeds/:idï¼ˆå®Ÿè£…ã‚ã‚Šãƒ»ç®¡ç†è€…ã®ã¿ï¼‰

çŒ«ç¨®ãƒã‚¹ã‚¿å–å¾—

#### ãƒ¬ã‚¹ãƒãƒ³ã‚¹: GET /breeds

```json
{
  "success": true,
  "data": [
    {
      "id": "breed-001",
      "name_ja": "æ—¥æœ¬çŒ«",
      "name_en": "Japanese Bobtail",
      "category": "shorthair",
      "description": "æ—¥æœ¬å¤æ¥ã®çŒ«ç¨®"
    }
  ]
}
```

### GET /coat-colors

### POST /coat-colorsï¼ˆå®Ÿè£…ã‚ã‚Šãƒ»ç®¡ç†è€…ã®ã¿ï¼‰

### PATCH /coat-colors/:idï¼ˆå®Ÿè£…ã‚ã‚Šãƒ»ç®¡ç†è€…ã®ã¿ï¼‰

### DELETE /coat-colors/:idï¼ˆå®Ÿè£…ã‚ã‚Šãƒ»ç®¡ç†è€…ã®ã¿ï¼‰

æ¯›è‰²ãƒã‚¹ã‚¿å–å¾—

#### ãƒ¬ã‚¹ãƒãƒ³ã‚¹: GET /coat-colors

```json
{
  "success": true,
  "data": [
    {
      "id": "color-001",
      "name_ja": "ä¸‰æ¯›",
      "name_en": "Calico",
      "color_code": "#F5DEB3",
      "pattern": "tricolor"
    }
  ]
}
```

## âš ï¸ ã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹

### ã‚¨ãƒ©ãƒ¼å½¢å¼

```json
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã«ä¸æ­£ãŒã‚ã‚Šã¾ã™",
    "details": [
      {
        "field": "name",
        "message": "åå‰ã¯å¿…é ˆã§ã™"
      }
    ]
  }
}
```

### ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ä¸€è¦§

| ã‚³ãƒ¼ãƒ‰               | HTTP Status | èª¬æ˜                   |
| -------------------- | ----------- | ---------------------- |
| VALIDATION_ERROR     | 400         | å…¥åŠ›å€¤æ¤œè¨¼ã‚¨ãƒ©ãƒ¼       |
| AUTHENTICATION_ERROR | 401         | èªè¨¼ã‚¨ãƒ©ãƒ¼             |
| AUTHORIZATION_ERROR  | 403         | èªå¯ã‚¨ãƒ©ãƒ¼             |
| NOT_FOUND            | 404         | ãƒªã‚½ãƒ¼ã‚¹ãŒè¦‹ã¤ã‹ã‚‰ãªã„ |
| CONFLICT             | 409         | ãƒ‡ãƒ¼ã‚¿ç«¶åˆã‚¨ãƒ©ãƒ¼       |
| INTERNAL_ERROR       | 500         | ã‚µãƒ¼ãƒãƒ¼å†…éƒ¨ã‚¨ãƒ©ãƒ¼     |

## ğŸ“Š ãƒ¬ãƒ¼ãƒˆåˆ¶é™

- ç¾è¡Œå®Ÿè£…: å…¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå…±é€šã§ 1åˆ†é–“ã«100ãƒªã‚¯ã‚¨ã‚¹ãƒˆï¼ˆThrottlerModuleã®ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®šï¼‰ã€‚
- å°†æ¥å¯¾å¿œ: èªè¨¼ãƒ»ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã«å¯¾ã™ã‚‹å€‹åˆ¥åˆ¶é™ã¯æœªå®Ÿè£…ï¼ˆä»•æ§˜ä¸Šã®ç›®æ¨™å€¤: èªè¨¼10/åˆ†ã€ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰5/åˆ†ï¼‰ã€‚

## ğŸ”„ ãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°

- **ç¾åœ¨**: v1
- **éäº’æ›å¤‰æ›´**: æ–°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã‚µãƒãƒ¼ãƒˆ
- **å¾Œæ–¹äº’æ›**: æœ€ä½6ãƒ¶æœˆã®ã‚µãƒãƒ¼ãƒˆä¿è¨¼

---

**API ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 1.0  
**æœ€çµ‚æ›´æ–°æ—¥**: 2025å¹´8æœˆ15æ—¥ï¼ˆå®Ÿè£…å·®åˆ†åæ˜ ã€å…¨ä½“å›³ãƒªãƒ³ã‚¯è¿½åŠ ï¼‰  
**Swagger UI**: [http://localhost:3004/api/docs](http://localhost:3004/api/docs)
`````

## File: docs/DATABASE_DEPLOYMENT_GUIDE.md
`````markdown
# ğŸš€ æœ¬ç•ªç’°å¢ƒãƒ‡ãƒ—ãƒ­ã‚¤æ™‚ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ§‹ç¯‰æ‰‹é †

## ğŸ“‹ æ¦‚è¦

æœ¬ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ã€çŒ«ç”Ÿä½“ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ï¼ˆMy Catsï¼‰ã‚’æœ¬ç•ªç’°å¢ƒã«ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹éš›ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­å®šãƒ»æ§‹ç¯‰æ‰‹é †ã‚’è©³è¿°ã—ã¦ã„ã¾ã™ã€‚Prismaã‚’ä½¿ç”¨ã—ã¦è‡ªå‹•çš„ã«PostgreSQLãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ã‚¹ã‚­ãƒ¼ãƒãŒç”Ÿæˆã•ã‚Œã¾ã™ã€‚

## ğŸ”§ å‰ææ¡ä»¶

### ã‚·ã‚¹ãƒ†ãƒ è¦ä»¶

- **PostgreSQL**: 15ä»¥ä¸Š
- **Node.js**: 20.xä»¥ä¸Š
- **pnpm**: æœ€æ–°ç‰ˆ
- **ãƒ¡ãƒ¢ãƒª**: æœ€å°2GBã€æ¨å¥¨4GBä»¥ä¸Š
- **ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸**: æœ€å°10GBã€æ¨å¥¨50GBä»¥ä¸Š

### ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯è¦ä»¶

- PostgreSQLãƒãƒ¼ãƒˆï¼ˆ5432ï¼‰ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹
- ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ¼ãƒˆï¼ˆ3004ï¼‰ã®é–‹æ”¾

## ğŸ“ ãƒ‡ãƒ—ãƒ­ã‚¤æ‰‹é †

### 1. ç’°å¢ƒå¤‰æ•°ã®è¨­å®š

æœ¬ç•ªç’°å¢ƒç”¨ã®`.env.production`ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆï¼š

```bash
# ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šï¼ˆå¿…é ˆï¼‰
DATABASE_URL="postgresql://username:password@hostname:5432/mycats_production"

# ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š
NODE_ENV=production
PORT=3004

# JWTè¨­å®šï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£é‡è¦ï¼‰
JWT_SECRET="your-production-jwt-secret-256-bit-minimum"
JWT_EXPIRES_IN="1h"

# CORSè¨­å®š
CORS_ORIGIN="https://yourdomain.com,https://www.yourdomain.com"

# ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®š
BCRYPT_ROUNDS=12

# Prismaè¨­å®š
PRISMA_QUERY_ENGINE_LIBRARY="true"
```

### 2. ä¾å­˜é–¢ä¿‚ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

```bash
# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã§å®Ÿè¡Œ
cd /path/to/mycats

# ä¾å­˜é–¢ä¿‚ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ï¼ˆlockfileä½¿ç”¨ï¼‰
pnpm install --frozen-lockfile

# ã¾ãŸã¯ npm ã®å ´åˆ
npm ci
```

### 3. Prismaã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®ç”Ÿæˆ

```bash
# Prismaã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆç”Ÿæˆ
pnpm -w run db:generate

# å®Ÿè¡Œã•ã‚Œã‚‹ã‚³ãƒãƒ³ãƒ‰:
# dotenv -e ./.env.production -- prisma generate --schema ./backend/prisma/schema.prisma
```

### 4. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ

```bash
# æœ¬ç•ªç’°å¢ƒãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
pnpm -w run db:deploy

# å®Ÿè¡Œã•ã‚Œã‚‹ã‚³ãƒãƒ³ãƒ‰:
# dotenv -e ./.env.production -- prisma migrate deploy --schema ./backend/prisma/schema.prisma
```

### 5. åˆæœŸãƒ‡ãƒ¼ã‚¿æŠ•å…¥ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰

```bash
# ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿æŠ•å…¥
pnpm --filter backend run seed
```

### 6. ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ“ãƒ«ãƒ‰

```bash
# ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒ“ãƒ«ãƒ‰
pnpm --filter backend run build

# ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒ“ãƒ«ãƒ‰
pnpm --filter frontend run build
```

### 7. æœ¬ç•ªã‚µãƒ¼ãƒãƒ¼èµ·å‹•

```bash
# æœ¬ç•ªãƒ¢ãƒ¼ãƒ‰ã§èµ·å‹•
NODE_ENV=production node backend/dist/main.js
```

## ğŸ—„ï¸ ç”Ÿæˆã•ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ§‹é€ 

### è‡ªå‹•ç”Ÿæˆã•ã‚Œã‚‹ãƒ†ãƒ¼ãƒ–ãƒ«ä¸€è¦§

ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œå¾Œã€ä»¥ä¸‹ã®ãƒ†ãƒ¼ãƒ–ãƒ«ãŒPostgreSQLã«è‡ªå‹•ç”Ÿæˆã•ã‚Œã¾ã™ï¼š

```sql
-- 1. ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç†
CREATE TABLE "users" (
  "id" TEXT NOT NULL,
  "clerk_id" TEXT NOT NULL,
  "email" TEXT NOT NULL,
  "first_name" TEXT,
  "last_name" TEXT,
  "role" "UserRole" NOT NULL DEFAULT 'USER',
  "is_active" BOOLEAN NOT NULL DEFAULT true,
  "password_hash" TEXT,
  "refresh_token" TEXT,
  "failed_login_attempts" INTEGER NOT NULL DEFAULT 0,
  "locked_until" TIMESTAMP(3),
  "last_login_at" TIMESTAMP(3),
  "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" TIMESTAMP(3) NOT NULL,
  CONSTRAINT "users_pkey" PRIMARY KEY ("id")
);

-- 2. ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œ
CREATE TABLE "login_attempts" (
  "id" TEXT NOT NULL,
  "user_id" TEXT,
  "email" TEXT NOT NULL,
  "ip_address" TEXT,
  "user_agent" TEXT,
  "success" BOOLEAN NOT NULL,
  "reason" TEXT,
  "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT "login_attempts_pkey" PRIMARY KEY ("id")
);

-- 3. çŒ«ç¨®ãƒã‚¹ã‚¿
CREATE TABLE "breeds" (
  "id" TEXT NOT NULL,
  "code" INTEGER NOT NULL,
  "name" TEXT NOT NULL,
  "description" TEXT,
  "is_active" BOOLEAN NOT NULL DEFAULT true,
  "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" TIMESTAMP(3) NOT NULL,
  CONSTRAINT "breeds_pkey" PRIMARY KEY ("id")
);

-- 4. æ¯›è‰²ãƒã‚¹ã‚¿
CREATE TABLE "coat_colors" (
  "id" TEXT NOT NULL,
  "code" INTEGER NOT NULL,
  "name" TEXT NOT NULL,
  "description" TEXT,
  "is_active" BOOLEAN NOT NULL DEFAULT true,
  "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" TIMESTAMP(3) NOT NULL,
  CONSTRAINT "coat_colors_pkey" PRIMARY KEY ("id")
);

-- 5. çŒ«åŸºæœ¬æƒ…å ±
CREATE TABLE "cats" (
  "id" TEXT NOT NULL,
  "registration_id" TEXT NOT NULL,
  "name" TEXT NOT NULL,
  "breed_id" TEXT,
  "color_id" TEXT,
  "legacy_breed" TEXT,
  "legacy_color" TEXT,
  "pattern" TEXT,
  "gender" "Gender" NOT NULL,
  "birth_date" TIMESTAMP(3) NOT NULL,
  "weight" DOUBLE PRECISION,
  "microchip_id" TEXT,
  "is_active" BOOLEAN NOT NULL DEFAULT true,
  "notes" TEXT,
  "image_url" TEXT,
  "father_id" TEXT,
  "mother_id" TEXT,
  "owner_id" TEXT NOT NULL,
  "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" TIMESTAMP(3) NOT NULL,
  CONSTRAINT "cats_pkey" PRIMARY KEY ("id")
);

-- 6. äº¤é…è¨˜éŒ²
CREATE TABLE "breeding_records" (
  "id" TEXT NOT NULL,
  "male_id" TEXT NOT NULL,
  "female_id" TEXT NOT NULL,
  "breeding_date" TIMESTAMP(3) NOT NULL,
  "expected_due_date" TIMESTAMP(3),
  "actual_due_date" TIMESTAMP(3),
  "number_of_kittens" INTEGER,
  "notes" TEXT,
  "status" "BreedingStatus" NOT NULL DEFAULT 'PLANNED',
  "recorded_by" TEXT NOT NULL,
  "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" TIMESTAMP(3) NOT NULL,
  CONSTRAINT "breeding_records_pkey" PRIMARY KEY ("id")
);

-- 7. ã‚±ã‚¢è¨˜éŒ²
CREATE TABLE "care_records" (
  "id" TEXT NOT NULL,
  "cat_id" TEXT NOT NULL,
  "care_type" "CareType" NOT NULL,
  "description" TEXT NOT NULL,
  "care_date" TIMESTAMP(3) NOT NULL,
  "next_due_date" TIMESTAMP(3),
  "cost" DOUBLE PRECISION,
  "veterinarian" TEXT,
  "notes" TEXT,
  "recorded_by" TEXT NOT NULL,
  "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" TIMESTAMP(3) NOT NULL,
  CONSTRAINT "care_records_pkey" PRIMARY KEY ("id")
);

-- 8. ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
CREATE TABLE "schedules" (
  "id" TEXT NOT NULL,
  "title" TEXT NOT NULL,
  "description" TEXT,
  "schedule_date" TIMESTAMP(3) NOT NULL,
  "schedule_type" "ScheduleType" NOT NULL,
  "status" "ScheduleStatus" NOT NULL DEFAULT 'PENDING',
  "priority" "Priority" NOT NULL DEFAULT 'MEDIUM',
  "cat_id" TEXT,
  "assigned_to" TEXT NOT NULL,
  "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" TIMESTAMP(3) NOT NULL,
  CONSTRAINT "schedules_pkey" PRIMARY KEY ("id")
);

-- 9. ã‚¿ã‚°ãƒã‚¹ã‚¿
CREATE TABLE "tags" (
  "id" TEXT NOT NULL,
  "name" TEXT NOT NULL,
  "color" TEXT NOT NULL DEFAULT '#3B82F6',
  "description" TEXT,
  "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" TIMESTAMP(3) NOT NULL,
  CONSTRAINT "tags_pkey" PRIMARY KEY ("id")
);

-- 10. è¡€çµ±æƒ…å ±
CREATE TABLE "pedigrees" (
  "id" TEXT NOT NULL,
  "pedigree_id" TEXT NOT NULL,
  "cat_id" TEXT,
  "title" TEXT,
  "cat_name" TEXT NOT NULL,
  "cat_name2" TEXT,
  "breed_id" TEXT,
  "breed_code" INTEGER,
  "gender" INTEGER,
  "eye_color" TEXT,
  "color_id" TEXT,
  "coat_color_code" INTEGER,
  "birth_date" TIMESTAMP(3),
  "registration_date" TIMESTAMP(3),
  "pedigree_issue_date" TIMESTAMP(3),
  "breeder_name" TEXT,
  "owner_name" TEXT,
  "brother_count" INTEGER,
  "sister_count" INTEGER,
  "notes" TEXT,
  "notes2" TEXT,
  "other_no" TEXT,
  "old_code" TEXT,
  "father_pedigree_id" TEXT,
  "mother_pedigree_id" TEXT,
  "paternal_grandfather_id" TEXT,
  "paternal_grandmother_id" TEXT,
  "maternal_grandfather_id" TEXT,
  "maternal_grandmother_id" TEXT,
  "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" TIMESTAMP(3) NOT NULL,
  CONSTRAINT "pedigrees_pkey" PRIMARY KEY ("id")
);

-- 11. çŒ«ã‚¿ã‚°é–¢é€£ï¼ˆä¸­é–“ãƒ†ãƒ¼ãƒ–ãƒ«ï¼‰
CREATE TABLE "cat_tags" (
  "cat_id" TEXT NOT NULL,
  "tag_id" TEXT NOT NULL,
  "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT "cat_tags_pkey" PRIMARY KEY ("cat_id","tag_id")
);
```

### è‡ªå‹•ç”Ÿæˆã•ã‚Œã‚‹åˆ—æŒ™å‹ï¼ˆEnumï¼‰

```sql
-- ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«
CREATE TYPE "UserRole" AS ENUM ('USER', 'ADMIN', 'SUPER_ADMIN');

-- æ€§åˆ¥
CREATE TYPE "Gender" AS ENUM ('MALE', 'FEMALE');

-- äº¤é…ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
CREATE TYPE "BreedingStatus" AS ENUM ('PLANNED', 'IN_PROGRESS', 'COMPLETED', 'FAILED');

-- ã‚±ã‚¢ç¨®åˆ¥
CREATE TYPE "CareType" AS ENUM ('VACCINATION', 'HEALTH_CHECK', 'GROOMING', 'DENTAL_CARE', 'MEDICATION', 'SURGERY', 'OTHER');

-- ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ç¨®åˆ¥
CREATE TYPE "ScheduleType" AS ENUM ('BREEDING', 'CARE', 'APPOINTMENT', 'REMINDER', 'MAINTENANCE');

-- ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
CREATE TYPE "ScheduleStatus" AS ENUM ('PENDING', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED');

-- å„ªå…ˆåº¦
CREATE TYPE "Priority" AS ENUM ('LOW', 'MEDIUM', 'HIGH', 'URGENT');
```

### è‡ªå‹•ç”Ÿæˆã•ã‚Œã‚‹åˆ¶ç´„ãƒ»ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹

```sql
-- ä¸€æ„åˆ¶ç´„
CREATE UNIQUE INDEX "users_clerk_id_key" ON "users"("clerk_id");
CREATE UNIQUE INDEX "users_email_key" ON "users"("email");
CREATE UNIQUE INDEX "breeds_code_key" ON "breeds"("code");
CREATE UNIQUE INDEX "breeds_name_key" ON "breeds"("name");
CREATE UNIQUE INDEX "coat_colors_code_key" ON "coat_colors"("code");
CREATE UNIQUE INDEX "coat_colors_name_key" ON "coat_colors"("name");
CREATE UNIQUE INDEX "cats_registration_id_key" ON "cats"("registration_id");
CREATE UNIQUE INDEX "cats_microchip_id_key" ON "cats"("microchip_id");
CREATE UNIQUE INDEX "tags_name_key" ON "tags"("name");
CREATE UNIQUE INDEX "pedigrees_pedigree_id_key" ON "pedigrees"("pedigree_id");

-- å¤–éƒ¨ã‚­ãƒ¼åˆ¶ç´„
ALTER TABLE "login_attempts" ADD CONSTRAINT "login_attempts_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "users"("id") ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE "cats" ADD CONSTRAINT "cats_breed_id_fkey" FOREIGN KEY ("breed_id") REFERENCES "breeds"("id") ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE "cats" ADD CONSTRAINT "cats_color_id_fkey" FOREIGN KEY ("color_id") REFERENCES "coat_colors"("id") ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE "cats" ADD CONSTRAINT "cats_father_id_fkey" FOREIGN KEY ("father_id") REFERENCES "cats"("id") ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE "cats" ADD CONSTRAINT "cats_mother_id_fkey" FOREIGN KEY ("mother_id") REFERENCES "cats"("id") ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE "cats" ADD CONSTRAINT "cats_owner_id_fkey" FOREIGN KEY ("owner_id") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
-- ... ãã®ä»–ã®å¤–éƒ¨ã‚­ãƒ¼åˆ¶ç´„
```

## ğŸ”§ åˆæœŸãƒ‡ãƒ¼ã‚¿ã®æŠ•å…¥

### å¿…è¦ãªåˆæœŸãƒ‡ãƒ¼ã‚¿

æœ¬ç•ªç’°å¢ƒã§ã¯ä»¥ä¸‹ã®åˆæœŸãƒ‡ãƒ¼ã‚¿ãŒå¿…è¦ã§ã™ï¼š

```sql
-- 1. ç®¡ç†è€…ãƒ¦ãƒ¼ã‚¶ãƒ¼
INSERT INTO "users" ("id", "clerk_id", "email", "role", "is_active")
VALUES ('admin-uuid', 'admin-clerk-id', 'admin@example.com', 'SUPER_ADMIN', true);

-- 2. åŸºæœ¬çŒ«ç¨®ãƒ‡ãƒ¼ã‚¿
INSERT INTO "breeds" ("id", "code", "name", "description")
VALUES
  ('breed-1', 1, 'ã‚¢ãƒ¡ãƒªã‚«ãƒ³ã‚·ãƒ§ãƒ¼ãƒˆãƒ˜ã‚¢', 'äººæ°—ã®çŸ­æ¯›ç¨®'),
  ('breed-2', 2, 'ãƒšãƒ«ã‚·ãƒ£', 'é•·æ¯›ã®ä»£è¡¨çš„å“ç¨®'),
  ('breed-3', 3, 'ãƒ©ã‚°ãƒ‰ãƒ¼ãƒ«', 'å¤§å‹ã§æ¸©åšãªæ€§æ ¼');

-- 3. åŸºæœ¬æ¯›è‰²ãƒ‡ãƒ¼ã‚¿
INSERT INTO "coat_colors" ("id", "code", "name", "description")
VALUES
  ('color-1', 1, 'ãƒ–ãƒ©ãƒƒã‚¯', 'é»’è‰²'),
  ('color-2', 2, 'ãƒ›ãƒ¯ã‚¤ãƒˆ', 'ç™½è‰²'),
  ('color-3', 3, 'ãƒ–ãƒ©ã‚¦ãƒ³', 'èŒ¶è‰²');

-- 4. åŸºæœ¬ã‚¿ã‚°
INSERT INTO "tags" ("id", "name", "color", "description")
VALUES
  ('tag-1', 'å®¤å†…é£¼ã„', '#10B981', 'å®Œå…¨å®¤å†…é£¼è‚²'),
  ('tag-2', 'ç¹æ®–ç”¨', '#F59E0B', 'ç¹æ®–ã«ä½¿ç”¨'),
  ('tag-3', 'ãƒšãƒƒãƒˆ', '#3B82F6', 'ãƒšãƒƒãƒˆç”¨é€”');
```

## ğŸ›¡ï¸ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®š

### ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¨©é™

```sql
-- å°‚ç”¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆ
CREATE USER mycats_app WITH PASSWORD 'secure_password';

-- å¿…è¦æœ€å°é™ã®æ¨©é™ä»˜ä¸
GRANT CONNECT ON DATABASE mycats_production TO mycats_app;
GRANT USAGE ON SCHEMA public TO mycats_app;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO mycats_app;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO mycats_app;
```

### æ¥ç¶šã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

```bash
# SSLæ¥ç¶šã®æœ‰åŠ¹åŒ–
DATABASE_URL="postgresql://mycats_app:password@hostname:5432/mycats_production?sslmode=require"

# æ¥ç¶šãƒ—ãƒ¼ãƒ«è¨­å®š
DATABASE_URL="postgresql://mycats_app:password@hostname:5432/mycats_production?connection_limit=10&pool_timeout=20"
```

## ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

### æ¨å¥¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½œæˆ

```sql
-- æ¤œç´¢ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Šç”¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX "idx_cats_owner_id" ON "cats"("owner_id");
CREATE INDEX "idx_cats_breed_id" ON "cats"("breed_id");
CREATE INDEX "idx_cats_birth_date" ON "cats"("birth_date");
CREATE INDEX "idx_care_records_cat_id_date" ON "care_records"("cat_id", "care_date");
CREATE INDEX "idx_schedules_assigned_date" ON "schedules"("assigned_to", "schedule_date");
CREATE INDEX "idx_pedigrees_father" ON "pedigrees"("father_pedigree_id");
CREATE INDEX "idx_pedigrees_mother" ON "pedigrees"("mother_pedigree_id");
```

### PostgreSQLè¨­å®šèª¿æ•´

```sql
-- postgresql.conf ã®æ¨å¥¨è¨­å®š
shared_buffers = 256MB
effective_cache_size = 1GB
work_mem = 4MB
maintenance_work_mem = 64MB
checkpoint_completion_target = 0.9
wal_buffers = 16MB
```

## ğŸ” ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ãƒ»ç›£è¦–

### ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯

```bash
# ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šç¢ºèª
curl http://localhost:3004/health

# æœŸå¾…ã™ã‚‹ãƒ¬ã‚¹ãƒãƒ³ã‚¹:
{
  "status": "ok",
  "info": {
    "database": {
      "status": "up"
    }
  }
}
```

### ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç›£è¦–ã‚¯ã‚¨ãƒª

```sql
-- æ¥ç¶šæ•°ç¢ºèª
SELECT count(*) as connections FROM pg_stat_activity;

-- ãƒ†ãƒ¼ãƒ–ãƒ«ã‚µã‚¤ã‚ºç¢ºèª
SELECT
  schemaname,
  tablename,
  pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;

-- å®Ÿè¡Œä¸­ã‚¯ã‚¨ãƒªç¢ºèª
SELECT
  query,
  state,
  query_start,
  state_change
FROM pg_stat_activity
WHERE state = 'active';
```

## ğŸš¨ ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### ã‚ˆãã‚ã‚‹å•é¡Œã¨è§£æ±ºç­–

**1. ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å¤±æ•—**

```bash
# åŸå› : ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã‚¨ãƒ©ãƒ¼
# è§£æ±º: DATABASE_URL ã®ç¢ºèª

# ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹ç¢ºèª
pnpm --filter backend run prisma:status

# ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
pnpm --filter backend run prisma:migrate -- deploy --schema ./prisma/schema.prisma
```

**2. Prismaã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆç”Ÿæˆã‚¨ãƒ©ãƒ¼**

```bash
# åŸå› : ã‚¹ã‚­ãƒ¼ãƒæ§‹æ–‡ã‚¨ãƒ©ãƒ¼
# è§£æ±º: schema.prisma ã®æ§‹æ–‡ç¢ºèª

# ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå†ç”Ÿæˆ
rm -rf node_modules/.prisma
pnpm -w run db:generate
```

**3. å¤–éƒ¨ã‚­ãƒ¼åˆ¶ç´„ã‚¨ãƒ©ãƒ¼**

```bash
# åŸå› : å‚ç…§æ•´åˆæ€§é•å
# è§£æ±º: ä¾å­˜é–¢ä¿‚é †åºã§ã®æŠ•å…¥

# åˆ¶ç´„ç¢ºèª
psql $DATABASE_URL -c "\d+ cats"
```

## ğŸ“‹ ãƒ‡ãƒ—ãƒ­ã‚¤ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

- [ ] PostgreSQL 15ä»¥ä¸ŠãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ¸ˆã¿
- [ ] Node.js 20ä»¥ä¸ŠãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ¸ˆã¿
- [ ] æœ¬ç•ªç”¨ç’°å¢ƒå¤‰æ•°ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆ.env.productionï¼‰ä½œæˆæ¸ˆã¿
- [ ] DATABASE_URL ãŒæ­£ã—ãè¨­å®šæ¸ˆã¿
- [ ] JWT_SECRET ãŒå®‰å…¨ãªå€¤ã«è¨­å®šæ¸ˆã¿
- [ ] ä¾å­˜é–¢ä¿‚ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å®Œäº†
- [ ] Prismaã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆç”Ÿæˆå®Œäº†
- [ ] ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†
- [ ] åˆæœŸãƒ‡ãƒ¼ã‚¿æŠ•å…¥å®Œäº†
- [ ] ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ“ãƒ«ãƒ‰å®Œäº†
- [ ] ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯æˆåŠŸ
- [ ] SSLè¨¼æ˜æ›¸è¨­å®šæ¸ˆã¿ï¼ˆHTTPSï¼‰
- [ ] ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«è¨­å®šå®Œäº†
- [ ] ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—è¨­å®šå®Œäº†
- [ ] ç›£è¦–è¨­å®šå®Œäº†

---

**é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**:

- [ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è©³ç´°ä»•æ§˜](./DATABASE_PRODUCTION_SCHEMA.md)
- [ERå›³ã¨ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆ](./DATABASE_ER_DIAGRAM.md)
- [é–‹ç™ºè€…å‘ã‘ã‚¯ã‚¤ãƒƒã‚¯ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹](../DATABASE_QUICK_REF.md)

_æœ€çµ‚æ›´æ–°: 2025å¹´1æœˆ_  
_ä½œæˆè€…: çŒ«ç”Ÿä½“ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ é–‹ç™ºãƒãƒ¼ãƒ _
`````

## File: docs/DATABASE_PRODUCTION_SCHEMA.md
`````markdown
# ğŸ—„ï¸ æœ¬ç•ªç’°å¢ƒãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒè©³ç´°

## ğŸ“‹ æ¦‚è¦

æœ¬ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ã€çŒ«ç”Ÿä½“ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ï¼ˆMy Catsï¼‰ã‚’æœ¬ç•ªç’°å¢ƒã«ãƒ‡ãƒ—ãƒ­ã‚¤ã—ãŸéš›ã«ã€Prismaã«ã‚ˆã£ã¦ç”Ÿæˆã•ã‚Œã‚‹PostgreSQLãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®å®Œå…¨ãªã‚¹ã‚­ãƒ¼ãƒå®šç¾©ã€ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã€ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³è¨­è¨ˆã‚’è©³è¿°ã—ã¦ã„ã¾ã™ã€‚

### ã‚·ã‚¹ãƒ†ãƒ æƒ…å ±

- **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹**: PostgreSQL 15+
- **ORM**: Prisma 6.14.0
- **ã‚¹ã‚­ãƒ¼ãƒãƒ•ã‚¡ã‚¤ãƒ«**: `backend/prisma/schema.prisma`
- **ç”Ÿæˆæ—¥**: 2025å¹´1æœˆï¼ˆæœ¬ç•ªç’°å¢ƒãƒ‡ãƒ—ãƒ­ã‚¤æ™‚ç‚¹ï¼‰

---

## ğŸ“Š ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å…¨ä½“æ§‹æˆ

### ãƒ†ãƒ¼ãƒ–ãƒ«ä¸€è¦§ï¼ˆ15ãƒ†ãƒ¼ãƒ–ãƒ«ï¼‰

| No. | ãƒ†ãƒ¼ãƒ–ãƒ«å           | ç‰©ç†å                   | æ¦‚è¦                       |
| --- | -------------------- | ------------------------ | -------------------------- |
| 1   | ãƒ¦ãƒ¼ã‚¶ãƒ¼             | `users`                  | ã‚·ã‚¹ãƒ†ãƒ åˆ©ç”¨è€…ã®ç®¡ç†       |
| 2   | ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œ         | `login_attempts`         | ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»ãƒ­ã‚°       |
| 3   | çŒ«ç¨®ãƒã‚¹ã‚¿           | `breeds`                 | çŒ«ã®å“ç¨®ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿       |
| 4   | æ¯›è‰²ãƒã‚¹ã‚¿           | `coat_colors`            | æ¯›è‰²ã®åˆ†é¡ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿     |
| 5   | çŒ«åŸºæœ¬æƒ…å ±           | `cats`                   | çŒ«ã®å€‹ä½“æƒ…å ±               |
| 6   | äº¤é…è¨˜éŒ²             | `breeding_records`       | äº¤é…ãƒ»ç¹æ®–å±¥æ­´             |
| 7   | ã‚±ã‚¢è¨˜éŒ²             | `care_records`           | åŒ»ç™‚ãƒ»ã‚±ã‚¢å±¥æ­´             |
| 8   | ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«         | `schedules`              | äºˆå®šãƒ»ã‚¿ã‚¹ã‚¯ç®¡ç†           |
| 9   | ã‚¿ã‚°ã‚«ãƒ†ã‚´ãƒª         | `tag_categories`         | ã‚¿ã‚°ã®åˆ†é¡ã‚«ãƒ†ã‚´ãƒª         |
| 10  | ã‚¿ã‚°ãƒã‚¹ã‚¿           | `tags`                   | ã‚«ãƒ†ã‚´ãƒªé…ä¸‹ã®ã‚¿ã‚°å®šç¾©     |
| 11  | ã‚¿ã‚°è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«     | `tag_automation_rules`   | ã‚¿ã‚°è‡ªå‹•ä»˜ä¸ã®ãƒ«ãƒ¼ãƒ«ç®¡ç†   |
| 12  | ã‚¿ã‚°è‡ªå‹•åŒ–å®Ÿè¡Œ       | `tag_automation_runs`    | è‡ªå‹•ä»˜ä¸ã®å®Ÿè¡Œå±¥æ­´         |
| 13  | ã‚¿ã‚°ä»˜ä¸å±¥æ­´         | `tag_assignment_history` | æ‰‹å‹•/è‡ªå‹•ã‚¿ã‚°æ“ä½œã®å±¥æ­´ç®¡ç† |
| 14  | çŒ«ã‚¿ã‚°é–¢é€£           | `cat_tags`               | çŒ«ã¨ã‚¿ã‚°ã®å¤šå¯¾å¤šé–¢é€£       |
| 15  | è¡€çµ±æƒ…å ±             | `pedigrees`              | è¡€çµ±æ›¸ãƒ»å®¶ç³»å›³ãƒ‡ãƒ¼ã‚¿       |


---

## ğŸ”‘ ä¸»è¦ãƒ†ãƒ¼ãƒ–ãƒ«è©³ç´°

### 1. ãƒ¦ãƒ¼ã‚¶ãƒ¼ï¼ˆusersï¼‰

**æ¦‚è¦**: ã‚·ã‚¹ãƒ†ãƒ åˆ©ç”¨è€…ã®åŸºæœ¬æƒ…å ±ã¨èªè¨¼ãƒ‡ãƒ¼ã‚¿ã‚’ç®¡ç†

| ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å         | ç‰©ç†å                  | ãƒ‡ãƒ¼ã‚¿å‹ | NULL | ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ | èª¬æ˜                     |
| -------------------- | ----------------------- | -------- | ---- | ---------- | ------------------------ |
| ID                   | `id`                    | String   | âœ—    | uuid()     | ä¸»ã‚­ãƒ¼ï¼ˆUUIDï¼‰           |
| Clerk ID             | `clerk_id`              | String   | âœ—    | -          | å¤–éƒ¨èªè¨¼ã‚µãƒ¼ãƒ“ã‚¹ID       |
| ãƒ¡ãƒ¼ãƒ«               | `email`                 | String   | âœ—    | -          | ãƒ­ã‚°ã‚¤ãƒ³ç”¨ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ |
| åå‰ï¼ˆå§“ï¼‰           | `first_name`            | String   | âœ“    | -          | ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å§“             |
| åå‰ï¼ˆåï¼‰           | `last_name`             | String   | âœ“    | -          | ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å             |
| ãƒ­ãƒ¼ãƒ«               | `role`                  | UserRole | âœ—    | USER       | æ¨©é™ãƒ¬ãƒ™ãƒ«               |
| æœ‰åŠ¹ãƒ•ãƒ©ã‚°           | `is_active`             | Boolean  | âœ—    | true       | ã‚¢ã‚«ã‚¦ãƒ³ãƒˆæœ‰åŠ¹æ€§         |
| ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥   | `password_hash`         | String   | âœ“    | -          | ãƒãƒƒã‚·ãƒ¥åŒ–ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰     |
| ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ | `refresh_token`         | String   | âœ“    | -          | JWTæ›´æ–°ç”¨ãƒˆãƒ¼ã‚¯ãƒ³        |
| ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—å›æ•°     | `failed_login_attempts` | Int      | âœ—    | 0          | ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç”¨ã‚«ã‚¦ãƒ³ã‚¿   |
| ãƒ­ãƒƒã‚¯æœŸé™           | `locked_until`          | DateTime | âœ“    | -          | ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ­ãƒƒã‚¯è§£é™¤æ™‚åˆ» |
| æœ€çµ‚ãƒ­ã‚°ã‚¤ãƒ³         | `last_login_at`         | DateTime | âœ“    | -          | æœ€å¾Œã®ãƒ­ã‚°ã‚¤ãƒ³æ™‚åˆ»       |
| ä½œæˆæ—¥æ™‚             | `created_at`            | DateTime | âœ—    | now()      | ãƒ¬ã‚³ãƒ¼ãƒ‰ä½œæˆæ—¥æ™‚         |
| æ›´æ–°æ—¥æ™‚             | `updated_at`            | DateTime | âœ—    | -          | ãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°æ—¥æ™‚         |

**åˆ¶ç´„**:

- ä¸»ã‚­ãƒ¼: `id`
- ãƒ¦ãƒ‹ãƒ¼ã‚¯åˆ¶ç´„: `clerk_id`, `email`

**ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³**:

- â†’ catsï¼ˆ1å¯¾å¤šï¼‰: æ‰€æœ‰ã™ã‚‹çŒ«
- â†’ breeding_recordsï¼ˆ1å¯¾å¤šï¼‰: è¨˜éŒ²ã—ãŸäº¤é…å±¥æ­´
- â†’ care_recordsï¼ˆ1å¯¾å¤šï¼‰: è¨˜éŒ²ã—ãŸã‚±ã‚¢å±¥æ­´
- â†’ schedulesï¼ˆ1å¯¾å¤šï¼‰: æ‹…å½“ã™ã‚‹ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
- â†’ login_attemptsï¼ˆ1å¯¾å¤šï¼‰: ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œå±¥æ­´

### 2. ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œï¼ˆlogin_attemptsï¼‰

**æ¦‚è¦**: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»ã®ãŸã‚ã®ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œãƒ­ã‚°

| ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å         | ç‰©ç†å       | ãƒ‡ãƒ¼ã‚¿å‹ | NULL | ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ | èª¬æ˜                     |
| -------------------- | ------------ | -------- | ---- | ---------- | ------------------------ |
| ID                   | `id`         | String   | âœ—    | uuid()     | ä¸»ã‚­ãƒ¼ï¼ˆUUIDï¼‰           |
| ãƒ¦ãƒ¼ã‚¶ãƒ¼ID           | `user_id`    | String   | âœ“    | -          | å¯¾è±¡ãƒ¦ãƒ¼ã‚¶ãƒ¼ï¼ˆå¤–éƒ¨ã‚­ãƒ¼ï¼‰ |
| ãƒ¡ãƒ¼ãƒ«               | `email`      | String   | âœ—    | -          | è©¦è¡Œã•ã‚ŒãŸãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ |
| IPã‚¢ãƒ‰ãƒ¬ã‚¹           | `ip_address` | String   | âœ“    | -          | ã‚¢ã‚¯ã‚»ã‚¹å…ƒIP             |
| ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ | `user_agent` | String   | âœ“    | -          | ãƒ–ãƒ©ã‚¦ã‚¶æƒ…å ±             |
| æˆåŠŸãƒ•ãƒ©ã‚°           | `success`    | Boolean  | âœ—    | -          | ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ/å¤±æ•—        |
| å¤±æ•—ç†ç”±             | `reason`     | String   | âœ“    | -          | å¤±æ•—æ™‚ã®ç†ç”±             |
| è©¦è¡Œæ—¥æ™‚             | `created_at` | DateTime | âœ—    | now()      | ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œæ—¥æ™‚         |

**åˆ¶ç´„**:

- ä¸»ã‚­ãƒ¼: `id`
- å¤–éƒ¨ã‚­ãƒ¼: `user_id` â†’ users.idï¼ˆCASCADEå‰Šé™¤ï¼‰

### 3. çŒ«ç¨®ãƒã‚¹ã‚¿ï¼ˆbreedsï¼‰

**æ¦‚è¦**: çŒ«ã®å“ç¨®ã‚’ç®¡ç†ã™ã‚‹ãƒã‚¹ã‚¿ãƒ†ãƒ¼ãƒ–ãƒ«

| ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å | ç‰©ç†å        | ãƒ‡ãƒ¼ã‚¿å‹ | NULL | ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ | èª¬æ˜                  |
| ------------ | ------------- | -------- | ---- | ---------- | --------------------- |
| ID           | `id`          | String   | âœ—    | uuid()     | ä¸»ã‚­ãƒ¼ï¼ˆUUIDï¼‰        |
| çŒ«ç¨®ã‚³ãƒ¼ãƒ‰   | `code`        | Int      | âœ—    | -          | æ•°å€¤ã‚³ãƒ¼ãƒ‰ï¼ˆCSVã‹ã‚‰ï¼‰ |
| çŒ«ç¨®å       | `name`        | String   | âœ—    | -          | å“ç¨®åç§°              |
| èª¬æ˜         | `description` | String   | âœ“    | -          | å“ç¨®ã®è©³ç´°èª¬æ˜        |
| æœ‰åŠ¹ãƒ•ãƒ©ã‚°   | `is_active`   | Boolean  | âœ—    | true       | ãƒã‚¹ã‚¿ã®æœ‰åŠ¹æ€§        |
| ä½œæˆæ—¥æ™‚     | `created_at`  | DateTime | âœ—    | now()      | ãƒ¬ã‚³ãƒ¼ãƒ‰ä½œæˆæ—¥æ™‚      |
| æ›´æ–°æ—¥æ™‚     | `updated_at`  | DateTime | âœ—    | -          | ãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°æ—¥æ™‚      |

**åˆ¶ç´„**:

- ä¸»ã‚­ãƒ¼: `id`
- ãƒ¦ãƒ‹ãƒ¼ã‚¯åˆ¶ç´„: `code`, `name`

**ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³**:

- â†’ catsï¼ˆ1å¯¾å¤šï¼‰: ã“ã®å“ç¨®ã®çŒ«
- â†’ pedigreesï¼ˆ1å¯¾å¤šï¼‰: ã“ã®å“ç¨®ã®è¡€çµ±è¨˜éŒ²

### 4. æ¯›è‰²ãƒã‚¹ã‚¿ï¼ˆcoat_colorsï¼‰

**æ¦‚è¦**: çŒ«ã®æ¯›è‰²ã‚’ç®¡ç†ã™ã‚‹ãƒã‚¹ã‚¿ãƒ†ãƒ¼ãƒ–ãƒ«

| ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å | ç‰©ç†å        | ãƒ‡ãƒ¼ã‚¿å‹ | NULL | ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ | èª¬æ˜                  |
| ------------ | ------------- | -------- | ---- | ---------- | --------------------- |
| ID           | `id`          | String   | âœ—    | uuid()     | ä¸»ã‚­ãƒ¼ï¼ˆUUIDï¼‰        |
| æ¯›è‰²ã‚³ãƒ¼ãƒ‰   | `code`        | Int      | âœ—    | -          | æ•°å€¤ã‚³ãƒ¼ãƒ‰ï¼ˆCSVã‹ã‚‰ï¼‰ |
| æ¯›è‰²å       | `name`        | String   | âœ—    | -          | æ¯›è‰²åç§°              |
| èª¬æ˜         | `description` | String   | âœ“    | -          | æ¯›è‰²ã®è©³ç´°èª¬æ˜        |
| æœ‰åŠ¹ãƒ•ãƒ©ã‚°   | `is_active`   | Boolean  | âœ—    | true       | ãƒã‚¹ã‚¿ã®æœ‰åŠ¹æ€§        |
| ä½œæˆæ—¥æ™‚     | `created_at`  | DateTime | âœ—    | now()      | ãƒ¬ã‚³ãƒ¼ãƒ‰ä½œæˆæ—¥æ™‚      |
| æ›´æ–°æ—¥æ™‚     | `updated_at`  | DateTime | âœ—    | -          | ãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°æ—¥æ™‚      |

**åˆ¶ç´„**:

- ä¸»ã‚­ãƒ¼: `id`
- ãƒ¦ãƒ‹ãƒ¼ã‚¯åˆ¶ç´„: `code`, `name`

**ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³**:

- â†’ catsï¼ˆ1å¯¾å¤šï¼‰: ã“ã®æ¯›è‰²ã®çŒ«
- â†’ pedigreesï¼ˆ1å¯¾å¤šï¼‰: ã“ã®æ¯›è‰²ã®è¡€çµ±è¨˜éŒ²

### 5. çŒ«åŸºæœ¬æƒ…å ±ï¼ˆcatsï¼‰

**æ¦‚è¦**: çŒ«ã®å€‹ä½“æƒ…å ±ã¨åŸºæœ¬ãƒ‡ãƒ¼ã‚¿ã‚’ç®¡ç†ã™ã‚‹ä¸­æ ¸ãƒ†ãƒ¼ãƒ–ãƒ«

| ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å     | ç‰©ç†å            | ãƒ‡ãƒ¼ã‚¿å‹ | NULL | ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ | èª¬æ˜               |
| ---------------- | ----------------- | -------- | ---- | ---------- | ------------------ |
| ID               | `id`              | String   | âœ—    | uuid()     | ä¸»ã‚­ãƒ¼ï¼ˆUUIDï¼‰     |
| ç™»éŒ²ID           | `registration_id` | String   | âœ—    | -          | ä¸€æ„ã®ç™»éŒ²ç•ªå·     |
| åå‰             | `name`            | String   | âœ—    | -          | çŒ«ã®åå‰           |
| çŒ«ç¨®ID           | `breed_id`        | String   | âœ“    | -          | å“ç¨®ï¼ˆå¤–éƒ¨ã‚­ãƒ¼ï¼‰   |
| æ¯›è‰²ID           | `color_id`        | String   | âœ“    | -          | æ¯›è‰²ï¼ˆå¤–éƒ¨ã‚­ãƒ¼ï¼‰   |
| å¾“æ¥çŒ«ç¨®         | `legacy_breed`    | String   | âœ“    | -          | æ—§ã‚·ã‚¹ãƒ†ãƒ ç”¨å“ç¨®   |
| å¾“æ¥æ¯›è‰²         | `legacy_color`    | String   | âœ“    | -          | æ—§ã‚·ã‚¹ãƒ†ãƒ ç”¨æ¯›è‰²   |
| æ¨¡æ§˜             | `pattern`         | String   | âœ“    | -          | æ¯›è‰²ã®æ¨¡æ§˜è©³ç´°     |
| æ€§åˆ¥             | `gender`          | Gender   | âœ—    | -          | ã‚ªã‚¹/ãƒ¡ã‚¹          |
| ç”Ÿå¹´æœˆæ—¥         | `birth_date`      | DateTime | âœ—    | -          | èª•ç”Ÿæ—¥             |
| ä½“é‡             | `weight`          | Float    | âœ“    | -          | ä½“é‡ï¼ˆkgï¼‰         |
| ãƒã‚¤ã‚¯ãƒ­ãƒãƒƒãƒ—ID | `microchip_id`    | String   | âœ“    | -          | å€‹ä½“è­˜åˆ¥ãƒãƒƒãƒ—     |
| æœ‰åŠ¹ãƒ•ãƒ©ã‚°       | `is_active`       | Boolean  | âœ—    | true       | çŒ«ã®ç®¡ç†çŠ¶æ…‹       |
| å‚™è€ƒ             | `notes`           | String   | âœ“    | -          | ãã®ä»–æƒ…å ±         |
| ç”»åƒURL          | `image_url`       | String   | âœ“    | -          | å†™çœŸã¸ã®ãƒªãƒ³ã‚¯     |
| çˆ¶è¦ªID           | `father_id`       | String   | âœ“    | -          | çˆ¶è¦ªçŒ«ï¼ˆå¤–éƒ¨ã‚­ãƒ¼ï¼‰ |
| æ¯è¦ªID           | `mother_id`       | String   | âœ“    | -          | æ¯è¦ªçŒ«ï¼ˆå¤–éƒ¨ã‚­ãƒ¼ï¼‰ |
| é£¼ã„ä¸»ID         | `owner_id`        | String   | âœ—    | -          | æ‰€æœ‰è€…ï¼ˆå¤–éƒ¨ã‚­ãƒ¼ï¼‰ |
| ä½œæˆæ—¥æ™‚         | `created_at`      | DateTime | âœ—    | now()      | ãƒ¬ã‚³ãƒ¼ãƒ‰ä½œæˆæ—¥æ™‚   |
| æ›´æ–°æ—¥æ™‚         | `updated_at`      | DateTime | âœ—    | -          | ãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°æ—¥æ™‚   |

**åˆ¶ç´„**:

- ä¸»ã‚­ãƒ¼: `id`
- ãƒ¦ãƒ‹ãƒ¼ã‚¯åˆ¶ç´„: `registration_id`, `microchip_id`
- å¤–éƒ¨ã‚­ãƒ¼: `breed_id` â†’ breeds.id, `color_id` â†’ coat_colors.id
- å¤–éƒ¨ã‚­ãƒ¼: `father_id` â†’ cats.id, `mother_id` â†’ cats.id
- å¤–éƒ¨ã‚­ãƒ¼: `owner_id` â†’ users.id

**è‡ªå·±å‚ç…§ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³**:

- â†’ fatherï¼ˆå¤šå¯¾1ï¼‰: çˆ¶è¦ªçŒ«
- â†’ motherï¼ˆå¤šå¯¾1ï¼‰: æ¯è¦ªçŒ«
- â†’ fatherOfï¼ˆ1å¯¾å¤šï¼‰: çˆ¶è¦ªã¨ã—ã¦é–¢ã‚ã‚‹å­çŒ«
- â†’ motherOfï¼ˆ1å¯¾å¤šï¼‰: æ¯è¦ªã¨ã—ã¦é–¢ã‚ã‚‹å­çŒ«

**ãã®ä»–ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³**:

- â†’ maleBreedingRecordsï¼ˆ1å¯¾å¤šï¼‰: ã‚ªã‚¹ã¨ã—ã¦ã®äº¤é…è¨˜éŒ²
- â†’ femaleBreedingRecordsï¼ˆ1å¯¾å¤šï¼‰: ãƒ¡ã‚¹ã¨ã—ã¦ã®äº¤é…è¨˜éŒ²
- â†’ careRecordsï¼ˆ1å¯¾å¤šï¼‰: ã‚±ã‚¢å±¥æ­´
- â†’ schedulesï¼ˆ1å¯¾å¤šï¼‰: ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
- â†’ tagsï¼ˆå¤šå¯¾å¤šã€cat_tagsçµŒç”±ï¼‰: ã‚¿ã‚°
- â†’ pedigreesï¼ˆ1å¯¾å¤šï¼‰: è¡€çµ±è¨˜éŒ²

### 6. äº¤é…è¨˜éŒ²ï¼ˆbreeding_recordsï¼‰

**æ¦‚è¦**: çŒ«ã®äº¤é…ãƒ»ç¹æ®–æ´»å‹•ã®å±¥æ­´ã‚’ç®¡ç†

| ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å | ç‰©ç†å              | ãƒ‡ãƒ¼ã‚¿å‹       | NULL | ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ | èª¬æ˜               |
| ------------ | ------------------- | -------------- | ---- | ---------- | ------------------ |
| ID           | `id`                | String         | âœ—    | uuid()     | ä¸»ã‚­ãƒ¼ï¼ˆUUIDï¼‰     |
| ã‚ªã‚¹çŒ«ID     | `male_id`           | String         | âœ—    | -          | çˆ¶è¦ªçŒ«ï¼ˆå¤–éƒ¨ã‚­ãƒ¼ï¼‰ |
| ãƒ¡ã‚¹çŒ«ID     | `female_id`         | String         | âœ—    | -          | æ¯è¦ªçŒ«ï¼ˆå¤–éƒ¨ã‚­ãƒ¼ï¼‰ |
| äº¤é…æ—¥       | `breeding_date`     | DateTime       | âœ—    | -          | å®Ÿéš›ã®äº¤é…æ—¥       |
| äºˆå®šå‡ºç”£æ—¥   | `expected_due_date` | DateTime       | âœ“    | -          | è¨ˆç®—ä¸Šã®å‡ºç”£äºˆå®šæ—¥ |
| å®Ÿéš›å‡ºç”£æ—¥   | `actual_due_date`   | DateTime       | âœ“    | -          | å®Ÿéš›ã®å‡ºç”£æ—¥       |
| å­çŒ«æ•°       | `number_of_kittens` | Int            | âœ“    | -          | ç”Ÿã¾ã‚ŒãŸå­çŒ«ã®æ•°   |
| å‚™è€ƒ         | `notes`             | String         | âœ“    | -          | äº¤é…ã«é–¢ã™ã‚‹è©³ç´°   |
| ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹   | `status`            | BreedingStatus | âœ—    | PLANNED    | äº¤é…ã®é€²è¡ŒçŠ¶æ³     |
| è¨˜éŒ²è€…ID     | `recorded_by`       | String         | âœ—    | -          | è¨˜éŒ²ã—ãŸãƒ¦ãƒ¼ã‚¶ãƒ¼   |
| ä½œæˆæ—¥æ™‚     | `created_at`        | DateTime       | âœ—    | now()      | ãƒ¬ã‚³ãƒ¼ãƒ‰ä½œæˆæ—¥æ™‚   |
| æ›´æ–°æ—¥æ™‚     | `updated_at`        | DateTime       | âœ—    | -          | ãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°æ—¥æ™‚   |

**åˆ¶ç´„**:

- ä¸»ã‚­ãƒ¼: `id`
- å¤–éƒ¨ã‚­ãƒ¼: `male_id` â†’ cats.id, `female_id` â†’ cats.id
- å¤–éƒ¨ã‚­ãƒ¼: `recorded_by` â†’ users.id

### 7. ã‚±ã‚¢è¨˜éŒ²ï¼ˆcare_recordsï¼‰

**æ¦‚è¦**: çŒ«ã®åŒ»ç™‚ãƒ»ã‚±ã‚¢æ´»å‹•ã®å±¥æ­´ã‚’ç®¡ç†

| ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å | ç‰©ç†å          | ãƒ‡ãƒ¼ã‚¿å‹ | NULL | ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ | èª¬æ˜               |
| ------------ | --------------- | -------- | ---- | ---------- | ------------------ |
| ID           | `id`            | String   | âœ—    | uuid()     | ä¸»ã‚­ãƒ¼ï¼ˆUUIDï¼‰     |
| çŒ«ID         | `cat_id`        | String   | âœ—    | -          | å¯¾è±¡çŒ«ï¼ˆå¤–éƒ¨ã‚­ãƒ¼ï¼‰ |
| ã‚±ã‚¢ç¨®åˆ¥     | `care_type`     | CareType | âœ—    | -          | ã‚±ã‚¢ã®åˆ†é¡         |
| è©³ç´°         | `description`   | String   | âœ—    | -          | ã‚±ã‚¢å†…å®¹ã®èª¬æ˜     |
| ã‚±ã‚¢æ—¥       | `care_date`     | DateTime | âœ—    | -          | å®Ÿæ–½æ—¥             |
| æ¬¡å›äºˆå®šæ—¥   | `next_due_date` | DateTime | âœ“    | -          | æ¬¡å›ã®äºˆå®šæ—¥       |
| è²»ç”¨         | `cost`          | Float    | âœ“    | -          | ã‹ã‹ã£ãŸè²»ç”¨       |
| ç£åŒ»å¸«       | `veterinarian`  | String   | âœ“    | -          | æ‹…å½“ç£åŒ»å¸«å       |
| å‚™è€ƒ         | `notes`         | String   | âœ“    | -          | ãã®ä»–è©³ç´°         |
| è¨˜éŒ²è€…ID     | `recorded_by`   | String   | âœ—    | -          | è¨˜éŒ²ã—ãŸãƒ¦ãƒ¼ã‚¶ãƒ¼   |
| ä½œæˆæ—¥æ™‚     | `created_at`    | DateTime | âœ—    | now()      | ãƒ¬ã‚³ãƒ¼ãƒ‰ä½œæˆæ—¥æ™‚   |
| æ›´æ–°æ—¥æ™‚     | `updated_at`    | DateTime | âœ—    | -          | ãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°æ—¥æ™‚   |

**åˆ¶ç´„**:

- ä¸»ã‚­ãƒ¼: `id`
- å¤–éƒ¨ã‚­ãƒ¼: `cat_id` â†’ cats.id, `recorded_by` â†’ users.id

### 8. ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆschedulesï¼‰

**æ¦‚è¦**: ã‚±ã‚¢ã‚„äº¤é…ãªã©ã®äºˆå®šãƒ»ã‚¿ã‚¹ã‚¯ã‚’ç®¡ç†

| ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å     | ç‰©ç†å          | ãƒ‡ãƒ¼ã‚¿å‹       | NULL | ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ | èª¬æ˜               |
| ---------------- | --------------- | -------------- | ---- | ---------- | ------------------ |
| ID               | `id`            | String         | âœ—    | uuid()     | ä¸»ã‚­ãƒ¼ï¼ˆUUIDï¼‰     |
| ã‚¿ã‚¤ãƒˆãƒ«         | `title`         | String         | âœ—    | -          | ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«å     |
| è©³ç´°             | `description`   | String         | âœ“    | -          | è©³ç´°èª¬æ˜           |
| äºˆå®šæ—¥æ™‚         | `schedule_date` | DateTime       | âœ—    | -          | å®Ÿè¡Œäºˆå®šæ—¥æ™‚       |
| ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ç¨®åˆ¥ | `schedule_type` | ScheduleType   | âœ—    | -          | äºˆå®šã®åˆ†é¡         |
| ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹       | `status`        | ScheduleStatus | âœ—    | PENDING    | é€²è¡ŒçŠ¶æ³           |
| å„ªå…ˆåº¦           | `priority`      | Priority       | âœ—    | MEDIUM     | é‡è¦åº¦ãƒ¬ãƒ™ãƒ«       |
| çŒ«ID             | `cat_id`        | String         | âœ“    | -          | å¯¾è±¡çŒ«ï¼ˆå¤–éƒ¨ã‚­ãƒ¼ï¼‰ |
| æ‹…å½“è€…ID         | `assigned_to`   | String         | âœ—    | -          | æ‹…å½“ãƒ¦ãƒ¼ã‚¶ãƒ¼       |
| ä½œæˆæ—¥æ™‚         | `created_at`    | DateTime       | âœ—    | now()      | ãƒ¬ã‚³ãƒ¼ãƒ‰ä½œæˆæ—¥æ™‚   |
| æ›´æ–°æ—¥æ™‚         | `updated_at`    | DateTime       | âœ—    | -          | ãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°æ—¥æ™‚   |

**åˆ¶ç´„**:

- ä¸»ã‚­ãƒ¼: `id`
- å¤–éƒ¨ã‚­ãƒ¼: `cat_id` â†’ cats.id, `assigned_to` â†’ users.id

### 9. ã‚¿ã‚°ã‚«ãƒ†ã‚´ãƒªï¼ˆtag_categoriesï¼‰

**æ¦‚è¦**: ã‚¿ã‚°ã‚’ã‚«ãƒ†ã‚´ãƒªå˜ä½ã§æ•´ç†ã—ã€å¯¾è±¡ã‚¹ã‚³ãƒ¼ãƒ—ã‚„è¡¨ç¤ºé †ã‚’ç®¡ç†

| ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å     | ç‰©ç†å           | ãƒ‡ãƒ¼ã‚¿å‹ | NULL | ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ | èª¬æ˜                     |
| ---------------- | ---------------- | -------- | ---- | ---------- | ------------------------ |
| ID               | `id`             | String   | âœ—    | uuid()     | ä¸»ã‚­ãƒ¼ï¼ˆUUIDï¼‰           |
| ã‚­ãƒ¼             | `key`            | String   | âœ—    | -          | ä¸€æ„ãªã‚«ãƒ†ã‚´ãƒªã‚­ãƒ¼       |
| åç§°             | `name`           | String   | âœ—    | -          | ã‚«ãƒ†ã‚´ãƒªå               |
| èª¬æ˜             | `description`    | String   | âœ“    | -          | ã‚«ãƒ†ã‚´ãƒªèª¬æ˜             |
| è‰²               | `color`          | String   | âœ“    | #3B82F6    | UIè¡¨ç¤ºç”¨ã‚«ãƒ©ãƒ¼           |
| è¡¨ç¤ºé †           | `display_order`  | Int      | âœ—    | 0          | ä¸¦ã³æ›¿ãˆç”¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹   |
| ã‚¹ã‚³ãƒ¼ãƒ—         | `scopes`         | String[] | âœ—    | []         | åˆ©ç”¨å¯èƒ½ãªãƒšãƒ¼ã‚¸ã‚¹ã‚³ãƒ¼ãƒ— |
| æœ‰åŠ¹ãƒ•ãƒ©ã‚°       | `is_active`      | Boolean  | âœ—    | true       | åˆ©ç”¨å¯å¦                 |
| ä½œæˆæ—¥æ™‚         | `created_at`     | DateTime | âœ—    | now()      | ãƒ¬ã‚³ãƒ¼ãƒ‰ä½œæˆæ—¥æ™‚         |
| æ›´æ–°æ—¥æ™‚         | `updated_at`     | DateTime | âœ—    | -          | ãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°æ—¥æ™‚         |

**åˆ¶ç´„**:

- ä¸»ã‚­ãƒ¼: `id`
- ãƒ¦ãƒ‹ãƒ¼ã‚¯åˆ¶ç´„: `key`

### 10. ã‚¿ã‚°ãƒã‚¹ã‚¿ï¼ˆtagsï¼‰

**æ¦‚è¦**: ã‚«ãƒ†ã‚´ãƒªé…ä¸‹ã®å€‹åˆ¥ã‚¿ã‚°ã‚’å®šç¾©ã—ã€æ‰‹å‹•/è‡ªå‹•ä»˜ä¸å¯å¦ã‚„è¡¨ç¤ºé †ã‚’åˆ¶å¾¡

| ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å           | ç‰©ç†å              | ãƒ‡ãƒ¼ã‚¿å‹ | NULL | ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ | èª¬æ˜                       |
| ---------------------- | ------------------- | -------- | ---- | ---------- | -------------------------- |
| ID                     | `id`                | String   | âœ—    | uuid()     | ä¸»ã‚­ãƒ¼ï¼ˆUUIDï¼‰             |
| ã‚«ãƒ†ã‚´ãƒªID             | `category_id`       | String   | âœ—    | -          | æ‰€å±ã‚«ãƒ†ã‚´ãƒªï¼ˆå¤–éƒ¨ã‚­ãƒ¼ï¼‰   |
| ã‚¿ã‚°å                 | `name`              | String   | âœ—    | -          | ã‚¿ã‚°ã®åç§°                 |
| è¡¨ç¤ºè‰²                 | `color`             | String   | âœ—    | #3B82F6    | UIè¡¨ç¤ºç”¨ã‚«ãƒ©ãƒ¼             |
| èª¬æ˜                   | `description`       | String   | âœ“    | -          | ã‚¿ã‚°ã®ç”¨é€”èª¬æ˜             |
| è¡¨ç¤ºé †                 | `display_order`     | Int      | âœ—    | 0          | ä¸¦ã³é †                     |
| æ‰‹å‹•ä»˜ä¸å¯å¦           | `allows_manual`     | Boolean  | âœ—    | true       | æ‰‹å‹•æ“ä½œã§åˆ©ç”¨å¯èƒ½ã‹       |
| è‡ªå‹•ä»˜ä¸å¯å¦           | `allows_automation` | Boolean  | âœ—    | true       | è‡ªå‹•ãƒ«ãƒ¼ãƒ«ã§åˆ©ç”¨å¯èƒ½ã‹     |
| ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿             | `metadata`          | Json     | âœ“    | -          | ä»»æ„ã®ä»˜éšæƒ…å ±             |
| æœ‰åŠ¹ãƒ•ãƒ©ã‚°             | `is_active`         | Boolean  | âœ—    | true       | åˆ©ç”¨å¯å¦                   |
| ä½œæˆæ—¥æ™‚               | `created_at`        | DateTime | âœ—    | now()      | ãƒ¬ã‚³ãƒ¼ãƒ‰ä½œæˆæ—¥æ™‚           |
| æ›´æ–°æ—¥æ™‚               | `updated_at`        | DateTime | âœ—    | -          | ãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°æ—¥æ™‚           |

**åˆ¶ç´„**:

- ä¸»ã‚­ãƒ¼: `id`
- è¤‡åˆãƒ¦ãƒ‹ãƒ¼ã‚¯åˆ¶ç´„: (`category_id`, `name`)
- å¤–éƒ¨ã‚­ãƒ¼: `category_id` â†’ tag_categories.idï¼ˆCASCADEï¼‰

### 11. ã‚¿ã‚°è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ï¼ˆtag_automation_rulesï¼‰

**æ¦‚è¦**: ã‚¤ãƒ™ãƒ³ãƒˆã‚„ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒˆãƒªã‚¬ãƒ¼ã«ã‚¿ã‚°ã‚’è‡ªå‹•ä»˜ä¸/å‰¥å¥ªã™ã‚‹ãƒ«ãƒ¼ãƒ«

| ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å     | ç‰©ç†å        | ãƒ‡ãƒ¼ã‚¿å‹                 | NULL | ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ | èª¬æ˜                                 |
| ---------------- | ------------- | ------------------------ | ---- | ---------- | ------------------------------------ |
| ID               | `id`          | String                   | âœ—    | uuid()     | ä¸»ã‚­ãƒ¼ï¼ˆUUIDï¼‰                     |
| ã‚­ãƒ¼             | `key`         | String                   | âœ—    | -          | ãƒ«ãƒ¼ãƒ«è­˜åˆ¥å­ï¼ˆãƒ¦ãƒ‹ãƒ¼ã‚¯ï¼‰           |
| åç§°             | `name`        | String                   | âœ—    | -          | ãƒ«ãƒ¼ãƒ«å                             |
| èª¬æ˜             | `description` | String                   | âœ“    | -          | ãƒ«ãƒ¼ãƒ«ã®èª¬æ˜                         |
| ãƒˆãƒªã‚¬ç¨®åˆ¥       | `trigger_type`| TagAutomationTriggerType | âœ—    | -          | EVENT / SCHEDULE / MANUAL           |
| ã‚¤ãƒ™ãƒ³ãƒˆç¨®åˆ¥     | `event_type`  | TagAutomationEventType   | âœ—    | -          | å…·ä½“çš„ãªãƒˆãƒªã‚¬ã‚¤ãƒ™ãƒ³ãƒˆ               |
| ã‚¹ã‚³ãƒ¼ãƒ—         | `scope`       | String                   | âœ“    | -          | é©ç”¨å¯¾è±¡ã‚¹ã‚³ãƒ¼ãƒ—                     |
| æœ‰åŠ¹ãƒ•ãƒ©ã‚°       | `is_active`   | Boolean                  | âœ—    | true       | ãƒ«ãƒ¼ãƒ«ãŒæœ‰åŠ¹ã‹                       |
| å„ªå…ˆåº¦           | `priority`    | Int                      | âœ—    | 0          | ãƒ«ãƒ¼ãƒ«é©ç”¨å„ªå…ˆåº¦                     |
| ã‚³ãƒ³ãƒ•ã‚£ã‚°       | `config`      | Json                     | âœ“    | -          | è¿½åŠ è¨­å®šï¼ˆJSONï¼‰                     |
| ä½œæˆæ—¥æ™‚         | `created_at`  | DateTime                 | âœ—    | now()      | ä½œæˆæ—¥æ™‚                             |
| æ›´æ–°æ—¥æ™‚         | `updated_at`  | DateTime                 | âœ—    | -          | æ›´æ–°æ—¥æ™‚                             |

**åˆ¶ç´„**:

- ä¸»ã‚­ãƒ¼: `id`
- ãƒ¦ãƒ‹ãƒ¼ã‚¯åˆ¶ç´„: `key`

### 12. ã‚¿ã‚°è‡ªå‹•åŒ–å®Ÿè¡Œï¼ˆtag_automation_runsï¼‰

**æ¦‚è¦**: è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ã®å®Ÿè¡Œå±¥æ­´ã¨å‡¦ç†çµæœã‚’ä¿å­˜

| ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å       | ç‰©ç†å          | ãƒ‡ãƒ¼ã‚¿å‹               | NULL | ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ | èª¬æ˜                     |
| ------------------ | --------------- | ---------------------- | ---- | ---------- | ------------------------ |
| ID                 | `id`            | String                 | âœ—    | uuid()     | ä¸»ã‚­ãƒ¼ï¼ˆUUIDï¼‰           |
| ãƒ«ãƒ¼ãƒ«ID           | `rule_id`       | String                 | âœ—    | -          | é–¢é€£ãƒ«ãƒ¼ãƒ«ï¼ˆå¤–éƒ¨ã‚­ãƒ¼ï¼‰   |
| ã‚¤ãƒ™ãƒ³ãƒˆãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ | `event_payload` | Json                   | âœ“    | -          | å®Ÿè¡Œæ™‚ã®å…¥åŠ›ãƒ‡ãƒ¼ã‚¿       |
| ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹         | `status`        | TagAutomationRunStatus | âœ—    | PENDING    | å®Ÿè¡ŒçŠ¶æ…‹                 |
| é–‹å§‹æ™‚åˆ»           | `started_at`    | DateTime               | âœ“    | -          | é–‹å§‹æ™‚é–“                 |
| å®Œäº†æ™‚åˆ»           | `completed_at`  | DateTime               | âœ“    | -          | å®Œäº†æ™‚é–“                 |
| ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸   | `error_message` | String                 | âœ“    | -          | å¤±æ•—æ™‚ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸         |
| ä½œæˆæ—¥æ™‚           | `created_at`    | DateTime               | âœ—    | now()      | ãƒ¬ã‚³ãƒ¼ãƒ‰ä½œæˆæ—¥æ™‚         |
| æ›´æ–°æ—¥æ™‚           | `updated_at`    | DateTime               | âœ—    | -          | ãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°æ—¥æ™‚         |

**åˆ¶ç´„**:

- ä¸»ã‚­ãƒ¼: `id`
- å¤–éƒ¨ã‚­ãƒ¼: `rule_id` â†’ tag_automation_rules.idï¼ˆCASCADEï¼‰
- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹: `rule_id`

### 13. ã‚¿ã‚°ä»˜ä¸å±¥æ­´ï¼ˆtag_assignment_historyï¼‰

**æ¦‚è¦**: æ‰‹å‹•/è‡ªå‹•ã‚’å•ã‚ãšã‚¿ã‚°ä»˜ä¸ãƒ»å‰¥å¥ªæ“ä½œã®å±¥æ­´ã‚’ä¿ç®¡

| ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å | ç‰©ç†å              | ãƒ‡ãƒ¼ã‚¿å‹             | NULL | ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ | èª¬æ˜                           |
| ------------ | ------------------- | -------------------- | ---- | ---------- | ------------------------------ |
| ID           | `id`                | String               | âœ—    | uuid()     | ä¸»ã‚­ãƒ¼ï¼ˆUUIDï¼‰                 |
| çŒ«ID         | `cat_id`            | String               | âœ—    | -          | å¯¾è±¡çŒ«ï¼ˆå¤–éƒ¨ã‚­ãƒ¼ï¼‰             |
| ã‚¿ã‚°ID       | `tag_id`            | String               | âœ—    | -          | å¯¾è±¡ã‚¿ã‚°ï¼ˆå¤–éƒ¨ã‚­ãƒ¼ï¼‰           |
| ãƒ«ãƒ¼ãƒ«ID     | `rule_id`           | String               | âœ“    | -          | è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ï¼ˆä»»æ„ï¼‰           |
| å®Ÿè¡ŒID       | `automation_run_id` | String               | âœ“    | -          | è‡ªå‹•åŒ–å®Ÿè¡Œå±¥æ­´ï¼ˆä»»æ„ï¼‰         |
| ã‚¢ã‚¯ã‚·ãƒ§ãƒ³   | `action`            | TagAssignmentAction  | âœ—    | ASSIGNED   | ASSIGNED / UNASSIGNED         |
| ã‚½ãƒ¼ã‚¹       | `source`            | TagAssignmentSource  | âœ—    | MANUAL     | MANUAL / AUTOMATION / SYSTEM |
| ç†ç”±         | `reason`            | String               | âœ“    | -          | æ“ä½œç†ç”±                       |
| ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿   | `metadata`          | Json                 | âœ“    | -          | è¿½åŠ æƒ…å ±                       |
| ä½œæˆæ—¥æ™‚     | `created_at`        | DateTime             | âœ—    | now()      | ãƒ¬ã‚³ãƒ¼ãƒ‰ä½œæˆæ—¥æ™‚               |

**åˆ¶ç´„**:

- ä¸»ã‚­ãƒ¼: `id`
- å¤–éƒ¨ã‚­ãƒ¼: `cat_id` â†’ cats.idï¼ˆCASCADEï¼‰
- å¤–éƒ¨ã‚­ãƒ¼: `tag_id` â†’ tags.idï¼ˆCASCADEï¼‰
- å¤–éƒ¨ã‚­ãƒ¼: `rule_id` â†’ tag_automation_rules.idï¼ˆSET NULLï¼‰
- å¤–éƒ¨ã‚­ãƒ¼: `automation_run_id` â†’ tag_automation_runs.idï¼ˆSET NULLï¼‰
- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹: `cat_id`, `tag_id`, `rule_id`, `automation_run_id`
### 14. è¡€çµ±æƒ…å ±ï¼ˆpedigreesï¼‰

**æ¦‚è¦**: è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã¨å®¶ç³»å›³æƒ…å ±ã‚’ç®¡ç†ã™ã‚‹è¤‡é›‘ãªãƒ†ãƒ¼ãƒ–ãƒ«

| ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å | ç‰©ç†å                | ãƒ‡ãƒ¼ã‚¿å‹ | NULL | ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ | èª¬æ˜                   |
| ------------ | --------------------- | -------- | ---- | ---------- | ---------------------- |
| ID           | `id`                  | String   | âœ—    | uuid()     | ä¸»ã‚­ãƒ¼ï¼ˆUUIDï¼‰         |
| è¡€çµ±æ›¸ID     | `pedigree_id`         | String   | âœ—    | -          | è¡€çµ±æ›¸ã®è­˜åˆ¥ç•ªå·       |
| çŒ«ID         | `cat_id`              | String   | âœ“    | -          | å¯¾è±¡çŒ«ï¼ˆå¤–éƒ¨ã‚­ãƒ¼ï¼‰     |
| ã‚¿ã‚¤ãƒˆãƒ«     | `title`               | String   | âœ“    | -          | ç§°å·ãƒ»ã‚¿ã‚¤ãƒˆãƒ«         |
| çŒ«å         | `cat_name`            | String   | âœ—    | -          | è¡€çµ±æ›¸è¨˜è¼‰å           |
| çŒ«å2        | `cat_name2`           | String   | âœ“    | -          | åˆ¥åãƒ»é€šç§°             |
| çŒ«ç¨®ID       | `breed_id`            | String   | âœ“    | -          | å“ç¨®ï¼ˆå¤–éƒ¨ã‚­ãƒ¼ï¼‰       |
| çŒ«ç¨®ã‚³ãƒ¼ãƒ‰   | `breed_code`          | Int      | âœ“    | -          | å“ç¨®ã®æ•°å€¤ã‚³ãƒ¼ãƒ‰       |
| æ€§åˆ¥         | `gender`              | Int      | âœ“    | -          | æ€§åˆ¥ï¼ˆ1=ã‚ªã‚¹ã€2=ãƒ¡ã‚¹ï¼‰ |
| ç›®è‰²         | `eye_color`           | String   | âœ“    | -          | ç›®ã®è‰²                 |
| æ¯›è‰²ID       | `color_id`            | String   | âœ“    | -          | æ¯›è‰²ï¼ˆå¤–éƒ¨ã‚­ãƒ¼ï¼‰       |
| æ¯›è‰²ã‚³ãƒ¼ãƒ‰   | `coat_color_code`     | Int      | âœ“    | -          | æ¯›è‰²ã®æ•°å€¤ã‚³ãƒ¼ãƒ‰       |
| ç”Ÿå¹´æœˆæ—¥     | `birth_date`          | DateTime | âœ“    | -          | èª•ç”Ÿæ—¥                 |
| ç™»éŒ²æ—¥       | `registration_date`   | DateTime | âœ“    | -          | è¡€çµ±æ›¸ç™»éŒ²æ—¥           |
| ç™ºè¡Œæ—¥       | `pedigree_issue_date` | DateTime | âœ“    | -          | è¡€çµ±æ›¸ç™ºè¡Œæ—¥           |
| ç¹æ®–è€…å     | `breeder_name`        | String   | âœ“    | -          | ãƒ–ãƒªãƒ¼ãƒ€ãƒ¼å           |
| æ‰€æœ‰è€…å     | `owner_name`          | String   | âœ“    | -          | æ‰€æœ‰è€…å               |
| å…„å¼Ÿæ•°       | `brother_count`       | Int      | âœ“    | -          | å…„å¼Ÿã®æ•°               |
| å§‰å¦¹æ•°       | `sister_count`        | Int      | âœ“    | -          | å§‰å¦¹ã®æ•°               |
| å‚™è€ƒ         | `notes`               | String   | âœ“    | -          | æ‘˜è¦                   |
| å‚™è€ƒ2        | `notes2`              | String   | âœ“    | -          | æ‘˜è¦2                  |
| ä»–å›£ä½“ç•ªå·   | `other_no`            | String   | âœ“    | -          | ä»–ã®ç™»éŒ²å›£ä½“ç•ªå·       |
| æ—§ã‚³ãƒ¼ãƒ‰     | `old_code`            | String   | âœ“    | -          | æ—§ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ‰       |
| ä½œæˆæ—¥æ™‚     | `created_at`          | DateTime | âœ—    | now()      | ãƒ¬ã‚³ãƒ¼ãƒ‰ä½œæˆæ—¥æ™‚       |
| æ›´æ–°æ—¥æ™‚     | `updated_at`          | DateTime | âœ—    | -          | ãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°æ—¥æ™‚       |

**è¡€çµ±é–¢ä¿‚ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰**:

| ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å | ç‰©ç†å                    | ãƒ‡ãƒ¼ã‚¿å‹ | NULL | èª¬æ˜           |
| ------------ | ------------------------- | -------- | ---- | -------------- |
| çˆ¶è¡€çµ±ID     | `father_pedigree_id`      | String   | âœ“    | çˆ¶è¦ªã®è¡€çµ±è¨˜éŒ² |
| æ¯è¡€çµ±ID     | `mother_pedigree_id`      | String   | âœ“    | æ¯è¦ªã®è¡€çµ±è¨˜éŒ² |
| çˆ¶æ–¹ç¥–çˆ¶ID   | `paternal_grandfather_id` | String   | âœ“    | çˆ¶æ–¹ã®ç¥–çˆ¶     |
| çˆ¶æ–¹ç¥–æ¯ID   | `paternal_grandmother_id` | String   | âœ“    | çˆ¶æ–¹ã®ç¥–æ¯     |
| æ¯æ–¹ç¥–çˆ¶ID   | `maternal_grandfather_id` | String   | âœ“    | æ¯æ–¹ã®ç¥–çˆ¶     |
| æ¯æ–¹ç¥–æ¯ID   | `maternal_grandmother_id` | String   | âœ“    | æ¯æ–¹ã®ç¥–æ¯     |

**åˆ¶ç´„**:

- ä¸»ã‚­ãƒ¼: `id`
- ãƒ¦ãƒ‹ãƒ¼ã‚¯åˆ¶ç´„: `pedigree_id`
- å¤–éƒ¨ã‚­ãƒ¼: `cat_id` â†’ cats.id
- å¤–éƒ¨ã‚­ãƒ¼: `breed_id` â†’ breeds.id, `color_id` â†’ coat_colors.id
- è‡ªå·±å‚ç…§å¤–éƒ¨ã‚­ãƒ¼: å„è¡€çµ±é–¢ä¿‚ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ â†’ pedigrees.id

**è‡ªå·±å‚ç…§ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³**:

- â†’ fatherPedigreeï¼ˆå¤šå¯¾1ï¼‰: çˆ¶è¦ªè¡€çµ±
- â†’ motherPedigreeï¼ˆå¤šå¯¾1ï¼‰: æ¯è¦ªè¡€çµ±
- â†’ paternalGrandfatherï¼ˆå¤šå¯¾1ï¼‰: çˆ¶æ–¹ç¥–çˆ¶
- â†’ paternalGrandmotherï¼ˆå¤šå¯¾1ï¼‰: çˆ¶æ–¹ç¥–æ¯
- â†’ maternalGrandfatherï¼ˆå¤šå¯¾1ï¼‰: æ¯æ–¹ç¥–çˆ¶
- â†’ maternalGrandmotherï¼ˆå¤šå¯¾1ï¼‰: æ¯æ–¹ç¥–æ¯
- â†’ fatherOfï¼ˆ1å¯¾å¤šï¼‰: çˆ¶è¦ªã¨ã—ã¦ã®å­å­«


### 15. çŒ«ã‚¿ã‚°é–¢é€£ï¼ˆcat_tagsï¼‰

**æ¦‚è¦**: çŒ«ã¨ã‚¿ã‚°ã®å¤šå¯¾å¤šé–¢ä¿‚ã‚’ç®¡ç†ã™ã‚‹ä¸­é–“ãƒ†ãƒ¼ãƒ–ãƒ«

| ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å | ç‰©ç†å       | ãƒ‡ãƒ¼ã‚¿å‹ | NULL | ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ | èª¬æ˜                 |
| ------------ | ------------ | -------- | ---- | ---------- | -------------------- |
| çŒ«ID         | `cat_id`     | String   | âœ—    | -          | å¯¾è±¡çŒ«ï¼ˆå¤–éƒ¨ã‚­ãƒ¼ï¼‰   |
| ã‚¿ã‚°ID       | `tag_id`     | String   | âœ—    | -          | å¯¾è±¡ã‚¿ã‚°ï¼ˆå¤–éƒ¨ã‚­ãƒ¼ï¼‰ |
| ä½œæˆæ—¥æ™‚     | `created_at` | DateTime | âœ—    | now()      | é–¢é€£ä½œæˆæ—¥æ™‚         |

**åˆ¶ç´„**:

- è¤‡åˆä¸»ã‚­ãƒ¼: `(cat_id, tag_id)`
- å¤–éƒ¨ã‚­ãƒ¼: `cat_id` â†’ cats.idï¼ˆCASCADEå‰Šé™¤ï¼‰
- å¤–éƒ¨ã‚­ãƒ¼: `tag_id` â†’ tags.idï¼ˆCASCADEå‰Šé™¤ï¼‰

---

## ğŸ”— ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³è¨­è¨ˆè©³ç´°

### ä¸»è¦ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å›³

```
users (1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ (âˆ) cats
  â”‚                      â”‚
  â”‚                      â”œâ”€â”€ (âˆ) breeding_records
  â”‚                      â”œâ”€â”€ (âˆ) care_records
  â”‚                      â”œâ”€â”€ (âˆ) schedules
  â”‚                      â”œâ”€â”€ (âˆ) pedigrees
  â”‚                      â””â”€â”€ (âˆ) cat_tags (âˆ) â”€â”€â†’ (1) tags
  â”‚
  â”œâ”€â”€ (âˆ) breeding_records
  â”œâ”€â”€ (âˆ) care_records
  â”œâ”€â”€ (âˆ) schedules
  â””â”€â”€ (âˆ) login_attempts

breeds (1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ (âˆ) cats
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ (âˆ) pedigrees

coat_colors (1) â”€â”€â”€â”€â”€â†’ (âˆ) cats
               â””â”€â”€â”€â”€â”€â†’ (âˆ) pedigrees

cats (1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ (âˆ) cats (è‡ªå·±å‚ç…§: è¦ªå­é–¢ä¿‚)

pedigrees (1) â”€â”€â”€â”€â”€â”€â”€â†’ (âˆ) pedigrees (è‡ªå·±å‚ç…§: è¡€çµ±é–¢ä¿‚)
```

### 1. ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸­å¿ƒã®ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

**users â†’ catsï¼ˆ1å¯¾å¤šï¼‰**

- é–¢ä¿‚: ä¸€äººã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¤‡æ•°ã®çŒ«ã‚’æ‰€æœ‰
- å¤–éƒ¨ã‚­ãƒ¼: cats.owner_id â†’ users.id
- å‰Šé™¤åˆ¶ç´„: RESTRICTï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼å‰Šé™¤æ™‚ã¯çŒ«ã®æ‰€æœ‰æ¨©ç§»è»¢ãŒå¿…è¦ï¼‰

**users â†’ breeding_recordsï¼ˆ1å¯¾å¤šï¼‰**

- é–¢ä¿‚: ä¸€äººã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¤‡æ•°ã®äº¤é…è¨˜éŒ²ã‚’ä½œæˆ
- å¤–éƒ¨ã‚­ãƒ¼: breeding_records.recorded_by â†’ users.id
- å‰Šé™¤åˆ¶ç´„: RESTRICTï¼ˆè¨˜éŒ²ã®æ•´åˆæ€§ä¿æŒï¼‰

**users â†’ care_recordsï¼ˆ1å¯¾å¤šï¼‰**

- é–¢ä¿‚: ä¸€äººã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¤‡æ•°ã®ã‚±ã‚¢è¨˜éŒ²ã‚’ä½œæˆ
- å¤–éƒ¨ã‚­ãƒ¼: care_records.recorded_by â†’ users.id
- å‰Šé™¤åˆ¶ç´„: RESTRICTï¼ˆè¨˜éŒ²ã®æ•´åˆæ€§ä¿æŒï¼‰

**users â†’ schedulesï¼ˆ1å¯¾å¤šï¼‰**

- é–¢ä¿‚: ä¸€äººã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¤‡æ•°ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ‹…å½“
- å¤–éƒ¨ã‚­ãƒ¼: schedules.assigned_to â†’ users.id
- å‰Šé™¤åˆ¶ç´„: RESTRICTï¼ˆã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å†å‰²ã‚Šå½“ã¦ãŒå¿…è¦ï¼‰

**users â†’ login_attemptsï¼ˆ1å¯¾å¤šï¼‰**

- é–¢ä¿‚: ä¸€äººã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¤‡æ•°ã®ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œå±¥æ­´ã‚’æŒã¤
- å¤–éƒ¨ã‚­ãƒ¼: login_attempts.user_id â†’ users.id
- å‰Šé™¤åˆ¶ç´„: CASCADEï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼å‰Šé™¤æ™‚ã«å±¥æ­´ã‚‚å‰Šé™¤ï¼‰

### 2. çŒ«ä¸­å¿ƒã®ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

**cats â†’ catsï¼ˆè‡ªå·±å‚ç…§ã€è¦ªå­é–¢ä¿‚ï¼‰**

- fatheré–¢ä¿‚: cats.father_id â†’ cats.idï¼ˆå¤šå¯¾1ï¼‰
- motheré–¢ä¿‚: cats.mother_id â†’ cats.idï¼ˆå¤šå¯¾1ï¼‰
- fatherOfé–¢ä¿‚: 1å¯¾å¤šï¼ˆé€†æ–¹å‘ï¼‰
- motherOfé–¢ä¿‚: 1å¯¾å¤šï¼ˆé€†æ–¹å‘ï¼‰
- å‰Šé™¤åˆ¶ç´„: SET NULLï¼ˆè¦ªãŒå‰Šé™¤ã•ã‚Œã¦ã‚‚å­ã¯æ®‹ã‚‹ï¼‰

**breeds â†’ catsï¼ˆ1å¯¾å¤šï¼‰**

- é–¢ä¿‚: ä¸€ã¤ã®å“ç¨®ã«è¤‡æ•°ã®çŒ«ãŒå±ã™ã‚‹
- å¤–éƒ¨ã‚­ãƒ¼: cats.breed_id â†’ breeds.id
- å‰Šé™¤åˆ¶ç´„: SET NULLï¼ˆå“ç¨®å‰Šé™¤æ™‚ã¯NULLã«è¨­å®šï¼‰

**coat_colors â†’ catsï¼ˆ1å¯¾å¤šï¼‰**

- é–¢ä¿‚: ä¸€ã¤ã®æ¯›è‰²ã«è¤‡æ•°ã®çŒ«ãŒå±ã™ã‚‹
- å¤–éƒ¨ã‚­ãƒ¼: cats.color_id â†’ coat_colors.id
- å‰Šé™¤åˆ¶ç´„: SET NULLï¼ˆæ¯›è‰²å‰Šé™¤æ™‚ã¯NULLã«è¨­å®šï¼‰

**cats â†’ breeding_recordsï¼ˆ1å¯¾å¤šã€åŒæ–¹å‘ï¼‰**

- maleé–¢ä¿‚: breeding_records.male_id â†’ cats.id
- femaleé–¢ä¿‚: breeding_records.female_id â†’ cats.id
- å‰Šé™¤åˆ¶ç´„: RESTRICTï¼ˆäº¤é…è¨˜éŒ²ãŒã‚ã‚‹çŒ«ã¯å‰Šé™¤ä¸å¯ï¼‰

**cats â†’ care_recordsï¼ˆ1å¯¾å¤šï¼‰**

- é–¢ä¿‚: ä¸€åŒ¹ã®çŒ«ãŒè¤‡æ•°ã®ã‚±ã‚¢è¨˜éŒ²ã‚’æŒã¤
- å¤–éƒ¨ã‚­ãƒ¼: care_records.cat_id â†’ cats.id
- å‰Šé™¤åˆ¶ç´„: CASCADEï¼ˆçŒ«å‰Šé™¤æ™‚ã«ã‚±ã‚¢è¨˜éŒ²ã‚‚å‰Šé™¤ï¼‰

**cats â†’ schedulesï¼ˆ1å¯¾å¤šï¼‰**

- é–¢ä¿‚: ä¸€åŒ¹ã®çŒ«ãŒè¤‡æ•°ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æŒã¤
- å¤–éƒ¨ã‚­ãƒ¼: schedules.cat_id â†’ cats.id
- å‰Šé™¤åˆ¶ç´„: SET NULLï¼ˆçŒ«å‰Šé™¤æ™‚ã¯ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯æ±ç”¨ã«å¤‰æ›´ï¼‰

**cats â†’ pedigreesï¼ˆ1å¯¾å¤šï¼‰**

- é–¢ä¿‚: ä¸€åŒ¹ã®çŒ«ãŒè¤‡æ•°ã®è¡€çµ±è¨˜éŒ²ã‚’æŒã¤ï¼ˆç¨€ï¼‰
- å¤–éƒ¨ã‚­ãƒ¼: pedigrees.cat_id â†’ cats.id
- å‰Šé™¤åˆ¶ç´„: SET NULLï¼ˆçŒ«å‰Šé™¤æ™‚ã‚‚è¡€çµ±è¨˜éŒ²ã¯ä¿æŒï¼‰

### 3. è¡€çµ±é–¢ä¿‚ã®ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

**pedigrees â†’ pedigreesï¼ˆè‡ªå·±å‚ç…§ã€è¡€çµ±é–¢ä¿‚ï¼‰**

**ç›´ç³»è¡€çµ±é–¢ä¿‚**:

- fatherPedigree: pedigrees.father_pedigree_id â†’ pedigrees.id
- motherPedigree: pedigrees.mother_pedigree_id â†’ pedigrees.id
- fatherOf: 1å¯¾å¤šï¼ˆé€†æ–¹å‘ï¼‰
- motherOf: 1å¯¾å¤šï¼ˆé€†æ–¹å‘ï¼‰

**ç¥–çˆ¶æ¯é–¢ä¿‚**:

- paternalGrandfather: pedigrees.paternal_grandfather_id â†’ pedigrees.id
- paternalGrandmother: pedigrees.paternal_grandmother_id â†’ pedigrees.id
- maternalGrandfather: pedigrees.maternal_grandfather_id â†’ pedigrees.id
- maternalGrandmother: pedigrees.maternal_grandmother_id â†’ pedigrees.id
- å„ç¥–çˆ¶æ¯ã‹ã‚‰ã®é€†æ–¹å‘1å¯¾å¤šé–¢ä¿‚

**å‰Šé™¤åˆ¶ç´„**: SET NULLï¼ˆè¡€çµ±è¨˜éŒ²å‰Šé™¤æ™‚ã‚‚é–¢ä¿‚æ€§ã¯ä¿æŒï¼‰

**breeds â†’ pedigreesï¼ˆ1å¯¾å¤šï¼‰**

- é–¢ä¿‚: ä¸€ã¤ã®å“ç¨®ã«è¤‡æ•°ã®è¡€çµ±è¨˜éŒ²
- å¤–éƒ¨ã‚­ãƒ¼: pedigrees.breed_id â†’ breeds.id
- å‰Šé™¤åˆ¶ç´„: SET NULL

**coat_colors â†’ pedigreesï¼ˆ1å¯¾å¤šï¼‰**

- é–¢ä¿‚: ä¸€ã¤ã®æ¯›è‰²ã«è¤‡æ•°ã®è¡€çµ±è¨˜éŒ²
- å¤–éƒ¨ã‚­ãƒ¼: pedigrees.color_id â†’ coat_colors.id
- å‰Šé™¤åˆ¶ç´„: SET NULL

### 4. ã‚¿ã‚°é–¢ä¿‚ã®ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

**cats â†” tagsï¼ˆå¤šå¯¾å¤šã€cat_tagsçµŒç”±ï¼‰**

- ä¸­é–“ãƒ†ãƒ¼ãƒ–ãƒ«: cat_tags
- é–¢ä¿‚1: cat_tags.cat_id â†’ cats.id
- é–¢ä¿‚2: cat_tags.tag_id â†’ tags.id
- å‰Šé™¤åˆ¶ç´„: CASCADEï¼ˆçŒ«ã¾ãŸã¯ã‚¿ã‚°å‰Šé™¤æ™‚ã«é–¢é€£ã‚‚å‰Šé™¤ï¼‰

---

## ğŸ“‹ åˆ—æŒ™å‹ï¼ˆEnumï¼‰å®šç¾©

### 1. UserRoleï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«ï¼‰

```
USER         - ä¸€èˆ¬ãƒ¦ãƒ¼ã‚¶ãƒ¼
ADMIN        - ç®¡ç†è€…
SUPER_ADMIN  - ã‚¹ãƒ¼ãƒ‘ãƒ¼ç®¡ç†è€…
```

### 2. Genderï¼ˆæ€§åˆ¥ï¼‰

```
MALE    - ã‚ªã‚¹
FEMALE  - ãƒ¡ã‚¹
```

### 3. BreedingStatusï¼ˆäº¤é…ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ï¼‰

```
PLANNED      - è¨ˆç”»ä¸­
IN_PROGRESS  - é€²è¡Œä¸­
COMPLETED    - å®Œäº†
FAILED       - å¤±æ•—
```

### 4. CareTypeï¼ˆã‚±ã‚¢ç¨®åˆ¥ï¼‰

```
VACCINATION   - äºˆé˜²æ¥ç¨®
HEALTH_CHECK  - å¥åº·è¨ºæ–­
GROOMING      - ã‚°ãƒ«ãƒ¼ãƒŸãƒ³ã‚°
DENTAL_CARE   - æ­¯ç§‘ã‚±ã‚¢
MEDICATION    - æŠ•è–¬
SURGERY       - æ‰‹è¡“
OTHER         - ãã®ä»–
```

### 5. ScheduleTypeï¼ˆã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ç¨®åˆ¥ï¼‰

```
BREEDING     - ç¹æ®–é–¢é€£
CARE         - ã‚±ã‚¢é–¢é€£
APPOINTMENT  - è¨ºå¯Ÿäºˆç´„
REMINDER     - ãƒªãƒã‚¤ãƒ³ãƒ€ãƒ¼
MAINTENANCE  - ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹
```

### 6. ScheduleStatusï¼ˆã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ï¼‰

```
PENDING      - æœªå®Ÿè¡Œ
IN_PROGRESS  - å®Ÿè¡Œä¸­
COMPLETED    - å®Œäº†
CANCELLED    - ã‚­ãƒ£ãƒ³ã‚»ãƒ«
```

### 7. Priorityï¼ˆå„ªå…ˆåº¦ï¼‰

```
LOW     - ä½
MEDIUM  - ä¸­
HIGH    - é«˜
URGENT  - ç·Šæ€¥
```

---

## ğŸ”’ åˆ¶ç´„ã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹

### ä¸»è¦åˆ¶ç´„ä¸€è¦§

**ä¸€æ„åˆ¶ç´„ï¼ˆUNIQUEï¼‰**:

- users.clerk_id
- users.email
- breeds.code, breeds.name
- coat_colors.code, coat_colors.name
- cats.registration_id
- cats.microchip_id
- tags.name
- pedigrees.pedigree_id

**å¤–éƒ¨ã‚­ãƒ¼åˆ¶ç´„ï¼ˆFOREIGN KEYï¼‰**:

- å…¨ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã«é©ç”¨
- å‰Šé™¤æ™‚ã®å‹•ä½œã¯é–¢ä¿‚æ€§ã«ã‚ˆã‚Šè¨­å®š

**éNULLåˆ¶ç´„ï¼ˆNOT NULLï¼‰**:

- å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«é©ç”¨
- ä¸»ã‚­ãƒ¼ã€å¿…é ˆã®æ¥­å‹™ãƒ‡ãƒ¼ã‚¿

### æ¨å¥¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹

**ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Šã®ãŸã‚ä»¥ä¸‹ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ¨å¥¨**:

```sql
-- ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¤œç´¢ç”¨
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_role ON users(role);

-- çŒ«æ¤œç´¢ç”¨
CREATE INDEX idx_cats_owner_id ON cats(owner_id);
CREATE INDEX idx_cats_breed_id ON cats(breed_id);
CREATE INDEX idx_cats_color_id ON cats(color_id);
CREATE INDEX idx_cats_birth_date ON cats(birth_date);
CREATE INDEX idx_cats_gender ON cats(gender);

-- è¡€çµ±æ¤œç´¢ç”¨
CREATE INDEX idx_pedigrees_cat_id ON pedigrees(cat_id);
CREATE INDEX idx_pedigrees_father_pedigree_id ON pedigrees(father_pedigree_id);
CREATE INDEX idx_pedigrees_mother_pedigree_id ON pedigrees(mother_pedigree_id);

-- è¨˜éŒ²æ¤œç´¢ç”¨
CREATE INDEX idx_breeding_records_male_id ON breeding_records(male_id);
CREATE INDEX idx_breeding_records_female_id ON breeding_records(female_id);
CREATE INDEX idx_breeding_records_breeding_date ON breeding_records(breeding_date);

CREATE INDEX idx_care_records_cat_id ON care_records(cat_id);
CREATE INDEX idx_care_records_care_date ON care_records(care_date);
CREATE INDEX idx_care_records_care_type ON care_records(care_type);

CREATE INDEX idx_schedules_cat_id ON schedules(cat_id);
CREATE INDEX idx_schedules_assigned_to ON schedules(assigned_to);
CREATE INDEX idx_schedules_schedule_date ON schedules(schedule_date);
CREATE INDEX idx_schedules_status ON schedules(status);
```

---

## ğŸš€ æœ¬ç•ªç’°å¢ƒãƒ‡ãƒ—ãƒ­ã‚¤æ™‚ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­å®š

### 1. ç’°å¢ƒå¤‰æ•°è¨­å®š

```bash
# ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶š
DATABASE_URL="postgresql://username:password@localhost:5432/mycats_production"

# Prismaè¨­å®š
PRISMA_QUERY_ENGINE_LIBRARY="true"
```

### 2. ãƒ‡ãƒ—ãƒ­ã‚¤æ‰‹é †

```bash
# 1. ä¾å­˜é–¢ä¿‚ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
pnpm install --frozen-lockfile

# 2. Prismaã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆç”Ÿæˆ
pnpm -w run db:generate

# 3. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
pnpm -w run db:deploy

# 4. ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ“ãƒ«ãƒ‰
pnpm run build

# 5. æœ¬ç•ªã‚µãƒ¼ãƒãƒ¼èµ·å‹•
NODE_ENV=production node backend/dist/main.js
```

### 3. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆæœŸåŒ–

**æœ¬ç•ªç’°å¢ƒã§ã¯ä»¥ä¸‹ã®åˆæœŸãƒ‡ãƒ¼ã‚¿ãŒå¿…è¦**:

1. **ç®¡ç†è€…ãƒ¦ãƒ¼ã‚¶ãƒ¼**: ã‚·ã‚¹ãƒ†ãƒ ç®¡ç†ç”¨
2. **åŸºæœ¬å“ç¨®ãƒ‡ãƒ¼ã‚¿**: breeds ãƒ†ãƒ¼ãƒ–ãƒ«
3. **åŸºæœ¬æ¯›è‰²ãƒ‡ãƒ¼ã‚¿**: coat_colors ãƒ†ãƒ¼ãƒ–ãƒ«
4. **åŸºæœ¬ã‚¿ã‚°**: tags ãƒ†ãƒ¼ãƒ–ãƒ«

### 4. ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æˆ¦ç•¥

**æ¨å¥¨ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—è¨­å®š**:

- **å®šæœŸãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—**: æ—¥æ¬¡è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
- **å·®åˆ†ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—**: æ™‚é–“å˜ä½ã®å·®åˆ†ä¿å­˜
- **ãƒ¬ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³**: èª­ã¿å–ã‚Šå°‚ç”¨ãƒ¬ãƒ—ãƒªã‚«ã®è¨­å®š
- **ãƒã‚¤ãƒ³ãƒˆã‚¤ãƒ³ã‚¿ã‚¤ãƒ ãƒªã‚«ãƒãƒª**: WALãƒ­ã‚°ã®ä¿æŒ

---

## ğŸ“ˆ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è€ƒæ…®äº‹é …

### 1. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆä¸Šã®æœ€é©åŒ–

**æ­£è¦åŒ–ãƒ¬ãƒ™ãƒ«**: ç¬¬3æ­£è¦å½¢ã¾ã§é©ç”¨
**éæ­£è¦åŒ–ç®‡æ‰€**: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹é‡è¦–ç®‡æ‰€ã§ã®æ„å›³çš„ãªéæ­£è¦åŒ–
**ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–æˆ¦ç•¥**: å¤ã„ãƒ‡ãƒ¼ã‚¿ã®åˆ¥ãƒ†ãƒ¼ãƒ–ãƒ«ç§»è¡Œ

### 2. ã‚¯ã‚¨ãƒªæœ€é©åŒ–

**é »ç¹ãªã‚¯ã‚¨ãƒªãƒ‘ã‚¿ãƒ¼ãƒ³**:

- æ‰€æœ‰è€…åˆ¥çŒ«ä¸€è¦§
- çŒ«ã®è¡€çµ±æ¤œç´¢
- æœŸé–“åˆ¥ã‚±ã‚¢è¨˜éŒ²
- äºˆå®šæ¸ˆã¿ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«

**æœ€é©åŒ–ã•ã‚ŒãŸã‚¯ã‚¨ãƒªä¾‹**:

```sql
-- æ‰€æœ‰è€…ã®çŒ«ä¸€è¦§ï¼ˆé–¢é€£ãƒ‡ãƒ¼ã‚¿å«ã‚€ï¼‰
SELECT c.*, b.name as breed_name, cc.name as color_name
FROM cats c
LEFT JOIN breeds b ON c.breed_id = b.id
LEFT JOIN coat_colors cc ON c.color_id = cc.id
WHERE c.owner_id = $1 AND c.is_active = true
ORDER BY c.birth_date DESC;

-- è¡€çµ±3ä¸–ä»£æ¤œç´¢
WITH RECURSIVE pedigree_tree AS (
  SELECT id, cat_name, father_pedigree_id, mother_pedigree_id, 0 as generation
  FROM pedigrees WHERE id = $1
  UNION ALL
  SELECT p.id, p.cat_name, p.father_pedigree_id, p.mother_pedigree_id, pt.generation + 1
  FROM pedigrees p
  JOIN pedigree_tree pt ON (p.id = pt.father_pedigree_id OR p.id = pt.mother_pedigree_id)
  WHERE pt.generation < 3
)
SELECT * FROM pedigree_tree;
```

---

## ğŸ” ç›£è¦–ã¨ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹

### 1. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç›£è¦–é …ç›®

**ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–**:

- ã‚¯ã‚¨ãƒªå®Ÿè¡Œæ™‚é–“
- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½¿ç”¨ç‡
- ãƒ†ãƒ¼ãƒ–ãƒ«ã‚µã‚¤ã‚º
- æ¥ç¶šæ•°

**ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ç›£è¦–**:

- å­¤ç«‹ãƒ¬ã‚³ãƒ¼ãƒ‰ã®æ¤œå‡º
- åˆ¶ç´„é•åã®ç¢ºèª
- ãƒ‡ãƒ¼ã‚¿å“è³ªãƒã‚§ãƒƒã‚¯

### 2. å®šæœŸãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹

**æ—¥æ¬¡ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹**:

- çµ±è¨ˆæƒ…å ±æ›´æ–°
- ãƒ­ã‚°ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³
- ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å®Ÿè¡Œ

**é€±æ¬¡ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹**:

- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å†æ§‹ç¯‰
- æ–­ç‰‡åŒ–è§£æ¶ˆ
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æ

**æœˆæ¬¡ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹**:

- ãƒ‡ãƒ¼ã‚¿ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–
- å®¹é‡åˆ†æ
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»

---

## ğŸ“š å‚è€ƒæƒ…å ±

### é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- [README.md](../README.md) - ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦
- [docs/system-design.md](./system-design.md) - ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆ
- [DATABASE_QUICK_REF.md](../DATABASE_QUICK_REF.md) - ã‚¯ã‚¤ãƒƒã‚¯ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹

### æŠ€è¡“ä»•æ§˜

- **Prisma**: https://www.prisma.io/docs
- **PostgreSQL**: https://www.postgresql.org/docs/
- **NestJS**: https://docs.nestjs.com/

---

_æœ€çµ‚æ›´æ–°: 2025å¹´1æœˆ_  
_ä½œæˆè€…: çŒ«ç”Ÿä½“ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ é–‹ç™ºãƒãƒ¼ãƒ _
`````

## File: docs/EMAIL_INTEGRATION_GUIDE.md
`````markdown
# ãƒ¡ãƒ¼ãƒ«é€ä¿¡æ©Ÿèƒ½å®Ÿè£…ã‚¬ã‚¤ãƒ‰ (Resend)

ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ã€NestJSãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«Resendã‚’ä½¿ç”¨ã—ãŸãƒ¡ãƒ¼ãƒ«é€ä¿¡æ©Ÿèƒ½ã‚’å®Ÿè£…ã™ã‚‹æ‰‹é †ã‚’èª¬æ˜ã—ã¾ã™ã€‚

## ãªãœResendã‚’é¸ã‚“ã ã‹?

| ã‚µãƒ¼ãƒ“ã‚¹ | ãƒ¡ãƒªãƒƒãƒˆ | ãƒ‡ãƒ¡ãƒªãƒƒãƒˆ |
|---------|---------|----------|
| **Resend** âœ… | ãƒ»æ—¥æœ¬èªãƒ¡ãƒ¼ãƒ«å¯¾å¿œ<br>ãƒ»ç„¡æ–™æ : 100é€š/æ—¥<br>ãƒ»ã‚·ãƒ³ãƒ—ãƒ«ãªAPI<br>ãƒ»React Emailå¯¾å¿œ | - |
| SendGrid | ãƒ»ä¿¡é ¼æ€§ãŒé«˜ã„<br>ãƒ»ç„¡æ–™æ : 100é€š/æ—¥ | ãƒ»è¨­å®šãŒè¤‡é›‘<br>ãƒ»æ—¥æœ¬èªãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãŒå°‘ãªã„ |
| Google Workspace | ãƒ»ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ¼ãƒ«ä½¿ç”¨å¯ | ãƒ»æœˆé¡èª²é‡‘å¿…é ˆ<br>ãƒ»APIè¨­å®šãŒè¤‡é›‘ |

**çµè«–**: Resend ãŒæœ€é© (ã‚·ãƒ³ãƒ—ãƒ«ãƒ»ä½ã‚³ã‚¹ãƒˆãƒ»æ—¥æœ¬èªå¯¾å¿œ)

---

## ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

```
[NestJS Backend] â†’ [Resend API] â†’ [å—ä¿¡è€…]
     â†“
[EmailModule]
  â”œâ”€â”€ EmailService (ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯)
  â””â”€â”€ ResendClient (APIå‘¼ã³å‡ºã—)
```

---

## ã‚¹ãƒ†ãƒƒãƒ—1: Resendã‚¢ã‚«ã‚¦ãƒ³ãƒˆä½œæˆ

### 1-1. Resendã«ã‚µã‚¤ãƒ³ã‚¢ãƒƒãƒ—

https://resend.com/signup ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã€ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ä½œæˆ

### 1-2. ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’è¿½åŠ 

1. ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã§ã€ŒDomainsã€â†’ã€ŒAdd Domainã€ã‚’ã‚¯ãƒªãƒƒã‚¯
2. `nekoya.co.jp` ã‚’å…¥åŠ›
3. è¡¨ç¤ºã•ã‚Œã‚‹DNSãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’ãƒ¡ãƒ¢

**ä¾‹**:
```
Type: TXT
Name: _resend
Value: resend-domain-verify=abc123xyz
TTL: 3600

Type: MX
Name: @
Value: mx1.resend.com
Priority: 10
TTL: 3600
```

### 1-3. ãŠåå‰.comã§DNSè¨­å®š

ãŠåå‰.comã®ç®¡ç†ç”»é¢ã§ä»¥ä¸‹ã‚’è¿½åŠ :

| ãƒ›ã‚¹ãƒˆå | TYPE | å€¤ | å„ªå…ˆåº¦ | TTL |
|---------|------|-----|-------|-----|
| _resend | TXT | `resend-domain-verify=abc123xyz` | - | 3600 |
| @ | MX | `mx1.resend.com` | 10 | 3600 |

### 1-4. ãƒ‰ãƒ¡ã‚¤ãƒ³æ¤œè¨¼

Resendãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã§ã€ŒVerify Domainã€ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã€æ¤œè¨¼å®Œäº†ã‚’å¾…ã¤ (é€šå¸¸5ã€œ15åˆ†)

### 1-5. APIã‚­ãƒ¼ã‚’å–å¾—

1. ã€ŒAPI Keysã€â†’ã€ŒCreate API Keyã€ã‚’ã‚¯ãƒªãƒƒã‚¯
2. åå‰: `MyCats Pro Backend`
3. Permission: `Sending access`
4. APIã‚­ãƒ¼ã‚’ã‚³ãƒ”ãƒ¼ (ä¾‹: `re_123456789abcdefg`)

---

## ã‚¹ãƒ†ãƒƒãƒ—2: ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã¸ã®å®Ÿè£…

### 2-1. ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

```bash
cd backend
pnpm add resend
```

### 2-2. ç’°å¢ƒå¤‰æ•°ã®è¿½åŠ 

`.env` ã¨ `.env.production` ã«ä»¥ä¸‹ã‚’è¿½åŠ :

```bash
# Resend Email Service
RESEND_API_KEY=re_your_api_key_here
EMAIL_FROM=noreply@nekoya.co.jp
EMAIL_FROM_NAME=MyCats Pro
```

### 2-3. ç’°å¢ƒå¤‰æ•°ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã®æ›´æ–°

`backend/src/common/config/env.validation.ts` ã«è¿½åŠ :

```typescript
// Resend Email
RESEND_API_KEY: z.string().min(1).optional(),
EMAIL_FROM: z.string().email().optional(),
EMAIL_FROM_NAME: z.string().min(1).optional(),
```

### 2-4. EmailModuleã®ä½œæˆ

```bash
cd backend
npx nest generate module email
npx nest generate service email
```

### 2-5. EmailServiceã®å®Ÿè£…

`backend/src/email/email.service.ts`:

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { Resend } from 'resend';

export interface SendEmailDto {
  to: string | string[];
  subject: string;
  html?: string;
  text?: string;
  replyTo?: string;
}

@Injectable()
export class EmailService {
  private readonly logger = new Logger(EmailService.name);
  private readonly resend: Resend;
  private readonly from: string;
  private readonly fromName: string;
  private readonly isEnabled: boolean;

  constructor(private readonly configService: ConfigService) {
    const apiKey = this.configService.get<string>('RESEND_API_KEY');
    this.from = this.configService.get<string>('EMAIL_FROM', 'noreply@nekoya.co.jp');
    this.fromName = this.configService.get<string>('EMAIL_FROM_NAME', 'MyCats Pro');
    
    if (apiKey) {
      this.resend = new Resend(apiKey);
      this.isEnabled = true;
      this.logger.log(`EmailService initialized with from: ${this.fromName} <${this.from}>`);
    } else {
      this.isEnabled = false;
      this.logger.warn('RESEND_API_KEY not set. Email sending is disabled.');
    }
  }

  /**
   * ãƒ¡ãƒ¼ãƒ«ã‚’é€ä¿¡
   */
  async sendEmail(dto: SendEmailDto): Promise<{ success: boolean; messageId?: string }> {
    if (!this.isEnabled) {
      this.logger.warn('Email sending is disabled. Skipping.');
      return { success: false };
    }

    try {
      const response = await this.resend.emails.send({
        from: `${this.fromName} <${this.from}>`,
        to: dto.to,
        subject: dto.subject,
        html: dto.html,
        text: dto.text,
        reply_to: dto.replyTo,
      });

      if (response.error) {
        this.logger.error(`Failed to send email: ${response.error.message}`);
        return { success: false };
      }

      this.logger.log(`Email sent successfully: ${response.data?.id}`);
      return { success: true, messageId: response.data?.id };
    } catch (error) {
      this.logger.error(`Error sending email: ${error.message}`, error.stack);
      return { success: false };
    }
  }

  /**
   * ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆãƒ¡ãƒ¼ãƒ«ã‚’é€ä¿¡
   */
  async sendPasswordResetEmail(email: string, resetToken: string): Promise<boolean> {
    const resetUrl = `https://nekoya.co.jp/reset-password?token=${resetToken}`;

    const html = `
      <!DOCTYPE html>
      <html lang="ja">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆ</title>
      </head>
      <body style="font-family: sans-serif; line-height: 1.6; color: #333;">
        <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
          <h2>ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆ</h2>
          <p>ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å—ã‘ä»˜ã‘ã¾ã—ãŸã€‚</p>
          <p>ä»¥ä¸‹ã®ãƒªãƒ³ã‚¯ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã€æ–°ã—ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’è¨­å®šã—ã¦ãã ã•ã„:</p>
          <p>
            <a href="${resetUrl}" style="display: inline-block; background-color: #007bff; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px;">
              ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆ
            </a>
          </p>
          <p>ã¾ãŸã¯ã€ä»¥ä¸‹ã®URLã‚’ãƒ–ãƒ©ã‚¦ã‚¶ã«ã‚³ãƒ”ãƒ¼&ãƒšãƒ¼ã‚¹ãƒˆã—ã¦ãã ã•ã„:</p>
          <p style="word-break: break-all; color: #007bff;">${resetUrl}</p>
          <p><strong>ã“ã®ãƒªãƒ³ã‚¯ã¯1æ™‚é–“å¾Œã«ç„¡åŠ¹ã«ãªã‚Šã¾ã™ã€‚</strong></p>
          <p>ã“ã®ãƒ¡ãƒ¼ãƒ«ã«å¿ƒå½“ãŸã‚ŠãŒãªã„å ´åˆã¯ã€ç„¡è¦–ã—ã¦ãã ã•ã„ã€‚</p>
          <hr style="margin: 30px 0; border: none; border-top: 1px solid #eee;">
          <p style="font-size: 12px; color: #999;">
            ã“ã®ãƒ¡ãƒ¼ãƒ«ã¯ MyCats Pro ã‹ã‚‰è‡ªå‹•é€ä¿¡ã•ã‚Œã¦ã„ã¾ã™ã€‚<br>
            è¿”ä¿¡ã¯ã§ãã¾ã›ã‚“ã®ã§ã”äº†æ‰¿ãã ã•ã„ã€‚
          </p>
        </div>
      </body>
      </html>
    `;

    const text = `
ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆ

ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å—ã‘ä»˜ã‘ã¾ã—ãŸã€‚
ä»¥ä¸‹ã®URLã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ã€æ–°ã—ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’è¨­å®šã—ã¦ãã ã•ã„:

${resetUrl}

ã“ã®ãƒªãƒ³ã‚¯ã¯1æ™‚é–“å¾Œã«ç„¡åŠ¹ã«ãªã‚Šã¾ã™ã€‚

ã“ã®ãƒ¡ãƒ¼ãƒ«ã«å¿ƒå½“ãŸã‚ŠãŒãªã„å ´åˆã¯ã€ç„¡è¦–ã—ã¦ãã ã•ã„ã€‚
    `;

    const result = await this.sendEmail({
      to: email,
      subject: 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆã®ã”æ¡ˆå†…',
      html,
      text,
    });

    return result.success;
  }

  /**
   * ã‚¦ã‚§ãƒ«ã‚«ãƒ ãƒ¡ãƒ¼ãƒ«ã‚’é€ä¿¡
   */
  async sendWelcomeEmail(email: string, username: string): Promise<boolean> {
    const html = `
      <!DOCTYPE html>
      <html lang="ja">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>ã‚ˆã†ã“ã MyCats Pro ã¸</title>
      </head>
      <body style="font-family: sans-serif; line-height: 1.6; color: #333;">
        <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
          <h2>ã‚ˆã†ã“ãã€${username} ã•ã‚“!</h2>
          <p>MyCats Pro ã¸ã®ã”ç™»éŒ²ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚</p>
          <p>ã•ã£ããã€ã‚ãªãŸã®çŒ«ã¡ã‚ƒã‚“ãŸã¡ã‚’ç™»éŒ²ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚</p>
          <p>
            <a href="https://nekoya.co.jp/cats/new" style="display: inline-block; background-color: #28a745; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px;">
              çŒ«ã‚’ç™»éŒ²ã™ã‚‹
            </a>
          </p>
          <p>ã”ä¸æ˜ãªç‚¹ãŒã”ã–ã„ã¾ã—ãŸã‚‰ã€ãŠæ°—è»½ã«ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚</p>
          <hr style="margin: 30px 0; border: none; border-top: 1px solid #eee;">
          <p style="font-size: 12px; color: #999;">
            MyCats Pro - çŒ«ç”Ÿä½“ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ <br>
            https://nekoya.co.jp
          </p>
        </div>
      </body>
      </html>
    `;

    const result = await this.sendEmail({
      to: email,
      subject: 'MyCats Pro ã¸ã‚ˆã†ã“ã!',
      html,
    });

    return result.success;
  }
}
```

### 2-6. EmailModuleã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆè¨­å®š

`backend/src/email/email.module.ts`:

```typescript
import { Module } from '@nestjs/common';
import { EmailService } from './email.service';

@Module({
  providers: [EmailService],
  exports: [EmailService], // ä»–ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ä½¿ç”¨å¯èƒ½ã«ã™ã‚‹
})
export class EmailModule {}
```

### 2-7. AppModuleã¸ã®ç™»éŒ²

`backend/src/app.module.ts`:

```typescript
import { EmailModule } from './email/email.module';

@Module({
  imports: [
    // ... æ—¢å­˜ã®imports
    EmailModule,
  ],
  // ...
})
export class AppModule {}
```

---

## ã‚¹ãƒ†ãƒƒãƒ—3: Secret Managerã¸ã®ç™»éŒ²

### 3-1. Resend APIã‚­ãƒ¼ã‚’Secret Managerã«ä¿å­˜

**é‡è¦**: `EMAIL_FROM` ã¨ `EMAIL_FROM_NAME` ã¯æ©Ÿå¯†æƒ…å ±ã§ã¯ãªã„ãŸã‚ã€Secret Managerã§ã¯ãªãç’°å¢ƒå¤‰æ•°ã¨ã—ã¦ç›´æ¥è¨­å®šã—ã¾ã™ã€‚

```bash
# Resend APIã‚­ãƒ¼ã®ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã‚’ä½œæˆ
gcloud secrets create RESEND_API_KEY \
  --replication-policy="automatic" \
  --project=my-cats-pro

# å€¤ã‚’è¨­å®š
echo -n "re_your_actual_api_key_here" | \
  gcloud secrets versions add RESEND_API_KEY \
    --data-file=- \
    --project=my-cats-pro
```

### 3-2. Cloud Runã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«æ¨©é™ä»˜ä¸

```bash
gcloud secrets add-iam-policy-binding RESEND_API_KEY \
  --member="serviceAccount:cloud-run-backend@my-cats-pro.iam.gserviceaccount.com" \
  --role="roles/secretmanager.secretAccessor" \
  --project=my-cats-pro
```

---

## ã‚¹ãƒ†ãƒƒãƒ—4: cloudbuild.yamlã®æ›´æ–°

`cloudbuild.yaml` ã®ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒ‡ãƒ—ãƒ­ã‚¤ã‚¹ãƒ†ãƒƒãƒ—ã«ç’°å¢ƒå¤‰æ•°ã‚’è¿½åŠ :

```yaml
--set-secrets "DATABASE_URL=...,RESEND_API_KEY=${_RESEND_API_KEY_SECRET_NAME}:${_RESEND_API_KEY_SECRET_VERSION}" \
--set-env-vars "NODE_ENV=${_ENVIRONMENT},EMAIL_FROM=${_EMAIL_FROM},EMAIL_FROM_NAME=${_EMAIL_FROM_NAME}"
```

ç½®æ›å¤‰æ•°ã‚’è¿½åŠ :

```yaml
substitutions:
  _RESEND_API_KEY_SECRET_NAME: RESEND_API_KEY_${_ENVIRONMENT}
  _RESEND_API_KEY_SECRET_VERSION: latest
  _EMAIL_FROM: noreply@nekoya.co.jp
  _EMAIL_FROM_NAME: MyCats Pro
```

---

## ã‚¹ãƒ†ãƒƒãƒ—5: ä½¿ç”¨ä¾‹

### AuthServiceã§ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆãƒ¡ãƒ¼ãƒ«ã‚’é€ä¿¡

`backend/src/auth/auth.service.ts`:

```typescript
import { EmailService } from '../email/email.service';

@Injectable()
export class AuthService {
  constructor(
    // ... æ—¢å­˜ã®ä¾å­˜æ€§
    private readonly emailService: EmailService,
  ) {}

  async requestPasswordReset(email: string): Promise<void> {
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’æ¤œç´¢
    const user = await this.userRepository.findByEmail(email);
    if (!user) {
      // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå­˜åœ¨ã—ãªã„å ´åˆã‚‚æˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã™
      return;
    }

    // ãƒªã‚»ãƒƒãƒˆãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç”Ÿæˆ
    const resetToken = this.generateResetToken();
    
    // DBã«ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä¿å­˜ (1æ™‚é–“æœ‰åŠ¹)
    await this.userRepository.savePasswordResetToken(user.id, resetToken, new Date(Date.now() + 3600000));

    // ãƒ¡ãƒ¼ãƒ«é€ä¿¡
    await this.emailService.sendPasswordResetEmail(user.email, resetToken);
  }
}
```

---

## ã‚¹ãƒ†ãƒƒãƒ—6: ãƒ†ã‚¹ãƒˆ

### ãƒ­ãƒ¼ã‚«ãƒ«ã§ã®ãƒ†ã‚¹ãƒˆ

```bash
# .env ã« Resend APIã‚­ãƒ¼ã‚’è¨­å®š
echo "RESEND_API_KEY=re_your_test_api_key" >> backend/.env

# ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚’èµ·å‹•
pnpm dev

# ãƒ¡ãƒ¼ãƒ«é€ä¿¡APIã‚’å‘¼ã³å‡ºã—
curl -X POST http://localhost:3004/api/v1/auth/password-reset \
  -H "Content-Type: application/json" \
  -d '{"email":"your-email@example.com"}'
```

### æœ¬ç•ªç’°å¢ƒã§ã®ãƒ†ã‚¹ãƒˆ

```bash
# Cloud Runã«ãƒ‡ãƒ—ãƒ­ã‚¤å¾Œ
curl -X POST https://api.nekoya.co.jp/api/v1/auth/password-reset \
  -H "Content-Type: application/json" \
  -d '{"email":"your-email@example.com"}'

# ãƒ­ã‚°ç¢ºèª
gcloud run services logs read mycats-pro-backend --region=asia-northeast1 --limit=50
```

---

## ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### ãƒ¡ãƒ¼ãƒ«ãŒå±Šã‹ãªã„

**åŸå› 1**: SPF/DKIM/DMARCè¨­å®šãŒä¸è¶³
- Resendãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã§ã€ŒDomain Statusã€ã‚’ç¢ºèª
- ãŠåå‰.comã§è¿½åŠ ã®TXTãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’è¨­å®š

**åŸå› 2**: APIã‚­ãƒ¼ãŒç„¡åŠ¹
```bash
# APIã‚­ãƒ¼ã‚’å†ç™ºè¡Œã—ã€Secret Managerã‚’æ›´æ–°
echo -n "re_new_api_key" | gcloud secrets versions add RESEND_API_KEY_production --data-file=-
```

### ã‚¨ãƒ©ãƒ¼: `RESEND_API_KEY not set`

**è§£æ±º**:
```bash
# Cloud Runã®ç’°å¢ƒå¤‰æ•°ã‚’ç¢ºèª
gcloud run services describe mycats-pro-backend --region=asia-northeast1 --format="get(spec.template.spec.containers[0].env)"
```

---

## å‚è€ƒè³‡æ–™

- [Resend Documentation](https://resend.com/docs)
- [Resend Node.js SDK](https://github.com/resend/resend-node)
- [React Email](https://react.email/) (HTMLãƒ¡ãƒ¼ãƒ«ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä½œæˆ)

---

## ã¾ã¨ã‚

å®Ÿè£…å®Œäº†å¾Œã€ä»¥ä¸‹ã®æ©Ÿèƒ½ãŒåˆ©ç”¨å¯èƒ½ã«ãªã‚Šã¾ã™:

- âœ… ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆãƒ¡ãƒ¼ãƒ«é€ä¿¡
- âœ… ã‚¦ã‚§ãƒ«ã‚«ãƒ ãƒ¡ãƒ¼ãƒ«é€ä¿¡
- âœ… ã‚«ã‚¹ã‚¿ãƒ ãƒ¡ãƒ¼ãƒ«ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
- âœ… æ—¥æœ¬èªãƒ¡ãƒ¼ãƒ«å¯¾å¿œ
- âœ… ä½ã‚³ã‚¹ãƒˆé‹ç”¨ (ç„¡æ–™æ : 100é€š/æ—¥)
`````

## File: docs/mycats_pro_å†ç™ºé˜²æ­¢ã‚¬ãƒ¼ãƒ‰æ©Ÿæ§‹_å®Ÿè£…ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸.md
`````markdown
# mycats-pro å†ç™ºé˜²æ­¢ã‚¬ãƒ¼ãƒ‰æ©Ÿæ§‹ å®Ÿè£…ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸

æœ¬ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ã€é–‹ç™ºä»¥æ¥åˆã‚ã¦ç™ºç”Ÿã—ãŸé‡å¤§ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆã‚’å—ã‘ã€**åŒç¨®ã®äº‹æ•…ã‚’äºŒåº¦ã¨èµ·ã“ã•ãªã„**ã“ã¨ã‚’ç›®çš„ã¨ã—ã¦æ•´å‚™ã—ãŸ AI ã‚¬ãƒ¼ãƒ‰æ©Ÿæ§‹ä¸€å¼ã‚’ã¾ã¨ã‚ãŸã‚‚ã®ã§ã™ã€‚

ã“ã®å†…å®¹ã¯ã€ãã®ã¾ã¾ **æ¬¡ã® AI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¸æ¸¡ã™å®Ÿè¡ŒæŒ‡ç¤ºæ›¸**ã¨ã—ã¦åˆ©ç”¨ã§ãã‚‹ç²’åº¦ã§è¨˜è¿°ã•ã‚Œã¦ã„ã¾ã™ã€‚

---

## 1. ä½œæˆãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã¨æ¦‚è¦

| ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ | ç›®çš„ãƒ»æ¦‚è¦ |
|---|---|
| `.github/ai-checklist.md` | AI ãŒä½œæ¥­å®Œäº†ã‚’å®£è¨€ã™ã‚‹å‰ã«å¿…ãšå®Ÿè¡Œã™ã‚‹è‡ªå·±æ¤œè¨¼ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ |
| `.github/guards/package-added-guard.md` | `pnpm add` å®Ÿè¡Œæ™‚ã« AI ãŒå¿…ãšè¸ã‚€æ‰‹é †ã‚’å®šç¾©ã™ã‚‹ã‚¬ã‚¤ãƒ‰ |
| `.github/staged-verification.md` | å®Ÿè£…ãƒ•ã‚§ãƒ¼ã‚ºã”ã¨ã®æ®µéšçš„æ¤œè¨¼ãƒã‚¤ãƒ³ãƒˆå®šç¾© |
| `.github/user-feedback-priority.md` | ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’æœ€å„ªå…ˆã§æ‰±ã†ãŸã‚ã®åˆ¤æ–­åŸºæº– |
| `AGENTS.md`ï¼ˆæ›´æ–°ï¼‰ | å‹å®‰å…¨ä¾‹å¤–æ¡é …ã®å³æ ¼åŒ–ï¼ˆany / unknown ä½¿ç”¨æ¡ä»¶ã®æ˜æ–‡åŒ–ï¼‰ |
| `.github/copilot-instructions.md`ï¼ˆæ›´æ–°ï¼‰ | Copilot / AI å…±é€šã®å‹å®‰å…¨ä¾‹å¤–ãƒ«ãƒ¼ãƒ«çµ±ä¸€ |

---

## 2. ã‚¿ã‚¹ã‚¯1: AI è‡ªå·±æ¤œè¨¼ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

**ãƒ•ã‚¡ã‚¤ãƒ«:** `.github/ai-checklist.md`

```markdown
# AI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ è‡ªå·±æ¤œè¨¼ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

## ğŸ“‹ ä½œæ¥­é–‹å§‹å‰ãƒã‚§ãƒƒã‚¯

- [ ] é–¢é€£ã™ã‚‹ CODE_GUIDE.md / AGENTS.md ã‚’èª­ã¿è¾¼ã¿æ¸ˆã¿
- [ ] æ—¢å­˜ã®é¡ä¼¼å®Ÿè£…ã‚’æ¤œç´¢æ¸ˆã¿ï¼ˆå†åˆ©ç”¨å¯èƒ½æ€§ã‚’ç¢ºèªï¼‰
- [ ] å½±éŸ¿ç¯„å›²ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¨ä¾å­˜é–¢ä¿‚ã‚’ç‰¹å®šæ¸ˆã¿

## ğŸ”§ å®Ÿè£…ä¸­ãƒã‚§ãƒƒã‚¯ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«å˜ä½ï¼‰

- [ ] æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆæ™‚: é…ç½®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒè²¬å‹™ã«é©åˆ
- [ ] å‹å®šç¾©: any/unknown ã‚’ä½¿ç”¨ã—ã¦ã„ãªã„ï¼ˆä¾‹å¤–æ™‚ã¯ç†ç”±ã‚³ãƒ¡ãƒ³ãƒˆ + ä»£æ›¿æ¡ˆæ¤œè¨æ¸ˆã¿ï¼‰
- [ ] é–¢æ•°: å¼•æ•°ãƒ»æˆ»ã‚Šå€¤ã®å‹ãŒå®Œå…¨ã«æ˜ç¤º
- [ ] Prisma: ã‚¹ã‚­ãƒ¼ãƒå¤‰æ›´æ™‚ã¯ `pnpm prisma:generate` å®Ÿè¡Œæ¸ˆã¿
- [ ] ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸è¿½åŠ æ™‚: `pnpm prisma:generate` å®Ÿè¡Œæ¸ˆã¿ï¼ˆPrisma Client å†ç”Ÿæˆï¼‰
- [ ] ã‚¨ãƒ©ãƒ¼å‡¦ç†: ç©º catch / console.error ã®ã¿ / void async ãŒãªã„

## âœ… æ©Ÿèƒ½å®Œæˆæ™‚ãƒã‚§ãƒƒã‚¯

- [ ] å½±éŸ¿ç¯„å›²ã®ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œ: `pnpm test`ï¼ˆè©²å½“ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼‰
- [ ] Lint ãƒã‚§ãƒƒã‚¯: `pnpm lint` ã§è­¦å‘Šãƒ»ã‚¨ãƒ©ãƒ¼ã‚¼ãƒ­
- [ ] ãƒ“ãƒ«ãƒ‰ç¢ºèª: `pnpm build`ï¼ˆbackend / frontendï¼‰æˆåŠŸ
- [ ] Prisma å¤‰æ›´æ™‚: `pnpm db:migrate` + `pnpm db:seed` ã§å‹•ä½œç¢ºèª

## ğŸš¨ ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯å„ªå…ˆåº¦

- [ ] ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®èª¿æŸ»ç¤ºå”†ã¯å³åº§ã«æ–¹é‡ã¸åæ˜ 
- [ ] ã‚¨ãƒ©ãƒ¼ãƒ»è­¦å‘ŠæŒ‡æ‘˜æ™‚ã¯ä»–ä½œæ¥­ã‚’ä¸­æ–­
- [ ] AI åˆ¤æ–­ã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼æŒ‡ç¤ºãŒçŸ›ç›¾ã—ãŸå ´åˆã¯å¿…ãšãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å„ªå…ˆ

## ğŸ“ ä½œæ¥­å®Œäº†å‰ã®æœ€çµ‚ç¢ºèª

- [ ] ã™ã¹ã¦ã®å“è³ªã‚²ãƒ¼ãƒˆã‚’ PASSï¼ˆlint / build / testï¼‰
- [ ] æ—¥æœ¬èª UI è¦ä»¶ã‚’æº€ãŸã™ï¼ˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ»ã‚³ãƒ¡ãƒ³ãƒˆï¼‰
- [ ] å‹å®‰å…¨æ€§: any / unknown / é null ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ / äºŒæ®µã‚­ãƒ£ã‚¹ãƒˆãªã—
- [ ] ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°ï¼ˆREADME / è¨­è¨ˆè³‡æ–™ï¼‰
- [ ] å¤‰æ›´ç†ç”±ã¨å½±éŸ¿ç¯„å›²ã‚’èª¬æ˜å¯èƒ½

## ğŸ“ è¨¼è·¡æç¤ºï¼ˆå¿…é ˆï¼‰

- [ ] å®Ÿè¡Œã—ãŸã‚³ãƒãƒ³ãƒ‰ã¨çµæœãƒ­ã‚°ã€ã¾ãŸã¯ CI å®Ÿè¡Œ URL ã‚’æç¤º
```

---

## 3. ã‚¿ã‚¹ã‚¯2: ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸è¿½åŠ æ™‚ã®è‡ªå‹•ã‚¬ã‚¤ãƒ‰

**ãƒ•ã‚¡ã‚¤ãƒ«:** `.github/guards/package-added-guard.md`

```markdown
# ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸è¿½åŠ æ™‚ã®å¿…é ˆæ‰‹é †

## 1. ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ç›´å¾Œ

```bash
pnpm install
pnpm prisma:generate
```

ç†ç”±: node_modules æ›´æ–°ã«ã‚ˆã‚Š Prisma Client ã®ä¾å­˜é–¢ä¿‚ãŒå¤‰åŒ–ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚

## 2. å‹ãƒã‚§ãƒƒã‚¯

```bash
pnpm --filter backend run build
pnpm --filter frontend run build
```

## 3. Lint ãƒã‚§ãƒƒã‚¯

```bash
pnpm lint
```

## 4. ä¾å­˜é–¢ä¿‚ã®ç¢ºèª

- package.json ã® diff ç¢ºèª
- pnpm-lock.yaml æ›´æ–°ç¢ºèª
- `pnpm audit` ã«ã‚ˆã‚‹è„†å¼±æ€§ãƒã‚§ãƒƒã‚¯

## ãƒ«ãƒ¼ãƒ«

- ã„ãšã‚Œã‹ã§å¤±æ•—ã—ãŸå ´åˆã€æ¬¡å·¥ç¨‹ã¸é€²ã¾ãªã„
- åŸå› è§£æ±ºã‚’æœ€å„ªå…ˆã¨ã™ã‚‹
```

---

## 4. ã‚¿ã‚¹ã‚¯3: å‹å®‰å…¨ä¾‹å¤–æ¡é …ï¼ˆAGENTS.md / copilot-instructions.mdï¼‰

```markdown
`any` / `unknown` ã®ä½¿ç”¨ã¯ç¦æ­¢ã€‚

ã€ä¾‹å¤–æ¡ä»¶ï¼ˆã™ã¹ã¦å¿…é ˆï¼‰ã€‘
1. å¤–éƒ¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å‹å®šç¾©ãŒå®Ÿæ…‹ã¨ç•°ãªã‚Šä¿®æ­£ä¸èƒ½
2. ä»¥ä¸‹ã®ä»£æ›¿æ¡ˆã‚’ã™ã¹ã¦è©¦è¡Œã—å¤±æ•—:
   - å‹ã‚¬ãƒ¼ãƒ‰
   - Partial / Pick / Omit
   - ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹
   - å‹ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³
   - ãƒ©ã‚¤ãƒ–ãƒ©ãƒªæ›´æ–°ãƒ»ä»£æ›¿æ¤œè¨
3. è©²å½“è¡Œã«ä»¥ä¸‹ã‚’å¿…ãšè¨˜è¼‰:
   - è©¦è¡Œã—ãŸä»£æ›¿æ¡ˆã¨çµæœ
   - any ä½¿ç”¨ç†ç”±
   - å½±éŸ¿ç¯„å›²æœ€å°åŒ–æ–¹æ³•
```

---

## 5. ã‚¿ã‚¹ã‚¯4: æ®µéšçš„æ¤œè¨¼ãƒã‚¤ãƒ³ãƒˆ

**ãƒ•ã‚¡ã‚¤ãƒ«:** `.github/staged-verification.md`

```markdown
# æ®µéšçš„æ¤œè¨¼ãƒã‚¤ãƒ³ãƒˆ

## Stage 1: ãƒ•ã‚¡ã‚¤ãƒ«å¤‰æ›´æ™‚

```bash
pnpm lint
```

## Stage 2: æ©Ÿèƒ½å˜ä½å®Œæˆæ™‚

```bash
pnpm --filter <package> run test
pnpm --filter <package> run build
```

## Stage 3: PR å‰æœ€çµ‚æ¤œè¨¼

```bash
pnpm lint
pnpm backend:build
pnpm frontend:build
pnpm db:migrate
pnpm db:seed
pnpm dev:health
```

## ç¦æ­¢äº‹é …

- ã‚¨ãƒ©ãƒ¼ã‚’æ®‹ã—ãŸã¾ã¾æ¬¡å·¥ç¨‹ã¸é€²ã‚€
- å¾Œå›ã—å‰æã®ã‚³ãƒŸãƒƒãƒˆ
```

---

## 6. ã‚¿ã‚¹ã‚¯5: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯å„ªå…ˆåº¦ãƒãƒˆãƒªã‚¯ã‚¹

**ãƒ•ã‚¡ã‚¤ãƒ«:** `.github/user-feedback-priority.md`

```markdown
# ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯å„ªå…ˆåº¦ãƒãƒˆãƒªã‚¯ã‚¹

## ğŸ”´ Critical

- ã‚¨ãƒ©ãƒ¼ãƒ»è­¦å‘Šå ±å‘Š
- èª¿æŸ»ç¤ºå”†
- CI/CD å¤±æ•—

å¯¾å¿œ: ä½œæ¥­ä¸­æ–­ â†’ èª¿æŸ»æ–¹é‡å¤‰æ›´ â†’ å ±å‘Š

## ğŸŸ¡ High

- æ©Ÿèƒ½å¤‰æ›´è¦æœ›
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ»ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ‡¸å¿µ

## ğŸŸ¢ Normal

- ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ”¹å–„
- UI/UX ææ¡ˆ

## NG ãƒ‘ã‚¿ãƒ¼ãƒ³

ãƒ¦ãƒ¼ã‚¶ãƒ¼ç¤ºå”†ã‚’ç‹¬è‡ªåˆ¤æ–­ã§ç„¡è¦–ã™ã‚‹ã“ã¨
```

---

## 7. å†ç™ºé˜²æ­¢ã®ç¢ºèªæ–¹æ³•

- AI ã¯ `.github/ai-checklist.md` ã‚’å®Œäº†ã—ãªã„é™ã‚Šä½œæ¥­å®Œäº†ã‚’å®£è¨€ã§ããªã„
- package.json å¤‰æ›´æ™‚ã¯å¿…ãš package-added-guard ã‚’é©ç”¨
- ãƒ¦ãƒ¼ã‚¶ãƒ¼æŒ‡æ‘˜ã¯ priority ãƒãƒˆãƒªã‚¯ã‚¹ã«å¾“ã„å‡¦ç†
- CI ã®æˆåŠŸãƒ­ã‚°ã‚’æœ€çµ‚è¨¼è·¡ã¨ã™ã‚‹

---

## 8. æ¬¡ã® AI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¸ã®å¼•ãæ¸¡ã—æ–¹

ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’ **ãã®ã¾ã¾ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã¨ã—ã¦æ¸¡ã™**ã€‚
è¿½åŠ æŒ‡ç¤ºã‚„çœç•¥ã¯è¡Œã‚ãšã€ã“ã“ã«è¨˜è¼‰ã•ã‚ŒãŸãƒ«ãƒ¼ãƒ«ã‚’æœ€å„ªå…ˆã§éµå®ˆã•ã›ã‚‹ã“ã¨ã€‚
`````

## File: docs/naming_convention_guidelines_v2.md
`````markdown
# ğŸ§­ Naming & Convention Guidelines â€” Complete Edition
**Version:** 2.0  
**Last Updated:** 2025-10-19  
**Scope:** å…¨ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆï¼ˆNestJS / Next.js / Prisma / CLI / Scripts / Tests / Infraï¼‰

---

## 1. åŸºæœ¬åŸå‰‡

- å‘½åã¯ **ä¸€è²«æ€§ãƒ»å¯èª­æ€§ãƒ»è‡ªå‹•æ¤œè¨¼å¯èƒ½æ€§** ã‚’æœ€é‡è¦–ã™ã‚‹ã€‚
- å…¨ã¦ã®å‘½åã¯ã€Œå½¹å‰²ãƒ»è²¬å‹™ãƒ»ãƒ¬ã‚¤ãƒ¤ãƒ¼ã€ã‚’æ˜ç¤ºã—ã€**ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆä¾å­˜ã®ç•¥èªã‚’é¿ã‘ã‚‹**ã€‚
- è‹±å˜èªã¯ã™ã¹ã¦**è‹±èªæ­£å¼èªã¾ãŸã¯æ‰¿èªæ¸ˆã¿ç•¥èª**ã‚’ç”¨ã„ã‚‹ã€‚
- **Public API å**ï¼ˆå¤–éƒ¨ä»•æ§˜ã«éœ²å‡ºã™ã‚‹ã‚‚ã®ï¼‰ã¯**ç ´å£Šçš„å¤‰æ›´ã‚’é¿ã‘ã‚‹**ã€‚

---

## 2. ãƒ•ã‚¡ã‚¤ãƒ«å‘½åè¦å‰‡

| ç¨®åˆ¥ | å‘½åå½¢å¼ | ä¾‹ |
|---|---|---|
| ä¸€èˆ¬TS | `kebab-case.ts` | `user-service.ts` |
| Reactã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ | `PascalCase.tsx` | `UserCard.tsx` |
| React Hook | `useCamelCase.ts` | `useUserData.ts` |
| NestJSæ§‹æˆ | `*.module.ts` / `*.controller.ts` / `*.service.ts` / `*.guard.ts` / `*.interceptor.ts` / `*.filter.ts` | ä¾‹: `cats.controller.ts` |
| ãƒ†ã‚¹ãƒˆ | `*.spec.ts` / `*.test.ts` | `user.service.spec.ts` |
| Prisma | `schema.prisma` å›ºå®š |  |
| Config / Env | `.env`, `.env.local`, `.env.production` |  |

### è£œè¶³ãƒ«ãƒ¼ãƒ«
- Barrel (`index.ts`) ã¯**å†ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå°‚ç”¨**ã€‚å®Ÿè£…ã‚³ãƒ¼ãƒ‰ã‚’æ··åœ¨ã•ã›ãªã„ã€‚
- Barrel ã¯**ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå = å®Ÿä½“å**ã‚’ç¶­æŒã€‚
- default export ã¯ç¦æ­¢ï¼ˆä¾‹å¤–ã¯ Next.js ãƒšãƒ¼ã‚¸ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ã¿ï¼‰ã€‚

---

## 3. ã‚·ãƒ³ãƒœãƒ«å‘½åè¦å‰‡

| ç¨®åˆ¥ | å‘½åå½¢å¼ | ä¾‹ |
|---|---|---|
| ã‚¯ãƒ©ã‚¹ / å‹ / ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ / ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ | PascalCase | `UserService`, `CreateCatDto` |
| é–¢æ•° / ãƒ¡ã‚½ãƒƒãƒ‰ / å¤‰æ•° / ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ | camelCase | `createUser`, `fetchData` |
| åˆ—æŒ™å‹ | Name=PascalCase, Member=SCREAMING_SNAKE_CASE | `Color.RED` |
| å®šæ•°ï¼ˆä¸å¤‰ï¼‰ | SCREAMING_SNAKE_CASE | `DEFAULT_LIMIT` |
| Prisma Model | PascalCase | `Cat`, `UserProfile` |
| Prisma ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ | camelCase | `birthDate` |
| DB ãƒ†ãƒ¼ãƒ–ãƒ« / ã‚«ãƒ©ãƒ  | snake_case | `cat_breed`, `birth_date` |

---

## 4. API & DTO å‘½åè¦å‰‡

- REST ãƒ«ãƒ¼ãƒˆã¯ `kebab-case` ã‚’ç”¨ã„ã€ãƒãƒ¼ã‚¸ãƒ§ãƒ³ä»˜ã `/api/v1/...` ã¨ã™ã‚‹ã€‚
- ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚­ãƒ¼ã¯ `snake_case`ã€‚
- DTO / Response ã‚¯ãƒ©ã‚¹ã¯ `PascalCaseDto` / `PascalCaseResponse`ã€‚
- ã‚¨ãƒ©ãƒ¼å¿œç­”å…±é€šæ§‹é€ ï¼š

```json
{ "success": false, "error": { "code": "INVALID_PARAMETER", "message": "..." } }
```

---

## 5. ã‚¨ãƒ©ãƒ¼ãƒ»ã‚¤ãƒ™ãƒ³ãƒˆãƒ»ãƒ­ã‚°å‘½å

| ç¨®åˆ¥ | å‘½åå½¢å¼ | ä¾‹ |
|---|---|---|
| ä¾‹å¤–ã‚¯ãƒ©ã‚¹ | PascalCase + `Exception` | `ValidationException` |
| ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ | SCREAMING_SNAKE_CASE | `UNAUTHORIZED_ACCESS` |
| ãƒ­ã‚°ã‚¤ãƒ™ãƒ³ãƒˆå | `domain.action`ï¼ˆå°æ–‡å­—ãƒ‰ãƒƒãƒˆåŒºåˆ‡ã‚Šï¼‰ | `cat.registered`, `auth.login.success` |

---

## 6. ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ / ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸

| é …ç›® | è¦å‰‡ |
|---|---|
| npm workspace å | `@org/kebab-case` |
| ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå | ãƒ•ã‚¡ã‚¤ãƒ«ã¨åŒä¸€è¦å‰‡ |
| ã‚µãƒ¼ãƒ“ã‚¹å˜ä½ | `apps/`ï¼ˆå®Ÿè¡Œç³»ï¼‰ãƒ»`packages/`ï¼ˆå…±é€šãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼‰ãƒ»`infra/`ï¼ˆæ§‹æˆç®¡ç†ï¼‰ã«åˆ†é¡ |

---

## 7. ãƒ†ã‚¹ãƒˆãƒ»UI å±æ€§ãƒ»CSS

| é …ç›® | è¦å‰‡ |
|---|---|
| data-testid | `kebab-case`ã€ãƒšãƒ¼ã‚¸ã”ã¨ã«åå‰ç©ºé–“ä»˜ä¸ï¼ˆä¾‹ï¼š`cat-form-submit`ï¼‰ |
| CSS Modules | `kebab-case` |
| BEM | å¿…è¦ã«å¿œã˜ã¦æ¡ç”¨ã€‚Block=PascalCase, element=camelCase |

---

## 8. ã‚¹ã‚¯ãƒªãƒ—ãƒˆå‘½åï¼ˆpackage.jsonï¼‰

| ã‚³ãƒãƒ³ãƒ‰ | ç›®çš„ |
|---|---|
| `lint:naming` | ESLintå‘½åæ¤œæŸ»ï¼ˆ--max-warnings=0ï¼‰ |
| `fix:naming` | è‡ªå‹•ä¿®æ­£ï¼ˆå®‰å…¨ç¯„å›²ã®ã¿ï¼‰ |
| `typecheck` | tscæ¤œæŸ» |
| `test:unit` / `test:e2e` | ãƒ†ã‚¹ãƒˆç¾¤ |
| `ci:verify` | lint + typecheck + test |

---

## 9. Gité‹ç”¨è¦ç´„

| é …ç›® | è¦å‰‡ |
|---|---|
| ãƒ–ãƒ©ãƒ³ãƒå | `feature/...`, `fix/...`, `chore/...`ï¼ˆkebab-caseï¼‰ |
| ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ | Conventional Commits æº–æ‹ ï¼ˆä¾‹ï¼š`feat(api): add cat register endpoint`ï¼‰ |
| ã‚¿ã‚° | `vX.Y.Z`ï¼ˆSemVerï¼‰ |

---

## 10. æ‰¿èªæ¸ˆã¿ç•¥èªè¡¨ï¼ˆä¾‹ï¼‰

| ç•¥èª | æ„å‘³ | è¨±å¯å¯¾è±¡ |
|---|---|---|
| dto | Data Transfer Object | OKï¼ˆæœ«å°¾ã®ã¿ï¼‰ |
| id | Identifier | OK |
| api | Application Programming Interface | OK |
| ui | User Interface | OKï¼ˆæœ«å°¾é™å®šï¼‰ |
| db | Database | OK |
| env | Environment | OK |

> Glossary æœªæ‰¿èªç•¥èªã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã¯ã€PR ã§ Glossary æ›´æ–°ã‚’ä¼´ã†ã€‚

---

## 11. å‘½åä¾‹å¤–ç”³è«‹ãƒ—ãƒ­ã‚»ã‚¹

ä¾‹å¤–ã‚’è¨±å¯ã™ã‚‹å ´åˆã¯ **Issue ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ**ã‚’åˆ©ç”¨ã—ã€æ¬¡ã‚’å¿…é ˆè¨˜è¼‰ï¼š

| é …ç›® | å†…å®¹ |
|---|---|
| ç†ç”± | ä¸€æ™‚çš„ãƒ»å¤–éƒ¨ä»•æ§˜ãƒ»å¾Œæ–¹äº’æ›ç¶­æŒãªã© |
| å¯¾è±¡ | ãƒ•ã‚¡ã‚¤ãƒ«/ã‚¯ãƒ©ã‚¹å |
| å½±éŸ¿ç¯„å›² | å†…éƒ¨é™å®š or å¤–éƒ¨APIå«ã‚€ |
| ä»£æ›¿æ¡ˆ | å°†æ¥çš„ãªãƒªãƒãƒ¼ãƒ è¨ˆç”» |
| æœ‰åŠ¹æœŸé™ | YYYY-MM-DDï¼ˆä¾‹å¤–ã®å†å¯©æŸ»æ—¥ï¼‰ |

---

## 12. Barrel / ãƒ‘ã‚¹ã‚¨ã‚¤ãƒªã‚¢ã‚¹æ•´åˆ

- `index.ts` ã¯å†ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå°‚ç”¨ã€‚
- ç›¸å¯¾ãƒ‘ã‚¹ã¯æ·±ã•2ä»¥ä¸Šã‚’ç¦æ­¢ã—ã€`@/` alias çµŒç”±ã«çµ±ä¸€ã€‚
- `tsconfig.json` ã® `paths` ã¨ç‰©ç†ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåã¯**ã‚±ãƒ¼ã‚¹ä¸€è‡´**å¿…é ˆã€‚

---

## 13. CI/CD è‡ªå‹•æ¤œè¨¼è¨­å®šä¾‹

**ESLintè¨­å®šï¼ˆæŠœç²‹ï¼‰**

```json
{
  "rules": {
    "@typescript-eslint/naming-convention": [
      "error",
      { "selector": "class", "format": ["PascalCase"] },
      { "selector": "variable", "format": ["camelCase", "UPPER_CASE"] },
      { "selector": "typeLike", "format": ["PascalCase"] }
    ],
    "filenames/match-regex": ["error", "^[a-z0-9]+(-[a-z0-9]+)*$", true],
    "filenames/match-exported": ["error", "pascal"]
  }
}
```

**CIè¨­å®šä¾‹ï¼ˆGitHub Actionsï¼‰**

```yaml
jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 22
      - run: npm ci
      - run: npm run lint:naming
```

---

## 14. Prisma & DB å‘½åä¸€è²«æ€§

- Prisma ãƒ¢ãƒ‡ãƒ«ã¯ PascalCaseã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ camelCaseã€‚
- å®ŸDBã®ãƒ†ãƒ¼ãƒ–ãƒ«ãƒ»ã‚«ãƒ©ãƒ ã¯ snake_caseã€‚
- `@@map` ãŠã‚ˆã³ `@map` ã§å¯¾å¿œï¼š

```prisma
model Cat {
  id        Int     @id @default(autoincrement()) @map("cat_id")
  birthDate DateTime @map("birth_date")
  @@map("cats")
}
```

---

## 15. é‹ç”¨ãƒ•ãƒ­ãƒ¼ãƒ»ç›£æŸ»æ‰‹é †

1. **ç›£æŸ»**  
   `npm run lint:naming` ã‚’ãƒªãƒã‚¸ãƒˆãƒªãƒ«ãƒ¼ãƒˆã§å®Ÿè¡Œã€‚
2. **è‡ªå‹•ä¿®æ­£ (Dry-run)**  
   `npm run fix:naming -- --dry-run`
3. **æ‰‹å‹•ãƒ¬ãƒ“ãƒ¥ãƒ¼**  
   Public APIå½±éŸ¿ã‚ã‚Šã¯PRã«ãƒ©ãƒ™ãƒ« `naming-exception` ã‚’ä»˜ä¸ã€‚
4. **é©ç”¨**  
   `npm run fix:naming`
5. **CIå›ºå®š**  
   ä»¥å¾Œã¯å¿…é ˆã‚²ãƒ¼ãƒˆåŒ–ã€‚

---

## 16. å°†æ¥æ‹¡å¼µäºˆå®š

- Lintãƒ«ãƒ¼ãƒ«ã§**Glossaryæœªæ‰¿èªç•¥èªã®æ¤œå‡º**ã‚’è‡ªå‹•åŒ–ã€‚
- `ts-morph`ã‚’ç”¨ã„ãŸ**importå‚ç…§ã®è‡ªå‹•ãƒªãƒãƒ¼ãƒ æ›´æ–°**ã€‚
- CIã«**å‘½åå·®åˆ†æ¤œå‡ºï¼ˆå‰å› vs ä»Šå›ï¼‰**ã‚’è¿½åŠ ã€‚

---

## 17. ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆç¶­æŒç®¡ç†

- ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ `docs/naming-guidelines.md` ã«é…ç½®ã€‚
- æ›´æ–°æ™‚ã¯ **Pull Request ã‚¿ã‚¤ãƒˆãƒ«ã‚’å¿…ãš `[docs] naming-guidelines update`** ã«ã™ã‚‹ã€‚
- ãƒªãƒªãƒ¼ã‚¹ãƒãƒ¼ãƒˆã«ã¯ã€Œå‘½åè¦ç´„æ›´æ–°ã€ã¨ã—ã¦æ˜è¨˜ã€‚

---

### âœ… æœ€çµ‚ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

| åˆ†é¡ | ãƒã‚§ãƒƒã‚¯ |
|---|---|
| Barrelã®å®Ÿè£…æ··åœ¨ç¦æ­¢ | â˜ |
| tsconfig.pathsã¨å®Ÿãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä¸€è‡´ | â˜ |
| Public APIå‘½åã®å®‰å®šåŒ– | â˜ |
| ç•¥èªGlossaryæ›´æ–°æ¸ˆ | â˜ |
| ESLintå‘½åãƒ«ãƒ¼ãƒ«æœ‰åŠ¹åŒ– | â˜ |
| CIã‚²ãƒ¼ãƒˆï¼ˆlint:namingï¼‰å¿…é ˆåŒ– | â˜ |
`````

## File: docs/PEDIGREE_PDF_DESIGN.md
`````markdown
# è¡€çµ±æ›¸PDFå°åˆ·æ©Ÿèƒ½ è¨­è¨ˆæ›¸

## ğŸ“‹ æ¦‚è¦

WCAï¼ˆWorld Cats Associationï¼‰å…¬å¼ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®è¡€çµ±æ›¸ã‚’PDFã§ç”Ÿæˆãƒ»å°åˆ·ã™ã‚‹æ©Ÿèƒ½ã®è¨­è¨ˆæ›¸ã€‚

## ğŸ¯ è¦ä»¶å®šç¾©

### æ©Ÿèƒ½è¦ä»¶
- ç™»éŒ²æ¸ˆã¿è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰PDFã‚’ç”Ÿæˆ
- WCAå…¬å¼ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«æº–æ‹ ã—ãŸãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
- 3ä¸–ä»£ï¼ˆæœ¬ä½“ + ä¸¡è¦ª + ç¥–çˆ¶æ¯ + æ›¾ç¥–çˆ¶æ¯ï¼‰ã®å®¶ç³»å›³è¡¨ç¤º
- å°åˆ·å“è³ª: 300dpiä»¥ä¸Šæ¨å¥¨

### éæ©Ÿèƒ½è¦ä»¶
- PDFç”Ÿæˆæ™‚é–“: 3ç§’ä»¥å†…
- ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 500KBä»¥ä¸‹
- åŒæ™‚ç”Ÿæˆ: æœ€å¤§10ä»¶ã¾ã§

## ğŸ“ ç”¨ç´™ä»•æ§˜

### ã‚µã‚¤ã‚º
- **å¹…**: 339mm
- **é«˜ã•**: 228mm
- **å‘ã**: æ¨ªé•·ï¼ˆLandscapeï¼‰
- **ãƒãƒ¼ã‚¸ãƒ³**: ä¸Šä¸‹å·¦å³ 10mm

### å°åˆ·é ˜åŸŸ
- **æœ‰åŠ¹å¹…**: 319mmï¼ˆ339 - 10Ã—2ï¼‰
- **æœ‰åŠ¹é«˜ã•**: 208mmï¼ˆ228 - 10Ã—2ï¼‰

### å‚è€ƒæ¯”è¼ƒ
- A4æ¨ª: 297Ã—210mm â†’ **è¡€çµ±æ›¸ã®æ–¹ãŒ42mmå¹…åºƒ**
- B4æ¨ª: 364Ã—257mm â†’ è¡€çµ±æ›¸ã®æ–¹ãŒå°ã•ã„
- **ã‚«ã‚¹ã‚¿ãƒ ã‚µã‚¤ã‚º**: 339Ã—228mmï¼ˆç´„B4ã®93%ã‚µã‚¤ã‚ºï¼‰

## ğŸ“Š ãƒ‡ãƒ¼ã‚¿ãƒãƒƒãƒ”ãƒ³ã‚°

### åŸºæœ¬æƒ…å ±ã‚¨ãƒªã‚¢ï¼ˆãƒ˜ãƒƒãƒ€ãƒ¼ï¼‰

| WCAé …ç›® | DBé …ç›®ï¼ˆPedigreeFormDataï¼‰ | å‚™è€ƒ |
|---------|---------------------------|------|
| Breed | breedCode â†’ breeds.name | ãƒã‚¹ã‚¿å‚ç…§ |
| Owner | ownerName | æ–‡å­—åˆ— |
| Sex | genderCode â†’ genders.name | ãƒã‚¹ã‚¿å‚ç…§ |
| Date of birth | birthDate | YYYY-MM-DD |
| Breeder | breederName | æ–‡å­—åˆ— |
| Eyecolor | eyeColor | æ–‡å­—åˆ— |
| Color | coatColorCode â†’ coatColors.name | ãƒã‚¹ã‚¿å‚ç…§ |
| Date of registration | registrationDate | YYYY-MM-DD |
| Litters (M) | brotherCount + sisterCount | å…„å¼Ÿå§‰å¦¹æ•°åˆè¨ˆ |
| WCA NO. | pedigreeId | è¡€çµ±æ›¸ç•ªå· |

### å®¶ç³»å›³ã‚¨ãƒªã‚¢ï¼ˆ3ä¸–ä»£ï¼‰

#### ç¬¬1ä¸–ä»£ï¼ˆä¸¡è¦ªï¼‰
| ä½ç½® | é …ç›® | DBé …ç›® |
|------|------|--------|
| 1 SIREï¼ˆçˆ¶ï¼‰ | Title + Name | fatherTitle, fatherCatName, fatherCatName2 |
|   | Color | fatherCoatColor |
|   | Eye | fatherEyeColor |
|   | JCU/Code | fatherJCU, fatherOtherCode |
| 2 DAMï¼ˆæ¯ï¼‰ | Title + Name | motherTitle, motherCatName, motherCatName2 |
|   | Color | motherCoatColor |
|   | Eye | motherEyeColor |
|   | JCU/Code | motherJCU, motherOtherCode |

#### ç¬¬2ä¸–ä»£ï¼ˆç¥–çˆ¶æ¯ï¼‰
| ä½ç½® | é–¢ä¿‚ | DBé …ç›®ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ |
|------|------|---------------------|
| 3 | Father's Father | ffï¼ˆä¾‹: ffTitle, ffCatName, ffCatColor, ffjcuï¼‰ |
| 4 | Father's Mother | fmï¼ˆä¾‹: fmTitle, fmCatName, fmCatColor, fmjcuï¼‰ |
| 5 | Mother's Father | mfï¼ˆä¾‹: mfTitle, mfCatName, mfCatColor, mfjcuï¼‰ |
| 6 | Mother's Mother | mmï¼ˆä¾‹: mmTitle, mmCatName, mmCatColor, mmjcuï¼‰ |

#### ç¬¬3ä¸–ä»£ï¼ˆæ›¾ç¥–çˆ¶æ¯ï¼‰
| ä½ç½® | é–¢ä¿‚ | DBé …ç›®ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ |
|------|------|---------------------|
| 7 | FF's Father | fff |
| 8 | FF's Mother | ffm |
| 9 | FM's Father | fmf |
| 10 | FM's Mother | fmm |
| 11 | MF's Father | mff |
| 12 | MF's Mother | mfm |
| 13 | MM's Father | mmf |
| 14 | MM's Mother | mmm |

### ãƒ•ãƒƒã‚¿ãƒ¼æƒ…å ±
| WCAé …ç›® | DBé …ç›® | å‚™è€ƒ |
|---------|--------|------|
| Other Organizations No. | otherNo | ä»–å›£ä½“ç™»éŒ²ç•ªå· |
| èªè¨¼æ–‡è¨€ | å›ºå®šãƒ†ã‚­ã‚¹ãƒˆ | è‹±æ–‡ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ |

## ğŸ› ï¸ æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯

### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰
```typescript
// æ¡ç”¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒª
{
  "pdfmake": "^0.2.x",          // PDFç”Ÿæˆã‚¨ãƒ³ã‚¸ãƒ³
  "@types/pdfmake": "^0.2.x"    // TypeScriptå‹å®šç¾©
}
```

### é¸å®šç†ç”±
- âœ… TypeScriptå®Œå…¨å¯¾å¿œ
- âœ… è¤‡é›‘ãªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼ˆãƒ†ãƒ¼ãƒ–ãƒ«ã€ãƒã‚¹ãƒˆï¼‰ãŒå¾—æ„
- âœ… ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚©ãƒ³ãƒˆãƒ»æ—¥æœ¬èªå¯¾å¿œ
- âœ… ãƒ¡ãƒ¢ãƒªåŠ¹ç‡ãŒè‰¯ã„
- âœ… NestJSã¨ã®çµ±åˆãŒå®¹æ˜“

### ä»£æ›¿æ¡ˆã¨ã®æ¯”è¼ƒ
| ãƒ©ã‚¤ãƒ–ãƒ©ãƒª | è©•ä¾¡ | ç†ç”± |
|-----------|------|------|
| puppeteer | â–³ | é‡ã„ã€ãƒ¡ãƒ¢ãƒªæ¶ˆè²»å¤§ |
| jsPDF | â–³ | è¤‡é›‘ãªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆãŒè‹¦æ‰‹ |
| PDFKit | â—‹ | è‰¯ã„ãŒã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†ãŒè¤‡é›‘ |
| **pdfmake** | â— | **æœ€é©** |

## ğŸ“‚ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹æˆ

```
backend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ pedigrees/
â”‚   â”‚   â”œâ”€â”€ pedigrees.controller.ts      # æ—¢å­˜
â”‚   â”‚   â”œâ”€â”€ pedigrees.service.ts         # æ—¢å­˜
â”‚   â”‚   â”œâ”€â”€ pdf/
â”‚   â”‚   â”‚   â”œâ”€â”€ pedigree-pdf.service.ts   # æ–°è¦: PDFç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯
â”‚   â”‚   â”‚   â”œâ”€â”€ templates/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ wca-pedigree.template.ts  # æ–°è¦: WCAãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
â”‚   â”‚   â”‚   â””â”€â”€ fonts/                     # æ–°è¦: ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚©ãƒ³ãƒˆ
â”‚   â”‚   â”‚       â”œâ”€â”€ NotoSansJP-Regular.ttf
â”‚   â”‚   â”‚       â””â”€â”€ NotoSansJP-Bold.ttf
â”‚   â”‚   â””â”€â”€ pedigrees.module.ts          # æ—¢å­˜ï¼ˆProviderè¿½åŠ ï¼‰
â”‚   â””â”€â”€ ...
â””â”€â”€ ...
```

## ğŸ”Œ APIè¨­è¨ˆ

### ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ

#### 1. å˜ä½“PDFç”Ÿæˆ
```http
GET /api/pedigrees/:id/pdf
```

**ãƒªã‚¯ã‚¨ã‚¹ãƒˆ:**
```typescript
// ãƒ‘ã‚¹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
{
  id: string  // è¡€çµ±æ›¸IDï¼ˆpedigreeIdï¼‰
}

// ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
{
  format?: 'pdf' | 'base64'  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: pdf
  download?: boolean          // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: true
}
```

**ãƒ¬ã‚¹ãƒãƒ³ã‚¹ï¼ˆæˆåŠŸï¼‰:**
```http
HTTP/1.1 200 OK
Content-Type: application/pdf
Content-Disposition: attachment; filename="pedigree_{id}_{YYYYMMDD}.pdf"

[PDFãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿]
```

**ãƒ¬ã‚¹ãƒãƒ³ã‚¹ï¼ˆã‚¨ãƒ©ãƒ¼ï¼‰:**
```json
{
  "statusCode": 404,
  "message": "Pedigree not found",
  "error": "Not Found"
}
```

#### 2. ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨Base64å–å¾—
```http
GET /api/pedigrees/:id/pdf?format=base64
```

**ãƒ¬ã‚¹ãƒãƒ³ã‚¹:**
```json
{
  "pedigreeId": "WCA12345",
  "format": "base64",
  "data": "JVBERi0xLjMKJcTl8uXrp...",
  "filename": "pedigree_WCA12345_20251211.pdf"
}
```

#### 3. ä¸€æ‹¬PDFç”Ÿæˆï¼ˆå°†æ¥å®Ÿè£…ï¼‰
```http
POST /api/pedigrees/bulk-pdf
```

**ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£:**
```json
{
  "pedigreeIds": ["WCA12345", "WCA12346"],
  "format": "zip"
}
```

## ğŸ“ å®Ÿè£…ãƒ•ã‚§ãƒ¼ã‚º

### Phase 1: åŸºç¤å®Ÿè£…ï¼ˆ1-2æ—¥ï¼‰
- [x] pdfmakeã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
- [ ] PedigreePdfServiceã‚¯ãƒ©ã‚¹ä½œæˆ
- [ ] åŸºæœ¬çš„ãªPDFç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯
- [ ] ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå®Ÿè£…
- [ ] ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆï¼ˆãƒ†ã‚­ã‚¹ãƒˆã®ã¿ï¼‰

**ã‚´ãƒ¼ãƒ«:** æœ€ä½é™ã®PDFå‡ºåŠ›ãŒã§ãã‚‹

### Phase 2: ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå®Ÿè£…ï¼ˆ2-3æ—¥ï¼‰
- [ ] WCAå…¬å¼ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®å†ç¾
  - [ ] ãƒ˜ãƒƒãƒ€ãƒ¼ãƒ‡ã‚¶ã‚¤ãƒ³ï¼ˆCERTIFIED PEDIGREEï¼‰
  - [ ] åŸºæœ¬æƒ…å ±ã‚¨ãƒªã‚¢ï¼ˆ2è¡Œãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼‰
  - [ ] å®¶ç³»å›³ãƒ†ãƒ¼ãƒ–ãƒ«ï¼ˆ3åˆ—æ§‹æˆï¼‰
  - [ ] ãƒ•ãƒƒã‚¿ãƒ¼ã‚¨ãƒªã‚¢
- [ ] ç½«ç·šãƒ»ãƒœãƒ¼ãƒ€ãƒ¼ã®é…ç½®
- [ ] ãƒ•ã‚©ãƒ³ãƒˆãƒ»ã‚µã‚¤ã‚ºèª¿æ•´

**ã‚´ãƒ¼ãƒ«:** è¦‹ãŸç›®ãŒWCAå…¬å¼ã«è¿‘ã¥ã

### Phase 3: ãƒ‡ãƒ¼ã‚¿çµ±åˆï¼ˆ1æ—¥ï¼‰
- [ ] ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿ã®å‚ç…§
  - [ ] breedsï¼ˆå“ç¨®ï¼‰
  - [ ] coatColorsï¼ˆæ¯›è‰²ï¼‰
  - [ ] gendersï¼ˆæ€§åˆ¥ï¼‰
- [ ] æ—¥ä»˜ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
- [ ] ç©ºæ¬„å‡¦ç†ï¼ˆæœªå…¥åŠ›é …ç›®ï¼‰

**ã‚´ãƒ¼ãƒ«:** å®Ÿãƒ‡ãƒ¼ã‚¿ã§æ­£ã—ãå‡ºåŠ›ã•ã‚Œã‚‹

### Phase 4: ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰é€£æºï¼ˆ1æ—¥ï¼‰
- [ ] å°åˆ·ãƒœã‚¿ãƒ³è¿½åŠ 
  - [ ] PedigreeListï¼ˆä¸€è¦§ç”»é¢ï¼‰
  - [ ] è©³ç´°ç”»é¢ï¼ˆå°†æ¥å®Ÿè£…æ™‚ï¼‰
- [ ] ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å‡¦ç†
- [ ] ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¡¨ç¤º
- [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

**ã‚´ãƒ¼ãƒ«:** ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå®Ÿéš›ã«ä½¿ãˆã‚‹

### Phase 5: å“è³ªå‘ä¸Šï¼ˆ1-2æ—¥ï¼‰
- [ ] æ—¥æœ¬èªãƒ•ã‚©ãƒ³ãƒˆæœ€é©åŒ–
- [ ] å°åˆ·å“è³ªç¢ºèªï¼ˆå®Ÿæ©Ÿãƒ†ã‚¹ãƒˆï¼‰
- [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
- [ ] ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆä½œæˆ

**ã‚´ãƒ¼ãƒ«:** ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³å“è³ª

### Phase 6: æ‹¡å¼µæ©Ÿèƒ½ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
- [ ] ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆé¸æŠæ©Ÿèƒ½
- [ ] ä¸€æ‹¬PDFç”Ÿæˆ
- [ ] é€ã‹ã—ï¼ˆDRAFT/COPYï¼‰è¿½åŠ 
- [ ] PDFæš—å·åŒ–
- [ ] å°åˆ·å±¥æ­´è¨˜éŒ²

## ğŸ¨ PDFãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆè©³ç´°

### ãƒšãƒ¼ã‚¸è¨­å®š
```typescript
const pageConfig = {
  pageSize: {
    width: 339,   // mm
    height: 228,  // mm
  },
  pageOrientation: 'landscape',
  pageMargins: [10, 10, 10, 10], // mm: [left, top, right, bottom]
};
```

### ã‚»ã‚¯ã‚·ãƒ§ãƒ³åˆ†å‰²
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Header (50mm)                                            â”‚
â”‚  - CERTIFIED PEDIGREE ãƒ­ã‚´                               â”‚
â”‚  - åŸºæœ¬æƒ…å ±2è¡Œ                                            â”‚
â”‚  - WCA NO. ãƒãƒŠãƒ¼                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Family Tree (140mm)                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚ PARENTS â”‚ GRAND      â”‚ GREAT GRAND PARENTS  â”‚       â”‚
â”‚  â”‚ (60mm)  â”‚ PARENTS    â”‚ (140mm)              â”‚       â”‚
â”‚  â”‚         â”‚ (90mm)     â”‚                      â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Footer (18mm)                                            â”‚
â”‚  - Other Organizations No.                               â”‚
â”‚  - èªè¨¼æ–‡è¨€                                               â”‚
â”‚  - WCA ãƒ­ã‚´ï¼ˆå³ä¸‹ï¼‰                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ãƒ•ã‚©ãƒ³ãƒˆè¨­å®š
```typescript
const fonts = {
  NotoSansJP: {
    normal: 'fonts/NotoSansJP-Regular.ttf',
    bold: 'fonts/NotoSansJP-Bold.ttf',
  },
};

const styles = {
  header: { fontSize: 18, bold: true, alignment: 'center' },
  subheader: { fontSize: 10, alignment: 'center' },
  label: { fontSize: 8, color: '#666' },
  value: { fontSize: 9, bold: true },
  familyTreeName: { fontSize: 8 },
  footer: { fontSize: 7, italics: true },
};
```

## ğŸ”’ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è€ƒæ…®äº‹é …

1. **ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡**
   - è‡ªåˆ†ã®ãƒ†ãƒŠãƒ³ãƒˆã®è¡€çµ±æ›¸ã®ã¿ç”Ÿæˆå¯èƒ½
   - JWTãƒˆãƒ¼ã‚¯ãƒ³å¿…é ˆ

2. **ãƒ¬ãƒ¼ãƒˆåˆ¶é™**
   - åŒä¸€ãƒ¦ãƒ¼ã‚¶ãƒ¼: 10å›/åˆ†ã¾ã§
   - åŒä¸€IP: 30å›/åˆ†ã¾ã§

3. **ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³**
   - è¡€çµ±æ›¸IDã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
   - ä¸æ­£ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ‹’å¦

4. **ãƒ‡ãƒ¼ã‚¿ä¿è­·**
   - ç”Ÿæˆã—ãŸPDFã¯ä¸€æ™‚çš„ã«ãƒ¡ãƒ¢ãƒªä¿æŒ
   - ãƒ‡ã‚£ã‚¹ã‚¯ã¸ã®ä¿å­˜ã¯è¡Œã‚ãªã„ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ã¨ã—ã¦å°†æ¥æ¤œè¨ï¼‰

## ğŸ§ª ãƒ†ã‚¹ãƒˆè¨ˆç”»

### ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ
- [ ] PedigreePdfService.generatePdf()
- [ ] ãƒ‡ãƒ¼ã‚¿ãƒãƒƒãƒ”ãƒ³ã‚°é–¢æ•°
- [ ] æ—¥ä»˜ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆé–¢æ•°
- [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

### çµ±åˆãƒ†ã‚¹ãƒˆ
- [ ] ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ: GET /api/pedigrees/:id/pdf
- [ ] ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿å‚ç…§
- [ ] å­˜åœ¨ã—ãªã„è¡€çµ±æ›¸ID
- [ ] æ¨©é™ãƒã‚§ãƒƒã‚¯

### æ‰‹å‹•ãƒ†ã‚¹ãƒˆ
- [ ] å®Ÿéš›ã®ç”¨ç´™ã«å°åˆ·ã—ã¦ä½ç½®ç¢ºèª
- [ ] å„ãƒ–ãƒ©ã‚¦ã‚¶ã§ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å‹•ä½œ
- [ ] é•·ã„åå‰ãƒ»ç‰¹æ®Šæ–‡å­—ã®è¡¨ç¤º
- [ ] ç©ºæ¬„é …ç›®ã®è¡¨ç¤º

## ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›®æ¨™

| æŒ‡æ¨™ | ç›®æ¨™å€¤ | æ¸¬å®šæ–¹æ³• |
|------|--------|----------|
| PDFç”Ÿæˆæ™‚é–“ | < 3ç§’ | ã‚µãƒ¼ãƒãƒ¼ãƒ­ã‚° |
| ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º | < 500KB | ç”Ÿæˆå¾Œã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º |
| åŒæ™‚ãƒªã‚¯ã‚¨ã‚¹ãƒˆ | 10ä»¶ | è² è·ãƒ†ã‚¹ãƒˆ |
| ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ | < 50MB/ãƒªã‚¯ã‚¨ã‚¹ãƒˆ | ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚° |

## ğŸš€ ãƒ‡ãƒ—ãƒ­ã‚¤å‰ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

- [ ] ãƒ•ã‚©ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒªãƒã‚¸ãƒˆãƒªã«å«ã‚ã‚‹ï¼ˆãƒ©ã‚¤ã‚»ãƒ³ã‚¹ç¢ºèªï¼‰
- [ ] ç’°å¢ƒå¤‰æ•°è¨­å®šï¼ˆå¿…è¦ãªå ´åˆï¼‰
- [ ] ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°è¨­å®š
- [ ] æœ¬ç•ªç’°å¢ƒã§ã®å°åˆ·ãƒ†ã‚¹ãƒˆ
- [ ] ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°ï¼ˆREADMEã€APIä»•æ§˜æ›¸ï¼‰

## ğŸ“š å‚è€ƒè³‡æ–™

### WCAå…¬å¼æƒ…å ±
- å…¬å¼ã‚µã‚¤ãƒˆ: https://worldcats.org/
- è¡€çµ±æ›¸ã‚µãƒ³ãƒ—ãƒ«: ï¼ˆå®Ÿç‰©ã‚¹ã‚­ãƒ£ãƒ³ç”»åƒï¼‰

### æŠ€è¡“ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
- pdfmakeå…¬å¼: http://pdfmake.org/
- NestJS File Response: https://docs.nestjs.com/techniques/file-upload

## ğŸ”„ æ›´æ–°å±¥æ­´

| æ—¥ä»˜ | ç‰ˆ | å¤‰æ›´å†…å®¹ | æ‹…å½“ |
|------|-----|----------|------|
| 2025-12-11 | 1.0 | åˆç‰ˆä½œæˆ | - |

---

**æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—:** Phase 1ã®å®Ÿè£…ã‚’é–‹å§‹
`````

## File: docs/production-deployment.md
`````markdown
# ğŸš€ æœ¬ç•ªç’°å¢ƒãƒ‡ãƒ—ãƒ­ã‚¤ã‚¬ã‚¤ãƒ‰

çŒ«ç”Ÿä½“ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã‚’æœ¬ç•ªç’°å¢ƒã«ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹ãŸã‚ã®æ‰‹é †æ›¸ã§ã™ã€‚

## ğŸ“‹ ãƒ‡ãƒ—ãƒ­ã‚¤å‰ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

### âœ… ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¦ä»¶

- [ ] å…¨ä¾å­˜é–¢ä¿‚ã‚’æœ€æ–°ã®å®‰å…¨ãªãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«æ›´æ–°
- [ ] ç’°å¢ƒå¤‰æ•°ãŒé©åˆ‡ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹
- [ ] CORSã‚ªãƒªã‚¸ãƒ³ãŒæœ¬ç•ªãƒ‰ãƒ¡ã‚¤ãƒ³ã®ã¿ã«åˆ¶é™ã•ã‚Œã¦ã„ã‚‹
- [ ] JWTã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆãŒååˆ†ã«å¼·åŠ›ï¼ˆ32æ–‡å­—ä»¥ä¸Šï¼‰
- [ ] ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹èªè¨¼æƒ…å ±ãŒå®‰å…¨
- [ ] HTTPSãŒå¼·åˆ¶ã•ã‚Œã¦ã„ã‚‹
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼ãŒæœ‰åŠ¹

### âœ… ã‚¤ãƒ³ãƒ•ãƒ©è¦ä»¶

- [ ] Node.js 20.x ã¾ãŸã¯ 22.x ãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ¸ˆã¿
- [ ] PostgreSQL 15+ ãŒç¨¼åƒä¸­ã§ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
- [ ] ãƒªãƒãƒ¼ã‚¹ãƒ—ãƒ­ã‚­ã‚· (nginx) ãŒè¨­å®šæ¸ˆã¿
- [ ] SSLè¨¼æ˜æ›¸ãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ¸ˆã¿
- [ ] ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ãƒ«ãƒ¼ãƒ«ãŒè¨­å®šæ¸ˆã¿
- [ ] ç›£è¦–ãƒ„ãƒ¼ãƒ«ãŒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æ¸ˆã¿

## ğŸ”§ ç’°å¢ƒè¨­å®š

1. **æœ¬ç•ªç’°å¢ƒè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®ä½œæˆ**:

   ```bash
   cp .env.production.example .env.production
   ```

2. **å¿…è¦ãªå¤‰æ•°ã®è¨­å®š**:

   ```bash
   # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹
   DATABASE_URL="postgresql://user:password@host:5432/mycats_prod"

   # ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
   JWT_SECRET="your-256-bit-production-secret-key-here"
   NODE_ENV=production

   # ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯
   PORT=3004
   CORS_ORIGIN="https://yourdomain.com,https://www.yourdomain.com"

   # ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
   HEALTH_CHECK_DATABASE=true
   ```

3. **è¨­å®šã®æ¤œè¨¼**:
   ```bash
   node -e "
   require('dotenv').config({ path: '.env.production' });
   const { validateProductionEnvironment } = require('./backend/dist/common/environment.validation');
   try {
     validateProductionEnvironment();
     console.log('âœ… ç’°å¢ƒè¨­å®šã®æ¤œè¨¼ã«æˆåŠŸã—ã¾ã—ãŸ');
   } catch (error) {
     console.error('âŒ ç’°å¢ƒè¨­å®šã®æ¤œè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸ:', error.message);
     process.exit(1);
   }
   "
   ```

## ğŸ—ï¸ ãƒ“ãƒ«ãƒ‰ãƒ—ãƒ­ã‚»ã‚¹

1. **æœ¬ç•ªãƒ“ãƒ«ãƒ‰ã®å®Ÿè¡Œ**:

   ```bash
   pnpm install --frozen-lockfile
   pnpm -w run db:generate
   pnpm run build
   ```

2. **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®é©ç”¨**:

   ```bash
   pnpm -w run db:deploy
   ```

3. **ãƒ“ãƒ«ãƒ‰æˆæœç‰©ã®ç¢ºèª**:
   ```bash
   ls -la backend/dist/
   ls -la frontend/.next/
   ```

## ğŸš€ ãƒ‡ãƒ—ãƒ­ã‚¤æ‰‹é †

### 1. ãƒ‡ãƒ—ãƒ­ã‚¤å‰æ¤œè¨¼

```bash
# ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»
pnpm audit --audit-level moderate

# ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®ãƒ†ã‚¹ãƒˆ
curl -f http://localhost:3004/health || echo "ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã«å¤±æ•—ã—ã¾ã—ãŸ"

# ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šãƒ†ã‚¹ãƒˆ
pnpm -w run test:api
```

### 2. ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³èµ·å‹•

```bash
# ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®èµ·å‹•ï¼ˆæœ¬ç•ªãƒ¢ãƒ¼ãƒ‰ï¼‰
cd backend && NODE_ENV=production node dist/main.js

# ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®èµ·å‹•ï¼ˆæœ¬ç•ªãƒ¢ãƒ¼ãƒ‰ï¼‰
cd frontend && npm run start
```

### 3. ãƒ‡ãƒ—ãƒ­ã‚¤å¾Œæ¤œè¨¼

```bash
# APIãŒå¿œç­”ã™ã‚‹ã“ã¨ã‚’ç¢ºèª
curl -f https://yourdomain.com/health

# ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ­ã‚°ã®ç¢ºèª
tail -f logs/application.log

# ã‚·ã‚¹ãƒ†ãƒ ãƒªã‚½ãƒ¼ã‚¹ã®ç›£è¦–
htop
```

## ğŸ”’ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–

### 1. Nginxè¨­å®š

```nginx
server {
    listen 443 ssl http2;
    server_name yourdomain.com;

    ssl_certificate /path/to/certificate.crt;
    ssl_certificate_key /path/to/private.key;

    # ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload";
    add_header X-Frame-Options DENY;
    add_header X-Content-Type-Options nosniff;

    # ãƒ¬ãƒ¼ãƒˆåˆ¶é™
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;

    location /api/ {
        limit_req zone=api burst=20 nodelay;
        proxy_pass http://localhost:3004;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location / {
        proxy_pass http://localhost:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

### 2. ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«è¨­å®š

```bash
# å¿…è¦ãªãƒãƒ¼ãƒˆã®ã¿ã‚’è¨±å¯
ufw allow 22/tcp   # SSH
ufw allow 80/tcp   # HTTP (ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ)
ufw allow 443/tcp  # HTTPS
ufw enable
```

## ğŸ“Š ç›£è¦–è¨­å®š

### 1. ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ç›£è¦–

```bash
# ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ç”¨cronã‚¸ãƒ§ãƒ–
echo "*/5 * * * * curl -f https://yourdomain.com/health || echo 'ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯å¤±æ•—' | mail -s 'API ãƒ˜ãƒ«ã‚¹ ã‚¢ãƒ©ãƒ¼ãƒˆ' admin@yourdomain.com" | crontab -
```

### 2. ãƒ­ã‚°ç›£è¦–

```bash
# ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ­ã‚°
tail -f /var/log/mycats/application.log

# ã‚¢ã‚¯ã‚»ã‚¹ãƒ­ã‚°
tail -f /var/log/nginx/access.log

# ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°
tail -f /var/log/nginx/error.log
```

## ğŸ”„ ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹æ‰‹é †

### 1. ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã¨ãƒ‘ãƒƒãƒ

```bash
# ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆ
pnpm audit
pnpm update

# ãƒªãƒ“ãƒ«ãƒ‰ã¨å†ãƒ‡ãƒ—ãƒ­ã‚¤
pnpm run build
```

### 2. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹

```bash
# ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
pg_dump $DATABASE_URL > backup_$(date +%Y%m%d_%H%M%S).sql

# æ–°ã—ã„ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®é©ç”¨
pnpm -w run db:deploy
```

### 3. ãƒ­ã‚°ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³

```bash
# ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ­ã‚°ç”¨ã®logrotateè¨­å®š
cat > /etc/logrotate.d/mycats << EOF
/var/log/mycats/*.log {
    daily
    missingok
    rotate 52
    compress
    notifempty
    create 644 www-data www-data
    sharedscripts
    postrotate
        systemctl reload nginx
    endscript
}
EOF
```

## ğŸš¨ ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œ

### 1. ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒèµ·å‹•ã—ãªã„å ´åˆ

```bash
# ãƒ­ã‚°ã®ç¢ºèª
journalctl -u mycats-api -n 50

# ç’°å¢ƒå¤‰æ•°ã®ç¢ºèª
env | grep -E "(DATABASE_URL|JWT_SECRET|NODE_ENV)"

# ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šãƒ†ã‚¹ãƒˆ
psql $DATABASE_URL -c "SELECT 1"
```

### 2. ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒé«˜ã„å ´åˆ

```bash
# ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã®ç¢ºèª
free -h
ps aux --sort=-%mem | head -10

# å¿…è¦ã«å¿œã˜ã¦ã‚µãƒ¼ãƒ“ã‚¹å†èµ·å‹•
systemctl restart mycats-api
systemctl restart nginx
```

### 3. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šå•é¡Œ

```bash
# PostgreSQLã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç¢ºèª
systemctl status postgresql

# æ¥ç¶šæ•°åˆ¶é™ã®ç¢ºèª
psql $DATABASE_URL -c "SELECT count(*) FROM pg_stat_activity;"

# å¿…è¦ã«å¿œã˜ã¦æ¥ç¶šãƒªã‚»ãƒƒãƒˆ
systemctl restart postgresql
```

## ğŸ“ ã‚µãƒãƒ¼ãƒˆé€£çµ¡å…ˆ

- **ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«ãƒªãƒ¼ãƒ‰**: [é€£çµ¡å…ˆæƒ…å ±]
- **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç®¡ç†è€…**: [é€£çµ¡å…ˆæƒ…å ±]
- **DevOpsãƒãƒ¼ãƒ **: [é€£çµ¡å…ˆæƒ…å ±]

## ğŸ“š é–¢é€£ãƒªã‚½ãƒ¼ã‚¹

- [ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆæ›¸](./system-design.md)
- [é‹ç”¨æ‰‹é †æ›¸](./operations.md)
- [APIä»•æ§˜æ›¸](./api-specification.md)
- [ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚¬ã‚¤ãƒ‰](./troubleshooting.md)

---

**æœ€çµ‚æ›´æ–°**: 2025å¹´1æœˆ14æ—¥  
**ç®¡ç†è€…**: é–‹ç™ºãƒãƒ¼ãƒ 

- [API Documentation](./docs/api-specification.md)
- [Troubleshooting Guide](./docs/troubleshooting.md)
`````

## File: docs/SUPER_ADMIN_SETUP.md
`````markdown
# æœ¬ç•ªç’°å¢ƒ åˆå› SUPER ADMIN ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚¬ã‚¤ãƒ‰

æœ¬ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ã€æœ¬ç•ªç’°å¢ƒã§æœ€åˆã® SUPER_ADMIN ã‚’ä½œæˆã™ã‚‹æ‰‹é †ã‚’èª¬æ˜ã—ã¾ã™ã€‚

## 1. æ¦‚è¦

æœ¬ç•ªç’°å¢ƒã«ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒ‡ãƒ—ãƒ­ã‚¤ã—ãŸå¾Œã€ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã‚’ç®¡ç†ã™ã‚‹ãŸã‚ã® SUPER_ADMIN æ¨©é™ã‚’æŒã¤ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå¿…è¦ã§ã™ã€‚ã“ã® SUPER_ADMIN ã¯ã€å…¨ãƒ†ãƒŠãƒ³ãƒˆãƒ»å…¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ç®¡ç†ã§ãã‚‹æœ€ä¸Šä½æ¨©é™ã‚’æŒã¡ã¾ã™ã€‚

ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã®ç†ç”±ã‹ã‚‰ã€ã“ã®æ˜‡æ ¼æ“ä½œã¯ **ä¸€åº¦ã ã‘** å®Ÿè¡Œå¯èƒ½ã§ã™ã€‚SUPER_ADMIN ãŒã™ã§ã«å­˜åœ¨ã™ã‚‹å ´åˆã¯ã‚¨ãƒ©ãƒ¼ã¨ãªã‚Šã¾ã™ã€‚

## 2. å‰ææ¡ä»¶

- ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒæœ¬ç•ªç’°å¢ƒã«ãƒ‡ãƒ—ãƒ­ã‚¤æ¸ˆã¿ã§ã‚ã‚‹ã“ã¨
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãŒå®Œäº†ã—ã¦ã„ã‚‹ã“ã¨
- ä¸€èˆ¬ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¨ã—ã¦æ–°è¦ç™»éŒ²ãƒ»ãƒ­ã‚°ã‚¤ãƒ³ãŒã§ãã‚‹çŠ¶æ…‹ã§ã‚ã‚‹ã“ã¨

## 3. ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æ‰‹é †

### 3-1. ç®¡ç†è€…ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’æ–°è¦ç™»éŒ²

1. ãƒ–ãƒ©ã‚¦ã‚¶ã§ `/register` ãƒšãƒ¼ã‚¸ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã™
2. SUPER_ADMIN ã¨ã—ã¦ä½¿ç”¨ã™ã‚‹ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ç™»éŒ²ã—ã¾ã™

> **ğŸ’¡ ãƒ’ãƒ³ãƒˆ**: ç®¡ç†å°‚ç”¨ã®ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ï¼ˆä¾‹: `admin@your-domain.com`ï¼‰ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™ã€‚

### 3-2. ãƒ­ã‚°ã‚¤ãƒ³

1. `/login` ãƒšãƒ¼ã‚¸ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã™
2. ç™»éŒ²ã—ãŸãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã§ãƒ­ã‚°ã‚¤ãƒ³ã—ã¾ã™

### 3-3. SUPER_ADMIN ã«æ˜‡æ ¼

1. `/setup/first-superadmin` ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã™
2. ç¾åœ¨ãƒ­ã‚°ã‚¤ãƒ³ä¸­ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆæƒ…å ±ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã™
3. **ã€Œã“ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ SUPER ADMIN ã«æ˜‡æ ¼ã™ã‚‹ã€** ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã™
4. ã€Œæ˜‡æ ¼ãŒå®Œäº†ã—ã¾ã—ãŸã€ã¨ã„ã†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒè¡¨ç¤ºã•ã‚ŒãŸã‚‰æˆåŠŸã§ã™

### 3-4. å‹•ä½œç¢ºèª

1. æ˜‡æ ¼å®Œäº†ç”»é¢ã® **ã€Œãƒ†ãƒŠãƒ³ãƒˆç®¡ç†ãƒšãƒ¼ã‚¸ã¸ã€** ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã‹ã€`/tenants` ã«ç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã™
2. ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†ãƒšãƒ¼ã‚¸ãŒè¡¨ç¤ºã•ã‚Œã‚Œã°ã€SUPER_ADMIN ã¨ã—ã¦æ­£å¸¸ã«å‹•ä½œã—ã¦ã„ã¾ã™

## 4. æ³¨æ„äº‹é …

| é …ç›® | èª¬æ˜ |
|------|------|
| **ä¸€åº¦ã ã‘å®Ÿè¡Œå¯èƒ½** | ã“ã®æ˜‡æ ¼æ“ä½œã¯åˆå›ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—å°‚ç”¨ã§ã™ã€‚SUPER_ADMIN ãŒã™ã§ã«å­˜åœ¨ã™ã‚‹å ´åˆã¯ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ |
| **å†ãƒ­ã‚°ã‚¤ãƒ³å¿…é ˆ** | æ˜‡æ ¼å¾Œã€JWT ãƒˆãƒ¼ã‚¯ãƒ³ã«ã¯å¤ã„æ¨©é™æƒ…å ±ãŒæ®‹ã£ã¦ã„ã‚‹ãŸã‚ã€å¿…ãšãƒ­ã‚°ã‚¢ã‚¦ãƒˆã—ã¦å†ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„ |
| **æ¨©é™ã®ç¯„å›²** | SUPER_ADMIN ã¯å…¨ãƒ†ãƒŠãƒ³ãƒˆãƒ»å…¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ç®¡ç†ã§ãã‚‹æœ€ä¸Šä½æ¨©é™ã‚’æŒã¡ã¾ã™ |

## 5. ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### ã€ŒSUPER ADMIN ã¯ã™ã§ã«å­˜åœ¨ã™ã‚‹ãŸã‚ã€ã“ã®æ“ä½œã¯å®Ÿè¡Œã§ãã¾ã›ã‚“ã€ã¨è¡¨ç¤ºã•ã‚Œã‚‹

**åŸå› **: ã™ã§ã«åˆ¥ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒ SUPER_ADMIN ã«æ˜‡æ ¼æ¸ˆã¿ã§ã™ã€‚

**å¯¾å‡¦æ³•**:
- æ—¢å­˜ã® SUPER_ADMIN ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã§ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„
- ä¸æ˜ãªå ´åˆã¯ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã§ `role = 'SUPER_ADMIN'` ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„

### æ˜‡æ ¼å¾Œã‚‚ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†ãƒšãƒ¼ã‚¸ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã„

**åŸå› **: JWT ãƒˆãƒ¼ã‚¯ãƒ³ã«å¤ã„æ¨©é™æƒ…å ±ãŒæ®‹ã£ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚

**å¯¾å‡¦æ³•**:
1. ä¸€åº¦ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã—ã¾ã™
2. å†åº¦ãƒ­ã‚°ã‚¤ãƒ³ã—ã¾ã™
3. `/tenants` ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã™

### `/setup/first-superadmin` ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã¨ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã•ã‚Œã‚‹

**åŸå› **: ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ã„ãªã„çŠ¶æ…‹ã§ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ã„ã¾ã™ã€‚

**å¯¾å‡¦æ³•**:
1. `/login` ã§ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ã‹ã‚‰å†åº¦ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ãã ã•ã„
2. ãƒ­ã‚°ã‚¤ãƒ³å¾Œã€è‡ªå‹•çš„ã« `/setup/first-superadmin` ã«ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã•ã‚Œã¾ã™

## 6. æŠ€è¡“çš„ãªè©³ç´°ï¼ˆé–‹ç™ºè€…å‘ã‘ï¼‰

### API ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ

| ãƒ¡ã‚½ãƒƒãƒ‰ | ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ | èª¬æ˜ |
|----------|----------------|------|
| POST | `/api/v1/users/promote-to-superadmin-once` | ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ SUPER_ADMIN ã«æ˜‡æ ¼ |

### å‡¦ç†ãƒ•ãƒ­ãƒ¼

```mermaid
sequenceDiagram
    participant B as ãƒ–ãƒ©ã‚¦ã‚¶
    participant API as Backend API
    participant DB as Database

    B->>API: POST /users/promote-to-superadmin-once
    API->>DB: SUPER_ADMIN ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
    alt SUPER_ADMIN ãŒå­˜åœ¨ã—ãªã„
        DB-->>API: count = 0
        API->>DB: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã® role ã‚’ SUPER_ADMIN ã«æ›´æ–°
        DB-->>API: æ›´æ–°å®Œäº†
        API-->>B: 200 OK { success: true, data: { id, email, role } }
    else SUPER_ADMIN ãŒå­˜åœ¨ã™ã‚‹
        DB-->>API: count > 0
        API-->>B: 403 Forbidden
    end
```

### ãƒ¬ã‚¹ãƒãƒ³ã‚¹ä¾‹

**æˆåŠŸæ™‚ (200 OK):**
```json
{
  "success": true,
  "data": {
    "id": "uuid-string",
    "email": "admin@example.com",
    "role": "SUPER_ADMIN"
  }
}
```

**å¤±æ•—æ™‚ (403 Forbidden):**
```json
{
  "statusCode": 403,
  "message": "SUPER_ADMINã¯ã™ã§ã«å­˜åœ¨ã—ã¾ã™",
  "error": "Forbidden"
}
```

### é–¢é€£ãƒ•ã‚¡ã‚¤ãƒ«

| ãƒ•ã‚¡ã‚¤ãƒ« | èª¬æ˜ |
|----------|------|
| `backend/src/users/users.service.ts` | æ˜‡æ ¼ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆ`promoteToSuperAdminOnce`ï¼‰ |
| `backend/src/users/users.controller.ts` | API ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå®šç¾© |
| `frontend/src/app/setup/first-superadmin/page.tsx` | ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ UI |

---
Last Update: 2025-11-28
`````

## File: docs/system-design.md
`````markdown
# ğŸ—ï¸ ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆæ›¸

## ğŸ“‹ ã‚·ã‚¹ãƒ†ãƒ æ¦‚è¦

**ã‚·ã‚¹ãƒ†ãƒ å**: çŒ«ç”Ÿä½“ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ  (My Cats)  
**ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£**: ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹æŒ‡å‘ã®ãƒ¢ãƒãƒªã‚·ãƒƒã‚¯æ§‹æˆ  
**è¨­è¨ˆæ€æƒ³**: TypeScript ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆã«ã‚ˆã‚‹å‹å®‰å…¨æ€§ã¨Reactãƒ™ãƒ¼ã‚¹ã®SPA

## ğŸ›ï¸ ã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### å…¨ä½“æ§‹æˆå›³

```mermaid
graph TB
    subgraph Client ["ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå±¤"]
        A["Web Browser<br/>Next.js 15"]
        B["ãƒ¢ãƒã‚¤ãƒ«ãƒ–ãƒ©ã‚¦ã‚¶<br/>PWAå¯¾å¿œ"]
    end

    subgraph Presentation ["ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³å±¤"]
        C["Next.js Frontend<br/>Port: 3000"]
        D["Mantine UI Components"]
    end

    subgraph Application ["ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å±¤"]
        E["NestJS API Server<br/>Port: 3004"]
        F["èªè¨¼ãƒ»èªå¯<br/>JWT + Passport"]
        G["ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³<br/>Class Validator"]
    end

    subgraph Business ["ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯å±¤"]
        H["çŒ«ç®¡ç†ã‚µãƒ¼ãƒ“ã‚¹"]
        I["è¡€çµ±ç®¡ç†ã‚µãƒ¼ãƒ“ã‚¹"]
        J["ç¹æ®–ç®¡ç†ã‚µãƒ¼ãƒ“ã‚¹"]
        K["ã‚±ã‚¢ç®¡ç†ã‚µãƒ¼ãƒ“ã‚¹"]
    end

    subgraph DataAccess ["ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹å±¤"]
        L["Prisma ORM"]
        M["PostgreSQL Database"]
    end

    A --> C
    B --> C
    C --> D
    C --> E
    E --> F
    E --> G
    F --> H
    F --> I
    F --> J
    F --> K
    H --> L
    I --> L
    J --> L
    K --> L
    L --> M
```

### ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«ã‚¹ã‚¿ãƒƒã‚¯

| å±¤             | æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯                 | ãƒãƒ¼ã‚¸ãƒ§ãƒ³            |
| -------------- | ---------------------------- | --------------------- |
| ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ | Next.js + React + TypeScript | 15.4.5 / 19.1.0 / 5.x |
| UIãƒ©ã‚¤ãƒ–ãƒ©ãƒª   | Mantine UI + Tailwind CSS    | 8.2.2 / 4.x           |
| ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰   | NestJS + TypeScript          | 10.0.0 / 5.x          |
| ORM            | Prisma                       | 6.14.0                |
| ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹   | PostgreSQL                   | 15+                   |
| èªè¨¼           | JWT + Passport               | -                     |

## ğŸ”§ ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè¨­è¨ˆ

### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

```text
src/
â”œâ”€â”€ app/                    # Next.js App Router
â”‚   â”œâ”€â”€ layout.tsx         # å…±é€šãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
â”‚   â”œâ”€â”€ page.tsx           # ãƒ›ãƒ¼ãƒ ç”»é¢
â”‚   â”œâ”€â”€ cats/              # çŒ«ç®¡ç†ãƒšãƒ¼ã‚¸
â”‚   â”œâ”€â”€ pedigrees/         # è¡€çµ±æ›¸ç®¡ç†ãƒšãƒ¼ã‚¸
â”‚   â”œâ”€â”€ breeding/          # ç¹æ®–ç®¡ç†ãƒšãƒ¼ã‚¸
â”‚   â”œâ”€â”€ care/              # ã‚±ã‚¢ç®¡ç†ãƒšãƒ¼ã‚¸
â”‚   â””â”€â”€ providers.tsx      # Context Providers
â””â”€â”€ components/            # å†åˆ©ç”¨å¯èƒ½ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
    â”œâ”€â”€ ui/               # åŸºæœ¬UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
    â”œâ”€â”€ forms/            # ãƒ•ã‚©ãƒ¼ãƒ ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
    â””â”€â”€ layout/           # ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
```

### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«è¨­è¨ˆ

```text
src/
â”œâ”€â”€ main.ts               # ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
â”œâ”€â”€ app.module.ts         # ãƒ«ãƒ¼ãƒˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
â”œâ”€â”€ cats/                 # çŒ«ç®¡ç†ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
â”‚   â”œâ”€â”€ cats.controller.ts
â”‚   â”œâ”€â”€ cats.service.ts
â”‚   â”œâ”€â”€ cats.module.ts
â”‚   â””â”€â”€ dto/
â”œâ”€â”€ pedigree/             # è¡€çµ±ç®¡ç†ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
â”œâ”€â”€ breeding/             # ç¹æ®–ç®¡ç†ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
â”œâ”€â”€ care/                 # ã‚±ã‚¢ç®¡ç†ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
â”œâ”€â”€ auth/                 # èªè¨¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
â”œâ”€â”€ prisma/               # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
â””â”€â”€ common/               # å…±é€šã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
```

## ğŸ—„ï¸ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆ

### ERå›³æ¦‚è¦

```mermaid
erDiagram
    Users ||--o{ Cats : owns
    Cats ||--o| Pedigrees : has
    Cats ||--o{ BreedingRecords : participates
    Cats ||--o{ CareSchedules : requires
    Breeds ||--o{ Cats : categorizes
    CoatColors ||--o{ Cats : colors

    Users {
        string id PK
        string email
        string name
        string role
        datetime created_at
    }

    Cats {
        string id PK
        string name
        date birth_date
        string gender
        string user_id FK
        string breed_id FK
        string coat_color_id FK
    }

    Pedigrees {
        string id PK
        string cat_id FK
        string father_id FK
        string mother_id FK
        int generation
    }
```

### ä¸»è¦ãƒ†ãƒ¼ãƒ–ãƒ«é–¢ä¿‚

1. **Users â†” Cats**: 1å¯¾å¤šï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯è¤‡æ•°ã®çŒ«ã‚’æ‰€æœ‰ï¼‰
2. **Cats â†” Pedigrees**: 1å¯¾1ï¼ˆå„çŒ«ã¯1ã¤ã®è¡€çµ±è¨˜éŒ²ï¼‰
3. **Cats â†” BreedingRecords**: å¤šå¯¾å¤šï¼ˆçŒ«ã¯è¤‡æ•°ã®äº¤é…ã«å‚åŠ ï¼‰
4. **Cats â†” CareSchedules**: 1å¯¾å¤šï¼ˆçŒ«ã¯è¤‡æ•°ã®ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼‰

## ğŸ”’ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­è¨ˆ

### èªè¨¼ãƒ»èªå¯ãƒ•ãƒ­ãƒ¼

```mermaid
sequenceDiagram
    participant C as Client
    participant F as Frontend
    participant A as Auth API
    participant B as Backend API
    participant D as Database

    C->>F: ãƒ­ã‚°ã‚¤ãƒ³è¦æ±‚
    F->>A: èªè¨¼æƒ…å ±é€ä¿¡
    A->>D: ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼
    D-->>A: èªè¨¼çµæœ
    A-->>F: JWT Tokenç™ºè¡Œ
    F->>B: APIè¦æ±‚ + JWT
    B->>B: JWTæ¤œè¨¼
    B->>D: ãƒ‡ãƒ¼ã‚¿å–å¾—
    D-->>B: ãƒ‡ãƒ¼ã‚¿è¿”å´
    B-->>F: ãƒ¬ã‚¹ãƒãƒ³ã‚¹
    F-->>C: ç”»é¢è¡¨ç¤º
```

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–

| é …ç›®   | å¯¾ç­–å†…å®¹                         |
| ------ | -------------------------------- |
| èªè¨¼   | JWT Token + Refresh Token        |
| èªå¯   | Role-based Access Control (RBAC) |
| é€šä¿¡   | HTTPSå¼·åˆ¶ã€CORSè¨­å®š              |
| ãƒ‡ãƒ¼ã‚¿ | SQL Injectionå¯¾ç­–ï¼ˆPrisma ORMï¼‰  |
| XSS    | CSPãƒ˜ãƒƒãƒ€ãƒ¼ã€å…¥åŠ›å€¤ã‚µãƒ‹ã‚¿ã‚¤ã‚º    |
| CSRF   | SameSite Cookieã€CSRFãƒˆãƒ¼ã‚¯ãƒ³    |

## ğŸ“Š APIè¨­è¨ˆ

### RESTful APIæ§‹æˆ

```text
/api/v1/
â”œâ”€â”€ /auth              # èªè¨¼é–¢é€£
â”‚   â”œâ”€â”€ POST /login    # ãƒ­ã‚°ã‚¤ãƒ³
â”‚   â””â”€â”€ POST /refresh  # ãƒˆãƒ¼ã‚¯ãƒ³ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
â”œâ”€â”€ /cats              # çŒ«ç®¡ç†
â”‚   â”œâ”€â”€ GET /          # çŒ«ä¸€è¦§å–å¾—
â”‚   â”œâ”€â”€ POST /         # çŒ«ç™»éŒ²
â”‚   â”œâ”€â”€ GET /:id       # çŒ«è©³ç´°å–å¾—
â”‚   â””â”€â”€ PUT /:id       # çŒ«æƒ…å ±æ›´æ–°
â”œâ”€â”€ /pedigrees         # è¡€çµ±ç®¡ç†
â”œâ”€â”€ /breeding          # ç¹æ®–ç®¡ç†
â””â”€â”€ /care             # ã‚±ã‚¢ç®¡ç†
```

### ãƒ¬ã‚¹ãƒãƒ³ã‚¹è¨­è¨ˆ

```typescript
// æˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹
interface ApiResponse<T> {
  success: true;
  data: T;
  meta?: {
    total: number;
    page: number;
    limit: number;
  };
}

// ã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹
interface ApiError {
  success: false;
  error: {
    code: string;
    message: string;
    details?: any;
  };
}
```

## ğŸ”„ ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼è¨­è¨ˆ

### çŠ¶æ…‹ç®¡ç†ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

```mermaid
graph LR
    A["User Action"] --> B["React Component"]
    B --> C["API Call"]
    C --> D["NestJS Controller"]
    D --> E["Service Layer"]
    E --> F["Prisma ORM"]
    F --> G["PostgreSQL"]
    G --> F
    F --> E
    E --> D
    D --> C
    C --> B
    B --> H["UI Update"]
```

### ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥

| ãƒ‡ãƒ¼ã‚¿ç¨®åˆ¥         | ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ–¹å¼       | TTL                |
| ------------------ | -------------------- | ------------------ |
| é™çš„ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿   | Browser Cache        | 24æ™‚é–“             |
| ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚»ãƒƒã‚·ãƒ§ãƒ³ | Memory               | ã‚»ãƒƒã‚·ãƒ§ãƒ³çµ‚äº†ã¾ã§ |
| API ãƒ¬ã‚¹ãƒãƒ³ã‚¹     | SWR (ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ)   | 5åˆ†                |
| ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹       | Query Cache (Prisma) | 1åˆ†                |

## ğŸ“± UI/UXè¨­è¨ˆ

### ãƒ‡ã‚¶ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ 

- **ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆ**: Mantine UI ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ + ã‚«ã‚¹ã‚¿ãƒ ãƒ†ãƒ¼ãƒ
- **ã‚¿ã‚¤ãƒã‚°ãƒ©ãƒ•ã‚£**: ã‚·ã‚¹ãƒ†ãƒ ãƒ•ã‚©ãƒ³ãƒˆå„ªå…ˆ
- **ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ**: Mantine UI + ã‚«ã‚¹ã‚¿ãƒ ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
- **ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–**: Mobile First ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ

### ç”»é¢æ§‹æˆ

```text
Header (ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³)
â”œâ”€â”€ ãƒ­ã‚°ã‚¤ãƒ³/ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±
â”œâ”€â”€ ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼
â””â”€â”€ æ¤œç´¢ãƒãƒ¼

Main Content
â”œâ”€â”€ ã‚µã‚¤ãƒ‰ãƒãƒ¼ (ãƒ¡ãƒ‹ãƒ¥ãƒ¼)
â””â”€â”€ ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¨ãƒªã‚¢

Footer
â”œâ”€â”€ ã‚·ã‚¹ãƒ†ãƒ æƒ…å ±
â””â”€â”€ ãƒ˜ãƒ«ãƒ—ãƒªãƒ³ã‚¯
```

## ğŸš€ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨­è¨ˆ

### æœ€é©åŒ–æˆ¦ç•¥

| é …ç›®           | æ‰‹æ³•                                                |
| -------------- | --------------------------------------------------- |
| ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ | Code Splittingã€Tree Shakingã€Image Optimization    |
| ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰   | N+1å•é¡Œå¯¾ç­–ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æœ€é©åŒ–ã€Connection Pooling |
| ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹   | ã‚¯ã‚¨ãƒªæœ€é©åŒ–ã€é©åˆ‡ãªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¨­è¨ˆ                |
| ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯   | CDNã€Gzipåœ§ç¸®ã€HTTP/2                               |

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›®æ¨™

- **First Contentful Paint**: 1.5ç§’ä»¥å†…
- **Largest Contentful Paint**: 2.5ç§’ä»¥å†…
- **Cumulative Layout Shift**: 0.1ä»¥ä¸‹
- **API Response Time**: å¹³å‡500msä»¥å†…

## ğŸ”§ é‹ç”¨è¨­è¨ˆ

### ç›£è¦–ãƒ»ãƒ­ã‚°

```mermaid
graph TB
    A["ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³"] --> B["ãƒ­ã‚°å‡ºåŠ›"]
    B --> C["ãƒ­ã‚°é›†ç´„"]
    C --> D["ç›£è¦–ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰"]
    D --> E["ã‚¢ãƒ©ãƒ¼ãƒˆé€šçŸ¥"]

    F["ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯"] --> G["æ­»æ´»ç›£è¦–"]
    G --> H["è‡ªå‹•å¾©æ—§"]
```

### ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆæˆ¦ç•¥

- **ç’°å¢ƒ**: Development â†’ Staging â†’ Production
- **æ‰‹æ³•**: Blue-Green Deployment
- **CI/CD**: GitHub Actions
- **ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯**: è‡ªå‹•ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯å¯¾å¿œ

---

**æ–‡æ›¸ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 1.1  
**æœ€çµ‚æ›´æ–°æ—¥**: 2025å¹´8æœˆ14æ—¥  
**è¨­è¨ˆè€…**: é–‹ç™ºãƒãƒ¼ãƒ 
`````

## File: docs/ui-button-design-guide.md
`````markdown
# ãƒœã‚¿ãƒ³ãƒ‡ã‚¶ã‚¤ãƒ³çµ±ä¸€ã‚¬ã‚¤ãƒ‰

## æ¦‚è¦

ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“ã§CRUDæ“ä½œãƒœã‚¿ãƒ³ã®ãƒ‡ã‚¶ã‚¤ãƒ³ã‚’çµ±ä¸€ã—ã€å¯èª­æ€§ã¨æ“ä½œæ€§ã‚’å‘ä¸Šã•ã›ã‚‹ãŸã‚ã®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã§ã™ã€‚

## ãƒ‡ã‚¶ã‚¤ãƒ³ãƒãƒªã‚·ãƒ¼

### åŸºæœ¬æ–¹é‡

1. **å¯èª­æ€§é‡è¦–**: ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ãƒ™ãƒ¼ã‚¹ã§èƒŒæ™¯ã‚’å¡—ã‚Šã¤ã¶ã•ãªã„ã“ã¨ã§ã€ãƒ†ã‚­ã‚¹ãƒˆã®å¯èª­æ€§ã‚’å‘ä¸Š
2. **è‰²ã«ã‚ˆã‚‹ç›´æ„Ÿçš„ãªç†è§£**: æ“ä½œã®ç¨®é¡ã‚’è‰²ã§è­˜åˆ¥ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
3. **ä¸€è²«æ€§**: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“ã§åŒã˜æ“ä½œã«ã¯åŒã˜ãƒ‡ã‚¶ã‚¤ãƒ³ã‚’é©ç”¨
4. **ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£**: è‰²ã ã‘ã§ãªãã‚¢ã‚¤ã‚³ãƒ³ã‚‚ä½µç”¨ã—ã¦æƒ…å ±ã‚’ä¼é”

## ãƒœã‚¿ãƒ³ã‚¹ã‚¿ã‚¤ãƒ«å®šç¾©

### 1. ä½œæˆãƒ»è¿½åŠ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆCreate/Addï¼‰

**ç”¨é€”**: æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã®ä½œæˆã€è¦ç´ ã®è¿½åŠ 

```tsx
<Button variant="outline" color="blue" leftSection={<IconPlus size={16} />}>
  æ–°è¦ç™»éŒ²
</Button>
```

- **variant**: `outline`
- **color**: `blue`
- **icon**: `IconPlus`
- **ä½¿ç”¨ä¾‹**: æ–°è¦çŒ«ç™»éŒ²ã€ã‚±ã‚¢äºˆå®šè¿½åŠ ã€ã‚¿ã‚°ä½œæˆ

### 2. ç·¨é›†ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆEdit/Updateï¼‰

**ç”¨é€”**: æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã®ç·¨é›†ãƒ»æ›´æ–°

```tsx
<Button variant="outline" color="yellow" leftSection={<IconEdit size={16} />}>
  ç·¨é›†
</Button>
```

- **variant**: `outline`
- **color**: `yellow`
- **icon**: `IconEdit`
- **ä½¿ç”¨ä¾‹**: çŒ«æƒ…å ±ç·¨é›†ã€ã‚±ã‚¢äºˆå®šç·¨é›†ã€è¨­å®šå¤‰æ›´

### 3. å‰Šé™¤ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆDeleteï¼‰

**ç”¨é€”**: ãƒ‡ãƒ¼ã‚¿ã®å‰Šé™¤ï¼ˆå±é™ºãªæ“ä½œï¼‰

```tsx
<Button variant="outline" color="red" leftSection={<IconTrash size={16} />}>
  å‰Šé™¤
</Button>
```

- **variant**: `outline`ï¼ˆç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ«å†…ã§ã¯`filled`ï¼‰
- **color**: `red`
- **icon**: `IconTrash`
- **ä½¿ç”¨ä¾‹**: çŒ«ãƒ‡ãƒ¼ã‚¿å‰Šé™¤ã€ã‚±ã‚¢äºˆå®šå‰Šé™¤ã€ã‚¿ã‚°å‰Šé™¤
- **æ³¨æ„**: å‰Šé™¤ç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ«å†…ã®æœ€çµ‚æ±ºå®šãƒœã‚¿ãƒ³ã¯`variant="filled"`ã§å¼·èª¿

### 4. è¡¨ç¤ºãƒ»è©³ç´°ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆView/Detailï¼‰

**ç”¨é€”**: è©³ç´°æƒ…å ±ã®é–²è¦§ã€å®‰å…¨ãªå‚ç…§æ“ä½œ

```tsx
<Button variant="outline" color="gray" leftSection={<IconEye size={16} />}>
  è©³ç´°
</Button>
```

- **variant**: `outline`
- **color**: `gray`
- **icon**: `IconEye`
- **ä½¿ç”¨ä¾‹**: ã‚±ã‚¢è©³ç´°è¡¨ç¤ºã€è¡€çµ±è¡¨è¡¨ç¤ºã€è©³ç´°æƒ…å ±ãƒ¢ãƒ¼ãƒ€ãƒ«

### 5. ä¿å­˜ãƒ»ç¢ºèªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆSave/Confirmï¼‰

**ç”¨é€”**: ãƒ•ã‚©ãƒ¼ãƒ é€ä¿¡ã€æœ€çµ‚ç¢ºèªï¼ˆãƒã‚¸ãƒ†ã‚£ãƒ–ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼‰

```tsx
<Button variant="filled" color="blue" leftSection={<IconDeviceFloppy size={16} />}>
  ä¿å­˜
</Button>

<Button variant="filled" color="blue" leftSection={<IconCheck size={16} />}>
  ç¢ºèª
</Button>
```

- **variant**: `filled`ï¼ˆèƒŒæ™¯å¡—ã‚Šã¤ã¶ã—ï¼‰
- **color**: `blue`
- **icon**: `IconDeviceFloppy` ã¾ãŸã¯ `IconCheck`
- **ä½¿ç”¨ä¾‹**: ãƒ•ã‚©ãƒ¼ãƒ ä¿å­˜ã€ç™»éŒ²ç¢ºèªã€è¨­å®šé©ç”¨
- **æ³¨æ„**: é‡è¦ãªæ±ºå®šæ“ä½œã®ãŸã‚ã€å”¯ä¸€`filled`ã‚’ä½¿ç”¨

### 6. ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒ»æˆ»ã‚‹ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆCancel/Backï¼‰

**ç”¨é€”**: æ“ä½œã®ä¸­æ­¢ã€å‰ç”»é¢ã¸ã®é·ç§»

```tsx
<Button variant="subtle" color="gray" leftSection={<IconX size={16} />}>
  ã‚­ãƒ£ãƒ³ã‚»ãƒ«
</Button>

<Button variant="subtle" color="gray" leftSection={<IconArrowLeft size={16} />}>
  æˆ»ã‚‹
</Button>
```

- **variant**: `subtle`
- **color**: `gray`
- **icon**: `IconX` ã¾ãŸã¯ `IconArrowLeft`
- **ä½¿ç”¨ä¾‹**: ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã€ä¸€è¦§ã¸æˆ»ã‚‹

### 7. æ›´æ–°ãƒ»ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆRefreshï¼‰

**ç”¨é€”**: ãƒ‡ãƒ¼ã‚¿ã®å†èª­ã¿è¾¼ã¿

```tsx
<Button variant="subtle" leftSection={<IconRefresh size={16} />}>
  æ›´æ–°
</Button>
```

- **variant**: `subtle`
- **icon**: `IconRefresh`
- **ä½¿ç”¨ä¾‹**: ãƒ‡ãƒ¼ã‚¿ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã€å†å–å¾—

## ãƒ†ãƒ¼ãƒ–ãƒ«è¡Œã‚¢ã‚¯ã‚·ãƒ§ãƒ³

ãƒ†ãƒ¼ãƒ–ãƒ«å†…ã®å„è¡Œã«é…ç½®ã™ã‚‹å°ã•ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã«ã¯`ActionIcon`ã‚’ä½¿ç”¨ï¼š

```tsx
<Group gap="xs" justify="center">
  {/* è¡¨ç¤º */}
  <ActionIcon variant="light" color="gray" size="sm">
    <IconEye size={16} />
  </ActionIcon>
  
  {/* ç·¨é›† */}
  <ActionIcon variant="light" color="yellow" size="sm">
    <IconEdit size={16} />
  </ActionIcon>
  
  {/* å‰Šé™¤ */}
  <ActionIcon variant="light" color="red" size="sm">
    <IconTrash size={16} />
  </ActionIcon>
</Group>
```

## ãƒ¢ãƒ¼ãƒ€ãƒ«ãƒ•ãƒƒã‚¿ãƒ¼ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ

ãƒ¢ãƒ¼ãƒ€ãƒ«ã®ãƒœã‚¿ãƒ³é…ç½®ã¯ä»¥ä¸‹ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«çµ±ä¸€ï¼š

### ä½œæˆãƒ¢ãƒ¼ãƒ€ãƒ«

```tsx
<Group justify="flex-end">
  <Button variant="subtle" color="gray">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</Button>
  <Button variant="filled" color="blue">ç™»éŒ²</Button>
</Group>
```

### ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ«

```tsx
<Group justify="flex-end">
  <Button variant="subtle" color="gray">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</Button>
  <Button variant="filled" color="blue">ä¿å­˜</Button>
</Group>
```

### å‰Šé™¤ç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ«

```tsx
<Group justify="flex-end">
  <Button variant="subtle" color="gray">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</Button>
  <Button variant="filled" color="red">å‰Šé™¤</Button>
</Group>
```

## ActionButtonã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ä½¿ç”¨

å…±é€šã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ`ActionButton`ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã€ã‚ˆã‚Šç°¡æ½”ã«è¨˜è¿°ã§ãã¾ã™ï¼š

```tsx
import { ActionButton } from '@/components/ActionButton';

// è‡ªå‹•çš„ã«ã‚¹ã‚¿ã‚¤ãƒ«ã¨ã‚¢ã‚¤ã‚³ãƒ³ãŒé©ç”¨ã•ã‚Œã‚‹
<ActionButton action="create">æ–°è¦ç™»éŒ²</ActionButton>
<ActionButton action="edit">ç·¨é›†</ActionButton>
<ActionButton action="delete">å‰Šé™¤</ActionButton>
<ActionButton action="view">è©³ç´°</ActionButton>
<ActionButton action="save">ä¿å­˜</ActionButton>
<ActionButton action="cancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</ActionButton>
```

## ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆ

| ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ | ã‚«ãƒ©ãƒ¼ | ç”¨é€” |
|-----------|-------|------|
| ä½œæˆãƒ»è¿½åŠ  | `blue` | ãƒã‚¸ãƒ†ã‚£ãƒ–ãªæ–°è¦æ“ä½œ |
| ç·¨é›† | `yellow` | æ³¨æ„ã‚’å¼•ãå¤‰æ›´æ“ä½œ |
| å‰Šé™¤ | `red` | å±é™ºãªæ“ä½œ |
| è¡¨ç¤ºãƒ»è©³ç´° | `gray` | å®‰å…¨ãªé–²è¦§æ“ä½œ |
| ä¿å­˜ãƒ»ç¢ºèª | `blue` | é‡è¦ãªæ±ºå®š |
| ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒ»æˆ»ã‚‹ | `gray` | ä¸­ç«‹çš„ãªæ“ä½œ |

## å®Ÿè£…æ™‚ã®æ³¨æ„ç‚¹

1. **ä¸€è²«æ€§ã‚’ä¿ã¤**: åŒã˜æ“ä½œã«ã¯å¿…ãšåŒã˜ã‚¹ã‚¿ã‚¤ãƒ«ã‚’é©ç”¨
2. **ã‚¢ã‚¤ã‚³ãƒ³ã‚’ä½¿ç”¨**: ãƒ†ã‚­ã‚¹ãƒˆã ã‘ã§ãªãã‚¢ã‚¤ã‚³ãƒ³ã§è¦–è¦šçš„ã«è­˜åˆ¥å¯èƒ½ã«
3. **è‰²ã®æ„å‘³ã‚’å°Šé‡**: èµ¤ã¯å‰Šé™¤ãªã©å±é™ºãªæ“ä½œã®ã¿ã«ä½¿ç”¨
4. **é©åˆ‡ãªvariantã‚’é¸æŠ**: 
   - ä¸»è¦ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: `outline`
   - æ±ºå®šæ“ä½œ: `filled`
   - æ§ãˆã‚ãªæ“ä½œ: `subtle`
5. **ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ã‚’è€ƒæ…®**: `loading`ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’é©åˆ‡ã«ä½¿ç”¨

## ç§»è¡Œæ‰‹é †

æ—¢å­˜ã®ãƒœã‚¿ãƒ³ã‚’æ®µéšçš„ã«ç§»è¡Œã™ã‚‹éš›ã®æ‰‹é †ï¼š

1. **å„ªå…ˆåº¦ã®é«˜ã„ãƒšãƒ¼ã‚¸ã‹ã‚‰ç€æ‰‹**: ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¥è§¦é »åº¦ã®é«˜ã„ãƒšãƒ¼ã‚¸ï¼ˆçŒ«ä¸€è¦§ã€ã‚±ã‚¢ç®¡ç†ãªã©ï¼‰
2. **ãƒšãƒ¼ã‚¸å˜ä½ã§å®Œå…¨ã«ç§»è¡Œ**: éƒ¨åˆ†çš„ãªç§»è¡Œã¯é¿ã‘ã€1ãƒšãƒ¼ã‚¸å†…ã¯å®Œå…¨ã«çµ±ä¸€
3. **ãƒ†ã‚¹ãƒˆã‚’å®Ÿæ–½**: å„ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãŒæ­£ã—ãå‹•ä½œã™ã‚‹ã‹ç¢ºèª
4. **UIãƒ¬ãƒ“ãƒ¥ãƒ¼**: å¯èª­æ€§ã¨æ“ä½œæ€§ãŒå‘ä¸Šã—ã¦ã„ã‚‹ã‹ç¢ºèª

## ãƒ‡ãƒ¢ãƒšãƒ¼ã‚¸

çµ±ä¸€ãƒœã‚¿ãƒ³ã®ãƒ‡ãƒ¢ã¯ä»¥ä¸‹ã®URLã§ç¢ºèªã§ãã¾ã™ï¼š

```
http://localhost:3000/demo/action-buttons
```

ã™ã¹ã¦ã®ãƒœã‚¿ãƒ³ã‚¹ã‚¿ã‚¤ãƒ«ã¨ãã®ä½¿ç”¨ä¾‹ã‚’ä¸€è¦§ã§ãã¾ã™ã€‚

## ã¾ã¨ã‚

ã“ã®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã«å¾“ã†ã“ã¨ã§ï¼š

- âœ… **å¯èª­æ€§å‘ä¸Š**: ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ãƒ™ãƒ¼ã‚¹ã§èƒŒæ™¯ãŒã‚¯ãƒªãƒ¼ãƒ³
- âœ… **æ“ä½œæ€§å‘ä¸Š**: è‰²ã¨ã‚¢ã‚¤ã‚³ãƒ³ã§ç›´æ„Ÿçš„ã«æ“ä½œã‚’è­˜åˆ¥
- âœ… **çµ±ä¸€æ„Ÿ**: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“ã§ä¸€è²«ã—ãŸUI
- âœ… **ä¿å®ˆæ€§**: å…±é€šã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã§ç®¡ç†ãŒå®¹æ˜“
- âœ… **ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£**: è‰²è¦šã«ä¾å­˜ã—ãªã„ã‚¢ã‚¤ã‚³ãƒ³è¡¨ç¤º

## å‚è€ƒãƒªãƒ³ã‚¯

- [Mantine Button Documentation](https://mantine.dev/core/button/)
- [Mantine ActionIcon Documentation](https://mantine.dev/core/action-icon/)
- [Tabler Icons](https://tabler.io/icons)
`````

## File: docs/Vertical_Review_Agent_Pronpt
`````
ç¸¦å‰²ã‚Šãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ä¾é ¼ã—ã¾ã™ã€‚

å¯¾è±¡æ©Ÿèƒ½:
- æ©Ÿèƒ½å: {æ©Ÿèƒ½å}
- èµ·ç‚¹UI: {ãƒšãƒ¼ã‚¸ / æ“ä½œ}

ãƒ¬ãƒ“ãƒ¥ãƒ¼æ¡ä»¶:
- UI â†’ API â†’ DB ã®ç¸¦ã®ç¹‹ãŒã‚Šã®ã¿ã‚’ç¢ºèª
- æ¨æ¸¬ã¯ç¦æ­¢ã€‚ä¸æ˜ãªå ´åˆã¯ã€Œä¸æ˜ã€ã¨è¨˜è¼‰
- å‡ºåŠ›ã¯ Vertical Review Agent ã®ä»•æ§˜æ›¸ã«å®Œå…¨æº–æ‹ 

ç‰¹ã«ç¢ºèªã—ãŸã„æ“ä½œ:
- {ä¾‹: æ–°è¦ä½œæˆ / ç·¨é›† / ä¸€è¦§è¡¨ç¤º}
`````

## File: docs/Vertical_Review_To_Copilot_Agent
`````
ã‚ãªãŸã¯ mycats-pro ã® {Frontend / Backend} å®Ÿè£…æ‹…å½“ AI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§ã™ã€‚
ãƒ«ãƒ¼ãƒˆ AGENTS.md ã¨è©²å½“ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã® instructions ã‚’å³å®ˆã—ã¦ãã ã•ã„ã€‚

æœ¬ã‚¿ã‚¹ã‚¯ã¯ã€Œç¸¦å‰²ã‚Šãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã€ã‚’å—ã‘ãŸã€å·®åˆ†ä¿®æ­£ã€‘ã§ã™ã€‚
æ–°è¦è¨­è¨ˆã‚„ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã¯ç›®çš„ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

ã€å…¥åŠ›ã€‘
ä»¥ä¸‹ã¯ Vertical Review Agent ã«ã‚ˆã‚‹ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã§ã™ã€‚
ã“ã®å†…å®¹ã‚’å”¯ä¸€ã®äº‹å®Ÿã¨ã—ã¦æ‰±ã£ã¦ãã ã•ã„ã€‚

--- ç¸¦å‰²ã‚Šãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœ ---
ï¼ˆãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã‚’ãã®ã¾ã¾è²¼ã‚‹ï¼‰
--- ã“ã“ã¾ã§ ---

ã€ä»Šå›ä¿®æ­£ã™ã‚‹å¯¾è±¡ï¼ˆå³å®ˆï¼‰ã€‘
- ä¿®æ­£å¯¾è±¡:
  1. ï¼ˆä¾‹ï¼‰useGetPregnancyChecks / useGetBirthPlans ãŒ
     params ã‚’ API ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«åæ˜ ã—ã¦ã„ãªã„å•é¡Œ
  2. ï¼ˆä¾‹ï¼‰kitten-dispositions / ä¸€éƒ¨ GET API ã®
     èªè¨¼ã‚¬ãƒ¼ãƒ‰ï¼ˆJwtAuthGuardï¼‰ãŒä»–ã¨ä¸æ•´åˆãªå•é¡Œ

ã€å¤‰æ›´å¢ƒç•Œï¼ˆçµ¶å¯¾ã«å®ˆã‚‹ã“ã¨ï¼‰ã€‘
- localStorage ã‚’ç”¨ã„ãŸäº¤é…ç®¡ç†ãƒ­ã‚¸ãƒƒã‚¯ã¯å¯¾è±¡å¤–
- DB ã‚¹ã‚­ãƒ¼ãƒå¤‰æ›´ã¯ç¦æ­¢
- API ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ§‹é€ å¤‰æ›´ã¯ç¦æ­¢
- æ—¢å­˜ã®è²¬å‹™åˆ†é›¢ã‚’å£Šã™ãƒªãƒ•ã‚¡ã‚¯ã‚¿ã¯ç¦æ­¢
- æŒ‡æ‘˜ã•ã‚Œã¦ã„ãªã„ç®‡æ‰€ã¸ã®ã€Œã¤ã„ã§ä¿®æ­£ã€ã¯ç¦æ­¢

ã€å®Œäº†æ¡ä»¶ã€‘
- ä¸Šè¨˜ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã®ã€Œæœªæ¥ç¶š / ä¸æ˜ç‚¹ä¸€è¦§ã€ã‹ã‚‰ã€
  ä»Šå›ã®ä¿®æ­£å¯¾è±¡ãŒæ¶ˆãˆã‚‹ã“ã¨
- å†åº¦ ç¸¦å‰²ã‚Šãƒ¬ãƒ“ãƒ¥ãƒ¼ Agent ã‚’å®Ÿè¡Œã—ãŸéš›ã€
  Coverage ãŒæ”¹å–„ã—ã¦ã„ã‚‹ã“ã¨

ã€å‡ºåŠ›ã—ã¦ã»ã—ã„å†…å®¹ã€‘
1. å¤‰æ›´ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã¨å¤‰æ›´ç†ç”±
2. ä¿®æ­£å†…å®¹ã®è¦ç‚¹ï¼ˆå·®åˆ†ãŒåˆ†ã‹ã‚‹èª¬æ˜ï¼‰
3. å®Ÿè¡Œã¾ãŸã¯æƒ³å®šã—ãŸç¢ºèªæ‰‹é †ï¼ˆç°¡æ½”ã§å¯ï¼‰
`````

## File: eslint.config.mjs
`````javascript
/**
 * ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆ ESLintè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«
 * çŒ«ç”Ÿä½“ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ  (My Cats) å…¨ä½“è¨­å®š
 * 
 * ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®å½¹å‰²:
 * - ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“ã®åŸºæœ¬ESLintãƒãƒªã‚·ãƒ¼ã‚’å®šç¾©
 * - ãƒ«ãƒ¼ãƒˆãƒ¬ãƒ™ãƒ«ã®è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãƒ»ã‚¹ã‚¯ãƒªãƒ—ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®å“è³ªç®¡ç†
 * - ã‚µãƒ–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªï¼ˆfrontend/backendï¼‰ã¯å€‹åˆ¥è¨­å®šã‚’ä½¿ç”¨
 * 
 * è¨­å®šæ–¹é‡:
 * - å„ã‚µãƒ–ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯ç‹¬è‡ªã®è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒã¤
 * - ãƒ«ãƒ¼ãƒˆãƒ¬ãƒ™ãƒ«ã§ã¯æœ€å°é™ã®è¨­å®šã§æ··ä¹±ã‚’é¿ã‘ã‚‹
 * - å…±é€šã®ã‚³ãƒ¼ãƒ‰å“è³ªåŸºæº–ã‚’ç¶­æŒ
 */

import js from '@eslint/js';
import tseslint from 'typescript-eslint';

export default [
  // === åŸºæœ¬è¨­å®š ===
  js.configs.recommended,
  ...tseslint.configs.recommended,
  
  // === ãƒ«ãƒ¼ãƒˆãƒ¬ãƒ™ãƒ«è¨­å®š ===
  {
    name: 'root-project-config',
    files: ['*.js', '*.mjs', '*.ts'],
    languageOptions: {
      ecmaVersion: 2020,
      sourceType: 'module',
      globals: {
        node: true
      }
    },
    rules: {
      // åŸºæœ¬çš„ãªJavaScript/TypeScriptãƒ«ãƒ¼ãƒ«
      'no-console': 'off', // ãƒ«ãƒ¼ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒˆã§ã®å‡ºåŠ›ã¯è¨±å¯
      'no-unused-vars': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/no-explicit-any': 'warn',
      
      // è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã§ã¯æŸ”è»Ÿæ€§ã‚’å„ªå…ˆ
      '@typescript-eslint/no-require-imports': 'off',
    }
  },
  
  // === é™¤å¤–è¨­å®š ===
  {
    name: 'root-ignores',
    ignores: [
  // root JSON configs should be ignored
  '*.json',
  'package.json',
      // ã‚µãƒ–ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªï¼ˆå€‹åˆ¥è¨­å®šã‚’ä½¿ç”¨ï¼‰
      'frontend/**',
      'backend/**',
      
      // ç”Ÿæˆãƒ•ã‚¡ã‚¤ãƒ«ãƒ»ä¾å­˜é–¢ä¿‚
      'node_modules/**',
      'dist/**',
      'coverage/**',
      '*.log',
      
      // ç’°å¢ƒå›ºæœ‰ãƒ•ã‚¡ã‚¤ãƒ«
      '.env*',
      '.DS_Store',
      
      // ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãƒ»è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«
      'docs/**',
      'README.md',
      '*.md',
      '.git/**',
      '.github/**',
      
      // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹é–¢é€£
      'database/**',
      '*.sql',
      '*.db',
      '*.sqlite',
      
      // ãã®ä»–ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå›ºæœ‰ãƒ•ã‚¡ã‚¤ãƒ«
      'nginx/**',
      'scripts/**',
      '*.ini',
      '*.csv'
    ]
  }
];
`````

## File: backend/src/export/dto/export-request.dto.ts
`````typescript
import { ApiProperty } from '@nestjs/swagger';
import { IsEnum, IsOptional, IsArray, IsDateString } from 'class-validator';

export enum ExportDataType {
  CATS = 'cats',
  PEDIGREES = 'pedigrees',
  MEDICAL_RECORDS = 'medical_records',
  CARE_SCHEDULES = 'care_schedules',
  TAGS = 'tags',
}

export enum ExportFormat {
  CSV = 'csv',
  JSON = 'json',
}

export class ExportRequestDto {
  @ApiProperty({ enum: ExportDataType, description: 'ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå¯¾è±¡ãƒ‡ãƒ¼ã‚¿ç¨®åˆ¥' })
  @IsEnum(ExportDataType)
  dataType: ExportDataType;

  @ApiProperty({ enum: ExportFormat, description: 'ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå½¢å¼', default: ExportFormat.CSV })
  @IsEnum(ExportFormat)
  format: ExportFormat;

  @ApiProperty({ description: 'é–‹å§‹æ—¥ï¼ˆãƒ•ã‚£ãƒ«ã‚¿ç”¨ï¼‰', required: false })
  @IsOptional()
  @IsDateString()
  startDate?: string;

  @ApiProperty({ description: 'çµ‚äº†æ—¥ï¼ˆãƒ•ã‚£ãƒ«ã‚¿ç”¨ï¼‰', required: false })
  @IsOptional()
  @IsDateString()
  endDate?: string;

  @ApiProperty({ description: 'å¯¾è±¡IDãƒªã‚¹ãƒˆï¼ˆç‰¹å®šãƒ‡ãƒ¼ã‚¿ã®ã¿ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆï¼‰', required: false, type: [String] })
  @IsOptional()
  @IsArray()
  ids?: string[];
}
`````

## File: backend/src/export/export.controller.ts
`````typescript
import {
  Controller,
  Post,
  Body,
  UseGuards,
  Res,
  HttpStatus,
} from '@nestjs/common';
import { ApiBearerAuth, ApiOperation, ApiResponse, ApiTags } from '@nestjs/swagger';
import { Response } from 'express';

import type { RequestUser } from '../auth/auth.types';
import { GetUser } from '../auth/get-user.decorator';
import { JwtAuthGuard } from '../auth/jwt-auth.guard';

import { ExportRequestDto, ExportFormat } from './dto/export-request.dto';
import { ExportService } from './export.service';

@ApiTags('Export')
@ApiBearerAuth()
@UseGuards(JwtAuthGuard)
@Controller('export')
export class ExportController {
  constructor(private readonly exportService: ExportService) {}

  @Post()
  @ApiOperation({ summary: 'ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ' })
  @ApiResponse({ status: HttpStatus.OK, description: 'ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæˆåŠŸ' })
  @ApiResponse({ status: HttpStatus.BAD_REQUEST, description: 'ç„¡åŠ¹ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆ' })
  async export(
    @Body() dto: ExportRequestDto,
    @GetUser() user: RequestUser,
    @Res() res: Response,
  ) {
    const { data, filename } = await this.exportService.exportData(dto, user.userId);

    if (dto.format === ExportFormat.CSV) {
      const csv = this.exportService.convertToCSV(data);
      res.setHeader('Content-Type', 'text/csv; charset=utf-8');
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.send(csv);
    } else {
      res.setHeader('Content-Type', 'application/json; charset=utf-8');
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.send(JSON.stringify(data, null, 2));
    }
  }
}
`````

## File: backend/src/export/export.module.ts
`````typescript
import { Module } from '@nestjs/common';

import { PrismaModule } from '../prisma/prisma.module';

import { ExportController } from './export.controller';
import { ExportService } from './export.service';

@Module({
  imports: [PrismaModule],
  controllers: [ExportController],
  providers: [ExportService],
})
export class ExportModule {}
`````

## File: backend/src/export/export.service.ts
`````typescript
import { Injectable, BadRequestException } from '@nestjs/common';
import { Prisma } from '@prisma/client';

import { PrismaService } from '../prisma/prisma.service';

import { ExportDataType, ExportRequestDto } from './dto/export-request.dto';

interface ExportResult {
  [key: string]: string | number | boolean | null;
}

@Injectable()
export class ExportService {
  constructor(private readonly prisma: PrismaService) {}

  async exportData(dto: ExportRequestDto, userId: string): Promise<{ data: ExportResult[]; filename: string }> {
    let data: ExportResult[] = [];
    let filename = '';

    switch (dto.dataType) {
      case ExportDataType.CATS:
        data = await this.exportCats(dto, userId);
        filename = `cats_export_${new Date().toISOString().split('T')[0]}`;
        break;
      case ExportDataType.PEDIGREES:
        data = await this.exportPedigrees(dto);
        filename = `pedigrees_export_${new Date().toISOString().split('T')[0]}`;
        break;
      case ExportDataType.MEDICAL_RECORDS:
        data = await this.exportMedicalRecords();
        filename = `medical_records_export_${new Date().toISOString().split('T')[0]}`;
        break;
      case ExportDataType.CARE_SCHEDULES:
        data = await this.exportCareSchedules(dto);
        filename = `care_schedules_export_${new Date().toISOString().split('T')[0]}`;
        break;
      case ExportDataType.TAGS:
        data = await this.exportTags();
        filename = `tags_export_${new Date().toISOString().split('T')[0]}`;
        break;
      default:
        throw new BadRequestException('æœªå¯¾å¿œã®ãƒ‡ãƒ¼ã‚¿ã‚¿ã‚¤ãƒ—ã§ã™');
    }

    return { data, filename: `${filename}.${dto.format}` };
  }

  private async exportCats(dto: ExportRequestDto, _userId: string): Promise<ExportResult[]> {
    const where: Prisma.CatWhereInput = {};
    
    if (dto.ids && dto.ids.length > 0) {
      where.id = { in: dto.ids };
    }

    if (dto.startDate || dto.endDate) {
      where.createdAt = {};
      if (dto.startDate) {
        where.createdAt.gte = new Date(dto.startDate);
      }
      if (dto.endDate) {
        where.createdAt.lte = new Date(dto.endDate);
      }
    }

    const cats = await this.prisma.cat.findMany({
      where,
      include: {
        breed: true,
        coatColor: true,
        father: true,
        mother: true,
      },
      orderBy: { createdAt: 'desc' },
    });

    return cats.map(cat => ({
      id: cat.id,
      name: cat.name,
      registrationNumber: cat.registrationNumber || '',
      gender: cat.gender,
      birthDate: cat.birthDate?.toISOString().split('T')[0] || '',
      breed: cat.breed?.name || '',
      color: cat.coatColor?.name || '',
      microchipNumber: cat.microchipNumber || '',
      fatherName: cat.father?.name || '',
      motherName: cat.mother?.name || '',
      notes: cat.description || '',
      createdAt: cat.createdAt.toISOString(),
      updatedAt: cat.updatedAt.toISOString(),
    }));
  }

  private async exportPedigrees(dto: ExportRequestDto): Promise<ExportResult[]> {
    const where: Prisma.PedigreeWhereInput = {};
    
    if (dto.ids && dto.ids.length > 0) {
      where.id = { in: dto.ids };
    }

    const pedigrees = await this.prisma.pedigree.findMany({
      where,
      orderBy: { createdAt: 'desc' },
    });

    return pedigrees.map(p => ({
      id: p.id,
      pedigreeId: p.pedigreeId,
      catName: p.catName,
      title: p.title || '',
      breedCode: p.breedCode || '',
      genderCode: p.genderCode || '',
      coatColorCode: p.coatColorCode || '',
      createdAt: p.createdAt.toISOString(),
      updatedAt: p.updatedAt.toISOString(),
    }));
  }

  private async exportMedicalRecords(): Promise<ExportResult[]> {
    // åŒ»ç™‚è¨˜éŒ²ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Ÿè£…ï¼ˆç¾åœ¨ã¯ç©ºé…åˆ—ã‚’è¿”ã™ï¼‰
    return [];
  }

  private async exportCareSchedules(dto: ExportRequestDto): Promise<ExportResult[]> {
    const where: Prisma.ScheduleWhereInput = {};
    
    if (dto.ids && dto.ids.length > 0) {
      where.id = { in: dto.ids };
    }

    const schedules = await this.prisma.schedule.findMany({
      where,
      include: {
        scheduleCats: {
          include: {
            cat: true,
          },
        },
      },
      orderBy: { scheduleDate: 'desc' },
    });

    return schedules.flatMap(schedule =>
      schedule.scheduleCats.map(scheduleCat => ({
        scheduleId: schedule.id,
        catName: scheduleCat.cat.name,
        careType: schedule.careType || '',
        scheduledDate: schedule.scheduleDate.toISOString().split('T')[0],
        completedDate: schedule.status === 'COMPLETED' ? schedule.updatedAt.toISOString().split('T')[0] : '',
        description: schedule.description || '',
        title: schedule.title || '',
      }))
    );
  }

  private async exportTags(): Promise<ExportResult[]> {
    const tags = await this.prisma.tag.findMany({
      include: {
        group: {
          include: {
            category: true,
          },
        },
      },
      orderBy: { name: 'asc' },
    });

    return tags.map(tag => ({
      id: tag.id,
      name: tag.name,
      color: tag.color,
      category: tag.group?.category?.name || '',
      group: tag.group?.name || '',
      isActive: tag.isActive,
      createdAt: tag.createdAt.toISOString(),
    }));
  }

  convertToCSV(data: ExportResult[]): string {
    if (data.length === 0) return '';

    const headers = Object.keys(data[0]);
    const rows = data.map(item => headers.map(h => {
      const value = item[h];
      // CSV ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—å‡¦ç†
      if (typeof value === 'string' && (value.includes(',') || value.includes('"') || value.includes('\n'))) {
        return `"${value.replace(/"/g, '""')}"`;
      }
      return value ?? '';
    }).join(','));

    return [headers.join(','), ...rows].join('\n');
  }
}
`````

## File: backend/src/import/dto/import-response.dto.ts
`````typescript
import { ApiProperty } from '@nestjs/swagger';

/**
 * ã‚¤ãƒ³ãƒãƒ¼ãƒˆçµæœDTO
 * 
 * ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆå®Œäº†å¾Œã«è¿”å´ã•ã‚Œã‚‹çµæœæƒ…å ±
 */
export class ImportResultDto {
  @ApiProperty({ description: 'ã‚¤ãƒ³ãƒãƒ¼ãƒˆæˆåŠŸä»¶æ•°' })
  successCount: number;

  @ApiProperty({ description: 'ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¤±æ•—ä»¶æ•°' })
  errorCount: number;

  @ApiProperty({ description: 'å‡¦ç†ç·ä»¶æ•°' })
  totalCount: number;

  @ApiProperty({ 
    description: 'ã‚¨ãƒ©ãƒ¼è©³ç´°ï¼ˆæœ€åˆã®10ä»¶ï¼‰', 
    type: [String], 
    required: false 
  })
  errors?: string[];
}

/**
 * ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨DTO
 * 
 * ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ™‚ã«ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã™ã‚‹ãŸã‚ã®æƒ…å ±
 */
export class ImportPreviewDto {
  @ApiProperty({ description: 'ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ‡ãƒ¼ã‚¿ä»¶æ•°' })
  previewCount: number;

  @ApiProperty({ 
    description: 'ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ï¼ˆæœ€åˆã®5ä»¶ï¼‰',
    type: 'array'
  })
  sampleData: Record<string, unknown>[];

  @ApiProperty({ description: 'æ¤œå‡ºã•ã‚ŒãŸã‚«ãƒ©ãƒ ' })
  columns: string[];

  @ApiProperty({ description: 'ãƒ‡ãƒ¼ã‚¿ç·ä»¶æ•°' })
  totalCount: number;
}
`````

## File: backend/src/import/import.controller.ts
`````typescript
import {
  Controller,
  Post,
  UseGuards,
  UseInterceptors,
  UploadedFile,
  BadRequestException,
  HttpStatus,
} from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { 
  ApiBearerAuth, 
  ApiOperation, 
  ApiResponse, 
  ApiTags, 
  ApiConsumes, 
  ApiBody 
} from '@nestjs/swagger';

import type { RequestUser } from '../auth/auth.types';
import { GetUser } from '../auth/get-user.decorator';
import { JwtAuthGuard } from '../auth/jwt-auth.guard';

import { ImportResultDto, ImportPreviewDto } from './dto/import-response.dto';
import { ImportService } from './import.service';

/**
 * ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã®å‹å®šç¾©
 */
interface UploadedFile {
  buffer: Buffer;
  originalname: string;
  size: number;
}

/**
 * ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©
 * 
 * CSV ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’æä¾›ã—ã¾ã™
 */
@ApiTags('Import')
@ApiBearerAuth()
@UseGuards(JwtAuthGuard)
@Controller('import')
export class ImportController {
  constructor(private readonly importService: ImportService) {}

  /**
   * ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å–å¾—
   * 
   * ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ã€ãƒ‡ãƒ¼ã‚¿ã®å†…å®¹ã‚’ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã—ã¾ã™
   */
  @Post('preview')
  @UseInterceptors(FileInterceptor('file'))
  @ApiOperation({ summary: 'ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼' })
  @ApiConsumes('multipart/form-data')
  @ApiBody({
    schema: {
      type: 'object',
      properties: {
        file: {
          type: 'string',
          format: 'binary',
          description: 'CSVãƒ•ã‚¡ã‚¤ãƒ«',
        },
      },
      required: ['file'],
    },
  })
  @ApiResponse({ 
    status: HttpStatus.OK, 
    description: 'ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å–å¾—æˆåŠŸ',
    type: ImportPreviewDto 
  })
  @ApiResponse({ 
    status: HttpStatus.BAD_REQUEST, 
    description: 'ãƒ•ã‚¡ã‚¤ãƒ«ãŒä¸æ­£ãªå½¢å¼' 
  })
  @ApiResponse({ 
    status: HttpStatus.UNAUTHORIZED, 
    description: 'èªè¨¼ãŒå¿…è¦' 
  })
  async preview(@UploadedFile() file: UploadedFile) {
    if (!file) {
      throw new BadRequestException('ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ã¾ã›ã‚“');
    }

    const result = await this.importService.previewFile(file);
    return {
      success: true,
      data: result,
    };
  }

  /**
   * çŒ«ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
   * 
   * CSV ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰çŒ«ãƒ‡ãƒ¼ã‚¿ã‚’ä¸€æ‹¬ç™»éŒ²ã—ã¾ã™
   */
  @Post('cats')
  @UseInterceptors(FileInterceptor('file'))
  @ApiOperation({ summary: 'çŒ«ãƒ‡ãƒ¼ã‚¿ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ' })
  @ApiConsumes('multipart/form-data')
  @ApiBody({
    schema: {
      type: 'object',
      properties: {
        file: {
          type: 'string',
          format: 'binary',
          description: 'CSVãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆã‚«ãƒ©ãƒ : name, gender, birthDate, breed, color, registrationNumber, microchipNumber, notesï¼‰',
        },
      },
      required: ['file'],
    },
  })
  @ApiResponse({ 
    status: HttpStatus.OK, 
    description: 'ã‚¤ãƒ³ãƒãƒ¼ãƒˆå®Œäº†',
    type: ImportResultDto 
  })
  @ApiResponse({ 
    status: HttpStatus.BAD_REQUEST, 
    description: 'ãƒ•ã‚¡ã‚¤ãƒ«ãŒä¸æ­£ãªå½¢å¼' 
  })
  @ApiResponse({ 
    status: HttpStatus.UNAUTHORIZED, 
    description: 'èªè¨¼ãŒå¿…è¦' 
  })
  async importCats(
    @UploadedFile() file: UploadedFile,
    @GetUser() user: RequestUser | undefined,
  ) {
    if (!file) {
      throw new BadRequestException('ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ã¾ã›ã‚“');
    }

    if (!user) {
      throw new BadRequestException('ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒå–å¾—ã§ãã¾ã›ã‚“');
    }

    const result = await this.importService.importCats(file, user.userId);
    return {
      success: true,
      data: result,
    };
  }

  /**
   * è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
   * 
   * CSV ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’ä¸€æ‹¬ç™»éŒ²ã—ã¾ã™
   */
  @Post('pedigrees')
  @UseInterceptors(FileInterceptor('file'))
  @ApiOperation({ summary: 'è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ' })
  @ApiConsumes('multipart/form-data')
  @ApiBody({
    schema: {
      type: 'object',
      properties: {
        file: {
          type: 'string',
          format: 'binary',
          description: 'CSVãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆã‚«ãƒ©ãƒ : pedigreeId, catName, title, breedCode, genderCode, coatColorCodeï¼‰',
        },
      },
      required: ['file'],
    },
  })
  @ApiResponse({ 
    status: HttpStatus.OK, 
    description: 'ã‚¤ãƒ³ãƒãƒ¼ãƒˆå®Œäº†',
    type: ImportResultDto 
  })
  @ApiResponse({ 
    status: HttpStatus.BAD_REQUEST, 
    description: 'ãƒ•ã‚¡ã‚¤ãƒ«ãŒä¸æ­£ãªå½¢å¼' 
  })
  @ApiResponse({ 
    status: HttpStatus.UNAUTHORIZED, 
    description: 'èªè¨¼ãŒå¿…è¦' 
  })
  async importPedigrees(@UploadedFile() file: UploadedFile) {
    if (!file) {
      throw new BadRequestException('ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ã¾ã›ã‚“');
    }

    const result = await this.importService.importPedigrees(file);
    return {
      success: true,
      data: result,
    };
  }

  /**
   * ã‚¿ã‚°ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
   * 
   * CSV ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚¿ã‚°ãƒ‡ãƒ¼ã‚¿ã‚’ä¸€æ‹¬ç™»éŒ²ã—ã¾ã™
   */
  @Post('tags')
  @UseInterceptors(FileInterceptor('file'))
  @ApiOperation({ summary: 'ã‚¿ã‚°ãƒ‡ãƒ¼ã‚¿ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ' })
  @ApiConsumes('multipart/form-data')
  @ApiBody({
    schema: {
      type: 'object',
      properties: {
        file: {
          type: 'string',
          format: 'binary',
          description: 'CSVãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆã‚«ãƒ©ãƒ : name, category, group, color, isActiveï¼‰',
        },
      },
      required: ['file'],
    },
  })
  @ApiResponse({ 
    status: HttpStatus.OK, 
    description: 'ã‚¤ãƒ³ãƒãƒ¼ãƒˆå®Œäº†',
    type: ImportResultDto 
  })
  @ApiResponse({ 
    status: HttpStatus.BAD_REQUEST, 
    description: 'ãƒ•ã‚¡ã‚¤ãƒ«ãŒä¸æ­£ãªå½¢å¼' 
  })
  @ApiResponse({ 
    status: HttpStatus.UNAUTHORIZED, 
    description: 'èªè¨¼ãŒå¿…è¦' 
  })
  async importTags(@UploadedFile() file: UploadedFile) {
    if (!file) {
      throw new BadRequestException('ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ã¾ã›ã‚“');
    }

    const result = await this.importService.importTags(file);
    return {
      success: true,
      data: result,
    };
  }
}
`````

## File: backend/src/import/import.module.ts
`````typescript
import { Module } from '@nestjs/common';

import { PrismaModule } from '../prisma/prisma.module';

import { ImportController } from './import.controller';
import { ImportService } from './import.service';

/**
 * ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
 * 
 * CSV ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™
 */
@Module({
  imports: [PrismaModule],
  controllers: [ImportController],
  providers: [ImportService],
  exports: [ImportService],
})
export class ImportModule {}
`````

## File: backend/src/import/import.service.ts
`````typescript
import { Injectable, BadRequestException, Logger } from '@nestjs/common';
import * as Papa from 'papaparse';

import { PrismaService } from '../prisma/prisma.service';

import { ImportResultDto, ImportPreviewDto } from './dto/import-response.dto';

/**
 * ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã®å‹å®šç¾©
 */
interface UploadedFile {
  buffer: Buffer;
  originalname: string;
  size: number;
}

/**
 * ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚µãƒ¼ãƒ“ã‚¹
 * 
 * CSV ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹æ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™
 */
@Injectable()
export class ImportService {
  private readonly logger = new Logger(ImportService.name);

  constructor(private readonly prisma: PrismaService) {}

  /**
   * ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’å–å¾—
   * 
   * @param file ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«
   * @returns ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æƒ…å ±
   */
  async previewFile(file: UploadedFile): Promise<ImportPreviewDto> {
    try {
      const content = file.buffer.toString('utf-8');
      const parsed = Papa.parse(content, { 
        header: true, 
        skipEmptyLines: true 
      });

      if (parsed.errors.length > 0) {
        this.logger.warn(`CSVè§£æã‚¨ãƒ©ãƒ¼: ${JSON.stringify(parsed.errors)}`);
        throw new BadRequestException('CSVãƒ•ã‚¡ã‚¤ãƒ«ã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸ');
      }

      const data = parsed.data as Record<string, unknown>[];

      return {
        previewCount: Math.min(data.length, 5),
        sampleData: data.slice(0, 5),
        columns: parsed.meta.fields || [],
        totalCount: data.length,
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼';
      this.logger.error(`ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å–å¾—ã‚¨ãƒ©ãƒ¼: ${errorMessage}`);
      throw error;
    }
  }

  /**
   * çŒ«ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
   * 
   * @param file ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸCSVãƒ•ã‚¡ã‚¤ãƒ«
   * @param _userId ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’å®Ÿè¡Œã™ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼ID
   * @returns ã‚¤ãƒ³ãƒãƒ¼ãƒˆçµæœ
   */
  async importCats(file: UploadedFile, _userId: string): Promise<ImportResultDto> {
    try {
      const content = file.buffer.toString('utf-8');
      const parsed = Papa.parse(content, { 
        header: true, 
        skipEmptyLines: true 
      });

      if (parsed.errors.length > 0) {
        throw new BadRequestException('CSVãƒ•ã‚¡ã‚¤ãƒ«ã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸ');
      }

      const data = parsed.data as Record<string, unknown>[];
      let successCount = 0;
      let errorCount = 0;
      const errors: string[] = [];

      for (let i = 0; i < data.length; i++) {
        try {
          const row = data[i];
          
          // å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ãƒã‚§ãƒƒã‚¯
          if (!row.name || !row.gender || !row.birthDate) {
            throw new Error('å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼ˆname, gender, birthDateï¼‰ãŒä¸è¶³ã—ã¦ã„ã¾ã™');
          }

          // Breed ã®æ¤œç´¢
          let breedId: string | null = null;
          if (row.breed && typeof row.breed === 'string') {
            const breed = await this.prisma.breed.findFirst({
              where: { name: row.breed },
            });
            breedId = breed?.id || null;
          }

          // CoatColor ã®æ¤œç´¢
          let colorId: string | null = null;
          if (row.color && typeof row.color === 'string') {
            const color = await this.prisma.coatColor.findFirst({
              where: { name: row.color },
            });
            colorId = color?.id || null;
          }

          // æ—¥ä»˜ã‚’ãƒ‘ãƒ¼ã‚¹
          const birthDate = new Date(String(row.birthDate));
          if (isNaN(birthDate.getTime())) {
            throw new Error('birthDate ãŒç„¡åŠ¹ãªå½¢å¼ã§ã™');
          }

          await this.prisma.cat.create({
            data: {
              name: String(row.name),
              registrationNumber: row.registrationNumber 
                ? String(row.registrationNumber)
                : `AUTO-${Date.now()}-${i}`,
              gender: String(row.gender),
              birthDate,
              breedId,
              coatColorId: colorId,
              microchipNumber: row.microchipNumber 
                ? String(row.microchipNumber)
                : null,
            },
          });

          successCount++;
        } catch (error) {
          errorCount++;
          const errorMessage = error instanceof Error ? error.message : 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼';
          errors.push(`è¡Œ${i + 2}: ${errorMessage}`);
        }
      }

      this.logger.log(`çŒ«ãƒ‡ãƒ¼ã‚¿ã‚¤ãƒ³ãƒãƒ¼ãƒˆå®Œäº†: æˆåŠŸ=${successCount}, å¤±æ•—=${errorCount}, ç·ä»¶æ•°=${data.length}`);

      return {
        successCount,
        errorCount,
        totalCount: data.length,
        errors: errors.slice(0, 10),
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼';
      this.logger.error(`çŒ«ãƒ‡ãƒ¼ã‚¿ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼: ${errorMessage}`);
      throw error;
    }
  }

  /**
   * è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
   * 
   * @param file ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸCSVãƒ•ã‚¡ã‚¤ãƒ«
   * @returns ã‚¤ãƒ³ãƒãƒ¼ãƒˆçµæœ
   */
  async importPedigrees(file: UploadedFile): Promise<ImportResultDto> {
    try {
      const content = file.buffer.toString('utf-8');
      const parsed = Papa.parse(content, { 
        header: true, 
        skipEmptyLines: true 
      });

      if (parsed.errors.length > 0) {
        throw new BadRequestException('CSVãƒ•ã‚¡ã‚¤ãƒ«ã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸ');
      }

      const data = parsed.data as Record<string, unknown>[];
      let successCount = 0;
      let errorCount = 0;
      const errors: string[] = [];

      for (let i = 0; i < data.length; i++) {
        try {
          const row = data[i];
          
          if (!row.pedigreeId || !row.catName) {
            throw new Error('å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼ˆpedigreeId, catNameï¼‰ãŒä¸è¶³ã—ã¦ã„ã¾ã™');
          }

          // é‡è¤‡ãƒã‚§ãƒƒã‚¯
          const existing = await this.prisma.pedigree.findUnique({
            where: { pedigreeId: String(row.pedigreeId) },
          });

          if (existing) {
            throw new Error('ã“ã®è¡€çµ±æ›¸IDã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™');
          }

          await this.prisma.pedigree.create({
            data: {
              pedigreeId: String(row.pedigreeId),
              catName: String(row.catName),
              title: row.title ? String(row.title) : null,
              breedCode: row.breedCode ? parseInt(String(row.breedCode), 10) : null,
              genderCode: row.genderCode ? parseInt(String(row.genderCode), 10) : null,
              coatColorCode: row.coatColorCode ? parseInt(String(row.coatColorCode), 10) : null,
            },
          });

          successCount++;
        } catch (error) {
          errorCount++;
          const errorMessage = error instanceof Error ? error.message : 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼';
          errors.push(`è¡Œ${i + 2}: ${errorMessage}`);
        }
      }

      this.logger.log(`è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚¤ãƒ³ãƒãƒ¼ãƒˆå®Œäº†: æˆåŠŸ=${successCount}, å¤±æ•—=${errorCount}, ç·ä»¶æ•°=${data.length}`);

      return {
        successCount,
        errorCount,
        totalCount: data.length,
        errors: errors.slice(0, 10),
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼';
      this.logger.error(`è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼: ${errorMessage}`);
      throw error;
    }
  }

  /**
   * ã‚¿ã‚°ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
   * 
   * @param file ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸCSVãƒ•ã‚¡ã‚¤ãƒ«
   * @returns ã‚¤ãƒ³ãƒãƒ¼ãƒˆçµæœ
   */
  async importTags(file: UploadedFile): Promise<ImportResultDto> {
    try {
      const content = file.buffer.toString('utf-8');
      const parsed = Papa.parse(content, { 
        header: true, 
        skipEmptyLines: true 
      });

      if (parsed.errors.length > 0) {
        throw new BadRequestException('CSVãƒ•ã‚¡ã‚¤ãƒ«ã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸ');
      }

      const data = parsed.data as Record<string, unknown>[];
      let successCount = 0;
      let errorCount = 0;
      const errors: string[] = [];

      for (let i = 0; i < data.length; i++) {
        try {
          const row = data[i];
          
          if (!row.name) {
            throw new Error('å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼ˆnameï¼‰ãŒä¸è¶³ã—ã¦ã„ã¾ã™');
          }

          // ã‚«ãƒ†ã‚´ãƒªã®å–å¾—ã¾ãŸã¯ä½œæˆ
          const categoryName = row.category ? String(row.category) : 'ãã®ä»–';
          let category = await this.prisma.tagCategory.findFirst({
            where: { name: categoryName },
          });

          if (!category) {
            category = await this.prisma.tagCategory.create({
              data: {
                name: categoryName,
                key: categoryName.toLowerCase().replace(/\s+/g, '_'),
              },
            });
          }

          // ã‚°ãƒ«ãƒ¼ãƒ—ã®å–å¾—ã¾ãŸã¯ä½œæˆ
          const groupName = row.group ? String(row.group) : 'ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ';
          let group = await this.prisma.tagGroup.findFirst({
            where: {
              name: groupName,
              categoryId: category.id,
            },
          });

          if (!group) {
            group = await this.prisma.tagGroup.create({
              data: {
                name: groupName,
                categoryId: category.id,
              },
            });
          }

          // ã‚¿ã‚°ã®ä½œæˆï¼ˆé‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼‰
          const existingTag = await this.prisma.tag.findFirst({
            where: {
              name: String(row.name),
              groupId: group.id,
            },
          });

          if (!existingTag) {
            await this.prisma.tag.create({
              data: {
                name: String(row.name),
                color: row.color ? String(row.color) : '#808080',
                groupId: group.id,
                isActive: row.isActive === 'false' ? false : true,
              },
            });
            successCount++;
          } else {
            errors.push(`è¡Œ${i + 2}: ã‚¿ã‚° "${row.name}" ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™ï¼ˆã‚¹ã‚­ãƒƒãƒ—ï¼‰`);
            errorCount++;
          }
        } catch (error) {
          errorCount++;
          const errorMessage = error instanceof Error ? error.message : 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼';
          errors.push(`è¡Œ${i + 2}: ${errorMessage}`);
        }
      }

      this.logger.log(`ã‚¿ã‚°ãƒ‡ãƒ¼ã‚¿ã‚¤ãƒ³ãƒãƒ¼ãƒˆå®Œäº†: æˆåŠŸ=${successCount}, å¤±æ•—=${errorCount}, ç·ä»¶æ•°=${data.length}`);

      return {
        successCount,
        errorCount,
        totalCount: data.length,
        errors: errors.slice(0, 10),
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼';
      this.logger.error(`ã‚¿ã‚°ãƒ‡ãƒ¼ã‚¿ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼: ${errorMessage}`);
      throw error;
    }
  }
}
`````

## File: backend/test/export.e2e-spec.ts
`````typescript
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import request from 'supertest';
import { AppModule } from '../src/app.module';
import { createTestApp } from './utils/create-test-app';

describe('Export API (e2e)', () => {
  let app: INestApplication;
  let authToken: string;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = await createTestApp(moduleRef);

    const email = `export_test_${Date.now()}@example.com`;
    const password = 'ExportTest123!';

    const res = await request(app.getHttpServer())
      .post('/api/v1/auth/register')
      .send({ email, password });
    expect(res.status).toBe(201);

    const loginRes = await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .send({ email, password });
    expect(loginRes.status).toBe(201);

    authToken = loginRes.body.data.access_token;
  });

  afterAll(async () => {
    await app.close();
  });

  describe('POST /api/v1/export', () => {
    it('should export cats data as CSV', async () => {
      const res = await request(app.getHttpServer())
        .post('/api/v1/export')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          dataType: 'cats',
          format: 'csv',
        })
        .expect(200);

      expect(res.headers['content-type']).toContain('text/csv');
      expect(res.headers['content-disposition']).toContain('attachment');
      expect(res.headers['content-disposition']).toContain('cats_export_');
    });

    it('should export pedigrees data as JSON', async () => {
      const res = await request(app.getHttpServer())
        .post('/api/v1/export')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          dataType: 'pedigrees',
          format: 'json',
        })
        .expect(200);

      expect(res.headers['content-type']).toContain('application/json');
      expect(res.headers['content-disposition']).toContain('attachment');
      expect(res.headers['content-disposition']).toContain('pedigrees_export_');
      
      const data = JSON.parse(res.text);
      expect(Array.isArray(data)).toBe(true);
    });

    it('should export care schedules data as CSV', async () => {
      const res = await request(app.getHttpServer())
        .post('/api/v1/export')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          dataType: 'care_schedules',
          format: 'csv',
        })
        .expect(200);

      expect(res.headers['content-type']).toContain('text/csv');
    });

    it('should export tags data as JSON', async () => {
      const res = await request(app.getHttpServer())
        .post('/api/v1/export')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          dataType: 'tags',
          format: 'json',
        })
        .expect(200);

      expect(res.headers['content-type']).toContain('application/json');
      const data = JSON.parse(res.text);
      expect(Array.isArray(data)).toBe(true);
    });

    it('should reject export without authentication', async () => {
      const res = await request(app.getHttpServer())
        .post('/api/v1/export')
        .send({
          dataType: 'cats',
          format: 'csv',
        })
        .expect(401);

      expect(res.body.success).toBe(false);
      expect(res.body.error.code).toBe('UNAUTHORIZED');
    });

    it('should reject invalid data type', async () => {
      await request(app.getHttpServer())
        .post('/api/v1/export')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          dataType: 'invalid_type',
          format: 'csv',
        })
        .expect(400);
    });

    it('should export with date filters', async () => {
      const startDate = new Date('2024-01-01').toISOString();
      const endDate = new Date('2024-12-31').toISOString();

      const res = await request(app.getHttpServer())
        .post('/api/v1/export')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          dataType: 'cats',
          format: 'csv',
          startDate,
          endDate,
        })
        .expect(200);

      expect(res.headers['content-type']).toContain('text/csv');
    });
  });
});
`````

## File: backend/test/import.e2e-spec.ts
`````typescript
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import request from 'supertest';
import * as path from 'path';
import * as fs from 'fs';

import { AppModule } from '../src/app.module';
import { createTestApp } from './utils/create-test-app';

describe('Import API (e2e)', () => {
  let app: INestApplication;
  let authToken: string;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = await createTestApp(moduleRef);

    const email = `import_test_${Date.now()}@example.com`;
    const password = 'ImportTest123!';

    const res = await request(app.getHttpServer())
      .post('/api/v1/auth/register')
      .send({ email, password });
    expect(res.status).toBe(201);

    const loginRes = await request(app.getHttpServer())
      .post('/api/v1/auth/login')
      .send({ email, password });
    expect(loginRes.status).toBe(201);

    authToken = loginRes.body.data.access_token;
  });

  afterAll(async () => {
    await app.close();
  });

  describe('POST /api/v1/import/preview', () => {
    it('ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼: CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ­£å¸¸ã«è§£æ', async () => {
      const csvContent = `name,gender,birthDate,breed,color
ãƒ†ã‚¹ãƒˆçŒ«1,MALE,2024-01-01,Siamese,White
ãƒ†ã‚¹ãƒˆçŒ«2,FEMALE,2024-01-02,Persian,Black`;

      const tempFilePath = path.join(__dirname, `temp-preview-${Date.now()}.csv`);
      fs.writeFileSync(tempFilePath, csvContent, 'utf-8');

      const res = await request(app.getHttpServer())
        .post('/api/v1/import/preview')
        .set('Authorization', `Bearer ${authToken}`)
        .attach('file', tempFilePath)
        .expect(201);

      expect(res.body.success).toBe(true);
      expect(res.body.data).toHaveProperty('previewCount');
      expect(res.body.data).toHaveProperty('sampleData');
      expect(res.body.data).toHaveProperty('columns');
      expect(res.body.data).toHaveProperty('totalCount');
      expect(res.body.data.totalCount).toBe(2);
      expect(res.body.data.columns).toEqual(
        expect.arrayContaining(['name', 'gender', 'birthDate'])
      );

      fs.unlinkSync(tempFilePath);
    });

    it('ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼: ãƒ•ã‚¡ã‚¤ãƒ«ãªã—ã§ã‚¨ãƒ©ãƒ¼', async () => {
      const res = await request(app.getHttpServer())
        .post('/api/v1/import/preview')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(400);

      expect(res.body.success).toBe(false);
    });

    it('ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼: èªè¨¼ãªã—ã§ã‚¨ãƒ©ãƒ¼', async () => {
      const csvContent = `name,gender,birthDate
ãƒ†ã‚¹ãƒˆçŒ«,MALE,2024-01-01`;

      const tempFilePath = path.join(__dirname, `temp-no-auth-${Date.now()}.csv`);
      fs.writeFileSync(tempFilePath, csvContent, 'utf-8');

      const res = await request(app.getHttpServer())
        .post('/api/v1/import/preview')
        .attach('file', tempFilePath)
        .expect(401);

      expect(res.body.success).toBe(false);

      fs.unlinkSync(tempFilePath);
    });
  });

  describe('POST /api/v1/import/cats', () => {
    it('çŒ«ã‚¤ãƒ³ãƒãƒ¼ãƒˆ: CSVãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰æ­£å¸¸ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆ', async () => {
      const csvContent = `name,gender,birthDate,registrationNumber
ã‚¤ãƒ³ãƒãƒ¼ãƒˆçŒ«1,MALE,2024-01-01,REG-IMP-001
ã‚¤ãƒ³ãƒãƒ¼ãƒˆçŒ«2,FEMALE,2024-01-02,REG-IMP-002`;

      const tempFilePath = path.join(__dirname, `temp-cats-${Date.now()}.csv`);
      fs.writeFileSync(tempFilePath, csvContent, 'utf-8');

      const res = await request(app.getHttpServer())
        .post('/api/v1/import/cats')
        .set('Authorization', `Bearer ${authToken}`)
        .attach('file', tempFilePath)
        .expect(201);

      expect(res.body.success).toBe(true);
      expect(res.body.data).toHaveProperty('successCount');
      expect(res.body.data).toHaveProperty('errorCount');
      expect(res.body.data).toHaveProperty('totalCount');
      expect(res.body.data.totalCount).toBe(2);
      expect(res.body.data.successCount).toBeGreaterThan(0);

      fs.unlinkSync(tempFilePath);
    });

    it('çŒ«ã‚¤ãƒ³ãƒãƒ¼ãƒˆ: å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ä¸è¶³ã§ã‚¨ãƒ©ãƒ¼', async () => {
      const csvContent = `name,gender,birthDate
æœ‰åŠ¹ãªçŒ«,MALE,2024-01-01
,FEMALE,2024-01-02
åˆ¥ã®çŒ«,MALE,2024-01-03`;

      const tempFilePath = path.join(
        __dirname,
        `temp-cats-partial-${Date.now()}.csv`
      );
      fs.writeFileSync(tempFilePath, csvContent, 'utf-8');

      const res = await request(app.getHttpServer())
        .post('/api/v1/import/cats')
        .set('Authorization', `Bearer ${authToken}`)
        .attach('file', tempFilePath)
        .expect(201);

      expect(res.body.success).toBe(true);
      expect(res.body.data.totalCount).toBe(3);
      expect(res.body.data.errorCount).toBeGreaterThan(0);
      expect(res.body.data.successCount).toBeGreaterThan(0);
      expect(res.body.data.errors).toBeDefined();

      fs.unlinkSync(tempFilePath);
    });

    it('çŒ«ã‚¤ãƒ³ãƒãƒ¼ãƒˆ: ãƒ•ã‚¡ã‚¤ãƒ«ãªã—ã§ã‚¨ãƒ©ãƒ¼', async () => {
      const res = await request(app.getHttpServer())
        .post('/api/v1/import/cats')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(400);

      expect(res.body.success).toBe(false);
    });
  });

  describe('POST /api/v1/import/pedigrees', () => {
    it('è¡€çµ±æ›¸ã‚¤ãƒ³ãƒãƒ¼ãƒˆ: CSVãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰æ­£å¸¸ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆ', async () => {
      const csvContent = `pedigreeId,catName,title
PED-001,è¡€çµ±çŒ«1,Champion
PED-002,è¡€çµ±çŒ«2,Grand Champion`;

      const tempFilePath = path.join(
        __dirname,
        `temp-pedigrees-${Date.now()}.csv`
      );
      fs.writeFileSync(tempFilePath, csvContent, 'utf-8');

      const res = await request(app.getHttpServer())
        .post('/api/v1/import/pedigrees')
        .set('Authorization', `Bearer ${authToken}`)
        .attach('file', tempFilePath)
        .expect(201);

      expect(res.body.success).toBe(true);
      expect(res.body.data.totalCount).toBe(2);
      expect(res.body.data.successCount).toBeGreaterThan(0);

      fs.unlinkSync(tempFilePath);
    });

    it('è¡€çµ±æ›¸ã‚¤ãƒ³ãƒãƒ¼ãƒˆ: é‡è¤‡IDã§ã‚¹ã‚­ãƒƒãƒ—', async () => {
      const pedigreeId = `PED-DUP-${Date.now()}`;
      const csvContent = `pedigreeId,catName,title
${pedigreeId},è¡€çµ±çŒ«1,Champion
${pedigreeId},è¡€çµ±çŒ«2,Grand Champion`;

      const tempFilePath = path.join(
        __dirname,
        `temp-pedigrees-dup-${Date.now()}.csv`
      );
      fs.writeFileSync(tempFilePath, csvContent, 'utf-8');

      const res = await request(app.getHttpServer())
        .post('/api/v1/import/pedigrees')
        .set('Authorization', `Bearer ${authToken}`)
        .attach('file', tempFilePath)
        .expect(201);

      expect(res.body.success).toBe(true);
      expect(res.body.data.totalCount).toBe(2);
      expect(res.body.data.errorCount).toBeGreaterThanOrEqual(1);

      fs.unlinkSync(tempFilePath);
    });
  });

  describe('POST /api/v1/import/tags', () => {
    it('ã‚¿ã‚°ã‚¤ãƒ³ãƒãƒ¼ãƒˆ: CSVãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰æ­£å¸¸ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆ', async () => {
      const csvContent = `name,category,group,color,isActive
ã‚¿ã‚°1,ãƒ†ã‚¹ãƒˆã‚«ãƒ†ã‚´ãƒª,ãƒ†ã‚¹ãƒˆã‚°ãƒ«ãƒ¼ãƒ—,#FF0000,true
ã‚¿ã‚°2,ãƒ†ã‚¹ãƒˆã‚«ãƒ†ã‚´ãƒª,ãƒ†ã‚¹ãƒˆã‚°ãƒ«ãƒ¼ãƒ—,#00FF00,true`;

      const tempFilePath = path.join(__dirname, `temp-tags-${Date.now()}.csv`);
      fs.writeFileSync(tempFilePath, csvContent, 'utf-8');

      const res = await request(app.getHttpServer())
        .post('/api/v1/import/tags')
        .set('Authorization', `Bearer ${authToken}`)
        .attach('file', tempFilePath)
        .expect(201);

      expect(res.body.success).toBe(true);
      expect(res.body.data.totalCount).toBe(2);
      expect(res.body.data.successCount).toBeGreaterThan(0);

      fs.unlinkSync(tempFilePath);
    });

    it('ã‚¿ã‚°ã‚¤ãƒ³ãƒãƒ¼ãƒˆ: é‡è¤‡ã‚¿ã‚°ã¯ã‚¹ã‚­ãƒƒãƒ—', async () => {
      const timestamp = Date.now();
      const csvContent = `name,category,group,color,isActive
ã‚¿ã‚°-${timestamp},ãƒ†ã‚¹ãƒˆã‚«ãƒ†ã‚´ãƒª,ãƒ†ã‚¹ãƒˆã‚°ãƒ«ãƒ¼ãƒ—,#FF0000,true
ã‚¿ã‚°-${timestamp},ãƒ†ã‚¹ãƒˆã‚«ãƒ†ã‚´ãƒª,ãƒ†ã‚¹ãƒˆã‚°ãƒ«ãƒ¼ãƒ—,#00FF00,true`;

      const tempFilePath = path.join(
        __dirname,
        `temp-tags-dup-${timestamp}.csv`
      );
      fs.writeFileSync(tempFilePath, csvContent, 'utf-8');

      const res = await request(app.getHttpServer())
        .post('/api/v1/import/tags')
        .set('Authorization', `Bearer ${authToken}`)
        .attach('file', tempFilePath)
        .expect(201);

      expect(res.body.success).toBe(true);
      expect(res.body.data.totalCount).toBe(2);
      expect(res.body.data.errorCount).toBeGreaterThanOrEqual(1);
      expect(res.body.data.successCount).toBeGreaterThan(0);

      fs.unlinkSync(tempFilePath);
    });

    it('ã‚¿ã‚°ã‚¤ãƒ³ãƒãƒ¼ãƒˆ: ãƒ•ã‚¡ã‚¤ãƒ«ãªã—ã§ã‚¨ãƒ©ãƒ¼', async () => {
      const res = await request(app.getHttpServer())
        .post('/api/v1/import/tags')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(400);

      expect(res.body.success).toBe(false);
    });
  });

  describe('èªè¨¼ãƒ†ã‚¹ãƒˆ', () => {
    it('èªè¨¼ãªã—ã§ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã«ã‚¢ã‚¯ã‚»ã‚¹ä¸å¯', async () => {
      const csvContent = `name,gender,birthDate
ãƒ†ã‚¹ãƒˆçŒ«,MALE,2024-01-01`;

      const tempFilePath = path.join(
        __dirname,
        `temp-unauth-${Date.now()}.csv`
      );
      fs.writeFileSync(tempFilePath, csvContent, 'utf-8');

      const res = await request(app.getHttpServer())
        .post('/api/v1/import/preview')
        .attach('file', tempFilePath)
        .expect(401);

      expect(res.body.success).toBe(false);
      expect(res.body.error.code).toBe('UNAUTHORIZED');

      fs.unlinkSync(tempFilePath);
    });

    it('ä¸æ­£ãªãƒˆãƒ¼ã‚¯ãƒ³ã§ã‚¨ãƒ©ãƒ¼', async () => {
      const csvContent = `name,gender,birthDate
ãƒ†ã‚¹ãƒˆçŒ«,MALE,2024-01-01`;

      const tempFilePath = path.join(
        __dirname,
        `temp-bad-token-${Date.now()}.csv`
      );
      fs.writeFileSync(tempFilePath, csvContent, 'utf-8');

      const res = await request(app.getHttpServer())
        .post('/api/v1/import/preview')
        .set('Authorization', `Bearer invalid-token`)
        .attach('file', tempFilePath)
        .expect(401);

      expect(res.body.success).toBe(false);

      fs.unlinkSync(tempFilePath);
    });
  });
});
`````

## File: Dockerfile.frontend
`````
# ---- Base Stage ----
FROM node:20-alpine AS base
WORKDIR /app
RUN npm install -g pnpm@10.18.1

# ---- Development Stage ----
FROM base AS development
# é–‹ç™ºãƒ¢ãƒ¼ãƒ‰: Next.js Fast Refresh å¯¾å¿œ
# ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã¯ãƒœãƒªãƒ¥ãƒ¼ãƒ ãƒã‚¦ãƒ³ãƒˆã•ã‚Œã‚‹ãŸã‚ã€COPY ã¯æœ€å°é™ã«ã¨ã©ã‚ã‚‹
COPY package.json pnpm-lock.yaml pnpm-workspace.yaml ./
COPY backend/package.json ./backend/
COPY frontend/package.json ./frontend/

# é–‹ç™ºä¾å­˜é–¢ä¿‚ã‚’å«ã‚€å…¨ä¾å­˜é–¢ä¿‚ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
RUN pnpm install --frozen-lockfile --filter frontend...

# .next ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¯ãƒœãƒªãƒ¥ãƒ¼ãƒ ãƒã‚¦ãƒ³ãƒˆã§ç®¡ç†ã•ã‚Œã‚‹
# ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã¯ãƒœãƒªãƒ¥ãƒ¼ãƒ ãƒã‚¦ãƒ³ãƒˆã§æä¾›ã•ã‚Œã‚‹
WORKDIR /app
ENV NEXT_TELEMETRY_DISABLED=1
CMD ["pnpm", "--filter", "frontend", "run", "dev"]

# ---- Build Stage ----
FROM base AS build
COPY package.json pnpm-lock.yaml pnpm-workspace.yaml ./
COPY backend/package.json ./backend/
COPY frontend/package.json ./frontend/

# Install dependencies including devDependencies for building
RUN pnpm install --frozen-lockfile --filter frontend...

COPY frontend ./frontend
WORKDIR /app/frontend
RUN mkdir -p public
# Set NEXT_PUBLIC_API_URL during build time if needed, or rely on runtime env
ARG NEXT_PUBLIC_API_URL
ENV NEXT_PUBLIC_API_URL=${NEXT_PUBLIC_API_URL}
RUN pnpm build

# ---- Production Stage ----
FROM node:20-alpine AS production
WORKDIR /app
ENV NODE_ENV=production
ENV PORT=8080
ENV NEXT_TELEMETRY_DISABLED=1

RUN npm install -g pnpm@10.18.1 && \
    addgroup -S nodejs && adduser -S nodeapp -G nodejs

# Copy workspace config and package files for production install
COPY package.json pnpm-lock.yaml pnpm-workspace.yaml ./
COPY backend/package.json ./backend/
COPY frontend/package.json ./frontend/

# Install ONLY production dependencies directly
RUN pnpm install --frozen-lockfile --prod --filter frontend...

# Copy build artifacts
COPY --from=build /app/frontend/.next ./frontend/.next
COPY --from=build /app/frontend/public ./frontend/public
COPY --from=build /app/frontend/package.json ./frontend/package.json

# Set working directory to frontend where the app runs
WORKDIR /app/frontend

RUN chown -R nodeapp:nodejs /app

USER nodeapp

EXPOSE 8080
CMD ["pnpm", "start"]
`````

## File: backend/src/main.ts
`````typescript
import { existsSync, statSync } from 'fs';
import { resolve } from 'path';

import { ValidationPipe, Logger } from "@nestjs/common";
import { NestFactory } from "@nestjs/core";
import { SwaggerModule, DocumentBuilder } from "@nestjs/swagger";
import * as Sentry from '@sentry/node';
import { nodeProfilingIntegration } from '@sentry/profiling-node';
import cookieParser from 'cookie-parser';
import { config as loadEnv } from 'dotenv';
import { json, urlencoded, Request, Response, NextFunction } from 'express';
import helmet from 'helmet';
import { Logger as PinoLogger } from 'nestjs-pino';


import { AppModule } from "./app.module";
import { validateProductionEnvironment, logEnvironmentInfo } from "./common/config/env.validation";
import { EnhancedGlobalExceptionFilter } from "./common/filters/enhanced-global-exception.filter";
import { PerformanceMonitoringInterceptor } from "./common/interceptors/performance-monitoring.interceptor";
import { TransformResponseInterceptor } from "./common/interceptors/transform-response.interceptor";

const candidateEnvFiles: Array<{ file: string; override: boolean }> = [
  { file: resolve(__dirname, "..", ".env"), override: false },
  { file: resolve(__dirname, "..", ".env.example"), override: false },
  { file: resolve(__dirname, "..", ".env.local"), override: true },
];

for (const candidate of candidateEnvFiles) {
  if (existsSync(candidate.file) && statSync(candidate.file).size > 0) {
    loadEnv({ path: candidate.file, override: candidate.override });
  }
}

async function bootstrap() {
  const logger = new Logger("Bootstrap");

  try {
    // Starting the application server
    logger.log("Starting Cat Management System API...");

    // Validate environment configuration
    const isProdLikeEnv = process.env.NODE_ENV === "production" || process.env.NODE_ENV === "staging";

    if (isProdLikeEnv) {
      validateProductionEnvironment();
      logger.log(`âœ… ${process.env.NODE_ENV} environment validation passed`);
    }
    
    logEnvironmentInfo();

    const app = await NestFactory.create(AppModule, {
      bufferLogs: true,
      cors: {
        origin: (origin: string | undefined, callback: (err: Error | null, allow?: boolean) => void) => {
          const allowedOrigins =
            (process.env.NODE_ENV === 'production' || process.env.NODE_ENV === 'staging')
              ? (process.env.CORS_ORIGIN || '').split(',').map((o: string) => o.trim()).filter(Boolean)
              : [
                  'http://localhost:3000',
                  'http://localhost:3002',
                  'http://localhost:3003',
                  'http://localhost:3005',
                ];

          if ((process.env.NODE_ENV === 'production' || process.env.NODE_ENV === 'staging') && (!process.env.CORS_ORIGIN || allowedOrigins.length === 0)) {
            return callback(new Error('CORS_ORIGIN is not set in production environment.'), false);
          }

          const isAllowed = allowedOrigins.some((allowedOrigin) => {
            if (typeof allowedOrigin === 'string') {
              return allowedOrigin === origin;
            }
            return false;
          });

          if (isAllowed || !origin) {
            callback(null, true);
          } else {
            callback(new Error('Not allowed by CORS'), false);
          }
        },
        credentials: true,
        methods: ['GET', 'HEAD', 'PUT', 'PATCH', 'POST', 'DELETE', 'OPTIONS'],
        allowedHeaders: ['Origin', 'X-Requested-With', 'Content-Type', 'Accept', 'Authorization', 'Cookie'],
        exposedHeaders: ['Content-Length', 'Content-Type', 'Set-Cookie'],
        preflightContinue: false,
        optionsSuccessStatus: 204,
      },
    });

  // Body parser limit ã‚’æ‹¡å¼µï¼ˆBase64ç”»åƒå¯¾å¿œï¼šæœ€å¤§50MBï¼‰
  app.use(json({ limit: '50mb' }));
  app.use(urlencoded({ extended: true, limit: '50mb' }));

  // Pino logger
  app.useLogger(app.get(PinoLogger));

    // Security: Helmet middleware for security headers
  app.use(
    helmet({
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          styleSrc: ["'self'", "'unsafe-inline'"],
          scriptSrc: ["'self'"],
          imgSrc: ["'self'", "data:", "https:"],
          connectSrc: ["'self'"],
          fontSrc: ["'self'"],
          objectSrc: ["'none'"],
          mediaSrc: ["'self'"],
          frameSrc: ["'none'"],
        },
      },
      hsts: {
        maxAge: 31536000, // 1 year in seconds
        includeSubDomains: true,
        preload: true,
      },
      referrerPolicy: {
        policy: 'strict-origin-when-cross-origin',
      },
      noSniff: true,
      xssFilter: true,
    }),
  );

  // Sentry (æ¡ä»¶ä»˜ã)
  if (process.env.SENTRY_DSN) {
    Sentry.init({
      dsn: process.env.SENTRY_DSN,
      environment: process.env.NODE_ENV || 'development',
      tracesSampleRate: Number(process.env.SENTRY_TRACES_SAMPLE_RATE || 0.1),
      profilesSampleRate: Number(process.env.SENTRY_PROFILES_SAMPLE_RATE || 0.1),
      integrations: [nodeProfilingIntegration()],
      beforeSend(event) {
        // Redact sensitive headers before sending to Sentry
        if (event.request?.headers) {
          const headers = event.request.headers as Record<string, string>;
          if (headers.authorization) {
            headers.authorization = '[REDACTED]';
          }
          if (headers.cookie) {
            headers.cookie = '[REDACTED]';
          }
          if (headers.Authorization) {
            headers.Authorization = '[REDACTED]';
          }
          if (headers.Cookie) {
            headers.Cookie = '[REDACTED]';
          }
        }
        return event;
      },
    });
    logger.log('Sentry initialized with security redaction');
  }

  // Cookie parser (for refresh token, etc.)
  app.use(cookieParser());

  // Debug middleware for pregnancy-checks (development only)
  if (process.env.NODE_ENV !== 'production') {
    app.use('/api/v1/breeding/pregnancy-checks', (req: Request, res: Response, next: NextFunction) => {
      if (req.method === 'POST') {
        const body = req.body as Record<string, unknown>;
        console.log('[DEBUG MIDDLEWARE] Raw request body:', JSON.stringify(body, null, 2));
        console.log('[DEBUG MIDDLEWARE] motherId type:', typeof body?.motherId, 'value:', body?.motherId);
        console.log('[DEBUG MIDDLEWARE] fatherId type:', typeof body?.fatherId, 'value:', body?.fatherId);
      }
      next();
    });
  }

    // Global validation pipe
    app.useGlobalPipes(
      new ValidationPipe({
        whitelist: true,
        forbidNonWhitelisted: true,
        transform: true,
      }),
    );    // Global response interceptor
    app.useGlobalInterceptors(new TransformResponseInterceptor());

    // Performance monitoring interceptor
    app.useGlobalInterceptors(new PerformanceMonitoringInterceptor());

    // Global exception filter (enhanced version)
    app.useGlobalFilters(new EnhancedGlobalExceptionFilter());

    // API prefix
    app.setGlobalPrefix("api/v1");

    // Root endpoint
    app.getHttpAdapter().get("/", (req: unknown, res: { json: (data: unknown) => void }) => {
      res.json({
        success: true,
        data: {
          message: "ğŸ± Cat Management System API",
          version: "1.0.0",
          documentation: "/api/docs",
          health: "/health",
          timestamp: new Date().toISOString(),
          endpoints: {
            cats: "/api/v1/cats",
            pedigrees: "/api/v1/pedigrees",
            breeds: "/api/v1/breeds",
            coatColors: "/api/v1/coat-colors",
          },
        },
      });
    });

    // Enhanced health check endpoint
    app.getHttpAdapter().get("/health", async (req: unknown, res: { status: (code: number) => { json: (data: unknown) => void } }) => {
      const health: {
        success: boolean;
        data: {
          status: string;
          timestamp: string;
          service: string;
          version: string;
          environment?: string;
          uptime: number;
          memory: {
            used: number;
            total: number;
          };
          database?: string;
          error?: string;
        };
      } = {
        success: true,
        data: {
          status: "ok",
          timestamp: new Date().toISOString(),
          service: "Cat Management System API",
          version: "1.0.0",
          environment: process.env.NODE_ENV,
          uptime: process.uptime(),
          memory: {
            used: Math.round((process.memoryUsage().heapUsed / 1024 / 1024) * 100) / 100,
            total: Math.round((process.memoryUsage().heapTotal / 1024 / 1024) * 100) / 100,
          },
        },
      };

      try {
        // Database health check (if enabled)
        if (process.env.HEALTH_CHECK_DATABASE === "true") {
          const { PrismaClient } = await import("@prisma/client");
          const prisma = new PrismaClient();
          await prisma.$queryRaw`SELECT 1`;
          await prisma.$disconnect();
          health.data.database = "ok";
        }
      } catch (error) {
        health.success = false;
        health.data.status = "error";
        health.data.database = "error";
        health.data.error = error instanceof Error ? error.message : "Unknown error";
      }

      res.status(health.success ? 200 : 503).json(health);
    });    // Swagger documentation
    if (process.env.NODE_ENV !== "production") {
      const config = new DocumentBuilder()
        .setTitle("Cat Management System API")
        .setDescription("API for managing cat breeding and care records")
        .setVersion("1.0")
        .addBearerAuth()
        .build();

      const document = SwaggerModule.createDocument(app, config);
      SwaggerModule.setup("api/docs", app, document);
    }

  if (!process.env.PORT && process.env.NODE_ENV === 'production') {
    throw new Error('PORT environment variable is not set in production environment.');
  }
  const port = process.env.PORT || 3004;
  await app.listen(port, '0.0.0.0');

    // Graceful shutdown
    const gracefulShutdown = (signal: string) => {
      logger.log(`ğŸš¨ Received ${signal}. Starting graceful shutdown...`);
      app.close().then(() => {
        logger.log("âœ… Application closed successfully");
        process.exit(0);
      }).catch((error) => {
        logger.error("âŒ Error during shutdown:", error);
        process.exit(1);
      });
    };

    process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
    process.on('SIGINT', () => gracefulShutdown('SIGINT'));

    logger.log(`ğŸš€ Application is running on: http://localhost:${port}`);
    logger.log(`ğŸ“š API Documentation: http://localhost:${port}/api/docs`);
    logger.log(`â¤ï¸  Health Check: http://localhost:${port}/health`);
  } catch (error) {
    logger.error("Failed to start application:", error);
    process.exit(1);
  }
}

bootstrap().catch((error) => {
  const logger = new Logger("Bootstrap");
  logger.error("Unhandled error during bootstrap:", error);
  process.exit(1);
});
`````

## File: backend/test/jest-e2e.json
`````json
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": "..",
  "testRegex": ".*\\.e2e-spec\\.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  },
  "collectCoverageFrom": [
    "src/**/*.(t|j)s",
    "!src/scripts/**",
    "!src/**/*.spec.ts"
  ],
  "coverageDirectory": "../coverage-e2e",
  "testEnvironment": "node",
  "maxWorkers": 1,
  "setupFiles": ["<rootDir>/test/setup-e2e.ts"]
}
`````

## File: Dockerfile.backend
`````
# ---- Base Stage ----
FROM node:20-alpine3.22 AS base
WORKDIR /app
RUN npm install -g pnpm@10.18.1

# ---- Development Stage ----
FROM base AS development
# é–‹ç™ºãƒ¢ãƒ¼ãƒ‰: ãƒ›ãƒƒãƒˆãƒªãƒ­ãƒ¼ãƒ‰å¯¾å¿œ
# ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã¯ãƒœãƒªãƒ¥ãƒ¼ãƒ ãƒã‚¦ãƒ³ãƒˆã•ã‚Œã‚‹ãŸã‚ã€COPY ã¯æœ€å°é™ã«ã¨ã©ã‚ã‚‹
COPY package.json pnpm-lock.yaml pnpm-workspace.yaml ./
COPY backend/package.json ./backend/
# pnpm workspace ã®ä¾å­˜é–¢ä¿‚è§£æ±ºã«å¿…è¦ï¼ˆfrontend ã¸ã®å‚ç…§ãŒã‚ã‚‹å ´åˆã«å‚™ãˆã‚‹ï¼‰
COPY frontend/package.json ./frontend/
COPY backend/prisma ./backend/prisma

# é–‹ç™ºä¾å­˜é–¢ä¿‚ã‚’å«ã‚€å…¨ä¾å­˜é–¢ä¿‚ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
RUN pnpm install --frozen-lockfile --filter backend...

# Prisma ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’ç”Ÿæˆ
# NOTE:
# - ã“ã®ã‚³ãƒãƒ³ãƒ‰ã¯ãƒ“ãƒ«ãƒ‰æ™‚ç‚¹ã® Prisma ã‚¹ã‚­ãƒ¼ãƒã‚’å…ƒã«ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’ç”Ÿæˆã—ã¾ã™
# - é–‹ç™ºã‚³ãƒ³ãƒ†ãƒŠèµ·å‹•å¾Œã«ãƒ›ã‚¹ãƒˆå´ã§ backend/prisma/schema.prisma ã‚’å¤‰æ›´ã—ãŸå ´åˆã€
#   ç”Ÿæˆæ¸ˆã¿ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒã‚¹ã‚­ãƒ¼ãƒã¨ä¸æ•´åˆã«ãªã‚‹ç‚¹ã«æ³¨æ„ã—ã¦ãã ã•ã„
# - ãã®å ´åˆã¯ã€ä»¥ä¸‹ã®ã„ãšã‚Œã‹ã®æ–¹æ³•ã§ Prisma ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’å†ç”Ÿæˆã—ã¦ãã ã•ã„
#   1. `pnpm run docker:dev:build` ã§é–‹ç™ºç”¨ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’å†ãƒ“ãƒ«ãƒ‰ã™ã‚‹
#   2. `docker exec -it mycats_dev_backend pnpm --filter backend run prisma:generate` ã‚’å®Ÿè¡Œã™ã‚‹
WORKDIR /app/backend
RUN pnpm prisma generate

# ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã¯ãƒœãƒªãƒ¥ãƒ¼ãƒ ãƒã‚¦ãƒ³ãƒˆã§æä¾›ã•ã‚Œã‚‹
# ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚³ãƒãƒ³ãƒ‰ã¯ docker-compose.dev.yml ã§æŒ‡å®š
WORKDIR /app
CMD ["pnpm", "--filter", "backend", "run", "start:dev"]

# ---- Build Stage ----
FROM base AS build
COPY package.json pnpm-lock.yaml pnpm-workspace.yaml ./
COPY backend/package.json ./backend/
COPY frontend/package.json ./frontend/
COPY backend/prisma ./backend/prisma

# Install dependencies including devDependencies for building
# Using --filter backend... to install backend dependencies and workspace root dependencies
RUN pnpm install --frozen-lockfile --filter backend...

COPY backend ./backend
WORKDIR /app/backend
RUN pnpm prisma generate
RUN pnpm build

# ---- Production Stage ----
FROM node:20-alpine3.22 AS production
WORKDIR /app

# Run backend container with restricted privileges and production-friendly defaults
ENV NODE_ENV=production
ENV PORT=8080

# Install required dependencies for Prisma on Alpine and pnpm, create user
# hadolint ignore=DL3018
RUN apk add --no-cache openssl libc6-compat && \
    npm install -g pnpm@10.18.1 && \
    addgroup -S nodejs && adduser -S nodeapp -G nodejs

# Copy workspace config and package files for production install
COPY package.json pnpm-lock.yaml pnpm-workspace.yaml ./
COPY backend/package.json ./backend/
COPY frontend/package.json ./frontend/
COPY backend/prisma ./backend/prisma

# Install ONLY production dependencies directly in the production stage
# This ensures no broken symlinks from copying node_modules and keeps image small
RUN pnpm install --frozen-lockfile --prod --filter backend...

# Copy build artifacts from build stage
COPY --from=build /app/backend/dist ./backend/dist
COPY --from=build /app/backend/prisma ./backend/prisma

# Generate Prisma Client for production environment
WORKDIR /app/backend
RUN pnpm prisma generate

# Copy entrypoint script
COPY backend/docker-entrypoint.sh ./
RUN chmod +x docker-entrypoint.sh && chown -R nodeapp:nodejs /app

USER nodeapp

EXPOSE 8080
CMD ["./docker-entrypoint.sh"]
`````

## File: backend/src/app.module.ts
`````typescript
import { Module, MiddlewareConsumer, NestModule } from "@nestjs/common";
import { ConfigModule } from "@nestjs/config";
import { APP_GUARD } from "@nestjs/core";
import { EventEmitterModule } from "@nestjs/event-emitter";
import { ThrottlerModule } from "@nestjs/throttler";
import { LoggerModule } from 'nestjs-pino';

import { AuthModule } from "./auth/auth.module";
import { BreedingModule } from "./breeding/breeding.module";
import { BreedsModule } from "./breeds/breeds.module";
import { CareModule } from "./care/care.module";
import { CatsModule } from "./cats/cats.module";
import { CoatColorsModule } from "./coat-colors/coat-colors.module";
import { envSchema } from "./common/config/env.validation";
import { MasterDataController } from "./common/controllers/master-data.controller";
import { EnhancedThrottlerGuard } from "./common/guards/enhanced-throttler.guard";
import { CookieParserMiddleware } from "./common/middleware/cookie-parser.middleware";
import { RequestIdMiddleware } from './common/middleware/request-id.middleware';
import { SecurityMiddleware } from "./common/middleware/security.middleware";
import { DisplayPreferencesModule } from "./display-preferences/display-preferences.module";
import { EmailModule } from "./email/email.module";
import { ExportModule } from "./export/export.module";
import { GalleryModule } from "./gallery/gallery.module";
import { GalleryUploadModule } from "./gallery-upload/gallery-upload.module";
import { GraduationModule } from "./graduation/graduation.module";
import { HealthModule } from "./health/health.module";
import { ImportModule } from "./import/import.module";
import { PedigreeModule } from "./pedigree/pedigree.module";
import { PrintTemplatesModule } from "./print-templates/print-templates.module";
import { PrismaModule } from "./prisma/prisma.module";
import { ScheduleModule } from "./schedule/schedule.module";
import { ShiftModule } from './shift/shift.module';
import { StaffModule } from './staff/staff.module';
import { TagsModule } from "./tags/tags.module";
import { TenantSettingsModule } from "./tenant-settings/tenant-settings.module";
import { TenantsModule } from "./tenants/tenants.module";
import { UploadModule } from "./upload/upload.module";
import { UsersModule } from "./users/users.module";

type LogLevel = 'fatal' | 'error' | 'warn' | 'info' | 'debug' | 'trace';

const ALLOWED_LEVELS: readonly LogLevel[] = ['fatal', 'error', 'warn', 'info', 'debug', 'trace'];

const sanitizeBindings = (input: unknown): { pid?: number; host?: string } => {
  if (!input || typeof input !== "object") {
    return {};
  }

  const record = input as Record<string, unknown>;
  const pid = typeof record.pid === "number" ? record.pid : undefined;
  const hostname = typeof record.hostname === "string" ? record.hostname : undefined;

  return {
    ...(pid !== undefined ? { pid } : {}),
    ...(hostname ? { host: hostname } : {}),
  };
};

const sanitizeLevel = (value: unknown): LogLevel => {
  if (typeof value === "string" && (ALLOWED_LEVELS as readonly string[]).includes(value)) {
    return value as LogLevel;
  }
  return 'info';
};

@Module({
  imports: [
    LoggerModule.forRoot({
      pinoHttp: {
        level: 'debug',
        transport: process.env.NODE_ENV === 'production' ? undefined : {
          target: 'pino-pretty',
          options: { colorize: true, singleLine: true },
        },
        redact: ['req.headers.authorization', 'req.headers.cookie'],
        formatters: {
          bindings: (value) => sanitizeBindings(value),
          level: (label) => ({ level: sanitizeLevel(label) }),
        },
      },
    }),
    ConfigModule.forRoot({
      isGlobal: true,
      validate: (config) => envSchema.parse(config),
    }),
    EventEmitterModule.forRoot({
      // ã‚¤ãƒ™ãƒ³ãƒˆã®éåŒæœŸå‡¦ç†ã‚’æœ‰åŠ¹åŒ–
      wildcard: false,
      delimiter: '.',
      newListener: false,
      removeListener: false,
      maxListeners: 10,
      verboseMemoryLeak: false,
      ignoreErrors: false,
    }),
    ThrottlerModule.forRoot([
      {
        name: 'default',
        ttl: 60000, // 1 minute in milliseconds
        limit: 100, // 100 requests per minute
      },
    ]),
    PrismaModule,
    AuthModule,
    UsersModule,
    TenantsModule,
    TenantSettingsModule,
    CatsModule,
    PedigreeModule,
    PrintTemplatesModule,
    BreedsModule,
    CoatColorsModule,
  BreedingModule,
  DisplayPreferencesModule,
    CareModule,
    ScheduleModule,
    UploadModule,
    TagsModule,
    HealthModule,
    StaffModule,
    ShiftModule,
    GraduationModule,
    GalleryUploadModule,
    GalleryModule,
    EmailModule,
    ExportModule,
    ImportModule,
  ],
  controllers: [MasterDataController],
  providers: [
    {
      provide: APP_GUARD,
      useClass: EnhancedThrottlerGuard,
    },
  ],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    // CORSã¯main.tsã§è¨­å®šæ¸ˆã¿ã®ãŸã‚ã€CorsMiddlewareã¯å‰Šé™¤
    consumer
      .apply(RequestIdMiddleware, SecurityMiddleware, CookieParserMiddleware)
      .forRoutes('*');
  }
}
`````

## File: .github/workflows/deploy-only.yml
`````yaml
name: Deploy Only (Staging & Production)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        type: choice
        options:
          - staging
          - production
          - both
  workflow_call:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        type: string
    secrets:
      # Staging secrets
      GCP_SA_KEY_STAGING:
        required: false
      GCP_PROJECT_ID_STAGING:
        required: false
      GCP_SQL_INSTANCE_NAME_STAGING:
        required: false
      GCP_RUN_SA_BACKEND_STAGING:
        required: false
      GCP_RUN_SA_FRONTEND_STAGING:
        required: false
      # Production secrets
      GCP_SA_KEY:
        required: false
      GCP_PROJECT_ID:
        required: false
      GCP_SQL_INSTANCE_NAME:
        required: false
      GCP_RUN_SA_BACKEND:
        required: false
      GCP_RUN_SA_FRONTEND:
        required: false

permissions:
  contents: read

env:
  NODE_VERSION: "20"
  PNPM_VERSION: "9"
  REGION: "asia-northeast1"
  REPO_NAME: "mycats-pro"

jobs:
  # Deploy to Staging Environment (mycats-pro-staging project)
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    if: inputs.environment == 'staging' || inputs.environment == 'both'
    environment:
      name: staging
      url: https://mycats-pro-backend-staging.asia-northeast1.run.app
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate required secrets for Staging
        run: |
          missing_secrets=()
          
          if [ -z "${{ secrets.GCP_SA_KEY_STAGING }}" ]; then
            missing_secrets+=("GCP_SA_KEY_STAGING")
          fi
          if [ -z "${{ secrets.GCP_PROJECT_ID_STAGING }}" ]; then
            missing_secrets+=("GCP_PROJECT_ID_STAGING")
          fi
          if [ -z "${{ secrets.GCP_SQL_INSTANCE_NAME_STAGING }}" ]; then
            missing_secrets+=("GCP_SQL_INSTANCE_NAME_STAGING")
          fi
          if [ -z "${{ secrets.GCP_RUN_SA_BACKEND_STAGING }}" ]; then
            missing_secrets+=("GCP_RUN_SA_BACKEND_STAGING")
          fi
          if [ -z "${{ secrets.GCP_RUN_SA_FRONTEND_STAGING }}" ]; then
            missing_secrets+=("GCP_RUN_SA_FRONTEND_STAGING")
          fi
          
          if [ ${#missing_secrets[@]} -gt 0 ]; then
            echo "âŒ Error: The following secrets are not set:"
            for secret in "${missing_secrets[@]}"; do
              echo "  - $secret"
            done
            echo ""
            echo "Please configure these secrets in repository settings:"
            echo "  Settings > Secrets and variables > Actions > New repository secret"
            exit 1
          fi
          
          echo "âœ… All required staging secrets are configured"

      - name: Authenticate to Google Cloud (Staging)
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY_STAGING }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID_STAGING }}

      - name: Configure Docker for Artifact Registry
        run: |
          gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev

      - name: Deploy to Staging using Cloud Build
        env:
          PROJECT_ID: ${{ secrets.GCP_PROJECT_ID_STAGING }}
          SQL_INSTANCE: ${{ secrets.GCP_SQL_INSTANCE_NAME_STAGING }}
          BACKEND_SA: ${{ secrets.GCP_RUN_SA_BACKEND_STAGING }}
          FRONTEND_SA: ${{ secrets.GCP_RUN_SA_FRONTEND_STAGING }}
        run: |
          echo "ğŸš€ Deploying to staging environment..."
          echo "   Project: ${PROJECT_ID}"
          echo "   SQL Instance: ${SQL_INSTANCE}"
          
          # Validate that required environment variables are set
          if [ -z "${FRONTEND_SA}" ]; then
            echo "âŒ Error: FRONTEND_SA is not set or empty"
            echo "   This means GCP_RUN_SA_FRONTEND_STAGING secret is missing or empty"
            exit 1
          fi
          
          if [ -z "${BACKEND_SA}" ]; then
            echo "âŒ Error: BACKEND_SA is not set or empty"
            echo "   This means GCP_RUN_SA_BACKEND_STAGING secret is missing or empty"
            exit 1
          fi
          
          echo "   Backend Service Account: ${BACKEND_SA}"
          echo "   Frontend Service Account: ${FRONTEND_SA}"
          
          # Build Cloud SQL connection name
          CLOUD_SQL_CONN="${PROJECT_ID}:${{ env.REGION }}:${SQL_INSTANCE}"
          
          # Build service URLs (will be updated after first deployment)
          BACKEND_URL="https://mycats-pro-backend-staging-687406216678.${{ env.REGION }}.run.app"
          FRONTEND_URL="https://mycats-pro-frontend-staging-687406216678.${{ env.REGION }}.run.app"
          
          # Get actual Cloud Run frontend URL for CORS
          CLOUD_RUN_FRONTEND_URL=$(gcloud run services describe mycats-pro-frontend-staging \
            --region=${{ env.REGION }} \
            --project="${PROJECT_ID}" \
            --format='value(status.url)' 2>/dev/null || echo "")
          
          # CORS_ORIGINã«æ—¢å®šURLã¨Cloud Run URLã®ä¸¡æ–¹ã‚’å«ã‚ã‚‹
          # æ³¨æ„: gcloud --substitutionsã§ã¯å€¤ã«ã‚«ãƒ³ãƒã‚’å«ã‚ã‚‰ã‚Œãªã„ãŸã‚ã€
          # ä¸€æ™‚çš„ã«ãƒ‘ã‚¤ãƒ—æ–‡å­—(|)ã‚’åŒºåˆ‡ã‚Šæ–‡å­—ã¨ã—ã¦ä½¿ç”¨ã—ã€cloudbuild.yamlå´ã§ã‚«ãƒ³ãƒã«å¤‰æ›ã™ã‚‹
          if [ -n "${CLOUD_RUN_FRONTEND_URL}" ]; then
            CORS_ORIGIN="${FRONTEND_URL}|${CLOUD_RUN_FRONTEND_URL}"
          else
            CORS_ORIGIN="${FRONTEND_URL}"
          fi
          
          # Build substitutions string
          # Note: ãƒ‘ã‚¤ãƒ—æ–‡å­—ã§åŒºåˆ‡ã‚‰ã‚ŒãŸCORS_ORIGINã¯cloudbuild.yamlã§ã‚«ãƒ³ãƒã«å¤‰æ›ã•ã‚Œã‚‹
          SUBSTITUTIONS="_ENVIRONMENT=staging"
          SUBSTITUTIONS="${SUBSTITUTIONS},_REPO_NAME=${{ env.REPO_NAME }}"
          SUBSTITUTIONS="${SUBSTITUTIONS},_BACKEND_SERVICE_NAME=mycats-pro-backend-staging"
          SUBSTITUTIONS="${SUBSTITUTIONS},_FRONTEND_SERVICE_NAME=mycats-pro-frontend-staging"
          SUBSTITUTIONS="${SUBSTITUTIONS},_CLOUD_SQL_CONNECTION_NAME=${CLOUD_SQL_CONN}"
          SUBSTITUTIONS="${SUBSTITUTIONS},_BACKEND_SERVICE_ACCOUNT=${BACKEND_SA}"
          SUBSTITUTIONS="${SUBSTITUTIONS},_FRONTEND_SERVICE_ACCOUNT=${FRONTEND_SA}"
          SUBSTITUTIONS="${SUBSTITUTIONS},_CORS_ORIGIN=${CORS_ORIGIN}"
          SUBSTITUTIONS="${SUBSTITUTIONS},_NEXT_PUBLIC_API_URL=${BACKEND_URL}/api/v1"
          SUBSTITUTIONS="${SUBSTITUTIONS},_DATABASE_URL_SECRET_NAME=DATABASE_URL"
          SUBSTITUTIONS="${SUBSTITUTIONS},_DATABASE_URL_SECRET_VERSION=latest"
          SUBSTITUTIONS="${SUBSTITUTIONS},_JWT_SECRET_NAME=JWT_SECRET"
          SUBSTITUTIONS="${SUBSTITUTIONS},_JWT_SECRET_VERSION=latest"
          SUBSTITUTIONS="${SUBSTITUTIONS},_JWT_REFRESH_SECRET_NAME=JWT_REFRESH_SECRET"
          SUBSTITUTIONS="${SUBSTITUTIONS},_JWT_REFRESH_SECRET_VERSION=latest"
          SUBSTITUTIONS="${SUBSTITUTIONS},_CSRF_TOKEN_SECRET_NAME=CSRF_TOKEN_SECRET"
          SUBSTITUTIONS="${SUBSTITUTIONS},_CSRF_TOKEN_SECRET_VERSION=latest"
          SUBSTITUTIONS="${SUBSTITUTIONS},_RESEND_API_KEY_SECRET_NAME=RESEND_API_KEY"
          SUBSTITUTIONS="${SUBSTITUTIONS},_RESEND_API_KEY_SECRET_VERSION=latest"
          SUBSTITUTIONS="${SUBSTITUTIONS},_EMAIL_FROM=noreply@nekoya.co.jp"
          SUBSTITUTIONS="${SUBSTITUTIONS},_EMAIL_FROM_NAME=MyCats Pro"
          
          echo "ğŸ“‹ Substitutions being passed to Cloud Build:"
          echo "${SUBSTITUTIONS}" | tr ',' '\n' | sed 's/^/  /'
          
          gcloud builds submit \
            --config=cloudbuild.yaml \
            --substitutions="${SUBSTITUTIONS}" \
            --project="${PROJECT_ID}"

      - name: Verify Staging Deployment
        env:
          PROJECT_ID: ${{ secrets.GCP_PROJECT_ID_STAGING }}
        run: |
          echo "âœ… Staging deployment completed"
          
          # Get actual service URLs
          BACKEND_URL=$(gcloud run services describe mycats-pro-backend-staging \
            --region=${{ env.REGION }} \
            --project="${PROJECT_ID}" \
            --format='value(status.url)' 2>/dev/null || echo "Not available yet")
          
          FRONTEND_URL=$(gcloud run services describe mycats-pro-frontend-staging \
            --region=${{ env.REGION }} \
            --project="${PROJECT_ID}" \
            --format='value(status.url)' 2>/dev/null || echo "Not available yet")
          
          echo "Backend URL: ${BACKEND_URL}"
          echo "Frontend URL: ${FRONTEND_URL}"

      - name: Test Staging Health Endpoint
        env:
          PROJECT_ID: ${{ secrets.GCP_PROJECT_ID_STAGING }}
        run: |
          echo "ğŸ¥ Testing staging backend health endpoint..."
          
          BACKEND_URL=$(gcloud run services describe mycats-pro-backend-staging \
            --region=${{ env.REGION }} \
            --project="${PROJECT_ID}" \
            --format='value(status.url)' 2>/dev/null || echo "")
          
          if [ -z "${BACKEND_URL}" ]; then
            echo "âš ï¸ Could not retrieve backend URL, skipping health check"
            exit 0
          fi
          
          sleep 30
          max_attempts=10
          attempt=0
          while [ $attempt -lt $max_attempts ]; do
            response=$(curl -s -o /dev/null -w "%{http_code}" "${BACKEND_URL}/health" || echo "000")
            if [ "$response" = "200" ]; then
              echo "âœ… Staging backend is healthy (HTTP 200)"
              break
            fi
            attempt=$((attempt + 1))
            echo "â³ Waiting for staging backend to be ready... (attempt $attempt/$max_attempts, got HTTP $response)"
            sleep 10
          done
          if [ $attempt -eq $max_attempts ]; then
            echo "âš ï¸ Warning: Staging backend did not respond with HTTP 200 after $max_attempts attempts"
            echo "This may be normal for initial deployments. Please verify manually."
          fi

  # Deploy to Production Environment (mycats-pro project)
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: |
      always() &&
      (needs.deploy-staging.result == 'success' || needs.deploy-staging.result == 'skipped') &&
      (inputs.environment == 'production' || inputs.environment == 'both')
    environment:
      name: production
      url: https://mycats-pro-backend.asia-northeast1.run.app
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate required secrets for Production
        run: |
          missing_secrets=()
          
          if [ -z "${{ secrets.GCP_SA_KEY }}" ]; then
            missing_secrets+=("GCP_SA_KEY")
          fi
          if [ -z "${{ secrets.GCP_PROJECT_ID }}" ]; then
            missing_secrets+=("GCP_PROJECT_ID")
          fi
          if [ -z "${{ secrets.GCP_SQL_INSTANCE_NAME }}" ]; then
            missing_secrets+=("GCP_SQL_INSTANCE_NAME")
          fi
          if [ -z "${{ secrets.GCP_RUN_SA_BACKEND }}" ]; then
            missing_secrets+=("GCP_RUN_SA_BACKEND")
          fi
          if [ -z "${{ secrets.GCP_RUN_SA_FRONTEND }}" ]; then
            missing_secrets+=("GCP_RUN_SA_FRONTEND")
          fi
          
          if [ ${#missing_secrets[@]} -gt 0 ]; then
            echo "âŒ Error: The following secrets are not set:"
            for secret in "${missing_secrets[@]}"; do
              echo "  - $secret"
            done
            echo ""
            echo "Please configure these secrets in repository settings:"
            echo "  Settings > Secrets and variables > Actions > New repository secret"
            exit 1
          fi
          
          echo "âœ… All required production secrets are configured"

      - name: Authenticate to Google Cloud (Production)
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      - name: Configure Docker for Artifact Registry
        run: |
          gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev

      - name: Deploy to Production using Cloud Build
        env:
          PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
          SQL_INSTANCE: ${{ secrets.GCP_SQL_INSTANCE_NAME }}
          BACKEND_SA: ${{ secrets.GCP_RUN_SA_BACKEND }}
          FRONTEND_SA: ${{ secrets.GCP_RUN_SA_FRONTEND }}
        run: |
          echo "ğŸš€ Deploying to production environment..."
          echo "   Project: ${PROJECT_ID}"
          echo "   SQL Instance: ${SQL_INSTANCE}"
          
          # Validate that required environment variables are set
          if [ -z "${FRONTEND_SA}" ]; then
            echo "âŒ Error: FRONTEND_SA is not set or empty"
            echo "   This means GCP_RUN_SA_FRONTEND secret is missing or empty"
            exit 1
          fi
          
          if [ -z "${BACKEND_SA}" ]; then
            echo "âŒ Error: BACKEND_SA is not set or empty"
            echo "   This means GCP_RUN_SA_BACKEND secret is missing or empty"
            exit 1
          fi
          
          echo "   Backend Service Account: ${BACKEND_SA}"
          echo "   Frontend Service Account: ${FRONTEND_SA}"
          
          # Build Cloud SQL connection name
          CLOUD_SQL_CONN="${PROJECT_ID}:${{ env.REGION }}:${SQL_INSTANCE}"
          
          # Production URLs - ç‹¬è‡ªãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’ä½¿ç”¨
          BACKEND_URL="https://api.nekoya.co.jp"
          FRONTEND_URL="https://nekoya.co.jp"
          
          # Get actual Cloud Run frontend URL for CORS
          CLOUD_RUN_FRONTEND_URL=$(gcloud run services describe mycats-pro-frontend \
            --region=${{ env.REGION }} \
            --project="${PROJECT_ID}" \
            --format='value(status.url)' 2>/dev/null || echo "")
          
          # CORS_ORIGINã«ç‹¬è‡ªãƒ‰ãƒ¡ã‚¤ãƒ³ã¨Cloud Run URLã®ä¸¡æ–¹ã‚’å«ã‚ã‚‹
          # æ³¨æ„: gcloud --substitutionsã§ã¯å€¤ã«ã‚«ãƒ³ãƒã‚’å«ã‚ã‚‰ã‚Œãªã„ãŸã‚ã€
          # ä¸€æ™‚çš„ã«ãƒ‘ã‚¤ãƒ—æ–‡å­—(|)ã‚’åŒºåˆ‡ã‚Šæ–‡å­—ã¨ã—ã¦ä½¿ç”¨ã—ã€cloudbuild.yamlå´ã§ã‚«ãƒ³ãƒã«å¤‰æ›ã™ã‚‹
          if [ -n "${CLOUD_RUN_FRONTEND_URL}" ]; then
            CORS_ORIGIN="${FRONTEND_URL}|https://www.nekoya.co.jp|${CLOUD_RUN_FRONTEND_URL}"
          else
            CORS_ORIGIN="${FRONTEND_URL}|https://www.nekoya.co.jp"
          fi
          
          # Build substitutions string
          # Note: ãƒ‘ã‚¤ãƒ—æ–‡å­—ã§åŒºåˆ‡ã‚‰ã‚ŒãŸCORS_ORIGINã¯cloudbuild.yamlã§ã‚«ãƒ³ãƒã«å¤‰æ›ã•ã‚Œã‚‹
          SUBSTITUTIONS="_ENVIRONMENT=production"
          SUBSTITUTIONS="${SUBSTITUTIONS},_REPO_NAME=${{ env.REPO_NAME }}"
          SUBSTITUTIONS="${SUBSTITUTIONS},_BACKEND_SERVICE_NAME=mycats-pro-backend"
          SUBSTITUTIONS="${SUBSTITUTIONS},_FRONTEND_SERVICE_NAME=mycats-pro-frontend"
          SUBSTITUTIONS="${SUBSTITUTIONS},_CLOUD_SQL_CONNECTION_NAME=${CLOUD_SQL_CONN}"
          SUBSTITUTIONS="${SUBSTITUTIONS},_BACKEND_SERVICE_ACCOUNT=${BACKEND_SA}"
          SUBSTITUTIONS="${SUBSTITUTIONS},_FRONTEND_SERVICE_ACCOUNT=${FRONTEND_SA}"
          SUBSTITUTIONS="${SUBSTITUTIONS},_CORS_ORIGIN=${CORS_ORIGIN}"
          SUBSTITUTIONS="${SUBSTITUTIONS},_NEXT_PUBLIC_API_URL=${BACKEND_URL}/api/v1"
          SUBSTITUTIONS="${SUBSTITUTIONS},_DATABASE_URL_SECRET_NAME=DATABASE_URL"
          SUBSTITUTIONS="${SUBSTITUTIONS},_DATABASE_URL_SECRET_VERSION=latest"
          SUBSTITUTIONS="${SUBSTITUTIONS},_JWT_SECRET_NAME=JWT_SECRET"
          SUBSTITUTIONS="${SUBSTITUTIONS},_JWT_SECRET_VERSION=latest"
          SUBSTITUTIONS="${SUBSTITUTIONS},_JWT_REFRESH_SECRET_NAME=JWT_REFRESH_SECRET"
          SUBSTITUTIONS="${SUBSTITUTIONS},_JWT_REFRESH_SECRET_VERSION=latest"
          SUBSTITUTIONS="${SUBSTITUTIONS},_CSRF_TOKEN_SECRET_NAME=CSRF_TOKEN_SECRET"
          SUBSTITUTIONS="${SUBSTITUTIONS},_CSRF_TOKEN_SECRET_VERSION=latest"
          SUBSTITUTIONS="${SUBSTITUTIONS},_RESEND_API_KEY_SECRET_NAME=RESEND_API_KEY"
          SUBSTITUTIONS="${SUBSTITUTIONS},_RESEND_API_KEY_SECRET_VERSION=latest"
          SUBSTITUTIONS="${SUBSTITUTIONS},_EMAIL_FROM=noreply@nekoya.co.jp"
          SUBSTITUTIONS="${SUBSTITUTIONS},_EMAIL_FROM_NAME=MyCats Pro"
          
          echo "ğŸ“‹ Substitutions being passed to Cloud Build:"
          echo "${SUBSTITUTIONS}" | tr ',' '\n' | sed 's/^/  /'
          
          gcloud builds submit \
            --config=cloudbuild.yaml \
            --substitutions="${SUBSTITUTIONS}" \
            --project="${PROJECT_ID}"

      - name: Verify Production Deployment
        env:
          PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
        run: |
          echo "âœ… Production deployment completed"
          
          # Get actual service URLs
          BACKEND_URL=$(gcloud run services describe mycats-pro-backend \
            --region=${{ env.REGION }} \
            --project="${PROJECT_ID}" \
            --format='value(status.url)' 2>/dev/null || echo "Not available yet")
          
          FRONTEND_URL=$(gcloud run services describe mycats-pro-frontend \
            --region=${{ env.REGION }} \
            --project="${PROJECT_ID}" \
            --format='value(status.url)' 2>/dev/null || echo "Not available yet")
          
          echo "Backend URL: ${BACKEND_URL}"
          echo "Frontend URL: ${FRONTEND_URL}"

      - name: Test Production Health Endpoint
        env:
          PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
        run: |
          echo "ğŸ¥ Testing production backend health endpoint..."
          
          BACKEND_URL=$(gcloud run services describe mycats-pro-backend \
            --region=${{ env.REGION }} \
            --project="${PROJECT_ID}" \
            --format='value(status.url)' 2>/dev/null || echo "")
          
          if [ -z "${BACKEND_URL}" ]; then
            echo "âš ï¸ Could not retrieve backend URL, skipping health check"
            exit 0
          fi
          
          sleep 30
          max_attempts=10
          attempt=0
          while [ $attempt -lt $max_attempts ]; do
            response=$(curl -s -o /dev/null -w "%{http_code}" "${BACKEND_URL}/health" || echo "000")
            if [ "$response" = "200" ]; then
              echo "âœ… Production backend is healthy (HTTP 200)"
              break
            fi
            attempt=$((attempt + 1))
            echo "â³ Waiting for production backend to be ready... (attempt $attempt/$max_attempts, got HTTP $response)"
            sleep 10
          done
          if [ $attempt -eq $max_attempts ]; then
            echo "âš ï¸ Warning: Production backend did not respond with HTTP 200 after $max_attempts attempts"
            echo "This may be normal for initial deployments. Please verify manually."
          fi
`````

## File: backend/package.json
`````json
{
  "name": "backend",
  "version": "1.0.0",
  "description": "Cat Management System Backend API",
  "author": "Cat Management Team",
  "private": true,
  "license": "MIT",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "prestart": "node ./scripts/ensure-dev-build.mjs",
    "prestart:dev": "node ./scripts/ensure-dev-build.mjs",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:changed": "jest --onlyChanged",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "sh -c 'if [ -f ./.env.test ]; then dotenv -e ./.env.test -- prisma migrate reset --force --schema ./prisma/schema.prisma; else prisma migrate reset --force --schema ./prisma/schema.prisma; fi && for file in test/*.e2e-spec.ts; do echo \"Running $file\"; npx jest \"$file\" --config ./test/jest-e2e.json --runInBand --forceExit; done'",
    "test:e2e:cov": "jest --config ./test/jest-e2e.json --runInBand --coverage",
    "type-check": "tsc --noEmit",
    "swagger:gen": "dotenv -e ./.env -- ts-node -r tsconfig-paths/register src/scripts/generate-swagger.ts",
    "prisma:generate": "dotenv -e ./.env -- prisma generate --schema ./prisma/schema.prisma",
    "prisma:migrate": "dotenv -e ./.env -- prisma migrate dev --schema ./prisma/schema.prisma",
    "prisma:deploy": "dotenv -e ./.env -- prisma migrate deploy --schema ./prisma/schema.prisma",
    "prisma:studio": "dotenv -e ./.env -- prisma studio --schema ./prisma/schema.prisma",
    "prisma:pull": "dotenv -e ./.env -- prisma db pull --schema ./prisma/schema.prisma",
    "prisma:status": "dotenv -e ./.env -- prisma migrate status --schema ./prisma/schema.prisma",
    "prisma:sync:once": "node src/scripts/sync-prisma.mjs --once",
    "prisma:sync:watch": "node src/scripts/sync-prisma.mjs",
    "seed": "ts-node src/prisma/seed.ts",
    "generate-secrets": "pnpm -C .. run generate-secrets",
    "csv:preview": "ts-node src/scripts/selective-csv-import.ts --preview --start 701606 --end 701630",
    "csv:import": "ts-node src/scripts/selective-csv-import.ts",
    "csv:sample": "ts-node src/scripts/selective-csv-import.ts --start 701606 --end 701630 --max 25",
    "csv:analyze": "ts-node src/scripts/csv-preview.ts",
    "pedigree:rename": "ts-node src/scripts/rename-pedigree-csv.ts",
    "pedigree:import": "ts-node src/scripts/import-pedigree-sample.ts",
    "pedigree:sample": "ts-node src/scripts/import-pedigree-sample.ts --range=701606-701630",
    "pedigree:check": "ts-node src/scripts/check-pedigree-data.ts",
    "pedigree:relations": "ts-node src/scripts/build-pedigree-relations.ts",
    "pedigree:medium": "ts-node src/scripts/import-medium-dataset.ts",
    "pedigree:parents": "ts-node src/scripts/import-parent-pedigrees.ts"
  },
  "dependencies": {
    "@google-cloud/storage": "^7.18.0",
    "@nestjs/common": "^10.4.20",
    "@nestjs/config": "^3.3.0",
    "@nestjs/core": "^10.4.20",
    "@nestjs/event-emitter": "^3.0.1",
    "@nestjs/jwt": "^10.2.0",
    "@nestjs/mapped-types": "^2.1.0",
    "@nestjs/passport": "^10.0.3",
    "@nestjs/platform-express": "^10.4.20",
    "@nestjs/schedule": "^6.1.0",
    "@nestjs/swagger": "^7.4.2",
    "@nestjs/throttler": "^5.2.0",
    "@prisma/client": "^6.19.0",
    "@sentry/node": "^8.55.0",
    "@sentry/profiling-node": "^8.55.0",
    "@types/papaparse": "^5.5.2",
    "@types/pg": "^8.16.0",
    "argon2": "^0.44.0",
    "bcryptjs": "^2.4.3",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.3",
    "cookie-parser": "^1.4.7",
    "csv-parse": "^6.1.0",
    "csv-parser": "^3.2.0",
    "dayjs": "^1.11.13",
    "dotenv": "^16.6.1",
    "express": "^4.21.2",
    "helmet": "^8.1.0",
    "multer": "^2.0.2",
    "nestjs-pino": "^4.5.0",
    "papaparse": "^5.5.3",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "passport-local": "^1.0.0",
    "pdfmake": "^0.2.20",
    "pg": "^8.16.3",
    "pino-pretty": "^11.3.0",
    "prisma": "^6.19.0",
    "redis": "^4.7.1",
    "reflect-metadata": "^0.2.2",
    "resend": "^6.6.0",
    "rxjs": "^7.8.1",
    "uuid": "^9.0.1",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@eslint/js": "^9",
    "@nestjs/cli": "^10.4.9",
    "@nestjs/schematics": "^10.2.3",
    "@nestjs/testing": "^10.4.20",
    "@types/bcryptjs": "^2.4.6",
    "@types/cookie-parser": "^1.4.9",
    "@types/express": "^4.17.25",
    "@types/jest": "^29.5.14",
    "@types/multer": "^1.4.13",
    "@types/node": "^20.19.25",
    "@types/passport-jwt": "^3.0.13",
    "@types/passport-local": "^1.0.38",
    "@types/pdfmake": "^0.2.12",
    "@types/supertest": "^2.0.16",
    "@types/uuid": "^9.0.8",
    "@typescript-eslint/eslint-plugin": "^8.49.0",
    "@typescript-eslint/parser": "^8.49.0",
    "chokidar": "^3.6.0",
    "dotenv-cli": "^7.4.4",
    "eslint": "^9",
    "eslint-config-prettier": "^9.1.2",
    "eslint-import-resolver-typescript": "^4.4.4",
    "eslint-plugin-import-x": "^4.16.1",
    "jest": "^29.7.0",
    "prettier": "^3.7.4",
    "source-map-support": "^0.5.21",
    "supertest": "^6.3.4",
    "ts-jest": "^29.4.6",
    "ts-loader": "^9.4.3",
    "ts-node": "^10.9.1",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.1.3",
    "typescript-eslint": "^8.49.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.service.ts",
      "**/*.controller.ts",
      "!**/*.spec.ts",
      "!**/*.module.ts",
      "!**/prisma.service.ts"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node",
    "coverageThreshold": {
      "global": {
        "branches": 70,
        "functions": 70,
        "lines": 70,
        "statements": 70
      }
    }
  }
}
`````

## File: cloudbuild.yaml
`````yaml
# Google Cloud Build Configuration
# This file defines the CI/CD pipeline for building, testing, and deploying the application.
# Supports both staging and production environments via substitution variables.
#
# All environment-specific values are now passed via substitutions from the caller.
# No hardcoded project IDs or service account emails.

steps:
  # 1. Build the backend Docker image
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Build Backend'
    args:
      - 'build'
      - '-t'
      - '${_LOCATION}-docker.pkg.dev/${PROJECT_ID}/${_REPO_NAME}/backend:latest'
      - '-f'
      - 'Dockerfile.backend'
      - '.'
    waitFor: ['-']

  # 2. Build the frontend Docker image
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Build Frontend'
    args:
      - 'build'
      - '-t'
      - '${_LOCATION}-docker.pkg.dev/${PROJECT_ID}/${_REPO_NAME}/frontend:latest'
      # Pass the public API URL as a build argument for the frontend
      - '--build-arg'
      - 'NEXT_PUBLIC_API_URL=${_NEXT_PUBLIC_API_URL}'
      - '-f'
      - 'Dockerfile.frontend'
      - '.'
    waitFor: ['-']

  # 3. Push the backend image to Artifact Registry
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Push Backend'
    args:
      - 'push'
      - '${_LOCATION}-docker.pkg.dev/${PROJECT_ID}/${_REPO_NAME}/backend:latest'
    waitFor: ['Build Backend']

  # 4. Push the frontend image to Artifact Registry
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Push Frontend'
    args:
      - 'push'
      - '${_LOCATION}-docker.pkg.dev/${PROJECT_ID}/${_REPO_NAME}/frontend:latest'
    waitFor: ['Build Frontend']

  # 5. Deploy Backend to Cloud Run (migration will run on startup)
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'Deploy Backend'
    entrypoint: bash
    args:
      - '-c'
      - |
          set -euo pipefail

          echo "ğŸ”§ Clearing default gcloud service account configuration..."
          gcloud config unset run/service-account 2>/dev/null || true

          EXTRA_FLAGS=()
          if [[ -n "${_BACKEND_DEPLOY_FLAGS}" ]]; then
            read -r -a EXTRA_FLAGS <<< "${_BACKEND_DEPLOY_FLAGS}"
          fi

          echo "ğŸ“‹ Deployment Configuration:"
          echo "  Environment: ${_ENVIRONMENT}"
          echo "  Service Name: ${_BACKEND_SERVICE_NAME}"
          echo "  Service Account Email: ${_BACKEND_SERVICE_ACCOUNT}"
          echo "  Cloud SQL Connection: ${_CLOUD_SQL_CONNECTION_NAME}"
          echo ""
          echo "ğŸ” Secrets Configuration:"
          echo "  DATABASE_URL: ${_DATABASE_URL_SECRET_NAME}:${_DATABASE_URL_SECRET_VERSION}"
          echo "  JWT_SECRET: ${_JWT_SECRET_NAME}:${_JWT_SECRET_VERSION}"
          echo "  JWT_REFRESH_SECRET: ${_JWT_REFRESH_SECRET_NAME}:${_JWT_REFRESH_SECRET_VERSION}"
          echo "  CSRF_TOKEN_SECRET: ${_CSRF_TOKEN_SECRET_NAME}:${_CSRF_TOKEN_SECRET_VERSION}"
          echo "  RESEND_API_KEY: ${_RESEND_API_KEY_SECRET_NAME}:${_RESEND_API_KEY_SECRET_VERSION}"

          # CORS_ORIGIN: ãƒ‘ã‚¤ãƒ—(|) â†’ ã‚«ãƒ³ãƒ(,)
          cors_origin_final="$(echo "${_CORS_ORIGIN}" | sed 's/|/,/g')"
          echo "  CORS_ORIGIN (input): ${_CORS_ORIGIN}"
          echo "  CORS_ORIGIN (final): ${cors_origin_final}"

          # ---- env-vars-file ã‚’ç”Ÿæˆ ----
          cat << EOF > env.yaml
          NODE_ENV: ${_ENVIRONMENT}
          INSTANCE_CONNECTION_NAME: ${_CLOUD_SQL_CONNECTION_NAME}
          EMAIL_FROM: ${_EMAIL_FROM}
          EMAIL_FROM_NAME: ${_EMAIL_FROM_NAME}
          CORS_ORIGIN: "${cors_origin_final}"
          EOF

          echo "ğŸ“„ Generated env.yaml:"
          cat env.yaml

          # ---- Deploy ----
          gcloud run deploy "${_BACKEND_SERVICE_NAME}" \
            --image "${_LOCATION}-docker.pkg.dev/${PROJECT_ID}/${_REPO_NAME}/backend:latest" \
            --region "${_LOCATION}" \
            --platform managed \
            --execution-environment=gen2 \
            --service-account "${_BACKEND_SERVICE_ACCOUNT}" \
            --allow-unauthenticated \
            --env-vars-file env.yaml \
            --set-secrets "DATABASE_URL=${_DATABASE_URL_SECRET_NAME}:${_DATABASE_URL_SECRET_VERSION},JWT_SECRET=${_JWT_SECRET_NAME}:${_JWT_SECRET_VERSION},JWT_REFRESH_SECRET=${_JWT_REFRESH_SECRET_NAME}:${_JWT_REFRESH_SECRET_VERSION},CSRF_TOKEN_SECRET=${_CSRF_TOKEN_SECRET_NAME}:${_CSRF_TOKEN_SECRET_VERSION},RESEND_API_KEY=${_RESEND_API_KEY_SECRET_NAME}:${_RESEND_API_KEY_SECRET_VERSION}" \
            --add-cloudsql-instances "${_CLOUD_SQL_CONNECTION_NAME}" \
            --concurrency 20 \
            --max-instances 3 \
            --min-instances 0 \
            --memory 512Mi \
            --cpu 1 \
            --cpu-boost \
            --timeout 300 \
            --port 8080 \
            --startup-probe=failureThreshold=30,timeoutSeconds=5,periodSeconds=10,httpGet.port=8080,httpGet.path=/health \
            "${EXTRA_FLAGS[@]}"
    waitFor: ['Push Backend']


  # 6. Deploy Frontend to Cloud Run
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'Deploy Frontend'
    entrypoint: bash
    args:
      - '-c'
      - |
          set -euo pipefail

          # Clear any default gcloud service account settings to ensure explicit specification is used
          echo "ğŸ”§ Clearing default gcloud service account configuration..."
          gcloud config unset run/service-account 2>/dev/null || true

          EXTRA_FLAGS=()
          if [[ -n "${_FRONTEND_DEPLOY_FLAGS}" ]]; then
            read -r -a EXTRA_FLAGS <<< "${_FRONTEND_DEPLOY_FLAGS}"
          fi

          # Debug output to verify correct service account is being used
          echo "ğŸ“‹ Deployment Configuration:"
          echo "  Environment: ${_ENVIRONMENT}"
          echo "  Service Name: ${_FRONTEND_SERVICE_NAME}"
          echo "  Service Account Email: ${_FRONTEND_SERVICE_ACCOUNT}"
          echo "  API URL: ${_NEXT_PUBLIC_API_URL}"

          # Deploy with the service account passed from substitutions
          gcloud run deploy "${_FRONTEND_SERVICE_NAME}" \
            --image "${_LOCATION}-docker.pkg.dev/${PROJECT_ID}/${_REPO_NAME}/frontend:latest" \
            --region "${_LOCATION}" \
            --platform managed \
            --allow-unauthenticated \
            --set-env-vars "NODE_ENV=${_ENVIRONMENT},NEXT_PUBLIC_API_URL=${_NEXT_PUBLIC_API_URL}" \
            --execution-environment=gen2 \
            --service-account "${_FRONTEND_SERVICE_ACCOUNT}" \
            --concurrency 50 \
            --cpu-boost \
            "${EXTRA_FLAGS[@]}"
    waitFor: ['Push Frontend']

# Define images to be pushed to Artifact Registry
images:
  - '${_LOCATION}-docker.pkg.dev/${PROJECT_ID}/${_REPO_NAME}/backend:latest'
  - '${_LOCATION}-docker.pkg.dev/${PROJECT_ID}/${_REPO_NAME}/frontend:latest'

# Define substitution variables that can be passed at build time
# All values with defaults are for local testing only.
# In CI/CD pipelines, all values should be explicitly provided.
substitutions:
  # Common settings
  _LOCATION: 'asia-northeast1' # Tokyo region
  _REPO_NAME: 'mycats-pro'
  _ENVIRONMENT: 'production'
  
  # Service names (must be provided by caller)
  _BACKEND_SERVICE_NAME: ''
  _FRONTEND_SERVICE_NAME: ''
  
  # URLs (must be provided by caller)
  _NEXT_PUBLIC_API_URL: ''
  _CORS_ORIGIN: ''
  
  # Cloud SQL connection (must be provided by caller)
  # Format: PROJECT_ID:REGION:INSTANCE_NAME
  _CLOUD_SQL_CONNECTION_NAME: ''
  
  # Service accounts (must be provided by caller)
  # Format: SERVICE_ACCOUNT_NAME@PROJECT_ID.iam.gserviceaccount.com
  _BACKEND_SERVICE_ACCOUNT: ''
  _FRONTEND_SERVICE_ACCOUNT: ''
  
  # Secret names (can be customized per environment)
  _DATABASE_URL_SECRET_NAME: 'DATABASE_URL'
  _JWT_SECRET_NAME: 'JWT_SECRET'
  _JWT_REFRESH_SECRET_NAME: 'JWT_REFRESH_SECRET'
  _CSRF_TOKEN_SECRET_NAME: 'CSRF_TOKEN_SECRET'
  _RESEND_API_KEY_SECRET_NAME: 'RESEND_API_KEY'
  
  # Secret versions
  _DATABASE_URL_SECRET_VERSION: '1'
  _JWT_SECRET_VERSION: '1'
  _JWT_REFRESH_SECRET_VERSION: '1'
  _CSRF_TOKEN_SECRET_VERSION: '1'
  _RESEND_API_KEY_SECRET_VERSION: 'latest'
  
  # Email settings
  _EMAIL_FROM: 'noreply@nekoya.co.jp'
  _EMAIL_FROM_NAME: 'MyCats Pro'
  
  # Additional deploy flags (optional)
  _BACKEND_DEPLOY_FLAGS: ''
  _FRONTEND_DEPLOY_FLAGS: ''

options:
  logging: CLOUD_LOGGING_ONLY
`````
