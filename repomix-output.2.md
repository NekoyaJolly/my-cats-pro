This file is a merged representation of the entire codebase, combined into a single document by Repomix.

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
.cursor/
  commands/
    backendenv.md
  rules/
    ai-checklist/
      RULE.md
    backend/
      RULE.md
    docs/
      RULE.md
    frontend/
      RULE.md
    gemini-tips/
      RULE.md
    package-guard/
      RULE.md
    project-core/
      RULE.md
    request-templates/
      RULE.md
.github/
  agents/
    backend-agent.md
    docs-agent.md
    frontend-agent.md
    test-agent.md
    vertical_review_agent_specification.md
  guards/
    package-added-guard.md
  instructions/
    backend.instructions.md
    docs.instructions.md
    frontend.instructions.md
  ISSUE_TEMPLATE/
    critical-env-file-tracking.md
    high-auth-bypass.md
    medium-frontend-env-example.md
  workflows/
    ci-cd.yml
    deploy-only.yml
    trigger-deploy-from-ci.yml
  ai-checklist.md
  CICD_PRODUCTION_GUIDE.md
  COPILOT_INSTRUCTIONS_README.md
  copilot-instructions.md
  DEPLOYMENT_CHECKLIST.md
  DEPLOYMENT_SECRETS_SETUP.md
  staged-verification.md
  user-feedback-priority.md
.playwright-mcp/
  cats-new.png
  kitten-disposition-all-types-success.png
  kittens-page-disposition-display-success.png
  kittens-page-showing-grace-kittens.png
  ng-rule-generation-limit-created.png
  ng-rule-individual-prohibition-created.png
  ng-rule-tag-combination-created.png
  ng-rules-all-5-rules-complete.png
  ng-rules-modal-initial.png
backend/
  prisma/
    migrations/
      20251004195835_init/
        migration.sql
      20251004205546_sync_pedigree_schema/
        migration.sql
      20251005205115_add_password_reset_fields/
        migration.sql
      20251005212034_add_performance_indexes/
        migration.sql
      20251011063613_add_breeding_ng_rules/
        migration.sql
      20251011082000_add_care_type_to_schedules/
        migration.sql
      20251015090000_add_tag_category_automation/
        migration.sql
      20251015100000_add_tag_groups/
        migration.sql
      20251015110000_add_text_colors/
        migration.sql
      20251023131448_add_is_in_house_column/
        migration.sql
      20251023132517_rename_registration_id_to_registration_number/
        migration.sql
      20251023190628_add_breedingrecord/
        migration.sql
      20251023191845_update_pregnancy_birth_models/
        migration.sql
      20251023191932_update_enum_values/
        migration.sql
      20251028180807_add_schedule_cats_table/
        migration.sql
      20251101114041_add_father_and_mating_date_to_pregnancy_and_birth/
        migration.sql
      20251106161358_add_staff_shift_management/
        migration.sql
      20251108122748_add_kitten_disposition_and_birth_completion/
        migration.sql
      20251108135042_add_page_action_event_type/
        migration.sql
      20251109034116_add_medical_page/
        migration.sql
      20251110175612_add_visit_type_relation/
        migration.sql
      20251111105249_add_graduation_table/
        migration.sql
      20251112000000_enhance_performance_indexes/
        migration.sql
      20251117001521_add_pedigrees_api/
        migration.sql
      20251117090000_add_display_preferences/
        migration.sql
      20251117171013_add_remove_coat_color_name_unique/
        migration.sql
      20251118001209_add_performance_indexes/
        migration.sql
      20251126000000_add_multi_tenant_support/
        migration.sql
      20251129203404_add_staff_working_schedule/
        migration.sql
      20251206064624_add_gallery_models/
        migration.sql
      20251210203339_add_tenant_settings/
        migration.sql
      20251212231309_add_print_template_with_category_tenant/
        migration.sql
      20251219032719_add_weight_records/
        migration.sql
      20251219090000_add_pedigree_print_settings/
        migration.sql
      20251220010039_add_breeding_schedule_and_mating_check/
        migration.sql
      20251223003428_202512230930_add_tags_auto_new_style/
        migration.sql
      migration_lock.toml
    seed/
      convert_csv_header_to_snake_case.py
      current_data.sql
      import-breeds.ts
      import-coat-colors.ts
      import-direct.ts
      import-genders.ts
      import-pedigrees.ts
      seed-staff-shifts.ts
      verify-indexes.sql
    schema.prisma
    seed-admin.sql
    seed-cats-simple.sql
    seed-gallery-migration.ts
    seed.ts
  scripts/
    ensure-dev-build.mjs
    export-cats-seed.ts
    generate-secrets.mjs
    migrate_csv_to_supabase.ts
  src/
    auth/
      dto/
        change-password.dto.ts
        login.dto.ts
        password-reset.dto.ts
        refresh-token.dto.ts
        request-password-reset.dto.ts
        reset-password.dto.ts
      auth.constants.spec.ts
      auth.constants.ts
      auth.controller.ts
      auth.module.ts
      auth.service.spec.ts
      auth.service.ts
      auth.types.ts
      get-user.decorator.ts
      jwt-auth.guard.ts
      jwt.strategy.ts
      login-attempt.service.ts
      password.service.ts
      role.guard.spec.ts
      role.guard.ts
      roles.decorator.ts
    breeding/
      dto/
        birth-plan.dto.ts
        breeding-query.dto.ts
        breeding-schedule.dto.ts
        create-breeding-ng-rule.dto.ts
        create-breeding.dto.ts
        index.ts
        kitten-disposition.dto.ts
        pregnancy-check.dto.ts
        update-breeding-ng-rule.dto.ts
        update-breeding.dto.ts
      types/
        breeding.types.ts
      breeding.controller.spec.ts
      breeding.controller.ts
      breeding.module.ts
      breeding.service.spec.ts
      breeding.service.ts
    breeds/
      dto/
        breed-query.dto.ts
        create-breed.dto.ts
        index.ts
        update-breed.dto.ts
      breed-master.data.ts
      breeds.controller.spec.ts
      breeds.controller.ts
      breeds.module.ts
      breeds.service.spec.ts
      breeds.service.ts
    care/
      dto/
        care-query.dto.ts
        care-schedule-response.dto.ts
        complete-care.dto.ts
        create-care-schedule.dto.ts
        create-medical-record.dto.ts
        index.ts
        medical-record-query.dto.ts
        medical-record-response.dto.ts
      care.controller.spec.ts
      care.controller.ts
      care.module.ts
      care.service.spec.ts
      care.service.ts
      json-value.utils.spec.ts
      json-value.utils.ts
      recurrence.utils.spec.ts
      recurrence.utils.ts
    cats/
      constants/
        gender.spec.ts
        gender.ts
      dto/
        cat-family.dto.ts
        cat-query.dto.ts
        cat-statistics.dto.ts
        create-cat.dto.ts
        index.ts
        kitten-query.dto.ts
        update-cat.dto.ts
        weight-record.dto.ts
      types/
        cat.types.ts
      cats.controller.spec.ts
      cats.controller.ts
      cats.module.ts
      cats.service.spec.ts
      cats.service.ts
    coat-colors/
      dto/
        coat-color-query.dto.ts
        create-coat-color.dto.ts
        index.ts
        update-coat-color.dto.ts
      coat-color-master.data.ts
      coat-colors.controller.spec.ts
      coat-colors.controller.ts
      coat-colors.module.ts
      coat-colors.service.spec.ts
      coat-colors.service.ts
    common/
      config/
        env.validation.ts
        rate-limit.config.ts
      controllers/
        master-data.controller.ts
      decorators/
        public.decorator.ts
        rate-limit.decorator.ts
      dto/
        api-response.dto.ts
      filters/
        enhanced-global-exception.filter.ts
        global-exception.filter.ts
      guards/
        enhanced-throttler.guard.ts
        tenant-scoped.guard.spec.ts
        tenant-scoped.guard.ts
      interceptors/
        performance-monitoring.interceptor.ts
        transform-response.interceptor.ts
      middleware/
        cookie-parser.middleware.ts
        request-id.middleware.ts
        security.middleware.ts
      types/
        express.d.ts
        shift.types.ts
        staff.types.ts
      environment.validation.ts
    display-preferences/
      dto/
        master-data-item.dto.ts
        update-display-preference.dto.ts
      display-preferences.controller.spec.ts
      display-preferences.controller.ts
      display-preferences.module.ts
      display-preferences.service.spec.ts
      display-preferences.service.ts
      display-preferences.types.ts
    email/
      email.module.ts
      email.service.spec.ts
      email.service.ts
    export/
      dto/
        export-request.dto.ts
      export.controller.ts
      export.module.ts
      export.service.ts
    gallery/
      dto/
        add-media.dto.ts
        create-gallery-entry.dto.ts
        gallery-query.dto.ts
        index.ts
        update-gallery-entry.dto.ts
      gallery.controller.ts
      gallery.module.ts
      gallery.service.ts
    gallery-upload/
      dto/
        confirm-upload.dto.ts
        generate-upload-url.dto.ts
        index.ts
      interfaces/
        upload-result.interface.ts
      gallery-upload.controller.ts
      gallery-upload.module.ts
      gallery-upload.service.ts
    graduation/
      dto/
        index.ts
        transfer-cat.dto.ts
      graduation.controller.spec.ts
      graduation.controller.ts
      graduation.module.ts
      graduation.service.spec.ts
      graduation.service.ts
    health/
      health.controller.spec.ts
      health.controller.ts
      health.module.ts
    import/
      dto/
        import-response.dto.ts
      import.controller.ts
      import.module.ts
      import.service.ts
    pedigree/
      dto/
        create-pedigree.dto.ts
        index.ts
        pedigree-query.dto.ts
        update-pedigree.dto.ts
      pdf/
        pedigree-pdf.service.ts
        positions.json
        print-settings.service.ts
        è¡€çµ±æ›¸è¦‹æœ¬.png
      types/
        pedigree.types.ts
      pedigree.controller.spec.ts
      pedigree.controller.ts
      pedigree.module.ts
      pedigree.service.spec.ts
      pedigree.service.ts
    print-templates/
      dto/
        index.ts
        print-template.dto.ts
      index.ts
      print-templates.controller.ts
      print-templates.module.ts
      print-templates.service.ts
    prisma/
      prisma.module.ts
      prisma.service.ts
      seed.ts
    schedule/
      schedule.module.ts
    scripts/
      utils/
        prisma-batch.ts
      build-pedigree-relations.ts
      check-parent-pedigrees.ts
      create-admin.ts
      create-or-update-admin.ts
      create-views-and-preview.ts
      generate-swagger.ts
      import-csv-data.ts
      import-master-data.ts
      import-parent-pedigrees.ts
      import-pedigree-data.ts
      inspect-admin.ts
      inspect-schema.ts
      list-tag-categories.ts
      rename-pedigree-csv.ts
      selective-csv-import.ts
      sync-prisma.mjs
      test-auth-login.ts
    shift/
      dto/
        create-shift-template.dto.ts
        create-shift.dto.ts
        get-shifts-query.dto.ts
        update-shift.dto.ts
      shift.controller.spec.ts
      shift.controller.ts
      shift.module.ts
      shift.service.spec.ts
      shift.service.ts
    staff/
      dto/
        create-staff.dto.ts
        update-staff.dto.ts
      staff.controller.spec.ts
      staff.controller.ts
      staff.module.ts
      staff.service.spec.ts
      staff.service.ts
    tags/
      dto/
        assign-tag.dto.ts
        create-tag-automation-rule.dto.ts
        create-tag-category.dto.ts
        create-tag-group.dto.ts
        create-tag.dto.ts
        index.ts
        reorder-tag-category.dto.ts
        reorder-tag-group.dto.ts
        reorder-tag.dto.ts
        update-tag-automation-rule.dto.ts
        update-tag-category.dto.ts
        update-tag-group.dto.ts
        update-tag.dto.ts
      events/
        tag-automation.events.ts
      age-threshold-checker.service.ts
      tag-automation-execution.service.ts
      tag-automation.controller.ts
      tag-automation.service.spec.ts
      tag-automation.service.ts
      tag-categories.controller.ts
      tag-categories.service.ts
      tag-groups.controller.ts
      tag-groups.service.ts
      tags.controller.ts
      tags.module.ts
      tags.service.ts
    tenant-settings/
      dto/
        tag-color-defaults.dto.ts
      tenant-settings.controller.ts
      tenant-settings.module.ts
      tenant-settings.service.ts
    tenants/
      dto/
        create-tenant.dto.ts
        invitation.dto.ts
        update-tenant.dto.ts
      tenants.controller.ts
      tenants.module.ts
      tenants.service.spec.ts
      tenants.service.ts
    test-utils/
      test-module-setup.ts
    upload/
      upload.module.ts
    users/
      dto/
        invite-user.dto.ts
        update-profile.dto.ts
        update-user-role.dto.ts
      users.controller.ts
      users.module.ts
      users.service.spec.ts
      users.service.ts
    app.controller.spec.ts
    app.controller.ts
    app.module.ts
    main.ts
  test/
    utils/
      create-test-app.ts
    auth-breeding.e2e-spec.ts
    auth-jwt.e2e-spec.ts
    auth-password-reset.e2e-spec.ts
    auth-register.e2e-spec.ts
    auth-seed-user.e2e-spec.ts
    breeding-ng-rules.e2e-spec.ts
    breeds-coat-colors.e2e-spec.ts
    care-and-tags.e2e-spec.ts
    care-tags.e2e-spec.ts
    cats.e2e-spec.ts
    export.e2e-spec.ts
    import.e2e-spec.ts
    jest-e2e.json
    pedigree.e2e-spec.ts
    setup-e2e.ts
    tenants.e2e-spec.ts
    users-promote-superadmin.e2e-spec.ts
  .env.example
  .env.test
  AGENTS.md
  docker-entrypoint.sh
  eslint.config.mjs
  GEMINI.md
  nest-cli.json
  openapi.json
  package.json
  SEED_USER_GUIDE.md
  tsconfig.build.json
  tsconfig.eslint.json
  tsconfig.json
database/
  init/
    01-init.sh
    02-seed-cats.sql
docs/
  deployment/
    CUSTOM_DOMAIN_SETUP.md
    DOMAIN_AND_EMAIL_SETUP.md
    GCP_DEPLOYMENT_GUIDE.md
  diagrams/
    project-overview.md
    system-architecture.md
  api-specification.md
  CICD_DEPLOYMENT_FLOW.md
  DATABASE_DEPLOYMENT_GUIDE.md
  DATABASE_PRODUCTION_SCHEMA.md
  EMAIL_INTEGRATION_GUIDE.md
  mycats_pro_å†ç™ºé˜²æ­¢ã‚¬ãƒ¼ãƒ‰æ©Ÿæ§‹_å®Ÿè£…ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸.md
  naming_convention_guidelines_v2.md
  PEDIGREE_PDF_DESIGN.md
  production-deployment.md
  SUPER_ADMIN_SETUP.md
  system-design.md
  ui-button-design-guide.md
  Vertical_Review_Agent_Pronpt
  Vertical_Review_To_Copilot_Agent
frontend/
  scripts/
    generate-api-types.mjs
  src/
    __tests__/
      README.md
    app/
      __tests__/
        page.test.tsx
      accept-invitation/
        page.tsx
      breeding/
        components/
          BirthInfoModal.tsx
          BirthPlanTab.tsx
          BreedingScheduleTab.tsx
          CompleteConfirmModal.tsx
          FemaleSelectionModal.tsx
          index.ts
          MaleSelectionModal.tsx
          NewRuleModal.tsx
          NgRulesModal.tsx
          PregnancyCheckTab.tsx
          RaisingTab.tsx
          ShippingTab.tsx
          WeightTab.tsx
        hooks/
          index.ts
          useBreedingSchedule.ts
          useNgPairing.ts
        page.tsx
        types.ts
        utils.ts
      care/
        page.tsx
      cats/
        [id]/
          edit/
            client.tsx
            page.tsx
          pedigree/
            client.tsx
            page.tsx
          client.tsx
          layout.tsx
          page.tsx
        new/
          page.tsx
        page.tsx
      demo/
        action-buttons/
          page.tsx
        unified-modal/
          page.tsx
      export/
        page.tsx
      forgot-password/
        page.tsx
      gallery/
        components/
          GalleryAddModal.tsx
          GalleryCatCard.tsx
          GalleryGrid.tsx
          GalleryTabs.tsx
          ImageUploader.tsx
          MediaCarousel.tsx
          MediaLightbox.tsx
          YouTubeInput.tsx
        hooks/
          useGalleryTab.ts
        page.tsx
      import/
        page.tsx
      kittens/
        page.tsx
      login/
        page.tsx
      medical-records/
        page.tsx
      more/
        page.tsx
      pedigrees/
        [id]/
          family-tree/
            client.tsx
            page.tsx
          client.tsx
          layout.tsx
          page.tsx
        new/
          page.tsx
        page.tsx
      print-templates/
        page.tsx
      register/
        page.tsx
      reset-password/
        page.tsx
      settings/
        page.tsx
      setup/
        first-superadmin/
          page.tsx
      staff/
        shifts/
          page.tsx
      tags/
        components/
          AutomationIndicator.tsx
          AutomationRuleModal.tsx
          AutomationTab.tsx
          CategoriesTab.tsx
          CategoryModal.tsx
          ExecuteRuleModal.tsx
          GroupModal.tsx
          index.ts
          SortableCategoryCard.tsx
          SortableGroupCard.tsx
          SortableTagItem.tsx
          TagModal.tsx
          TagsListTab.tsx
        hooks/
          index.ts
          useAutomationRulesData.ts
          useTagPageData.ts
        constants.ts
        page.tsx
        types.ts
        utils.ts
      tenants/
        _components/
          ActionMenu.tsx
          BottomNavSettings.tsx
          EditTenantModal.tsx
          InviteTenantAdminModal.tsx
          InviteUserModal.tsx
          TenantsList.tsx
          TenantsManagement.tsx
          UserProfileForm.tsx
          UsersList.tsx
        page.tsx
      CodeCitations.md
      favicon.ico
      globals.css
      layout.tsx
      manifest.ts
      page.module.css
      page.tsx
      providers.tsx
    components/
      __tests__/
        TagSelector.test.tsx
      badges/
        index.ts
      breeding/
        breeding-schedule-edit-modal.tsx
        kitten-disposition-modal.tsx
      buttons/
        IconActionButton.tsx
        index.ts
        PrimaryButton.tsx
      cards/
        CardSpreadDemo.module.css
        CardSpreadDemo.tsx
        CatTexturedCard.module.css
        CatTexturedCard.tsx
        index.ts
      cats/
        cat-edit-modal.tsx
        cat-quick-edit-modal.tsx
        PedigreeTab.tsx
      common/
        __tests__/
          UnifiedModal.test.tsx
        index.ts
        UNIFIED_MODAL_SECTIONS.md
        UnifiedModal.tsx
        UnifiedModalSectionsDemo.tsx
      context-menu/
        context-menu.tsx
        index.ts
        operation-modal-manager.tsx
        use-context-menu.ts
      dashboard/
        __tests__/
          DialNavigation.test.tsx
        DashboardCardSettings.tsx
        DialMenuSettings.tsx
        DialMenuV2.module.css
        DialNavigation.tsx
        DialNavigationExample.tsx
        DialWheel.module.css
        DialWheel.tsx
        DisplayModeToggle.tsx
        HexIconButton.module.css
        HexIconButton.tsx
      editable-field/
        editable-field.tsx
        field-edit-modal.tsx
      forms/
        ColorInputField.tsx
        DateInputField.tsx
        FormField.tsx
        MasterDataCombobox.tsx
      kittens/
        BulkWeightRecordModal.tsx
        KittenManagementModal.tsx
        WeightChart.tsx
        WeightRecordModal.tsx
        WeightRecordTable.tsx
      pedigrees/
        __tests__/
          PedigreeFamilyTree.test.tsx
          PedigreeList.test.tsx
          PedigreeRegistrationForm.callid.test.tsx
          PedigreeRegistrationForm.create.test.tsx
          PedigreeRegistrationForm.update.test.tsx
          PrintSettingsEditor.test.tsx
        PedigreeFamilyTree.tsx
        PedigreeList.tsx
        PedigreeRegistrationForm.tsx
        PrintSettingsEditor.tsx
      print-templates/
        index.ts
        PrintTemplateManager.tsx
      ui/
        InputWithFloatingLabel.module.css
        InputWithFloatingLabel.tsx
        SelectWithFloatingLabel.tsx
        TextareaWithFloatingLabel.tsx
      ActionButton.tsx
      AppLayout.tsx
      GenderBadge.tsx
      PageTitle.tsx
      README.md
      SectionTitle.tsx
      TabsSection.tsx
      TagSelector.tsx
    lib/
      api/
        generated/
          README.md
          schema.ts
        hooks/
          query-key-factory.ts
          use-breeding.ts
          use-breeds.ts
          use-care.ts
          use-cats.ts
          use-coat-colors.ts
          use-gallery-upload.ts
          use-gallery.ts
          use-graduation.ts
          use-master-data.ts
          use-pedigrees.ts
          use-tag-automation.ts
          use-tags.ts
          use-tenant-settings.ts
          use-weight-records.ts
        auth-store.ts
        client.ts
        index.ts
        public-api-base-url.ts
        query-client.tsx
        typesafe-client.ts
      auth/
        password-reset-store.ts
        routes.ts
        store.ts
        useBootstrapAuth.ts
      contexts/
        page-header-context.tsx
      hooks/
        use-bottom-nav-settings.ts
        use-selection-history.ts
      master-data/
        constants.ts
        master-options.ts
      schemas/
        cat.ts
        common.ts
        index.ts
      storage/
        dashboard-settings.ts
      store/
        theme-store.ts
      utils/
        image-resizer.ts
      api.ts
      invitation-utils.ts
    styles/
      page-header.css
    types/
      api.types.ts
    middleware.ts
  .gitignore
  AGENTS.md
  check-syntax.js
  eslint.config.mjs
  GEMINI.md
  jest.config.js
  jest.setup.js
  next.config.ts
  package.json
  postcss.config.mjs
  README.md
  sentry.client.config.ts
  sentry.server.config.ts
  tsconfig.json
nginx/
  conf.d/
    default.conf
  nginx.conf
scripts/
  build-production.sh
  check-memory.mjs
  diagnose.sh
  export-cats-seed.ps1
  export-cats-seed.sh
  generate-secrets.ts
  health-check.sh
  kill-backend.sh
  local-postgres.sh
  preflight-backend.sh
  prestart-migrate.sh
  quick-start.sh
  setup-custom-domain.sh
  setup-dev-docker.bat
  setup-dev-docker.sh
  setup-dev.sh
  setup-domain-and-email.sh
  start-all.bat
  start-all.sh
  start-dev-stable.mjs
  start-dev-stable.sh
  stop-dev.sh
  test-session-persistence.sh
  validate-deployment-config.sh
supabase/
  .gitignore
  config.toml
.dockerignore
.env.development.example
.env.docker.example
.env.production.example
.gitattributes
.gitignore
.trivyignore
AGENTS.md
cloudbuild.yaml
docker-compose.dev.yml
docker-compose.yml
Dockerfile.backend
Dockerfile.frontend
eslint.config.mjs
gcp_verification_results.md
GEMINI.md
IMPLEMENTATION_COMPLETE.md
init_database.sql
package.json
pip_Image.png
pnpm-workspace.yaml
README.md
seed_data.sql
SETUP_GUIDE.md
TROUBLESHOOTING.md
```

# Files

## File: frontend/scripts/generate-api-types.mjs
````javascript
/**
 * OpenAPIå‹å®šç¾©ç”Ÿæˆã‚¹ã‚¯ãƒªãƒ—ãƒˆ
 * ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®Swagger JSONã‹ã‚‰ TypeScript å‹å®šç¾©ã‚’ç”Ÿæˆã—ã¾ã™
 */


/* global process, console */
import { access, writeFile, mkdir } from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath, pathToFileURL } from 'node:url';
import openapiTS, { astToString } from 'openapi-typescript';

const DEFAULT_SCHEMA_PATH = path.join(process.cwd(), '../backend/openapi.json');

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const OUTPUT_PATH = path.join(__dirname, '../src/lib/api/generated/schema.ts');
function createGeneratedBanner() {
  return `/* eslint-disable */
/* tslint:disable */
/**
 * ğŸ”’ ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯è‡ªå‹•ç”Ÿæˆã•ã‚Œã¦ã„ã¾ã™ã€‚
 * ç”Ÿæˆã‚³ãƒãƒ³ãƒ‰: pnpm --filter frontend generate:api-types
 * ç›´æ¥ç·¨é›†ã›ãšã€OpenAPI ã‚¹ã‚­ãƒ¼ãƒã‚’æ›´æ–°ã—ã¦å†ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚
 */
`;
}

function resolveSchemaPath() {
  if (process.env.OPENAPI_SCHEMA_PATH) {
    return path.resolve(process.cwd(), process.env.OPENAPI_SCHEMA_PATH);
  }

  return DEFAULT_SCHEMA_PATH;
}

async function ensureSchemaExists(schemaPath) {
  try {
    await access(schemaPath);
  } catch {
    throw new Error(`OpenAPI ã‚¹ã‚­ãƒ¼ãƒãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${schemaPath}`);
  }
}

async function generateTypes() {
  try {
    console.log('ğŸ”„ OpenAPIå‹å®šç¾©ã‚’ç”Ÿæˆä¸­...');
    const schemaPath = resolveSchemaPath();
    console.log(`ğŸ“„ èª­ã¿è¾¼ã¿ãƒ•ã‚¡ã‚¤ãƒ«: ${schemaPath}`);

    await ensureSchemaExists(schemaPath);

    const outputDir = path.dirname(OUTPUT_PATH);
    await mkdir(outputDir, { recursive: true });

    // TypeScriptå‹å®šç¾©ã‚’ç”Ÿæˆ
    const ast = await openapiTS(pathToFileURL(schemaPath), {
      exportType: true,
      defaultNonNullable: true,
    });
    const generated = astToString(ast);

    const fileContent = `${createGeneratedBanner()}${generated}\n`;

    await writeFile(OUTPUT_PATH, fileContent, 'utf8');

    console.log(`âœ… å‹å®šç¾©ã‚’ç”Ÿæˆã—ã¾ã—ãŸ: ${OUTPUT_PATH}`);
  } catch (error) {
    console.error('âŒ å‹å®šç¾©ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ:', error);
    process.exit(1);
  }
}

generateTypes();
````

## File: frontend/src/__tests__/README.md
````markdown
# Frontend Test Structure

This directory contains the test files for the frontend application.

## Current Test Setup

The test infrastructure is configured using:
- **Jest**: JavaScript testing framework
- **@testing-library/react**: React component testing utilities
- **@testing-library/jest-dom**: Custom Jest matchers for DOM elements

## Test Files

- `src/app/__tests__/page.test.tsx`: Basic smoke tests for the application
- `src/components/__tests__/TagSelector.test.tsx`: Basic tests for components

## Running Tests

```bash
# Run all tests
npm test

# Run tests in watch mode
npm run test:watch

# Run tests with coverage
npm run test:coverage
```

## Adding New Tests

When adding new tests:
1. Create test files in `__tests__` directories within the relevant feature folders
2. Use the `.test.tsx` or `.test.ts` naming convention
3. Import required testing utilities and the component/function being tested
4. Write descriptive test names that explain what is being tested

## Notes

- Tests require MantineProvider wrapper for component testing
- Next.js navigation hooks need to be mocked for page components
- These basic tests ensure CI/CD pipeline doesn't fail when no tests exist
````

## File: frontend/src/app/__tests__/page.test.tsx
````typescript
import '@testing-library/jest-dom'

describe('Frontend Application', () => {
  it('should have a basic test to prevent CI/CD failure', () => {
    // Basic smoke test to ensure Jest is working
    expect(true).toBe(true)
  })

  it('should be able to import testing utilities', () => {
    // Test that testing libraries are properly configured
    expect(expect).toBeDefined()
    expect(typeof expect).toBe('function')
  })
})
````

## File: frontend/src/app/accept-invitation/page.tsx
````typescript
/**
 * æ‹›å¾…å—è«¾ãƒ»ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²å®Œäº†ç”»é¢
 * æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½¿ç”¨ã—ã¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²ã‚’å®Œäº†ã™ã‚‹ãŸã‚ã®ãƒšãƒ¼ã‚¸
 */

'use client'; // ãƒ•ã‚©ãƒ¼ãƒ é€ä¿¡ãŒå¿…è¦ãªãŸã‚ Client Component

import { useState, Suspense, useEffect, useMemo, useCallback, useRef, type CSSProperties } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import {
  Container,
  Paper,
  Title,
  TextInput,
  PasswordInput,
  Button,
  Alert,
  Stack,
  Center,
  Box,
  Text,
  Loader,
  List,
  ThemeIcon,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { IconAlertCircle, IconCheck, IconX } from '@tabler/icons-react';
import { apiRequest, setTokens } from '@/lib/api/client';
import { useAuthStore } from '@/lib/auth/store';

// å…±é€šã‚¹ã‚¿ã‚¤ãƒ«å®šç¾©
const PAGE_BACKGROUND_STYLE: CSSProperties = {
  minHeight: '100vh',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  background: 'linear-gradient(135deg, #eef2ff 0%, #e1f1ff 100%)',
  padding: '1rem',
};

const CARD_SHADOW_STYLE: CSSProperties = {
  width: '100%',
  boxShadow: '0 16px 40px rgba(15, 23, 42, 0.08)',
};

const TITLE_STYLE: CSSProperties = {
  color: 'var(--text-primary)',
  fontSize: 18,
  display: 'flex',
  flexDirection: 'column',
  gap: 4,
};

// å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å…±é€šã‚¹ã‚¿ã‚¤ãƒ«
const INPUT_STYLES = {
  label: { color: 'var(--text-secondary)', fontWeight: 500 },
  input: { backgroundColor: 'var(--surface)' },
};

/**
 * ãƒ­ã‚´ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆï¼ˆé‡è¤‡ã‚’é¿ã‘ã‚‹ãŸã‚å…±é€šåŒ–ï¼‰
 */
function Logo({ subtitle }: { subtitle: string }) {
  return (
    <Title order={2} ta="center" mb="md" style={TITLE_STYLE}>
      <span style={{ fontSize: '3.5rem', lineHeight: 1, display: 'block' }}>ğŸˆ</span>
      <span style={{ fontSize: 18, fontWeight: 700 }}>{subtitle}</span>
    </Title>
  );
}

interface AcceptInvitationFormValues {
  password: string;
  confirmPassword: string;
  firstName: string;
  lastName: string;
}

interface CompleteInvitationRequest {
  token: string;
  password: string;
  firstName?: string;
  lastName?: string;
}

interface CompleteInvitationResponse {
  success: boolean;
  userId?: string;
  tenantId?: string;
  access_token?: string;
  message?: string;
}

/**
 * ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰è¦ä»¶ã‚’æ¤œè¨¼ã™ã‚‹
 */
function validatePasswordRequirements(password: string) {
  return {
    minLength: password.length >= 8,
    hasLowercase: /[a-z]/.test(password),
    hasUppercase: /[A-Z]/.test(password),
    hasNumber: /[0-9]/.test(password),
  };
}

/**
 * ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰è¦ä»¶ã®è¡¨ç¤ºã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 */
function PasswordRequirements({ password }: { password: string }) {
  const requirements = validatePasswordRequirements(password);

  const items = [
    { label: '8æ–‡å­—ä»¥ä¸Š', met: requirements.minLength },
    { label: 'å°æ–‡å­—ã‚’å«ã‚€ (a-z)', met: requirements.hasLowercase },
    { label: 'å¤§æ–‡å­—ã‚’å«ã‚€ (A-Z)', met: requirements.hasUppercase },
    { label: 'æ•°å­—ã‚’å«ã‚€ (0-9)', met: requirements.hasNumber },
  ];

  return (
    <List spacing="xs" size="sm">
      {items.map((item) => (
        <List.Item
          key={item.label}
          icon={
            <ThemeIcon
              color={item.met ? 'teal' : 'gray'}
              size={20}
              radius="xl"
            >
              {item.met ? <IconCheck size={12} /> : <IconX size={12} />}
            </ThemeIcon>
          }
          style={{ color: item.met ? 'var(--text-secondary)' : 'var(--text-muted)' }}
        >
          {item.label}
        </List.Item>
      ))}
    </List>
  );
}

function AcceptInvitationForm() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const bootstrap = useAuthStore((state) => state.bootstrap);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);

  // ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—
  const token = searchParams?.get('token') ?? null;

  // ãƒˆãƒ¼ã‚¯ãƒ³ãŒãªã„å ´åˆã®ã‚¨ãƒ©ãƒ¼çŠ¶æ…‹
  const [tokenError, setTokenError] = useState<string | null>(null);

  useEffect(() => {
    if (!token) {
      setTokenError('æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚æ‹›å¾…ãƒ¡ãƒ¼ãƒ«ã®ãƒªãƒ³ã‚¯ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
    }
  }, [token]);

  // ãƒ•ã‚©ãƒ¼ãƒ è¨­å®š
  const form = useForm<AcceptInvitationFormValues>({
    initialValues: {
      password: '',
      confirmPassword: '',
      firstName: '',
      lastName: '',
    },
    validate: {
      password: (value) => {
        if (!value) return 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„';
        const requirements = validatePasswordRequirements(value);
        if (!requirements.minLength) return 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯8æ–‡å­—ä»¥ä¸Šã§å…¥åŠ›ã—ã¦ãã ã•ã„';
        if (!requirements.hasLowercase) return 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã«å°æ–‡å­—ã‚’å«ã‚ã¦ãã ã•ã„';
        if (!requirements.hasUppercase) return 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã«å¤§æ–‡å­—ã‚’å«ã‚ã¦ãã ã•ã„';
        if (!requirements.hasNumber) return 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã«æ•°å­—ã‚’å«ã‚ã¦ãã ã•ã„';
        return null;
      },
      confirmPassword: (value, values) => {
        if (!value) return 'ç¢ºèªç”¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„';
        if (value !== values.password) return 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒä¸€è‡´ã—ã¾ã›ã‚“';
        return null;
      },
    },
  });

  // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã®çŠ¶æ…‹ï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ï¼‰
  const passwordValue = form.values.password;
  const passwordRequirements = useMemo(
    () => validatePasswordRequirements(passwordValue),
    [passwordValue]
  );
  const allRequirementsMet = useMemo(
    () =>
      passwordRequirements.minLength &&
      passwordRequirements.hasLowercase &&
      passwordRequirements.hasUppercase &&
      passwordRequirements.hasNumber,
    [passwordRequirements]
  );

  // ã‚¿ã‚¤ãƒãƒ¼ç®¡ç†ç”¨ã®refï¼ˆã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚¢ãƒ³ãƒã‚¦ãƒ³ãƒˆæ™‚ã«ã‚¯ãƒªã‚¢ï¼‰
  const redirectTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  // æˆåŠŸå¾Œã®ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆå‡¦ç†
  const handleRedirectToHome = useCallback(() => {
    router.push('/');
  }, [router]);

  // æˆåŠŸæ™‚ã®ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã‚¿ã‚¤ãƒãƒ¼è¨­å®š
  useEffect(() => {
    if (success) {
      redirectTimerRef.current = setTimeout(() => {
        handleRedirectToHome();
      }, 2000);
    }

    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–¢æ•°ã§ã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚¯ãƒªã‚¢
    return () => {
      if (redirectTimerRef.current) {
        clearTimeout(redirectTimerRef.current);
        redirectTimerRef.current = null;
      }
    };
  }, [success, handleRedirectToHome]);

  // ç™»éŒ²å®Œäº†å‡¦ç†
  const handleSubmit = async (values: AcceptInvitationFormValues) => {
    if (!token) {
      setError('æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
      return;
    }

    setIsSubmitting(true);
    setError(null);

    try {
      const payload: CompleteInvitationRequest = {
        token,
        password: values.password,
      };

      // ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯å€¤ãŒã‚ã‚‹å ´åˆã®ã¿è¿½åŠ 
      if (values.firstName.trim()) {
        payload.firstName = values.firstName.trim();
      }
      if (values.lastName.trim()) {
        payload.lastName = values.lastName.trim();
      }

      const response = await apiRequest<CompleteInvitationResponse>(
        '/tenants/complete-invitation',
        {
          method: 'POST',
          body: JSON.stringify(payload),
        },
        false // èªè¨¼ä¸è¦
      );

      if (response.success && response.data) {
        const data = response.data;
        
        // API ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã¯ snake_case (access_token) ã ãŒã€TypeScript å¤‰æ•°åã¯ camelCase (accessToken) ã‚’ä½¿ç”¨
        const accessToken = data.access_token;
        if (accessToken && typeof accessToken === 'string') {
          // ç¬¬2å¼•æ•°ã® null ã¯ refreshTokenï¼ˆæ‹›å¾…ç™»éŒ²ã§ã¯ refresh token ã¯è¿”ã•ã‚Œãªã„ï¼‰
          setTokens(accessToken, null);
          
          // auth store ã‚’ bootstrapï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã¯å¾Œã§ /me ãªã©ã§å–å¾—ã•ã‚Œã‚‹æƒ³å®šï¼‰
          await bootstrap({
            accessToken,
          });
          
          setSuccess(true);
          // ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã¯ useEffect å†…ã§å‡¦ç†
        } else {
          // ç™»éŒ²ã¯æˆåŠŸã—ãŸãŒèªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ãŒå–å¾—ã§ããªã‹ã£ãŸå ´åˆ
          // ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«èª˜å°
          setError('ç™»éŒ²ã¯å®Œäº†ã—ã¾ã—ãŸãŒã€è‡ªå‹•ãƒ­ã‚°ã‚¤ãƒ³ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã‹ã‚‰ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„ã€‚');
        }
      } else {
        setError(response.message || 'ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }
    } catch (err) {
      console.error('Complete invitation error:', err);
      if (err instanceof Error) {
        setError(err.message);
      } else {
        setError('ç™»éŒ²ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚');
      }
    } finally {
      setIsSubmitting(false);
    }
  };

  // ãƒˆãƒ¼ã‚¯ãƒ³ã‚¨ãƒ©ãƒ¼ã®å ´åˆ
  if (tokenError) {
    return (
      <Box style={PAGE_BACKGROUND_STYLE}>
        <Container size={420}>
          <Paper
            shadow="md"
            p="xl"
            radius="lg"
            style={CARD_SHADOW_STYLE}
          >
            <Logo subtitle="MyCats æ‹›å¾…" />
            <Alert
              icon={<IconAlertCircle size={16} />}
              title="ã‚¨ãƒ©ãƒ¼"
              color="red"
              mt="md"
            >
              {tokenError}
            </Alert>
            <Button
              fullWidth
              mt="xl"
              onClick={() => router.push('/login')}
              variant="outline"
            >
              ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã¸
            </Button>
          </Paper>
        </Container>
      </Box>
    );
  }

  return (
    <Box style={PAGE_BACKGROUND_STYLE}>
      <Container size={420}>
        <Center>
          <Stack gap="lg" style={{ width: '100%' }}>
            {/* ãƒ­ã‚´ãƒ»ã‚¿ã‚¤ãƒˆãƒ« */}
            <Paper
              shadow="md"
              p="xl"
              radius="lg"
              style={CARD_SHADOW_STYLE}
            >
              <Logo subtitle="MyCats æ‹›å¾…ç™»éŒ²" />
              <Text size="sm" ta="center" mb="xl" style={{ color: 'var(--text-muted)' }}>
                æ‹›å¾…ã‚’å—è«¾ã—ã¦ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ä½œæˆ
              </Text>

              {/* æˆåŠŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ */}
              {success && (
                <Alert
                  icon={<IconCheck size={16} />}
                  title="ç™»éŒ²å®Œäº†ï¼"
                  color="green"
                  mb="md"
                >
                  ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãŒä½œæˆã•ã‚Œã¾ã—ãŸã€‚ãƒ›ãƒ¼ãƒ ãƒšãƒ¼ã‚¸ã¸ç§»å‹•ã—ã¾ã™...
                </Alert>
              )}

              {/* ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ */}
              {error && (
                <Stack gap="md">
                  <Alert
                    icon={<IconAlertCircle size={16} />}
                    title="ã‚¨ãƒ©ãƒ¼"
                    color="red"
                    withCloseButton
                    onClose={() => setError(null)}
                  >
                    {error}
                  </Alert>
                  <Button
                    variant="outline"
                    onClick={() => router.push('/login')}
                  >
                    ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã¸
                  </Button>
                </Stack>
              )}

              {!success && (
                <form onSubmit={form.onSubmit(handleSubmit)}>
                  <Stack gap="md">
                    {/* å§“ */}
                    <TextInput
                      label="å§“"
                      placeholder="å±±ç”°"
                      styles={INPUT_STYLES}
                      {...form.getInputProps('lastName')}
                    />

                    {/* å */}
                    <TextInput
                      label="å"
                      placeholder="å¤ªéƒ"
                      styles={INPUT_STYLES}
                      {...form.getInputProps('firstName')}
                    />

                    {/* ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ */}
                    <PasswordInput
                      label="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰"
                      placeholder="8æ–‡å­—ä»¥ä¸Š"
                      required
                      styles={INPUT_STYLES}
                      {...form.getInputProps('password')}
                    />

                    {/* ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰è¦ä»¶ã®è¡¨ç¤º */}
                    {passwordValue && (
                      <Box pl="xs">
                        <PasswordRequirements password={passwordValue} />
                      </Box>
                    )}

                    {/* ç¢ºèªç”¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ */}
                    <PasswordInput
                      label="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼ˆç¢ºèªï¼‰"
                      placeholder="ã‚‚ã†ä¸€åº¦å…¥åŠ›"
                      required
                      styles={INPUT_STYLES}
                      {...form.getInputProps('confirmPassword')}
                    />

                    {/* ç™»éŒ²ãƒœã‚¿ãƒ³ */}
                    <Button
                      type="submit"
                      fullWidth
                      mt="md"
                      loading={isSubmitting}
                      disabled={isSubmitting || !allRequirementsMet}
                      style={{ background: 'var(--accent)', boxShadow: '0 8px 20px rgba(37, 99, 235, 0.25)' }}
                    >
                      ç™»éŒ²ã‚’å®Œäº†
                    </Button>
                  </Stack>
                </form>
              )}
            </Paper>

            {/* ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰è¦ä»¶ã®ãƒ˜ãƒ«ãƒ— */}
            <Paper
              shadow="sm"
              p="md"
              radius="lg"
              style={{ backgroundColor: 'rgba(255, 255, 255, 0.9)', backdropFilter: 'blur(4px)' }}
            >
              <Text size="xs" ta="center" mb="xs" fw={700} style={{ color: 'var(--text-secondary)' }}>
                ğŸ” ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰è¦ä»¶
              </Text>
              <Stack gap={4}>
                <Text size="xs" style={{ color: 'var(--text-secondary)' }}>
                  âœ“ 8æ–‡å­—ä»¥ä¸Š
                </Text>
                <Text size="xs" style={{ color: 'var(--text-secondary)' }}>
                  âœ“ å°æ–‡å­—ã‚’å«ã‚€ (a-z)
                </Text>
                <Text size="xs" style={{ color: 'var(--text-secondary)' }}>
                  âœ“ å¤§æ–‡å­—ã‚’å«ã‚€ (A-Z)
                </Text>
                <Text size="xs" style={{ color: 'var(--text-secondary)' }}>
                  âœ“ æ•°å­—ã‚’å«ã‚€ (0-9)
                </Text>
              </Stack>
            </Paper>
          </Stack>
        </Center>
      </Container>
    </Box>
  );
}

export default function AcceptInvitationPage() {
  return (
    <Suspense
      fallback={
        <Box
          style={{
            minHeight: '100vh',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            background: 'linear-gradient(135deg, #eef2ff 0%, #e1f1ff 100%)',
          }}
        >
          <Loader size="lg" />
        </Box>
      }
    >
      <AcceptInvitationForm />
    </Suspense>
  );
}
````

## File: frontend/src/app/breeding/components/index.ts
````typescript
export { BreedingScheduleTab } from './BreedingScheduleTab';
export type { BreedingScheduleTabProps } from './BreedingScheduleTab';

export { PregnancyCheckTab } from './PregnancyCheckTab';
export type { PregnancyCheckTabProps } from './PregnancyCheckTab';

export { BirthPlanTab } from './BirthPlanTab';
export type { BirthPlanTabProps } from './BirthPlanTab';

export { RaisingTab } from './RaisingTab';
export type { RaisingTabProps } from './RaisingTab';

export { WeightTab } from './WeightTab';
export type { WeightTabProps } from './WeightTab';

export { ShippingTab } from './ShippingTab';
export type { ShippingTabProps } from './ShippingTab';

export { MaleSelectionModal } from './MaleSelectionModal';
export type { MaleSelectionModalProps } from './MaleSelectionModal';

export { FemaleSelectionModal } from './FemaleSelectionModal';
export type { FemaleSelectionModalProps } from './FemaleSelectionModal';

export { BirthInfoModal } from './BirthInfoModal';
export type { BirthInfoModalProps } from './BirthInfoModal';

export { NgRulesModal } from './NgRulesModal';
export type { NgRulesModalProps } from './NgRulesModal';

export { NewRuleModal } from './NewRuleModal';
export type { NewRuleModalProps } from './NewRuleModal';

export { CompleteConfirmModal } from './CompleteConfirmModal';
export type { CompleteConfirmModalProps } from './CompleteConfirmModal';
````

## File: frontend/src/app/breeding/hooks/index.ts
````typescript
export { useBreedingSchedule } from './useBreedingSchedule';
export type { UseBreedingScheduleReturn } from './useBreedingSchedule';
export { useNgPairing } from './useNgPairing';
export type { UseNgPairingParams, UseNgPairingReturn } from './useNgPairing';

// API ãƒ•ãƒƒã‚¯ã®å†ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆï¼ˆä½¿ã„ã‚„ã™ã•ã®ãŸã‚ï¼‰
export {
  useGetBreedingSchedules,
  useCreateBreedingSchedule,
  useUpdateBreedingSchedule,
  useDeleteBreedingSchedule,
  useGetMatingChecks,
  useCreateMatingCheck,
  useUpdateMatingCheck,
  useDeleteMatingCheck,
  breedingScheduleKeys,
  matingCheckKeys,
} from '@/lib/api/hooks/use-breeding';

export type {
  BreedingSchedule,
  BreedingScheduleStatus,
  BreedingScheduleListResponse,
  CreateBreedingScheduleRequest,
  UpdateBreedingScheduleRequest,
  BreedingScheduleQueryParams,
  MatingCheck,
  CreateMatingCheckRequest,
  UpdateMatingCheckRequest,
} from '@/lib/api/hooks/use-breeding';
````

## File: frontend/src/app/breeding/hooks/useBreedingSchedule.ts
````typescript
/**
 * äº¤é…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«çŠ¶æ…‹ç®¡ç†ãƒ•ãƒƒã‚¯
 * 
 * localStorage ã«ã‚ˆã‚‹ãƒ­ãƒ¼ã‚«ãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã¨ API åŒæœŸã®ä¸¡æ–¹ã‚’ã‚µãƒãƒ¼ãƒˆã€‚
 * - ã‚ªãƒ³ãƒ©ã‚¤ãƒ³æ™‚: API ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã€localStorage ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥
 * - ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ™‚: localStorage ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
 * - æ–°è¦ä½œæˆ/æ›´æ–°/å‰Šé™¤: API çµŒç”±ã§å®Ÿè¡Œã—ã€æˆåŠŸæ™‚ã« localStorage ã‚’æ›´æ–°
 */

import { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import type { Cat } from '@/lib/api/hooks/use-cats';
import {
  useGetBreedingSchedules,
  useCreateBreedingSchedule,
  useUpdateBreedingSchedule,
  useDeleteBreedingSchedule,
  useCreateMatingCheck,
  type BreedingSchedule,
  type CreateBreedingScheduleRequest,
  type UpdateBreedingScheduleRequest,
  type CreateMatingCheckRequest,
} from '@/lib/api/hooks/use-breeding';
import type { BreedingScheduleEntry } from '../types';
import { STORAGE_KEYS } from '../types';

export interface UseBreedingScheduleReturn {
  // çŠ¶æ…‹
  breedingSchedule: Record<string, BreedingScheduleEntry>;
  matingChecks: Record<string, number>;
  activeMales: Cat[];
  selectedYear: number;
  selectedMonth: number;
  defaultDuration: number;
  
  // API çŠ¶æ…‹
  isLoading: boolean;
  isSyncing: boolean;
  
  // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
  setBreedingSchedule: React.Dispatch<React.SetStateAction<Record<string, BreedingScheduleEntry>>>;
  setMatingChecks: React.Dispatch<React.SetStateAction<Record<string, number>>>;
  setActiveMales: React.Dispatch<React.SetStateAction<Cat[]>>;
  setSelectedYear: React.Dispatch<React.SetStateAction<number>>;
  setSelectedMonth: React.Dispatch<React.SetStateAction<number>>;
  setDefaultDuration: React.Dispatch<React.SetStateAction<number>>;
  
  // ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
  addMale: (male: Cat) => void;
  removeMale: (maleId: string) => void;
  getMatingCheckCount: (maleId: string, femaleId: string, date: string) => number;
  addMatingCheck: (maleId: string, femaleId: string, date: string) => void;
  clearScheduleData: () => void;
  
  // API åŒæœŸé–¢æ•°
  createScheduleOnServer: (entry: BreedingScheduleEntry) => Promise<void>;
  updateScheduleOnServer: (scheduleId: string, updates: UpdateBreedingScheduleRequest) => Promise<void>;
  deleteScheduleOnServer: (scheduleId: string) => Promise<void>;
  syncFromServer: () => Promise<void>;
}

/**
 * ã‚µãƒ¼ãƒãƒ¼ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ­ãƒ¼ã‚«ãƒ«å½¢å¼ã«å¤‰æ›
 */
function convertServerScheduleToLocal(
  schedule: BreedingSchedule
): Record<string, BreedingScheduleEntry> {
  const result: Record<string, BreedingScheduleEntry> = {};
  const startDate = new Date(schedule.startDate);
  
  for (let i = 0; i < schedule.duration; i++) {
    const currentDate = new Date(startDate);
    currentDate.setDate(startDate.getDate() + i);
    const dateStr = currentDate.toISOString().split('T')[0];
    const scheduleKey = `${schedule.maleId}-${dateStr}`;
    
    result[scheduleKey] = {
      maleId: schedule.maleId,
      maleName: schedule.male?.name ?? '',
      femaleId: schedule.femaleId,
      femaleName: schedule.female?.name ?? '',
      date: dateStr,
      duration: schedule.duration,
      dayIndex: i,
      isHistory: schedule.status === 'COMPLETED' || schedule.status === 'CANCELLED',
      result: schedule.status === 'COMPLETED' ? 'æˆåŠŸ' : schedule.status === 'CANCELLED' ? 'å¤±æ•—' : undefined,
      // ã‚µãƒ¼ãƒãƒ¼å´ã® ID ã‚’ä¿æŒï¼ˆæ›´æ–°/å‰Šé™¤æ™‚ã«ä½¿ç”¨ï¼‰
      serverId: schedule.id,
    };
  }
  
  return result;
}

/**
 * ã‚µãƒ¼ãƒãƒ¼ã®äº¤é…ãƒã‚§ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ­ãƒ¼ã‚«ãƒ«å½¢å¼ã«å¤‰æ›
 */
function convertServerChecksToLocal(
  schedules: BreedingSchedule[]
): Record<string, number> {
  const result: Record<string, number> = {};
  
  for (const schedule of schedules) {
    if (!schedule.checks) continue;
    
    for (const check of schedule.checks) {
      const checkDate = new Date(check.checkDate).toISOString().split('T')[0];
      const key = `${schedule.maleId}-${schedule.femaleId}-${checkDate}`;
      result[key] = (result[key] || 0) + check.count;
    }
  }
  
  return result;
}

export function useBreedingSchedule(): UseBreedingScheduleReturn {
  // hydration guard: åˆå›ãƒã‚¦ãƒ³ãƒˆæ™‚ã« localStorage ã‹ã‚‰èª­ã¿è¾¼ã‚€ã¾ã§ä¿å­˜ã‚’æŠ‘åˆ¶
  const hydratedRef = useRef(false);
  const mountCountRef = useRef(0);

  const [selectedMonth, setSelectedMonth] = useState(new Date().getMonth() + 1);
  const [selectedYear, setSelectedYear] = useState(new Date().getFullYear());
  const [breedingSchedule, setBreedingSchedule] = useState<Record<string, BreedingScheduleEntry>>({});
  const [activeMales, setActiveMales] = useState<Cat[]>([]);
  const [defaultDuration, setDefaultDuration] = useState<number>(1);
  const [matingChecks, setMatingChecks] = useState<Record<string, number>>({});
  const [isSyncing, setIsSyncing] = useState(false);

  // API ãƒ•ãƒƒã‚¯
  const schedulesQuery = useGetBreedingSchedules({}, { enabled: true });
  const createScheduleMutation = useCreateBreedingSchedule();
  const updateScheduleMutation = useUpdateBreedingSchedule();
  const deleteScheduleMutation = useDeleteBreedingSchedule();
  const createMatingCheckMutation = useCreateMatingCheck();

  // localStorageã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€
  useEffect(() => {
    const loadFromStorage = () => {
      try {
        const storedActiveMales = localStorage.getItem(STORAGE_KEYS.ACTIVE_MALES);
        if (storedActiveMales) {
          const parsed = JSON.parse(storedActiveMales) as Cat[];
          setActiveMales(parsed);
        }

        const storedDefaultDuration = localStorage.getItem(STORAGE_KEYS.DEFAULT_DURATION);
        if (storedDefaultDuration) {
          const parsed = parseInt(storedDefaultDuration, 10);
          setDefaultDuration(parsed);
        }

        const storedYear = localStorage.getItem(STORAGE_KEYS.SELECTED_YEAR);
        if (storedYear) {
          const parsed = parseInt(storedYear, 10);
          setSelectedYear(parsed);
        }

        const storedMonth = localStorage.getItem(STORAGE_KEYS.SELECTED_MONTH);
        if (storedMonth) {
          const parsed = parseInt(storedMonth, 10);
          setSelectedMonth(parsed);
        }

        // ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨äº¤é…ãƒã‚§ãƒƒã‚¯ã¯ API ã‹ã‚‰å–å¾—ã™ã‚‹ãŒã€
        // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ™‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¨ã—ã¦ localStorage ã‹ã‚‰ã‚‚èª­ã¿è¾¼ã‚€
        const storedBreedingSchedule = localStorage.getItem(STORAGE_KEYS.BREEDING_SCHEDULE);
        if (storedBreedingSchedule) {
          const parsed = JSON.parse(storedBreedingSchedule) as Record<string, BreedingScheduleEntry>;
          setBreedingSchedule(parsed);
        }

        const storedMatingChecks = localStorage.getItem(STORAGE_KEYS.MATING_CHECKS);
        if (storedMatingChecks) {
          const parsed = JSON.parse(storedMatingChecks) as Record<string, number>;
          setMatingChecks(parsed);
        }
      } catch (error) {
        console.warn('Failed to load breeding data from localStorage:', error);
      }
    };

    loadFromStorage();
    
    // setTimeoutã§hydratedRefã‚’trueã«ã™ã‚‹
    setTimeout(() => {
      hydratedRef.current = true;
    }, 0);
  }, []);

  // API ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¦ãƒ­ãƒ¼ã‚«ãƒ«çŠ¶æ…‹ã‚’æ›´æ–°
  useEffect(() => {
    if (!schedulesQuery.data?.data) return;
    
    const serverSchedules = schedulesQuery.data.data;
    
    // ã‚µãƒ¼ãƒãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ­ãƒ¼ã‚«ãƒ«å½¢å¼ã«å¤‰æ›
    let mergedSchedule: Record<string, BreedingScheduleEntry> = {};
    for (const schedule of serverSchedules) {
      const localEntries = convertServerScheduleToLocal(schedule);
      mergedSchedule = { ...mergedSchedule, ...localEntries };
    }
    
    // ãƒ­ãƒ¼ã‚«ãƒ«ã® serverId ãŒãªã„ã‚¨ãƒ³ãƒˆãƒªï¼ˆã¾ã ã‚µãƒ¼ãƒãƒ¼ã«ä¿å­˜ã•ã‚Œã¦ã„ãªã„ï¼‰ã‚’ä¿æŒ
    setBreedingSchedule(prev => {
      const localOnlyEntries: Record<string, BreedingScheduleEntry> = {};
      for (const [key, entry] of Object.entries(prev)) {
        if (!entry.serverId) {
          localOnlyEntries[key] = entry;
        }
      }
      return { ...mergedSchedule, ...localOnlyEntries };
    });
    
    // äº¤é…ãƒã‚§ãƒƒã‚¯ã‚‚åŒæœŸ
    const serverChecks = convertServerChecksToLocal(serverSchedules);
    setMatingChecks(prev => ({ ...prev, ...serverChecks }));
    
  }, [schedulesQuery.data]);

  // ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ãƒã‚¦ãƒ³ãƒˆ/ã‚¢ãƒ³ãƒã‚¦ãƒ³ãƒˆã‚’è¿½è·¡
  useEffect(() => {
    mountCountRef.current += 1;
    return () => {
      hydratedRef.current = false;
    };
  }, []);

  // localStorageã«ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã™ã‚‹
  useEffect(() => {
    const saveToStorage = () => {
      if (!hydratedRef.current) return;

      try {
        localStorage.setItem(STORAGE_KEYS.ACTIVE_MALES, JSON.stringify(activeMales));
        localStorage.setItem(STORAGE_KEYS.DEFAULT_DURATION, defaultDuration.toString());
        localStorage.setItem(STORAGE_KEYS.SELECTED_YEAR, selectedYear.toString());
        localStorage.setItem(STORAGE_KEYS.SELECTED_MONTH, selectedMonth.toString());
        if (Object.keys(breedingSchedule).length > 0) {
          localStorage.setItem(STORAGE_KEYS.BREEDING_SCHEDULE, JSON.stringify(breedingSchedule));
        }
        localStorage.setItem(STORAGE_KEYS.MATING_CHECKS, JSON.stringify(matingChecks));
      } catch (error) {
        console.warn('Failed to save breeding data to localStorage:', error);
      }
    };

    saveToStorage();
  }, [activeMales, defaultDuration, selectedYear, selectedMonth, breedingSchedule, matingChecks]);

  // ã‚ªã‚¹çŒ«è¿½åŠ 
  const addMale = useCallback((male: Cat) => {
    setActiveMales((prev) => [...prev, male]);
  }, []);

  // ã‚ªã‚¹çŒ«å‰Šé™¤
  const removeMale = useCallback((maleId: string) => {
    setActiveMales((prev) => prev.filter((m) => m.id !== maleId));
  }, []);

  // äº¤é…ãƒã‚§ãƒƒã‚¯å›æ•°ã‚’å–å¾—
  const getMatingCheckCount = useCallback((maleId: string, femaleId: string, date: string): number => {
    const key = `${maleId}-${femaleId}-${date}`;
    return matingChecks[key] || 0;
  }, [matingChecks]);

  // äº¤é…ãƒã‚§ãƒƒã‚¯ã‚’è¿½åŠ ï¼ˆãƒ­ãƒ¼ã‚«ãƒ« + APIï¼‰
  const addMatingCheck = useCallback((maleId: string, femaleId: string, date: string) => {
    const key = `${maleId}-${femaleId}-${date}`;
    
    // ãƒ­ãƒ¼ã‚«ãƒ«çŠ¶æ…‹ã‚’å³åº§ã«æ›´æ–°
    setMatingChecks((prev) => ({
      ...prev,
      [key]: (prev[key] || 0) + 1
    }));
    
    // å¯¾å¿œã™ã‚‹ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã® serverId ã‚’æ¢ã™
    const scheduleKey = `${maleId}-${date}`;
    const scheduleEntry = breedingSchedule[scheduleKey];
    
    if (scheduleEntry?.serverId) {
      // ã‚µãƒ¼ãƒãƒ¼ã«äº¤é…ãƒã‚§ãƒƒã‚¯ã‚’è¿½åŠ 
      const payload: CreateMatingCheckRequest = {
        checkDate: date,
        count: 1,
      };
      
      createMatingCheckMutation.mutate({
        scheduleId: scheduleEntry.serverId,
        payload,
      });
    }
  }, [breedingSchedule, createMatingCheckMutation]);

  // ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢
  const clearScheduleData = useCallback(() => {
    localStorage.removeItem(STORAGE_KEYS.BREEDING_SCHEDULE);
    localStorage.removeItem(STORAGE_KEYS.MATING_CHECKS);
    setBreedingSchedule({});
    setMatingChecks({});
  }, []);

  // ã‚µãƒ¼ãƒãƒ¼ã«ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½œæˆ
  const createScheduleOnServer = useCallback(async (entry: BreedingScheduleEntry) => {
    const payload: CreateBreedingScheduleRequest = {
      maleId: entry.maleId,
      femaleId: entry.femaleId,
      startDate: entry.date,
      duration: entry.duration,
      status: 'SCHEDULED',
    };
    
    try {
      setIsSyncing(true);
      await createScheduleMutation.mutateAsync(payload);
      // æˆåŠŸæ™‚ã¯ schedulesQuery ãŒè‡ªå‹•çš„ã«å†å–å¾—ã•ã‚Œã‚‹
    } finally {
      setIsSyncing(false);
    }
  }, [createScheduleMutation]);

  // ã‚µãƒ¼ãƒãƒ¼ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ›´æ–°
  const updateScheduleOnServer = useCallback(async (scheduleId: string, updates: UpdateBreedingScheduleRequest) => {
    try {
      setIsSyncing(true);
      await updateScheduleMutation.mutateAsync({ id: scheduleId, payload: updates });
    } finally {
      setIsSyncing(false);
    }
  }, [updateScheduleMutation]);

  // ã‚µãƒ¼ãƒãƒ¼ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‰Šé™¤
  const deleteScheduleOnServer = useCallback(async (scheduleId: string) => {
    try {
      setIsSyncing(true);
      await deleteScheduleMutation.mutateAsync(scheduleId);
    } finally {
      setIsSyncing(false);
    }
  }, [deleteScheduleMutation]);

  // ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å†å–å¾—
  const syncFromServer = useCallback(async () => {
    try {
      setIsSyncing(true);
      await schedulesQuery.refetch();
    } finally {
      setIsSyncing(false);
    }
  }, [schedulesQuery]);

  // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹
  const isLoading = useMemo(() => {
    return schedulesQuery.isLoading || 
           createScheduleMutation.isPending || 
           updateScheduleMutation.isPending || 
           deleteScheduleMutation.isPending;
  }, [
    schedulesQuery.isLoading,
    createScheduleMutation.isPending,
    updateScheduleMutation.isPending,
    deleteScheduleMutation.isPending,
  ]);

  return {
    breedingSchedule,
    matingChecks,
    activeMales,
    selectedYear,
    selectedMonth,
    defaultDuration,
    isLoading,
    isSyncing,
    setBreedingSchedule,
    setMatingChecks,
    setActiveMales,
    setSelectedYear,
    setSelectedMonth,
    setDefaultDuration,
    addMale,
    removeMale,
    getMatingCheckCount,
    addMatingCheck,
    clearScheduleData,
    createScheduleOnServer,
    updateScheduleOnServer,
    deleteScheduleOnServer,
    syncFromServer,
  };
}
````

## File: frontend/src/app/breeding/hooks/useNgPairing.ts
````typescript
/**
 * NGãƒšã‚¢ãƒªãƒ³ã‚°åˆ¤å®šãƒ•ãƒƒã‚¯
 */

import { useCallback } from 'react';
import type { Cat } from '@/lib/api/hooks/use-cats';
import type { NgPairingRule } from '../types';

export interface UseNgPairingParams {
  activeMales: Cat[];
  allCats: Cat[];
  ngPairingRules: NgPairingRule[];
}

export interface UseNgPairingReturn {
  isNGPairing: (maleId: string, femaleId: string) => boolean;
  findMatchingRule: (maleId: string, femaleId: string) => NgPairingRule | undefined;
}

export function useNgPairing({
  activeMales,
  allCats,
  ngPairingRules,
}: UseNgPairingParams): UseNgPairingReturn {
  
  const isNGPairing = useCallback((maleId: string, femaleId: string): boolean => {
    const male = activeMales.find((m) => m.id === maleId);
    const female = allCats.find((f) => f.id === femaleId);
    
    if (!male || !female) return false;
    
    const maleTags = male.tags?.map((catTag) => catTag.tag.name) ?? [];
    const femaleTags = female.tags?.map((catTag) => catTag.tag.name) ?? [];
    
    return ngPairingRules.some((rule) => {
      if (!rule.active) return false;
      
      if (rule.type === 'TAG_COMBINATION' && rule.maleConditions && rule.femaleConditions) {
        const maleMatches = rule.maleConditions.some((condition) => maleTags.includes(condition));
        const femaleMatches = rule.femaleConditions.some((condition) => femaleTags.includes(condition));
        return maleMatches && femaleMatches;
      }
      
      if (rule.type === 'INDIVIDUAL_PROHIBITION' && rule.maleNames && rule.femaleNames) {
        return rule.maleNames.includes(male.name) && rule.femaleNames.includes(female.name);
      }
      
      // generation_limit ã®å®Ÿè£…ï¼ˆå°†æ¥çš„ã«pedigreeæ©Ÿèƒ½é€£æºï¼‰
      if (rule.type === 'GENERATION_LIMIT') {
        return false;
      }
      
      return false;
    });
  }, [activeMales, allCats, ngPairingRules]);

  const findMatchingRule = useCallback((maleId: string, femaleId: string): NgPairingRule | undefined => {
    const male = activeMales.find((m) => m.id === maleId);
    const female = allCats.find((f) => f.id === femaleId);
    
    if (!male || !female) return undefined;
    
    const maleTags = male.tags?.map((catTag) => catTag.tag.name) ?? [];
    const femaleTags = female.tags?.map((catTag) => catTag.tag.name) ?? [];
    
    return ngPairingRules.find((rule) => {
      if (!rule.active) return false;
      
      if (rule.type === 'TAG_COMBINATION' && rule.maleConditions && rule.femaleConditions) {
        const maleMatches = rule.maleConditions.some((condition) => maleTags.includes(condition));
        const femaleMatches = rule.femaleConditions.some((condition) => femaleTags.includes(condition));
        return maleMatches && femaleMatches;
      }
      
      if (rule.type === 'INDIVIDUAL_PROHIBITION' && rule.maleNames && rule.femaleNames) {
        return rule.maleNames.includes(male.name) && rule.femaleNames.includes(female.name);
      }
      
      return false;
    });
  }, [activeMales, allCats, ngPairingRules]);

  return {
    isNGPairing,
    findMatchingRule,
  };
}
````

## File: frontend/src/app/breeding/types.ts
````typescript
/**
 * äº¤é…ç®¡ç†ãƒšãƒ¼ã‚¸ã§ä½¿ç”¨ã™ã‚‹å‹å®šç¾©
 */

import type { Cat } from '@/lib/api/hooks/use-cats';
import type { BreedingNgRuleType } from '@/lib/api/hooks/use-breeding';

/**
 * äº¤é…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¨ãƒ³ãƒˆãƒª
 */
export interface BreedingScheduleEntry {
  maleId: string;
  maleName: string;
  femaleId: string;
  femaleName: string;
  date: string;
  duration: number;
  dayIndex: number;
  isHistory: boolean;
  result?: string;
  /** ã‚µãƒ¼ãƒãƒ¼å´ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ« IDï¼ˆAPI åŒæœŸç”¨ï¼‰ */
  serverId?: string;
}

/**
 * NGãƒšã‚¢ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ«
 */
export interface NgPairingRule {
  id: string;
  name: string;
  type: BreedingNgRuleType;
  maleConditions?: string[];
  femaleConditions?: string[];
  maleNames?: string[];
  femaleNames?: string[];
  generationLimit?: number | null;
  description?: string | null;
  active: boolean;
  createdAt?: string;
  updatedAt?: string;
}

/**
 * æ–°è¦ãƒ«ãƒ¼ãƒ«ä½œæˆç”¨ã®çŠ¶æ…‹
 */
export interface NewRuleState {
  name: string;
  type: BreedingNgRuleType;
  maleConditions: string[];
  femaleConditions: string[];
  maleNames: string[];
  femaleNames: string[];
  generationLimit: number | null;
  description: string;
}

/**
 * æœˆã®ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼æ—¥ä»˜
 */
export interface MonthDate {
  date: number;
  dateString: string;
  dayOfWeek: number;
}

/**
 * localStorageã‚­ãƒ¼
 */
export const STORAGE_KEYS = {
  ACTIVE_MALES: 'breeding_active_males',
  DEFAULT_DURATION: 'breeding_default_duration',
  SELECTED_YEAR: 'breeding_selected_year',
  SELECTED_MONTH: 'breeding_selected_month',
  BREEDING_SCHEDULE: 'breeding_schedule',
  MATING_CHECKS: 'breeding_mating_checks',
} as const;

/**
 * å­è‚²ã¦ä¸­ã®æ¯çŒ«æƒ…å ±
 */
export interface MotherWithKittens {
  mother: Cat;
  kittens: Cat[];
}
````

## File: frontend/src/app/breeding/utils.ts
````typescript
/**
 * äº¤é…ç®¡ç†ãƒšãƒ¼ã‚¸ã§ä½¿ç”¨ã™ã‚‹ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
 */

import type { MonthDate } from './types';

/**
 * æŒ‡å®šã•ã‚ŒãŸå¹´æœˆã®ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼æ—¥ä»˜ã‚’ç”Ÿæˆ
 */
export const generateMonthDates = (year: number, month: number): MonthDate[] => {
  const dates: MonthDate[] = [];
  const daysInMonth = new Date(year, month, 0).getDate();
  
  for (let day = 1; day <= daysInMonth; day++) {
    const date = new Date(year, month - 1, day);
    dates.push({
      date: day,
      dateString: `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`,
      dayOfWeek: date.getDay(),
    });
  }
  return dates;
};

/**
 * å¹´é½¢ã‚’æœˆå˜ä½ã§è¨ˆç®—
 */
export const calculateAgeInMonths = (birthDate: string): number => {
  if (!birthDate) return 0;
  const birth = new Date(birthDate);
  const now = new Date();
  
  let months = (now.getFullYear() - birth.getFullYear()) * 12;
  months += now.getMonth() - birth.getMonth();
  
  // ã‚‚ã—ä»Šæœˆã®æ—¥ä»˜ãŒèª•ç”Ÿæ—¥ã®æ—¥ä»˜ã‚ˆã‚Šå‰ãªã‚‰ã€1ãƒ¶æœˆå¼•ã
  if (now.getDate() < birth.getDate()) {
    months--;
  }
  
  return Math.max(0, months);
};

/**
 * ç”Ÿã¾ã‚ŒãŸæ—¥ã‚’0æ—¥ã¨ã—ã¦ã€ç”Ÿå¾Œæ—¥æ•°ã‚’è¨ˆç®—
 */
export const calculateAgeInDays = (birthDate: string): number => {
  if (!birthDate) return 0;
  const birth = new Date(birthDate);
  const now = new Date();
  
  // ãƒŸãƒªç§’ã®å·®ã‚’æ—¥æ•°ã«å¤‰æ›ï¼ˆç”Ÿã¾ã‚ŒãŸæ—¥ã‚’0æ—¥ã¨ã™ã‚‹ï¼‰
  const diffInMs = now.getTime() - birth.getTime();
  const diffInDays = Math.floor(diffInMs / (1000 * 60 * 60 * 24));
  
  return Math.max(0, diffInDays);
};

/**
 * æ—¥ä»˜æ–‡å­—åˆ—ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
 */
export const formatDateJP = (dateString: string): string => {
  if (!dateString) return 'ä¸æ˜';
  const date = new Date(dateString);
  return date.toLocaleDateString('ja-JP', { month: 'numeric', day: 'numeric' });
};
````

## File: frontend/src/app/cats/[id]/edit/client.tsx
````typescript
"use client";

import { useRouter } from "next/navigation";
import { Container, Title, Paper, Group, Button, Stack, TextInput, Textarea, Select, Loader, Center, Alert } from "@mantine/core";
import { IconArrowLeft, IconDeviceFloppy, IconAlertCircle } from "@tabler/icons-react";
import { useEffect, useMemo, useState } from "react";
import { useGetCat, useUpdateCat, useDeleteCat } from "@/lib/api/hooks/use-cats";
import { useGetBreeds } from "@/lib/api/hooks/use-breeds";
import { useGetCoatColors } from "@/lib/api/hooks/use-coat-colors";
import { useBreedMasterData, useCoatColorMasterData } from "@/lib/api/hooks/use-master-data";
import { ALPHANUM_SPACE_HYPHEN_PATTERN, MasterDataCombobox } from "@/components/forms/MasterDataCombobox";
import { useSelectionHistory } from "@/lib/hooks/use-selection-history";
import { buildMasterOptions, createDisplayNameMap } from "@/lib/master-data/master-options";
import { format } from "date-fns";

type Props = {
  catId: string;
};

// Gender options
const GENDER_OPTIONS = [
  { value: "MALE", label: "Male" },
  { value: "FEMALE", label: "Female" },
  { value: "NEUTER", label: "Neutered Male" },
  { value: "SPAY", label: "Spayed Female" },
];

const COAT_COLOR_DESCRIPTION = "åŠè§’è‹±æ•°å­—ãƒ»ã‚¹ãƒšãƒ¼ã‚¹ãƒ»ãƒã‚¤ãƒ•ãƒ³ã§æ¤œç´¢ã§ãã¾ã™ã€‚";

export default function CatEditClient({ catId }: Props) {
  const router = useRouter();
  const { data: cat, isLoading: isCatLoading, error: catError } = useGetCat(catId);
  const breedListQuery = useMemo(() => ({ limit: 1000, sortBy: 'code', sortOrder: 'asc' as const }), []);
  const coatColorListQuery = useMemo(() => ({ limit: 1000, sortBy: 'code', sortOrder: 'asc' as const }), []);
  const { data: breedsData, isLoading: isBreedsLoading } = useGetBreeds(breedListQuery);
  const { data: coatColorsData, isLoading: isCoatColorsLoading } = useGetCoatColors(coatColorListQuery);
  const { data: breedMasterData, isLoading: isBreedMasterLoading } = useBreedMasterData();
  const { data: coatMasterData, isLoading: isCoatMasterLoading } = useCoatColorMasterData();
  const { history: breedHistory, recordSelection: recordBreedSelection } = useSelectionHistory('breed');
  const { history: coatHistory, recordSelection: recordCoatSelection } = useSelectionHistory('coat-color');
  const breedDisplayMap = useMemo(() => createDisplayNameMap(breedMasterData?.data), [breedMasterData]);
  const coatDisplayMap = useMemo(() => createDisplayNameMap(coatMasterData?.data), [coatMasterData]);
  const breedOptions = useMemo(() => buildMasterOptions(breedsData?.data, breedDisplayMap), [breedsData, breedDisplayMap]);
  const coatColorOptions = useMemo(() => buildMasterOptions(coatColorsData?.data, coatDisplayMap), [coatColorsData, coatDisplayMap]);
  const updateCat = useUpdateCat(catId);
  const deleteCat = useDeleteCat();

  const [form, setForm] = useState<{
    name: string;
    gender: 'MALE' | 'FEMALE' | 'NEUTER' | 'SPAY';
    breedId: string;
    coatColorId: string;
    birthDate: string;
    microchipNumber: string;
    registrationNumber: string;
    description: string;
  }>({
    name: "",
    gender: "MALE",
    breedId: "",
    coatColorId: "",
    birthDate: "",
    microchipNumber: "",
    registrationNumber: "",
    description: "",
  });

  // ãƒ‡ãƒ¼ã‚¿å–å¾—å¾Œã«ãƒ•ã‚©ãƒ¼ãƒ ã‚’åˆæœŸåŒ–
  useEffect(() => {
    if (cat?.data) {
      const catData = cat.data;
      setForm({
        name: catData.name || "",
        gender: catData.gender || "MALE",
        breedId: catData.breedId || "",
        coatColorId: catData.coatColorId || "",
        birthDate: catData.birthDate ? format(new Date(catData.birthDate), "yyyy-MM-dd") : "",
        microchipNumber: catData.microchipNumber || "",
        registrationNumber: catData.registrationNumber || "",
        description: catData.description || "",
      });
    }
  }, [cat]);

  const handleChange = (field: string, value: string) => {
    setForm(prev => ({
      ...prev,
      [field]: value,
    }));
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    try {
      await updateCat.mutateAsync({
        name: form.name,
        gender: form.gender,
        breedId: form.breedId || null,
        coatColorId: form.coatColorId || null,
        birthDate: form.birthDate,
        microchipNumber: form.microchipNumber || null,
        registrationNumber: form.registrationNumber || null,
        description: form.description || null,
      });

      router.push(`/cats/${catId}`);
    } catch (error) {
      console.error("æ›´æ–°ã‚¨ãƒ©ãƒ¼:", error);
    }
  };

  const handleDelete = async () => {
    if (!confirm("æœ¬å½“ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚")) {
      return;
    }

    try {
      await deleteCat.mutateAsync(catId);
      router.push("/cats");
    } catch (error) {
      console.error("å‰Šé™¤ã‚¨ãƒ©ãƒ¼:", error);
    }
  };

  // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ä¸­
  if (isCatLoading || isBreedsLoading || isCoatColorsLoading || isBreedMasterLoading || isCoatMasterLoading) {
    return (
      <Center style={{ minHeight: "100vh" }}>
        <Loader size="lg" />
      </Center>
    );
  }

  // ã‚¨ãƒ©ãƒ¼
  if (catError || !cat) {
    return (
      <Container size="md" py="xl">
        <Alert icon={<IconAlertCircle size={16} />} title="ã‚¨ãƒ©ãƒ¼" color="red">
          çŒ«ã®æƒ…å ±ã‚’èª­ã¿è¾¼ã‚ã¾ã›ã‚“ã§ã—ãŸã€‚
        </Alert>
        <Button
          mt="md"
          variant="light"
          leftSection={<IconArrowLeft size={16} />}
          onClick={() => router.push("/cats")}
        >
          ä¸€è¦§ã¸æˆ»ã‚‹
        </Button>
      </Container>
    );
  }

  return (
    <Container size="md" py="xl">
      <Group justify="space-between" mb="xl">
        <Title order={1}>çŒ«ã®æƒ…å ±ç·¨é›†</Title>
        <Button
          variant="outline"
          leftSection={<IconArrowLeft size={16} />}
          onClick={() => router.push(`/cats/${catId}`)}
        >
          è©³ç´°ã¸æˆ»ã‚‹
        </Button>
      </Group>

      <Paper shadow="sm" p="xl" radius="md">
        <form onSubmit={handleSubmit}>
          <Stack gap="md">
            <TextInput
              label="åå‰"
              value={form.name}
              onChange={(e) => handleChange("name", e.target.value)}
              required
            />

            <Select
              label="æ€§åˆ¥"
              value={form.gender}
              onChange={(value) => handleChange("gender", value || "")}
              data={GENDER_OPTIONS}
              required
            />

            <MasterDataCombobox
              label="å“ç¨®"
              value={form.breedId || undefined}
              onChange={(next) => handleChange("breedId", next ?? "")}
              options={breedOptions}
              historyItems={breedHistory}
              disabled={updateCat.isPending}
              loading={isBreedsLoading || isBreedMasterLoading}
              historyLabel="æœ€è¿‘ã®å“ç¨®"
              onOptionSelected={recordBreedSelection}
            />

            <MasterDataCombobox
              label="è‰²æŸ„"
              value={form.coatColorId || undefined}
              onChange={(next) => handleChange("coatColorId", next ?? "")}
              options={coatColorOptions}
              historyItems={coatHistory}
              disabled={updateCat.isPending}
              loading={isCoatColorsLoading || isCoatMasterLoading}
              historyLabel="æœ€è¿‘ã®è‰²æŸ„"
              onOptionSelected={recordCoatSelection}
              description={COAT_COLOR_DESCRIPTION}
              sanitizePattern={ALPHANUM_SPACE_HYPHEN_PATTERN}
            />

            <TextInput
              label="ç”Ÿå¹´æœˆæ—¥"
              type="date"
              value={form.birthDate}
              onChange={(e) => handleChange("birthDate", e.target.value)}
              required
            />

            <TextInput
              label="ãƒã‚¤ã‚¯ãƒ­ãƒãƒƒãƒ—ç•ªå·"
              value={form.microchipNumber}
              onChange={(e) => handleChange("microchipNumber", e.target.value)}
              placeholder="15æ¡ã®ç•ªå·"
            />

            <TextInput
              label="ç™»éŒ²ç•ªå·"
              value={form.registrationNumber}
              onChange={(e) => handleChange("registrationNumber", e.target.value)}
              placeholder="è¡€çµ±æ›¸ç™»éŒ²ç•ªå·"
            />

            <Textarea
              label="è©³ç´°èª¬æ˜"
              value={form.description}
              onChange={(e) => handleChange("description", e.target.value)}
              rows={4}
              placeholder="ç‰¹è¨˜äº‹é …ã‚„æ€§æ ¼ãªã©"
            />

            <Group justify="flex-end" gap="md" pt="md">
              <Button 
                variant="outline" 
                color="red" 
                onClick={handleDelete}
                loading={deleteCat.isPending}
              >
                å‰Šé™¤
              </Button>
              <Button 
                type="submit" 
                leftSection={<IconDeviceFloppy size={16} />}
                loading={updateCat.isPending}
              >
                ä¿å­˜
              </Button>
            </Group>
          </Stack>
        </form>
      </Paper>
    </Container>
  );
}
````

## File: frontend/src/app/cats/[id]/edit/page.tsx
````typescript
import CatEditClient from './client';

type Props = {
  params: Promise<{ id: string }>;
};

export default async function CatEditPage({ params }: Props) {
  const { id } = await params;
  return <CatEditClient catId={id} />;
}
````

## File: frontend/src/app/cats/[id]/pedigree/client.tsx
````typescript
'use client';

import { useRouter } from 'next/navigation';
import {
  Box,
  Button,
  Card,
  Container,
  Stack,
  Title,
  Text,
  Flex,
  Grid,
} from '@mantine/core';
import { IconArrowLeft } from '@tabler/icons-react';

// ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿
const pedigreeData = {
  id: '1',
  name: 'ãƒ¬ã‚ª',
  generation1: { // è¦ª
    father: { name: 'ãƒ‘ãƒ‘çŒ«', color: 'èŒ¶ãƒˆãƒ©' },
    mother: { name: 'ãƒãƒçŒ«', color: 'ä¸‰æ¯›' }
  },
  generation2: { // ç¥–çˆ¶æ¯
    paternalGrandfather: { name: 'ç¥–çˆ¶1', color: 'èŒ¶ãƒˆãƒ©' },
    paternalGrandmother: { name: 'ç¥–æ¯1', color: 'ç™½' },
    maternalGrandfather: { name: 'ç¥–çˆ¶2', color: 'é»’' },
    maternalGrandmother: { name: 'ç¥–æ¯2', color: 'ä¸‰æ¯›' }
  },
  generation3: { // æ›¾ç¥–çˆ¶æ¯
    ppgf: { name: 'æ›¾ç¥–çˆ¶1', color: 'èŒ¶ãƒˆãƒ©' }, // paternal paternal grandfather
    ppgm: { name: 'æ›¾ç¥–æ¯1', color: 'ç™½' },     // paternal paternal grandmother
    pmgf: { name: 'æ›¾ç¥–çˆ¶2', color: 'èŒ¶' },     // paternal maternal grandfather
    pmgm: { name: 'æ›¾ç¥–æ¯2', color: 'ç™½' },     // paternal maternal grandmother
    mpgf: { name: 'æ›¾ç¥–çˆ¶3', color: 'é»’' },     // maternal paternal grandfather
    mpgm: { name: 'æ›¾ç¥–æ¯3', color: 'ç°' },     // maternal paternal grandmother
    mmgf: { name: 'æ›¾ç¥–çˆ¶4', color: 'ä¸‰æ¯›' },   // maternal maternal grandfather
    mmgm: { name: 'æ›¾ç¥–æ¯4', color: 'èŒ¶' }      // maternal maternal grandmother
  }
};

const CatCard = ({ cat, level = 0 }: { cat: { name: string; color: string } | null; level?: number }) => {
  if (!cat) {
    return (
      <Card shadow="sm" padding="sm" radius="md" withBorder style={{ minHeight: 60, opacity: 0.3 }}>
        <Text size="sm" c="dimmed">ä¸æ˜</Text>
      </Card>
    );
  }

  const colors = {
    0: '#e3f2fd', // æœ¬äºº: ãƒ©ã‚¤ãƒˆãƒ–ãƒ«ãƒ¼
    1: '#f3e5f5', // è¦ª: ãƒ©ã‚¤ãƒˆãƒ‘ãƒ¼ãƒ—ãƒ«
    2: '#e8f5e8', // ç¥–çˆ¶æ¯: ãƒ©ã‚¤ãƒˆã‚°ãƒªãƒ¼ãƒ³
    3: '#fff3e0'  // æ›¾ç¥–çˆ¶æ¯: ãƒ©ã‚¤ãƒˆã‚ªãƒ¬ãƒ³ã‚¸
  };

  return (
    <Card 
      shadow="sm" 
      padding="sm" 
      radius="md" 
      withBorder 
      style={{ 
        backgroundColor: colors[level as keyof typeof colors] || '#f5f5f5',
        minHeight: 60 
      }}
    >
      <Stack gap="xs">
        <Text fw={600} size="sm">{cat.name}</Text>
        <Text size="xs" c="dimmed">{cat.color}</Text>
      </Stack>
    </Card>
  );
};

export default function PedigreeClient() {
  const router = useRouter();

  return (
  <Box style={{ minHeight: '100vh', backgroundColor: 'var(--background-base)' }}>
      {/* ãƒ˜ãƒƒãƒ€ãƒ¼ */}
      <Box
        style={{
          backgroundColor: 'var(--surface)',
          borderBottom: '1px solid var(--border-subtle)',
          padding: '1rem 0',
          boxShadow: '0 6px 20px rgba(15, 23, 42, 0.04)',
        }}
      >
        <Container size="xl">
          <Flex justify="space-between" align="center">
            <Button
              variant="light"
              leftSection={<IconArrowLeft size={16} />}
              onClick={() => router.back()}
            >
              æˆ»ã‚‹
            </Button>
          </Flex>
        </Container>
      </Box>

      <Container size="xl" style={{ paddingTop: '2rem' }}>
        <Title order={1} mb="lg" ta="center">
          {pedigreeData.name}ã®è¡€çµ±è¡¨ï¼ˆ4ä¸–ä»£ï¼‰
        </Title>

        {/* è¡€çµ±è¡¨ã‚°ãƒªãƒƒãƒ‰ */}
        <Box style={{ overflowX: 'auto' }}>
          <Grid style={{ minWidth: '1200px' }}>
            {/* ç¬¬1åˆ—: æœ¬äºº */}
            <Grid.Col span={3}>
              <Stack gap="md" style={{ height: '100%', justifyContent: 'center' }}>
                <CatCard cat={{ name: pedigreeData.name, color: 'èŒ¶ãƒˆãƒ©' }} level={0} />
              </Stack>
            </Grid.Col>

            {/* ç¬¬2åˆ—: è¦ª */}
            <Grid.Col span={3}>
              <Stack gap="md" style={{ height: '100%' }}>
                <CatCard cat={pedigreeData.generation1.father} level={1} />
                <CatCard cat={pedigreeData.generation1.mother} level={1} />
              </Stack>
            </Grid.Col>

            {/* ç¬¬3åˆ—: ç¥–çˆ¶æ¯ */}
            <Grid.Col span={3}>
              <Stack gap="md" style={{ height: '100%' }}>
                <CatCard cat={pedigreeData.generation2.paternalGrandfather} level={2} />
                <CatCard cat={pedigreeData.generation2.paternalGrandmother} level={2} />
                <CatCard cat={pedigreeData.generation2.maternalGrandfather} level={2} />
                <CatCard cat={pedigreeData.generation2.maternalGrandmother} level={2} />
              </Stack>
            </Grid.Col>

            {/* ç¬¬4åˆ—: æ›¾ç¥–çˆ¶æ¯ */}
            <Grid.Col span={3}>
              <Stack gap="md" style={{ height: '100%' }}>
                <CatCard cat={pedigreeData.generation3.ppgf} level={3} />
                <CatCard cat={pedigreeData.generation3.ppgm} level={3} />
                <CatCard cat={pedigreeData.generation3.pmgf} level={3} />
                <CatCard cat={pedigreeData.generation3.pmgm} level={3} />
                <CatCard cat={pedigreeData.generation3.mpgf} level={3} />
                <CatCard cat={pedigreeData.generation3.mpgm} level={3} />
                <CatCard cat={pedigreeData.generation3.mmgf} level={3} />
                <CatCard cat={pedigreeData.generation3.mmgm} level={3} />
              </Stack>
            </Grid.Col>
          </Grid>
        </Box>

        {/* ä¸–ä»£ãƒ©ãƒ™ãƒ« */}
        <Box mt="xl">
          <Grid>
            <Grid.Col span={3}>
              <Text ta="center" fw={600} c="blue">æœ¬äºº</Text>
            </Grid.Col>
            <Grid.Col span={3}>
              <Text ta="center" fw={600} c="purple">è¦ªï¼ˆç¬¬1ä¸–ä»£ï¼‰</Text>
            </Grid.Col>
            <Grid.Col span={3}>
              <Text ta="center" fw={600} c="green">ç¥–çˆ¶æ¯ï¼ˆç¬¬2ä¸–ä»£ï¼‰</Text>
            </Grid.Col>
            <Grid.Col span={3}>
              <Text ta="center" fw={600} c="orange">æ›¾ç¥–çˆ¶æ¯ï¼ˆç¬¬3ä¸–ä»£ï¼‰</Text>
            </Grid.Col>
          </Grid>
        </Box>

        {/* æ³¨æ„æ›¸ã */}
        <Card shadow="sm" padding="lg" radius="md" withBorder mt="xl">
          <Title order={3} mb="md">è¡€çµ±è¡¨ã«ã¤ã„ã¦</Title>
          <Stack gap="sm">
            <Text size="sm">â€¢ ã“ã®è¡€çµ±è¡¨ã¯4ä¸–ä»£ï¼ˆæœ¬äºº + è¦ªã€ç¥–çˆ¶æ¯ã€æ›¾ç¥–çˆ¶æ¯ï¼‰ã‚’è¡¨ç¤ºã—ã¦ã„ã¾ã™</Text>
            <Text size="sm">â€¢ å„ä¸–ä»£ã¯è‰²åˆ†ã‘ã•ã‚Œã¦ãŠã‚Šã€ä¸–ä»£ãŒå¤ããªã‚‹ã»ã©è–„ã„è‰²ã«ãªã‚Šã¾ã™</Text>
            <Text size="sm">â€¢ ä¸æ˜ãªå€‹ä½“ã¯ã€Œä¸æ˜ã€ã¨è¡¨ç¤ºã•ã‚Œã¾ã™</Text>
            <Text size="sm">â€¢ ã‚ˆã‚Šè©³ç´°ãªè¡€çµ±æƒ…å ±ãŒå¿…è¦ãªå ´åˆã¯ã€å€‹åˆ¥ã«ãŠå•ã„åˆã‚ã›ãã ã•ã„</Text>
          </Stack>
        </Card>
      </Container>
    </Box>
  );
}
````

## File: frontend/src/app/cats/[id]/layout.tsx
````typescript
// Static export support - return empty array for dynamic routes
export function generateStaticParams() {
  return [];
}

export default function CatLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return <>{children}</>;
}
````

## File: frontend/src/app/cats/[id]/page.tsx
````typescript
import CatDetailClient from './client';

type Props = {
  params: Promise<{ id: string }>;
};

export default async function CatDetailPage({ params }: Props) {
  const { id } = await params;
  return <CatDetailClient catId={id} />;
}
````

## File: frontend/src/app/cats/new/page.tsx
````typescript
'use client';
import { useState, useEffect, useMemo } from 'react';
import { useRouter } from 'next/navigation';
import {
  Card,
  Container,
  Group,
  Stack,
  Switch,
  Alert,
  LoadingOverlay,
  Tabs,
} from '@mantine/core';
import { InputWithFloatingLabel } from '@/components/ui/InputWithFloatingLabel';
import { TextareaWithFloatingLabel } from '@/components/ui/TextareaWithFloatingLabel';
import { Controller, useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { IconPlus } from '@tabler/icons-react';
import { useCreateCat, type CreateCatRequest } from '@/lib/api/hooks/use-cats';
import { useGetBreeds } from '@/lib/api/hooks/use-breeds';
import { useGetCoatColors } from '@/lib/api/hooks/use-coat-colors';
import { useBreedMasterData, useCoatColorMasterData } from '@/lib/api/hooks/use-master-data';
import { ActionButton } from '@/components/ActionButton';
import { usePageHeader } from '@/lib/contexts/page-header-context';
import TagSelector from '@/components/TagSelector';
import { ALPHANUM_SPACE_HYPHEN_PATTERN, MasterDataCombobox } from '@/components/forms/MasterDataCombobox';
import { useSelectionHistory } from '@/lib/hooks/use-selection-history';
import { buildMasterOptions, createDisplayNameMap } from '@/lib/master-data/master-options';
import { catFormSchema, type CatFormSchema as CatFormValues } from '@/lib/schemas';
import { SelectWithFloatingLabel } from '@/components/ui/SelectWithFloatingLabel';

export default function CatRegistrationPage() {
  const router = useRouter();
  const [activeTab, setActiveTab] = useState<string | null>('register');
  const { setPageHeader } = usePageHeader();
  const createCat = useCreateCat();
  const breedListQuery = useMemo(() => ({ limit: 500, sortBy: 'code', sortOrder: 'asc' as const }), []);
  const coatColorListQuery = useMemo(() => ({ limit: 500, sortBy: 'code', sortOrder: 'asc' as const }), []);
  const { data: breedsData, isLoading: isBreedsLoading } = useGetBreeds(breedListQuery);
  const { data: coatColorsData, isLoading: isCoatColorsLoading } = useGetCoatColors(coatColorListQuery);
  const { data: breedMasterData, isLoading: isBreedMasterLoading } = useBreedMasterData();
  const { data: coatMasterData, isLoading: isCoatMasterLoading } = useCoatColorMasterData();
  const { history: breedHistory, recordSelection: recordBreedSelection } = useSelectionHistory('breed');
  const { history: coatHistory, recordSelection: recordCoatSelection } = useSelectionHistory('coat-color');
  const breedDisplayMap = useMemo(() => createDisplayNameMap(breedMasterData?.data), [breedMasterData]);
  const coatDisplayMap = useMemo(() => createDisplayNameMap(coatMasterData?.data), [coatMasterData]);
  const breedOptions = useMemo(
    () => buildMasterOptions(breedsData?.data, breedDisplayMap),
    [breedsData, breedDisplayMap],
  );
  const coatColorOptions = useMemo(
    () => buildMasterOptions(coatColorsData?.data, coatDisplayMap),
    [coatColorsData, coatDisplayMap],
  );
  const {
    control,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm<CatFormValues>({
    resolver: zodResolver(catFormSchema),
    defaultValues: {
      name: '',
      gender: undefined,
      birthDate: '',
      breedId: undefined,
      coatColorId: undefined,
      microchipNumber: undefined,
      registrationId: undefined,
      description: undefined,
      isInHouse: true,
      tagIds: [],
    },
  });

  const onSubmit = async (values: CatFormValues) => {
    const payload: CreateCatRequest = {
      name: values.name,
      gender: values.gender,
      birthDate: values.birthDate,
      breedId: values.breedId ?? null,
      coatColorId: values.coatColorId ?? null,
      microchipNumber: values.microchipNumber,
      registrationNumber: values.registrationId,
      description: values.description,
      isInHouse: values.isInHouse,
      tagIds: values.tagIds.length > 0 ? values.tagIds : undefined,
    };

    try {
      await createCat.mutateAsync(payload);
      reset();
      // ç™»éŒ²æˆåŠŸå¾Œã«ä¸€è¦§ãƒšãƒ¼ã‚¸ã«é·ç§»ï¼ˆã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’è¿½åŠ ã—ã¦ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ãƒã‚¤ãƒ‘ã‚¹ï¼‰
      router.replace(`/cats?t=${Date.now()}`);
    } catch {
      // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¯ useCreateCat å†…ã§é€šçŸ¥ã‚’è¡¨ç¤º
    }
  };

  const isSubmitting = createCat.isPending;

  // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ˜ãƒƒãƒ€ãƒ¼ã«ãƒšãƒ¼ã‚¸ã‚¿ã‚¤ãƒˆãƒ«ã¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã‚’è¨­å®š
  useEffect(() => {
    setPageHeader(
      'åœ¨èˆçŒ«ç™»éŒ²',
      <ActionButton
        action="create"
        onClick={handleSubmit(onSubmit)}
        loading={isSubmitting}
      >
        ç™»éŒ²ã™ã‚‹
      </ActionButton>
    );

    return () => {
      setPageHeader(null);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isSubmitting]);

  return (
    <Container size="xl" style={{ position: 'relative' }}>
      <LoadingOverlay visible={isSubmitting} zIndex={1000} overlayProps={{ blur: 2 }} />

      {/* ã‚¿ãƒ–ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ */}
      <Tabs value={activeTab} onChange={setActiveTab}>
        <Tabs.List>
          <Tabs.Tab value="register" leftSection={<IconPlus size={16} />}>
            æ–°è¦ç™»éŒ²
          </Tabs.Tab>
        </Tabs.List>

        <Tabs.Panel value="register" pt="md">
          <Card shadow="sm" padding="lg" radius="md" withBorder>
            <form onSubmit={handleSubmit(onSubmit)}>
              <Stack gap={10}>
                {/* 1è¡Œç›®: çŒ«ã®åå‰ã€æ€§åˆ¥ */}
                <Group grow gap={10}>
                  <Controller
                    name="name"
                    control={control}
                    render={({ field }) => (
                      <InputWithFloatingLabel
                        label="çŒ«ã®åå‰"
                        required
                        error={errors.name?.message}
                        {...field}
                        value={field.value}
                      />
                    )}
                  />

                  <Controller
                    name="gender"
                    control={control}
                    render={({ field }) => (
                      <SelectWithFloatingLabel
                        label="æ€§åˆ¥"
                        data={[
                          { value: 'MALE', label: 'Male (ã‚ªã‚¹)' },
                          { value: 'FEMALE', label: 'Female (ãƒ¡ã‚¹)' },
                          { value: 'NEUTER', label: 'Neuter (å»å‹¢ã‚ªã‚¹)' },
                          { value: 'SPAY', label: 'Spay (é¿å¦Šãƒ¡ã‚¹)' },
                        ]}
                        required
                        error={errors.gender?.message}
                        value={field.value ?? null}
                        onChange={field.onChange}
                      />
                    )}
                  />
                </Group>

                {/* 2è¡Œç›®: çŒ«ç¨®ã‚³ãƒ³ãƒœã€è‰²æŸ„ã‚³ãƒ³ãƒœ */}
                <Group grow gap={10}>
                  <Controller
                    name="breedId"
                    control={control}
                    render={({ field }) => (
                      <MasterDataCombobox
                        label=""
                        placeholder="çŒ«ç¨®ã‚³ãƒ¼ãƒ‰ã‚„åç§°ã‚’å…¥åŠ›"
                        description=""
                        value={field.value ?? undefined}
                        onChange={(next) => field.onChange(next ?? undefined)}
                        options={breedOptions}
                        historyItems={breedHistory}
                        error={errors.breedId?.message}
                        disabled={isSubmitting}
                        loading={isBreedsLoading || isBreedMasterLoading}
                        historyLabel="æœ€è¿‘ã®å“ç¨®"
                        onOptionSelected={recordBreedSelection}
                      />
                    )}
                  />

                  <Controller
                    name="coatColorId"
                    control={control}
                    render={({ field }) => (
                      <MasterDataCombobox
                        label=""
                        placeholder="è‰²æŸ„ã‚³ãƒ¼ãƒ‰ã‚„åç§°ã‚’å…¥åŠ›"
                        description=""
                        value={field.value ?? undefined}
                        onChange={(next) => field.onChange(next ?? undefined)}
                        options={coatColorOptions}
                        historyItems={coatHistory}
                        error={errors.coatColorId?.message}
                        disabled={isSubmitting}
                        loading={isCoatColorsLoading || isCoatMasterLoading}
                        historyLabel="æœ€è¿‘ã®è‰²æŸ„"
                        onOptionSelected={recordCoatSelection}
                        sanitizePattern={ALPHANUM_SPACE_HYPHEN_PATTERN}
                      />
                    )}
                  />
                </Group>

                {/* 3è¡Œç›®: ç”Ÿå¹´æœˆæ—¥ã€ãƒã‚¤ã‚¯ãƒ­ãƒãƒƒãƒ—ç•ªå·ã€ç™»éŒ²ç•ªå· */}
                <Group grow gap={10}>
                  <Controller
                    name="birthDate"
                    control={control}
                    render={({ field }) => (
                      <InputWithFloatingLabel
                        label="ç”Ÿå¹´æœˆæ—¥"
                        error={errors.birthDate?.message}
                        {...field}
                        value={field.value ?? ''}
                      />
                    )}
                  />

                  <Controller
                    name="microchipNumber"
                    control={control}
                    render={({ field }) => (
                      <InputWithFloatingLabel
                        label="ãƒã‚¤ã‚¯ãƒ­ãƒãƒƒãƒ—ç•ªå·"
                        error={errors.microchipNumber?.message}
                        {...field}
                        value={field.value ?? ''}
                      />
                    )}
                  />

                  <Controller
                    name="registrationId"
                    control={control}
                    render={({ field }) => (
                      <InputWithFloatingLabel
                        label="ç™»éŒ²ç•ªå·"
                        error={errors.registrationId?.message}
                        {...field}
                        value={field.value ?? ''}
                      />
                    )}
                  />
                </Group>

                {/* 4è¡Œç›®: å‚™è€ƒ */}
                <Controller
                  name="description"
                  control={control}
                  render={({ field }) => (
                    <TextareaWithFloatingLabel
                      label="å‚™è€ƒ"
                      placeholder="ç‰¹å¾´ã‚„æ€§æ ¼ãªã©ã‚’è¨˜å…¥ã—ã¦ãã ã•ã„"
                      minRows={3}
                      error={errors.description?.message}
                      {...field}
                      value={field.value ?? ''}
                    />
                  )}
                />

                {/* 5è¡Œç›®: ã‚¿ã‚° */}
                <Controller
                  name="tagIds"
                  control={control}
                  render={({ field }) => (
                    <TagSelector
                      selectedTags={field.value ?? []}
                      onChange={field.onChange}
                      label="ã‚¿ã‚°"
                      placeholder="çŒ«ã®ç‰¹å¾´ã‚¿ã‚°ã‚’é¸æŠ"
                      disabled={isSubmitting}
                    />
                  )}
                />

                {/* 6è¡Œç›®: åœ¨èˆã‚¹ã‚¤ãƒƒãƒ */}
                <Controller
                  name="isInHouse"
                  control={control}
                  render={({ field }) => (
                    <Switch
                      label="æ–½è¨­å†…ã«åœ¨èˆã—ã¦ã„ã‚‹çŒ«ã§ã™"
                      checked={field.value}
                      onChange={(event) => field.onChange(event.currentTarget.checked)}
                    />
                  )}
                />

                {createCat.isError && (
                  <Alert color="red" title="ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ">
                    {(createCat.error as Error)?.message ?? 'æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚'}
                  </Alert>
                )}

                {/* ãƒ•ã‚©ãƒ¼ãƒ ä¸‹éƒ¨ã®ç™»éŒ²ãƒœã‚¿ãƒ³ */}
                <Group justify="flex-end" mt="md">
                  <ActionButton
                    action="create"
                    onClick={handleSubmit(onSubmit)}
                    loading={isSubmitting}
                    isSectionAction
                  >
                    ç™»éŒ²ã™ã‚‹
                  </ActionButton>
                </Group>
              </Stack>
            </form>
          </Card>
        </Tabs.Panel>
      </Tabs>
    </Container>
  );
}
````

## File: frontend/src/app/forgot-password/page.tsx
````typescript
'use client';

import { useEffect, useMemo, useState, Suspense } from 'react';
import { Container, Paper, Title, Text, TextInput, Button, Alert, Group, Anchor, CopyButton, ActionIcon, Tooltip, Code, Loader, Box } from '@mantine/core';
import { IconMail, IconCheck, IconAlertCircle, IconCopy, IconCheck as IconCheckmark } from '@tabler/icons-react';
import Link from 'next/link';
import { useSearchParams } from 'next/navigation';
import { usePasswordResetActions, usePasswordResetSelectors } from '@/lib/auth/password-reset-store';

function ForgotPasswordForm() {
  const [email, setEmail] = useState('');
  const [localError, setLocalError] = useState<string | null>(null);
  const searchParams = useSearchParams();
  const { requestStatus, requestError, devToken, lastRequestedEmail } = usePasswordResetSelectors();
  const { requestPasswordReset, resetRequestState, clearDevToken } = usePasswordResetActions();

  const returnTo = searchParams?.get('returnTo') ?? null;
  const targetPath = useMemo(() => {
    if (!returnTo || !returnTo.startsWith('/') || returnTo.startsWith('//')) {
      return '/';
    }
    const disallowed = ['/login', '/register', '/forgot-password'];
    return disallowed.includes(returnTo) ? '/' : returnTo;
  }, [returnTo]);

  const loginHref = useMemo(() => {
    if (returnTo && targetPath !== '/') {
      return `/login?returnTo=${encodeURIComponent(targetPath)}`;
    }
    return '/login';
  }, [returnTo, targetPath]);

  useEffect(() => {
    resetRequestState();
    clearDevToken();
    return () => {
      resetRequestState();
      clearDevToken();
    };
  }, [resetRequestState, clearDevToken]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLocalError(null);

    try {
      await requestPasswordReset(email);
    } catch (err) {
      setLocalError(err instanceof Error ? err.message : 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
    }
  };

  const loading = requestStatus === 'loading';
  const success = requestStatus === 'success';
  const error = localError || requestError;

  if (success) {
    return (
      <Container size="xs" style={{ marginTop: '5rem' }}>
        <Paper shadow="md" p="xl" radius="md">
          <Alert icon={<IconCheck size={16} />} title="ãƒ¡ãƒ¼ãƒ«ã‚’é€ä¿¡ã—ã¾ã—ãŸ" color="green" mb="lg">
            ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆã®æ‰‹é †ã‚’è¨˜è¼‰ã—ãŸãƒ¡ãƒ¼ãƒ«ã‚’é€ä¿¡ã—ã¾ã—ãŸã€‚
            ãƒ¡ãƒ¼ãƒ«ã«è¨˜è¼‰ã•ã‚ŒãŸãƒªãƒ³ã‚¯ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã€ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦ãã ã•ã„ã€‚
            {lastRequestedEmail && (
              <Text size="sm" mt="sm">
                é€ä¿¡å…ˆ: <strong>{lastRequestedEmail}</strong>
              </Text>
            )}
            {devToken && (
              <Alert mt="md" variant="light" color="blue" title="é–‹ç™ºãƒ¢ãƒ¼ãƒ‰æƒ…å ±">
                <Text size="sm" mb="xs">
                  ä¸‹è¨˜ãƒˆãƒ¼ã‚¯ãƒ³ã§ãƒªã‚»ãƒƒãƒˆãƒšãƒ¼ã‚¸ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚
                </Text>
                <Group justify="space-between" wrap="nowrap">
                  <Code style={{ flex: 1, overflowX: 'auto' }}>{devToken}</Code>
                  <CopyButton value={devToken} timeout={1500}>
                    {({ copied, copy }) => (
                      <Tooltip label={copied ? 'ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ' : 'ã‚³ãƒ”ãƒ¼'} withArrow position="left">
                        <ActionIcon variant="subtle" color={copied ? 'teal' : 'blue'} onClick={copy}>
                          {copied ? <IconCheckmark size={16} /> : <IconCopy size={16} />}
                        </ActionIcon>
                      </Tooltip>
                    )}
                  </CopyButton>
                </Group>
              </Alert>
            )}
          </Alert>
          <Group justify="center">
            <Anchor component={Link} href={loginHref}>
              ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«æˆ»ã‚‹
            </Anchor>
          </Group>
        </Paper>
      </Container>
    );
  }

  return (
    <Container size="xs" style={{ marginTop: '5rem' }}>
      <Paper shadow="md" p="xl" radius="md">
        <Title order={2} ta="center" mb="md">
          ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ãŠå¿˜ã‚Œã§ã™ã‹ï¼Ÿ
        </Title>
        <Text c="dimmed" size="sm" ta="center" mb="xl">
          ç™»éŒ²ã•ã‚ŒãŸãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚
          ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆç”¨ã®ãƒªãƒ³ã‚¯ã‚’ãŠé€ã‚Šã—ã¾ã™ã€‚
        </Text>

        {error && (
          <Alert icon={<IconAlertCircle size={16} />} title="ã‚¨ãƒ©ãƒ¼" color="red" mb="lg">
            {error}
          </Alert>
        )}

        <form onSubmit={handleSubmit}>
          <TextInput
            label="ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹"
            placeholder="your@email.com"
            required
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            leftSection={<IconMail size={16} />}
            mb="lg"
          />

          <Button
            type="submit"
            fullWidth
            loading={loading}
            mb="md"
          >
            ãƒªã‚»ãƒƒãƒˆãƒªãƒ³ã‚¯ã‚’é€ä¿¡
          </Button>

          <Group justify="center">
            <Anchor component={Link} href={loginHref} size="sm">
              ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«æˆ»ã‚‹
            </Anchor>
          </Group>
        </form>
      </Paper>
    </Container>
  );
}

export default function ForgotPasswordPage() {
  return (
    <Suspense
      fallback={
        <Box
          style={{
            minHeight: '100vh',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
          }}
        >
          <Loader size="lg" />
        </Box>
      }
    >
      <ForgotPasswordForm />
    </Suspense>
  );
}
````

## File: frontend/src/app/gallery/components/GalleryCatCard.tsx
````typescript
'use client';

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚«ãƒ¼ãƒ‰ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * å€‹åˆ¥ã®çŒ«ã‚«ãƒ¼ãƒ‰è¡¨ç¤º
 */

import {
  Card,
  Image,
  Text,
  Badge,
  Group,
  ActionIcon,
  Menu,
  Stack,
  AspectRatio,
} from '@mantine/core';
import {
  IconDots,
  IconEdit,
  IconTrash,
  IconExternalLink,
  IconPhoto,
  IconBrandYoutube,
} from '@tabler/icons-react';
import type { GalleryEntry } from '@/lib/api/hooks/use-gallery';
import { GenderBadge } from '@/components/GenderBadge';

/**
 * æ€§åˆ¥ã‚’è¡¨ç¤ºç”¨ã«å¤‰æ›
 */
function formatGender(gender: string): 'MALE' | 'FEMALE' | 'NEUTER' | 'SPAY' {
  const upperGender = gender.toUpperCase();
  if (
    upperGender === 'MALE' ||
    upperGender === 'FEMALE' ||
    upperGender === 'NEUTER' ||
    upperGender === 'SPAY'
  ) {
    return upperGender;
  }
  // ã‚ªã‚¹/ãƒ¡ã‚¹ã®æ–‡å­—åˆ—å¯¾å¿œ
  if (gender === 'ã‚ªã‚¹' || gender === 'â™‚') return 'MALE';
  if (gender === 'ãƒ¡ã‚¹' || gender === 'â™€') return 'FEMALE';
  return 'MALE';
}

/**
 * æ—¥ä»˜ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
 */
function formatDate(value: string | null | undefined): string {
  if (!value) return '';
  try {
    const date = new Date(value);
    return date.toLocaleDateString('ja-JP', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
    });
  } catch {
    return '';
  }
}

/**
 * ã‚µãƒ ãƒã‚¤ãƒ«URLã®å–å¾—
 */
function getThumbnailUrl(entry: GalleryEntry): string | null {
  if (entry.media.length === 0) return null;

  // orderé †ã§ã‚½ãƒ¼ãƒˆã—ã¦æœ€åˆã®ãƒ¡ãƒ‡ã‚£ã‚¢ã‚’å–å¾—
  const sortedMedia = [...entry.media].sort((a, b) => a.order - b.order);
  const firstMedia = sortedMedia[0];

  if (firstMedia.type === 'YOUTUBE') {
    return firstMedia.thumbnailUrl ?? null;
  }
  return firstMedia.url;
}

/**
 * ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¿ã‚¤ãƒ—ã®åˆ¤å®š
 */
function getMediaInfo(entry: GalleryEntry): {
  hasImages: boolean;
  hasYouTube: boolean;
  count: number;
} {
  const hasImages = entry.media.some((m) => m.type === 'IMAGE');
  const hasYouTube = entry.media.some((m) => m.type === 'YOUTUBE');
  return {
    hasImages,
    hasYouTube,
    count: entry.media.length,
  };
}

interface GalleryCatCardProps {
  /** ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒª */
  entry: GalleryEntry;
  /** ã‚«ãƒ¼ãƒ‰ã‚¯ãƒªãƒƒã‚¯æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
  onClick?: () => void;
  /** ç·¨é›†ã‚¯ãƒªãƒƒã‚¯æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
  onEdit?: () => void;
  /** å‰Šé™¤ã‚¯ãƒªãƒƒã‚¯æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
  onDelete?: () => void;
}

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚«ãƒ¼ãƒ‰ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 *
 * @example
 * ```tsx
 * <GalleryCatCard
 *   entry={entry}
 *   onClick={() => openDetail(entry.id)}
 *   onEdit={() => openEditModal(entry)}
 *   onDelete={() => confirmDelete(entry)}
 * />
 * ```
 */
export function GalleryCatCard({
  entry,
  onClick,
  onEdit,
  onDelete,
}: GalleryCatCardProps) {
  const thumbnailUrl = getThumbnailUrl(entry);
  const mediaInfo = getMediaInfo(entry);

  return (
    <Card
      shadow="sm"
      padding="sm"
      radius="md"
      withBorder
      style={{ cursor: onClick ? 'pointer' : 'default' }}
      onClick={(e) => {
        // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã¯é™¤å¤–
        if ((e.target as HTMLElement).closest('[data-menu-button]')) {
          return;
        }
        onClick?.();
      }}
    >
      {/* ã‚µãƒ ãƒã‚¤ãƒ«ç”»åƒ */}
      <Card.Section>
        <AspectRatio ratio={4 / 3}>
          {thumbnailUrl ? (
            <Image src={thumbnailUrl} alt={entry.name} fit="cover" />
          ) : (
            <div
              style={{
                width: '100%',
                height: '100%',
                backgroundColor: 'var(--mantine-color-gray-1)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
              }}
            >
              <IconPhoto size={48} stroke={1} color="var(--mantine-color-gray-5)" />
            </div>
          )}
        </AspectRatio>
      </Card.Section>

      {/* ã‚«ãƒ¼ãƒ‰æœ¬ä½“ */}
      <Stack gap="xs" mt="sm">
        {/* ãƒ˜ãƒƒãƒ€ãƒ¼: åå‰ã¨ãƒ¡ãƒ‹ãƒ¥ãƒ¼ */}
        <Group justify="space-between" align="flex-start" wrap="nowrap">
          <Text fw={600} size="md" lineClamp={1}>
            {entry.name}
          </Text>
          {(onEdit || onDelete) && (
            <Menu shadow="md" position="bottom-end" withinPortal>
              <Menu.Target>
                <ActionIcon
                  variant="subtle"
                  color="gray"
                  size="sm"
                  data-menu-button
                  onClick={(e) => e.stopPropagation()}
                >
                  <IconDots size={16} />
                </ActionIcon>
              </Menu.Target>
              <Menu.Dropdown>
                {onEdit && (
                  <Menu.Item
                    leftSection={<IconEdit size={14} />}
                    onClick={(e) => {
                      e.stopPropagation();
                      onEdit();
                    }}
                  >
                    ç·¨é›†
                  </Menu.Item>
                )}
                {entry.externalLink && (
                  <Menu.Item
                    leftSection={<IconExternalLink size={14} />}
                    component="a"
                    href={entry.externalLink}
                    target="_blank"
                    rel="noopener noreferrer"
                    onClick={(e) => e.stopPropagation()}
                  >
                    å¤–éƒ¨ãƒªãƒ³ã‚¯
                  </Menu.Item>
                )}
                {onDelete && (
                  <>
                    <Menu.Divider />
                    <Menu.Item
                      color="red"
                      leftSection={<IconTrash size={14} />}
                      onClick={(e) => {
                        e.stopPropagation();
                        onDelete();
                      }}
                    >
                      å‰Šé™¤
                    </Menu.Item>
                  </>
                )}
              </Menu.Dropdown>
            </Menu>
          )}
        </Group>

        {/* æ€§åˆ¥ã¨æ¯›è‰² */}
        <Group gap="xs">
          <GenderBadge gender={formatGender(entry.gender)} size="xs" />
          {entry.coatColor && (
            <Badge size="xs" variant="light" color="gray">
              {entry.coatColor}
            </Badge>
          )}
        </Group>

        {/* çŒ«ç¨® */}
        {entry.breed && (
          <Text size="xs" c="dimmed" lineClamp={1}>
            {entry.breed}
          </Text>
        )}

        {/* å’æ¥­æƒ…å ±ï¼ˆGRADUATIONã‚«ãƒ†ã‚´ãƒªã®å ´åˆï¼‰ */}
        {entry.category === 'GRADUATION' && entry.transferDate && (
          <Text size="xs" c="dimmed">
            å’æ¥­: {formatDate(entry.transferDate)}
          </Text>
        )}

        {/* ãƒ¡ãƒ‡ã‚£ã‚¢æƒ…å ± */}
        {mediaInfo.count > 0 && (
          <Group gap={4}>
            {mediaInfo.hasImages && (
              <Badge
                size="xs"
                variant="dot"
                color="blue"
                leftSection={<IconPhoto size={10} />}
              >
                ç”»åƒ
              </Badge>
            )}
            {mediaInfo.hasYouTube && (
              <Badge
                size="xs"
                variant="dot"
                color="red"
                leftSection={<IconBrandYoutube size={10} />}
              >
                å‹•ç”»
              </Badge>
            )}
          </Group>
        )}
      </Stack>
    </Card>
  );
}
````

## File: frontend/src/app/gallery/components/GalleryGrid.tsx
````typescript
'use client';

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚°ãƒªãƒƒãƒ‰ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * ã‚«ãƒ¼ãƒ‰ã‚’ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ã‚°ãƒªãƒƒãƒ‰ã§è¡¨ç¤º
 */

import {
  SimpleGrid,
  Skeleton,
  Alert,
  Center,
  Stack,
  Text,
  Pagination,
} from '@mantine/core';
import { IconAlertCircle, IconPhotoOff } from '@tabler/icons-react';
import { GalleryCatCard } from './GalleryCatCard';
import type { GalleryEntry, GalleryCategory } from '@/lib/api/hooks/use-gallery';

interface GalleryGridProps {
  /** ã‚¨ãƒ³ãƒˆãƒªä¸€è¦§ */
  entries: GalleryEntry[];
  /** ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ä¸­ãƒ•ãƒ©ã‚° */
  loading?: boolean;
  /** ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ */
  error?: string | null;
  /** ç¾åœ¨ã®ã‚«ãƒ†ã‚´ãƒª */
  category: GalleryCategory;
  /** ã‚«ãƒ¼ãƒ‰ã‚¯ãƒªãƒƒã‚¯æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
  onCardClick?: (entry: GalleryEntry) => void;
  /** ç·¨é›†ã‚¯ãƒªãƒƒã‚¯æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
  onEditClick?: (entry: GalleryEntry) => void;
  /** å‰Šé™¤ã‚¯ãƒªãƒƒã‚¯æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
  onDeleteClick?: (entry: GalleryEntry) => void;
  /** ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³: ç¾åœ¨ãƒšãƒ¼ã‚¸ */
  currentPage?: number;
  /** ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³: ç·ãƒšãƒ¼ã‚¸æ•° */
  totalPages?: number;
  /** ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³: ãƒšãƒ¼ã‚¸å¤‰æ›´ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
  onPageChange?: (page: number) => void;
}

/**
 * ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¹ã‚±ãƒ«ãƒˆãƒ³
 */
function LoadingSkeleton() {
  return (
    <SimpleGrid cols={{ base: 1, xs: 2, sm: 3, md: 4 }} spacing="md">
      {Array.from({ length: 8 }).map((_, i) => (
        <Skeleton key={i} height={280} radius="md" />
      ))}
    </SimpleGrid>
  );
}

/**
 * ç©ºçŠ¶æ…‹ã®è¡¨ç¤º
 */
function EmptyState({ category }: { category: GalleryCategory }) {
  const categoryLabels: Record<GalleryCategory, string> = {
    KITTEN: 'å­çŒ«',
    FATHER: 'çˆ¶çŒ«',
    MOTHER: 'æ¯çŒ«',
    GRADUATION: 'å’æ¥­çŒ«',
  };

  return (
    <Center py="xl">
      <Stack align="center" gap="md">
        <IconPhotoOff size={48} stroke={1.5} color="gray" />
        <Text c="dimmed" ta="center">
          {categoryLabels[category]}ã®ã‚®ãƒ£ãƒ©ãƒªãƒ¼ãŒã¾ã ã‚ã‚Šã¾ã›ã‚“
        </Text>
      </Stack>
    </Center>
  );
}

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚°ãƒªãƒƒãƒ‰ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 *
 * @example
 * ```tsx
 * <GalleryGrid
 *   entries={data}
 *   loading={isLoading}
 *   category="KITTEN"
 *   onCardClick={(entry) => openDetail(entry.id)}
 * />
 * ```
 */
export function GalleryGrid({
  entries,
  loading,
  error,
  category,
  onCardClick,
  onEditClick,
  onDeleteClick,
  currentPage,
  totalPages,
  onPageChange,
}: GalleryGridProps) {
  // ã‚¨ãƒ©ãƒ¼è¡¨ç¤º
  if (error) {
    return (
      <Alert
        icon={<IconAlertCircle size={16} />}
        title="ã‚¨ãƒ©ãƒ¼"
        color="red"
        variant="light"
      >
        {error}
      </Alert>
    );
  }

  // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¡¨ç¤º
  if (loading) {
    return <LoadingSkeleton />;
  }

  // ç©ºçŠ¶æ…‹
  if (entries.length === 0) {
    return <EmptyState category={category} />;
  }

  return (
    <Stack gap="md">
      <SimpleGrid cols={{ base: 1, xs: 2, sm: 3, md: 4 }} spacing="md">
        {entries.map((entry) => (
          <GalleryCatCard
            key={entry.id}
            entry={entry}
            onClick={() => onCardClick?.(entry)}
            onEdit={() => onEditClick?.(entry)}
            onDelete={() => onDeleteClick?.(entry)}
          />
        ))}
      </SimpleGrid>

      {/* ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ */}
      {totalPages && totalPages > 1 && onPageChange && (
        <Center mt="md">
          <Pagination
            value={currentPage}
            onChange={onPageChange}
            total={totalPages}
            siblings={1}
            boundaries={1}
          />
        </Center>
      )}
    </Stack>
  );
}
````

## File: frontend/src/app/gallery/components/ImageUploader.tsx
````typescript
'use client';

/**
 * ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ€ãƒ¼ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠã«ã‚ˆã‚‹ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
 */

import { useState, useRef } from 'react';
import {
  Box,
  Text,
  Stack,
  Progress,
  Group,
  ActionIcon,
  Image,
  Paper,
} from '@mantine/core';
import { IconUpload, IconPhoto, IconX, IconCheck } from '@tabler/icons-react';
import { useGalleryUpload } from '@/lib/api/hooks/use-gallery-upload';
import { notifications } from '@mantine/notifications';

interface ImageUploaderProps {
  /** ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº†æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
  onUploaded: (url: string) => void;
  /** è¨±å¯ã™ã‚‹æœ€å¤§ãƒ•ã‚¡ã‚¤ãƒ«æ•° */
  maxFiles?: number;
  /** ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ç„¡åŠ¹ */
  disabled?: boolean;
}

/**
 * ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ€ãƒ¼ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 *
 * @example
 * ```tsx
 * <ImageUploader
 *   onUploaded={(url) => handleImageUploaded(url)}
 *   maxFiles={5}
 * />
 * ```
 */
export function ImageUploader({
  onUploaded,
  maxFiles = 10,
  disabled,
}: ImageUploaderProps) {
  const [isDragging, setIsDragging] = useState(false);
  const [uploadingFiles, setUploadingFiles] = useState<
    Array<{
      id: string;
      name: string;
      progress: number;
      status: 'uploading' | 'completed' | 'error';
      previewUrl?: string;
      error?: string;
    }>
  >([]);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const { uploadFile } = useGalleryUpload();

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    if (!disabled) {
      setIsDragging(true);
    }
  };

  const handleDragLeave = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);
  };

  const handleDrop = async (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);

    if (disabled) return;

    const files = Array.from(e.dataTransfer.files).filter((file) =>
      file.type.startsWith('image/')
    );

    if (files.length === 0) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: 'ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã§ãã¾ã™',
        color: 'red',
      });
      return;
    }

    await processFiles(files);
  };

  const handleFileSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = Array.from(e.target.files ?? []);
    if (files.length > 0) {
      await processFiles(files);
    }
    // inputã‚’ãƒªã‚»ãƒƒãƒˆ
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  const processFiles = async (files: File[]) => {
    const filesToProcess = files.slice(0, maxFiles);

    for (const file of filesToProcess) {
      const id = `${Date.now()}-${Math.random().toString(36).slice(2)}`;
      const previewUrl = URL.createObjectURL(file);

      setUploadingFiles((prev) => [
        ...prev,
        {
          id,
          name: file.name,
          progress: 0,
          status: 'uploading',
          previewUrl,
        },
      ]);

      try {
        // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹æ›´æ–°ï¼ˆæ“¬ä¼¼çš„ï¼‰
        setUploadingFiles((prev) =>
          prev.map((f) => (f.id === id ? { ...f, progress: 30 } : f))
        );

        const url = await uploadFile(file);

        setUploadingFiles((prev) =>
          prev.map((f) =>
            f.id === id ? { ...f, progress: 100, status: 'completed' } : f
          )
        );

        onUploaded(url);

        // å®Œäº†ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’å°‘ã—å¾Œã«å‰Šé™¤
        setTimeout(() => {
          setUploadingFiles((prev) => prev.filter((f) => f.id !== id));
          URL.revokeObjectURL(previewUrl);
        }, 2000);
      } catch (error) {
        setUploadingFiles((prev) =>
          prev.map((f) =>
            f.id === id
              ? {
                  ...f,
                  status: 'error',
                  error:
                    error instanceof Error
                      ? error.message
                      : 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ',
                }
              : f
          )
        );
      }
    }
  };

  const handleRemoveFile = (id: string) => {
    const file = uploadingFiles.find((f) => f.id === id);
    if (file?.previewUrl) {
      URL.revokeObjectURL(file.previewUrl);
    }
    setUploadingFiles((prev) => prev.filter((f) => f.id !== id));
  };

  const handleClick = () => {
    if (!disabled) {
      fileInputRef.current?.click();
    }
  };

  return (
    <Stack gap="sm">
      {/* ãƒ‰ãƒ­ãƒƒãƒ—ã‚¾ãƒ¼ãƒ³ */}
      <Paper
        p="lg"
        radius="md"
        withBorder
        style={{
          borderStyle: 'dashed',
          borderColor: isDragging
            ? 'var(--mantine-color-blue-5)'
            : 'var(--mantine-color-gray-4)',
          backgroundColor: isDragging
            ? 'var(--mantine-color-blue-0)'
            : 'transparent',
          cursor: disabled ? 'not-allowed' : 'pointer',
          opacity: disabled ? 0.5 : 1,
          transition: 'all 0.2s',
        }}
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        onDrop={handleDrop}
        onClick={handleClick}
      >
        <Stack align="center" gap="xs">
          <IconUpload
            size={32}
            stroke={1.5}
            color={
              isDragging
                ? 'var(--mantine-color-blue-5)'
                : 'var(--mantine-color-gray-5)'
            }
          />
          <Text size="sm" c="dimmed" ta="center">
            ç”»åƒã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—
            <br />
            ã¾ãŸã¯ã‚¯ãƒªãƒƒã‚¯ã—ã¦é¸æŠ
          </Text>
          <Text size="xs" c="dimmed">
            JPEG, PNG, WebP å¯¾å¿œ
          </Text>
        </Stack>
      </Paper>

      {/* éš ã—ãƒ•ã‚¡ã‚¤ãƒ«ã‚¤ãƒ³ãƒ—ãƒƒãƒˆ */}
      <input
        ref={fileInputRef}
        type="file"
        accept="image/*"
        multiple
        style={{ display: 'none' }}
        onChange={handleFileSelect}
      />

      {/* ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ä¸­ã®ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ */}
      {uploadingFiles.length > 0 && (
        <Stack gap="xs">
          {uploadingFiles.map((file) => (
            <Paper key={file.id} p="xs" radius="sm" withBorder>
              <Group gap="sm" wrap="nowrap">
                {/* ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ */}
                <Box
                  w={40}
                  h={40}
                  style={{
                    borderRadius: 4,
                    overflow: 'hidden',
                    flexShrink: 0,
                  }}
                >
                  {file.previewUrl ? (
                    <Image
                      src={file.previewUrl}
                      alt={file.name}
                      w={40}
                      h={40}
                      fit="cover"
                    />
                  ) : (
                    <Box
                      w={40}
                      h={40}
                      style={{
                        backgroundColor: 'var(--mantine-color-gray-1)',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                      }}
                    >
                      <IconPhoto size={20} />
                    </Box>
                  )}
                </Box>

                {/* ãƒ•ã‚¡ã‚¤ãƒ«åã¨ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ */}
                <Stack gap={4} style={{ flex: 1, minWidth: 0 }}>
                  <Text size="sm" lineClamp={1}>
                    {file.name}
                  </Text>
                  {file.status === 'uploading' && (
                    <Progress value={file.progress} size="xs" animated />
                  )}
                  {file.status === 'error' && (
                    <Text size="xs" c="red">
                      {file.error}
                    </Text>
                  )}
                </Stack>

                {/* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚¢ã‚¤ã‚³ãƒ³ */}
                {file.status === 'completed' && (
                  <IconCheck size={20} color="var(--mantine-color-green-5)" />
                )}
                {file.status === 'error' && (
                  <ActionIcon
                    variant="subtle"
                    color="red"
                    size="sm"
                    onClick={() => handleRemoveFile(file.id)}
                  >
                    <IconX size={16} />
                  </ActionIcon>
                )}
              </Group>
            </Paper>
          ))}
        </Stack>
      )}
    </Stack>
  );
}
````

## File: frontend/src/app/gallery/components/MediaCarousel.tsx
````typescript
'use client';

/**
 * ãƒ¡ãƒ‡ã‚£ã‚¢ã‚«ãƒ«ãƒ¼ã‚»ãƒ«ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * ç”»åƒã¨YouTubeå‹•ç”»ã®ã‚¹ãƒ©ã‚¤ãƒ‰è¡¨ç¤º
 */

import { useState } from 'react';
import {
  Box,
  Image,
  ActionIcon,
  Group,
  AspectRatio,
  Indicator,
} from '@mantine/core';
import {
  IconChevronLeft,
  IconChevronRight,
  IconBrandYoutube,
} from '@tabler/icons-react';
import type { GalleryMedia } from '@/lib/api/hooks/use-gallery';

/**
 * YouTube URLã‹ã‚‰ãƒ“ãƒ‡ã‚ªIDã‚’æŠ½å‡º
 */
function extractYouTubeId(url: string): string | null {
  const patterns = [
    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
    /youtube\.com\/shorts\/([^&\n?#]+)/,
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match && match[1]) {
      return match[1];
    }
  }
  return null;
}

/**
 * YouTubeåŸ‹ã‚è¾¼ã¿ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 */
function YouTubeEmbed({ url }: { url: string }) {
  const videoId = extractYouTubeId(url);

  if (!videoId) {
    return (
      <Box
        style={{
          width: '100%',
          height: '100%',
          backgroundColor: 'var(--mantine-color-dark-6)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
        }}
      >
        <IconBrandYoutube size={48} color="var(--mantine-color-red-5)" />
      </Box>
    );
  }

  return (
    <iframe
      src={`https://www.youtube.com/embed/${videoId}`}
      title="YouTube video"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowFullScreen
      style={{
        width: '100%',
        height: '100%',
        border: 'none',
      }}
    />
  );
}

interface MediaCarouselProps {
  /** ãƒ¡ãƒ‡ã‚£ã‚¢ä¸€è¦§ */
  media: GalleryMedia[];
  /** ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯” */
  aspectRatio?: number;
  /** ã‚¯ãƒªãƒƒã‚¯æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆãƒ©ã‚¤ãƒˆãƒœãƒƒã‚¯ã‚¹è¡¨ç¤ºç”¨ï¼‰ */
  onMediaClick?: (index: number) => void;
}

/**
 * ãƒ¡ãƒ‡ã‚£ã‚¢ã‚«ãƒ«ãƒ¼ã‚»ãƒ«ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 *
 * @example
 * ```tsx
 * <MediaCarousel
 *   media={entry.media}
 *   aspectRatio={4 / 3}
 *   onMediaClick={(index) => openLightbox(index)}
 * />
 * ```
 */
export function MediaCarousel({
  media,
  aspectRatio = 4 / 3,
  onMediaClick,
}: MediaCarouselProps) {
  const [currentIndex, setCurrentIndex] = useState(0);

  // orderé †ã§ã‚½ãƒ¼ãƒˆ
  const sortedMedia = [...media].sort((a, b) => a.order - b.order);

  if (sortedMedia.length === 0) {
    return null;
  }

  const currentMedia = sortedMedia[currentIndex];
  const hasMultiple = sortedMedia.length > 1;

  const handlePrev = (e: React.MouseEvent) => {
    e.stopPropagation();
    setCurrentIndex((prev) =>
      prev === 0 ? sortedMedia.length - 1 : prev - 1
    );
  };

  const handleNext = (e: React.MouseEvent) => {
    e.stopPropagation();
    setCurrentIndex((prev) =>
      prev === sortedMedia.length - 1 ? 0 : prev + 1
    );
  };

  const handleClick = () => {
    onMediaClick?.(currentIndex);
  };

  return (
    <Box pos="relative">
      <AspectRatio ratio={aspectRatio}>
        <Box
          onClick={handleClick}
          style={{ cursor: onMediaClick ? 'pointer' : 'default' }}
        >
          {currentMedia.type === 'YOUTUBE' ? (
            <YouTubeEmbed url={currentMedia.url} />
          ) : (
            <Image
              src={currentMedia.url}
              alt="Gallery media"
              fit="cover"
              style={{ width: '100%', height: '100%' }}
            />
          )}
        </Box>
      </AspectRatio>

      {/* ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ */}
      {hasMultiple && (
        <>
          <ActionIcon
            variant="filled"
            color="dark"
            opacity={0.7}
            radius="xl"
            size="lg"
            pos="absolute"
            left={8}
            top="50%"
            style={{ transform: 'translateY(-50%)' }}
            onClick={handlePrev}
          >
            <IconChevronLeft size={20} />
          </ActionIcon>

          <ActionIcon
            variant="filled"
            color="dark"
            opacity={0.7}
            radius="xl"
            size="lg"
            pos="absolute"
            right={8}
            top="50%"
            style={{ transform: 'translateY(-50%)' }}
            onClick={handleNext}
          >
            <IconChevronRight size={20} />
          </ActionIcon>
        </>
      )}

      {/* ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ */}
      {hasMultiple && (
        <Group
          gap={4}
          justify="center"
          pos="absolute"
          bottom={8}
          left={0}
          right={0}
        >
          {sortedMedia.map((m, index) => (
            <Indicator
              key={m.id}
              color={index === currentIndex ? 'blue' : 'gray'}
              size={8}
              processing={false}
              position="middle-center"
              offset={0}
              style={{ cursor: 'pointer' }}
              onClick={(e) => {
                e.stopPropagation();
                setCurrentIndex(index);
              }}
            >
              <Box w={8} h={8} />
            </Indicator>
          ))}
        </Group>
      )}

      {/* YouTubeãƒãƒƒã‚¸ */}
      {currentMedia.type === 'YOUTUBE' && (
        <Box
          pos="absolute"
          top={8}
          right={8}
          style={{
            backgroundColor: 'rgba(255, 0, 0, 0.8)',
            borderRadius: 4,
            padding: '2px 6px',
          }}
        >
          <IconBrandYoutube size={16} color="white" />
        </Box>
      )}
    </Box>
  );
}
````

## File: frontend/src/app/gallery/components/MediaLightbox.tsx
````typescript
'use client';

/**
 * ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ©ã‚¤ãƒˆãƒœãƒƒã‚¯ã‚¹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã§ã®ãƒ¡ãƒ‡ã‚£ã‚¢è¡¨ç¤º
 */

import { useState, useEffect, useCallback } from 'react';
import {
  Modal,
  Box,
  Image,
  ActionIcon,
  Group,
  Text,
  Stack,
  CloseButton,
} from '@mantine/core';
import {
  IconChevronLeft,
  IconChevronRight,
  IconBrandYoutube,
  IconDownload,
} from '@tabler/icons-react';
import type { GalleryMedia } from '@/lib/api/hooks/use-gallery';

/**
 * YouTube URLã‹ã‚‰ãƒ“ãƒ‡ã‚ªIDã‚’æŠ½å‡º
 */
function extractYouTubeId(url: string): string | null {
  const patterns = [
    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
    /youtube\.com\/shorts\/([^&\n?#]+)/,
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match && match[1]) {
      return match[1];
    }
  }
  return null;
}

interface MediaLightboxProps {
  /** ãƒ¡ãƒ‡ã‚£ã‚¢ä¸€è¦§ */
  media: GalleryMedia[];
  /** è¡¨ç¤º/éè¡¨ç¤º */
  opened: boolean;
  /** é–‰ã˜ã‚‹æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
  onClose: () => void;
  /** åˆæœŸè¡¨ç¤ºã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ */
  initialIndex?: number;
}

/**
 * ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ©ã‚¤ãƒˆãƒœãƒƒã‚¯ã‚¹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 *
 * @example
 * ```tsx
 * <MediaLightbox
 *   media={entry.media}
 *   opened={lightboxOpened}
 *   onClose={() => setLightboxOpened(false)}
 *   initialIndex={0}
 * />
 * ```
 */
export function MediaLightbox({
  media,
  opened,
  onClose,
  initialIndex = 0,
}: MediaLightboxProps) {
  const [currentIndex, setCurrentIndex] = useState(initialIndex);

  // orderé †ã§ã‚½ãƒ¼ãƒˆ
  const sortedMedia = [...media].sort((a, b) => a.order - b.order);

  // åˆæœŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒå¤‰ã‚ã£ãŸã‚‰ãƒªã‚»ãƒƒãƒˆ
  useEffect(() => {
    setCurrentIndex(initialIndex);
  }, [initialIndex]);

  const currentMedia = sortedMedia[currentIndex];
  const hasMultiple = sortedMedia.length > 1;

  const handlePrev = useCallback(() => {
    setCurrentIndex((prev) =>
      prev === 0 ? sortedMedia.length - 1 : prev - 1
    );
  }, [sortedMedia.length]);

  const handleNext = useCallback(() => {
    setCurrentIndex((prev) =>
      prev === sortedMedia.length - 1 ? 0 : prev + 1
    );
  }, [sortedMedia.length]);

  // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
  useEffect(() => {
    if (!opened) return;

    const handleKeyDown = (e: KeyboardEvent) => {
      switch (e.key) {
        case 'ArrowLeft':
          handlePrev();
          break;
        case 'ArrowRight':
          handleNext();
          break;
        case 'Escape':
          onClose();
          break;
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [opened, handlePrev, handleNext, onClose]);

  if (sortedMedia.length === 0) {
    return null;
  }

  const handleDownload = async () => {
    if (currentMedia.type === 'YOUTUBE') return;

    try {
      const response = await fetch(currentMedia.url);
      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `gallery-${currentMedia.id}.jpg`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.URL.revokeObjectURL(url);
    } catch {
      // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å¤±æ•—æ™‚ã¯ä½•ã‚‚ã—ãªã„
    }
  };

  return (
    <Modal
      opened={opened}
      onClose={onClose}
      fullScreen
      withCloseButton={false}
      padding={0}
      styles={{
        body: {
          height: '100%',
          display: 'flex',
          flexDirection: 'column',
          backgroundColor: 'rgba(0, 0, 0, 0.95)',
        },
        content: {
          backgroundColor: 'transparent',
        },
      }}
    >
      {/* ãƒ˜ãƒƒãƒ€ãƒ¼ */}
      <Group
        justify="space-between"
        p="md"
        style={{ backgroundColor: 'rgba(0, 0, 0, 0.5)' }}
      >
        <Text c="white" size="sm">
          {currentIndex + 1} / {sortedMedia.length}
        </Text>
        <Group gap="xs">
          {currentMedia.type === 'IMAGE' && (
            <ActionIcon
              variant="subtle"
              color="white"
              size="lg"
              onClick={handleDownload}
              title="ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰"
            >
              <IconDownload size={20} />
            </ActionIcon>
          )}
          <CloseButton
            variant="subtle"
            color="white"
            size="lg"
            onClick={onClose}
          />
        </Group>
      </Group>

      {/* ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ */}
      <Box
        style={{
          flex: 1,
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          position: 'relative',
          padding: '0 60px',
        }}
      >
        {/* å‰ã¸ãƒœã‚¿ãƒ³ */}
        {hasMultiple && (
          <ActionIcon
            variant="filled"
            color="dark"
            opacity={0.7}
            radius="xl"
            size="xl"
            pos="absolute"
            left={16}
            onClick={handlePrev}
          >
            <IconChevronLeft size={24} />
          </ActionIcon>
        )}

        {/* ãƒ¡ãƒ‡ã‚£ã‚¢è¡¨ç¤º */}
        <Box
          style={{
            maxWidth: '100%',
            maxHeight: 'calc(100vh - 120px)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
          }}
        >
          {currentMedia.type === 'YOUTUBE' ? (
            <Box
              style={{
                width: '80vw',
                maxWidth: '1200px',
                aspectRatio: '16 / 9',
              }}
            >
              {(() => {
                const videoId = extractYouTubeId(currentMedia.url);
                if (!videoId) {
                  return (
                    <Stack align="center" justify="center" h="100%">
                      <IconBrandYoutube
                        size={64}
                        color="var(--mantine-color-red-5)"
                      />
                      <Text c="white">å‹•ç”»ã‚’èª­ã¿è¾¼ã‚ã¾ã›ã‚“ã§ã—ãŸ</Text>
                    </Stack>
                  );
                }
                return (
                  <iframe
                    src={`https://www.youtube.com/embed/${videoId}?autoplay=1`}
                    title="YouTube video"
                    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                    allowFullScreen
                    style={{
                      width: '100%',
                      height: '100%',
                      border: 'none',
                    }}
                  />
                );
              })()}
            </Box>
          ) : (
            <Image
              src={currentMedia.url}
              alt="Gallery media"
              fit="contain"
              style={{
                maxWidth: '100%',
                maxHeight: 'calc(100vh - 120px)',
              }}
            />
          )}
        </Box>

        {/* æ¬¡ã¸ãƒœã‚¿ãƒ³ */}
        {hasMultiple && (
          <ActionIcon
            variant="filled"
            color="dark"
            opacity={0.7}
            radius="xl"
            size="xl"
            pos="absolute"
            right={16}
            onClick={handleNext}
          >
            <IconChevronRight size={24} />
          </ActionIcon>
        )}
      </Box>

      {/* ã‚µãƒ ãƒã‚¤ãƒ«ä¸€è¦§ */}
      {hasMultiple && (
        <Group
          gap="xs"
          justify="center"
          p="md"
          style={{ backgroundColor: 'rgba(0, 0, 0, 0.5)' }}
        >
          {sortedMedia.map((m, index) => (
            <Box
              key={m.id}
              onClick={() => setCurrentIndex(index)}
              style={{
                width: 60,
                height: 60,
                borderRadius: 4,
                overflow: 'hidden',
                cursor: 'pointer',
                border:
                  index === currentIndex
                    ? '2px solid var(--mantine-color-blue-5)'
                    : '2px solid transparent',
                opacity: index === currentIndex ? 1 : 0.6,
                transition: 'all 0.2s',
              }}
            >
              {m.type === 'YOUTUBE' ? (
                <Box
                  style={{
                    width: '100%',
                    height: '100%',
                    backgroundColor: 'var(--mantine-color-dark-6)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                  }}
                >
                  <IconBrandYoutube
                    size={20}
                    color="var(--mantine-color-red-5)"
                  />
                </Box>
              ) : (
                <Image
                  src={m.thumbnailUrl || m.url}
                  alt="Thumbnail"
                  fit="cover"
                  style={{ width: '100%', height: '100%' }}
                />
              )}
            </Box>
          ))}
        </Group>
      )}
    </Modal>
  );
}
````

## File: frontend/src/app/gallery/components/YouTubeInput.tsx
````typescript
'use client';

/**
 * YouTube URLå…¥åŠ›ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * YouTube URLã®å…¥åŠ›ã¨ã‚µãƒ ãƒã‚¤ãƒ«å–å¾—
 */

import { useState } from 'react';
import {
  TextInput,
  Button,
  Group,
  Paper,
  Text,
  Image,
  Stack,
  ActionIcon,
  Box,
} from '@mantine/core';
import { IconBrandYoutube, IconPlus, IconX } from '@tabler/icons-react';
import { notifications } from '@mantine/notifications';

/**
 * YouTube URLã‹ã‚‰ãƒ“ãƒ‡ã‚ªIDã‚’æŠ½å‡º
 */
function extractYouTubeId(url: string): string | null {
  const patterns = [
    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
    /youtube\.com\/shorts\/([^&\n?#]+)/,
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match && match[1]) {
      return match[1];
    }
  }
  return null;
}

/**
 * YouTubeå‹•ç”»ã®ã‚µãƒ ãƒã‚¤ãƒ«URLã‚’å–å¾—
 */
function getYouTubeThumbnailUrl(videoId: string): string {
  // é«˜å“è³ªã‚µãƒ ãƒã‚¤ãƒ«ï¼ˆå­˜åœ¨ã—ãªã„å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
  return `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;
}

/**
 * YouTube URLã‚’æ­£è¦åŒ–
 */
function normalizeYouTubeUrl(videoId: string): string {
  return `https://www.youtube.com/watch?v=${videoId}`;
}

interface YouTubeInputProps {
  /** è¿½åŠ æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
  onAdded: (url: string, thumbnailUrl?: string) => void;
  /** ç„¡åŠ¹çŠ¶æ…‹ */
  disabled?: boolean;
}

/**
 * YouTube URLå…¥åŠ›ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 *
 * @example
 * ```tsx
 * <YouTubeInput
 *   onAdded={(url, thumbnail) => handleYouTubeAdded(url, thumbnail)}
 * />
 * ```
 */
export function YouTubeInput({ onAdded, disabled }: YouTubeInputProps) {
  const [url, setUrl] = useState('');
  const [preview, setPreview] = useState<{
    videoId: string;
    thumbnailUrl: string;
  } | null>(null);
  const [isValidating, setIsValidating] = useState(false);

  const handleUrlChange = (value: string) => {
    setUrl(value);
    setPreview(null);
  };

  const handleValidate = () => {
    if (!url.trim()) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: 'URLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„',
        color: 'red',
      });
      return;
    }

    setIsValidating(true);

    const videoId = extractYouTubeId(url);

    if (!videoId) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: 'æœ‰åŠ¹ãªYouTube URLã§ã¯ã‚ã‚Šã¾ã›ã‚“',
        color: 'red',
      });
      setIsValidating(false);
      return;
    }

    const thumbnailUrl = getYouTubeThumbnailUrl(videoId);
    setPreview({ videoId, thumbnailUrl });
    setIsValidating(false);
  };

  const handleAdd = () => {
    if (!preview) return;

    const normalizedUrl = normalizeYouTubeUrl(preview.videoId);
    onAdded(normalizedUrl, preview.thumbnailUrl);

    // ãƒªã‚»ãƒƒãƒˆ
    setUrl('');
    setPreview(null);

    notifications.show({
      title: 'è¿½åŠ å®Œäº†',
      message: 'YouTubeå‹•ç”»ã‚’è¿½åŠ ã—ã¾ã—ãŸ',
      color: 'green',
    });
  };

  const handleClearPreview = () => {
    setPreview(null);
    setUrl('');
  };

  return (
    <Stack gap="sm">
      {/* URLå…¥åŠ› */}
      <Group gap="sm" align="flex-end">
        <TextInput
          label="YouTube URL"
          placeholder="https://www.youtube.com/watch?v=..."
          value={url}
          onChange={(e) => handleUrlChange(e.currentTarget.value)}
          disabled={disabled}
          style={{ flex: 1 }}
          leftSection={<IconBrandYoutube size={16} />}
        />
        <Button
          variant="light"
          onClick={handleValidate}
          loading={isValidating}
          disabled={disabled || !url.trim()}
        >
          ç¢ºèª
        </Button>
      </Group>

      {/* ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ */}
      {preview && (
        <Paper p="sm" radius="md" withBorder>
          <Group gap="md" wrap="nowrap">
            <Box
              w={120}
              h={90}
              style={{
                borderRadius: 4,
                overflow: 'hidden',
                position: 'relative',
                flexShrink: 0,
              }}
            >
              <Image
                src={preview.thumbnailUrl}
                alt="YouTube thumbnail"
                w={120}
                h={90}
                fit="cover"
              />
              <Box
                pos="absolute"
                top={0}
                left={0}
                right={0}
                bottom={0}
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  backgroundColor: 'rgba(0, 0, 0, 0.3)',
                }}
              >
                <IconBrandYoutube size={32} color="white" />
              </Box>
            </Box>

            <Stack gap="xs" style={{ flex: 1 }}>
              <Text size="sm" fw={500}>
                YouTubeå‹•ç”»
              </Text>
              <Text size="xs" c="dimmed" lineClamp={2}>
                ID: {preview.videoId}
              </Text>
              <Group gap="xs">
                <Button
                  size="xs"
                  leftSection={<IconPlus size={14} />}
                  onClick={handleAdd}
                >
                  è¿½åŠ 
                </Button>
                <ActionIcon
                  variant="subtle"
                  color="gray"
                  onClick={handleClearPreview}
                >
                  <IconX size={16} />
                </ActionIcon>
              </Group>
            </Stack>
          </Group>
        </Paper>
      )}

      {/* ãƒ˜ãƒ«ãƒ—ãƒ†ã‚­ã‚¹ãƒˆ */}
      <Text size="xs" c="dimmed">
        å¯¾å¿œå½¢å¼: youtube.com/watch?v=..., youtu.be/..., youtube.com/shorts/...
      </Text>
    </Stack>
  );
}
````

## File: frontend/src/app/gallery/hooks/useGalleryTab.ts
````typescript
'use client';

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¿ãƒ–ã®URLåŒæœŸç®¡ç†ãƒ•ãƒƒã‚¯
 * URLã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ã‚¿ãƒ–çŠ¶æ…‹ã‚’åŒæœŸ
 */

import { useSearchParams, useRouter, usePathname } from 'next/navigation';
import { useCallback, useMemo } from 'react';
import type { GalleryCategory } from '@/lib/api/hooks/use-gallery';

/**
 * æœ‰åŠ¹ãªã‚¿ãƒ–ä¸€è¦§
 */
const VALID_TABS: GalleryCategory[] = [
  'KITTEN',
  'FATHER',
  'MOTHER',
  'GRADUATION',
];

/**
 * ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¿ãƒ–
 */
const DEFAULT_TAB: GalleryCategory = 'KITTEN';

/**
 * ã‚¿ãƒ–ã®ãƒ©ãƒ™ãƒ«ãƒãƒƒãƒ”ãƒ³ã‚°
 */
export const TAB_LABELS: Record<GalleryCategory, string> = {
  KITTEN: 'å­çŒ«',
  FATHER: 'çˆ¶çŒ«',
  MOTHER: 'æ¯çŒ«',
  GRADUATION: 'å’æ¥­çŒ«',
};

/**
 * URLã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰ã‚«ãƒ†ã‚´ãƒªã‚’åˆ¤å®šã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼
 */
function parseTabFromQuery(tabQuery: string | null): GalleryCategory {
  if (!tabQuery) return DEFAULT_TAB;
  const upperTab = tabQuery.toUpperCase() as GalleryCategory;
  return VALID_TABS.includes(upperTab) ? upperTab : DEFAULT_TAB;
}

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¿ãƒ–ç®¡ç†ãƒ•ãƒƒã‚¯
 *
 * @returns currentTab - ç¾åœ¨ã®ã‚¿ãƒ–
 * @returns setTab - ã‚¿ãƒ–ã‚’å¤‰æ›´ï¼ˆURLåŒæœŸï¼‰
 * @returns tabLabels - ã‚¿ãƒ–ãƒ©ãƒ™ãƒ«ä¸€è¦§
 *
 * @example
 * ```tsx
 * const { currentTab, setTab } = useGalleryTab();
 *
 * return (
 *   <Tabs value={currentTab} onChange={(tab) => setTab(tab as GalleryCategory)}>
 *     ...
 *   </Tabs>
 * );
 * ```
 */
export function useGalleryTab() {
  const searchParams = useSearchParams();
  const router = useRouter();
  const pathname = usePathname();

  /**
   * ç¾åœ¨ã®ã‚¿ãƒ–ï¼ˆURLã‚¯ã‚¨ãƒªã‹ã‚‰å–å¾—ï¼‰
   */
  const currentTab = useMemo(() => {
    const tab = searchParams.get('tab');
    return parseTabFromQuery(tab);
  }, [searchParams]);

  /**
   * ã‚¿ãƒ–ã‚’å¤‰æ›´ã—ã€URLã‚’æ›´æ–°
   */
  const setTab = useCallback(
    (tab: GalleryCategory) => {
      const params = new URLSearchParams(searchParams.toString());
      params.set('tab', tab.toLowerCase());
      // ãƒšãƒ¼ã‚¸ã¯ãƒªã‚»ãƒƒãƒˆ
      params.delete('page');
      router.push(`${pathname}?${params.toString()}`, { scroll: false });
    },
    [searchParams, router, pathname]
  );

  /**
   * æœ‰åŠ¹ãªã‚¿ãƒ–ä¸€è¦§ã‚’å–å¾—
   */
  const validTabs = useMemo(() => VALID_TABS, []);

  return {
    currentTab,
    setTab,
    tabLabels: TAB_LABELS,
    validTabs,
  };
}

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ç®¡ç†ãƒ•ãƒƒã‚¯
 */
export function useGalleryPagination() {
  const searchParams = useSearchParams();
  const router = useRouter();
  const pathname = usePathname();

  /**
   * ç¾åœ¨ã®ãƒšãƒ¼ã‚¸ç•ªå·
   */
  const currentPage = useMemo(() => {
    const page = searchParams.get('page');
    const parsed = page ? parseInt(page, 10) : 1;
    return isNaN(parsed) || parsed < 1 ? 1 : parsed;
  }, [searchParams]);

  /**
   * ãƒšãƒ¼ã‚¸ã‚’å¤‰æ›´ã—ã€URLã‚’æ›´æ–°
   */
  const setPage = useCallback(
    (page: number) => {
      const params = new URLSearchParams(searchParams.toString());
      if (page <= 1) {
        params.delete('page');
      } else {
        params.set('page', String(page));
      }
      router.push(`${pathname}?${params.toString()}`, { scroll: false });
    },
    [searchParams, router, pathname]
  );

  return {
    currentPage,
    setPage,
  };
}
````

## File: frontend/src/app/login/page.tsx
````typescript
/**
 * ãƒ­ã‚°ã‚¤ãƒ³ç”»é¢ (å†æ§‹ç¯‰: ãƒ–ãƒ©ãƒ³ãƒ‡ã‚£ãƒ³ã‚°/ãƒ•ã‚©ãƒ³ãƒˆæ­£è¦åŒ–)
 */

'use client';

import { useState, useEffect, useMemo, Suspense } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import {
  Container,
  Paper,
  Title,
  TextInput,
  PasswordInput,
  Button,
  Alert,
  Stack,
  Center,
  Box,
  Text,
  Loader,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { IconAlertCircle } from '@tabler/icons-react';
import { useAuth } from '@/lib/auth/store';

interface LoginFormValues {
  email: string;
  password: string;
}

function LoginForm() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const { login, isAuthenticated, isLoading, error, clearError, initialized } = useAuth();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isMounted, setIsMounted] = useState(false);

  // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã§ã®ã¿ãƒã‚¦ãƒ³ãƒˆçŠ¶æ…‹ã‚’è¨­å®š
  useEffect(() => {
    setIsMounted(true);
  }, []);

  const returnTo = searchParams?.get('returnTo') ?? null;
  const targetPath = useMemo(() => {
    if (typeof returnTo !== 'string' || returnTo.length === 0) {
      return '/';
    }

    if (!returnTo.startsWith('/') || returnTo.startsWith('//')) {
      return '/';
    }

    const disallowed = ['/login', '/register'];
    if (disallowed.includes(returnTo)) {
      return '/';
    }

    return returnTo;
  }, [returnTo]);

  const form = useForm<LoginFormValues>({
    initialValues: { email: '', password: '' },
    validate: {
      email: (value) => {
        if (!value) return 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„';
        if (!/^\S+@\S+$/i.test(value)) return 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã®å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“';
        return null;
      },
      password: (value) => {
        if (!value) return 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„';
        if (value.length < 6) return 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯6æ–‡å­—ä»¥ä¸Šã§å…¥åŠ›ã—ã¦ãã ã•ã„';
        return null;
      },
    },
  });

  // æ—¢ãƒ­ã‚°ã‚¤ãƒ³æ™‚ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ
  useEffect(() => {
    if (initialized && isAuthenticated) {
      router.replace(targetPath);
    }
  }, [initialized, isAuthenticated, router, targetPath]);

  // ã‚¢ãƒ³ãƒã‚¦ãƒ³ãƒˆæ™‚ã‚¨ãƒ©ãƒ¼ã‚¯ãƒªã‚¢
  useEffect(() => () => clearError(), [clearError]);

  const handleSubmit = async (values: LoginFormValues) => {
    setIsSubmitting(true);
    clearError();
    try {
      await login(values);
    } catch (e) {
      console.error('Login error:', e);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Box
      component="main"
      role="main"
      aria-label="ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸"
      style={{
        minHeight: '100vh',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        background: 'linear-gradient(135deg, #eef2ff 0%, #e1f1ff 100%)',
        padding: '1rem',
      }}
    >
      <Container size={420}>
        <Center>
          <Stack gap="lg" style={{ width: '100%' }}>
            <Box style={{ textAlign: 'center' }}>
              <Text
                size="xl"
                style={{ fontSize: '3.5rem', marginBottom: '0.75rem', lineHeight: 1 }}
              >
                ğŸˆ
              </Text>
              <Title
                order={2}
                style={{
                  color: 'var(--text-primary)',
                  fontSize: 18,
                  fontWeight: 700,
                  marginBottom: '0.5rem',
                  letterSpacing: 0.5,
                }}
              >
                MyCats
              </Title>
              <Text style={{ color: 'var(--text-secondary)' }}>ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ç¶šè¡Œ</Text>
            </Box>

            <Paper radius="lg" p="xl" shadow="xl" style={{ boxShadow: '0 16px 40px rgba(15, 23, 42, 0.08)' }}>
              <form onSubmit={form.onSubmit(handleSubmit)} aria-label="ãƒ­ã‚°ã‚¤ãƒ³ãƒ•ã‚©ãƒ¼ãƒ ">
                <Stack gap="md">
                  {error && (
                    <Alert
                      icon={<IconAlertCircle size="1rem" />}
                      title="ãƒ­ã‚°ã‚¤ãƒ³ã‚¨ãƒ©ãƒ¼"
                      color="red"
                      onClose={clearError}
                      withCloseButton
                      role="alert"
                      aria-live="polite"
                    >
                      {error}
                    </Alert>
                  )}
                  <TextInput
                    required
                    label="ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹"
                    placeholder="your@email.com"
                    size="md"
                    aria-label="ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹"
                    aria-required="true"
                    autoComplete="email"
                    {...form.getInputProps('email')}
                    disabled={isSubmitting || isLoading}
                    styles={{
                      label: { color: 'var(--text-secondary)', fontWeight: 500 },
                      input: { backgroundColor: 'var(--surface)' },
                    }}
                  />
                  <PasswordInput
                    required
                    label="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰"
                    placeholder="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›"
                    size="md"
                    aria-label="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰"
                    aria-required="true"
                    autoComplete="current-password"
                    {...form.getInputProps('password')}
                    disabled={isSubmitting || isLoading}
                    styles={{
                      label: { color: 'var(--text-secondary)', fontWeight: 500 },
                      input: { backgroundColor: 'var(--surface)' },
                    }}
                  />
                  <Button
                    type="submit"
                    fullWidth
                    size="md"
                    loading={isSubmitting || isLoading}
                    aria-label="ãƒ­ã‚°ã‚¤ãƒ³"
                    style={{
                      marginTop: '1rem',
                      background: 'var(--accent)',
                      boxShadow: '0 8px 20px rgba(37, 99, 235, 0.25)',
                    }}
                  >
                    ãƒ­ã‚°ã‚¤ãƒ³
                  </Button>
                  <Text size="sm" style={{ textAlign: 'center', color: 'var(--text-secondary)' }}>
                    ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ãŠå¿˜ã‚Œã§ã™ã‹ï¼Ÿ{' '}
                    <Text
                      component="span"
                      style={{ color: 'var(--accent)', cursor: 'pointer', fontWeight: 500 }}
                      onClick={() => {
                        const params = new URLSearchParams();
                        if (returnTo) {
                          params.set('returnTo', targetPath);
                        }
                        const query = params.toString();
                        router.push(query ? `/forgot-password?${query}` : '/forgot-password');
                      }}
                    >
                      ãƒªã‚»ãƒƒãƒˆ
                    </Text>
                  </Text>
                  <Text size="sm" style={{ textAlign: 'center', color: 'var(--text-secondary)', marginTop: '0.5rem' }}>
                    ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ãŠæŒã¡ã§ãªã„æ–¹ã¯{' '}
                    <Text
                      component="span"
                      style={{ color: 'var(--accent)', cursor: 'pointer', fontWeight: 500 }}
                      onClick={() => {
                        const params = new URLSearchParams();
                        if (returnTo) {
                          params.set('returnTo', targetPath);
                        }
                        const query = params.toString();
                        router.push(query ? `/register?${query}` : '/register');
                      }}
                    >
                      æ–°è¦ç™»éŒ²
                    </Text>
                  </Text>
                </Stack>
              </form>
            </Paper>
            {isMounted && (
              <Text size="sm" style={{ textAlign: 'center', color: 'var(--text-secondary)' }}>
                Â© {new Date().getFullYear()} MyCats. All rights reserved.
              </Text>
            )}
          </Stack>
        </Center>
      </Container>
    </Box>
  );
}

export default function LoginPage() {
  return (
    <Suspense
      fallback={
        <Box
          style={{
            minHeight: '100vh',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            background: 'linear-gradient(135deg, #eef2ff 0%, #e1f1ff 100%)',
          }}
        >
          <Loader size="lg" />
        </Box>
      }
    >
      <LoginForm />
    </Suspense>
  );
}
````

## File: frontend/src/app/more/page.tsx
````typescript
'use client';

import { useRouter } from 'next/navigation';
import {
  Container,
  Card,
  Group,
  Text,
  SimpleGrid,
  Box,
} from '@mantine/core';
import { PageTitle } from '@/components/PageTitle';
import { 
  IconFileExport,
  IconFileImport,
  IconPrinter,
  IconChevronRight
} from '@tabler/icons-react';

interface MenuItem {
  title: string;
  description: string;
  icon: React.ReactNode;
  href: string;
  color: string;
}

const menuItems: MenuItem[] = [
  {
    title: 'å°åˆ·ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç®¡ç†',
    description: 'è¡€çµ±æ›¸ã‚„å„ç¨®æ›¸é¡ã®å°åˆ·ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’è¨­å®š',
    icon: <IconPrinter size={24} />,
    href: '/print-templates',
    color: 'orange'
  },
  {
    title: 'ãƒ‡ãƒ¼ã‚¿ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ',
    description: 'çŒ«ã®æƒ…å ±ã‚’CSVã‚„PDFã§å‡ºåŠ›',
    icon: <IconFileExport size={24} />,
    href: '/export',
    color: 'cyan'
  },
  {
    title: 'ãƒ‡ãƒ¼ã‚¿ã‚¤ãƒ³ãƒãƒ¼ãƒˆ',
    description: 'CSVãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰çŒ«ã®æƒ…å ±ã‚’ä¸€æ‹¬ç™»éŒ²',
    icon: <IconFileImport size={24} />,
    href: '/import',
    color: 'teal'
  }
];

export default function MorePage() {
  const router = useRouter();

  const handleNavigate = (href: string) => {
    router.push(href);
  };

  return (
  <Container size="lg" style={{ minHeight: '100vh', backgroundColor: 'var(--background-base)', padding: '1rem', paddingBottom: '5rem' }}>
      {/* ãƒ˜ãƒƒãƒ€ãƒ¼ */}
      <Group justify="center" mb="lg">
  <PageTitle style={{ color: 'var(--text-primary)' }}>ãã®ä»–ã®æ©Ÿèƒ½</PageTitle>
      </Group>

      {/* æ©Ÿèƒ½ä¸€è¦§ */}
      <SimpleGrid cols={{ base: 1, sm: 2 }} spacing="md">
        {menuItems.map((item, index) => (
          <Card 
            key={index}
            shadow="sm" 
            padding="lg" 
            radius="md" 
            withBorder
            style={{ cursor: 'pointer', transition: 'transform 0.2s ease' }}
            onMouseEnter={(e) => {
              e.currentTarget.style.transform = 'translateY(-2px)';
            }}
            onMouseLeave={(e) => {
              e.currentTarget.style.transform = 'translateY(0)';
            }}
            onClick={() => handleNavigate(item.href)}
          >
            <Group justify="space-between" align="flex-start" wrap="nowrap">
              <Group align="flex-start" gap="md">
                <Box
                  style={{
                    padding: '12px',
                    borderRadius: '8px',
                    backgroundColor: `var(--mantine-color-${item.color}-1)`,
                    color: `var(--mantine-color-${item.color}-7)`,
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center'
                  }}
                >
                  {item.icon}
                </Box>
                <Box style={{ flex: 1 }}>
                  <Text fw={600} size="md" mb="xs">
                    {item.title}
                  </Text>
                  <Text size="sm" c="dimmed" style={{ lineHeight: 1.4 }}>
                    {item.description}
                  </Text>
                </Box>
              </Group>
              <IconChevronRight 
                size={20} 
                style={{ 
                  color: 'var(--mantine-color-gray-5)',
                  marginTop: '2px',
                  flexShrink: 0
                }} 
              />
            </Group>
          </Card>
        ))}
      </SimpleGrid>
    </Container>
  );
}
````

## File: frontend/src/app/pedigrees/new/page.tsx
````typescript
import { redirect } from 'next/navigation';

/**
 * æ—§è¡€çµ±æ›¸ç™»éŒ²ãƒšãƒ¼ã‚¸ - ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆç”¨
 * 
 * ã“ã®ãƒšãƒ¼ã‚¸ã¯ `/pedigrees/new` ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’ `/pedigrees?tab=register` ã«ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã—ã¾ã™ã€‚
 * æ–°ã—ã„çµ±åˆUIã§ã¯ã€ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆã§ç™»éŒ²ãƒ»ç·¨é›†ãƒ»æ›´æ–°ãŒå¯èƒ½ã§ã™ã€‚
 */
export default function NewPedigreeRedirect() {
  redirect('/pedigrees?tab=register');
}
````

## File: frontend/src/app/print-templates/page.tsx
````typescript
'use client';

import { Container } from '@mantine/core';
import { useEffect } from 'react';
import { usePageHeader } from '@/lib/contexts/page-header-context';
import { PrintTemplateManager } from '@/components/print-templates/PrintTemplateManager';

export default function PrintTemplatesPage() {
  const { setPageTitle } = usePageHeader();

  useEffect(() => {
    setPageTitle('å°åˆ·ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç®¡ç†');
    return () => setPageTitle(null);
  }, [setPageTitle]);

  return (
    <Container size="xl" py="md">
      <PrintTemplateManager />
    </Container>
  );
}
````

## File: frontend/src/app/register/page.tsx
````typescript
/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²ç”»é¢
 */

'use client';

import { useMemo, useState, Suspense } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import {
  Container,
  Paper,
  Title,
  TextInput,
  PasswordInput,
  Button,
  Alert,
  Stack,
  Center,
  Box,
  Text,
  Anchor,
  Loader,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { IconAlertCircle, IconCheck } from '@tabler/icons-react';
import { apiClient, type ApiRequestBody } from '@/lib/api/client';

type RegisterRequestBody = ApiRequestBody<'/auth/register', 'post'>;

interface RegisterFormValues {
  email: string;
  password: string;
  confirmPassword: string;
}

function RegisterForm() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);

  const returnTo = searchParams?.get('returnTo') ?? null;
  const targetPath = useMemo(() => {
    if (!returnTo || !returnTo.startsWith('/') || returnTo.startsWith('//')) {
      return '/';
    }
    const disallowed = ['/login', '/register'];
    return disallowed.includes(returnTo) ? '/' : returnTo;
  }, [returnTo]);

  // ãƒ•ã‚©ãƒ¼ãƒ è¨­å®š
  const form = useForm<RegisterFormValues>({
    initialValues: {
      email: '',
      password: '',
      confirmPassword: '',
    },
    validate: {
      email: (value) => {
        if (!value) return 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„';
        if (!/^\S+@\S+$/i.test(value)) return 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã®å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“';
        return null;
      },
      password: (value) => {
        if (!value) return 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„';
        if (value.length < 6) return 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯6æ–‡å­—ä»¥ä¸Šã§å…¥åŠ›ã—ã¦ãã ã•ã„';
        return null;
      },
      confirmPassword: (value, values) => {
        if (!value) return 'ç¢ºèªç”¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„';
        if (value !== values.password) return 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒä¸€è‡´ã—ã¾ã›ã‚“';
        return null;
      },
    },
  });

  // ç™»éŒ²å‡¦ç†
  const handleSubmit = async (values: RegisterFormValues) => {
    setIsSubmitting(true);
    setError(null);

    try {
      const payload: RegisterRequestBody = {
        email: values.email,
        password: values.password,
      };

      const response = await apiClient.post('/auth/register', {
        body: payload,
        retryOnUnauthorized: false,
      });

      if (response.success) {
        setSuccess(true);
        // 3ç§’å¾Œã«ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã¸ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ
        setTimeout(() => {
          if (returnTo && targetPath !== '/') {
            router.push(`/login?returnTo=${encodeURIComponent(targetPath)}`);
          } else {
            router.push('/login');
          }
        }, 3000);
      } else {
        setError(response.message || 'ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }
    } catch (err) {
      console.error('Registration error:', err);
  setError(err instanceof Error ? err.message : 'ç™»éŒ²ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Box
      style={{
        minHeight: '100vh',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        background: 'linear-gradient(135deg, #eef2ff 0%, #e1f1ff 100%)',
        padding: '1rem',
      }}
    >
      <Container size={420}>
        <Center>
          <Stack gap="lg" style={{ width: '100%' }}>
            {/* ãƒ­ã‚´ãƒ»ã‚¿ã‚¤ãƒˆãƒ« */}
            <Paper
              shadow="md"
              p="xl"
              radius="lg"
              style={{ width: '100%', boxShadow: '0 16px 40px rgba(15, 23, 42, 0.08)' }}
            >
              <Title order={2} ta="center" mb="md" style={{ color: 'var(--text-primary)', fontSize: 18, display: 'flex', flexDirection: 'column', gap: 4 }}>
                <span style={{ fontSize: '3.5rem', lineHeight: 1, display: 'block' }}>ğŸˆ</span>
                <span style={{ fontSize: 18, fontWeight: 700 }}>MyCats æ–°è¦ç™»éŒ²</span>
              </Title>
              <Text size="sm" ta="center" mb="xl" style={{ color: 'var(--text-muted)' }}>
                MyCats ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ä½œæˆ
              </Text>

              {/* æˆåŠŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ */}
              {success && (
                <Alert
                  icon={<IconCheck size={16} />}
                  title="ç™»éŒ²æˆåŠŸï¼"
                  color="green"
                  mb="md"
                >
                  ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãŒä½œæˆã•ã‚Œã¾ã—ãŸã€‚ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã¸ç§»å‹•ã—ã¾ã™...
                </Alert>
              )}

              {/* ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ */}
              {error && (
                <Alert
                  icon={<IconAlertCircle size={16} />}
                  title="ã‚¨ãƒ©ãƒ¼"
                  color="red"
                  mb="md"
                  withCloseButton
                  onClose={() => setError(null)}
                >
                  {error}
                </Alert>
              )}

              {!success && (
                <form onSubmit={form.onSubmit(handleSubmit)}>
                  <Stack gap="md">
                    {/* ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ */}
                    <TextInput
                      label="ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹"
                      placeholder="your@email.com"
                      required
                      styles={{
                        label: { color: 'var(--text-secondary)', fontWeight: 500 },
                        input: { backgroundColor: 'var(--surface)' },
                      }}
                      {...form.getInputProps('email')}
                    />

                    {/* ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ */}
                    <PasswordInput
                      label="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰"
                      placeholder="6æ–‡å­—ä»¥ä¸Š"
                      required
                      styles={{
                        label: { color: 'var(--text-secondary)', fontWeight: 500 },
                        input: { backgroundColor: 'var(--surface)' },
                      }}
                      {...form.getInputProps('password')}
                    />

                    {/* ç¢ºèªç”¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ */}
                    <PasswordInput
                      label="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼ˆç¢ºèªï¼‰"
                      placeholder="ã‚‚ã†ä¸€åº¦å…¥åŠ›"
                      required
                      styles={{
                        label: { color: 'var(--text-secondary)', fontWeight: 500 },
                        input: { backgroundColor: 'var(--surface)' },
                      }}
                      {...form.getInputProps('confirmPassword')}
                    />

                    {/* ç™»éŒ²ãƒœã‚¿ãƒ³ */}
                    <Button
                      type="submit"
                      fullWidth
                      mt="md"
                      loading={isSubmitting}
                      disabled={isSubmitting}
                      style={{ background: 'var(--accent)', boxShadow: '0 8px 20px rgba(37, 99, 235, 0.25)' }}
                    >
                      ç™»éŒ²
                    </Button>

                    {/* ãƒ­ã‚°ã‚¤ãƒ³ãƒªãƒ³ã‚¯ */}
                    <Text ta="center" mt="md" size="sm" style={{ color: 'var(--text-secondary)' }}>
                      æ—¢ã«ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ãŠæŒã¡ã§ã™ã‹ï¼Ÿ{' '}
                      <Anchor
                        component="button"
                        type="button"
                        onClick={() => {
                          if (returnTo && targetPath !== '/') {
                            router.push(`/login?returnTo=${encodeURIComponent(targetPath)}`);
                          } else {
                            router.push('/login');
                          }
                        }}
                        fw={500}
                        style={{ color: 'var(--accent)' }}
                      >
                        ãƒ­ã‚°ã‚¤ãƒ³
                      </Anchor>
                    </Text>
                  </Stack>
                </form>
              )}
            </Paper>

            {/* ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰è¦ä»¶ã¨ãƒ†ã‚¹ãƒˆç”¨æƒ…å ± */}
            <Paper
              shadow="sm"
              p="md"
              radius="lg"
              style={{ backgroundColor: 'rgba(255, 255, 255, 0.9)', backdropFilter: 'blur(4px)' }}
            >
              <Text size="xs" ta="center" mb="xs" fw={700} style={{ color: 'var(--text-secondary)' }}>
                ğŸ” ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰è¦ä»¶
              </Text>
              <Stack gap={4}>
                <Text size="xs" style={{ color: 'var(--text-secondary)' }}>
                  âœ“ 8æ–‡å­—ä»¥ä¸Š
                </Text>
                <Text size="xs" style={{ color: 'var(--text-secondary)' }}>
                  âœ“ å°æ–‡å­—ã‚’å«ã‚€ (a-z)
                </Text>
                <Text size="xs" style={{ color: 'var(--text-secondary)' }}>
                  âœ“ å¤§æ–‡å­—ã‚’å«ã‚€ (A-Z)
                </Text>
                <Text size="xs" style={{ color: 'var(--text-secondary)' }}>
                  âœ“ æ•°å­—ã‚’å«ã‚€ (0-9)
                </Text>
              </Stack>
              <Text size="xs" ta="center" mt="md" fw={700} style={{ color: 'var(--text-secondary)' }}>
                ğŸ’¡ ãƒ†ã‚¹ãƒˆç”¨ã‚¢ã‚«ã‚¦ãƒ³ãƒˆä¾‹
              </Text>
              <Stack gap={4} mt="xs">
                <Text size="xs" style={{ color: 'var(--text-secondary)' }}>
                  ğŸ“§ Email: admin@example.com
                </Text>
                <Text size="xs" style={{ color: 'var(--text-secondary)' }}>
                  ğŸ” Password: Passw0rd!
                </Text>
              </Stack>
            </Paper>
          </Stack>
        </Center>
      </Container>
    </Box>
  );
}

export default function RegisterPage() {
  return (
    <Suspense
      fallback={
        <Box
          style={{
            minHeight: '100vh',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            background: 'linear-gradient(135deg, #eef2ff 0%, #e1f1ff 100%)',
          }}
        >
          <Loader size="lg" />
        </Box>
      }
    >
      <RegisterForm />
    </Suspense>
  );
}
````

## File: frontend/src/app/reset-password/page.tsx
````typescript
'use client';

import { useState, useEffect, Suspense } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import { Container, Paper, Title, Text, PasswordInput, Button, Alert, Group, Anchor } from '@mantine/core';
import { IconLock, IconCheck, IconAlertCircle } from '@tabler/icons-react';
import Link from 'next/link';
import { usePasswordResetActions, usePasswordResetSelectors } from '@/lib/auth/password-reset-store';

function ResetPasswordForm() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [token, setToken] = useState('');
  const [newPassword, setNewPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const { resetStatus, resetError } = usePasswordResetSelectors();
  const { resetPassword, resetResetState, resetRequestState } = usePasswordResetActions();
  const [localError, setLocalError] = useState<string | null>(null);
  const loading = resetStatus === 'loading';
  const success = resetStatus === 'success';

  useEffect(() => {
    const tokenParam = searchParams.get('token');
    if (tokenParam) {
      setToken(tokenParam);
    } else {
      resetResetState();
      setLocalError('ãƒªã‚»ãƒƒãƒˆãƒˆãƒ¼ã‚¯ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
    }
    return () => {
      resetResetState();
      resetRequestState();
    };
  }, [searchParams, resetRequestState, resetResetState]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLocalError(null);

    if (newPassword !== confirmPassword) {
      setLocalError('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒä¸€è‡´ã—ã¾ã›ã‚“');
      return;
    }

    if (newPassword.length < 8) {
      setLocalError('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯8æ–‡å­—ä»¥ä¸Šã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™');
      return;
    }

    try {
      await resetPassword({ token, newPassword });

      setTimeout(() => {
        router.push('/login');
      }, 3000);
    } catch (err) {
      setLocalError(err instanceof Error ? err.message : 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
    }
  };

  if (!token && !localError && !resetError) {
    return (
      <Container size="xs" style={{ marginTop: '5rem' }}>
        <Paper shadow="md" p="xl" radius="md">
          <Text ta="center">èª­ã¿è¾¼ã¿ä¸­...</Text>
        </Paper>
      </Container>
    );
  }

  if (success) {
    return (
      <Container size="xs" style={{ marginTop: '5rem' }}>
        <Paper shadow="md" p="xl" radius="md">
          <Alert icon={<IconCheck size={16} />} title="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ" color="green" mb="lg">
            ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒæ­£å¸¸ã«ãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã—ãŸã€‚
            ã¾ã‚‚ãªããƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã—ã¾ã™...
          </Alert>
          <Group justify="center">
            <Anchor component={Link} href="/login">
              ä»Šã™ããƒ­ã‚°ã‚¤ãƒ³
            </Anchor>
          </Group>
        </Paper>
      </Container>
    );
  }

  return (
    <Container size="xs" style={{ marginTop: '5rem' }}>
      <Paper shadow="md" p="xl" radius="md">
        <Title order={2} ta="center" mb="md">
          æ–°ã—ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’è¨­å®š
        </Title>
        <Text c="dimmed" size="sm" ta="center" mb="xl">
          æ–°ã—ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„
        </Text>

        {(localError || resetError) && (
          <Alert icon={<IconAlertCircle size={16} />} title="ã‚¨ãƒ©ãƒ¼" color="red" mb="lg">
            {localError || resetError}
          </Alert>
        )}

        <form onSubmit={handleSubmit}>
          <PasswordInput
            label="æ–°ã—ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰"
            placeholder="8æ–‡å­—ä»¥ä¸Š"
            required
            value={newPassword}
            onChange={(e) => setNewPassword(e.target.value)}
            leftSection={<IconLock size={16} />}
            mb="md"
          />

          <PasswordInput
            label="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼ˆç¢ºèªï¼‰"
            placeholder="ã‚‚ã†ä¸€åº¦å…¥åŠ›ã—ã¦ãã ã•ã„"
            required
            value={confirmPassword}
            onChange={(e) => setConfirmPassword(e.target.value)}
            leftSection={<IconLock size={16} />}
            mb="lg"
          />

          <Button
            type="submit"
            fullWidth
            loading={loading}
            disabled={!token}
            mb="md"
          >
            ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆ
          </Button>

          <Group justify="center">
            <Anchor component={Link} href="/login" size="sm">
              ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«æˆ»ã‚‹
            </Anchor>
          </Group>
        </form>
      </Paper>
    </Container>
  );
}

export default function ResetPasswordPage() {
  return (
    <Suspense fallback={
      <Container size="xs" style={{ marginTop: '5rem' }}>
        <Paper shadow="md" p="xl" radius="md">
          <Text ta="center">èª­ã¿è¾¼ã¿ä¸­...</Text>
        </Paper>
      </Container>
    }>
      <ResetPasswordForm />
    </Suspense>
  );
}
````

## File: frontend/src/app/settings/page.tsx
````typescript
import { redirect } from 'next/navigation';

/**
 * è¨­å®šãƒšãƒ¼ã‚¸ - tenantsãƒšãƒ¼ã‚¸ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šã‚¿ãƒ–ã¸ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ
 * 
 * ãƒœãƒˆãƒ ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®šã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šã‚¿ãƒ–ã«çµ±åˆã•ã‚Œã¾ã—ãŸã€‚
 */
export default function SettingsPage() {
  redirect('/tenants');
}
````

## File: frontend/src/app/setup/first-superadmin/page.tsx
````typescript
/**
 * åˆå› SUPER ADMIN ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãƒšãƒ¼ã‚¸
 *
 * - æœªãƒ­ã‚°ã‚¤ãƒ³æ™‚: /login?returnTo=/setup/first-superadmin ã«ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ
 * - ãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿: æ˜‡æ ¼ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤ºã—ã€POST /users/promote-to-superadmin-once ã‚’å‘¼ã³å‡ºã™
 */

'use client';

import { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import {
  Container,
  Paper,
  Title,
  Button,
  Alert,
  Stack,
  Center,
  Box,
  Text,
  Loader,
} from '@mantine/core';
import { IconAlertTriangle, IconCheck, IconLogout, IconShieldCheck } from '@tabler/icons-react';
import { useAuth } from '@/lib/auth/store';
import { apiRequest, ApiError, ApiResponse } from '@/lib/api/client';

/**
 * ãƒšãƒ¼ã‚¸è¡¨ç¤ºçŠ¶æ…‹
 */
type PageState =
  | { status: 'loading' }
  | { status: 'unauthenticated' }
  | { status: 'ready' }
  | { status: 'submitting' }
  | { status: 'success' }
  | { status: 'error'; message: string };

/**
 * æ˜‡æ ¼æˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹ã® data ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å‹
 * ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã¯ { success: true, data: { id, email, role } } ã‚’è¿”ã™
 */
interface PromoteResponseData {
  id: string; // UUID
  email: string;
  role: string;
}

/**
 * æ˜‡æ ¼ API ã‚’å‘¼ã³å‡ºã™
 */
async function promoteToSuperAdmin(): Promise<ApiResponse<PromoteResponseData>> {
  return apiRequest<PromoteResponseData>('/users/promote-to-superadmin-once', {
    method: 'POST',
  });
}

export default function FirstSuperAdminSetupPage() {
  const router = useRouter();
  const { user, isAuthenticated, initialized, logout } = useAuth();
  const [pageState, setPageState] = useState<PageState>({ status: 'loading' });

  // èªè¨¼çŠ¶æ…‹ã«å¿œã˜ãŸåˆæœŸåŒ–
  useEffect(() => {
    if (!initialized) {
      return;
    }

    if (!isAuthenticated) {
      setPageState({ status: 'unauthenticated' });
      // æœªãƒ­ã‚°ã‚¤ãƒ³æ™‚ã¯ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã¸ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ
      router.replace('/login?returnTo=/setup/first-superadmin');
      return;
    }

    setPageState({ status: 'ready' });
  }, [initialized, isAuthenticated, router]);

  // æ˜‡æ ¼ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯æ™‚ã®å‡¦ç†
  const handlePromote = async () => {
    setPageState({ status: 'submitting' });

    try {
      const response = await promoteToSuperAdmin();

      if (response.success) {
        setPageState({ status: 'success' });
      } else {
        // APIãŒã‚¨ãƒ©ãƒ¼ã‚’è¿”ã—ãŸå ´åˆ
        const errorMessage = response.message ?? response.error ?? 'æ˜‡æ ¼å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸ';
        setPageState({ status: 'error', message: errorMessage });
      }
    } catch (error) {
      if (error instanceof ApiError) {
        if (error.status === 403) {
          setPageState({
            status: 'error',
            message: 'SUPER ADMIN ã¯ã™ã§ã«å­˜åœ¨ã™ã‚‹ãŸã‚ã€ã“ã®æ“ä½œã¯å®Ÿè¡Œã§ãã¾ã›ã‚“ã€‚',
          });
        } else {
          setPageState({
            status: 'error',
            message: error.message || 'æ˜‡æ ¼å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸ',
          });
        }
      } else {
        setPageState({
          status: 'error',
          message: 'æ˜‡æ ¼å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸ',
        });
      }
    }
  };

  // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ä¸­
  if (pageState.status === 'loading' || pageState.status === 'unauthenticated') {
    return (
      <Box
        style={{
          minHeight: '100vh',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          background: 'linear-gradient(135deg, #eef2ff 0%, #e1f1ff 100%)',
        }}
        role="status"
        aria-live="polite"
        aria-label="èª­ã¿è¾¼ã¿ä¸­"
      >
        <Loader size="lg" aria-label="èª­ã¿è¾¼ã¿ä¸­" />
      </Box>
    );
  }

  return (
    <Box
      component="main"
      role="main"
      aria-label="åˆå› SUPER ADMIN ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãƒšãƒ¼ã‚¸"
      style={{
        minHeight: '100vh',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        background: 'linear-gradient(135deg, #eef2ff 0%, #e1f1ff 100%)',
        padding: '1rem',
      }}
    >
      <Container size={520}>
        <Center>
          <Stack gap="lg" style={{ width: '100%' }}>
            <Box style={{ textAlign: 'center' }}>
              <Text
                size="xl"
                style={{ fontSize: '3.5rem', marginBottom: '0.75rem', lineHeight: 1 }}
                aria-hidden="true"
              >
                ğŸ›¡ï¸
              </Text>
              <Title
                order={2}
                style={{
                  color: 'var(--text-primary)',
                  fontSize: 20,
                  fontWeight: 700,
                  marginBottom: '0.5rem',
                  letterSpacing: 0.5,
                }}
              >
                åˆå› SUPER ADMIN ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
              </Title>
              <Text style={{ color: 'var(--text-secondary)' }}>
                ã‚·ã‚¹ãƒ†ãƒ ã®æœ€é«˜æ¨©é™ã‚’è¨­å®šã—ã¾ã™
              </Text>
            </Box>

            <Paper
              radius="lg"
              p="xl"
              shadow="xl"
              style={{ boxShadow: '0 16px 40px rgba(15, 23, 42, 0.08)' }}
            >
              <Stack gap="md">
                {/* æˆåŠŸçŠ¶æ…‹ */}
                {pageState.status === 'success' && (
                  <>
                    <Alert
                      icon={<IconCheck size="1rem" />}
                      title="æ˜‡æ ¼ãŒå®Œäº†ã—ã¾ã—ãŸ"
                      color="green"
                      role="alert"
                      aria-live="polite"
                    >
                      ã“ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã¯ SUPER ADMIN ã«æ˜‡æ ¼ã—ã¾ã—ãŸã€‚
                      ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®ç®¡ç†æ¨©é™ã‚’æŒã£ã¦ã„ã¾ã™ã€‚
                      <Text size="sm" fw={600} mt="xs">
                        æ¨©é™ã‚’åæ˜ ã™ã‚‹ãŸã‚ã€å†ãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ã§ã™ã€‚
                      </Text>
                    </Alert>
                    <Button
                      fullWidth
                      size="md"
                      leftSection={<IconLogout size="1rem" />}
                      onClick={async () => {
                        await logout();
                        router.push('/login');
                      }}
                      style={{
                        marginTop: '0.5rem',
                        background: 'var(--accent)',
                        boxShadow: '0 8px 20px rgba(37, 99, 235, 0.25)',
                      }}
                    >
                      ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã—ã¦å†ãƒ­ã‚°ã‚¤ãƒ³
                    </Button>
                  </>
                )}

                {/* ã‚¨ãƒ©ãƒ¼çŠ¶æ…‹ */}
                {pageState.status === 'error' && (
                  <>
                    <Alert
                      icon={<IconAlertTriangle size="1rem" />}
                      title="ã‚¨ãƒ©ãƒ¼"
                      color="red"
                      role="alert"
                      aria-live="polite"
                    >
                      {pageState.message}
                    </Alert>
                    <Button
                      fullWidth
                      size="md"
                      variant="outline"
                      onClick={() => setPageState({ status: 'ready' })}
                      style={{ marginTop: '0.5rem' }}
                    >
                      æˆ»ã‚‹
                    </Button>
                  </>
                )}

                {/* æº–å‚™å®Œäº† / é€ä¿¡ä¸­çŠ¶æ…‹ */}
                {(pageState.status === 'ready' || pageState.status === 'submitting') && (
                  <>
                    {/* ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ± */}
                    <Box
                      style={{
                        padding: '1rem',
                        backgroundColor: 'var(--surface)',
                        borderRadius: '8px',
                        border: '1px solid var(--border)',
                      }}
                    >
                      <Text size="sm" style={{ color: 'var(--text-secondary)', marginBottom: '0.25rem' }}>
                        ç¾åœ¨ãƒ­ã‚°ã‚¤ãƒ³ä¸­ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ
                      </Text>
                      <Text size="md" fw={600} style={{ color: 'var(--text-primary)' }}>
                        {user?.email ?? 'ä¸æ˜'}
                      </Text>
                    </Box>

                    {/* è­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ */}
                    <Alert
                      icon={<IconAlertTriangle size="1rem" />}
                      title="SUPER ADMIN ã®å½¹å‰²ã«ã¤ã„ã¦"
                      color="yellow"
                      role="alert"
                    >
                      <Stack gap="xs">
                        <Text size="sm">
                          â€¢ å…¨ãƒ†ãƒŠãƒ³ãƒˆãƒ»å…¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ç®¡ç†ã§ãã‚‹æœ€ä¸Šä½æ¨©é™ã§ã™
                        </Text>
                        <Text size="sm">
                          â€¢ ã“ã®æ“ä½œã¯åˆå›ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—å°‚ç”¨ã§ã€SUPER ADMIN ãŒæ—¢ã«å­˜åœ¨ã™ã‚‹å ´åˆã¯å¤±æ•—ã—ã¾ã™
                        </Text>
                      </Stack>
                    </Alert>

                    {/* æ˜‡æ ¼ãƒœã‚¿ãƒ³ */}
                    <Button
                      fullWidth
                      size="md"
                      loading={pageState.status === 'submitting'}
                      onClick={handlePromote}
                      disabled={pageState.status === 'submitting'}
                      leftSection={<IconShieldCheck size="1rem" />}
                      style={{
                        marginTop: '0.5rem',
                        background: 'var(--accent)',
                        boxShadow: '0 8px 20px rgba(37, 99, 235, 0.25)',
                      }}
                    >
                      ã“ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ SUPER ADMIN ã«æ˜‡æ ¼ã™ã‚‹
                    </Button>
                  </>
                )}
              </Stack>
            </Paper>

            <Text size="sm" style={{ textAlign: 'center', color: 'var(--text-secondary)' }}>
              Â© {new Date().getFullYear()} MyCats. All rights reserved.
            </Text>
          </Stack>
        </Center>
      </Container>
    </Box>
  );
}
````

## File: frontend/src/app/tags/components/AutomationIndicator.tsx
````typescript
'use client';

import { Group, Text, Tooltip } from '@mantine/core';
import { IconWand } from '@tabler/icons-react';

import type { TagView } from '@/lib/api/hooks/use-tags';
import { extractAutomationMeta } from '../utils';

type AutomationIndicatorProps = {
  tag: TagView;
};

/**
 * ã‚¿ã‚°ã®è‡ªå‹•åŒ–çŠ¶æ…‹ã‚’è¡¨ç¤ºã™ã‚‹ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼
 */
export function AutomationIndicator({ tag }: AutomationIndicatorProps) {
  const meta = extractAutomationMeta(tag);
  if (!meta && !tag.allowsAutomation) {
    return null;
  }

  const tooltipParts = [meta?.ruleName, meta?.reason, meta?.source, meta?.assignedAt].filter(Boolean);
  if (!meta && tag.allowsAutomation && !tag.allowsManual) {
    tooltipParts.push('è‡ªå‹•ä»˜ä¸å°‚ç”¨ã‚¿ã‚°');
  }
  if (!meta && tag.allowsAutomation && tooltipParts.length === 0) {
    tooltipParts.push('è‡ªå‹•ä»˜ä¸ãƒ«ãƒ¼ãƒ«ã§ä½¿ç”¨å¯èƒ½');
  }

  const content = (
    <Group gap={4} align="center" wrap="nowrap" style={{ fontSize: 11 }}>
      <IconWand size={12} />
      <Text span>{meta ? 'è‡ªå‹•' : 'è‡ªå‹•å¯'}</Text>
    </Group>
  );

  return (
    <Tooltip label={tooltipParts.join(' / ')} withArrow multiline withinPortal>
      {content}
    </Tooltip>
  );
}
````

## File: frontend/src/app/tags/components/AutomationTab.tsx
````typescript
'use client';

import {
  ActionIcon,
  Alert,
  Badge,
  Button,
  Card,
  Center,
  Group,
  Loader,
  Stack,
  Text,
  Tooltip,
} from '@mantine/core';
import {
  IconInfoCircle,
  IconPencil,
  IconPlus,
  IconRobot,
  IconTrash,
  IconWand,
} from '@tabler/icons-react';

import type { TagAutomationRule } from '@/lib/api/hooks/use-tag-automation';

export type AutomationTabProps = {
  isLoading: boolean;
  automationRules: TagAutomationRule[];
  isAnyMutationPending: boolean;
  createAutomationRulePending: boolean;
  updateAutomationRulePending: boolean;
  deleteAutomationRulePending: boolean;
  onOpenCreateRule: () => void;
  onEditRule: (rule: TagAutomationRule) => void;
  onDeleteRule: (id: string) => void;
  onOpenExecuteRule: (rule: TagAutomationRule) => void;
};

/**
 * è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ã‚¿ãƒ–ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * ã‚¿ã‚°è‡ªå‹•ä»˜ä¸ãƒ«ãƒ¼ãƒ«ã®ä¸€è¦§ã¨ç®¡ç†
 */
export function AutomationTab({
  isLoading,
  automationRules,
  isAnyMutationPending,
  createAutomationRulePending,
  updateAutomationRulePending,
  deleteAutomationRulePending,
  onOpenCreateRule,
  onEditRule,
  onDeleteRule,
  onOpenExecuteRule,
}: AutomationTabProps) {
  return (
    <Stack gap="md">
      <Card withBorder padding="md" radius="md">
        <Stack gap="md">
          <Group justify="space-between" align="center">
            <Text size="lg" fw={600}>
              è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«
            </Text>
            <Button 
              leftSection={<IconPlus size={16} />} 
              size="sm" 
              onClick={onOpenCreateRule}
              disabled={isAnyMutationPending || createAutomationRulePending}
            >
              ãƒ«ãƒ¼ãƒ«ä½œæˆ
            </Button>
          </Group>
          <Alert icon={<IconInfoCircle size={18} />} variant="light" color="blue">
            è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ã‚’è¨­å®šã™ã‚‹ã¨ã€ç‰¹å®šã®ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆäº¤é…ç™»éŒ²ã€å¦Šå¨ ç¢ºèªã€å­çŒ«ç™»éŒ²ãªã©ï¼‰ãŒç™ºç”Ÿã—ãŸã¨ãã«ã€æ¡ä»¶ã«åˆè‡´ã™ã‚‹çŒ«ã¸è‡ªå‹•çš„ã«ã‚¿ã‚°ã‚’ä»˜ä¸ã§ãã¾ã™ã€‚
          </Alert>
        </Stack>
      </Card>

      {isLoading ? (
        <Center py="xl">
          <Loader />
        </Center>
      ) : automationRules.length === 0 ? (
        <Center py="xl">
          <Stack gap="sm" align="center">
            <IconRobot size={48} stroke={1.5} color="var(--mantine-color-gray-5)" />
            <Text c="dimmed" size="sm">
              è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“
            </Text>
            <Text c="dimmed" size="xs">
              ã€Œãƒ«ãƒ¼ãƒ«ä½œæˆã€ãƒœã‚¿ãƒ³ã‹ã‚‰æ–°ã—ã„ãƒ«ãƒ¼ãƒ«ã‚’è¿½åŠ ã§ãã¾ã™
            </Text>
          </Stack>
        </Center>
      ) : (
        <Stack gap="sm">
          {automationRules.map((rule) => (
            <Card key={rule.id} withBorder radius="md" padding="md">
              <Group justify="space-between" align="flex-start">
                <Stack gap={4} style={{ flex: 1 }}>
                  <Group gap="xs" align="center">
                    <Text fw={500}>{rule.name}</Text>
                    {!rule.isActive && (
                      <Badge size="xs" color="gray" variant="outline">
                        ç„¡åŠ¹
                      </Badge>
                    )}
                    <Badge size="xs" variant="light" color="blue">
                      {rule.triggerType === 'EVENT' && 'ã‚¤ãƒ™ãƒ³ãƒˆ'}
                      {rule.triggerType === 'SCHEDULE' && 'ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«'}
                      {rule.triggerType === 'MANUAL' && 'æ‰‹å‹•'}
                    </Badge>
                    {rule.eventType && (
                      <Badge size="xs" variant="outline">
                        {rule.eventType === 'BREEDING_PLANNED' && 'äº¤é…äºˆå®š'}
                        {rule.eventType === 'BREEDING_CONFIRMED' && 'äº¤é…ç¢ºèª'}
                        {rule.eventType === 'PREGNANCY_CONFIRMED' && 'å¦Šå¨ ç¢ºèª'}
                        {rule.eventType === 'KITTEN_REGISTERED' && 'å­çŒ«ç™»éŒ²'}
                        {rule.eventType === 'AGE_THRESHOLD' && 'å¹´é½¢é–¾å€¤'}
                        {rule.eventType === 'PAGE_ACTION' && 'ãƒšãƒ¼ã‚¸ã‚¢ã‚¯ã‚·ãƒ§ãƒ³'}
                        {rule.eventType === 'CUSTOM' && 'ã‚«ã‚¹ã‚¿ãƒ '}
                      </Badge>
                    )}
                  </Group>
                  {rule.description && (
                    <Text size="sm" c="dimmed">
                      {rule.description}
                    </Text>
                  )}
                  <Group gap="xs">
                    <Badge size="xs" variant="outline">
                      å„ªå…ˆåº¦: {rule.priority}
                    </Badge>
                    {rule.scope && (
                      <Badge size="xs" variant="outline">
                        ã‚¹ã‚³ãƒ¼ãƒ—: {rule.scope}
                      </Badge>
                    )}
                    {rule.config && typeof rule.config === 'object' && (rule.config as { tagIds?: string[] }).tagIds && (
                      <Badge size="xs" variant="outline" color="teal">
                        ä»˜ä¸ã‚¿ã‚°: {((rule.config as { tagIds?: string[] }).tagIds ?? []).length}å€‹
                      </Badge>
                    )}
                    {rule._count && (
                      <>
                        {rule._count.runs !== undefined && (
                          <Badge size="xs" variant="outline">
                            å®Ÿè¡Œå›æ•°: {rule._count.runs}
                          </Badge>
                        )}
                        {rule._count.assignmentHistory !== undefined && (
                          <Badge size="xs" variant="outline">
                            ä»˜ä¸å±¥æ­´: {rule._count.assignmentHistory}
                          </Badge>
                        )}
                      </>
                    )}
                  </Group>
                </Stack>
                <Group gap={6}>
                  <Tooltip label="ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ">
                    <ActionIcon
                      variant="light"
                      color="green"
                      size="sm"
                      onClick={() => onOpenExecuteRule(rule)}
                      disabled={isAnyMutationPending}
                    >
                      <IconWand size={14} />
                    </ActionIcon>
                  </Tooltip>
                  <Tooltip label="ç·¨é›†">
                    <ActionIcon
                      variant="light"
                      color="blue"
                      size="sm"
                      onClick={() => onEditRule(rule)}
                      disabled={isAnyMutationPending || updateAutomationRulePending}
                    >
                      <IconPencil size={14} />
                    </ActionIcon>
                  </Tooltip>
                  <Tooltip label="å‰Šé™¤">
                    <ActionIcon
                      variant="light"
                      color="red"
                      size="sm"
                      disabled={deleteAutomationRulePending}
                      onClick={() => void onDeleteRule(rule.id)}
                    >
                      <IconTrash size={14} />
                    </ActionIcon>
                  </Tooltip>
                </Group>
              </Group>
            </Card>
          ))}
        </Stack>
      )}
    </Stack>
  );
}
````

## File: frontend/src/app/tags/components/CategoriesTab.tsx
````typescript
'use client';

import {
  closestCenter,
  DndContext,
  KeyboardSensor,
  PointerSensor,
  type DragEndEvent,
  useSensor,
  useSensors,
} from '@dnd-kit/core';
import {
  SortableContext,
  rectSortingStrategy,
  sortableKeyboardCoordinates,
} from '@dnd-kit/sortable';
import {
  Center,
  Loader,
  Stack,
  Text,
} from '@mantine/core';

import type {
  TagCategoryView,
  TagGroupView,
  TagView,
} from '@/lib/api/hooks/use-tags';
import { SortableCategoryCard } from './SortableCategoryCard';

export type CategoriesTabProps = {
  isLoading: boolean;
  sortedCategories: TagCategoryView[];
  isAnyMutationPending: boolean;
  reorderCategoriesPending: boolean;
  deleteCategoryPending: boolean;
  deleteGroupPending: boolean;
  deleteTagPending: boolean;
  reorderGroupsPending: boolean;
  reorderTagsPending: boolean;
  onCategoryDragEnd: (event: DragEndEvent) => void;
  onEditCategory: (category: TagCategoryView) => void;
  onDeleteCategory: (id: string) => void;
  onOpenCreateGroup: (categoryId: string) => void;
  onOpenCreateTag: (categoryId: string, groupId?: string) => void;
  onEditGroup: (category: TagCategoryView, group: TagGroupView) => void;
  onDeleteGroup: (groupId: string) => void;
  onEditTag: (category: TagCategoryView, group: TagGroupView, tag: TagView) => void;
  onDeleteTag: (id: string) => void;
  onTagContextAction?: (action: string, tag?: TagView) => void;
  onReorderGroups: (categoryId: string, groups: TagGroupView[]) => void;
  onReorderTags: (groupId: string, tags: TagView[]) => void;
};

/**
 * ã‚«ãƒ†ã‚´ãƒªã‚¿ãƒ–ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * ã‚«ãƒ†ã‚´ãƒªä¸€è¦§ã‚’DnDã§ä¸¦ã¹æ›¿ãˆå¯èƒ½ãªå½¢å¼ã§è¡¨ç¤º
 */
export function CategoriesTab({
  isLoading,
  sortedCategories,
  isAnyMutationPending,
  reorderCategoriesPending,
  deleteCategoryPending,
  deleteGroupPending,
  deleteTagPending,
  reorderGroupsPending,
  reorderTagsPending,
  onCategoryDragEnd,
  onEditCategory,
  onDeleteCategory,
  onOpenCreateGroup,
  onOpenCreateTag,
  onEditGroup,
  onDeleteGroup,
  onEditTag,
  onDeleteTag,
  onTagContextAction,
  onReorderGroups,
  onReorderTags,
}: CategoriesTabProps) {
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: { distance: 8 },
    }),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    }),
  );

  if (isLoading) {
    return (
      <Center py="xl">
        <Loader />
      </Center>
    );
  }

  if (sortedCategories.length === 0) {
    return (
      <Center py="xl">
        <Text c="dimmed">ã‚«ãƒ†ã‚´ãƒªãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚æ–°è¦ä½œæˆã—ã¦ãã ã•ã„ã€‚</Text>
      </Center>
    );
  }

  return (
    <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={onCategoryDragEnd}>
      <SortableContext items={sortedCategories.map((category) => category.id)} strategy={rectSortingStrategy}>
        <Stack gap="lg">
          {sortedCategories.map((category) => (
            <SortableCategoryCard
              key={category.id}
              category={category}
              isAnyMutationPending={isAnyMutationPending}
              reorderCategoriesPending={reorderCategoriesPending}
              deleteCategoryPending={deleteCategoryPending}
              deleteGroupPending={deleteGroupPending}
              deleteTagPending={deleteTagPending}
              reorderGroupsPending={reorderGroupsPending}
              reorderTagsPending={reorderTagsPending}
              onEditCategory={onEditCategory}
              onDeleteCategory={onDeleteCategory}
              onOpenCreateGroup={onOpenCreateGroup}
              onOpenCreateTag={onOpenCreateTag}
              onEditGroup={onEditGroup}
              onDeleteGroup={onDeleteGroup}
              onEditTag={onEditTag}
              onDeleteTag={onDeleteTag}
              onTagContextAction={onTagContextAction}
              onReorderGroups={onReorderGroups}
              onReorderTags={onReorderTags}
            />
          ))}
        </Stack>
      </SortableContext>
    </DndContext>
  );
}
````

## File: frontend/src/app/tags/components/index.ts
````typescript
/**
 * ã‚¿ã‚°ç®¡ç†ãƒšãƒ¼ã‚¸ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆç¾¤
 */

// ã‚¿ãƒ–ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
export { CategoriesTab } from './CategoriesTab';
export type { CategoriesTabProps } from './CategoriesTab';

export { TagsListTab } from './TagsListTab';
export type { TagsListTabProps, FlatTag } from './TagsListTab';

export { AutomationTab } from './AutomationTab';
export type { AutomationTabProps } from './AutomationTab';

// DnDã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
export { SortableCategoryCard } from './SortableCategoryCard';
export type { SortableCategoryCardProps } from './SortableCategoryCard';

export { SortableGroupCard } from './SortableGroupCard';
export type { SortableGroupCardProps } from './SortableGroupCard';

export { SortableTagItem } from './SortableTagItem';
export type { SortableTagItemProps } from './SortableTagItem';

export { AutomationIndicator } from './AutomationIndicator';

// ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
export { CategoryModal } from './CategoryModal';
export type { CategoryModalProps } from './CategoryModal';

export { GroupModal } from './GroupModal';
export type { GroupModalProps } from './GroupModal';

export { TagModal } from './TagModal';
export type { TagModalProps } from './TagModal';

export { AutomationRuleModal } from './AutomationRuleModal';
export type { AutomationRuleModalProps } from './AutomationRuleModal';

export { ExecuteRuleModal } from './ExecuteRuleModal';
export type { ExecuteRuleModalProps } from './ExecuteRuleModal';
````

## File: frontend/src/app/tags/components/SortableCategoryCard.tsx
````typescript
'use client';

import { useEffect, useMemo, useState, type CSSProperties } from 'react';
import {
  closestCenter,
  DndContext,
  KeyboardSensor,
  PointerSensor,
  type DragEndEvent,
  useSensor,
  useSensors,
} from '@dnd-kit/core';
import {
  arrayMove,
  SortableContext,
  rectSortingStrategy,
  sortableKeyboardCoordinates,
  useSortable,
} from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import {
  ActionIcon,
  Badge,
  Button,
  Card,
  Collapse,
  Group,
  Stack,
  Text,
  Tooltip,
} from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import {
  IconChevronDown,
  IconHandGrab,
  IconPencil,
  IconPlus,
  IconTrash,
} from '@tabler/icons-react';

import type {
  TagCategoryView,
  TagGroupView,
  TagView,
} from '@/lib/api/hooks/use-tags';
import {
  DEFAULT_CATEGORY_COLOR,
  DEFAULT_CATEGORY_TEXT_COLOR,
} from '../constants';
import { sortGroups, sortTags } from '../utils';
import { SortableGroupCard } from './SortableGroupCard';
import { SortableTagItem } from './SortableTagItem';

export type SortableCategoryCardProps = {
  category: TagCategoryView;
  isAnyMutationPending: boolean;
  reorderCategoriesPending: boolean;
  deleteCategoryPending: boolean;
  deleteGroupPending: boolean;
  deleteTagPending: boolean;
  reorderGroupsPending: boolean;
  reorderTagsPending: boolean;
  onEditCategory: (category: TagCategoryView) => void;
  onDeleteCategory: (id: string) => void;
  onOpenCreateGroup: (categoryId: string) => void;
  onOpenCreateTag: (categoryId: string, groupId?: string) => void;
  onEditGroup: (category: TagCategoryView, group: TagGroupView) => void;
  onDeleteGroup: (groupId: string) => void;
  onEditTag: (category: TagCategoryView, group: TagGroupView, tag: TagView) => void;
  onDeleteTag: (id: string) => void;
  onTagContextAction?: (action: string, tag?: TagView) => void;
  onReorderGroups: (categoryId: string, groups: TagGroupView[]) => void;
  onReorderTags: (groupId: string, tags: TagView[]) => void;
};

/**
 * ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½ãªã‚«ãƒ†ã‚´ãƒªã‚«ãƒ¼ãƒ‰ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * å†…éƒ¨ã«ã‚°ãƒ«ãƒ¼ãƒ—ã¨ã‚¿ã‚°ã®DnDã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’æŒã¤
 */
export function SortableCategoryCard({
  category,
  isAnyMutationPending,
  reorderCategoriesPending,
  deleteCategoryPending,
  deleteGroupPending,
  deleteTagPending,
  reorderGroupsPending,
  reorderTagsPending,
  onEditCategory,
  onDeleteCategory,
  onOpenCreateGroup,
  onOpenCreateTag,
  onEditGroup,
  onDeleteGroup,
  onEditTag,
  onDeleteTag,
  onTagContextAction,
  onReorderGroups,
  onReorderTags,
}: SortableCategoryCardProps) {
  const sortedGroups = useMemo(() => sortGroups(category.groups), [category.groups]);
  const [groupsOpened, { toggle: toggleGroups }] = useDisclosure(false);
  const [tagsOpened, { toggle: toggleTags }] = useDisclosure(false);
  const [groupOrder, setGroupOrder] = useState(sortedGroups);
  const [tagOrders, setTagOrders] = useState<Record<string, TagView[]>>(() =>
    Object.fromEntries(sortedGroups.map((group) => [group.id, sortTags(group.tags)])),
  );

  useEffect(() => {
    setGroupOrder(sortedGroups);
    setTagOrders(Object.fromEntries(sortedGroups.map((group) => [group.id, sortTags(group.tags)])));
  }, [sortedGroups]);

  const totalTags = useMemo(
    () =>
      groupOrder.reduce((sum, group) => {
        const tags = tagOrders[group.id] ?? sortTags(group.tags);
        return sum + tags.length;
      }, 0),
    [groupOrder, tagOrders],
  );

  const {
    attributes,
    listeners,
    setActivatorNodeRef,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({
    id: category.id,
    data: { type: 'category' },
    disabled: reorderCategoriesPending,
  });

  const colorHex = category.color ?? DEFAULT_CATEGORY_COLOR;

  const style: CSSProperties = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.9 : 1,
    borderColor: colorHex,
    borderWidth: 2,
    backgroundColor: `${colorHex}14`,
  };

  const nestedSensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: { distance: 6 },
    }),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    }),
  );

  const handleGroupDragEnd = ({ active, over }: DragEndEvent) => {
    if (!over || active.id === over.id || reorderGroupsPending) {
      return;
    }

    const oldIndex = groupOrder.findIndex((group) => group.id === active.id);
    const newIndex = groupOrder.findIndex((group) => group.id === over.id);
    if (oldIndex === -1 || newIndex === -1) {
      return;
    }

    const reordered = arrayMove(groupOrder, oldIndex, newIndex);
    setGroupOrder(reordered);
    void onReorderGroups(category.id, reordered);
  };

  return (
    <Card
      ref={setNodeRef}
      style={style}
      withBorder
      padding="lg"
      radius="md"
      shadow="sm"
    >
      <Stack gap="sm">
        <Group justify="space-between" align="center" gap="sm" wrap="wrap">
          <Group gap="sm" align="center" wrap="wrap">
            <Tooltip label="ãƒ‰ãƒ©ãƒƒã‚°ã§ä¸¦ã¹æ›¿ãˆ" withArrow withinPortal>
              <ActionIcon
                variant="light"
                aria-label="ã‚«ãƒ†ã‚´ãƒªã‚’ä¸¦ã¹æ›¿ãˆ"
                ref={setActivatorNodeRef}
                disabled={reorderCategoriesPending}
                {...listeners}
                {...attributes}
              >
                <IconHandGrab size={16} />
              </ActionIcon>
            </Tooltip>
            <Text fw={600} size="lg" style={{ color: category.textColor ?? DEFAULT_CATEGORY_TEXT_COLOR }}>
              {category.name}
            </Text>
            {!category.isActive && (
              <Badge color="gray" variant="outline" size="sm">
                éã‚¢ã‚¯ãƒ†ã‚£ãƒ–
              </Badge>
            )}
            <Group gap={6} wrap="wrap">
              {category.scopes.length > 0 ? (
                category.scopes.map((scope) => (
                  <Badge key={scope} variant="dot">
                    {scope}
                  </Badge>
                ))
              ) : (
                <Badge variant="dot" color="gray">
                  ã‚¹ã‚³ãƒ¼ãƒ—æœªè¨­å®š
                </Badge>
              )}
            </Group>
          </Group>
          <Group gap={6} align="center">
            <ActionIcon
              variant="light"
              aria-label="ã‚«ãƒ†ã‚´ãƒªã‚’ç·¨é›†"
              onClick={() => onEditCategory(category)}
              disabled={isAnyMutationPending}
            >
              <IconPencil size={16} />
            </ActionIcon>
            <ActionIcon
              variant="light"
              color="red"
              aria-label="ã‚«ãƒ†ã‚´ãƒªã‚’å‰Šé™¤"
              onClick={() => void onDeleteCategory(category.id)}
              disabled={deleteCategoryPending}
            >
              <IconTrash size={16} />
            </ActionIcon>
          </Group>
        </Group>

        <Group justify="space-between" align="center" gap="sm" wrap="wrap">
          <Group gap="md" align="center" wrap="wrap" style={{ flex: 1 }}>
            <Text size="sm" c="dimmed" style={{ flex: 1 }}>
              {category.description || 'èª¬æ˜ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“'}
            </Text>
          </Group>
          <Group gap="md" align="center" wrap="wrap">
            <Group gap={4} align="center">
              <Button
                variant="subtle"
                size="xs"
                rightSection={
                  <IconChevronDown
                    size={12}
                    style={{ transform: groupsOpened ? 'rotate(180deg)' : undefined, transition: 'transform 120ms ease' }}
                  />
                }
                onClick={toggleGroups}
              >
                ã‚°ãƒ«ãƒ¼ãƒ— {groupOrder.length}
              </Button>
              <Tooltip label="ã‚°ãƒ«ãƒ¼ãƒ—ã‚’è¿½åŠ " withArrow withinPortal>
                <ActionIcon
                  variant="light"
                  size="sm"
                  onClick={() => onOpenCreateGroup(category.id)}
                  disabled={isAnyMutationPending}
                  aria-label="ã‚°ãƒ«ãƒ¼ãƒ—ã‚’è¿½åŠ "
                >
                  <IconPlus size={14} />
                </ActionIcon>
              </Tooltip>
            </Group>
            <Group gap={4} align="center">
              <Button
                variant="subtle"
                size="xs"
                rightSection={
                  <IconChevronDown
                    size={12}
                    style={{ transform: tagsOpened ? 'rotate(180deg)' : undefined, transition: 'transform 120ms ease' }}
                  />
                }
                onClick={toggleTags}
              >
                ã‚¿ã‚° {totalTags}
              </Button>
              <Tooltip label="ã‚¿ã‚°ã‚’è¿½åŠ " withArrow withinPortal>
                <ActionIcon
                  variant="light"
                  size="sm"
                  onClick={() => onOpenCreateTag(category.id)}
                  disabled={isAnyMutationPending}
                  aria-label="ã‚¿ã‚°ã‚’è¿½åŠ "
                >
                  <IconPlus size={14} />
                </ActionIcon>
              </Tooltip>
            </Group>
          </Group>
        </Group>

        <Collapse in={groupsOpened}>
          <Stack gap="sm" mt="sm">
            {groupOrder.length === 0 ? (
              <Text size="sm" c="dimmed">
                ã“ã®ã‚«ãƒ†ã‚´ãƒªã«ã¯ã¾ã ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ãŒã‚ã‚Šã¾ã›ã‚“ã€‚
              </Text>
            ) : (
              <DndContext
                sensors={nestedSensors}
                collisionDetection={closestCenter}
                onDragEnd={handleGroupDragEnd}
              >
                <SortableContext items={groupOrder.map((group) => group.id)} strategy={rectSortingStrategy}>
                  <Stack gap="sm">
                    {groupOrder.map((group, groupIndex) => {
                      const tags = tagOrders[group.id] ?? sortTags(group.tags);
                      return (
                        <SortableGroupCard
                          key={group.id}
                          category={category}
                          group={group}
                          index={groupIndex}
                          tags={tags}
                          reorderGroupsPending={reorderGroupsPending}
                          deleteGroupPending={deleteGroupPending}
                          isAnyMutationPending={isAnyMutationPending}
                          onOpenCreateTag={onOpenCreateTag}
                          onEditGroup={onEditGroup}
                          onDeleteGroup={onDeleteGroup}
                        />
                      );
                    })}
                  </Stack>
                </SortableContext>
              </DndContext>
            )}
          </Stack>
        </Collapse>

        <Collapse in={tagsOpened}>
          <Stack gap="md" mt="sm">
            {totalTags === 0 ? (
              <Text size="sm" c="dimmed">
                ã“ã®ã‚«ãƒ†ã‚´ãƒªã«ã¯ã¾ã ã‚¿ã‚°ãŒã‚ã‚Šã¾ã›ã‚“ã€‚
              </Text>
            ) : (
              groupOrder.map((group) => {
                const tags = tagOrders[group.id] ?? sortTags(group.tags);
                return (
                  <Stack key={group.id} gap="xs">
                    <Group justify="space-between" align="center" wrap="wrap">
                      <Group gap="xs" align="center" wrap="wrap">
                        <Badge variant="light" color="gray">
                          {group.name}
                        </Badge>
                        <Badge size="xs" variant="outline">
                          ã‚¿ã‚° {tags.length}
                        </Badge>
                      </Group>
                      <Tooltip label="ã“ã®ã‚°ãƒ«ãƒ¼ãƒ—ã«ã‚¿ã‚°ã‚’è¿½åŠ " withArrow withinPortal>
                        <ActionIcon
                          variant="light"
                          size="sm"
                          onClick={() => onOpenCreateTag(category.id, group.id)}
                          disabled={isAnyMutationPending}
                          aria-label="ã‚¿ã‚°ã‚’è¿½åŠ "
                        >
                          <IconPlus size={14} />
                        </ActionIcon>
                      </Tooltip>
                    </Group>
                    {tags.length === 0 ? (
                      <Text size="xs" c="dimmed" pl="md">
                        ã“ã®ã‚°ãƒ«ãƒ¼ãƒ—ã«ã¯ã¾ã ã‚¿ã‚°ãŒã‚ã‚Šã¾ã›ã‚“ã€‚
                      </Text>
                    ) : (
                      <DndContext
                        sensors={nestedSensors}
                        collisionDetection={closestCenter}
                        onDragEnd={({ active, over }) => {
                          if (!over || active.id === over.id || reorderTagsPending) {
                            return;
                          }
                          const currentTags = tagOrders[group.id] ?? tags;
                          const oldIndex = currentTags.findIndex((item) => item.id === active.id);
                          const newIndex = currentTags.findIndex((item) => item.id === over.id);
                          if (oldIndex === -1 || newIndex === -1) {
                            return;
                          }
                          const reordered = arrayMove(currentTags, oldIndex, newIndex);
                          setTagOrders((prev) => ({ ...prev, [group.id]: reordered }));
                          void onReorderTags(group.id, reordered);
                        }}
                      >
                        <SortableContext
                          items={(tagOrders[group.id] ?? tags).map((tag) => tag.id)}
                          strategy={rectSortingStrategy}
                        >
                          <Stack gap="xs">
                            {(tagOrders[group.id] ?? tags).map((tag, tagIndex) => (
                              <SortableTagItem
                                key={tag.id}
                                category={category}
                                group={group}
                                tag={tag}
                                index={tagIndex}
                                reorderTagsPending={reorderTagsPending}
                                deleteTagPending={deleteTagPending}
                                isAnyMutationPending={isAnyMutationPending}
                                onEditTag={onEditTag}
                                onDeleteTag={onDeleteTag}
                                onContextAction={onTagContextAction}
                              />
                            ))}
                          </Stack>
                        </SortableContext>
                      </DndContext>
                    )}
                  </Stack>
                );
              })
            )}
          </Stack>
        </Collapse>
      </Stack>
    </Card>
  );
}
````

## File: frontend/src/app/tags/components/SortableGroupCard.tsx
````typescript
'use client';

import type { CSSProperties } from 'react';
import { useSortable } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import {
  ActionIcon,
  Badge,
  Card,
  Group,
  Stack,
  Text,
  Tooltip,
} from '@mantine/core';
import { IconHandGrab, IconPencil, IconPlus, IconTrash } from '@tabler/icons-react';

import type {
  TagCategoryView,
  TagGroupView,
  TagView,
} from '@/lib/api/hooks/use-tags';
import {
  DEFAULT_GROUP_COLOR,
  DEFAULT_GROUP_TEXT_COLOR,
} from '../constants';

export type SortableGroupCardProps = {
  category: TagCategoryView;
  group: TagGroupView;
  index: number;
  tags: TagView[];
  reorderGroupsPending: boolean;
  deleteGroupPending: boolean;
  isAnyMutationPending: boolean;
  onOpenCreateTag: (categoryId: string, groupId: string) => void;
  onEditGroup: (category: TagCategoryView, group: TagGroupView) => void;
  onDeleteGroup: (groupId: string) => void;
};

/**
 * ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½ãªã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ã‚«ãƒ¼ãƒ‰ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 */
export function SortableGroupCard({
  category,
  group,
  index,
  tags,
  reorderGroupsPending,
  deleteGroupPending,
  isAnyMutationPending,
  onOpenCreateTag,
  onEditGroup,
  onDeleteGroup,
}: SortableGroupCardProps) {
  const {
    attributes,
    listeners,
    setActivatorNodeRef,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({
    id: group.id,
    data: { type: 'group', categoryId: category.id },
    disabled: reorderGroupsPending,
  });

  const groupColor = group.color ?? DEFAULT_GROUP_COLOR;
  const groupTextColor = group.textColor ?? DEFAULT_GROUP_TEXT_COLOR;

  const style: CSSProperties = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.9 : 1,
    borderColor: groupColor,
    borderWidth: 2,
    backgroundColor: `${groupColor}14`,
  };

  return (
    <Card ref={setNodeRef} style={style} withBorder radius="sm" padding="md" shadow="xs">
      <Group justify="space-between" align="flex-start" gap="sm" wrap="wrap">
        <Stack gap={4} style={{ flex: 1 }}>
          <Group gap="xs" align="center" wrap="wrap">
            <Tooltip label="ãƒ‰ãƒ©ãƒƒã‚°ã§ä¸¦ã¹æ›¿ãˆ" withArrow withinPortal>
              <ActionIcon
                variant="light"
                aria-label="ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä¸¦ã¹æ›¿ãˆ"
                ref={setActivatorNodeRef}
                disabled={reorderGroupsPending}
                {...listeners}
                {...attributes}
              >
                <IconHandGrab size={14} />
              </ActionIcon>
            </Tooltip>
            <Badge color="gray" variant="light" size="sm">
              {index + 1}
            </Badge>
            <Text fw={600} style={{ color: groupTextColor }}>
              {group.name}
            </Text>
            {!group.isActive && (
              <Badge size="xs" color="gray" variant="outline">
                éã‚¢ã‚¯ãƒ†ã‚£ãƒ–
              </Badge>
            )}
            <Badge size="xs" variant="outline">
              ã‚¿ã‚° {tags.length}
            </Badge>
          </Group>
          {group.description && (
            <Text size="xs" c="dimmed">
              {group.description}
            </Text>
          )}
        </Stack>
        <Group gap={6} align="center" wrap="wrap">
          <Tooltip label="ã“ã®ã‚°ãƒ«ãƒ¼ãƒ—ã«ã‚¿ã‚°ã‚’è¿½åŠ " withArrow withinPortal>
            <ActionIcon
              variant="light"
              size="sm"
              onClick={() => onOpenCreateTag(category.id, group.id)}
              disabled={isAnyMutationPending}
              aria-label="ã‚¿ã‚°ã‚’è¿½åŠ "
            >
              <IconPlus size={14} />
            </ActionIcon>
          </Tooltip>
          <ActionIcon
            variant="light"
            aria-label="ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ç·¨é›†"
            onClick={() => onEditGroup(category, group)}
            disabled={isAnyMutationPending}
          >
            <IconPencil size={14} />
          </ActionIcon>
          <ActionIcon
            variant="light"
            color="red"
            aria-label="ã‚°ãƒ«ãƒ¼ãƒ—ã‚’å‰Šé™¤"
            onClick={() => void onDeleteGroup(group.id)}
            disabled={deleteGroupPending}
          >
            <IconTrash size={14} />
          </ActionIcon>
        </Group>
      </Group>
    </Card>
  );
}
````

## File: frontend/src/app/tags/components/SortableTagItem.tsx
````typescript
'use client';

import type { CSSProperties } from 'react';
import { useSortable } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import {
  ActionIcon,
  Badge,
  Card,
  Group,
  Stack,
  Text,
  Tooltip,
} from '@mantine/core';
import { IconHandGrab, IconPencil, IconTrash } from '@tabler/icons-react';

import { ContextMenuProvider } from '@/components/context-menu/context-menu';
import type {
  TagCategoryView,
  TagGroupView,
  TagView,
} from '@/lib/api/hooks/use-tags';
import {
  DEFAULT_CATEGORY_COLOR,
  DEFAULT_TAG_COLOR,
  DEFAULT_TAG_TEXT_COLOR,
} from '../constants';
import { AutomationIndicator } from './AutomationIndicator';

export type SortableTagItemProps = {
  category: TagCategoryView;
  group: TagGroupView;
  tag: TagView;
  index: number;
  reorderTagsPending: boolean;
  deleteTagPending: boolean;
  isAnyMutationPending: boolean;
  onEditTag: (category: TagCategoryView, group: TagGroupView, tag: TagView) => void;
  onDeleteTag: (id: string) => void;
  onContextAction?: (action: string, tag?: TagView) => void;
};

/**
 * ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½ãªã‚¿ã‚°ã‚¢ã‚¤ãƒ†ãƒ ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 */
export function SortableTagItem({
  category,
  group,
  tag,
  index,
  reorderTagsPending,
  deleteTagPending,
  isAnyMutationPending,
  onEditTag,
  onDeleteTag,
  onContextAction,
}: SortableTagItemProps) {
  const {
    attributes,
    listeners,
    setActivatorNodeRef,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({
    id: tag.id,
    data: { type: 'tag', groupId: group.id },
    disabled: reorderTagsPending,
  });

  const tagColor = tag.color ?? DEFAULT_TAG_COLOR;
  const tagTextColor = tag.textColor ?? DEFAULT_TAG_TEXT_COLOR;

  const style: CSSProperties = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.95 : 1,
    borderColor: tagColor,
    borderWidth: 2,
    backgroundColor: `${tagColor}14`,
  };

  return (
    <ContextMenuProvider
      entity={tag}
      entityType="ã‚¿ã‚°"
      actions={['edit', 'delete']}
      onAction={onContextAction}
    >
      <Card 
        ref={setNodeRef} 
        style={{ 
          ...style, 
          cursor: 'pointer',
        }} 
        withBorder 
        radius="sm" 
        padding="sm"
        title="å³ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§æ“ä½œ"
      >
        <Group justify="space-between" align="center" gap="sm" wrap="wrap">
          <Stack gap={4} style={{ flex: 1 }}>
            <Group gap="xs" align="center" wrap="wrap">
              <Tooltip label="ãƒ‰ãƒ©ãƒƒã‚°ã§ä¸¦ã¹æ›¿ãˆ" withArrow withinPortal>
                <ActionIcon
                  variant="light"
                  aria-label="ã‚¿ã‚°ã‚’ä¸¦ã¹æ›¿ãˆ"
                  ref={setActivatorNodeRef}
                  disabled={reorderTagsPending}
                  {...attributes}
                  {...listeners}
                >
                  <IconHandGrab size={14} />
                </ActionIcon>
              </Tooltip>
              <Badge color="gray" variant="light" size="sm">
                {index + 1}
              </Badge>
              <Text fw={600} size="sm" style={{ color: tagTextColor }}>
                {tag.name}
              </Text>
              {!tag.isActive && (
                <Badge size="xs" color="gray" variant="outline">
                  éã‚¢ã‚¯ãƒ†ã‚£ãƒ–
                </Badge>
              )}
              <Badge size="xs" variant="outline">
                ä½¿ç”¨ {tag.usageCount.toLocaleString()}å›
              </Badge>
              <AutomationIndicator tag={tag} />
            </Group>
            {tag.description && (
              <Text size="xs" c="dimmed">
                {tag.description}
              </Text>
            )}
            <Group gap="xs" wrap="wrap">
              <Badge size="xs" variant="outline">
                æ‰‹å‹• {tag.allowsManual ? 'å¯' : 'ä¸å¯'}
              </Badge>
              <Badge size="xs" variant="outline">
                è‡ªå‹• {tag.allowsAutomation ? 'å¯' : 'ä¸å¯'}
              </Badge>
              <Badge size="xs" variant="outline">
                {group.name}
              </Badge>
              <Badge
                size="xs"
                variant="light"
                style={{
                  backgroundColor: `${(category.color ?? DEFAULT_CATEGORY_COLOR)}1A`,
                  color: category.color ?? DEFAULT_CATEGORY_COLOR,
                }}
              >
                {category.name}
              </Badge>
            </Group>
          </Stack>
          <Group gap={4} align="center" wrap="wrap">
            <ActionIcon
              variant="light"
              aria-label="ã‚¿ã‚°ã‚’ç·¨é›†"
              onClick={() => onEditTag(category, group, tag)}
              disabled={isAnyMutationPending}
            >
              <IconPencil size={14} />
            </ActionIcon>
            <ActionIcon
              variant="light"
              color="red"
              aria-label="ã‚¿ã‚°ã‚’å‰Šé™¤"
              onClick={() => onDeleteTag(tag.id)}
              disabled={deleteTagPending || isAnyMutationPending}
            >
              <IconTrash size={14} />
            </ActionIcon>
          </Group>
        </Group>
      </Card>
    </ContextMenuProvider>
  );
}
````

## File: frontend/src/app/tags/components/TagsListTab.tsx
````typescript
'use client';

import {
  Badge,
  Button,
  Card,
  Center,
  Group,
  Loader,
  Stack,
  Text,
} from '@mantine/core';

import type {
  TagCategoryView,
  TagGroupView,
  TagView,
} from '@/lib/api/hooks/use-tags';
import { DEFAULT_CATEGORY_COLOR } from '../constants';
import { AutomationIndicator } from './AutomationIndicator';

export type FlatTag = {
  category: TagCategoryView;
  group: TagGroupView;
  tag: TagView;
};

export type TagsListTabProps = {
  isLoading: boolean;
  flatTags: FlatTag[];
  isAnyMutationPending: boolean;
  deleteTagPending: boolean;
  onEditTag: (category: TagCategoryView, group: TagGroupView, tag: TagView) => void;
  onDeleteTag: (id: string) => void;
};

/**
 * ã‚¿ã‚°ä¸€è¦§ã‚¿ãƒ–ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * ãƒ•ãƒ©ãƒƒãƒˆãªãƒªã‚¹ãƒˆå½¢å¼ã§ã‚¿ã‚°ã‚’è¡¨ç¤º
 */
export function TagsListTab({
  isLoading,
  flatTags,
  isAnyMutationPending,
  deleteTagPending,
  onEditTag,
  onDeleteTag,
}: TagsListTabProps) {
  if (isLoading) {
    return (
      <Center py="xl">
        <Loader />
      </Center>
    );
  }

  if (flatTags.length === 0) {
    return (
      <Center py="xl">
        <Text c="dimmed">è¡¨ç¤ºã§ãã‚‹ã‚¿ã‚°ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</Text>
      </Center>
    );
  }

  return (
    <Stack gap="sm">
      {flatTags.map(({ category, group, tag }) => (
        <Card key={tag.id} withBorder radius="md" padding="md">
          <Group justify="space-between" align="flex-start">
            <Stack gap={4}>
              <Group gap="xs" align="center">
                <Badge
                  variant="light"
                  style={{
                    backgroundColor: `${(category.color ?? DEFAULT_CATEGORY_COLOR)}1A`,
                    color: category.color ?? DEFAULT_CATEGORY_COLOR,
                  }}
                >
                  {category.name}
                </Badge>
                <Badge variant="light" color="gray">
                  {group.name}
                </Badge>
                <Text fw={500}>{tag.name}</Text>
                {!tag.isActive && (
                  <Badge size="xs" color="gray" variant="outline">
                    éã‚¢ã‚¯ãƒ†ã‚£ãƒ–
                  </Badge>
                )}
                <AutomationIndicator tag={tag} />
              </Group>
              <Group gap="xs">
                <Badge size="xs" variant="outline">
                  ä½¿ç”¨ {tag.usageCount.toLocaleString()}å›
                </Badge>
                <Badge size="xs" variant="outline">
                  æ‰‹å‹• {tag.allowsManual ? 'å¯' : 'ä¸å¯'}
                </Badge>
                <Badge size="xs" variant="outline">
                  è‡ªå‹• {tag.allowsAutomation ? 'å¯' : 'ä¸å¯'}
                </Badge>
              </Group>
              {tag.description && (
                <Text size="sm" c="dimmed">
                  {tag.description}
                </Text>
              )}
            </Stack>
            <Group gap={6}>
              <Button
                size="xs"
                variant="light"
                onClick={() => onEditTag(category, group, tag)}
                disabled={isAnyMutationPending}
              >
                ç·¨é›†
              </Button>
              <Button 
                size="xs" 
                color="red" 
                variant="light" 
                onClick={() => void onDeleteTag(tag.id)} 
                disabled={deleteTagPending}
              >
                å‰Šé™¤
              </Button>
            </Group>
          </Group>
        </Card>
      ))}
    </Stack>
  );
}
````

## File: frontend/src/app/tags/hooks/index.ts
````typescript
/**
 * ã‚¿ã‚°ç®¡ç†ãƒšãƒ¼ã‚¸ã®ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯ç¾¤
 */

export { useTagPageData } from './useTagPageData';
export { useAutomationRulesData } from './useAutomationRulesData';
````

## File: frontend/src/app/tags/hooks/useAutomationRulesData.ts
````typescript
'use client';

import { useMemo } from 'react';

import {
  useGetAutomationRules,
  useCreateAutomationRule,
  useUpdateAutomationRule,
  useDeleteAutomationRule,
  useExecuteAutomationRule,
} from '@/lib/api/hooks/use-tag-automation';

/**
 * è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ã®ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ»ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ãƒ•ãƒƒã‚¯
 */
export function useAutomationRulesData() {
  // ãƒ‡ãƒ¼ã‚¿å–å¾—
  const { data: automationRulesData, isLoading: isLoadingAutomationRules } = useGetAutomationRules();

  // ãƒ«ãƒ¼ãƒ«ãƒªã‚¹ãƒˆã‚’æ•´å½¢
  const automationRules = useMemo(() => automationRulesData?.data ?? [], [automationRulesData]);

  // ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³
  const createAutomationRule = useCreateAutomationRule();
  const updateAutomationRule = useUpdateAutomationRule();
  const deleteAutomationRule = useDeleteAutomationRule();
  const executeAutomationRule = useExecuteAutomationRule();

  return {
    // ãƒ‡ãƒ¼ã‚¿
    isLoadingAutomationRules,
    automationRules,
    // ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³
    createAutomationRule,
    updateAutomationRule,
    deleteAutomationRule,
    executeAutomationRule,
  };
}
````

## File: frontend/src/app/tags/hooks/useTagPageData.ts
````typescript
'use client';

import { useMemo, useState } from 'react';

import {
  useGetTagCategories,
  useCreateTagCategory,
  useUpdateTagCategory,
  useDeleteTagCategory,
  useReorderTagCategories,
  useCreateTagGroup,
  useUpdateTagGroup,
  useDeleteTagGroup,
  useReorderTagGroups,
  useCreateTag,
  useUpdateTag,
  useDeleteTag,
  useReorderTags,
  type TagCategoryFilters,
} from '@/lib/api/hooks/use-tags';
import {
  useGetTagColorDefaults,
  useUpdateTagColorDefaults,
} from '@/lib/api/hooks/use-tenant-settings';

import type { TagFiltersState } from '../types';
import { sortCategories, sortGroups, sortTags } from '../utils';

/**
 * ã‚¿ã‚°ãƒšãƒ¼ã‚¸ã®ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ»ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ãƒ•ãƒƒã‚¯
 */
export function useTagPageData() {
  // ãƒ•ã‚£ãƒ«ã‚¿çŠ¶æ…‹
  const [filters, setFilters] = useState<TagFiltersState>({
    scopes: [],
    includeInactive: false,
  });

  // ã‚¯ã‚¨ãƒªãƒ•ã‚£ãƒ«ã‚¿ã‚’æ§‹ç¯‰
  const queryFilters = useMemo<TagCategoryFilters | undefined>(() => {
    const payload: TagCategoryFilters = {};
    if (filters.scopes.length) {
      payload.scope = filters.scopes;
    }
    if (filters.includeInactive) {
      payload.includeInactive = true;
    }
    return Object.keys(payload).length ? payload : undefined;
  }, [filters]);

  // ãƒ‡ãƒ¼ã‚¿å–å¾—
  const { data, isLoading, isFetching } = useGetTagCategories(queryFilters, {
    placeholderData: (previousData) => previousData,
  });

  // ã‚«ãƒ†ã‚´ãƒªãƒ‡ãƒ¼ã‚¿ã‚’æ•´å½¢
  const categories = useMemo(() => data?.data ?? [], [data]);
  const sortedCategories = useMemo(() => sortCategories(categories), [categories]);

  // åˆ©ç”¨å¯èƒ½ãªã‚¹ã‚³ãƒ¼ãƒ—ã‚’æŠ½å‡º
  const availableScopes = useMemo(() => {
    const set = new Set<string>();
    categories.forEach((category) => {
      category.scopes.forEach((scope) => {
        if (scope) {
          set.add(scope);
        }
      });
    });
    return Array.from(set).sort((a, b) => a.localeCompare(b, 'ja'));
  }, [categories]);

  // ãƒ•ãƒ©ãƒƒãƒˆãªã‚¿ã‚°ãƒªã‚¹ãƒˆã‚’ç”Ÿæˆ
  const flatTags = useMemo(() => {
    return sortedCategories.flatMap((category) =>
      sortGroups(category.groups).flatMap((group) =>
        sortTags(group.tags).map((tag) => ({ category, group, tag })),
      ),
    );
  }, [sortedCategories]);

  // ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³
  const createCategory = useCreateTagCategory();
  const updateCategory = useUpdateTagCategory();
  const deleteCategory = useDeleteTagCategory();
  const reorderCategoriesMutation = useReorderTagCategories();
  const createGroup = useCreateTagGroup();
  const updateGroup = useUpdateTagGroup();
  const deleteGroup = useDeleteTagGroup();
  const reorderGroupsMutation = useReorderTagGroups();
  const createTag = useCreateTag();
  const updateTag = useUpdateTag();
  const deleteTag = useDeleteTag();
  const reorderTagsMutation = useReorderTags();

  // ãƒ†ãƒŠãƒ³ãƒˆã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ©ãƒ¼è¨­å®š
  const { data: colorDefaults } = useGetTagColorDefaults();
  const updateTagColorDefaults = useUpdateTagColorDefaults();

  // ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹
  const isCategorySubmitting = createCategory.isPending || updateCategory.isPending;
  const isGroupSubmitting = createGroup.isPending || updateGroup.isPending;
  const isTagSubmitting = createTag.isPending || updateTag.isPending;
  const isAnyMutationPending =
    isCategorySubmitting ||
    isGroupSubmitting ||
    isTagSubmitting ||
    deleteCategory.isPending ||
    deleteGroup.isPending ||
    deleteTag.isPending ||
    reorderCategoriesMutation.isPending ||
    reorderGroupsMutation.isPending ||
    reorderTagsMutation.isPending;

  return {
    // ãƒ•ã‚£ãƒ«ã‚¿
    filters,
    setFilters,
    // ãƒ‡ãƒ¼ã‚¿
    isLoading,
    isFetching,
    categories,
    sortedCategories,
    availableScopes,
    flatTags,
    // ã‚«ãƒ†ã‚´ãƒªæ“ä½œ
    createCategory,
    updateCategory,
    deleteCategory,
    reorderCategoriesMutation,
    // ã‚°ãƒ«ãƒ¼ãƒ—æ“ä½œ
    createGroup,
    updateGroup,
    deleteGroup,
    reorderGroupsMutation,
    // ã‚¿ã‚°æ“ä½œ
    createTag,
    updateTag,
    deleteTag,
    reorderTagsMutation,
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ©ãƒ¼
    colorDefaults,
    updateTagColorDefaults,
    // ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹
    isCategorySubmitting,
    isGroupSubmitting,
    isTagSubmitting,
    isAnyMutationPending,
  };
}
````

## File: frontend/src/app/tags/constants.ts
````typescript
/**
 * ã‚¿ã‚°ç®¡ç†ãƒšãƒ¼ã‚¸ã§ä½¿ç”¨ã™ã‚‹å®šæ•°
 */

// ãƒ—ãƒªã‚»ãƒƒãƒˆã‚«ãƒ©ãƒ¼
export const PRESET_COLORS = [
  '#e74c3c',
  '#e67e22',
  '#f39c12',
  '#f1c40f',
  '#2ecc71',
  '#1abc9c',
  '#3498db',
  '#9b59b6',
  '#34495e',
  '#95a5a6',
];

// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ©ãƒ¼
export const DEFAULT_CATEGORY_COLOR = '#6366F1';
export const DEFAULT_CATEGORY_TEXT_COLOR = '#111827';
export const DEFAULT_GROUP_COLOR = '#3B82F6';
export const DEFAULT_GROUP_TEXT_COLOR = '#111827';
export const DEFAULT_TAG_COLOR = '#3B82F6';
export const DEFAULT_TAG_TEXT_COLOR = '#FFFFFF';

// ã‚«ãƒ†ã‚´ãƒªã®ã‚¹ã‚³ãƒ¼ãƒ—é¸æŠè‚¢ï¼ˆã‚¢ãƒ—ãƒªå®šç¾©ï¼‰
export const CATEGORY_SCOPE_OPTIONS = [
  { value: 'global', label: 'å…¨ã¦ã®ãƒšãƒ¼ã‚¸' },
  { value: 'cats', label: 'çŒ«ä¸€è¦§' },
  { value: 'cats-detail', label: 'çŒ«è©³ç´°' },
  { value: 'breeding', label: 'äº¤é…ç®¡ç†' },
  { value: 'kittens', label: 'å­çŒ«ç®¡ç†' },
  { value: 'care', label: 'ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«' },
  { value: 'pedigrees', label: 'è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿' },
  { value: 'medical-records', label: 'åŒ»ç™‚ãƒ‡ãƒ¼ã‚¿' },
  { value: 'gallery', label: 'ã‚®ãƒ£ãƒ©ãƒªãƒ¼' },
  { value: 'tags', label: 'ã‚¿ã‚°ç®¡ç†' },
  { value: 'staff-shifts', label: 'ã‚¹ã‚¿ãƒƒãƒ•ã‚·ãƒ•ãƒˆ' },
  { value: 'settings', label: 'è¨­å®š' },
  { value: 'tenants', label: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®š' },
];

// ãƒ«ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ—ã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼ˆã‚·ãƒ³ãƒ—ãƒ«åŒ–ã•ã‚ŒãŸUIç”¨ï¼‰
export const RULE_TYPE_OPTIONS = [
  { value: 'PAGE_ACTION', label: 'ã‚¤ãƒ™ãƒ³ãƒˆç™ºç”Ÿæ™‚' },
  { value: 'AGE_THRESHOLD', label: 'å¹´é½¢æ¡ä»¶ã«é”ã—ãŸæ™‚' },
  { value: 'TAG_ASSIGNED', label: 'ç‰¹å®šã‚¿ã‚°ãŒä»˜ä¸ã•ã‚ŒãŸæ™‚' },
];

// ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—ã‚ªãƒ—ã‚·ãƒ§ãƒ³
export const ACTION_TYPE_OPTIONS = [
  { value: 'ASSIGN', label: 'ã‚¿ã‚°ã‚’ä»˜ä¸ã™ã‚‹' },
  { value: 'REMOVE', label: 'ã‚¿ã‚°ã‚’å‰Šé™¤ã™ã‚‹' },
];

// å¹´é½¢ã‚¿ã‚¤ãƒ—ã‚ªãƒ—ã‚·ãƒ§ãƒ³
export const AGE_TYPE_OPTIONS = [
  { value: 'days', label: 'å­çŒ«ï¼ˆæ—¥æ•°ã§æŒ‡å®šï¼‰' },
  { value: 'months', label: 'æˆçŒ«ï¼ˆæœˆæ•°ã§æŒ‡å®šï¼‰' },
];

// ãƒˆãƒªã‚¬ãƒ¼ã‚¿ã‚¤ãƒ—ã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼ˆå†…éƒ¨ç”¨ãƒ»äº’æ›æ€§ç¶­æŒï¼‰
export const TRIGGER_TYPE_OPTIONS = [
  { value: 'EVENT', label: 'ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•' },
  { value: 'SCHEDULE', label: 'ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«' },
];

// ã‚¤ãƒ™ãƒ³ãƒˆã‚¿ã‚¤ãƒ—ã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼ˆå†…éƒ¨ç”¨ãƒ»äº’æ›æ€§ç¶­æŒï¼‰
export const EVENT_TYPE_OPTIONS = [
  { value: 'BREEDING_PLANNED', label: 'äº¤é…äºˆå®š' },
  { value: 'BREEDING_CONFIRMED', label: 'äº¤é…ç¢ºèª' },
  { value: 'PREGNANCY_CONFIRMED', label: 'å¦Šå¨ ç¢ºèª' },
  { value: 'KITTEN_REGISTERED', label: 'å­çŒ«ç™»éŒ²' },
  { value: 'AGE_THRESHOLD', label: 'å¹´é½¢é–¾å€¤' },
  { value: 'PAGE_ACTION', label: 'ãƒšãƒ¼ã‚¸ãƒ»ã‚¢ã‚¯ã‚·ãƒ§ãƒ³é§†å‹•' },
  { value: 'TAG_ASSIGNED', label: 'ã‚¿ã‚°ä»˜ä¸æ™‚' },
  { value: 'CUSTOM', label: 'ã‚«ã‚¹ã‚¿ãƒ ' },
];

// è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ã§ä½¿ç”¨å¯èƒ½ãªã‚¹ã‚³ãƒ¼ãƒ—ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒªã‚¹ãƒˆï¼ˆäº’æ›æ€§ç¶­æŒï¼‰
export const AUTOMATION_SCOPE_OPTIONS = [
  { value: 'cats', label: 'çŒ«ç®¡ç†' },
  { value: 'breeding', label: 'äº¤é…ç®¡ç†' },
  { value: 'health', label: 'å¥åº·ç®¡ç†' },
  { value: 'care', label: 'ã‚±ã‚¢è¨˜éŒ²' },
  { value: 'pedigree', label: 'è¡€çµ±ç®¡ç†' },
];

// PAGE_ACTIONã§é¸æŠå¯èƒ½ãªãƒšãƒ¼ã‚¸ï¼ˆå®Ÿéš›ã®ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³æ§‹é€ ã«åŸºã¥ãï¼‰
export const PAGE_OPTIONS = [
  { value: 'cats', label: 'çŒ«ä¸€è¦§', href: '/cats' },
  { value: 'cats-new', label: 'æ–°è¦çŒ«ç™»éŒ²', href: '/cats/new' },
  { value: 'cats-detail', label: 'çŒ«è©³ç´°', href: '/cats/[id]' },
  { value: 'breeding', label: 'äº¤é…ç®¡ç†', href: '/breeding' },
  { value: 'kittens', label: 'å­çŒ«ç®¡ç†', href: '/kittens' },
  { value: 'care', label: 'ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«', href: '/care' },
  { value: 'pedigrees', label: 'è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿', href: '/pedigrees' },
  { value: 'medical-records', label: 'åŒ»ç™‚ãƒ‡ãƒ¼ã‚¿', href: '/medical-records' },
  { value: 'gallery', label: 'ã‚®ãƒ£ãƒ©ãƒªãƒ¼', href: '/gallery' },
  { value: 'tags', label: 'ã‚¿ã‚°ç®¡ç†', href: '/tags' },
  { value: 'staff-shifts', label: 'ã‚¹ã‚¿ãƒƒãƒ•ã‚·ãƒ•ãƒˆ', href: '/staff/shifts' },
];

// ãƒšãƒ¼ã‚¸ã”ã¨ã«åˆ©ç”¨å¯èƒ½ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³
export const PAGE_ACTIONS_MAP: Record<string, Array<{ value: string; label: string; description?: string }>> = {
  'cats': [
    { value: 'view', label: 'ä¸€è¦§è¡¨ç¤º', description: 'çŒ«ä¸€è¦§ãƒšãƒ¼ã‚¸ãŒè¡¨ç¤ºã•ã‚ŒãŸæ™‚' },
    { value: 'filter', label: 'ãƒ•ã‚£ãƒ«ã‚¿é©ç”¨', description: 'æ¤œç´¢ãƒ»ãƒ•ã‚£ãƒ«ã‚¿ãŒé©ç”¨ã•ã‚ŒãŸæ™‚' },
    { value: 'sort', label: 'ã‚½ãƒ¼ãƒˆå¤‰æ›´', description: 'ä¸¦ã³é †ãŒå¤‰æ›´ã•ã‚ŒãŸæ™‚' },
  ],
  'cats-new': [
    { value: 'create', label: 'æ–°è¦ç™»éŒ²', description: 'æ–°ã—ã„çŒ«ãŒç™»éŒ²ã•ã‚ŒãŸæ™‚' },
    { value: 'create_success', label: 'ç™»éŒ²æˆåŠŸ', description: 'çŒ«ã®ç™»éŒ²ãŒæˆåŠŸã—ãŸæ™‚' },
  ],
  'cats-detail': [
    { value: 'view', label: 'è©³ç´°è¡¨ç¤º', description: 'çŒ«ã®è©³ç´°ãŒè¡¨ç¤ºã•ã‚ŒãŸæ™‚' },
    { value: 'update', label: 'æƒ…å ±æ›´æ–°', description: 'çŒ«ã®æƒ…å ±ãŒæ›´æ–°ã•ã‚ŒãŸæ™‚' },
    { value: 'delete', label: 'å‰Šé™¤', description: 'çŒ«ãŒå‰Šé™¤ã•ã‚ŒãŸæ™‚' },
    { value: 'tag_added', label: 'ã‚¿ã‚°è¿½åŠ ', description: 'çŒ«ã«ã‚¿ã‚°ãŒè¿½åŠ ã•ã‚ŒãŸæ™‚' },
    { value: 'tag_removed', label: 'ã‚¿ã‚°å‰Šé™¤', description: 'çŒ«ã‹ã‚‰ã‚¿ã‚°ãŒå‰Šé™¤ã•ã‚ŒãŸæ™‚' },
  ],
  'breeding': [
    { value: 'create', label: 'äº¤é…äºˆå®šç™»éŒ²', description: 'æ–°ã—ã„äº¤é…äºˆå®šãŒç™»éŒ²ã•ã‚ŒãŸæ™‚' },
    { value: 'update', label: 'äº¤é…æƒ…å ±æ›´æ–°', description: 'äº¤é…æƒ…å ±ãŒæ›´æ–°ã•ã‚ŒãŸæ™‚' },
    { value: 'confirm', label: 'äº¤é…ç¢ºèª', description: 'äº¤é…ãŒç¢ºèªã•ã‚ŒãŸæ™‚' },
    { value: 'pregnancy_confirmed', label: 'å¦Šå¨ ç¢ºèª', description: 'å¦Šå¨ ãŒç¢ºèªã•ã‚ŒãŸæ™‚' },
    { value: 'cancel', label: 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«', description: 'äº¤é…äºˆå®šãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸæ™‚' },
  ],
  'kittens': [
    { value: 'register', label: 'å­çŒ«ç™»éŒ²', description: 'æ–°ã—ã„å­çŒ«ãŒç™»éŒ²ã•ã‚ŒãŸæ™‚' },
    { value: 'update', label: 'å­çŒ«æƒ…å ±æ›´æ–°', description: 'å­çŒ«ã®æƒ…å ±ãŒæ›´æ–°ã•ã‚ŒãŸæ™‚' },
    { value: 'graduate', label: 'å’æ¥­å‡¦ç†', description: 'å­çŒ«ãŒå’æ¥­ã—ãŸæ™‚' },
    { value: 'health_check', label: 'å¥åº·ãƒã‚§ãƒƒã‚¯', description: 'å¥åº·ãƒã‚§ãƒƒã‚¯ãŒè¨˜éŒ²ã•ã‚ŒãŸæ™‚' },
  ],
  'care': [
    { value: 'create', label: 'ã‚±ã‚¢äºˆå®šç™»éŒ²', description: 'æ–°ã—ã„ã‚±ã‚¢äºˆå®šãŒç™»éŒ²ã•ã‚ŒãŸæ™‚' },
    { value: 'complete', label: 'ã‚±ã‚¢å®Œäº†', description: 'ã‚±ã‚¢ãŒå®Œäº†ã—ãŸæ™‚' },
    { value: 'update', label: 'ã‚±ã‚¢æƒ…å ±æ›´æ–°', description: 'ã‚±ã‚¢æƒ…å ±ãŒæ›´æ–°ã•ã‚ŒãŸæ™‚' },
    { value: 'cancel', label: 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«', description: 'ã‚±ã‚¢äºˆå®šãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸæ™‚' },
  ],
  'pedigrees': [
    { value: 'create', label: 'è¡€çµ±æ›¸ä½œæˆ', description: 'æ–°ã—ã„è¡€çµ±æ›¸ãŒä½œæˆã•ã‚ŒãŸæ™‚' },
    { value: 'update', label: 'è¡€çµ±æ›¸æ›´æ–°', description: 'è¡€çµ±æ›¸ãŒæ›´æ–°ã•ã‚ŒãŸæ™‚' },
    { value: 'export', label: 'ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ', description: 'è¡€çµ±æ›¸ãŒã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã•ã‚ŒãŸæ™‚' },
  ],
  'medical-records': [
    { value: 'create', label: 'åŒ»ç™‚è¨˜éŒ²ç™»éŒ²', description: 'æ–°ã—ã„åŒ»ç™‚è¨˜éŒ²ãŒç™»éŒ²ã•ã‚ŒãŸæ™‚' },
    { value: 'update', label: 'åŒ»ç™‚è¨˜éŒ²æ›´æ–°', description: 'åŒ»ç™‚è¨˜éŒ²ãŒæ›´æ–°ã•ã‚ŒãŸæ™‚' },
    { value: 'delete', label: 'åŒ»ç™‚è¨˜éŒ²å‰Šé™¤', description: 'åŒ»ç™‚è¨˜éŒ²ãŒå‰Šé™¤ã•ã‚ŒãŸæ™‚' },
  ],
  'gallery': [
    { value: 'upload', label: 'ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰', description: 'æ–°ã—ã„ç”»åƒãŒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸæ™‚' },
    { value: 'delete', label: 'ç”»åƒå‰Šé™¤', description: 'ç”»åƒãŒå‰Šé™¤ã•ã‚ŒãŸæ™‚' },
  ],
  'tags': [
    { value: 'create', label: 'ã‚¿ã‚°ä½œæˆ', description: 'æ–°ã—ã„ã‚¿ã‚°ãŒä½œæˆã•ã‚ŒãŸæ™‚' },
    { value: 'update', label: 'ã‚¿ã‚°æ›´æ–°', description: 'ã‚¿ã‚°ãŒæ›´æ–°ã•ã‚ŒãŸæ™‚' },
    { value: 'delete', label: 'ã‚¿ã‚°å‰Šé™¤', description: 'ã‚¿ã‚°ãŒå‰Šé™¤ã•ã‚ŒãŸæ™‚' },
  ],
  'staff-shifts': [
    { value: 'create', label: 'ã‚·ãƒ•ãƒˆç™»éŒ²', description: 'æ–°ã—ã„ã‚·ãƒ•ãƒˆãŒç™»éŒ²ã•ã‚ŒãŸæ™‚' },
    { value: 'update', label: 'ã‚·ãƒ•ãƒˆæ›´æ–°', description: 'ã‚·ãƒ•ãƒˆãŒæ›´æ–°ã•ã‚ŒãŸæ™‚' },
    { value: 'delete', label: 'ã‚·ãƒ•ãƒˆå‰Šé™¤', description: 'ã‚·ãƒ•ãƒˆãŒå‰Šé™¤ã•ã‚ŒãŸæ™‚' },
  ],
};

// å¯¾è±¡çŒ«ã®é¸æŠæ–¹æ³•
export const TARGET_SELECTION_OPTIONS = [
  { value: 'event_target', label: 'ã‚¤ãƒ™ãƒ³ãƒˆå¯¾è±¡ã®çŒ«' },
  { value: 'specific_cats', label: 'ç‰¹å®šã®çŒ«' },
  { value: 'all_cats', label: 'å…¨ã¦ã®çŒ«' },
];
````

## File: frontend/src/app/tags/types.ts
````typescript
/**
 * ã‚¿ã‚°ç®¡ç†ãƒšãƒ¼ã‚¸ã§ä½¿ç”¨ã™ã‚‹å‹å®šç¾©
 */

import type {
  TagAutomationTriggerType,
  TagAutomationEventType,
} from '@/lib/api/hooks/use-tag-automation';

// ã‚«ãƒ†ã‚´ãƒªãƒ•ã‚©ãƒ¼ãƒ ã®å€¤
export type CategoryFormValues = {
  key: string;
  name: string;
  description: string;
  color: string;
  textColor: string;
  scopes: string[];
  isActive: boolean;
};

// ã‚¿ã‚°ãƒ•ã‚©ãƒ¼ãƒ ã®å€¤
export type TagFormValues = {
  categoryId: string;
  name: string;
  groupId: string;
  description: string;
  color: string;
  textColor: string;
  allowsManual: boolean;
  allowsAutomation: boolean;
  isActive: boolean;
};

// ã‚°ãƒ«ãƒ¼ãƒ—ãƒ•ã‚©ãƒ¼ãƒ ã®å€¤
export type GroupFormValues = {
  categoryId: string;
  name: string;
  description: string;
  color: string;
  textColor: string;
  isActive: boolean;
};

// ãƒ«ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ—ï¼ˆã‚·ãƒ³ãƒ—ãƒ«åŒ–ã•ã‚ŒãŸUIç”¨ï¼‰
export type RuleType = 'PAGE_ACTION' | 'AGE_THRESHOLD' | 'TAG_ASSIGNED';

// ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—
export type ActionType = 'ASSIGN' | 'REMOVE';

// è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ãƒ•ã‚©ãƒ¼ãƒ ã®å€¤ï¼ˆã‚·ãƒ³ãƒ—ãƒ«åŒ–ç‰ˆï¼‰
export type AutomationRuleFormValues = {
  // UIç”¨ã®ãƒ«ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ—
  ruleType: RuleType;
  // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆä»˜ä¸/å‰Šé™¤ï¼‰
  actionType: ActionType;
  // å¯¾è±¡ã‚¿ã‚°
  tagIds: string[];
  // ãƒ«ãƒ¼ãƒ«åï¼ˆä»»æ„ã€æœªå…¥åŠ›ãªã‚‰è‡ªå‹•ç”Ÿæˆï¼‰
  name: string;
  // ãƒ¡ãƒ¢
  description: string;
  // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹
  isActive: boolean;
  // PAGE_ACTIONè¨­å®š
  pageAction: {
    page: string;
    action: string;
  };
  // å¹´é½¢é–¾å€¤è¨­å®š
  ageThreshold: {
    ageType: 'days' | 'months';
    threshold: number;
  };
  // TAG_ASSIGNEDè¨­å®šï¼ˆç‰¹å®šã‚¿ã‚°ä»˜ä¸æ™‚ã®å‰Šé™¤ãƒˆãƒªã‚¬ãƒ¼ï¼‰
  triggerTagId: string;
  // å†…éƒ¨ç”¨ï¼ˆãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã¨ã®äº’æ›æ€§ç¶­æŒï¼‰
  key?: string;
  triggerType?: TagAutomationTriggerType;
  eventType?: TagAutomationEventType | '';
  scope?: string;
  priority?: number;
};

// è‡ªå‹•åŒ–ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿
export type AutomationMeta = {
  ruleName?: string;
  reason?: string;
  source?: string;
  assignedAt?: string;
};

// ãƒ•ã‚£ãƒ«ã‚¿çŠ¶æ…‹
export type TagFiltersState = {
  scopes: string[];
  includeInactive: boolean;
};
````

## File: frontend/src/app/tags/utils.ts
````typescript
/**
 * ã‚¿ã‚°ç®¡ç†ãƒšãƒ¼ã‚¸ã§ä½¿ç”¨ã™ã‚‹ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
 */

import type {
  TagCategoryView,
  TagGroupView,
  TagView,
  CreateTagCategoryRequest,
  CreateTagRequest,
} from '@/lib/api/hooks/use-tags';
import type { AutomationMeta, CategoryFormValues, TagFormValues } from './types';
import {
  DEFAULT_CATEGORY_COLOR,
  DEFAULT_CATEGORY_TEXT_COLOR,
  DEFAULT_TAG_COLOR,
  DEFAULT_TAG_TEXT_COLOR,
} from './constants';

/**
 * ã‚«ãƒ†ã‚´ãƒªã‚’è¡¨ç¤ºé †ã§ã‚½ãƒ¼ãƒˆ
 */
export function sortCategories(categories: TagCategoryView[]): TagCategoryView[] {
  return [...categories].sort((a, b) => {
    const orderA = a.displayOrder ?? Number.MAX_SAFE_INTEGER;
    const orderB = b.displayOrder ?? Number.MAX_SAFE_INTEGER;
    if (orderA === orderB) {
      return a.name.localeCompare(b.name, 'ja');
    }
    return orderA - orderB;
  });
}

/**
 * ã‚°ãƒ«ãƒ¼ãƒ—ã‚’è¡¨ç¤ºé †ã§ã‚½ãƒ¼ãƒˆ
 */
export function sortGroups(groups?: TagGroupView[] | null): TagGroupView[] {
  return [...(groups ?? [])].sort((a, b) => {
    const orderA = a.displayOrder ?? Number.MAX_SAFE_INTEGER;
    const orderB = b.displayOrder ?? Number.MAX_SAFE_INTEGER;
    if (orderA === orderB) {
      return a.name.localeCompare(b.name, 'ja');
    }
    return orderA - orderB;
  });
}

/**
 * ã‚¿ã‚°ã‚’è¡¨ç¤ºé †ã§ã‚½ãƒ¼ãƒˆ
 */
export function sortTags(tags?: TagView[] | null): TagView[] {
  return [...(tags ?? [])].sort((a, b) => {
    const orderA = a.displayOrder ?? Number.MAX_SAFE_INTEGER;
    const orderB = b.displayOrder ?? Number.MAX_SAFE_INTEGER;
    if (orderA === orderB) {
      return a.name.localeCompare(b.name, 'ja');
    }
    return orderA - orderB;
  });
}

/**
 * ã‚¿ã‚°ã‹ã‚‰è‡ªå‹•åŒ–ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡º
 */
export function extractAutomationMeta(tag: TagView): AutomationMeta | null {
  if (!tag.metadata || typeof tag.metadata !== 'object') {
    return null;
  }

  const metadata = tag.metadata as Record<string, unknown>;
  const automation = metadata.automation;

  if (!automation || typeof automation !== 'object') {
    return null;
  }

  const info = automation as Record<string, unknown>;

  const meta: AutomationMeta = {
    ruleName: typeof info.ruleName === 'string' ? info.ruleName : undefined,
    reason: typeof info.reason === 'string' ? info.reason : undefined,
    source: typeof info.source === 'string' ? info.source : undefined,
    assignedAt: typeof info.assignedAt === 'string' ? info.assignedAt : undefined,
  };

  return Object.values(meta).some(Boolean) ? meta : null;
}

/**
 * ã‚«ãƒ†ã‚´ãƒªãƒ•ã‚©ãƒ¼ãƒ ã®å€¤ã‹ã‚‰APIãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ã‚’æ§‹ç¯‰
 */
export function buildCategoryPayload(values: CategoryFormValues): CreateTagCategoryRequest & {
  textColor?: string;
} {
  const payload: CreateTagCategoryRequest & { textColor?: string } = {
    name: values.name,
    ...(values.key ? { key: values.key } : {}),
    ...(values.description ? { description: values.description } : {}),
    color: values.color || DEFAULT_CATEGORY_COLOR,
    textColor: values.textColor || DEFAULT_CATEGORY_TEXT_COLOR,
    ...(values.scopes.length ? { scopes: values.scopes } : { scopes: [] }),
    isActive: values.isActive,
  };
  return payload;
}

/**
 * ã‚¿ã‚°ãƒ•ã‚©ãƒ¼ãƒ ã®å€¤ã‹ã‚‰APIãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ã‚’æ§‹ç¯‰
 */
export function buildTagPayload(values: TagFormValues): CreateTagRequest & {
  textColor?: string;
} {
  const payload: CreateTagRequest & { textColor?: string } = {
    name: values.name,
    groupId: values.groupId,
    ...(values.description ? { description: values.description } : {}),
    color: values.color || DEFAULT_TAG_COLOR,
    textColor: values.textColor || DEFAULT_TAG_TEXT_COLOR,
    allowsManual: values.allowsManual,
    allowsAutomation: values.allowsAutomation,
    isActive: values.isActive,
  };
  return payload;
}
````

## File: frontend/src/app/tenants/_components/BottomNavSettings.tsx
````typescript
'use client';

import { Card, Stack, Title, Text, Switch, Group, Divider } from '@mantine/core';
import { notifications } from '@mantine/notifications';
import { useBottomNavSettings } from '@/lib/hooks/use-bottom-nav-settings';
import { bottomNavigationItems } from '@/components/AppLayout';
import { ActionButton } from '@/components/ActionButton';

/**
 * ãƒœãƒˆãƒ ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®šã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * 
 * è¡¨ç¤ºã—ãŸã„é …ç›®ã‚’é¸æŠã—ã¦ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã¾ã™ã€‚
 * è¨­å®šã¯ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜ã•ã‚Œã¾ã™ã€‚
 */
export function BottomNavSettings() {
  const {
    items,
    isLoading,
    hasChanges,
    toggleItem,
    showAll,
    hideAll,
    resetToDefault,
    saveSettings,
  } = useBottomNavSettings(bottomNavigationItems);

  const handleSave = () => {
    const success = saveSettings();
    if (success) {
      notifications.show({
        title: 'ä¿å­˜ã—ã¾ã—ãŸ',
        message: 'ãƒœãƒˆãƒ ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ã®è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸ',
        color: 'green',
      });
    } else {
      notifications.show({
        title: 'ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: 'è¨­å®šã®ä¿å­˜ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ',
        color: 'red',
      });
    }
  };

  if (isLoading) {
    return (
      <Card shadow="sm" padding="lg" radius="md" withBorder>
        <Text>èª­ã¿è¾¼ã¿ä¸­...</Text>
      </Card>
    );
  }

  return (
    <Card shadow="sm" padding="lg" radius="md" withBorder>
      <Stack gap="md">
        <Title order={3}>ãƒœãƒˆãƒ ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š</Title>
        <Text size="sm" c="dimmed">
          è¡¨ç¤ºã—ãŸã„é …ç›®ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚è¨­å®šã¯ã“ã®ãƒ‡ãƒã‚¤ã‚¹ã«ä¿å­˜ã•ã‚Œã¾ã™ã€‚
        </Text>

        <Divider />

        <Stack gap="xs">
          {items.map((item) => (
            <Group key={item.id} justify="space-between">
              <Text size="sm">{item.label}</Text>
              <Switch
                checked={item.visible}
                onChange={() => toggleItem(item.id)}
                size="sm"
              />
            </Group>
          ))}
        </Stack>

        <Divider />

        <Group gap="sm">
          <ActionButton action="view" onClick={showAll} isSectionAction>
            å…¨ã¦è¡¨ç¤º
          </ActionButton>
          <ActionButton action="cancel" onClick={hideAll} isSectionAction>
            å…¨ã¦éè¡¨ç¤º
          </ActionButton>
          <ActionButton action="delete" onClick={resetToDefault} isSectionAction>
            ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«æˆ»ã™
          </ActionButton>
        </Group>

        <Divider />

        <Group justify="flex-end">
          <ActionButton 
            action="save"
            onClick={handleSave} 
            disabled={!hasChanges}
            isSectionAction
          >
            {hasChanges ? 'è¨­å®šã‚’ä¿å­˜' : 'å¤‰æ›´ãªã—'}
          </ActionButton>
        </Group>
      </Stack>
    </Card>
  );
}
````

## File: frontend/src/app/tenants/_components/TenantsList.tsx
````typescript
'use client';

import { useState, useEffect, useCallback } from 'react';
import {
  Table,
  Badge,
  Text,
  Card,
  Loader,
  Center,
  Alert,
  Stack,
  Group,
  Modal,
  TextInput,
} from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { IconAlertCircle, IconPlus, IconUserPlus } from '@tabler/icons-react';
import { apiClient, apiRequest } from '@/lib/api/client';
import { notifications } from '@mantine/notifications';
import { ActionButton, ActionIconButton } from '@/components/ActionButton';
import { useAuth } from '@/lib/auth/store';
import { EditTenantModal } from './EditTenantModal';
import { ActionMenu } from './ActionMenu';
import { InviteTenantAdminModal } from './InviteTenantAdminModal';

interface Tenant {
  id: string;
  name: string;
  slug: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

interface CreateTenantFormData {
  name: string;
  slug: string;
}

interface CreateTenantResponse {
  id: string;
  name: string;
  slug: string;
}

/**
 * ãƒ†ãƒŠãƒ³ãƒˆä¸€è¦§ãƒ†ãƒ¼ãƒ–ãƒ«
 * SUPER_ADMINã¯ãƒ†ãƒŠãƒ³ãƒˆä½œæˆæ©Ÿèƒ½ã‚‚ä½¿ç”¨å¯èƒ½
 */
export function TenantsList() {
  const { user } = useAuth();
  const [tenants, setTenants] = useState<Tenant[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // ãƒ†ãƒŠãƒ³ãƒˆä½œæˆãƒ¢ãƒ¼ãƒ€ãƒ«ã®çŠ¶æ…‹
  const [opened, { open, close }] = useDisclosure(false);
  const [createLoading, setCreateLoading] = useState(false);
  const [formData, setFormData] = useState<CreateTenantFormData>({
    name: '',
    slug: '',
  });

  // ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ«ã®çŠ¶æ…‹
  const [editingTenant, setEditingTenant] = useState<Tenant | null>(null);
  const [editModalOpened, { open: openEditModal, close: closeEditModal }] = useDisclosure(false);

  // æ‹›å¾…ãƒ¢ãƒ¼ãƒ€ãƒ«ã®çŠ¶æ…‹
  const [inviteAdminOpened, { open: openInviteAdmin, close: closeInviteAdmin }] = useDisclosure(false);

  // å‰Šé™¤ç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ«ã®çŠ¶æ…‹
  const [deleteModalOpened, { open: openDeleteModal, close: closeDeleteModal }] = useDisclosure(false);
  const [deletingTenant, setDeletingTenant] = useState<Tenant | null>(null);
  const [deleteLoading, setDeleteLoading] = useState(false);

  const isSuperAdmin = user?.role === 'SUPER_ADMIN';

  // ãƒ†ãƒŠãƒ³ãƒˆä¸€è¦§å–å¾—
  const fetchTenants = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      // SUPER_ADMIN ã®ã¿ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
      const response = await apiClient.request('/tenants' as never, 'get');

      if (response.success && Array.isArray(response.data)) {
        setTenants(response.data as Tenant[]);
      } else {
        throw new Error(response.error || 'ãƒ†ãƒŠãƒ³ãƒˆæƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';
      setError(message);
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message,
        color: 'red',
      });
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchTenants();
  }, [fetchTenants]);

  // ãƒ•ã‚©ãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆ
  const resetForm = () => {
    setFormData({
      name: '',
      slug: '',
    });
  };

  // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
  const handleClose = () => {
    if (!createLoading) {
      resetForm();
      close();
    }
  };

  // ãƒ†ãƒŠãƒ³ãƒˆä½œæˆå‡¦ç†
  const handleCreateTenant = async () => {
    // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    if (!formData.name.trim()) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: 'ãƒ†ãƒŠãƒ³ãƒˆåã‚’å…¥åŠ›ã—ã¦ãã ã•ã„',
        color: 'red',
      });
      return;
    }

    try {
      setCreateLoading(true);

      // POST /tenants ã§ãƒ†ãƒŠãƒ³ãƒˆã‚’ä½œæˆ
      const requestBody: { name: string; slug?: string } = {
        name: formData.name.trim(),
      };
      if (formData.slug.trim()) {
        requestBody.slug = formData.slug.trim();
      }

      const response = await apiRequest<CreateTenantResponse>('/tenants', {
        method: 'POST',
        body: JSON.stringify(requestBody),
      });

      if (response.success && response.data) {
        notifications.show({
          title: 'æˆåŠŸ',
          message: 'ãƒ†ãƒŠãƒ³ãƒˆã‚’ä½œæˆã—ã¾ã—ãŸ',
          color: 'green',
        });
        handleClose();
        // ä¸€è¦§ã‚’å†å–å¾—
        fetchTenants();
      } else {
        const errorMessage =
          response.error ||
          response.message ||
          'ãƒ†ãƒŠãƒ³ãƒˆã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ';
        notifications.show({
          title: 'ã‚¨ãƒ©ãƒ¼',
          message: errorMessage,
          color: 'red',
        });
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message,
        color: 'red',
      });
    } finally {
      setCreateLoading(false);
    }
  };

  // ç·¨é›†ãƒœã‚¿ãƒ³ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸã¨ãã®ãƒãƒ³ãƒ‰ãƒ©
  const handleEditClick = (tenant: Tenant) => {
    setEditingTenant(tenant);
    openEditModal();
  };

  // ç·¨é›†æˆåŠŸæ™‚ã®ãƒãƒ³ãƒ‰ãƒ©
  const handleEditSuccess = () => {
    fetchTenants();
  };

  // å‰Šé™¤ãƒœã‚¿ãƒ³ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸã¨ãã®ãƒãƒ³ãƒ‰ãƒ©
  const handleDeleteClick = (tenant: Tenant) => {
    setDeletingTenant(tenant);
    openDeleteModal();
  };

  // å‰Šé™¤ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‰ã˜ã‚‹
  const handleDeleteModalClose = () => {
    if (!deleteLoading) {
      setDeletingTenant(null);
      closeDeleteModal();
    }
  };

  // ãƒ†ãƒŠãƒ³ãƒˆå‰Šé™¤å‡¦ç†
  const handleDeleteTenant = async () => {
    if (!deletingTenant) return;

    try {
      setDeleteLoading(true);

      const response = await apiRequest(`/tenants/${deletingTenant.id}`, {
        method: 'DELETE',
      });

      if (response.success) {
        notifications.show({
          title: 'æˆåŠŸ',
          message: 'ãƒ†ãƒŠãƒ³ãƒˆã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
          color: 'green',
        });
        handleDeleteModalClose();
        // ä¸€è¦§ã‚’å†å–å¾—
        fetchTenants();
      } else {
        const errorMessage =
          response.error ||
          response.message ||
          'ãƒ†ãƒŠãƒ³ãƒˆã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ';
        notifications.show({
          title: 'ã‚¨ãƒ©ãƒ¼',
          message: errorMessage,
          color: 'red',
        });
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message,
        color: 'red',
      });
    } finally {
      setDeleteLoading(false);
    }
  };

  // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›®ã‚’ç”Ÿæˆ
  const getActionItems = () => {
    if (!isSuperAdmin) return [];

    return [
      {
        id: 'create-tenant',
        label: 'æ–°è¦ãƒ†ãƒŠãƒ³ãƒˆä½œæˆ',
        icon: <IconPlus size={16} />,
        onClick: open,
      },
      {
        id: 'invite-admin',
        label: 'ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†è€…ã‚’æ‹›å¾…',
        icon: <IconUserPlus size={16} />,
        onClick: openInviteAdmin,
      },
    ];
  };

  if (loading) {
    return (
      <Center h={200}>
        <Loader size="lg" />
      </Center>
    );
  }

  if (error) {
    return (
      <Alert icon={<IconAlertCircle size={16} />} title="ã‚¨ãƒ©ãƒ¼" color="red">
        {error}
      </Alert>
    );
  }

  return (
    <Stack gap="md">
      {/* SUPER_ADMIN ã®ã¿ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’è¡¨ç¤º */}
      {isSuperAdmin && (
        <Group justify="flex-end">
          <ActionMenu 
            items={getActionItems()} 
            buttonLabel="ã‚¢ã‚¯ã‚·ãƒ§ãƒ³" 
            isSectionAction
          />
        </Group>
      )}

      {tenants.length === 0 ? (
        <Card withBorder p="xl">
          <Center>
            <Text c="dimmed">ãƒ†ãƒŠãƒ³ãƒˆãŒã‚ã‚Šã¾ã›ã‚“</Text>
          </Center>
        </Card>
      ) : (
        <Card withBorder>
          <Table striped highlightOnHover>
            <Table.Thead>
              <Table.Tr>
                <Table.Th>ãƒ†ãƒŠãƒ³ãƒˆå</Table.Th>
                <Table.Th>ã‚¹ãƒ©ãƒƒã‚°</Table.Th>
                <Table.Th>ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</Table.Th>
                <Table.Th>ä½œæˆæ—¥</Table.Th>
                {isSuperAdmin && <Table.Th>æ“ä½œ</Table.Th>}
              </Table.Tr>
            </Table.Thead>
            <Table.Tbody>
              {tenants.map((tenant) => (
                <Table.Tr key={tenant.id}>
                  <Table.Td>
                    <Text fw={600}>{tenant.name}</Text>
                  </Table.Td>
                  <Table.Td>
                    <Text c="dimmed" size="sm">
                      {tenant.slug}
                    </Text>
                  </Table.Td>
                  <Table.Td>
                    <Badge color={tenant.isActive ? 'green' : 'gray'} variant="light">
                      {tenant.isActive ? 'æœ‰åŠ¹' : 'ç„¡åŠ¹'}
                    </Badge>
                  </Table.Td>
                  <Table.Td>
                    <Text size="sm">
                      {new Date(tenant.createdAt).toLocaleDateString('ja-JP')}
                    </Text>
                  </Table.Td>
                  {isSuperAdmin && (
                    <Table.Td>
                      <Group gap="xs" wrap="nowrap">
                        <ActionIconButton
                          action="edit"
                          onClick={() => handleEditClick(tenant)}
                          title="ç·¨é›†"
                        />
                        <ActionIconButton
                          action="delete"
                          onClick={() => handleDeleteClick(tenant)}
                          title="å‰Šé™¤"
                        />
                      </Group>
                    </Table.Td>
                  )}
                </Table.Tr>
              ))}
            </Table.Tbody>
          </Table>
        </Card>
      )}

      {/* ãƒ†ãƒŠãƒ³ãƒˆä½œæˆãƒ¢ãƒ¼ãƒ€ãƒ« */}
      <Modal
        opened={opened}
        onClose={handleClose}
        title="æ–°è¦ãƒ†ãƒŠãƒ³ãƒˆä½œæˆ"
        size="md"
      >
        <Stack gap="md">
          <TextInput
            label="ãƒ†ãƒŠãƒ³ãƒˆå"
            placeholder="ã‚µãƒ³ãƒ—ãƒ«ãƒ†ãƒŠãƒ³ãƒˆ"
            required
            value={formData.name}
            onChange={(e) => setFormData({ ...formData, name: e.target.value })}
            disabled={createLoading}
          />

          <TextInput
            label="ãƒ†ãƒŠãƒ³ãƒˆã‚¹ãƒ©ãƒƒã‚°ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰"
            placeholder="sample-tenant"
            description="æœªå…¥åŠ›ã®å ´åˆã€ãƒ†ãƒŠãƒ³ãƒˆåã‹ã‚‰è‡ªå‹•ç”Ÿæˆã•ã‚Œã¾ã™"
            value={formData.slug}
            onChange={(e) => setFormData({ ...formData, slug: e.target.value })}
            disabled={createLoading}
          />

          <Group justify="flex-end" mt="md">
            <ActionButton action="cancel" onClick={handleClose} disabled={createLoading}>
              ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            </ActionButton>
            <ActionButton action="save" onClick={handleCreateTenant} loading={createLoading}>
              ä½œæˆ
            </ActionButton>
          </Group>
        </Stack>
      </Modal>

      {/* ãƒ†ãƒŠãƒ³ãƒˆç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ« */}
      <EditTenantModal
        tenant={editingTenant}
        opened={editModalOpened}
        onClose={closeEditModal}
        onSuccess={handleEditSuccess}
      />

      {/* ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†è€…æ‹›å¾…ãƒ¢ãƒ¼ãƒ€ãƒ« */}
      <InviteTenantAdminModal
        opened={inviteAdminOpened}
        onClose={closeInviteAdmin}
      />

      {/* ãƒ†ãƒŠãƒ³ãƒˆå‰Šé™¤ç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ« */}
      <Modal
        opened={deleteModalOpened}
        onClose={handleDeleteModalClose}
        title="ãƒ†ãƒŠãƒ³ãƒˆå‰Šé™¤ã®ç¢ºèª"
        size="md"
      >
        <Stack gap="md">
          <Text>
            ä»¥ä¸‹ã®ãƒ†ãƒŠãƒ³ãƒˆã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚
          </Text>
          <Text fw={600} size="lg">
            {deletingTenant?.name}
          </Text>
          <Text size="sm" c="dimmed">
            â€»æ‰€å±ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã„ã‚‹å ´åˆã¯å‰Šé™¤ã§ãã¾ã›ã‚“ã€‚
          </Text>
          <Group justify="flex-end" mt="md">
            <ActionButton action="cancel" onClick={handleDeleteModalClose} disabled={deleteLoading}>
              ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            </ActionButton>
            <ActionButton action="delete" onClick={handleDeleteTenant} loading={deleteLoading}>
              å‰Šé™¤
            </ActionButton>
          </Group>
        </Stack>
      </Modal>
    </Stack>
  );
}
````

## File: frontend/src/app/tenants/page.tsx
````typescript
import { TenantsManagement } from './_components/TenantsManagement';

/**
 * ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†ãƒšãƒ¼ã‚¸
 * 
 * SUPER_ADMIN: ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†è€…æ‹›å¾…æ©Ÿèƒ½
 * TENANT_ADMIN: è‡ªãƒ†ãƒŠãƒ³ãƒˆå†…ãƒ¦ãƒ¼ã‚¶ãƒ¼æ‹›å¾…æ©Ÿèƒ½
 * å…±é€š: ãƒ†ãƒŠãƒ³ãƒˆä¸€è¦§è¡¨ç¤ºã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§è¡¨ç¤º
 */
export default function TenantsPage() {
  return <TenantsManagement />;
}
````

## File: frontend/src/app/CodeCitations.md
````markdown
# Code Citations

## License: MIT
https://github.com/cdnjs/cdnjs/blob/2c59dc30ac29c6b174049fe61823890bccf46dd3/ajax/libs/tolgee-web/5.20.3/tolgee-web.development.esm.mjs

```
{
    50: '#e3f2fd',
    100:
```


## License: MIT
https://github.com/cdnjs/cdnjs/blob/2c59dc30ac29c6b174049fe61823890bccf46dd3/ajax/libs/tolgee-web/5.20.3/tolgee-web.development.esm.mjs

```
{
    50: '#e3f2fd',
    100: '#bbdefb',
    200: '#90caf9',
    300: '#64b5f6',
    400: '#42a5f5',
    500: '#2196f3',
    600
```


## License: MIT
https://github.com/cdnjs/cdnjs/blob/2c59dc30ac29c6b174049fe61823890bccf46dd3/ajax/libs/tolgee-web/5.20.3/tolgee-web.development.esm.mjs

```
: {
    50:
```


## License: ä¸æ˜
https://github.com/vticonsulting/testing/blob/640eaf5ce5f4c572c232909d9b7455ff68c299a8/tailwind.config.js

```
: {
    50:
```


## License: MIT
https://github.com/cdnjs/cdnjs/blob/2c59dc30ac29c6b174049fe61823890bccf46dd3/ajax/libs/tolgee-web/5.20.3/tolgee-web.development.esm.mjs

```
: {
    50: '#fafafa',
    100: '#f5f5f5',
    200: '#eeeeee',
    300: '#e0e0e0',
    400: '#bdbdbd',
    500: '#9e9e
```


## License: ä¸æ˜
https://github.com/vticonsulting/testing/blob/640eaf5ce5f4c572c232909d9b7455ff68c299a8/tailwind.config.js

```
: {
    50: '#fafafa',
    100: '#f5f5f5',
    200: '#eeeeee',
    300: '#e0e0e0',
    400: '#bdbdbd',
    500: '#9e9e
```


## License: MIT
https://github.com/cdnjs/cdnjs/blob/2c59dc30ac29c6b174049fe61823890bccf46dd3/ajax/libs/tolgee-web/5.20.3/tolgee-web.development.esm.mjs

```
: {
    50: '#fafafa',
    100: '#f5f5f5',
    200: '#eeeeee',
    300: '#e0e0e0',
    400: '#bdbdbd',
    500: '#9e9e9e',
    600: '#757575',
    700: '#616161',
    800: '#424242',
    900: '#212121',
```


## License: ä¸æ˜
https://github.com/vticonsulting/testing/blob/640eaf5ce5f4c572c232909d9b7455ff68c299a8/tailwind.config.js

```
: {
    50: '#fafafa',
    100: '#f5f5f5',
    200: '#eeeeee',
    300: '#e0e0e0',
    400: '#bdbdbd',
    500: '#9e9e9e',
    600: '#757575',
    700: '#616161',
    800: '#424242',
    900: '#212121',
```
````

## File: frontend/src/app/layout.tsx
````typescript
import type { Metadata } from "next";
import "./globals.css";
import "@mantine/core/styles.css";
import { Suspense } from "react";
import { Providers } from "./providers";
import { AppLayout } from "@/components/AppLayout";

export const metadata: Metadata = {
  title: 'MyCats',
  description: 'MyCats: çŒ«ã®å€‹ä½“ãƒ»è¡€çµ±ãƒ»ã‚±ã‚¢æƒ…å ±ã‚’ä¸€å…ƒç®¡ç†ã™ã‚‹ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³',
  icons: {
    icon: '/favicon.svg',
  },
  manifest: '/manifest.json',
  openGraph: {
    title: 'MyCats',
    description: 'çŒ«ã®å€‹ä½“ãƒ»è¡€çµ±ãƒ»ã‚±ã‚¢æƒ…å ±ã‚’ä¸€å…ƒç®¡ç†ã™ã‚‹ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³',
    url: 'https://example.com',
    siteName: 'MyCats',
    type: 'website',
    locale: 'ja_JP',
  },
  twitter: {
    card: 'summary',
    title: 'MyCats',
    description: 'çŒ«ã®å€‹ä½“ãƒ»è¡€çµ±ãƒ»ã‚±ã‚¢æƒ…å ±ã‚’ä¸€å…ƒç®¡ç†ã™ã‚‹ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³',
  },
};

export const viewport = {
  themeColor: [
    { media: '(prefers-color-scheme: light)', color: '#ffffff' },
    { media: '(prefers-color-scheme: dark)', color: '#0f172a' },
  ],
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="ja">
      <body className="font-sans antialiased">
        <Providers>
          <Suspense fallback={null}>
            <AppLayout>{children}</AppLayout>
          </Suspense>
        </Providers>
      </body>
    </html>
  );
}
````

## File: frontend/src/app/manifest.ts
````typescript
import type { MetadataRoute } from 'next';

export default function manifest(): MetadataRoute.Manifest {
  return {
    name: 'MyCats Pro',
    short_name: 'MyCats',
    description: 'åœ¨èˆçŒ«ãƒ»è¡€çµ±ç®¡ç†ã®ãŸã‚ã®ç¤¾å†…ãƒãƒ¼ã‚¿ãƒ«',
    start_url: '/',
    display: 'standalone',
    background_color: '#ffffff',
    theme_color: '#1f2937',
    lang: 'ja',
    orientation: 'portrait-primary',
    icons: [
      {
        src: '/favicon.ico',
        sizes: '32x32',
        type: 'image/x-icon',
      },
    ],
  };
}
````

## File: frontend/src/app/page.module.css
````css
.page {
  --gray-rgb: 0, 0, 0;
  --gray-alpha-200: rgba(var(--gray-rgb), 0.08);
  --gray-alpha-100: rgba(var(--gray-rgb), 0.05);

  --button-primary-hover: #383838;
  --button-secondary-hover: #f2f2f2;

  display: grid;
  grid-template-rows: 20px 1fr 20px;
  align-items: center;
  justify-items: center;
  min-height: 100svh;
  padding: 80px;
  gap: 64px;
  font-family: var(--font-geist-sans);
}

@media (prefers-color-scheme: dark) {
  .page {
    --gray-rgb: 255, 255, 255;
    --gray-alpha-200: rgba(var(--gray-rgb), 0.145);
    --gray-alpha-100: rgba(var(--gray-rgb), 0.06);

    --button-primary-hover: #ccc;
    --button-secondary-hover: #1a1a1a;
  }
}

.main {
  display: flex;
  flex-direction: column;
  gap: 32px;
  grid-row-start: 2;
}

.main ol {
  font-family: var(--font-geist-mono);
  padding-left: 0;
  margin: 0;
  font-size: 14px;
  line-height: 24px;
  letter-spacing: -0.01em;
  list-style-position: inside;
}

.main li:not(:last-of-type) {
  margin-bottom: 8px;
}

.main code {
  font-family: inherit;
  background: var(--gray-alpha-100);
  padding: 2px 4px;
  border-radius: 4px;
  font-weight: 600;
}

.ctas {
  display: flex;
  gap: 16px;
}

.ctas a {
  appearance: none;
  border-radius: 128px;
  height: 48px;
  padding: 0 20px;
  border: 1px solid transparent;
  transition:
    background 0.2s,
    color 0.2s,
    border-color 0.2s;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  line-height: 20px;
  font-weight: 500;
}

a.primary {
  background: var(--foreground);
  color: var(--background);
  gap: 8px;
}

a.secondary {
  border-color: var(--gray-alpha-200);
  min-width: 158px;
}

.footer {
  grid-row-start: 3;
  display: flex;
  gap: 24px;
}

.footer a {
  display: flex;
  align-items: center;
  gap: 8px;
}

.footer img {
  flex-shrink: 0;
}

/* Enable hover only on non-touch devices */
@media (hover: hover) and (pointer: fine) {
  a.primary:hover {
    background: var(--button-primary-hover);
    border-color: transparent;
  }

  a.secondary:hover {
    background: var(--button-secondary-hover);
    border-color: transparent;
  }

  .footer a:hover {
    text-decoration: underline;
    text-underline-offset: 4px;
  }
}

@media (max-width: 600px) {
  .page {
    padding: 32px;
    padding-bottom: 80px;
  }

  .main {
    align-items: center;
  }

  .main ol {
    text-align: center;
  }

  .ctas {
    flex-direction: column;
  }

  .ctas a {
    font-size: 14px;
    height: 40px;
    padding: 0 16px;
  }

  a.secondary {
    min-width: auto;
  }

  .footer {
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
  }
}

@media (prefers-color-scheme: dark) {
  .logo {
    filter: invert();
  }
}
````

## File: frontend/src/components/__tests__/TagSelector.test.tsx
````typescript
import '@testing-library/jest-dom'

describe('TagSelector Component', () => {
  it('should be testable when properly imported', async () => {
    // Basic test to ensure component module structure is valid
    try {
      const tagSelectorModule = await import('../TagSelector')
      expect(tagSelectorModule).toBeDefined()
    } catch (error) {
      // If import fails, that's okay - we're just ensuring Jest can run
      expect(error).toBeDefined()
    }
  })

  it('should pass a basic smoke test', () => {
    // Simple test that always passes to ensure CI pipeline works
    expect(true).toBe(true)
  })
})
````

## File: frontend/src/components/badges/index.ts
````typescript
// å…±é€šãƒãƒƒã‚¸ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
export { GenderBadge, getGenderLabel, getGenderColor } from '../GenderBadge';
export { TagDisplay } from '../TagSelector';
````

## File: frontend/src/components/buttons/IconActionButton.tsx
````typescript
'use client';

/**
 * IconActionButton - ãƒ¬ã‚³ãƒ¼ãƒ‰æ“ä½œç”¨ã‚¢ã‚¤ã‚³ãƒ³ãƒœã‚¿ãƒ³
 * 
 * è¨­è¨ˆæ€æƒ³:
 * - ãƒªã‚¹ãƒˆåŒ–ã•ã‚ŒãŸå„ãƒ¬ã‚³ãƒ¼ãƒ‰ã«è¨­ç½®ã™ã‚‹ã‚¢ã‚¤ã‚³ãƒ³ã®ã¿ã®ãƒœã‚¿ãƒ³
 * - å‰Šé™¤ã€è©³ç´°ã€å°åˆ·ãªã©ç”¨é€”åˆ¥ã«ãƒãƒªã‚¢ãƒ³ãƒˆã‚’æä¾›
 * - ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ†ãƒ¼ãƒã«è‡ªå‹•å¯¾å¿œ
 */

import { forwardRef } from 'react';
import { ActionIcon, Tooltip, type ActionIconProps, type MantineColor } from '@mantine/core';
import {
  IconTrash,
  IconEye,
  IconEdit,
  IconPrinter,
  IconDownload,
  IconCopy,
  IconDotsVertical,
  IconCheck,
  IconX,
  IconPlus,
  IconMinus,
  IconRefresh,
  IconExternalLink,
  IconShare,
  IconHeart,
  IconStar,
} from '@tabler/icons-react';

/** ã‚¢ã‚¤ã‚³ãƒ³ãƒœã‚¿ãƒ³ã®ãƒãƒªã‚¢ãƒ³ãƒˆ */
export type IconActionVariant =
  | 'view'      // è©³ç´°è¡¨ç¤º
  | 'edit'      // ç·¨é›†
  | 'delete'    // å‰Šé™¤
  | 'print'     // å°åˆ·
  | 'download'  // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
  | 'copy'      // ã‚³ãƒ”ãƒ¼
  | 'more'      // ãã®ä»–ãƒ¡ãƒ‹ãƒ¥ãƒ¼
  | 'confirm'   // ç¢ºèª
  | 'cancel'    // ã‚­ãƒ£ãƒ³ã‚»ãƒ«
  | 'add'       // è¿½åŠ 
  | 'remove'    // å‰Šé™¤ï¼ˆãƒªã‚¹ãƒˆã‹ã‚‰ï¼‰
  | 'refresh'   // æ›´æ–°
  | 'external'  // å¤–éƒ¨ãƒªãƒ³ã‚¯
  | 'share'     // å…±æœ‰
  | 'favorite'  // ãŠæ°—ã«å…¥ã‚Š
  | 'star';     // ã‚¹ã‚¿ãƒ¼

/** ãƒãƒªã‚¢ãƒ³ãƒˆã”ã¨ã®è¨­å®š */
const VARIANT_CONFIG: Record<
  IconActionVariant,
  {
    icon: React.ComponentType<{ size?: number | string; stroke?: number }>;
    color: MantineColor;
    label: string;
  }
> = {
  view: { icon: IconEye, color: 'gray', label: 'è©³ç´°ã‚’è¦‹ã‚‹' },
  edit: { icon: IconEdit, color: 'orange', label: 'ç·¨é›†' },
  delete: { icon: IconTrash, color: 'red', label: 'å‰Šé™¤' },
  print: { icon: IconPrinter, color: 'gray', label: 'å°åˆ·' },
  download: { icon: IconDownload, color: 'blue', label: 'ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰' },
  copy: { icon: IconCopy, color: 'gray', label: 'ã‚³ãƒ”ãƒ¼' },
  more: { icon: IconDotsVertical, color: 'gray', label: 'ãã®ä»–' },
  confirm: { icon: IconCheck, color: 'green', label: 'ç¢ºèª' },
  cancel: { icon: IconX, color: 'gray', label: 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«' },
  add: { icon: IconPlus, color: 'blue', label: 'è¿½åŠ ' },
  remove: { icon: IconMinus, color: 'red', label: 'å‰Šé™¤' },
  refresh: { icon: IconRefresh, color: 'gray', label: 'æ›´æ–°' },
  external: { icon: IconExternalLink, color: 'blue', label: 'å¤–éƒ¨ãƒªãƒ³ã‚¯' },
  share: { icon: IconShare, color: 'blue', label: 'å…±æœ‰' },
  favorite: { icon: IconHeart, color: 'pink', label: 'ãŠæ°—ã«å…¥ã‚Š' },
  star: { icon: IconStar, color: 'yellow', label: 'ã‚¹ã‚¿ãƒ¼' },
};

export interface IconActionButtonProps extends Omit<ActionIconProps, 'variant' | 'color' | 'children'> {
  /** ãƒœã‚¿ãƒ³ã®ãƒãƒªã‚¢ãƒ³ãƒˆ */
  variant: IconActionVariant;
  /** ã‚¯ãƒªãƒƒã‚¯æ™‚ã®ãƒãƒ³ãƒ‰ãƒ© */
  onClick?: () => void;
  /** ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã®ãƒ©ãƒ™ãƒ«ï¼ˆçœç•¥æ™‚ã¯ãƒãƒªã‚¢ãƒ³ãƒˆã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ©ãƒ™ãƒ«ï¼‰ */
  label?: string;
  /** ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã‚’éè¡¨ç¤ºã«ã™ã‚‹ */
  hideTooltip?: boolean;
  /** ã‚¢ã‚¤ã‚³ãƒ³ã‚µã‚¤ã‚ºï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 18ï¼‰ */
  iconSize?: number;
  /** ã‚«ã‚¹ã‚¿ãƒ ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆReactNodeã¾ãŸã¯é–¢æ•°ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆï¼‰ */
  customIcon?: React.ReactNode | (() => React.ReactNode);
  /** ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ */
  loading?: boolean;
  /** ç„¡åŠ¹åŒ– */
  disabled?: boolean;
}

/**
 * ãƒ¬ã‚³ãƒ¼ãƒ‰æ“ä½œç”¨ã‚¢ã‚¤ã‚³ãƒ³ãƒœã‚¿ãƒ³
 * 
 * @example
 * // è©³ç´°ãƒœã‚¿ãƒ³
 * <IconActionButton variant="view" onClick={() => handleView(id)} />
 * 
 * @example
 * // å‰Šé™¤ãƒœã‚¿ãƒ³
 * <IconActionButton variant="delete" onClick={() => handleDelete(id)} />
 * 
 * @example
 * // ã‚«ã‚¹ã‚¿ãƒ ãƒ©ãƒ™ãƒ«
 * <IconActionButton variant="edit" label="çŒ«æƒ…å ±ã‚’ç·¨é›†" onClick={handleEdit} />
 */
export const IconActionButton = forwardRef<HTMLButtonElement, IconActionButtonProps>(
  (
    {
      variant,
      onClick,
      label,
      hideTooltip = false,
      iconSize = 18,
      customIcon,
      loading = false,
      disabled = false,
      ...props
    },
    ref
  ) => {
    const config = VARIANT_CONFIG[variant];
    const Icon = config.icon;
    const tooltipLabel = label ?? config.label;
    const isDisabled = disabled || loading;

    const button = (
      <ActionIcon
        ref={ref}
        variant="subtle"
        color={config.color}
        onClick={onClick}
        loading={loading}
        disabled={isDisabled}
        aria-label={tooltipLabel}
        styles={{
          root: {
            transition: 'all 0.2s ease',
            color: `var(--button-icon-color, var(--text-secondary))`,
            '&:hover': {
              color: `var(--mantine-color-${config.color}-6, var(--accent))`,
              backgroundColor: `var(--mantine-color-${config.color}-0, var(--accent-soft))`,
            },
          },
        }}
        {...props}
      >
        {typeof customIcon === 'function' ? customIcon() : (customIcon ?? <Icon size={iconSize} stroke={1.5} />)}
      </ActionIcon>
    );

    if (hideTooltip) {
      return button;
    }

    return (
      <Tooltip label={tooltipLabel} withArrow position="top">
        {button}
      </Tooltip>
    );
  }
);

IconActionButton.displayName = 'IconActionButton';
````

## File: frontend/src/components/buttons/index.ts
````typescript
/**
 * çµ±ä¸€ãƒœã‚¿ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * 
 * è¨­è¨ˆæ€æƒ³:
 * - PrimaryButton: ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ¡ã‚¤ãƒ³ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆ1ã‚»ã‚¯ã‚·ãƒ§ãƒ³ = 1ãƒœã‚¿ãƒ³ï¼‰
 * - IconActionButton: ãƒ¬ã‚³ãƒ¼ãƒ‰æ“ä½œç”¨ã‚¢ã‚¤ã‚³ãƒ³ãƒœã‚¿ãƒ³
 * - å„ªå…ˆé †ä½: ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå˜ä½ > ãƒšãƒ¼ã‚¸å˜ä½ > ã‚°ãƒ­ãƒ¼ãƒãƒ«
 */

export { PrimaryButton, type PrimaryButtonProps, type MenuAction } from './PrimaryButton';
export { IconActionButton, type IconActionButtonProps, type IconActionVariant } from './IconActionButton';
````

## File: frontend/src/components/buttons/PrimaryButton.tsx
````typescript
'use client';

/**
 * PrimaryButton - ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ¡ã‚¤ãƒ³ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç”¨ãƒœã‚¿ãƒ³
 * 
 * è¨­è¨ˆæ€æƒ³:
 * - 1ã‚»ã‚¯ã‚·ãƒ§ãƒ³ = 1ãƒœã‚¿ãƒ³ï¼ˆè¤‡æ•°ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¯ Button with Menu ã§çµ±åˆï¼‰
 * - ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ†ãƒ¼ãƒï¼ˆmonolith/ethereal/organicï¼‰ã«è‡ªå‹•å¯¾å¿œ
 * - ã‚µã‚¤ã‚ºãƒ»è‰²ãƒ»è§’ä¸¸ã¯ãƒ†ãƒ¼ãƒã‹ã‚‰ç¶™æ‰¿
 */

import { forwardRef } from 'react';
import { Button, Menu, type ButtonProps } from '@mantine/core';
import { IconChevronDown } from '@tabler/icons-react';

export interface MenuAction {
  /** ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›®ã®ãƒ©ãƒ™ãƒ« */
  label: string;
  /** ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆä»»æ„ï¼‰ */
  icon?: React.ReactNode;
  /** ã‚¯ãƒªãƒƒã‚¯æ™‚ã®ãƒãƒ³ãƒ‰ãƒ© */
  onClick: () => void;
  /** ç„¡åŠ¹åŒ–ãƒ•ãƒ©ã‚° */
  disabled?: boolean;
  /** å±é™ºãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆå‰Šé™¤ãªã©ï¼‰ã®å ´åˆã¯ true */
  danger?: boolean;
}

export interface PrimaryButtonProps extends Omit<ButtonProps, 'variant' | 'color'> {
  /** ãƒœã‚¿ãƒ³ã®ãƒ©ãƒ™ãƒ« */
  children: React.ReactNode;
  /** ã‚¯ãƒªãƒƒã‚¯æ™‚ã®ãƒãƒ³ãƒ‰ãƒ©ï¼ˆå˜ä¸€ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®å ´åˆï¼‰ */
  onClick?: () => void;
  /** è¤‡æ•°ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®å ´åˆã®ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›® */
  menuActions?: MenuAction[];
  /** ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ */
  loading?: boolean;
  /** ç„¡åŠ¹åŒ– */
  disabled?: boolean;
  /** å·¦å´ã®ã‚¢ã‚¤ã‚³ãƒ³ */
  leftSection?: React.ReactNode;
}

/**
 * ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ¡ã‚¤ãƒ³ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç”¨ãƒœã‚¿ãƒ³
 * 
 * @example
 * // å˜ä¸€ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
 * <PrimaryButton onClick={handleSave}>
 *   ä¿å­˜
 * </PrimaryButton>
 * 
 * @example
 * // è¤‡æ•°ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆButton with Menuï¼‰
 * <PrimaryButton
 *   menuActions={[
 *     { label: 'æ–°è¦ç™»éŒ²', icon: <IconPlus size={16} />, onClick: handleCreate },
 *     { label: 'ã‚¤ãƒ³ãƒãƒ¼ãƒˆ', icon: <IconUpload size={16} />, onClick: handleImport },
 *   ]}
 * >
 *   ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
 * </PrimaryButton>
 */
export const PrimaryButton = forwardRef<HTMLButtonElement, PrimaryButtonProps>(
  (
    {
      children,
      onClick,
      menuActions,
      loading = false,
      disabled = false,
      leftSection,
      ...props
    },
    ref
  ) => {
    const isDisabled = disabled || loading;

    // è¤‡æ•°ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®å ´åˆã¯ Button with Menu
    if (menuActions && menuActions.length > 0) {
      return (
        <Menu shadow="md" width={200} position="bottom-end">
          <Menu.Target>
            <Button
              ref={ref}
              loading={loading}
              disabled={isDisabled}
              leftSection={leftSection}
              rightSection={<IconChevronDown size={16} />}
              styles={{
                root: {
                  backgroundColor: 'var(--accent)',
                  color: 'var(--button-primary-text, #ffffff)',
                  borderRadius: 'var(--radius-base)',
                  transition: 'all 0.2s ease',
                  '&:hover': {
                    backgroundColor: 'var(--accent)',
                    opacity: 0.9,
                    transform: 'translateY(-1px)',
                  },
                },
              }}
              {...props}
            >
              {children}
            </Button>
          </Menu.Target>

          <Menu.Dropdown>
            {menuActions.map((action, index) => (
              <Menu.Item
                key={index}
                leftSection={action.icon}
                onClick={action.onClick}
                disabled={action.disabled}
                color={action.danger ? 'red' : undefined}
              >
                {action.label}
              </Menu.Item>
            ))}
          </Menu.Dropdown>
        </Menu>
      );
    }

    // å˜ä¸€ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®å ´åˆ
    return (
      <Button
        ref={ref}
        onClick={onClick}
        loading={loading}
        disabled={isDisabled}
        leftSection={leftSection}
        styles={{
          root: {
            backgroundColor: 'var(--accent)',
            color: 'var(--button-primary-text, #ffffff)',
            borderRadius: 'var(--radius-base)',
            transition: 'all 0.2s ease',
            '&:hover': {
              backgroundColor: 'var(--accent)',
              opacity: 0.9,
              transform: 'translateY(-1px)',
            },
          },
        }}
        {...props}
      >
        {children}
      </Button>
    );
  }
);

PrimaryButton.displayName = 'PrimaryButton';
````

## File: frontend/src/components/cards/CardSpreadDemo.module.css
````css
/**
 * ã‚«ãƒ¼ãƒ‰å±•é–‹ãƒ‡ãƒ¢ - CSSã‚¹ã‚¿ã‚¤ãƒ«å®šç¾©
 * ãƒ•ã‚¡ãƒ³ãƒ»ãƒªãƒœãƒ³ãƒ»ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰ã®å±•é–‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
 */

/* å±•é–‹ã‚¨ãƒªã‚¢ */
.spreadArea {
  position: relative;
  width: 100%;
  min-height: 450px;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  background: linear-gradient(180deg, var(--mantine-color-gray-0) 0%, var(--mantine-color-gray-1) 100%);
  border-radius: 12px;
  padding: 40px;
}

/* ã‚«ãƒ¼ãƒ‰ã‚³ãƒ³ãƒ†ãƒŠ */
.cardContainer {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* å€‹åˆ¥ã‚«ãƒ¼ãƒ‰ãƒ©ãƒƒãƒ‘ãƒ¼ */
.cardWrapper {
  position: absolute;
  cursor: pointer;
  transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1), 
              filter 0.3s ease,
              z-index 0s;
  transform-style: preserve-3d;
}

.cardWrapper:hover {
  z-index: 100 !important;
}

/* é¸æŠçŠ¶æ…‹ */
.selected {
  z-index: 200 !important;
  filter: drop-shadow(0 0 12px rgba(59, 130, 246, 0.6));
}

.selected::after {
  content: '';
  position: absolute;
  inset: -4px;
  border: 3px solid var(--mantine-color-blue-5);
  border-radius: 20px;
  pointer-events: none;
  animation: selectPulse 1.5s ease-in-out infinite;
}

@keyframes selectPulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

/* ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ¥ã‚¹ã‚¿ã‚¤ãƒ«èª¿æ•´ */

/* ãƒ•ã‚¡ãƒ³å±•é–‹ */
.fan {
  height: 300px;
  margin-top: 80px;
}

.fan .cardWrapper {
  transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
}

/* ãƒªãƒœãƒ³å±•é–‹ */
.ribbon {
  width: 100%;
  height: 320px;
}

.ribbon .cardWrapper {
  transition: transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

/* ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰å±•é–‹ */
.cascade {
  align-items: flex-start;
  justify-content: flex-start;
  height: 400px;
  padding-left: 20px;
  padding-top: 20px;
}

.cascade .cardWrapper {
  transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

/* prefers-reduced-motion å¯¾å¿œ */
@media (prefers-reduced-motion: reduce) {
  .cardWrapper {
    transition: none;
  }
  
  .selected::after {
    animation: none;
  }
}

/* ã‚«ãƒ¼ãƒ‰ç¸®å°è¡¨ç¤ºï¼ˆå¤šæ•°è¡¨ç¤ºæ™‚ï¼‰ */
.cardWrapper :global(.card) {
  transform: scale(0.85);
  transform-origin: top center;
}

/* ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œ */
@media (max-width: 768px) {
  .spreadArea {
    min-height: 350px;
    padding: 20px;
  }

  .cardWrapper :global(.card) {
    transform: scale(0.65);
  }

  .fan {
    margin-top: 60px;
  }
}
````

## File: frontend/src/components/cards/CardSpreadDemo.tsx
````typescript
'use client';

/**
 * ã‚«ãƒ¼ãƒ‰å±•é–‹ãƒ‡ãƒ¢ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * ã‚«ã‚¸ãƒãƒ‡ã‚£ãƒ¼ãƒ©ãƒ¼é¢¨ã®ã‚«ãƒ¼ãƒ‰å±•é–‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
 * ãƒ•ã‚¡ãƒ³ãƒ»ãƒªãƒœãƒ³ãƒ»ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰ã®3ãƒ‘ã‚¿ãƒ¼ãƒ³å¯¾å¿œ
 */

import { useState, useMemo } from 'react';
import { Button, Group, Stack, SegmentedControl, Slider, Text, Badge } from '@mantine/core';
import { CatTexturedCard, type RarityType, type DemoCat } from './CatTexturedCard';
import styles from './CardSpreadDemo.module.css';

/** å±•é–‹ãƒ‘ã‚¿ãƒ¼ãƒ³ */
export type SpreadPattern = 'fan' | 'ribbon' | 'cascade';

/** å±•é–‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã®è¨­å®š */
const SPREAD_CONFIG: Record<SpreadPattern, { label: string; icon: string }> = {
  fan: { label: 'ãƒ•ã‚¡ãƒ³', icon: 'ğŸŒ€' },
  ribbon: { label: 'ãƒªãƒœãƒ³', icon: 'â¡ï¸' },
  cascade: { label: 'ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰', icon: 'ğŸ“' },
};

/** ãƒ‡ãƒ¢ç”¨ã®ã‚µãƒ³ãƒ—ãƒ«çŒ«ãƒ‡ãƒ¼ã‚¿ */
const SAMPLE_CATS: DemoCat[] = [
  { id: '1', name: 'ãƒŸã‚±', gender: 'FEMALE', breed: { id: '1', name: 'é›‘ç¨®' } },
  { id: '2', name: 'ã‚¿ãƒ', gender: 'MALE', breed: { id: '2', name: 'ã‚¢ãƒ¡ã‚·ãƒ§ãƒ¼' } },
  { id: '3', name: 'ã‚½ãƒ©', gender: 'MALE', breed: { id: '3', name: 'ã‚¹ã‚³ãƒ†ã‚£ãƒƒã‚·ãƒ¥' } },
  { id: '4', name: 'ãƒ«ãƒŠ', gender: 'FEMALE', breed: { id: '4', name: 'ãƒšãƒ«ã‚·ãƒ£' } },
  { id: '5', name: 'ãƒ¬ã‚ª', gender: 'MALE', breed: { id: '5', name: 'ãƒ™ãƒ³ã‚¬ãƒ«' } },
  { id: '6', name: 'ã‚­ãƒ³ã‚°', gender: 'MALE', breed: { id: '6', name: 'ãƒ¡ã‚¤ãƒ³ã‚¯ãƒ¼ãƒ³' } },
  { id: '7', name: 'ãƒãƒŠ', gender: 'FEMALE', breed: { id: '7', name: 'ãƒ©ã‚°ãƒ‰ãƒ¼ãƒ«' } },
  { id: '8', name: 'ã‚³ã‚¿ãƒ­ã‚¦', gender: 'NEUTER', breed: { id: '8', name: 'ãƒ–ãƒªãƒ†ã‚£ãƒƒã‚·ãƒ¥' } },
];

/** ãƒ¬ã‚¢ãƒªãƒ†ã‚£ã‚’ã‚«ãƒ¼ãƒ‰ä½ç½®ã«å¿œã˜ã¦å‰²ã‚Šå½“ã¦ */
const RARITY_ORDER: RarityType[] = ['common', 'common', 'uncommon', 'uncommon', 'rare', 'superRare', 'ultraRare', 'legendary'];

export interface CardSpreadDemoProps {
  /** ã‚«ã‚¹ã‚¿ãƒ çŒ«ãƒ‡ãƒ¼ã‚¿ï¼ˆçœç•¥æ™‚ã¯ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ï¼‰ */
  cats?: DemoCat[];
}

/**
 * ã‚«ãƒ¼ãƒ‰å±•é–‹ãƒ‡ãƒ¢ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 */
export function CardSpreadDemo({ cats }: CardSpreadDemoProps) {
  const [pattern, setPattern] = useState<SpreadPattern>('fan');
  const [cardCount, setCardCount] = useState(5);
  const [isSpread, setIsSpread] = useState(false);
  const [selectedIndex, setSelectedIndex] = useState<number | null>(null);

  // ä½¿ç”¨ã™ã‚‹çŒ«ãƒ‡ãƒ¼ã‚¿
  const catData = cats ?? SAMPLE_CATS;

  // è¡¨ç¤ºã™ã‚‹ã‚«ãƒ¼ãƒ‰
  const visibleCards = useMemo(() => {
    return Array.from({ length: cardCount }, (_, i) => ({
      cat: catData[i % catData.length],
      rarity: RARITY_ORDER[i % RARITY_ORDER.length],
    }));
  }, [cardCount, catData]);

  // ã‚«ãƒ¼ãƒ‰ä½ç½®ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¨ˆç®—
  const getCardStyle = (index: number, total: number): React.CSSProperties => {
    if (!isSpread) {
      // åæŸçŠ¶æ…‹: å°‘ã—ãšã¤ãšã‚‰ã—ã¦é‡ã­ã‚‹
      return {
        transform: `translateX(${index * 3}px) translateY(${index * 2}px)`,
        zIndex: index,
      };
    }

    switch (pattern) {
      case 'fan': {
        // ãƒ•ã‚¡ãƒ³å±•é–‹: æ‰‡çŠ¶ã«åºƒã’ã‚‹
        const totalAngle = Math.min(60, total * 8); // æœ€å¤§60åº¦
        const startAngle = -totalAngle / 2;
        const angleStep = total > 1 ? totalAngle / (total - 1) : 0;
        const angle = startAngle + index * angleStep;
        const radius = 120;
        return {
          transform: `rotate(${angle}deg) translateY(-${radius}px)`,
          transformOrigin: 'bottom center',
          zIndex: index,
        };
      }
      case 'ribbon': {
        // ãƒªãƒœãƒ³å±•é–‹: æ¨ªä¸€åˆ—ã«åºƒã’ã‚‹
        const spacing = Math.min(180, 800 / total);
        const totalWidth = spacing * (total - 1);
        const startX = -totalWidth / 2;
        return {
          transform: `translateX(${startX + index * spacing}px)`,
          zIndex: index,
        };
      }
      case 'cascade': {
        // ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰å±•é–‹: éšæ®µçŠ¶ã«é‡ã­ã‚‹
        const offsetX = index * 35;
        const offsetY = index * 25;
        return {
          transform: `translateX(${offsetX}px) translateY(${offsetY}px)`,
          zIndex: index,
        };
      }
      default:
        return { zIndex: index };
    }
  };

  const handleCardClick = (index: number) => {
    setSelectedIndex(selectedIndex === index ? null : index);
  };

  return (
    <Stack gap="lg">
      {/* ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ« */}
      <Group justify="center" gap="lg" wrap="wrap">
        <div>
          <Text size="sm" fw={500} mb="xs">å±•é–‹ãƒ‘ã‚¿ãƒ¼ãƒ³</Text>
          <SegmentedControl
            value={pattern}
            onChange={(value) => setPattern(value as SpreadPattern)}
            data={Object.entries(SPREAD_CONFIG).map(([value, { label, icon }]) => ({
              value,
              label: `${icon} ${label}`,
            }))}
          />
        </div>

        <div style={{ width: 200 }}>
          <Text size="sm" fw={500} mb="xs">ã‚«ãƒ¼ãƒ‰æšæ•°: {cardCount}</Text>
          <Slider
            value={cardCount}
            onChange={setCardCount}
            min={3}
            max={Math.min(52, catData.length * 6)}
            step={1}
            marks={[
              { value: 3, label: '3' },
              { value: 13, label: '13' },
              { value: 26, label: '26' },
            ]}
          />
        </div>

        <Button
          onClick={() => setIsSpread(!isSpread)}
          variant={isSpread ? 'filled' : 'outline'}
          color={isSpread ? 'blue' : 'gray'}
        >
          {isSpread ? 'ğŸ´ åæŸ' : 'ğŸƒ å±•é–‹'}
        </Button>
      </Group>

      {/* é¸æŠä¸­ã®ã‚«ãƒ¼ãƒ‰æƒ…å ± */}
      {selectedIndex !== null && (
        <Group justify="center">
          <Badge size="lg" variant="light" color="blue">
            é¸æŠä¸­: {visibleCards[selectedIndex].cat.name}ï¼ˆ{selectedIndex + 1}æšç›®ï¼‰
          </Badge>
        </Group>
      )}

      {/* ã‚«ãƒ¼ãƒ‰å±•é–‹ã‚¨ãƒªã‚¢ */}
      <div className={styles.spreadArea}>
        <div className={`${styles.cardContainer} ${styles[pattern]}`}>
          {visibleCards.map((card, index) => (
            <div
              key={`${card.cat.id}-${index}`}
              className={`${styles.cardWrapper} ${selectedIndex === index ? styles.selected : ''}`}
              style={getCardStyle(index, visibleCards.length)}
              onClick={() => handleCardClick(index)}
            >
              <CatTexturedCard
                cat={card.cat}
                rarity={card.rarity}
                enableHoverEffect={false}
              />
            </div>
          ))}
        </div>
      </div>
    </Stack>
  );
}

export default CardSpreadDemo;
````

## File: frontend/src/components/cards/CatTexturedCard.module.css
````css
/**
 * è³ªæ„Ÿãƒ™ãƒ¼ã‚¹ã®çŒ«ã‚«ãƒ¼ãƒ‰ - CSSã‚¹ã‚¿ã‚¤ãƒ«å®šç¾©
 * ãƒ™ãƒ¼ã‚¹è³ªæ„Ÿ9ç¨®é¡ + ãƒ›ãƒ­ã‚°ãƒ©ãƒ åŠ å·¥4ç¨®é¡ + ç‰¹æ®ŠåŠ¹æœ
 * GPUæœ€é©åŒ–: transform ã¨ opacity ã®ã¿ä½¿ç”¨
 */

/* ===========================================
   ãƒ™ãƒ¼ã‚¹ã‚«ãƒ¼ãƒ‰ã‚¹ã‚¿ã‚¤ãƒ«
   =========================================== */

.card {
  --card-radius: 16px;
  position: relative;
  width: 100%;
  max-width: 220px;
  min-height: 280px;
  border-radius: var(--card-radius);
  overflow: hidden;
  display: flex;
  flex-direction: column;
  transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.card:focus-visible {
  outline: 3px solid var(--mantine-color-blue-5);
  outline-offset: 2px;
}

/* ãƒ›ãƒãƒ¼æ™‚ã®åŸºæœ¬ãƒªãƒ•ãƒˆåŠ¹æœ */
.hoverEnabled:hover {
  transform: translateY(-4px);
}

/* prefers-reduced-motion å¯¾å¿œ */
@media (prefers-reduced-motion: reduce) {
  .card,
  .card:hover,
  .shimmerOverlay,
  .card:hover .shimmerOverlay,
  .rainbowBorder::before {
    transition: none;
    transform: none;
    animation: none;
  }
}

/* ç”»åƒã‚»ã‚¯ã‚·ãƒ§ãƒ³ */
.imageSection {
  height: 140px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(180deg, rgba(0,0,0,0.02) 0%, rgba(0,0,0,0.05) 100%);
}

.imagePlaceholder {
  width: 80px;
  height: 80px;
  border-radius: 50%;
  background: rgba(255,255,255,0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

/* ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¨ãƒªã‚¢ */
.content {
  flex: 1;
  padding: 12px;
  display: flex;
  flex-direction: column;
}

.catName {
  line-height: 1.3;
}

/* ===========================================
   ã‚·ãƒãƒ¼ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼ˆGPUæœ€é©åŒ–ï¼‰
   =========================================== */

.shimmerOverlay {
  position: absolute;
  inset: 0;
  background: linear-gradient(
    105deg, 
    transparent 40%, 
    rgba(255,255,255,0.6) 50%, 
    transparent 60%
  );
  transform: translateX(-100%);
  transition: transform 0.6s ease;
  pointer-events: none;
  z-index: 15;
}

.hoverEnabled:hover .shimmerOverlay {
  transform: translateX(100%);
}

/* ===========================================
   ãƒ™ãƒ¼ã‚¹è³ªæ„Ÿã‚¹ã‚¿ã‚¤ãƒ« - 9ç¨®é¡
   =========================================== */

/* 1. ãƒãƒƒãƒˆ - ã¤ã‚„æ¶ˆã—ä¸Šè³ªç´™ */
.matte {
  background: 
    url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E"),
    linear-gradient(180deg, #fefefe 0%, #f5f5f5 100%);
  background-blend-mode: overlay;
  border: 1px solid #e5e5e5;
  box-shadow: 0 2px 8px rgba(0,0,0,0.08);
}

/* 2. ã‚°ãƒ­ãƒƒã‚·ãƒ¼ - å…‰æ²¢ã‚³ãƒ¼ãƒˆç´™ */
.glossy {
  background: 
    linear-gradient(180deg, rgba(255,255,255,0.5) 0%, rgba(255,255,255,0.1) 40%, transparent 50%),
    linear-gradient(180deg, #ffffff 0%, #f0f0f0 100%);
  border: 1px solid rgba(255,255,255,0.6);
  box-shadow: 
    0 4px 16px rgba(0,0,0,0.12),
    inset 0 1px 0 rgba(255,255,255,0.9);
}

/* 3. ã‚¨ãƒ³ãƒœã‚¹ - æµ®ãå½«ã‚ŠåŠ å·¥ */
.embossed {
  background: linear-gradient(135deg, #f8f8f8 0%, #ececec 50%, #f5f5f5 100%);
  border: none;
  box-shadow: 
    2px 2px 4px rgba(0,0,0,0.1),
    -2px -2px 4px rgba(255,255,255,0.9),
    inset 1px 1px 2px rgba(255,255,255,0.8),
    inset -1px -1px 2px rgba(0,0,0,0.05);
}

/* 4. ãƒªãƒãƒ³ - å¸ƒç›®ãƒ‘ã‚¿ãƒ¼ãƒ³ */
.linen {
  background: 
    url("data:image/svg+xml,%3Csvg viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='linen'%3E%3CfeTurbulence type='turbulence' baseFrequency='0.04' numOctaves='2' result='noise'/%3E%3CfeDisplacementMap in='SourceGraphic' in2='noise' scale='2' xChannelSelector='R' yChannelSelector='G'/%3E%3C/filter%3E%3Crect width='100' height='100' fill='%23f5f0e8' filter='url(%23linen)'/%3E%3C/svg%3E"),
    linear-gradient(180deg, #faf7f2 0%, #f0ebe3 100%);
  background-blend-mode: multiply;
  border: 1px solid #e5ddd0;
  box-shadow: 0 2px 6px rgba(0,0,0,0.06);
}

/* 5. å’Œç´™ - ç¹Šç¶­æ„Ÿãƒ†ã‚¯ã‚¹ãƒãƒ£ */
.washi {
  background: 
    url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='washi'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.04' numOctaves='5' stitchTiles='stitch'/%3E%3CfeColorMatrix type='saturate' values='0'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23washi)' opacity='0.15'/%3E%3C/svg%3E"),
    linear-gradient(180deg, #fffef8 0%, #f8f5ec 100%);
  background-blend-mode: overlay;
  border: 1px solid #e8e2d6;
  box-shadow: 0 1px 4px rgba(0,0,0,0.05);
}

/* 6. ãƒ¡ã‚¿ãƒªãƒƒã‚¯ã‚·ãƒ«ãƒãƒ¼ */
.metallic {
  background: linear-gradient(
    135deg, 
    #e8e8e8 0%, 
    #f8f8f8 20%, 
    #c8c8c8 40%, 
    #f0f0f0 60%, 
    #d8d8d8 80%, 
    #e8e8e8 100%
  );
  border: 2px solid;
  border-image: linear-gradient(135deg, #ccc 0%, #fff 50%, #aaa 100%) 1;
  box-shadow: 
    0 4px 16px rgba(0,0,0,0.12),
    inset 0 1px 0 rgba(255,255,255,0.6),
    inset 0 -1px 0 rgba(0,0,0,0.1);
}

/* 7. ãƒ¡ã‚¿ãƒªãƒƒã‚¯ã‚´ãƒ¼ãƒ«ãƒ‰ */
.metallicGold {
  background: linear-gradient(
    135deg,
    #d4a854 0%,
    #f5e6a3 20%,
    #c9973e 40%,
    #edd994 60%,
    #d4af5c 80%,
    #d4a854 100%
  );
  border: 2px solid;
  border-image: linear-gradient(135deg, #b8860b 0%, #ffd700 50%, #b8860b 100%) 1;
  box-shadow: 
    0 4px 16px rgba(180,140,60,0.25),
    inset 0 1px 0 rgba(255,240,180,0.5);
}

/* 8. ãƒ¬ã‚¶ãƒ¼ - é©ã‚·ãƒœãƒ‘ã‚¿ãƒ¼ãƒ³ */
.leather {
  background: 
    url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='leather'%3E%3CfeTurbulence type='turbulence' baseFrequency='0.15' numOctaves='3' stitchTiles='stitch' result='noise'/%3E%3CfeDiffuseLighting in='noise' lighting-color='%23fff' surfaceScale='1.5'%3E%3CfeDistantLight azimuth='45' elevation='60'/%3E%3C/feDiffuseLighting%3E%3C/filter%3E%3Crect width='100%25' height='100%25' fill='%235d4037' filter='url(%23leather)' opacity='0.3'/%3E%3C/svg%3E"),
    linear-gradient(180deg, #6d4c41 0%, #5d4037 50%, #4e342e 100%);
  background-blend-mode: overlay;
  border: none;
  box-shadow: 0 4px 12px rgba(0,0,0,0.25);
  color: #fff;
}

.leather .catName,
.leather .content {
  color: #fff;
}

.leather .imagePlaceholder {
  background: rgba(255,255,255,0.15);
}

/* 9. æœ¨ç›® - ã‚¦ãƒƒãƒ‰ãƒ‘ã‚¿ãƒ¼ãƒ³ */
.wood {
  background: 
    url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='wood'%3E%3CfeTurbulence type='turbulence' baseFrequency='0.02 0.15' numOctaves='2' seed='5' stitchTiles='stitch' result='noise'/%3E%3CfeColorMatrix type='saturate' values='0'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23wood)' opacity='0.2'/%3E%3C/svg%3E"),
    linear-gradient(180deg, #d7ccc8 0%, #bcaaa4 50%, #a1887f 100%);
  background-blend-mode: multiply;
  border: none;
  box-shadow: 0 3px 10px rgba(0,0,0,0.15);
}

/* ===========================================
   ãƒ›ãƒ­ã‚°ãƒ©ãƒ åŠ å·¥ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ - 4ç¨®é¡
   =========================================== */

/* å…±é€šãƒ™ãƒ¼ã‚¹ */
.holoOverlay {
  position: absolute;
  inset: 0;
  border-radius: inherit;
  pointer-events: none;
  z-index: 2;
  mix-blend-mode: overlay;
}

/* 1. ã‚¹ãƒˆãƒ©ã‚¤ãƒ—ãƒ›ãƒ­ã‚°ãƒ©ãƒ  */
.holoStripe {
  background: repeating-linear-gradient(
    135deg,
    rgba(255, 0, 0, 0.08) 0px,
    rgba(255, 127, 0, 0.08) 10px,
    rgba(255, 255, 0, 0.08) 20px,
    rgba(0, 255, 0, 0.08) 30px,
    rgba(0, 127, 255, 0.08) 40px,
    rgba(75, 0, 130, 0.08) 50px,
    rgba(148, 0, 211, 0.08) 60px,
    rgba(255, 0, 0, 0.08) 70px
  );
}

/* 2. ãƒ‰ãƒƒãƒˆãƒ›ãƒ­ã‚°ãƒ©ãƒ  */
.holoDot {
  background: 
    radial-gradient(circle at 25% 25%, rgba(255,100,100,0.12) 1px, transparent 2px),
    radial-gradient(circle at 75% 25%, rgba(100,255,100,0.12) 1px, transparent 2px),
    radial-gradient(circle at 50% 75%, rgba(100,100,255,0.12) 1px, transparent 2px),
    radial-gradient(circle at 50% 50%, rgba(255,255,100,0.12) 1px, transparent 2px);
  background-size: 12px 12px;
}

/* 3. ãƒ—ãƒªã‚ºãƒ ãƒ›ãƒ­ã‚°ãƒ©ãƒ  */
.holoPrism {
  background: linear-gradient(
    60deg,
    rgba(255, 0, 0, 0.06) 0%,
    rgba(255, 165, 0, 0.06) 17%,
    rgba(255, 255, 0, 0.06) 33%,
    rgba(0, 255, 0, 0.06) 50%,
    rgba(0, 127, 255, 0.06) 67%,
    rgba(139, 0, 255, 0.06) 83%,
    rgba(255, 0, 0, 0.06) 100%
  );
}

/* 4. ã‚¹ã‚¿ãƒ¼ãƒ€ã‚¹ãƒˆãƒ›ãƒ­ã‚°ãƒ©ãƒ  */
.holoStardust {
  background-image: 
    radial-gradient(circle at 20% 30%, rgba(255,255,255,0.5) 0px, transparent 2px),
    radial-gradient(circle at 80% 20%, rgba(255,200,100,0.4) 0px, transparent 1.5px),
    radial-gradient(circle at 40% 70%, rgba(100,200,255,0.4) 0px, transparent 2px),
    radial-gradient(circle at 70% 60%, rgba(255,100,200,0.4) 0px, transparent 1.5px),
    radial-gradient(circle at 15% 85%, rgba(100,255,200,0.4) 0px, transparent 1px),
    radial-gradient(circle at 90% 80%, rgba(200,100,255,0.4) 0px, transparent 2px),
    radial-gradient(circle at 50% 50%, rgba(255,255,200,0.3) 0px, transparent 2.5px),
    radial-gradient(circle at 35% 15%, rgba(200,255,255,0.3) 0px, transparent 1px);
  background-size: 80px 80px;
}

/* ===========================================
   ç‰¹æ®ŠåŠ¹æœ - ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ãƒœãƒ¼ãƒ€ãƒ¼
   =========================================== */

.rainbowBorder {
  position: relative;
}

.rainbowBorder::before {
  content: '';
  position: absolute;
  inset: -3px;
  border-radius: calc(var(--card-radius) + 3px);
  background: linear-gradient(
    135deg,
    #ff0000,
    #ff7f00,
    #ffff00,
    #00ff00,
    #0000ff,
    #4b0082,
    #9400d3,
    #ff0000
  );
  background-size: 400% 400%;
  z-index: -1;
  animation: rainbowShift 6s linear infinite;
}

@keyframes rainbowShift {
  0% { background-position: 0% 50%; }
  100% { background-position: 400% 50%; }
}

@media (prefers-reduced-motion: reduce) {
  .rainbowBorder::before {
    animation: none;
  }
}
````

## File: frontend/src/components/cards/CatTexturedCard.tsx
````typescript
'use client';

/**
 * è³ªæ„Ÿãƒ™ãƒ¼ã‚¹ã®çŒ«ã‚«ãƒ¼ãƒ‰ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * ãƒ™ãƒ¼ã‚¹è³ªæ„Ÿ + ãƒ›ãƒ­ã‚°ãƒ©ãƒ åŠ å·¥ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼æ§‹é€ 
 */

import { Card, Text, Badge, Group, Stack } from '@mantine/core';
import type { Cat } from '@/lib/api/hooks/use-cats';
import styles from './CatTexturedCard.module.css';

/** è³ªæ„Ÿã‚¿ã‚¤ãƒ—ï¼ˆ9ç¨®é¡ï¼‰ */
export type TextureType = 
  | 'matte' 
  | 'glossy' 
  | 'embossed' 
  | 'linen' 
  | 'washi' 
  | 'metallic' 
  | 'metallicGold' 
  | 'leather' 
  | 'wood';

/** ãƒ›ãƒ­ã‚°ãƒ©ãƒ åŠ å·¥ã‚¿ã‚¤ãƒ—ï¼ˆ4ç¨®é¡ + noneï¼‰ */
export type HoloPatternType = 'none' | 'stripe' | 'dot' | 'prism' | 'stardust';

/** ãƒ¬ã‚¢ãƒªãƒ†ã‚£ã‚¿ã‚¤ãƒ—ï¼ˆ6æ®µéšï¼‰ */
export type RarityType = 'common' | 'uncommon' | 'rare' | 'superRare' | 'ultraRare' | 'legendary';

/** ãƒ¬ã‚¢ãƒªãƒ†ã‚£åˆ¥ãƒ—ãƒªã‚»ãƒƒãƒˆè¨­å®š */
interface RarityPreset {
  texture: TextureType;
  holoPattern: HoloPatternType;
  rainbowBorder: boolean;
}

const RARITY_PRESETS: Record<RarityType, RarityPreset> = {
  common: {
    texture: 'matte',
    holoPattern: 'none',
    rainbowBorder: false,
  },
  uncommon: {
    texture: 'linen',
    holoPattern: 'none',
    rainbowBorder: false,
  },
  rare: {
    texture: 'glossy',
    holoPattern: 'none',
    rainbowBorder: false,
  },
  superRare: {
    texture: 'metallic',
    holoPattern: 'stripe',  // ãƒ¡ã‚¿ãƒªãƒƒã‚¯ + ã‚¹ãƒˆãƒ©ã‚¤ãƒ—ãƒ›ãƒ­
    rainbowBorder: false,
  },
  ultraRare: {
    texture: 'metallicGold',
    holoPattern: 'prism',   // ã‚´ãƒ¼ãƒ«ãƒ‰ + ãƒ—ãƒªã‚ºãƒ ãƒ›ãƒ­
    rainbowBorder: false,
  },
  legendary: {
    texture: 'embossed',
    holoPattern: 'stardust', // ã‚¨ãƒ³ãƒœã‚¹ + ã‚¹ã‚¿ãƒ¼ãƒ€ã‚¹ãƒˆãƒ›ãƒ­
    rainbowBorder: true,
  },
};

/** ãƒ¬ã‚¢ãƒªãƒ†ã‚£ã®æ—¥æœ¬èªè¡¨ç¤ºã¨è‰²è¨­å®š */
const RARITY_DISPLAY: Record<RarityType, { label: string; color: string }> = {
  common: { label: 'ã‚³ãƒ¢ãƒ³', color: 'gray' },
  uncommon: { label: 'ã‚¢ãƒ³ã‚³ãƒ¢ãƒ³', color: 'green' },
  rare: { label: 'ãƒ¬ã‚¢', color: 'blue' },
  superRare: { label: 'ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒ¬ã‚¢', color: 'violet' },
  ultraRare: { label: 'ã‚¦ãƒ«ãƒˆãƒ©ãƒ¬ã‚¢', color: 'orange' },
  legendary: { label: 'ãƒ¬ã‚¸ã‚§ãƒ³ãƒ€ãƒªãƒ¼', color: 'yellow' },
};

/** è³ªæ„Ÿã®æ—¥æœ¬èªè¡¨ç¤º */
const TEXTURE_DISPLAY: Record<TextureType, string> = {
  matte: 'ãƒãƒƒãƒˆ',
  glossy: 'ã‚°ãƒ­ãƒƒã‚·ãƒ¼',
  embossed: 'ã‚¨ãƒ³ãƒœã‚¹',
  linen: 'ãƒªãƒãƒ³',
  washi: 'å’Œç´™',
  metallic: 'ãƒ¡ã‚¿ãƒªãƒƒã‚¯',
  metallicGold: 'ã‚´ãƒ¼ãƒ«ãƒ‰',
  leather: 'ãƒ¬ã‚¶ãƒ¼',
  wood: 'æœ¨ç›®',
};

/** ãƒ›ãƒ­ã‚°ãƒ©ãƒ åŠ å·¥ã®æ—¥æœ¬èªè¡¨ç¤º */
const HOLO_DISPLAY: Record<HoloPatternType, string> = {
  none: 'ãªã—',
  stripe: 'ã‚¹ãƒˆãƒ©ã‚¤ãƒ—',
  dot: 'ãƒ‰ãƒƒãƒˆ',
  prism: 'ãƒ—ãƒªã‚ºãƒ ',
  stardust: 'ã‚¹ã‚¿ãƒ¼ãƒ€ã‚¹ãƒˆ',
};

/** ãƒ‡ãƒ¢ç”¨ã®ãƒ€ãƒŸãƒ¼çŒ«ãƒ‡ãƒ¼ã‚¿ */
export interface DemoCat {
  id: string;
  name: string;
  gender?: 'MALE' | 'FEMALE' | 'NEUTER' | 'SPAY';
  birthDate?: string;
  breed?: { id: string; name: string };
  coatColor?: { id: string; name: string };
  registrationNumber?: string | null;
}

export interface CatTexturedCardProps {
  /** çŒ«ãƒ‡ãƒ¼ã‚¿ï¼ˆå®Ÿéš›ã®Catå‹ã¾ãŸã¯ãƒ‡ãƒ¢ç”¨ãƒ‡ãƒ¼ã‚¿ï¼‰ */
  cat: Cat | DemoCat;
  /** ãƒ™ãƒ¼ã‚¹è³ªæ„Ÿã‚¿ã‚¤ãƒ— */
  texture?: TextureType;
  /** ãƒ›ãƒ­ã‚°ãƒ©ãƒ åŠ å·¥ãƒ‘ã‚¿ãƒ¼ãƒ³ */
  holoPattern?: HoloPatternType;
  /** ãƒ¬ã‚¢ãƒªãƒ†ã‚£ï¼ˆæŒ‡å®šã™ã‚‹ã¨ texture + holoPattern ã‚’è‡ªå‹•æ±ºå®šï¼‰ */
  rarity?: RarityType;
  /** ãƒ›ãƒãƒ¼æ™‚ã®è»½ã„æ¼”å‡ºã‚’æœ‰åŠ¹åŒ–ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: trueï¼‰ */
  enableHoverEffect?: boolean;
  /** ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ãƒœãƒ¼ãƒ€ãƒ¼ */
  rainbowBorder?: boolean;
  /** ã‚¯ãƒªãƒƒã‚¯ãƒãƒ³ãƒ‰ãƒ© */
  onClick?: () => void;
}

/**
 * ãƒ›ãƒ­ã‚°ãƒ©ãƒ åŠ å·¥ãƒ‘ã‚¿ãƒ¼ãƒ³åã‚’CSSã‚¯ãƒ©ã‚¹åã«å¤‰æ›
 */
function getHoloClassName(pattern: HoloPatternType): string {
  if (pattern === 'none') return '';
  // stripe -> holoStripe, dot -> holoDot, etc.
  return `holo${pattern.charAt(0).toUpperCase()}${pattern.slice(1)}`;
}

/**
 * è³ªæ„Ÿãƒ™ãƒ¼ã‚¹ã®çŒ«ã‚«ãƒ¼ãƒ‰ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * 
 * @example
 * // ãƒ™ãƒ¼ã‚¹è³ªæ„Ÿã®ã¿
 * <CatTexturedCard cat={cat} texture="metallic" />
 * 
 * // ãƒ™ãƒ¼ã‚¹è³ªæ„Ÿ + ãƒ›ãƒ­ã‚°ãƒ©ãƒ åŠ å·¥
 * <CatTexturedCard cat={cat} texture="metallicGold" holoPattern="prism" />
 * 
 * // ãƒ¬ã‚¢ãƒªãƒ†ã‚£ã§è‡ªå‹•æ±ºå®š
 * <CatTexturedCard cat={cat} rarity="legendary" />
 * 
 * // ãƒ•ãƒ«ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º
 * <CatTexturedCard 
 *   cat={cat} 
 *   texture="metallic" 
 *   holoPattern="stardust" 
 *   rainbowBorder 
 *   enableHoverEffect={false}
 * />
 */
export function CatTexturedCard({
  cat,
  texture,
  holoPattern,
  rarity,
  enableHoverEffect = true,
  rainbowBorder,
  onClick,
}: CatTexturedCardProps) {
  // ãƒ¬ã‚¢ãƒªãƒ†ã‚£æŒ‡å®šæ™‚ã¯ãƒ—ãƒªã‚»ãƒƒãƒˆã‚’é©ç”¨
  const preset = rarity ? RARITY_PRESETS[rarity] : null;
  const finalTexture = texture ?? preset?.texture ?? 'matte';
  const finalHolo = holoPattern ?? preset?.holoPattern ?? 'none';
  const finalRainbow = rainbowBorder ?? preset?.rainbowBorder ?? false;

  // CSSã‚¯ãƒ©ã‚¹ã‚’çµ„ã¿ç«‹ã¦
  const cardClasses = [
    styles.card,
    styles[finalTexture],
    finalRainbow ? styles.rainbowBorder : '',
    enableHoverEffect ? styles.hoverEnabled : '',
  ].filter(Boolean).join(' ');

  // ãƒ›ãƒ­ã‚°ãƒ©ãƒ ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã®ã‚¯ãƒ©ã‚¹
  const holoClassName = getHoloClassName(finalHolo);

  // æ€§åˆ¥è¡¨ç¤º
  const genderDisplay = cat.gender 
    ? { MALE: 'â™‚', FEMALE: 'â™€', NEUTER: 'â™‚ï¼ˆå»å‹¢ï¼‰', SPAY: 'â™€ï¼ˆé¿å¦Šï¼‰' }[cat.gender]
    : null;

  // ã‚·ãƒãƒ¼æ¼”å‡ºå¯¾è±¡åˆ¤å®šï¼ˆglossy, metallicç³», ãƒ›ãƒ­ã‚°ãƒ©ãƒ æœ‰ã‚Šã®å ´åˆï¼‰
  const hasShimmer = enableHoverEffect && (
    finalTexture === 'glossy' || 
    finalTexture === 'metallic' || 
    finalTexture === 'metallicGold' ||
    finalHolo !== 'none'
  );

  return (
    <div 
      className={cardClasses}
      role="article"
      onClick={onClick}
      style={{ cursor: onClick ? 'pointer' : 'default' }}
    >
      {/* ãƒ›ãƒ­ã‚°ãƒ©ãƒ åŠ å·¥ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */}
      {finalHolo !== 'none' && (
        <div 
          className={`${styles.holoOverlay} ${styles[holoClassName]}`} 
          aria-hidden="true" 
        />
      )}

      {/* ã‚·ãƒãƒ¼æ¼”å‡ºç”¨ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */}
      {hasShimmer && (
        <div className={styles.shimmerOverlay} aria-hidden="true" />
      )}

      <Card.Section className={styles.imageSection}>
        <div className={styles.imagePlaceholder}>
          <Text size="3rem" style={{ lineHeight: 1 }}>ğŸ±</Text>
        </div>
      </Card.Section>

      <Stack gap="xs" className={styles.content}>
        <Group justify="space-between" align="flex-start">
          <Text fw={600} size="md" className={styles.catName}>
            {cat.name}
          </Text>
          {genderDisplay && (
            <Text size="sm" c="dimmed">
              {genderDisplay}
            </Text>
          )}
        </Group>

        {cat.breed && (
          <Text size="xs" c="dimmed">
            {cat.breed.name}
          </Text>
        )}

        <Group gap="xs" mt="auto" wrap="wrap">
          {rarity && (
            <Badge 
              color={RARITY_DISPLAY[rarity].color} 
              variant="light" 
              size="sm"
            >
              {RARITY_DISPLAY[rarity].label}
            </Badge>
          )}
          <Badge variant="outline" size="xs" color="gray">
            {TEXTURE_DISPLAY[finalTexture]}
          </Badge>
          {finalHolo !== 'none' && (
            <Badge variant="dot" size="xs" color="cyan">
              {HOLO_DISPLAY[finalHolo]}
            </Badge>
          )}
        </Group>
      </Stack>
    </div>
  );
}

export default CatTexturedCard;
````

## File: frontend/src/components/cards/index.ts
````typescript
/**
 * ã‚«ãƒ¼ãƒ‰ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
 */

export { CatTexturedCard } from './CatTexturedCard';
export type { 
  CatTexturedCardProps, 
  TextureType, 
  HoloPatternType,
  RarityType,
  DemoCat 
} from './CatTexturedCard';

export { CardSpreadDemo } from './CardSpreadDemo';
export type { CardSpreadDemoProps, SpreadPattern } from './CardSpreadDemo';
````

## File: frontend/src/components/context-menu/context-menu.tsx
````typescript
'use client';

import { useState, useRef, useEffect, ReactNode, cloneElement, isValidElement, createContext, useContext } from 'react';
import { Menu, Portal } from '@mantine/core';
import {
  IconEye,
  IconEdit,
  IconTrash,
  IconCopy,
  IconDownload,
  IconPrinter,
  IconShare,
  IconPlus,
  IconDots,
} from '@tabler/icons-react';

// ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼ç®¡ç†ç”¨ã®Context
interface ContextMenuContextType {
  currentMenuId: string | null;
  setCurrentMenuId: (id: string | null) => void;
}

const ContextMenuContext = createContext<ContextMenuContextType>({
  currentMenuId: null,
  setCurrentMenuId: () => {},
});

export function ContextMenuManager({ children }: { children: ReactNode }) {
  const [currentMenuId, setCurrentMenuId] = useState<string | null>(null);
  
  return (
    <ContextMenuContext.Provider value={{ currentMenuId, setCurrentMenuId }}>
      {children}
    </ContextMenuContext.Provider>
  );
}

export type ContextAction = 
  | 'view'
  | 'edit'
  | 'delete'
  | 'duplicate'
  | 'export'
  | 'print'
  | 'share'
  | 'create';

export interface CustomAction {
  id: string;
  label: string;
  icon?: ReactNode;
  color?: string;
  divider?: boolean;
}

export interface ContextMenuAction {
  action: ContextAction | string;
  label?: string;
  icon?: ReactNode;
  color?: string;
  disabled?: boolean;
  hidden?: boolean;
}

interface ContextMenuProviderProps<T = unknown> {
  children: ReactNode;
  entity?: T;
  entityType?: string;
  actions?: (ContextAction | string)[];
  customActions?: CustomAction[];
  onAction?: (action: string, entity?: T) => void;
  disabled?: boolean;
  enableDoubleClick?: boolean;
  doubleClickAction?: ContextAction | string;
}

const defaultIcons: Record<ContextAction, ReactNode> = {
  view: <IconEye size={16} />,
  edit: <IconEdit size={16} />,
  delete: <IconTrash size={16} />,
  duplicate: <IconCopy size={16} />,
  export: <IconDownload size={16} />,
  print: <IconPrinter size={16} />,
  share: <IconShare size={16} />,
  create: <IconPlus size={16} />,
};

const defaultLabels: Record<ContextAction, string> = {
  view: 'è©³ç´°ã‚’è¦‹ã‚‹',
  edit: 'ç·¨é›†',
  delete: 'å‰Šé™¤',
  duplicate: 'è¤‡è£½',
  export: 'ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ',
  print: 'å°åˆ·',
  share: 'å…±æœ‰',
  create: 'æ–°è¦ä½œæˆ',
};

const defaultColors: Partial<Record<ContextAction, string>> = {
  delete: 'red',
};

export function ContextMenuProvider<T = unknown>({
  children,
  entity,
  entityType,
  actions = ['view', 'edit', 'delete'],
  customActions = [],
  onAction,
  disabled = false,
  enableDoubleClick = true,
  doubleClickAction = 'edit',
}: ContextMenuProviderProps<T>) {
  const [opened, setOpened] = useState(false);
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const containerRef = useRef<HTMLDivElement>(null);
  const menuRef = useRef<HTMLDivElement>(null);
  const lastTapRef = useRef<number>(0);
  const menuIdRef = useRef<string>(Math.random().toString(36).substring(7));
  
  // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼ç®¡ç†
  const { currentMenuId, setCurrentMenuId } = useContext(ContextMenuContext);
  
  // ä»–ã®ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãŒé–‹ã„ãŸã‚‰è‡ªåˆ†ã‚’é–‰ã˜ã‚‹
  useEffect(() => {
    if (currentMenuId !== null && currentMenuId !== menuIdRef.current) {
      setOpened(false);
    }
  }, [currentMenuId]);

  // ãƒ¡ãƒ‹ãƒ¥ãƒ¼å¤–ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
  useEffect(() => {
    if (!opened) return;

    const handleClickOutside = (event: MouseEvent) => {
      const target = event.target as HTMLElement;
      // Menu.Dropdownè¦ç´ ã¨ãã®å­å­«ã‹ãƒã‚§ãƒƒã‚¯
      const dropdown = document.querySelector('[data-menu-dropdown]');
      if (dropdown && !dropdown.contains(target)) {
        setOpened(false);
        setCurrentMenuId(null);
      }
    };

    // å°‘ã—é…å»¶ã•ã›ã¦ã‹ã‚‰è¿½åŠ ï¼ˆå³ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã®å¾Œã«å®Ÿè¡Œã•ã‚Œã‚‹ã‚ˆã†ã«ï¼‰
    const timer = setTimeout(() => {
      document.addEventListener('click', handleClickOutside);
      document.addEventListener('contextmenu', handleClickOutside);
    }, 0);

    return () => {
      clearTimeout(timer);
      document.removeEventListener('click', handleClickOutside);
      document.removeEventListener('contextmenu', handleClickOutside);
    };
  }, [opened, setCurrentMenuId]);

  // å³ã‚¯ãƒªãƒƒã‚¯ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handleContextMenu = (e: React.MouseEvent) => {
    if (disabled) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«ç¾åœ¨ã®ãƒ¡ãƒ‹ãƒ¥ãƒ¼IDã‚’è¨­å®šï¼ˆä»–ã®ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‰ã˜ã‚‹ï¼‰
    setCurrentMenuId(menuIdRef.current);
    setPosition({ x: e.clientX, y: e.clientY });
    setOpened(true);
  };

  // ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handleDoubleClick = (e: React.MouseEvent) => {
    if (disabled || !enableDoubleClick) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    if (onAction && doubleClickAction) {
      onAction(doubleClickAction, entity);
    }
  };

  // ãƒ¢ãƒã‚¤ãƒ«å‘ã‘ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handleTouchEnd = (e: React.TouchEvent) => {
    if (disabled) return;

    const now = Date.now();
    const timeSinceLastTap = now - lastTapRef.current;

    if (timeSinceLastTap < 300 && timeSinceLastTap > 0) {
      // ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—æ¤œçŸ¥
      e.preventDefault();
      if (onAction && doubleClickAction && enableDoubleClick) {
        onAction(doubleClickAction, entity);
      }
      lastTapRef.current = 0;
    } else {
      lastTapRef.current = now;
    }
  };

  // é•·æŠ¼ã—ã§ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼ï¼ˆãƒ¢ãƒã‚¤ãƒ«ï¼‰
  const [longPressTimer, setLongPressTimer] = useState<NodeJS.Timeout | null>(null);

  const handleTouchStart = (e: React.TouchEvent) => {
    if (disabled) return;

    const touch = e.touches[0];
    const timer = setTimeout(() => {
      setPosition({ x: touch.clientX, y: touch.clientY });
      setOpened(true);
    }, 500); // 500msã®é•·æŠ¼ã—

    setLongPressTimer(timer);
  };

  const handleTouchMove = () => {
    if (longPressTimer) {
      clearTimeout(longPressTimer);
      setLongPressTimer(null);
    }
  };

  const handleTouchCancel = () => {
    if (longPressTimer) {
      clearTimeout(longPressTimer);
      setLongPressTimer(null);
    }
  };

  // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
  useEffect(() => {
    return () => {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
      }
    };
  }, [longPressTimer]);

  // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
  const handleActionClick = (action: string) => {
    setOpened(false);
    setCurrentMenuId(null);
    if (onAction) {
      onAction(action, entity);
    }
  };

  // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¨­å®šã‚’æ§‹ç¯‰
  const buildActionConfig = (action: ContextAction | string): ContextMenuAction => {
    if (typeof action === 'string' && action in defaultIcons) {
      const contextAction = action as ContextAction;
      return {
        action: contextAction,
        label: defaultLabels[contextAction],
        icon: defaultIcons[contextAction],
        color: defaultColors[contextAction],
      };
    }

    // ã‚«ã‚¹ã‚¿ãƒ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
    const customAction = customActions.find((a) => a.id === action);
    if (customAction) {
      return {
        action: customAction.id,
        label: customAction.label,
        icon: customAction.icon || <IconDots size={16} />,
        color: customAction.color,
      };
    }

    return {
      action,
      label: action,
      icon: <IconDots size={16} />,
    };
  };

  const actionConfigs = actions.map(buildActionConfig);

  // å­è¦ç´ ã«ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’è¿½åŠ 
  const childWithHandlers = isValidElement(children)
    ? cloneElement(children as React.ReactElement<React.HTMLAttributes<HTMLElement> & { ref?: React.Ref<HTMLElement> }>, {
        ref: containerRef,
        onContextMenu: handleContextMenu,
        onDoubleClick: handleDoubleClick,
        onTouchEnd: handleTouchEnd,
        onTouchStart: handleTouchStart,
        onTouchMove: handleTouchMove,
        onTouchCancel: handleTouchCancel,
        style: {
          ...((children as React.ReactElement<{ style?: React.CSSProperties }>).props.style || {}),
          cursor: disabled ? 'default' : 'context-menu',
          userSelect: 'none',
        },
      })
    : children;

  return (
    <>
      {childWithHandlers}

      {opened && (
        <Portal>
          <Menu
            opened={opened}
            onClose={() => {
              setOpened(false);
              setCurrentMenuId(null);
            }}
            position="right-start"
            withArrow
            shadow="md"
          >
            <Menu.Target>
              <div
                ref={menuRef}
                style={{
                  position: 'fixed',
                  left: position.x,
                  top: position.y,
                  width: 1,
                  height: 1,
                  pointerEvents: 'none',
                }}
              />
            </Menu.Target>
            <Menu.Dropdown data-menu-dropdown>
              <Menu.Label>
                {entityType ? `${entityType}ã®æ“ä½œ` : 'æ“ä½œ'}
              </Menu.Label>

              {actionConfigs.map((config, index) => {
                const customAction = customActions.find((a) => a.id === config.action);
                
                return (
                  <div key={config.action}>
                    {customAction?.divider && index > 0 && <Menu.Divider />}
                    <Menu.Item
                      leftSection={config.icon}
                      color={config.color}
                      disabled={config.disabled}
                      onClick={() => handleActionClick(config.action)}
                    >
                      {config.label}
                    </Menu.Item>
                  </div>
                );
              })}

              {customActions.length > 0 && actions.length > 0 && (
                <Menu.Divider />
              )}

              {customActions
                .filter((action) => !actions.includes(action.id))
                .map((action, index) => (
                  <div key={action.id}>
                    {action.divider && index > 0 && <Menu.Divider />}
                    <Menu.Item
                      leftSection={action.icon || <IconDots size={16} />}
                      color={action.color}
                      onClick={() => handleActionClick(action.id)}
                    >
                      {action.label}
                    </Menu.Item>
                  </div>
                ))}
            </Menu.Dropdown>
          </Menu>
        </Portal>
      )}
    </>
  );
}
````

## File: frontend/src/components/context-menu/index.ts
````typescript
export { ContextMenuProvider, ContextMenuManager } from './context-menu';
export type { ContextAction, CustomAction, ContextMenuAction } from './context-menu';

export { OperationModalManager } from './operation-modal-manager';
export type { OperationType } from './operation-modal-manager';

export { useContextMenu } from './use-context-menu';
export type { UseContextMenuReturn } from './use-context-menu';
````

## File: frontend/src/components/context-menu/use-context-menu.ts
````typescript
'use client';

import { useState, useCallback } from 'react';
import { OperationType } from './operation-modal-manager';

export interface UseContextMenuReturn<T = unknown> {
  currentOperation: OperationType | null;
  currentEntity: T | null;
  openOperation: (operation: OperationType, entity?: T) => void;
  closeOperation: () => void;
  handleAction: (action: string, entity?: T) => void;
}

export function useContextMenu<T = unknown>(
  customHandlers?: Partial<Record<string, (entity?: T) => void | Promise<void>>>
): UseContextMenuReturn<T> {
  const [currentOperation, setCurrentOperation] = useState<OperationType | null>(null);
  const [currentEntity, setCurrentEntity] = useState<T | null>(null);

  const openOperation = useCallback((operation: OperationType, entity?: T) => {
    setCurrentOperation(operation);
    setCurrentEntity(entity || null);
  }, []);

  const closeOperation = useCallback(() => {
    setCurrentOperation(null);
    setCurrentEntity(null);
  }, []);

  const handleAction = useCallback((action: string, entity?: T) => {
    // ã‚«ã‚¹ã‚¿ãƒ ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ãŒã‚ã‚Œã°å®Ÿè¡Œ
    if (customHandlers && action in customHandlers) {
      const handler = customHandlers[action];
      if (handler) {
        handler(entity);
        return;
      }
    }

    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æ“ä½œãƒãƒƒãƒ”ãƒ³ã‚°
    const operationMap: Record<string, OperationType> = {
      view: 'view',
      edit: 'edit',
      delete: 'delete',
      duplicate: 'duplicate',
      create: 'create',
    };

    const operation = operationMap[action];
    if (operation) {
      openOperation(operation, entity);
    } else {
      // ã‚«ã‚¹ã‚¿ãƒ æ“ä½œ
      openOperation('custom', entity);
    }
  }, [customHandlers, openOperation]);

  return {
    currentOperation,
    currentEntity,
    openOperation,
    closeOperation,
    handleAction,
  };
}
````

## File: frontend/src/components/dashboard/__tests__/DialNavigation.test.tsx
````typescript
import '@testing-library/jest-dom';

/**
 * DialNavigation ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ãƒ†ã‚¹ãƒˆ
 * ã‚¿ã‚¹ã‚¯1: é¸æŠä½ç½®ã‚’ä¸‹å´ä¸­å¤®ã«å¤‰æ›´ã—ãŸã“ã¨ã®æ¤œè¨¼
 */
describe('DialNavigation Component', () => {
  it('should be importable', async () => {
    // ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒæ­£ã—ãã‚¤ãƒ³ãƒãƒ¼ãƒˆã§ãã‚‹ã“ã¨ã‚’ç¢ºèª
    try {
      const dialNavigationModule = await import('../DialNavigation');
      expect(dialNavigationModule).toBeDefined();
      expect(dialNavigationModule.DialNavigation).toBeDefined();
    } catch (error) {
      expect(error).toBeDefined();
    }
  });

  it('should pass a basic smoke test', () => {
    // åŸºæœ¬çš„ãªå‹•ä½œç¢ºèª
    expect(true).toBe(true);
  });

  /**
   * è§’åº¦è¨ˆç®—ã®ãƒ­ã‚¸ãƒƒã‚¯æ¤œè¨¼
   * æ³¨: å®Ÿéš›ã®angleToIndexé–¢æ•°ã¯å†…éƒ¨é–¢æ•°ãªã®ã§ç›´æ¥ãƒ†ã‚¹ãƒˆã§ããªã„ãŒã€
   * ãƒ­ã‚¸ãƒƒã‚¯ã®æ­£ã—ã•ã‚’æ–‡æ›¸åŒ–ã™ã‚‹ãŸã‚ã®ãƒ†ã‚¹ãƒˆ
   */
  describe('Angle calculation logic (bottom-center selection)', () => {
    // æ­£è¦åŒ–é–¢æ•°ã®å†ç¾ï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰
    const normalizeAngle = (angle: number): number => {
      return ((angle % 360) + 360) % 360;
    };

    // angleToIndex ã®å†ç¾ï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰
    const angleToIndex = (angle: number, itemCount: number): number => {
      const step = 360 / itemCount;
      // ä¸‹å´ï¼ˆ6æ™‚æ–¹å‘ï¼‰ã‚’åŸºæº–ã«ã™ã‚‹ãŸã‚ã€180åº¦ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¿½åŠ 
      const normalized = normalizeAngle(-angle + 180);
      const rawIndex = Math.round(normalized / step) % itemCount;
      return rawIndex;
    };

    it('should calculate correct index for 8 items with bottom-center as reference', () => {
      // 8å€‹ã®ã‚¢ã‚¤ãƒ†ãƒ ã®å ´åˆã€45åº¦ã”ã¨ã«é…ç½®ã•ã‚Œã‚‹
      const itemCount = 8;

      // è§’åº¦0åº¦ï¼ˆå›è»¢ãªã—ï¼‰= ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹4ï¼ˆä¸‹å´ä¸­å¤®ã®ã‚¢ã‚¤ãƒ†ãƒ ï¼‰
      expect(angleToIndex(0, itemCount)).toBe(4);

      // è§’åº¦45åº¦å›è»¢ï¼ˆæ™‚è¨ˆå›ã‚Šï¼‰= ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹3ï¼ˆå³ã‹ã‚‰å·¦ã¸ç§»å‹•ï¼‰
      expect(angleToIndex(45, itemCount)).toBe(3);

      // è§’åº¦-45åº¦å›è»¢ï¼ˆåæ™‚è¨ˆå›ã‚Šï¼‰= ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹5ï¼ˆå·¦ã‹ã‚‰å³ã¸ç§»å‹•ï¼‰
      expect(angleToIndex(-45, itemCount)).toBe(5);

      // è§’åº¦180åº¦å›è»¢ = ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹0ï¼ˆä¸Šå´ã®ã‚¢ã‚¤ãƒ†ãƒ ãŒä¸‹ã«æ¥ã‚‹ï¼‰
      expect(angleToIndex(180, itemCount)).toBe(0);
    });

    it('should calculate correct index for 4 items with bottom-center as reference', () => {
      // 4å€‹ã®ã‚¢ã‚¤ãƒ†ãƒ ã®å ´åˆã€90åº¦ã”ã¨ã«é…ç½®ã•ã‚Œã‚‹
      const itemCount = 4;

      // è§’åº¦0åº¦ï¼ˆå›è»¢ãªã—ï¼‰= ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹2ï¼ˆä¸‹å´ä¸­å¤®ã®ã‚¢ã‚¤ãƒ†ãƒ ï¼‰
      expect(angleToIndex(0, itemCount)).toBe(2);

      // è§’åº¦90åº¦å›è»¢ï¼ˆæ™‚è¨ˆå›ã‚Šï¼‰= ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹1
      expect(angleToIndex(90, itemCount)).toBe(1);

      // è§’åº¦-90åº¦å›è»¢ï¼ˆåæ™‚è¨ˆå›ã‚Šï¼‰= ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹3
      expect(angleToIndex(-90, itemCount)).toBe(3);

      // è§’åº¦180åº¦å›è»¢ = ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹0ï¼ˆä¸Šå´ã®ã‚¢ã‚¤ãƒ†ãƒ ãŒä¸‹ã«æ¥ã‚‹ï¼‰
      expect(angleToIndex(180, itemCount)).toBe(0);
    });

    it('should handle 16 items correctly', () => {
      // æœ€å¤§16å€‹ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚µãƒãƒ¼ãƒˆ
      const itemCount = 16;

      // è§’åº¦0åº¦ï¼ˆå›è»¢ãªã—ï¼‰= ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹8ï¼ˆä¸‹å´ä¸­å¤®ã®ã‚¢ã‚¤ãƒ†ãƒ ï¼‰
      expect(angleToIndex(0, itemCount)).toBe(8);

      // å„ã‚¢ã‚¤ãƒ†ãƒ ã¯22.5åº¦ã”ã¨ã«é…ç½®ã•ã‚Œã‚‹
      expect(angleToIndex(22.5, itemCount)).toBe(7);
      expect(angleToIndex(-22.5, itemCount)).toBe(9);
    });
  });
});
````

## File: frontend/src/components/dashboard/DashboardCardSettings.tsx
````typescript
'use client';

import { useState } from 'react';
import {
  Modal,
  Stack,
  Group,
  Text,
  Switch,
  Button,
  Box,
  ThemeIcon,
  Card,
  ActionIcon,
  Paper,
} from '@mantine/core';
import { IconGripVertical, IconEye, IconEyeOff } from '@tabler/icons-react';
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  DragEndEvent,
} from '@dnd-kit/core';
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  useSortable,
  verticalListSortingStrategy,
} from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';

export interface DashboardCardConfig {
  id: string;
  title: string;
  description: string;
  icon: React.ReactNode;
  color: string;
  href: string;
  badge?: string | number;
  stats?: string;
  visible: boolean;
  order: number;
}

interface DashboardCardSettingsProps {
  opened: boolean;
  onClose: () => void;
  cards: DashboardCardConfig[];
  onSave: (cards: DashboardCardConfig[]) => void;
}

interface SortableCardItemProps {
  card: DashboardCardConfig;
  onToggle: (id: string) => void;
}

function SortableCardItem({ card, onToggle }: SortableCardItemProps) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id: card.id });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
  };

  return (
    <Paper
      ref={setNodeRef}
      style={style}
      p="md"
      withBorder
      radius="md"
      shadow={isDragging ? 'lg' : 'xs'}
    >
      <Group wrap="nowrap" gap="md">
        {/* ãƒ‰ãƒ©ãƒƒã‚°ãƒãƒ³ãƒ‰ãƒ« */}
        <ActionIcon
          {...attributes}
          {...listeners}
          variant="subtle"
          color="gray"
          style={{ cursor: 'grab', touchAction: 'none' }}
          size="lg"
        >
          <IconGripVertical size={20} />
        </ActionIcon>

        {/* ã‚¢ã‚¤ã‚³ãƒ³ */}
        <ThemeIcon
          size={48}
          radius="md"
          variant="light"
          color={card.color}
        >
          {card.icon}
        </ThemeIcon>

        {/* ã‚«ãƒ¼ãƒ‰æƒ…å ± */}
        <Box style={{ flex: 1, minWidth: 0 }}>
          <Text fw={600} size="sm" lineClamp={1}>
            {card.title}
          </Text>
          <Text size="xs" c="dimmed" lineClamp={1}>
            {card.description}
          </Text>
        </Box>

        {/* è¡¨ç¤º/éè¡¨ç¤ºã‚¹ã‚¤ãƒƒãƒ */}
        <Switch
          checked={card.visible}
          onChange={() => onToggle(card.id)}
          size="md"
          color={card.color}
          onLabel={<IconEye size={14} />}
          offLabel={<IconEyeOff size={14} />}
        />
      </Group>
    </Paper>
  );
}

export function DashboardCardSettings({
  opened,
  onClose,
  cards,
  onSave,
}: DashboardCardSettingsProps) {
  const [localCards, setLocalCards] = useState<DashboardCardConfig[]>(
    [...cards].sort((a, b) => a.order - b.order)
  );

  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8,
      },
    }),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event;

    if (over && active.id !== over.id) {
      setLocalCards((items) => {
        const oldIndex = items.findIndex((item) => item.id === active.id);
        const newIndex = items.findIndex((item) => item.id === over.id);
        
        const newItems = arrayMove(items, oldIndex, newIndex);
        
        // é †åºã‚’æ›´æ–°
        return newItems.map((item, index) => ({
          ...item,
          order: index,
        }));
      });
    }
  };

  const handleToggle = (id: string) => {
    setLocalCards((items) =>
      items.map((item) =>
        item.id === id ? { ...item, visible: !item.visible } : item
      )
    );
  };

  const handleSave = () => {
    onSave(localCards);
    onClose();
  };

  const handleReset = () => {
    setLocalCards([...cards].sort((a, b) => a.order - b.order));
  };

  const visibleCount = localCards.filter((card) => card.visible).length;

  return (
    <Modal
      opened={opened}
      onClose={onClose}
      title="ãƒ›ãƒ¼ãƒ ç”»é¢ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º"
      size="lg"
      centered
    >
      <Stack gap="lg">
        {/* èª¬æ˜ */}
        <Card p="md" withBorder bg="blue.0">
          <Stack gap="xs">
            <Text size="sm" fw={600}>
              ğŸ“± ã‚«ãƒ¼ãƒ‰ã®è¡¨ç¤ºã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º
            </Text>
            <Text size="xs" c="dimmed">
              â€¢ ã‚¹ã‚¤ãƒƒãƒã§ã‚«ãƒ¼ãƒ‰ã®è¡¨ç¤º/éè¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆ
            </Text>
            <Text size="xs" c="dimmed">
              â€¢ ãƒãƒ³ãƒ‰ãƒ«ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ä¸¦ã³é †ã‚’å¤‰æ›´
            </Text>
            <Text size="xs" c="dimmed">
              â€¢ è¨­å®šã¯è‡ªå‹•çš„ã«ä¿å­˜ã•ã‚Œã¾ã™
            </Text>
          </Stack>
        </Card>

        {/* è¡¨ç¤ºã‚«ãƒ¼ãƒ‰æ•° */}
        <Group justify="space-between">
          <Text size="sm" c="dimmed">
            è¡¨ç¤ºä¸­: <Text span fw={600} c="blue">{visibleCount}</Text> / {localCards.length} ä»¶
          </Text>
        </Group>

        {/* ã‚«ãƒ¼ãƒ‰ãƒªã‚¹ãƒˆ */}
        <Box style={{ maxHeight: '400px', overflowY: 'auto' }}>
          <DndContext
            sensors={sensors}
            collisionDetection={closestCenter}
            onDragEnd={handleDragEnd}
          >
            <SortableContext
              items={localCards.map((card) => card.id)}
              strategy={verticalListSortingStrategy}
            >
              <Stack gap="sm">
                {localCards.map((card) => (
                  <SortableCardItem
                    key={card.id}
                    card={card}
                    onToggle={handleToggle}
                  />
                ))}
              </Stack>
            </SortableContext>
          </DndContext>
        </Box>

        {/* ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ */}
        <Group justify="space-between">
          <Button
            variant="subtle"
            color="gray"
            onClick={handleReset}
          >
            ãƒªã‚»ãƒƒãƒˆ
          </Button>
          <Group gap="sm">
            <Button
              variant="light"
              onClick={onClose}
            >
              ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            </Button>
            <Button
              onClick={handleSave}
            >
              ä¿å­˜
            </Button>
          </Group>
        </Group>
      </Stack>
    </Modal>
  );
}
````

## File: frontend/src/components/dashboard/DialMenuSettings.tsx
````typescript
'use client';

import { useState } from 'react';
import {
  Modal,
  Stack,
  Group,
  Text,
  Switch,
  Button,
  Box,
  Card,
  ActionIcon,
  Paper,
} from '@mantine/core';
import { IconGripVertical, IconEye, IconEyeOff, IconRefresh } from '@tabler/icons-react';
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  DragEndEvent,
} from '@dnd-kit/core';
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  useSortable,
  verticalListSortingStrategy,
} from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import type { ReactNode } from 'react';

/**
 * ãƒ€ã‚¤ãƒ¤ãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›®ã®è¨­å®šå‹
 */
export interface DialMenuItemConfig {
  id: string;
  title: string;
  icon: ReactNode;
  color: string;
  href: string;
  badge?: string | number;
  subActions?: {
    id: string;
    title: string;
    icon: ReactNode;
    href: string;
  }[];
  visible: boolean;
  order: number;
}

interface DialMenuSettingsProps {
  opened: boolean;
  onClose: () => void;
  items: DialMenuItemConfig[];
  onSave: (items: DialMenuItemConfig[]) => void;
}

interface SortableMenuItemProps {
  item: DialMenuItemConfig;
  onToggle: (id: string) => void;
}

/**
 * ã‚½ãƒ¼ãƒˆå¯èƒ½ãªãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›®
 */
function SortableMenuItem({ item, onToggle }: SortableMenuItemProps) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id: item.id });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
  };

  return (
    <Paper
      ref={setNodeRef}
      style={style}
      p="md"
      withBorder
      radius="md"
      shadow={isDragging ? 'lg' : 'xs'}
    >
      <Group wrap="nowrap" gap="md">
        {/* ãƒ‰ãƒ©ãƒƒã‚°ãƒãƒ³ãƒ‰ãƒ« */}
        <ActionIcon
          {...attributes}
          {...listeners}
          variant="subtle"
          color="gray"
          style={{ cursor: 'grab', touchAction: 'none' }}
          size="lg"
        >
          <IconGripVertical size={20} />
        </ActionIcon>

        {/* ã‚¢ã‚¤ã‚³ãƒ³ã¨å…­è§’å½¢ã®èƒŒæ™¯ */}
        <Box
          style={{
            width: 48,
            height: 48,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            backgroundColor: item.visible ? item.color : '#E9ECEF',
            clipPath: 'polygon(25% 6.7%, 75% 6.7%, 100% 50%, 75% 93.3%, 25% 93.3%, 0% 50%)',
            color: item.visible ? '#FFFFFF' : '#868E96',
          }}
        >
          {item.icon}
        </Box>

        {/* ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›®æƒ…å ± */}
        <Box style={{ flex: 1, minWidth: 0 }}>
          <Text fw={600} size="sm" lineClamp={1}>
            {item.title}
          </Text>
          {item.subActions && item.subActions.length > 0 && (
            <Text size="xs" c="dimmed" lineClamp={1}>
              ã‚µãƒ–ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: {item.subActions.length}ä»¶
            </Text>
          )}
        </Box>

        {/* è¡¨ç¤º/éè¡¨ç¤ºã‚¹ã‚¤ãƒƒãƒ */}
        <Switch
          checked={item.visible}
          onChange={() => onToggle(item.id)}
          size="md"
          color={item.color}
          onLabel={<IconEye size={14} />}
          offLabel={<IconEyeOff size={14} />}
        />
      </Group>
    </Paper>
  );
}

/**
 * ãƒ€ã‚¤ãƒ¤ãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ«
 */
export function DialMenuSettings({
  opened,
  onClose,
  items,
  onSave,
}: DialMenuSettingsProps) {
  const [localItems, setLocalItems] = useState<DialMenuItemConfig[]>(
    [...items].sort((a, b) => a.order - b.order)
  );

  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8,
      },
    }),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event;

    if (over && active.id !== over.id) {
      setLocalItems((currentItems) => {
        const oldIndex = currentItems.findIndex((item) => item.id === active.id);
        const newIndex = currentItems.findIndex((item) => item.id === over.id);
        
        const newItems = arrayMove(currentItems, oldIndex, newIndex);
        
        // é †åºã‚’æ›´æ–°
        return newItems.map((item, index) => ({
          ...item,
          order: index,
        }));
      });
    }
  };

  const handleToggle = (id: string) => {
    setLocalItems((currentItems) =>
      currentItems.map((item) =>
        item.id === id ? { ...item, visible: !item.visible } : item
      )
    );
  };

  const handleSave = () => {
    onSave(localItems);
    onClose();
  };

  const handleReset = () => {
    setLocalItems([...items].sort((a, b) => a.order - b.order));
  };

  const visibleCount = localItems.filter((item) => item.visible).length;
  const hasChanges = JSON.stringify(localItems) !== JSON.stringify([...items].sort((a, b) => a.order - b.order));

  return (
    <Modal
      opened={opened}
      onClose={onClose}
      title="ãƒ€ã‚¤ãƒ¤ãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®ç·¨é›†"
      size="lg"
      centered
    >
      <Stack gap="lg">
        {/* èª¬æ˜ */}
        <Card p="md" withBorder bg="blue.0">
          <Stack gap="xs">
            <Text size="sm" fw={600}>
              ğŸ¯ ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›®ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º
            </Text>
            <Text size="xs" c="dimmed">
              â€¢ ã‚¹ã‚¤ãƒƒãƒã§é …ç›®ã®è¡¨ç¤º/éè¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆ
            </Text>
            <Text size="xs" c="dimmed">
              â€¢ ãƒãƒ³ãƒ‰ãƒ«ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ä¸¦ã³é †ã‚’å¤‰æ›´
            </Text>
            <Text size="xs" c="dimmed">
              â€¢ æœ€å¤§16é …ç›®ã¾ã§å¯¾å¿œã—ã¦ã„ã¾ã™
            </Text>
          </Stack>
        </Card>

        {/* è¡¨ç¤ºé …ç›®æ•° */}
        <Group justify="space-between">
          <Text size="sm" c="dimmed">
            è¡¨ç¤ºä¸­: <Text span fw={600} c="blue">{visibleCount}</Text> / {localItems.length} ä»¶
          </Text>
          {hasChanges && (
            <Text size="xs" c="orange" fw={600}>
              æœªä¿å­˜ã®å¤‰æ›´ãŒã‚ã‚Šã¾ã™
            </Text>
          )}
        </Group>

        {/* ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›®ãƒªã‚¹ãƒˆ */}
        <Box style={{ maxHeight: '400px', overflowY: 'auto' }}>
          <DndContext
            sensors={sensors}
            collisionDetection={closestCenter}
            onDragEnd={handleDragEnd}
          >
            <SortableContext
              items={localItems.map((item) => item.id)}
              strategy={verticalListSortingStrategy}
            >
              <Stack gap="sm">
                {localItems.map((item) => (
                  <SortableMenuItem
                    key={item.id}
                    item={item}
                    onToggle={handleToggle}
                  />
                ))}
              </Stack>
            </SortableContext>
          </DndContext>
        </Box>

        {/* ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ */}
        <Group justify="space-between">
          <Button
            variant="subtle"
            color="gray"
            leftSection={<IconRefresh size={16} />}
            onClick={handleReset}
            disabled={!hasChanges}
          >
            ãƒªã‚»ãƒƒãƒˆ
          </Button>
          <Group gap="sm">
            <Button
              variant="default"
              onClick={onClose}
            >
              ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            </Button>
            <Button
              onClick={handleSave}
              disabled={!hasChanges || visibleCount === 0}
            >
              ä¿å­˜
            </Button>
          </Group>
        </Group>
      </Stack>
    </Modal>
  );
}
````

## File: frontend/src/components/dashboard/DialMenuV2.module.css
````css
.container {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px;
  touch-action: none;
  user-select: none;
}

.dial {
  position: relative;
  width: 320px;
  height: 320px;
  border-radius: 50%;
  background: linear-gradient(
    145deg,
    var(--mantine-color-gray-0),
    var(--mantine-color-gray-2)
  );
  box-shadow:
    0 8px 32px rgba(0, 0, 0, 0.12),
    inset 0 2px 4px rgba(255, 255, 255, 0.9),
    inset 0 -2px 4px rgba(0, 0, 0, 0.05);
}

:global([data-mantine-color-scheme='dark']) .dial {
  background: linear-gradient(
    145deg,
    var(--mantine-color-dark-5),
    var(--mantine-color-dark-7)
  );
  box-shadow:
    0 8px 32px rgba(0, 0, 0, 0.4),
    inset 0 2px 4px rgba(255, 255, 255, 0.05),
    inset 0 -2px 4px rgba(0, 0, 0, 0.3);
}

/* å¤–å´ãƒªãƒ³ã‚°: ãƒ‘ãƒ¼ã‚½ãƒŠãƒ«é …ç›® */
.outerRing {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
}

.personalItem {
  position: absolute;
  cursor: pointer;
  transition: transform 0.2s ease, opacity 0.2s ease;
  opacity: 0.7;
  transform-origin: center;

  &:hover {
    opacity: 1;
    transform: scale(1.15) !important;
  }

  &:active {
    transform: scale(0.95) !important;
  }
}

/* ãƒ¡ã‚¤ãƒ³ãƒªãƒ³ã‚°: æ¥­å‹™é …ç›® */
.ring {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  transition: transform 0.15s ease-out;
}

.ringItem {
  position: absolute;
  /* CSSå¤‰æ•°ã§è§’åº¦ã‚’å—ã‘å–ã‚Šã€é…ç½® */
  transform: rotate(var(--item-angle)) translateY(-95px);
  cursor: pointer;
}

.ringItemInner {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  transition: transform 0.15s ease-out;
}

.ringIcon {
  transition: all 0.2s ease;
  box-shadow: 0 3px 12px rgba(0, 0, 0, 0.15);
}

.ringItem.focused .ringIcon {
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
}

.ringItem:not(.focused):hover .ringIcon {
  transform: scale(1.1);
}

.ringItem:active .ringIcon {
  transform: scale(0.95);
}

.badge {
  position: absolute;
  top: -4px;
  right: -4px;
  min-width: 18px;
  height: 18px;
  padding: 0 5px;
  font-size: 10px;
  z-index: 1;
}

.ringLabel {
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  margin-top: 4px;
  white-space: nowrap;
  background: var(--mantine-color-white);
  padding: 2px 8px;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

:global([data-mantine-color-scheme='dark']) .ringLabel {
  background: var(--mantine-color-dark-5);
}

/* ä¸­å¤®ã‚¨ãƒªã‚¢ */
.center {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 100px;
  height: 100px;
  border-radius: 50%;
  background: var(--mantine-color-white);
  box-shadow:
    0 4px 16px rgba(0, 0, 0, 0.1),
    inset 0 1px 2px rgba(255, 255, 255, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
}

:global([data-mantine-color-scheme='dark']) .center {
  background: var(--mantine-color-dark-4);
  box-shadow:
    0 4px 16px rgba(0, 0, 0, 0.3),
    inset 0 1px 2px rgba(255, 255, 255, 0.05);
}

.centerMain {
  cursor: pointer;
  transition: transform 0.2s ease;

  &:hover {
    transform: scale(1.1);
  }

  &:active {
    transform: scale(0.95);
  }
}

.subItem {
  cursor: pointer;
  transition: transform 0.2s ease;
  z-index: 1;

  &:hover {
    transform: scale(1.15) !important;
  }

  &:active {
    transform: scale(0.9) !important;
  }
}

/* ä¸Šéƒ¨ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ */
.indicator {
  position: absolute;
  top: 4px;
  left: 50%;
  transform: translateX(-50%);
  width: 0;
  height: 0;
  border-left: 8px solid transparent;
  border-right: 8px solid transparent;
  border-top: 12px solid var(--mantine-color-blue-5);
  filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
  z-index: 20;
}

/* ã‚¿ãƒƒãƒãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ */
.dial:active {
  cursor: grabbing;
}
````

## File: frontend/src/components/dashboard/DialNavigation.tsx
````typescript
'use client';

import { useState, useRef, useCallback, useEffect, type ReactNode } from 'react';
import { motion, useMotionValue, useSpring, AnimatePresence } from 'framer-motion';
import { Box, Text, ActionIcon, Tooltip, Button, ScrollArea, SegmentedControl } from '@mantine/core';
import { IconCat, IconSettings, IconCheck, IconX, IconPlus } from '@tabler/icons-react';
import { HexIconButton } from './HexIconButton';
import {
  DndContext,
  DragOverlay,
  closestCenter,
  PointerSensor,
  useSensor,
  useSensors,
  type DragStartEvent,
  type DragEndEvent,
} from '@dnd-kit/core';
import {
  SortableContext,
  useSortable,
  arrayMove,
  rectSortingStrategy,
} from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import {
  type DialSizePreset,
  DIAL_SIZE_PRESETS,
  DIAL_SIZE_PRESET_LABELS,
} from '@/lib/storage/dashboard-settings';

// ============================================
// å‹å®šç¾©
// ============================================

/** ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›® */
export interface DialItem {
  id: string;
  title: string;
  icon: ReactNode;
  color: string;
  href: string;
  badge?: string | number;
  subActions?: {
    id: string;
    title: string;
    icon: ReactNode;
    href: string;
  }[];
}

/** ç·¨é›†å¯èƒ½ãªãƒ€ã‚¤ã‚¢ãƒ«é …ç›®ï¼ˆè¡¨ç¤º/éè¡¨ç¤ºæƒ…å ±ä»˜ãï¼‰ */
export interface EditableDialItem extends DialItem {
  visible: boolean;
  order: number;
}

interface DialNavigationProps {
  items: DialItem[];
  onNavigate: (href: string) => void;
  centerLogo?: ReactNode;
  onSettingsClick?: () => void;
  /** ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ç”¨: å…¨ã‚¢ã‚¤ãƒ†ãƒ ï¼ˆéè¡¨ç¤ºå«ã‚€ï¼‰ */
  allItems?: EditableDialItem[];
  /** ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ç”¨: ã‚¢ã‚¤ãƒ†ãƒ å¤‰æ›´æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
  onItemsChange?: (items: EditableDialItem[]) => void;
  /** ã‚µã‚¤ã‚ºãƒ—ãƒªã‚»ãƒƒãƒˆ */
  sizePreset?: DialSizePreset;
  /** ã‚µã‚¤ã‚ºãƒ—ãƒªã‚»ãƒƒãƒˆå¤‰æ›´æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
  onSizePresetChange?: (preset: DialSizePreset) => void;
}

// ============================================
// ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆï¼ˆçµ±ä¸€ï¼‰
// ============================================

const COLORS = {
  primary: '#2563EB',        // ãƒ¡ã‚¤ãƒ³ãƒ–ãƒ«ãƒ¼
  primaryLight: 'rgba(37, 99, 235, 0.10)',
  primaryMedium: 'rgba(37, 99, 235, 0.15)',
  secondary: '#22C55E',      // ã‚°ãƒªãƒ¼ãƒ³
  accent: '#F97316',         // ã‚ªãƒ¬ãƒ³ã‚¸
  text: '#111827',           // ãƒ¡ã‚¤ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
  textMuted: '#6B7280',      // ã‚µãƒ–ãƒ†ã‚­ã‚¹ãƒˆ
  background: '#FFFFFF',
  backgroundGradientStart: '#F8FAFC',
  backgroundGradientEnd: '#F1F5F9',
  border: '#E5E7EB',
  shadow: 'rgba(15, 23, 42, 0.12)',
  // ãƒªãƒ³ã‚°ç”¨ã®ã‚«ãƒ©ãƒ¼
  ringTrack: 'rgba(37, 99, 235, 0.06)',  // ãƒªãƒ³ã‚°ã®è»Œé“
  ringBorder: 'rgba(37, 99, 235, 0.15)', // ãƒªãƒ³ã‚°å¢ƒç•Œç·š
};

// ============================================
// ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ç”¨ã®å›ºå®šã‚µã‚¤ã‚ºï¼ˆmediumãƒ—ãƒªã‚»ãƒƒãƒˆï¼‰
// ============================================

const EDIT_MODE_ICON_SIZE = 48;  // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã§ã®ã‚¢ã‚¤ã‚³ãƒ³ã‚µã‚¤ã‚º

// ============================================
// ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
// ============================================

/**
 * å††è»Œé“ä¸Šã®åº§æ¨™ã‚’è¨ˆç®—
 * @param index ã‚¢ã‚¤ãƒ†ãƒ ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
 * @param totalItems å…¨ã‚¢ã‚¤ãƒ†ãƒ æ•°
 * @param centerX ä¸­å¿ƒXåº§æ¨™
 * @param centerY ä¸­å¿ƒYåº§æ¨™
 * @param radius è»Œé“åŠå¾„
 * @returns {x, y} åº§æ¨™
 */
const getCirclePosition = (
  index: number,
  totalItems: number,
  centerX: number,
  centerY: number,
  radius: number
): { x: number; y: number } => {
  // ä¸‹ï¼ˆ6æ™‚æ–¹å‘ï¼‰ã‚’0ç•ªç›®ã®åŸºæº–ä½ç½®ã«ã™ã‚‹
  // ã“ã‚Œã«ã‚ˆã‚Šã€åˆæœŸçŠ¶æ…‹ã§index=0ãŒ6æ™‚ä½ç½®ã«æ¥ã‚‹
  const angleOffset = Math.PI / 2; // +90åº¦ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆä¸‹ã‚’åŸºæº–ï¼‰
  const angle = (index / totalItems) * 2 * Math.PI + angleOffset;
  return {
    x: centerX + radius * Math.cos(angle),
    y: centerY + radius * Math.sin(angle),
  };
};

/** è§’åº¦ã‚’0-360ã«æ­£è¦åŒ– */
const normalizeAngle = (angle: number): number => {
  return ((angle % 360) + 360) % 360;
};

/** æœ€ã‚‚è¿‘ã„ã‚¹ãƒŠãƒƒãƒ—è§’åº¦ã‚’è¨ˆç®— */
const getSnapAngle = (currentAngle: number, itemCount: number): number => {
  const step = 360 / itemCount;
  const normalized = normalizeAngle(currentAngle);
  const snappedNormalized = Math.round(normalized / step) * step;
  const fullRotations = Math.floor(currentAngle / 360) * 360;
  return fullRotations + snappedNormalized;
};

/** 
 * è§’åº¦ã‹ã‚‰ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—ï¼ˆä¸‹=6æ™‚ä½ç½®ãŒé¸æŠä½ç½®ï¼‰
 * 
 * é…ç½®: index=0ãŒ6æ™‚ä½ç½®ã€æ™‚è¨ˆå›ã‚Šã«indexãŒå¢—ãˆã‚‹
 * å›è»¢: displayRotationãŒæ­£ã®æ™‚ã€ãƒªãƒ³ã‚°ãŒæ™‚è¨ˆå›ã‚Šã«å›è»¢
 * 
 * ã¤ã¾ã‚Š:
 * - rotation=0: index=0ãŒ6æ™‚ä½ç½®
 * - rotation=+step: ãƒªãƒ³ã‚°ãŒæ™‚è¨ˆå›ã‚Šã«å›è»¢ã€index=0ã¯å³ä¸‹ã¸ã€
 *                   index=(n-1)ãŒ6æ™‚ä½ç½®ã«æ¥ã‚‹
 */
const angleToIndex = (angle: number, itemCount: number): number => {
  const step = 360 / itemCount;
  const normalized = normalizeAngle(-angle); // è² ã«ã™ã‚‹ã“ã¨ã§å›è»¢æ–¹å‘ã‚’åè»¢
  const rawIndex = Math.round(normalized / step) % itemCount;
  return rawIndex;
};

// ============================================
// ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ç”¨ã‚µãƒ–ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
// ============================================

/** ãƒ•ãƒƒã‚¿ãƒ¼ã®ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½ãªã‚¢ã‚¤ã‚³ãƒ³ */
function DraggableFooterIcon({ item }: { item: EditableDialItem }) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ 
    id: `footer-${item.id}`,
    data: { type: 'footer', item },
  });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      {...attributes}
      {...listeners}
    >
      <div
        style={{
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          gap: 4,
          padding: 8,
          cursor: 'grab',
        }}
      >
        <HexIconButton
          size={40}
          selected={false}
          hovered={false}
          color={item.color}
        >
          {item.icon}
        </HexIconButton>
        <Text size="xs" c="dimmed" lineClamp={1} style={{ maxWidth: 56 }}>
          {item.title}
        </Text>
      </div>
    </div>
  );
}

/** ãƒ€ã‚¤ã‚¢ãƒ«ä¸Šã®ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½ãªã‚¢ã‚¤ã‚³ãƒ³ */
function SortableDialIcon({ 
  item, 
  position,
  rotation,
  isSelected,
  onRemove,
}: { 
  item: DialItem; 
  position: { x: number; y: number };
  rotation: number;
  isSelected: boolean;
  onRemove: () => void;
}) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ 
    id: `dial-${item.id}`,
    data: { type: 'dial', item },
  });

  const style = {
    position: 'absolute' as const,
    left: position.x,
    top: position.y,
    transform: `translate(-50%, -50%) ${CSS.Transform.toString(transform) || ''}`,
    transition,
    opacity: isDragging ? 0.5 : 1,
    zIndex: isDragging ? 100 : isSelected ? 2 : 1,
  };

  return (
    <div ref={setNodeRef} style={style}>
      <div
        {...attributes}
        {...listeners}
        style={{ cursor: 'grab', position: 'relative' }}
      >
        <motion.div
          style={{ transformOrigin: '50% 50%' }}
          animate={{ rotate: -rotation }}
        >
          <HexIconButton
            size={EDIT_MODE_ICON_SIZE}
            selected={isSelected}
            hovered={false}
            color={item.color}
            badge={item.badge}
          >
            {item.icon}
          </HexIconButton>
        </motion.div>
        {/* å‰Šé™¤ãƒœã‚¿ãƒ³ */}
        <ActionIcon
          size="xs"
          color="red"
          variant="filled"
          radius="xl"
          style={{
            position: 'absolute',
            top: -6,
            right: -6,
            zIndex: 10,
          }}
          onClick={(e) => {
            e.stopPropagation();
            onRemove();
          }}
        >
          <IconX size={10} />
        </ActionIcon>
      </div>
    </div>
  );
}

// ============================================
// DialNavigation: ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
// ============================================

export function DialNavigation({ 
  items, 
  onNavigate, 
  centerLogo, 
  onSettingsClick,
  allItems,
  onItemsChange,
  sizePreset = 'medium',
  onSizePresetChange,
}: DialNavigationProps) {
  // ã‚µã‚¤ã‚ºè¨­å®šã‚’å–å¾—
  const sizeConfig = DIAL_SIZE_PRESETS[sizePreset];
  const {
    dialSize: DIAL_SIZE,
    centerSize: CENTER_SIZE,
    iconButtonSize: ICON_BUTTON_SIZE,
    iconOrbitRadius: ICON_ORBIT_RADIUS,
    subRadius: SUB_RADIUS,
  } = sizeConfig;

  // å›è»¢è§’åº¦ï¼ˆç”Ÿã®å€¤ï¼‰
  const rotationValue = useMotionValue(0);
  // ã‚¹ãƒ—ãƒªãƒ³ã‚°ã§æ»‘ã‚‰ã‹ã«ï¼ˆãƒã‚¦ãƒ³ã‚¹åŠ¹æœã®ãŸã‚dampingä½ã‚ï¼‰
  const smoothRotation = useSpring(rotationValue, {
    stiffness: 120,
    damping: 18,  // ä½ã‚ã§ãƒã‚¦ãƒ³ã‚¹åŠ¹æœ
    mass: 0.5,
  });
  
  // è¡¨ç¤ºç”¨ã®å›è»¢è§’åº¦
  const [displayRotation, setDisplayRotation] = useState(0);
  // é¸æŠä¸­ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
  const [selectedIndex, setSelectedIndex] = useState(0);
  // ã‚µãƒ–ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å±•é–‹çŠ¶æ…‹
  const [isSubExpanded, setIsSubExpanded] = useState(false);
  // ãƒ‰ãƒ©ãƒƒã‚°çŠ¶æ…‹ï¼ˆãƒ€ã‚¤ã‚¢ãƒ«å›è»¢ç”¨ï¼‰
  const [isDragging, setIsDragging] = useState(false);
  // ãƒ›ãƒãƒ¼çŠ¶æ…‹
  const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);
  
  // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ state
  const [isEditMode, setIsEditMode] = useState(false);
  const [editItems, setEditItems] = useState<EditableDialItem[]>([]);
  const [draggedItem, setDraggedItem] = useState<EditableDialItem | null>(null);
  
  // dnd-kit ã‚»ãƒ³ã‚µãƒ¼è¨­å®š
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8,
      },
    })
  );
  
  const containerRef = useRef<HTMLDivElement>(null);
  const dragStartRef = useRef({ angle: 0, rotation: 0 });
  const velocityRef = useRef(0);
  const lastAngleRef = useRef(0);
  const lastTimeRef = useRef(0);

  const anglePerItem = 360 / items.length;
  const radius = DIAL_SIZE / 2;

  // smoothRotation ã®å¤‰æ›´ã‚’ç›£è¦–
  useEffect(() => {
    const unsubscribe = smoothRotation.on('change', (value) => {
      setDisplayRotation(value);
      setSelectedIndex(angleToIndex(value, items.length));
    });
    return unsubscribe;
  }, [smoothRotation, items.length]);

  // ä¸­å¿ƒåº§æ¨™ã‚’å–å¾—
  const getCenter = useCallback(() => {
    if (!containerRef.current) return { x: 0, y: 0 };
    const rect = containerRef.current.getBoundingClientRect();
    return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
  }, []);

  // åº§æ¨™ã‹ã‚‰è§’åº¦ã‚’è¨ˆç®—ï¼ˆä¸Š=0åº¦ã€æ™‚è¨ˆå›ã‚Šæ­£ï¼‰
  const getAngleFromPoint = useCallback((clientX: number, clientY: number) => {
    const center = getCenter();
    const dx = clientX - center.x;
    const dy = clientY - center.y;
    return Math.atan2(dx, -dy) * (180 / Math.PI);
  }, [getCenter]);

  // ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹
  const handlePointerDown = useCallback((e: React.PointerEvent) => {
    const target = e.target as HTMLElement;
    if (target.closest('[data-center]') || target.closest('[data-sub-item]')) {
      return;
    }

    setIsDragging(true);
    setIsSubExpanded(false);
    
    const angle = getAngleFromPoint(e.clientX, e.clientY);
    dragStartRef.current = { angle, rotation: rotationValue.get() };
    lastAngleRef.current = angle;
    lastTimeRef.current = Date.now();
    velocityRef.current = 0;

    target.setPointerCapture(e.pointerId);
  }, [getAngleFromPoint, rotationValue]);

  // ãƒ‰ãƒ©ãƒƒã‚°ä¸­
  const handlePointerMove = useCallback((e: React.PointerEvent) => {
    if (!isDragging) return;

    const currentAngle = getAngleFromPoint(e.clientX, e.clientY);
    const deltaAngle = currentAngle - dragStartRef.current.angle;
    const newRotation = dragStartRef.current.rotation + deltaAngle;

    const now = Date.now();
    const dt = now - lastTimeRef.current;
    if (dt > 0) {
      velocityRef.current = (currentAngle - lastAngleRef.current) / dt * 16;
    }
    lastAngleRef.current = currentAngle;
    lastTimeRef.current = now;

    rotationValue.set(newRotation);
  }, [isDragging, getAngleFromPoint, rotationValue]);

  // ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†
  const handlePointerUp = useCallback((e: React.PointerEvent) => {
    if (!isDragging) return;
    setIsDragging(false);

    (e.target as HTMLElement).releasePointerCapture(e.pointerId);

    const currentRotation = rotationValue.get();
    const velocity = velocityRef.current;
    const inertiaRotation = velocity * 8;
    const targetRotation = currentRotation + inertiaRotation;
    const snapAngle = getSnapAngle(targetRotation, items.length);

    rotationValue.set(snapAngle);
  }, [isDragging, rotationValue, items.length]);

  // ãƒ›ã‚¤ãƒ¼ãƒ«æ“ä½œ
  const handleWheel = useCallback((e: React.WheelEvent) => {
    e.preventDefault();
    setIsSubExpanded(false);

    const direction = e.deltaY > 0 ? 1 : -1;
    const currentRotation = rotationValue.get();
    const targetRotation = currentRotation + direction * anglePerItem;
    const snapAngle = getSnapAngle(targetRotation, items.length);

    rotationValue.set(snapAngle);
  }, [rotationValue, anglePerItem, items.length]);

  // ã‚¢ã‚¤ãƒ†ãƒ ã‚¯ãƒªãƒƒã‚¯
  // é¸æŠä¸­ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚¿ãƒƒãƒ— â†’ å³åº§ã«é·ç§»ï¼ˆã‚µãƒ–ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¯ä¸­å¤®ã‹ã‚‰å±•é–‹ï¼‰
  // éé¸æŠã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚¿ãƒƒãƒ— â†’ ãã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’6æ™‚ä½ç½®ã«ç§»å‹•
  const handleItemClick = useCallback((index: number) => {
    if (index === selectedIndex) {
      // é¸æŠä¸­ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚¿ãƒƒãƒ—ã—ãŸã‚‰å³åº§ã«é·ç§»
      const item = items[selectedIndex];
      setIsSubExpanded(false);
      onNavigate(item.href);
    } else {
      setIsSubExpanded(false);
      // indexç•ªç›®ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’6æ™‚ä½ç½®ã«æŒã£ã¦ãã‚‹
      // å›è»¢ã¯è² ã®æ–¹å‘ï¼ˆåæ™‚è¨ˆå›ã‚Šï¼‰ã§indexãŒå¢—ãˆã‚‹æ–¹å‘
      const targetRotation = -index * anglePerItem;
      
      // æœ€çŸ­çµŒè·¯ã§å›è»¢
      const currentRotation = rotationValue.get();
      const currentNormalized = normalizeAngle(currentRotation);
      const targetNormalized = normalizeAngle(targetRotation);
      
      let delta = targetNormalized - currentNormalized;
      if (delta > 180) delta -= 360;
      if (delta < -180) delta += 360;

      rotationValue.set(currentRotation + delta);
    }
  }, [selectedIndex, items, rotationValue, anglePerItem, onNavigate]);

  // ä¸­å¤®ã‚¯ãƒªãƒƒã‚¯
  const handleCenterClick = useCallback(() => {
    const item = items[selectedIndex];
    if (isSubExpanded) {
      onNavigate(item.href);
    } else if (item.subActions && item.subActions.length > 0) {
      setIsSubExpanded(true);
    } else {
      onNavigate(item.href);
    }
  }, [items, selectedIndex, isSubExpanded, onNavigate]);

  // ã‚µãƒ–ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¯ãƒªãƒƒã‚¯
  const handleSubActionClick = useCallback((href: string) => {
    setIsSubExpanded(false);
    onNavigate(href);
  }, [onNavigate]);

  const selectedItem = items[selectedIndex];
  const subActions = selectedItem?.subActions ?? [];
  const subCount = subActions.length;
  const spreadAngle = Math.min(120, subCount * 40); // å±•é–‹è§’åº¦ã‚’ç‹­ã
  const subStartAngle = 90 - spreadAngle / 2; // ä¸‹å‘ãï¼ˆ90åº¦ï¼‰ã‚’åŸºæº–ã«å±•é–‹

  // ============================================
  // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰é–¢é€£ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  // ============================================

  // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰é–‹å§‹
  const handleStartEdit = useCallback(() => {
    if (allItems) {
      setEditItems([...allItems]);
      setIsEditMode(true);
    }
  }, [allItems]);

  // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰çµ‚äº†ï¼ˆä¿å­˜ï¼‰
  const handleSaveEdit = useCallback(() => {
    if (onItemsChange) {
      onItemsChange(editItems);
    }
    setIsEditMode(false);
  }, [editItems, onItemsChange]);

  // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã‚­ãƒ£ãƒ³ã‚»ãƒ«
  const handleCancelEdit = useCallback(() => {
    setIsEditMode(false);
    setEditItems([]);
  }, []);

  // ãƒ€ã‚¤ã‚¢ãƒ«ã«è¡¨ç¤ºä¸­ã®ã‚¢ã‚¤ãƒ†ãƒ ï¼ˆç·¨é›†ãƒ¢ãƒ¼ãƒ‰ç”¨ï¼‰
  const visibleEditItems = editItems.filter((item) => item.visible);
  // ãƒ•ãƒƒã‚¿ãƒ¼ã«è¡¨ç¤ºã™ã‚‹ã‚¢ã‚¤ãƒ†ãƒ ï¼ˆéè¡¨ç¤ºã®ã‚‚ã®ï¼‰
  const hiddenEditItems = editItems.filter((item) => !item.visible);

  // dnd-kit: ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹
  const handleDragStart = useCallback((event: DragStartEvent) => {
    const { active } = event;
    const itemId = String(active.id).replace(/^(footer-|dial-)/, '');
    const item = editItems.find((i) => i.id === itemId);
    if (item) {
      setDraggedItem(item);
    }
  }, [editItems]);

  // dnd-kit: ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†
  const handleDragEnd = useCallback((event: DragEndEvent) => {
    const { active, over } = event;
    setDraggedItem(null);

    if (!over) return;

    const activeId = String(active.id);
    const overId = String(over.id);
    const activeType = activeId.startsWith('footer-') ? 'footer' : 'dial';
    const overType = overId.startsWith('footer-') ? 'footer' : overId === 'dial-drop-zone' ? 'dial-zone' : 'dial';

    const activeItemId = activeId.replace(/^(footer-|dial-)/, '');
    const overItemId = overId.replace(/^(footer-|dial-)/, '');

    setEditItems((current) => {
      const newItems = [...current];
      const activeIndex = newItems.findIndex((i) => i.id === activeItemId);

      if (activeIndex === -1) return current;

      // ãƒ•ãƒƒã‚¿ãƒ¼â†’ãƒ€ã‚¤ã‚¢ãƒ«ã‚¾ãƒ¼ãƒ³: è¡¨ç¤ºã«åˆ‡ã‚Šæ›¿ãˆ
      if (activeType === 'footer' && (overType === 'dial-zone' || overType === 'dial')) {
        newItems[activeIndex] = { ...newItems[activeIndex], visible: true };
        // é †åºã‚’æ›´æ–°
        const visibleItems = newItems.filter((i) => i.visible);
        visibleItems.forEach((item, idx) => {
          const itemIndex = newItems.findIndex((i) => i.id === item.id);
          if (itemIndex !== -1) {
            newItems[itemIndex] = { ...newItems[itemIndex], order: idx };
          }
        });
        return newItems;
      }

      // ãƒ€ã‚¤ã‚¢ãƒ«å†…ã®ä¸¦ã¹æ›¿ãˆ
      if (activeType === 'dial' && overType === 'dial' && activeId !== overId) {
        const overIndex = newItems.findIndex((i) => i.id === overItemId);
        if (overIndex === -1) return current;

        const result = arrayMove(newItems, activeIndex, overIndex);
        // é †åºã‚’æ›´æ–°
        result.forEach((item, idx) => {
          result[idx] = { ...item, order: idx };
        });
        return result;
      }

      return current;
    });
  }, []);

  // ã‚¢ã‚¤ãƒ†ãƒ ã‚’ãƒ€ã‚¤ã‚¢ãƒ«ã‹ã‚‰å‰Šé™¤ï¼ˆãƒ•ãƒƒã‚¿ãƒ¼ã¸ç§»å‹•ï¼‰
  const handleRemoveFromDial = useCallback((itemId: string) => {
    setEditItems((current) => {
      const newItems = current.map((item) =>
        item.id === itemId ? { ...item, visible: false } : item
      );
      // é †åºã‚’æ›´æ–°
      const visibleItems = newItems.filter((i) => i.visible);
      visibleItems.forEach((item, idx) => {
        const itemIndex = newItems.findIndex((i) => i.id === item.id);
        if (itemIndex !== -1) {
          newItems[itemIndex] = { ...newItems[itemIndex], order: idx };
        }
      });
      return newItems;
    });
  }, []);

  // ============================================
  // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
  // ============================================

  // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
  if (isEditMode) {
    return (
      <DndContext
        sensors={sensors}
        collisionDetection={closestCenter}
        onDragStart={handleDragStart}
        onDragEnd={handleDragEnd}
      >
        <Box
          style={{
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            padding: 20,
            gap: 16,
            background: `linear-gradient(180deg, ${COLORS.backgroundGradientStart} 0%, ${COLORS.backgroundGradientEnd} 100%)`,
            minHeight: 400,
            borderRadius: 16,
            position: 'relative',
          }}
        >
          {/* ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ãƒ˜ãƒƒãƒ€ãƒ¼ */}
          <div style={{ 
            display: 'flex', 
            justifyContent: 'space-between', 
            alignItems: 'center',
            width: '100%',
            paddingBottom: 8,
            borderBottom: `1px solid ${COLORS.border}`,
          }}>
            <Text fw={600} size="sm">ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’ç·¨é›†</Text>
            <div style={{ display: 'flex', gap: 8 }}>
              <Button
                size="xs"
                variant="subtle"
                color="gray"
                leftSection={<IconX size={14} />}
                onClick={handleCancelEdit}
              >
                ã‚­ãƒ£ãƒ³ã‚»ãƒ«
              </Button>
              <Button
                size="xs"
                leftSection={<IconCheck size={14} />}
                onClick={handleSaveEdit}
              >
                ä¿å­˜
              </Button>
            </div>
          </div>

          {/* ã‚µã‚¤ã‚ºãƒ—ãƒªã‚»ãƒƒãƒˆé¸æŠ */}
          {onSizePresetChange && (
            <div style={{ 
              display: 'flex', 
              alignItems: 'center', 
              gap: 12,
              width: '100%',
            }}>
              <Text size="sm" c="dimmed">ã‚µã‚¤ã‚º:</Text>
              <SegmentedControl
                size="xs"
                value={sizePreset}
                onChange={(value) => onSizePresetChange(value as DialSizePreset)}
                data={[
                  { label: DIAL_SIZE_PRESET_LABELS.small, value: 'small' },
                  { label: DIAL_SIZE_PRESET_LABELS.medium, value: 'medium' },
                  { label: DIAL_SIZE_PRESET_LABELS.large, value: 'large' },
                ]}
              />
            </div>
          )}

          {/* ãƒ€ã‚¤ã‚¢ãƒ«ç·¨é›†ã‚¨ãƒªã‚¢ */}
          <div
            id="dial-drop-zone"
            style={{
              width: DIAL_SIZE,
              height: DIAL_SIZE,
              borderRadius: '50%',
              position: 'relative',
              background: COLORS.background,
              boxShadow: `0 4px 20px ${COLORS.shadow}`,
              border: `2px dashed ${COLORS.primary}`,
            }}
          >
            {/* ãƒªãƒ³ã‚°ã®ãƒˆãƒ©ãƒƒã‚¯ï¼ˆè»Œé“ï¼‰ - ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã§ã‚‚è¡¨ç¤º */}
            <div
              style={{
                position: 'absolute',
                left: radius - ICON_ORBIT_RADIUS - ICON_BUTTON_SIZE / 2 - 4,
                top: radius - ICON_ORBIT_RADIUS - ICON_BUTTON_SIZE / 2 - 4,
                width: (ICON_ORBIT_RADIUS + ICON_BUTTON_SIZE / 2 + 4) * 2,
                height: (ICON_ORBIT_RADIUS + ICON_BUTTON_SIZE / 2 + 4) * 2,
                borderRadius: '50%',
                background: COLORS.ringTrack,
                border: `1.5px solid ${COLORS.ringBorder}`,
                pointerEvents: 'none',
              }}
            />
            <SortableContext
              items={visibleEditItems.map((item) => `dial-${item.id}`)}
              strategy={rectSortingStrategy}
            >
              {visibleEditItems.map((item, index) => {
                const pos = getCirclePosition(
                  index,
                  visibleEditItems.length,
                  radius,
                  radius,
                  ICON_ORBIT_RADIUS
                );
                return (
                  <SortableDialIcon
                    key={item.id}
                    item={item}
                    position={pos}
                    rotation={0}
                    isSelected={false}
                    onRemove={() => handleRemoveFromDial(item.id)}
                  />
                );
              })}
            </SortableContext>

            {/* ä¸­å¤®ã®ãƒ—ãƒ©ã‚¹ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆç©ºã®å ´åˆï¼‰ */}
            {visibleEditItems.length === 0 && (
              <div
                style={{
                  position: 'absolute',
                  top: '50%',
                  left: '50%',
                  transform: 'translate(-50%, -50%)',
                  color: COLORS.textMuted,
                  textAlign: 'center',
                }}
              >
                <IconPlus size={32} />
                <Text size="xs" c="dimmed">
                  ä¸‹ã‹ã‚‰ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦è¿½åŠ 
                </Text>
              </div>
            )}
          </div>

          {/* ãƒ•ãƒƒã‚¿ãƒ¼: éè¡¨ç¤ºã‚¢ã‚¤ã‚³ãƒ³ä¸€è¦§ */}
          <div
            style={{
              width: '100%',
              background: COLORS.background,
              borderRadius: 12,
              padding: 12,
              boxShadow: `0 2px 8px ${COLORS.shadow}`,
            }}
          >
            <Text size="xs" c="dimmed" mb={8}>
              åˆ©ç”¨å¯èƒ½ãªãƒ¡ãƒ‹ãƒ¥ãƒ¼ï¼ˆãƒ‰ãƒ©ãƒƒã‚°ã—ã¦è¿½åŠ ï¼‰
            </Text>
            <ScrollArea type="auto" offsetScrollbars>
              <SortableContext
                items={hiddenEditItems.map((item) => `footer-${item.id}`)}
                strategy={rectSortingStrategy}
              >
                <div style={{ display: 'flex', gap: 8, minHeight: 80 }}>
                  {hiddenEditItems.length === 0 ? (
                    <Text size="xs" c="dimmed" style={{ padding: 20 }}>
                      ã™ã¹ã¦ã®ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãŒè¡¨ç¤ºä¸­ã§ã™
                    </Text>
                  ) : (
                    hiddenEditItems.map((item) => (
                      <DraggableFooterIcon key={item.id} item={item} />
                    ))
                  )}
                </div>
              </SortableContext>
            </ScrollArea>
          </div>
        </Box>

        {/* ãƒ‰ãƒ©ãƒƒã‚°ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */}
        <DragOverlay>
          {draggedItem && (
            <HexIconButton
              size={ICON_BUTTON_SIZE}
              selected={false}
              hovered={false}
              color={draggedItem.color}
            >
              {draggedItem.icon}
            </HexIconButton>
          )}
        </DragOverlay>
      </DndContext>
    );
  }

  return (
    <Box
      style={{
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        padding: 20,
        gap: 16,
        // èƒŒæ™¯ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
        background: `linear-gradient(180deg, ${COLORS.backgroundGradientStart} 0%, ${COLORS.backgroundGradientEnd} 100%)`,
        minHeight: 400,
        borderRadius: 16,
        position: 'relative',
      }}
    >
      {/* è¨­å®šãƒœã‚¿ãƒ³ï¼ˆå³ä¸Šï¼‰ */}
      {(onSettingsClick || allItems) && (
        <Tooltip label="ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’ç·¨é›†" position="left">
          <ActionIcon
            variant="subtle"
            color="gray"
            size="lg"
            onClick={allItems ? handleStartEdit : onSettingsClick}
            style={{
              position: 'absolute',
              top: 16,
              right: 16,
              zIndex: 100,
            }}
          >
            <IconSettings size={20} />
          </ActionIcon>
        </Tooltip>
      )}

      {/* ãƒ©ãƒ™ãƒ«ï¼ˆä¸Šéƒ¨ã«é…ç½®ï¼‰ */}
      <div style={{ textAlign: 'center', minHeight: 46 }}>
        <AnimatePresence mode="wait">
          <motion.div
            key={selectedItem?.id}
            initial={{ opacity: 0, y: -6 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: 6 }}
            transition={{ duration: 0.12 }}
          >
            <Text
              style={{
                fontSize: 18,
                fontWeight: 600,
                color: COLORS.text,
                marginBottom: 2,
              }}
              ta="center"
            >
              {selectedItem?.title}
            </Text>
          </motion.div>
        </AnimatePresence>
        <Text
          style={{
            fontSize: 12,
            color: COLORS.textMuted,
          }}
          ta="center"
        >
          {isSubExpanded ? 'ã‚¿ãƒƒãƒ—ã§æ©Ÿèƒ½ã‚’é¸æŠ' : 'å›è»¢ã§é¸æŠï¼ã‚¿ãƒƒãƒ—ã§æ±ºå®š'}
        </Text>
      </div>

      {/* ãƒ€ã‚¤ãƒ¤ãƒ«æœ¬ä½“ */}
      <div
        ref={containerRef}
        style={{
          position: 'relative',
          width: DIAL_SIZE,
          height: DIAL_SIZE,
          touchAction: 'none',
          userSelect: 'none',
          cursor: isDragging ? 'grabbing' : 'grab',
        }}
        onPointerDown={handlePointerDown}
        onPointerMove={handlePointerMove}
        onPointerUp={handlePointerUp}
        onPointerCancel={handlePointerUp}
        onWheel={handleWheel}
      >
        {/* èƒŒæ™¯ã®å††ï¼ˆçœŸã£ç™½ã€å½±ã‚’è»½ãï¼‰ */}
        <div
          style={{
            position: 'absolute',
            inset: 0,
            borderRadius: '50%',
            background: COLORS.background,
            boxShadow: `0 12px 30px ${COLORS.shadow}`,
          }}
        />

        {/* ãƒªãƒ³ã‚°ã®ãƒˆãƒ©ãƒƒã‚¯ï¼ˆè»Œé“ï¼‰ - ã‚¢ã‚¤ã‚³ãƒ³ãŒé…ç½®ã•ã‚Œã‚‹å††ã‚’å¯è¦–åŒ– */}
        <div
          style={{
            position: 'absolute',
            left: radius - ICON_ORBIT_RADIUS - ICON_BUTTON_SIZE / 2 - 4,
            top: radius - ICON_ORBIT_RADIUS - ICON_BUTTON_SIZE / 2 - 4,
            width: (ICON_ORBIT_RADIUS + ICON_BUTTON_SIZE / 2 + 4) * 2,
            height: (ICON_ORBIT_RADIUS + ICON_BUTTON_SIZE / 2 + 4) * 2,
            borderRadius: '50%',
            background: COLORS.ringTrack,
            border: `1.5px solid ${COLORS.ringBorder}`,
            pointerEvents: 'none',
          }}
        />

        {/* ä¸‹éƒ¨ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚»ã‚¯ã‚¿ãƒ¼ï¼ˆé¸æŠä½ç½®ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ï¼‰ */}
        <div
          style={{
            position: 'absolute',
            bottom: 0,
            left: '50%',
            transform: 'translateX(-50%)',
            width: 70,
            height: 35,
            background: `linear-gradient(0deg, rgba(37, 99, 235, 0.25) 0%, transparent 100%)`,
            borderRadius: '35px 35px 0 0',
            pointerEvents: 'none',
            zIndex: 15,
          }}
        />
        {/* é¸æŠä½ç½®ã®ãƒ‰ãƒƒãƒˆã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ï¼ˆä¸‹éƒ¨ï¼‰ */}
        <div
          style={{
            position: 'absolute',
            bottom: 12,
            left: '50%',
            transform: 'translateX(-50%)',
            width: 8,
            height: 8,
            borderRadius: '50%',
            background: COLORS.primary,
            boxShadow: `0 0 10px ${COLORS.primary}`,
            zIndex: 16,
          }}
        />

        {/* ã‚¢ã‚¤ã‚³ãƒ³ãƒªãƒ³ã‚° - å††å½¢è»Œé“ã«é…ç½® */}
        <motion.div
          style={{
            position: 'absolute',
            inset: 0,
            borderRadius: '50%',
            transformOrigin: '50% 50%',
          }}
          animate={{ rotate: displayRotation }}
          transition={{ type: 'spring', stiffness: 120, damping: 18 }}
        >
          {items.map((item, index) => {
            // å††è»Œé“ä¸Šã®åº§æ¨™ã‚’å–å¾—
            const pos = getCirclePosition(
              index,
              items.length,
              radius,  // centerX
              radius,  // centerY
              ICON_ORBIT_RADIUS
            );
            
            const isSelected = index === selectedIndex;
            const isHovered = index === hoveredIndex;

            return (
              <div
                key={item.id}
                style={{
                  position: 'absolute',
                  left: pos.x,
                  top: pos.y,
                  transform: 'translate(-50%, -50%)',
                  cursor: 'pointer',
                  zIndex: isSelected ? 2 : 1,
                }}
                onClick={(e) => {
                  e.stopPropagation();
                  handleItemClick(index);
                }}
                onPointerEnter={() => setHoveredIndex(index)}
                onPointerLeave={() => setHoveredIndex(null)}
              >
                {/* ã‚¢ã‚¤ã‚³ãƒ³ãƒœã‚¿ãƒ³ï¼ˆå›è»¢ã‚’æ‰“ã¡æ¶ˆã™ï¼‰ - å…­è§’å½¢ */}
                <motion.div
                  style={{ transformOrigin: '50% 50%' }}
                  animate={{
                    rotate: -displayRotation,
                    scale: isHovered && !isSelected ? 1.06 : 1,
                    y: isSelected ? -4 : 0,
                  }}
                  transition={{ 
                    type: 'spring', 
                    stiffness: 400, 
                    damping: 30,
                    scale: { duration: 0.15, ease: 'easeOut' },
                  }}
                >
                  <HexIconButton
                    size={ICON_BUTTON_SIZE}
                    selected={isSelected}
                    hovered={isHovered}
                    color={item.color || COLORS.primary}
                    badge={item.badge}
                  >
                    {item.icon}
                  </HexIconButton>
                </motion.div>
              </div>
            );
          })}
        </motion.div>

        {/* ã‚µãƒ–ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒªãƒ³ã‚° */}
        <AnimatePresence>
          {isSubExpanded && subActions.length > 0 && (
            <div
              style={{
                position: 'absolute',
                left: '50%',
                top: '50%',
                width: 0,
                height: 0,
                zIndex: 20, // ãƒªãƒ³ã‚°ã‚ˆã‚Šä¸Šã«è¡¨ç¤º
              }}
            >
              {subActions.map((sub, index) => {
                // ä¸‹å‘ãï¼ˆ90åº¦ï¼‰ã‚’ä¸­å¿ƒã«æ‰‡çŠ¶ã«å±•é–‹
                const angle = subCount === 1
                  ? 90 // 1ã¤ã®å ´åˆã¯çœŸä¸‹
                  : subStartAngle + (index / (subCount - 1)) * spreadAngle;
                const x = Math.cos((angle * Math.PI) / 180) * SUB_RADIUS;
                const y = Math.sin((angle * Math.PI) / 180) * SUB_RADIUS;

                return (
                  <motion.div
                    key={sub.id}
                    data-sub-item
                    style={{
                      position: 'absolute',
                      left: 0,
                      top: 0,
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center',
                      gap: 2,
                      cursor: 'pointer',
                    }}
                    initial={{ scale: 0, x: 0, y: 0, opacity: 0 }}
                    animate={{ scale: 1, x, y, opacity: 1 }}
                    exit={{ scale: 0, x: 0, y: 0, opacity: 0 }}
                    transition={{
                      type: 'spring',
                      stiffness: 500,
                      damping: 30,
                      delay: index * 0.04,
                    }}
                    whileHover={{ scale: 1.08 }}
                    onClick={(e) => {
                      e.stopPropagation();
                      handleSubActionClick(sub.href);
                    }}
                  >
                    <div
                      style={{
                        width: 40,
                        height: 40,
                        borderRadius: '50%',
                        background: COLORS.background,
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        boxShadow: '0 3px 12px rgba(0, 0, 0, 0.15)',
                        color: COLORS.primary,
                        border: `2px solid ${COLORS.primary}20`,
                      }}
                    >
                      {sub.icon}
                    </div>
                    <Text
                      size="xs"
                      fw={500}
                      style={{
                        position: 'absolute',
                        top: '100%',
                        marginTop: 4,
                        whiteSpace: 'nowrap',
                        padding: '3px 8px',
                        background: COLORS.background,
                        borderRadius: 6,
                        boxShadow: '0 2px 8px rgba(0, 0, 0, 0.12)',
                        color: COLORS.text,
                        fontSize: 11,
                      }}
                    >
                      {sub.title}
                    </Text>
                  </motion.div>
                );
              })}
            </div>
          )}
        </AnimatePresence>

        {/* ä¸­å¤®ã®ç©´ */}
        <div
          style={{
            position: 'absolute',
            left: (DIAL_SIZE - CENTER_SIZE) / 2,
            top: (DIAL_SIZE - CENTER_SIZE) / 2,
            width: CENTER_SIZE,
            height: CENTER_SIZE,
            borderRadius: '50%',
            // è–„ã„ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³èƒŒæ™¯
            background: 'radial-gradient(circle, #ffffff 0%, #E8F0FE 100%)',
            boxShadow: '0 4px 12px rgba(0, 0, 0, 0.08), inset 0 1px 2px rgba(255, 255, 255, 0.9)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            cursor: 'pointer',
            zIndex: 10,
          }}
          data-center
          onClick={handleCenterClick}
        >
          <motion.div
            style={{ transformOrigin: '50% 50%' }}
            animate={{ scale: isSubExpanded ? 0.9 : 1 }}
            transition={{ type: 'spring', stiffness: 300, damping: 25 }}
          >
            <AnimatePresence mode="wait">
              {isSubExpanded && selectedItem ? (
                <motion.div
                  key="expanded"
                  initial={{ scale: 0, rotate: -90 }}
                  animate={{ scale: 1, rotate: 0 }}
                  exit={{ scale: 0, rotate: 90 }}
                  transition={{ type: 'spring', stiffness: 400, damping: 25 }}
                >
                  <div
                    style={{
                      width: 52,
                      height: 52,
                      borderRadius: '50%',
                      background: COLORS.primary,
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      boxShadow: '0 3px 10px rgba(37, 99, 235, 0.3)',
                      color: COLORS.background,
                    }}
                  >
                    {selectedItem.icon}
                  </div>
                </motion.div>
              ) : (
                <motion.div
                  key="logo"
                  initial={{ scale: 0 }}
                  animate={{ scale: 1 }}
                  exit={{ scale: 0 }}
                  transition={{ type: 'spring', stiffness: 400, damping: 25 }}
                >
                  {centerLogo ?? (
                    <div
                      style={{
                        width: 48,
                        height: 48,
                        borderRadius: '50%',
                        background: COLORS.primaryLight,
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        color: COLORS.primary,
                      }}
                    >
                      <IconCat size={26} />
                    </div>
                  )}
                </motion.div>
              )}
            </AnimatePresence>
          </motion.div>
        </div>
      </div>
    </Box>
  );
}
````

## File: frontend/src/components/dashboard/DialNavigationExample.tsx
````typescript
/**
 * DialNavigation çµ±åˆã‚µãƒ³ãƒ—ãƒ«
 * 
 * ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€DialNavigation ã¨ DialMenuSettings ã‚’çµ±åˆã™ã‚‹æ–¹æ³•ã‚’ç¤ºã—ã¾ã™ã€‚
 * å®Ÿéš›ã®ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ç”»é¢ã§ä½¿ç”¨ã™ã‚‹éš›ã®å‚è€ƒã«ã—ã¦ãã ã•ã„ã€‚
 */

'use client';

import { useState, useEffect, useMemo } from 'react';
import { DialNavigation } from '@/components/dashboard/DialNavigation';
import { DialMenuSettings, DialMenuItemConfig } from '@/components/dashboard/DialMenuSettings';
import {
  IconCat,
  IconUsers,
  IconCalendar,
  IconHeart,
  IconMedicalCross,
  IconPhoto,
  IconSettings,
} from '@tabler/icons-react';

/**
 * ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ¡ãƒ‹ãƒ¥ãƒ¼è¨­å®š
 */
const DEFAULT_MENU_CONFIG: DialMenuItemConfig[] = [
  {
    id: '1',
    title: 'åœ¨èˆçŒ«ä¸€è¦§',
    icon: <IconCat size={24} />,
    color: '#2563EB',
    href: '/cats',
    badge: 12,
    visible: true,
    order: 0,
    subActions: [
      { id: '1-1', title: 'æ–°è¦ç™»éŒ²', icon: <IconCat size={18} />, href: '/cats/new' },
      { id: '1-2', title: 'ä¸€æ‹¬ç·¨é›†', icon: <IconCat size={18} />, href: '/cats/bulk-edit' },
    ],
  },
  {
    id: '2',
    title: 'é€€èˆçŒ«',
    icon: <IconUsers size={24} />,
    color: '#22C55E',
    href: '/cats/retired',
    badge: 8,
    visible: true,
    order: 1,
  },
  {
    id: '3',
    title: 'å­çŒ«ä¸€è¦§',
    icon: <IconCalendar size={24} />,
    color: '#F97316',
    href: '/kittens',
    badge: 5,
    visible: true,
    order: 2,
  },
  {
    id: '4',
    title: 'äºˆå®šç®¡ç†',
    icon: <IconCalendar size={24} />,
    color: '#8B5CF6',
    href: '/schedule',
    visible: true,
    order: 3,
  },
  {
    id: '5',
    title: 'å¥åº·è¨˜éŒ²',
    icon: <IconMedicalCross size={24} />,
    color: '#EF4444',
    href: '/medical-records',
    visible: true,
    order: 4,
  },
  {
    id: '6',
    title: 'ã‚®ãƒ£ãƒ©ãƒªãƒ¼',
    icon: <IconPhoto size={24} />,
    color: '#EC4899',
    href: '/gallery',
    visible: true,
    order: 5,
  },
  {
    id: '7',
    title: 'é‡Œè¦ªç®¡ç†',
    icon: <IconHeart size={24} />,
    color: '#F43F5E',
    href: '/adoption',
    visible: false,
    order: 6,
  },
  {
    id: '8',
    title: 'è¨­å®š',
    icon: <IconSettings size={24} />,
    color: '#64748B',
    href: '/settings',
    visible: false,
    order: 7,
  },
];

/**
 * DialNavigation çµ±åˆã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 */
export function DialNavigationExample() {
  // ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›®ã®è¨­å®šï¼ˆlocalStorage ã‹ã‚‰èª­ã¿è¾¼ã¿ï¼‰
  const [menuConfig, setMenuConfig] = useState<DialMenuItemConfig[]>(() => {
    // ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å¯¾ç­–
    if (typeof window === 'undefined') {
      return DEFAULT_MENU_CONFIG;
    }

    const saved = localStorage.getItem('dialMenuConfig');
    if (saved) {
      try {
        return JSON.parse(saved);
      } catch (e) {
        console.error('Failed to parse saved dial menu config:', e);
      }
    }
    return DEFAULT_MENU_CONFIG;
  });

  // è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ«ã®è¡¨ç¤ºçŠ¶æ…‹
  const [settingsOpened, setSettingsOpened] = useState(false);

  // visible ãªã‚¢ã‚¤ãƒ†ãƒ ã®ã¿ã‚’ order ã§ã‚½ãƒ¼ãƒˆ (useMemo ã§ãƒ¡ãƒ¢åŒ–)
  const visibleItems = useMemo(
    () => menuConfig.filter(item => item.visible).sort((a, b) => a.order - b.order),
    [menuConfig]
  );

  // ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç†
  const handleNavigate = (href: string) => {
    console.log('Navigate to:', href);
    
    // Next.js ã® useRouter ã‚’ä½¿ã£ãŸé·ç§»ä¾‹
    // const router = useRouter();
    // router.push(href);
    
    // ã¾ãŸã¯ window.location ã‚’ä½¿ã£ãŸé·ç§»
    // window.location.href = href;
  };

  // è¨­å®šä¿å­˜
  const handleSaveSettings = (updatedItems: DialMenuItemConfig[]) => {
    setMenuConfig(updatedItems);
    
    // localStorage ã«ä¿å­˜
    if (typeof window !== 'undefined') {
      localStorage.setItem('dialMenuConfig', JSON.stringify(updatedItems));
    }
    
    // ã¾ãŸã¯ API ã«ä¿å­˜ã™ã‚‹å ´åˆ
    // try {
    //   await fetch('/api/user/dial-menu-settings', {
    //     method: 'PUT',
    //     headers: { 'Content-Type': 'application/json' },
    //     body: JSON.stringify(updatedItems),
    //   });
    //   console.log('Settings saved to server');
    // } catch (error) {
    //   console.error('Failed to save settings:', error);
    // }
  };

  // åˆæœŸèª­ã¿è¾¼ã¿æ™‚ã®ãƒ­ã‚°
  useEffect(() => {
    console.log('Dial menu initialized:', {
      total: menuConfig.length,
      visible: visibleItems.length,
      hidden: menuConfig.length - visibleItems.length,
    });
  }, [menuConfig, visibleItems.length]);

  return (
    <div style={{ padding: 20 }}>
      <h1 style={{ textAlign: 'center', marginBottom: 20 }}>
        ãƒ€ã‚¤ãƒ¤ãƒ«ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ ã‚µãƒ³ãƒ—ãƒ«
      </h1>

      {/* ãƒ€ã‚¤ãƒ¤ãƒ«ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³æœ¬ä½“ */}
      <DialNavigation
        items={visibleItems}
        onNavigate={handleNavigate}
        onSettingsClick={() => setSettingsOpened(true)}
      />

      {/* è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ« */}
      <DialMenuSettings
        opened={settingsOpened}
        onClose={() => setSettingsOpened(false)}
        items={menuConfig}
        onSave={handleSaveSettings}
      />

      {/* ãƒ‡ãƒãƒƒã‚°æƒ…å ± */}
      <div style={{
        marginTop: 40,
        padding: 20,
        background: '#F3F4F6',
        borderRadius: 8,
      }}>
        <h3>ãƒ‡ãƒãƒƒã‚°æƒ…å ±</h3>
        <p>è¡¨ç¤ºä¸­ã®é …ç›®: {visibleItems.length} / {menuConfig.length}</p>
        <details>
          <summary style={{ cursor: 'pointer', marginTop: 10 }}>
            è¨­å®šè©³ç´°ã‚’è¡¨ç¤º
          </summary>
          <pre style={{
            marginTop: 10,
            padding: 10,
            background: 'white',
            borderRadius: 4,
            overflow: 'auto',
            fontSize: 12,
          }}>
            {JSON.stringify(menuConfig, null, 2)}
          </pre>
        </details>
      </div>
    </div>
  );
}

/**
 * ãƒªã‚»ãƒƒãƒˆæ©Ÿèƒ½ä»˜ããƒãƒ¼ã‚¸ãƒ§ãƒ³
 */
export function DialNavigationWithReset() {
  const [menuConfig, setMenuConfig] = useState<DialMenuItemConfig[]>(DEFAULT_MENU_CONFIG);
  const [settingsOpened, setSettingsOpened] = useState(false);

  const visibleItems = useMemo(
    () => menuConfig.filter(item => item.visible).sort((a, b) => a.order - b.order),
    [menuConfig]
  );

  // è¨­å®šã‚’ãƒªã‚»ãƒƒãƒˆ
  const handleReset = () => {
    setMenuConfig(DEFAULT_MENU_CONFIG);
    if (typeof window !== 'undefined') {
      localStorage.removeItem('dialMenuConfig');
    }
  };

  return (
    <div>
      <div style={{ textAlign: 'center', marginBottom: 20 }}>
        <button
          onClick={handleReset}
          style={{
            padding: '8px 16px',
            background: '#EF4444',
            color: 'white',
            border: 'none',
            borderRadius: 4,
            cursor: 'pointer',
          }}
        >
          è¨­å®šã‚’ãƒªã‚»ãƒƒãƒˆ
        </button>
      </div>

      <DialNavigation
        items={visibleItems}
        onNavigate={(href) => console.log('Navigate:', href)}
        onSettingsClick={() => setSettingsOpened(true)}
      />

      <DialMenuSettings
        opened={settingsOpened}
        onClose={() => setSettingsOpened(false)}
        items={menuConfig}
        onSave={setMenuConfig}
      />
    </div>
  );
}

/**
 * API é€£æºãƒãƒ¼ã‚¸ãƒ§ãƒ³
 */
export function DialNavigationWithAPI() {
  const [menuConfig, setMenuConfig] = useState<DialMenuItemConfig[]>(DEFAULT_MENU_CONFIG);
  const [settingsOpened, setSettingsOpened] = useState(false);
  const [loading, setLoading] = useState(true);

  // visible ãªã‚¢ã‚¤ãƒ†ãƒ ã®ã¿ã‚’ order ã§ã‚½ãƒ¼ãƒˆ (useMemo ã§ãƒ¡ãƒ¢åŒ–)
  const visibleItems = useMemo(
    () => menuConfig.filter(item => item.visible).sort((a, b) => a.order - b.order),
    [menuConfig]
  );

  // åˆæœŸèª­ã¿è¾¼ã¿
  useEffect(() => {
    const loadSettings = async () => {
      try {
        const response = await fetch('/api/user/dial-menu-settings');
        if (response.ok) {
          const data = await response.json();
          setMenuConfig(data);
        }
      } catch (error) {
        console.error('Failed to load settings:', error);
      } finally {
        setLoading(false);
      }
    };

    loadSettings();
  }, []);

  // è¨­å®šä¿å­˜
  const handleSaveSettings = async (updatedItems: DialMenuItemConfig[]) => {
    try {
      const response = await fetch('/api/user/dial-menu-settings', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updatedItems),
      });

      if (response.ok) {
        setMenuConfig(updatedItems);
        console.log('Settings saved successfully');
      } else {
        console.error('Failed to save settings');
      }
    } catch (error) {
      console.error('Failed to save settings:', error);
    }
  };

  if (loading) {
    return <div>èª­ã¿è¾¼ã¿ä¸­...</div>;
  }

  return (
    <div>
      <DialNavigation
        items={visibleItems}
        onNavigate={(href) => console.log('Navigate:', href)}
        onSettingsClick={() => setSettingsOpened(true)}
      />

      <DialMenuSettings
        opened={settingsOpened}
        onClose={() => setSettingsOpened(false)}
        items={menuConfig}
        onSave={handleSaveSettings}
      />
    </div>
  );
}
````

## File: frontend/src/components/dashboard/DialWheel.module.css
````css
.container {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 24px;
  gap: 20px;
}

/* ãƒ¡ã‚¤ãƒ³ãƒ€ã‚¤ãƒ¤ãƒ« */
.dial {
  position: relative;
  width: 300px;
  height: 300px;
  border-radius: 50%;
  background: linear-gradient(
    145deg,
    var(--mantine-color-gray-0),
    var(--mantine-color-gray-2)
  );
  box-shadow:
    0 10px 40px rgba(0, 0, 0, 0.15),
    inset 0 2px 4px rgba(255, 255, 255, 0.9),
    inset 0 -2px 6px rgba(0, 0, 0, 0.08);
  cursor: grab;
  touch-action: none;
  user-select: none;

  &:active {
    cursor: grabbing;
  }
}

:global([data-mantine-color-scheme='dark']) .dial {
  background: linear-gradient(
    145deg,
    var(--mantine-color-dark-5),
    var(--mantine-color-dark-7)
  );
  box-shadow:
    0 10px 40px rgba(0, 0, 0, 0.5),
    inset 0 2px 4px rgba(255, 255, 255, 0.05),
    inset 0 -2px 6px rgba(0, 0, 0, 0.4);
}

/* å¤–æ ã‚°ãƒ­ãƒ¼ */
.dialGlow {
  position: absolute;
  inset: -4px;
  border-radius: 50%;
  background: conic-gradient(
    from 0deg,
    transparent 0deg,
    var(--mantine-color-blue-4) 30deg,
    transparent 60deg,
    transparent 300deg,
    var(--mantine-color-blue-4) 330deg,
    transparent 360deg
  );
  opacity: 0.3;
  filter: blur(8px);
  pointer-events: none;
  animation: glowRotate 8s linear infinite;
}

@keyframes glowRotate {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

/* å›è»¢ãƒªãƒ³ã‚° */
.ring {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  /* ã‚¹ãƒ—ãƒªãƒ³ã‚°ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã¯ Framer Motion ãŒåˆ¶å¾¡ */
}

.ringItem {
  position: absolute;
  cursor: pointer;
  /* ä¸­å¤®ã‚’åŸºç‚¹ã«é…ç½® */
  transform: translate(-50%, -50%);
}

.ringItemInner {
  display: flex;
  flex-direction: column;
  align-items: center;
  transform: translate(-50%, -50%);
}

.ringIcon {
  transition: box-shadow 0.3s ease;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.ringIconSelected {
  box-shadow:
    0 6px 20px rgba(0, 0, 0, 0.25),
    0 0 20px var(--mantine-color-blue-3);
}

:global([data-mantine-color-scheme='dark']) .ringIconSelected {
  box-shadow:
    0 6px 20px rgba(0, 0, 0, 0.4),
    0 0 25px var(--mantine-color-blue-6);
}

.badge {
  position: absolute;
  top: -6px;
  right: -6px;
  min-width: 20px;
  height: 20px;
  font-size: 11px;
  z-index: 1;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
}

/* ä¸­å¤®ã‚¨ãƒªã‚¢ */
.center {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 100px;
  height: 100px;
  border-radius: 50%;
  background: var(--mantine-color-white);
  box-shadow:
    0 4px 20px rgba(0, 0, 0, 0.12),
    inset 0 2px 4px rgba(255, 255, 255, 0.8),
    inset 0 -1px 2px rgba(0, 0, 0, 0.05);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 10;
  transition: background-color 0.3s ease;
}

:global([data-mantine-color-scheme='dark']) .center {
  background: var(--mantine-color-dark-4);
  box-shadow:
    0 4px 20px rgba(0, 0, 0, 0.3),
    inset 0 2px 4px rgba(255, 255, 255, 0.03),
    inset 0 -1px 2px rgba(0, 0, 0, 0.2);
}

.centerLogo {
  display: flex;
  align-items: center;
  justify-content: center;
}

.centerIcon {
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
}

/* ã‚µãƒ–ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒªãƒ³ã‚° */
.subRing {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  z-index: 5;
}

.subItem {
  position: absolute;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  cursor: pointer;
  transform: translate(-50%, -50%);
}

.subIcon {
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
}

.subItem:hover .subIcon {
  transform: scale(1.15);
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

.subItem:active .subIcon {
  transform: scale(0.95);
}

.subLabel {
  position: absolute;
  top: 100%;
  white-space: nowrap;
  font-weight: 500;
  margin-top: 2px;
  padding: 2px 6px;
  background: var(--mantine-color-white);
  border-radius: 4px;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
  font-size: 10px;
}

:global([data-mantine-color-scheme='dark']) .subLabel {
  background: var(--mantine-color-dark-5);
}

/* ä¸Šéƒ¨ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ */
.indicator {
  position: absolute;
  top: 8px;
  left: 50%;
  transform: translateX(-50%);
  width: 0;
  height: 0;
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
  border-top: 16px solid var(--mantine-color-blue-5);
  filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.25));
  z-index: 20;
}

/* ãƒ©ãƒ™ãƒ« */
.labelContainer {
  text-align: center;
}

.selectedTitle {
  background: linear-gradient(
    135deg,
    var(--mantine-color-gray-9),
    var(--mantine-color-gray-7)
  );
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

:global([data-mantine-color-scheme='dark']) .selectedTitle {
  background: linear-gradient(
    135deg,
    var(--mantine-color-gray-0),
    var(--mantine-color-gray-4)
  );
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}
````

## File: frontend/src/components/dashboard/DialWheel.tsx
````typescript
'use client';

import { useState, useRef, useCallback, useEffect, type ReactNode } from 'react';
import {
  motion,
  useMotionValue,
  useTransform,
  useSpring,
  AnimatePresence,
  type PanInfo,
} from 'framer-motion';
import { Box, Text, ThemeIcon, Badge } from '@mantine/core';
import { IconCat } from '@tabler/icons-react';
import classes from './DialWheel.module.css';

/** ãƒªãƒ³ã‚°ä¸Šã®ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›® */
export interface DialWheelItem {
  id: string;
  title: string;
  icon: ReactNode;
  color: string;
  href: string;
  badge?: string | number;
  /** ã‚µãƒ–ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆé¸æŠæ™‚ã«æ‰‡çŠ¶å±•é–‹ï¼‰ */
  subActions?: {
    id: string;
    title: string;
    icon: ReactNode;
    href: string;
  }[];
}

interface DialWheelProps {
  /** ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›® */
  items: DialWheelItem[];
  /** ã‚¢ã‚¤ãƒ†ãƒ ã‚¯ãƒªãƒƒã‚¯æ™‚ */
  onNavigate: (href: string) => void;
  /** ä¸­å¤®ã®ãƒ­ã‚´/ã‚¢ã‚¤ã‚³ãƒ³ */
  centerLogo?: ReactNode;
}

/**
 * iPodãƒ›ã‚¤ãƒ¼ãƒ«é¢¨ãƒ€ã‚¤ãƒ¤ãƒ«UI
 * - ä¸­å¤®: ãƒ­ã‚´ or é¸æŠä¸­ã‚¢ã‚¤ã‚³ãƒ³
 * - ãƒªãƒ³ã‚°: å›è»¢ã™ã‚‹ã‚¢ã‚¤ã‚³ãƒ³ç¾¤
 * - ã‚µãƒ–ãƒªãƒ³ã‚°: é¸æŠæ™‚ã«æ‰‡çŠ¶å±•é–‹
 */
export function DialWheel({ items, onNavigate, centerLogo }: DialWheelProps) {
  // å›è»¢è§’åº¦ï¼ˆdegreeï¼‰
  const rotation = useMotionValue(0);
  // ã‚¹ãƒ—ãƒªãƒ³ã‚°ã§æ»‘ã‚‰ã‹ã«
  const smoothRotation = useSpring(rotation, {
    stiffness: 100,
    damping: 20,
    mass: 0.5,
  });
  // ã‚¢ã‚¤ã‚³ãƒ³é€†å›è»¢ç”¨
  const inverseRotation = useTransform(smoothRotation, (r) => -r);
  
  // é¸æŠä¸­ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
  const [selectedIndex, setSelectedIndex] = useState(0);
  // ã‚µãƒ–ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å±•é–‹ä¸­ã‹
  const [isSubExpanded, setIsSubExpanded] = useState(false);
  // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã‹
  const [isDragging, setIsDragging] = useState(false);
  
  const containerRef = useRef<HTMLDivElement>(null);
  const anglePerItem = 360 / items.length;

  // å›è»¢è§’åº¦ã‹ã‚‰é¸æŠã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—
  const updateSelectedIndex = useCallback(() => {
    const currentRotation = rotation.get();
    // æ­£è¦åŒ–ï¼ˆ0-360ï¼‰
    const normalized = ((currentRotation % 360) + 360) % 360;
    // ä¸Šéƒ¨ï¼ˆ0åº¦ï¼‰ã«æœ€ã‚‚è¿‘ã„ã‚¢ã‚¤ãƒ†ãƒ 
    const rawIndex = Math.round(normalized / anglePerItem);
    // å›è»¢æ–¹å‘ã‚’åè»¢ï¼ˆæ™‚è¨ˆå›ã‚Šã§æ¬¡ã¸ï¼‰
    const index = (items.length - (rawIndex % items.length)) % items.length;
    setSelectedIndex(index);
  }, [rotation, anglePerItem, items.length]);

  // å›è»¢å€¤ã®å¤‰æ›´ã‚’ç›£è¦–
  useEffect(() => {
    const unsubscribe = rotation.on('change', updateSelectedIndex);
    return () => unsubscribe();
  }, [rotation, updateSelectedIndex]);

  // ã‚¹ãƒŠãƒƒãƒ—å…ˆã®è§’åº¦ã‚’è¨ˆç®—
  const getSnapAngle = useCallback(
    (currentRotation: number): number => {
      const normalized = ((currentRotation % 360) + 360) % 360;
      const nearestIndex = Math.round(normalized / anglePerItem);
      const snapAngle = nearestIndex * anglePerItem;
      // å®Œå…¨ãªå›è»¢æ•°ã‚’ç¶­æŒ
      const fullRotations = Math.floor(currentRotation / 360) * 360;
      return fullRotations + snapAngle;
    },
    [anglePerItem]
  );

  // ä¸­å¿ƒåº§æ¨™ã‚’å–å¾—
  const getCenter = useCallback(() => {
    if (!containerRef.current) return { x: 0, y: 0 };
    const rect = containerRef.current.getBoundingClientRect();
    return {
      x: rect.left + rect.width / 2,
      y: rect.top + rect.height / 2,
    };
  }, []);

  // åº§æ¨™ã‹ã‚‰è§’åº¦ã‚’è¨ˆç®—
  const getAngleFromPoint = useCallback(
    (x: number, y: number) => {
      const center = getCenter();
      const dx = x - center.x;
      const dy = y - center.y;
      // ä¸Šã‚’0åº¦ã€æ™‚è¨ˆå›ã‚Šã‚’æ­£
      return Math.atan2(dx, -dy) * (180 / Math.PI);
    },
    [getCenter]
  );

  // ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹æ™‚ã®è§’åº¦
  const dragStartAngle = useRef(0);
  const dragStartRotation = useRef(0);

  // ãƒ‘ãƒ³ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handlePanStart = useCallback(
    (event: PointerEvent) => {
      setIsDragging(true);
      setIsSubExpanded(false);
      dragStartAngle.current = getAngleFromPoint(event.clientX, event.clientY);
      dragStartRotation.current = rotation.get();
    },
    [getAngleFromPoint, rotation]
  );

  const handlePan = useCallback(
    (event: PointerEvent, _info: PanInfo) => {
      const currentAngle = getAngleFromPoint(event.clientX, event.clientY);
      const deltaAngle = currentAngle - dragStartAngle.current;
      rotation.set(dragStartRotation.current + deltaAngle);
    },
    [getAngleFromPoint, rotation]
  );

  const handlePanEnd = useCallback(
    (event: PointerEvent, info: PanInfo) => {
      setIsDragging(false);
      
      // é€Ÿåº¦ã‹ã‚‰æ…£æ€§ã‚’è¨ˆç®—
      const velocity = Math.sqrt(info.velocity.x ** 2 + info.velocity.y ** 2);
      const currentRotation = rotation.get();
      
      if (velocity > 100) {
        // æ…£æ€§: é€Ÿåº¦ã«å¿œã˜ã¦è¿½åŠ å›è»¢
        const center = getCenter();
        const dx = event.clientX - center.x;
        const dy = event.clientY - center.y;
        // æ¥ç·šæ–¹å‘ã®é€Ÿåº¦æˆåˆ†
        const tangentialVelocity =
          (info.velocity.x * (-dy) + info.velocity.y * dx) /
          Math.sqrt(dx * dx + dy * dy);
        
        const inertiaRotation = tangentialVelocity * 0.3;
        const targetRotation = currentRotation + inertiaRotation;
        const snapAngle = getSnapAngle(targetRotation);
        
        rotation.set(snapAngle);
      } else {
        // ã‚¹ãƒŠãƒƒãƒ—ã®ã¿
        rotation.set(getSnapAngle(currentRotation));
      }
    },
    [rotation, getCenter, getSnapAngle]
  );

  // ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚‚å›è»¢
  const handleWheel = useCallback(
    (event: React.WheelEvent) => {
      event.preventDefault();
      setIsSubExpanded(false);
      
      const delta = event.deltaY > 0 ? anglePerItem : -anglePerItem;
      const currentRotation = rotation.get();
      rotation.set(getSnapAngle(currentRotation + delta));
    },
    [rotation, anglePerItem, getSnapAngle]
  );

  // ã‚¢ã‚¤ãƒ†ãƒ ã‚¯ãƒªãƒƒã‚¯
  const handleItemClick = useCallback(
    (index: number) => {
      if (index === selectedIndex) {
        // é¸æŠä¸­ã®ã‚¢ã‚¤ãƒ†ãƒ  â†’ ã‚µãƒ–å±•é–‹ or é·ç§»
        const item = items[selectedIndex];
        if (item.subActions && item.subActions.length > 0) {
          setIsSubExpanded((prev) => !prev);
        } else {
          onNavigate(item.href);
        }
      } else {
        // åˆ¥ã®ã‚¢ã‚¤ãƒ†ãƒ  â†’ ãã“ã¾ã§å›è»¢
        setIsSubExpanded(false);
        const currentNormalized = ((rotation.get() % 360) + 360) % 360;
        const targetIndex = (items.length - index) % items.length;
        const targetAngle = targetIndex * anglePerItem;
        
        let delta = targetAngle - currentNormalized;
        if (delta > 180) delta -= 360;
        if (delta < -180) delta += 360;
        
        rotation.set(rotation.get() + delta);
      }
    },
    [selectedIndex, items, rotation, anglePerItem, onNavigate]
  );

  // ã‚µãƒ–ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¯ãƒªãƒƒã‚¯
  const handleSubActionClick = useCallback(
    (href: string) => {
      setIsSubExpanded(false);
      onNavigate(href);
    },
    [onNavigate]
  );

  // ä¸­å¤®ã‚¯ãƒªãƒƒã‚¯
  const handleCenterClick = useCallback(() => {
    const item = items[selectedIndex];
    if (isSubExpanded) {
      // ã‚µãƒ–å±•é–‹ä¸­ â†’ ãƒ¡ã‚¤ãƒ³ã«é·ç§»
      onNavigate(item.href);
    } else if (item.subActions && item.subActions.length > 0) {
      // ã‚µãƒ–ã‚ã‚Š â†’ å±•é–‹
      setIsSubExpanded(true);
    } else {
      // ã‚µãƒ–ãªã— â†’ é·ç§»
      onNavigate(item.href);
    }
  }, [items, selectedIndex, isSubExpanded, onNavigate]);

  const selectedItem = items[selectedIndex];

  return (
    <Box className={classes.container}>
      {/* ãƒ¡ã‚¤ãƒ³ãƒ€ã‚¤ãƒ¤ãƒ« */}
      <motion.div
        ref={containerRef}
        className={classes.dial}
        onPanStart={handlePanStart}
        onPan={handlePan}
        onPanEnd={handlePanEnd}
        onWheel={handleWheel}
      >
        {/* å¤–æ ã‚°ãƒ­ãƒ¼åŠ¹æœ */}
        <div className={classes.dialGlow} />

        {/* å›è»¢ãƒªãƒ³ã‚° */}
        <motion.div
          className={classes.ring}
          style={{ rotate: smoothRotation }}
        >
          {items.map((item, index) => {
            // ä¸Šã‚’0åº¦ã¨ã—ã¦æ™‚è¨ˆå›ã‚Šã«é…ç½®
            const itemAngle = (index / items.length) * 360 - 90;
            const radius = 100;
            const x = Math.cos((itemAngle * Math.PI) / 180) * radius;
            const y = Math.sin((itemAngle * Math.PI) / 180) * radius;
            const isSelected = index === selectedIndex;

            return (
              <motion.div
                key={item.id}
                className={classes.ringItem}
                style={{
                  // åº§æ¨™ãƒ™ãƒ¼ã‚¹ã§é…ç½®ï¼ˆå›è»¢ã«ã‚ˆã‚‹ä½ç½®ã‚ºãƒ¬ã‚’é˜²ãï¼‰
                  x,
                  y,
                }}
                onClick={(e) => {
                  e.stopPropagation();
                  handleItemClick(index);
                }}
              >
                {/* ã‚¢ã‚¤ã‚³ãƒ³ã¯é€†å›è»¢ã§æ­£ä½ç½® */}
                <motion.div
                  className={classes.ringItemInner}
                  style={{ rotate: inverseRotation }}
                  animate={{
                    scale: isSelected ? 1.25 : 1,
                    opacity: isSelected ? 1 : 0.7,
                  }}
                  transition={{ type: 'spring', stiffness: 300, damping: 25 }}
                >
                  <ThemeIcon
                    size={isSelected ? 56 : 44}
                    radius="50%"
                    variant={isSelected ? 'filled' : 'light'}
                    color={item.color}
                    className={`${classes.ringIcon} ${isSelected ? classes.ringIconSelected : ''}`}
                  >
                    {item.icon}
                  </ThemeIcon>

                  {/* ãƒãƒƒã‚¸ */}
                  {item.badge !== undefined && item.badge !== 0 && item.badge !== '' && (
                    <Badge
                      variant="filled"
                      color="red"
                      size="sm"
                      circle
                      className={classes.badge}
                    >
                      {item.badge}
                    </Badge>
                  )}
                </motion.div>
              </motion.div>
            );
          })}
        </motion.div>

        {/* ä¸­å¤®ã‚¨ãƒªã‚¢ */}
        <motion.div
          className={classes.center}
          onClick={handleCenterClick}
          animate={{
            scale: isSubExpanded ? 0.9 : 1,
            backgroundColor: isSubExpanded
              ? `var(--mantine-color-${selectedItem?.color}-1)`
              : 'var(--mantine-color-white)',
          }}
          transition={{ type: 'spring', stiffness: 300, damping: 25 }}
        >
          <AnimatePresence mode="wait">
            {isSubExpanded ? (
              <motion.div
                key="selected-icon"
                initial={{ scale: 0, rotate: -180 }}
                animate={{ scale: 1, rotate: 0 }}
                exit={{ scale: 0, rotate: 180 }}
                transition={{ type: 'spring', stiffness: 300, damping: 25 }}
              >
                <ThemeIcon
                  size={60}
                  radius="50%"
                  variant="filled"
                  color={selectedItem?.color}
                  className={classes.centerIcon}
                >
                  {selectedItem?.icon}
                </ThemeIcon>
              </motion.div>
            ) : (
              <motion.div
                key="logo"
                initial={{ scale: 0 }}
                animate={{ scale: 1 }}
                exit={{ scale: 0 }}
                transition={{ type: 'spring', stiffness: 300, damping: 25 }}
                className={classes.centerLogo}
              >
                {centerLogo ?? (
                  <ThemeIcon size={50} radius="50%" variant="light" color="gray">
                    <IconCat size={28} />
                  </ThemeIcon>
                )}
              </motion.div>
            )}
          </AnimatePresence>
        </motion.div>

        {/* ã‚µãƒ–ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒªãƒ³ã‚°ï¼ˆæ‰‡çŠ¶å±•é–‹ï¼‰ */}
        <AnimatePresence>
          {isSubExpanded && selectedItem?.subActions && (
            <motion.div
              className={classes.subRing}
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
            >
              {selectedItem.subActions.map((subAction, index) => {
                const subCount = selectedItem.subActions?.length ?? 0;
                // æ‰‡çŠ¶ã«é…ç½®ï¼ˆä¸ŠåŠåˆ†ã«åºƒãŒã‚‹ï¼‰
                const spreadAngle = Math.min(180, subCount * 45);
                const startAngle = -90 - spreadAngle / 2;
                const subAngle = startAngle + (index / (subCount - 1 || 1)) * spreadAngle;
                const radius = 70;

                return (
                  <motion.div
                    key={subAction.id}
                    className={classes.subItem}
                    initial={{ scale: 0, x: 0, y: 0 }}
                    animate={{
                      scale: 1,
                      x: Math.cos((subAngle * Math.PI) / 180) * radius,
                      y: Math.sin((subAngle * Math.PI) / 180) * radius,
                    }}
                    exit={{ scale: 0, x: 0, y: 0 }}
                    transition={{
                      type: 'spring',
                      stiffness: 400,
                      damping: 25,
                      delay: index * 0.05,
                    }}
                    onClick={(e) => {
                      e.stopPropagation();
                      handleSubActionClick(subAction.href);
                    }}
                    title={subAction.title}
                  >
                    <ThemeIcon
                      size={40}
                      radius="50%"
                      variant="light"
                      color={selectedItem.color}
                      className={classes.subIcon}
                    >
                      {subAction.icon}
                    </ThemeIcon>
                    <Text size="xs" className={classes.subLabel}>
                      {subAction.title}
                    </Text>
                  </motion.div>
                );
              })}
            </motion.div>
          )}
        </AnimatePresence>

        {/* ä¸Šéƒ¨ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ */}
        <div className={classes.indicator} />
      </motion.div>

      {/* é¸æŠä¸­ã®ãƒ©ãƒ™ãƒ« */}
      <motion.div
        className={classes.labelContainer}
        initial={false}
        animate={{ opacity: isDragging ? 0.5 : 1 }}
      >
        <AnimatePresence mode="wait">
          <motion.div
            key={selectedItem?.id}
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            transition={{ duration: 0.2 }}
          >
            <Text size="xl" fw={700} ta="center" className={classes.selectedTitle}>
              {selectedItem?.title}
            </Text>
          </motion.div>
        </AnimatePresence>
        <Text size="sm" c="dimmed" ta="center">
          {isSubExpanded ? 'ã‚¿ãƒƒãƒ—ã§æ©Ÿèƒ½ã‚’é¸æŠ' : 'å›ã—ã¦é¸æŠ â€¢ ã‚¿ãƒƒãƒ—ã§æ±ºå®š'}
        </Text>
      </motion.div>
    </Box>
  );
}
````

## File: frontend/src/components/dashboard/DisplayModeToggle.tsx
````typescript
'use client';

import { ActionIcon, Tooltip, SegmentedControl, Group, Box } from '@mantine/core';
import { IconLayoutGrid, IconCircleDot, IconSettings } from '@tabler/icons-react';
import { type HomeDisplayMode } from '@/lib/storage/dashboard-settings';

interface DisplayModeToggleProps {
  /** ç¾åœ¨ã®è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ */
  mode: HomeDisplayMode;
  /** ãƒ¢ãƒ¼ãƒ‰å¤‰æ›´æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
  onModeChange: (mode: HomeDisplayMode) => void;
  /** è¨­å®šãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
  onSettingsClick: () => void;
  /** ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆè¡¨ç¤ºï¼ˆã‚¢ã‚¤ã‚³ãƒ³ã®ã¿ï¼‰ */
  compact?: boolean;
}

/**
 * ãƒ›ãƒ¼ãƒ ç”»é¢ã®è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * ã‚«ãƒ¼ãƒ‰å¼/ãƒ€ã‚¤ã‚¢ãƒ«å¼ã®åˆ‡ã‚Šæ›¿ãˆã¨è¨­å®šãƒœã‚¿ãƒ³ã‚’æä¾›
 */
export function DisplayModeToggle({
  mode,
  onModeChange,
  onSettingsClick,
  compact = false,
}: DisplayModeToggleProps) {
  if (compact) {
    // ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆè¡¨ç¤º: ã‚¢ã‚¤ã‚³ãƒ³ãƒœã‚¿ãƒ³ã®ã¿
    return (
      <Group gap="xs">
        {/* è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³ */}
        <Tooltip 
          label={mode === 'card' ? 'ãƒ€ã‚¤ã‚¢ãƒ«è¡¨ç¤ºã«åˆ‡ã‚Šæ›¿ãˆ' : 'ã‚«ãƒ¼ãƒ‰è¡¨ç¤ºã«åˆ‡ã‚Šæ›¿ãˆ'} 
          position="left"
        >
          <ActionIcon
            variant="light"
            color={mode === 'card' ? 'blue' : 'violet'}
            size="lg"
            onClick={() => {
              const nextMode = mode === 'card' ? 'dial' : 'card';
              onModeChange(nextMode);
            }}
          >
            {mode === 'card' ? <IconCircleDot size={20} /> : <IconLayoutGrid size={20} />}
          </ActionIcon>
        </Tooltip>
        
        {/* è¨­å®šãƒœã‚¿ãƒ³ */}
        <Tooltip label="è¨­å®šã‚’é–‹ã" position="left">
          <ActionIcon
            variant="light"
            color="gray"
            size="lg"
            onClick={onSettingsClick}
          >
            <IconSettings size={20} />
          </ActionIcon>
        </Tooltip>
      </Group>
    );
  }

  // é€šå¸¸è¡¨ç¤º: ã‚»ã‚°ãƒ¡ãƒ³ãƒˆä»˜ã
  return (
    <Group gap="md" wrap="nowrap">
      {/* è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰é¸æŠ */}
      <Box>
        <SegmentedControl
          value={mode}
          onChange={(value) => onModeChange(value as HomeDisplayMode)}
          data={[
            {
              value: 'auto',
              label: 'è‡ªå‹•',
            },
            {
              value: 'card',
              label: (
                <Group gap={6} wrap="nowrap">
                  <IconLayoutGrid size={16} />
                  <span>ã‚«ãƒ¼ãƒ‰</span>
                </Group>
              ),
            },
            {
              value: 'dial',
              label: (
                <Group gap={6} wrap="nowrap">
                  <IconCircleDot size={16} />
                  <span>ãƒ€ã‚¤ã‚¢ãƒ«</span>
                </Group>
              ),
            },
          ]}
          size="sm"
        />
      </Box>
      
      {/* è¨­å®šãƒœã‚¿ãƒ³ */}
      <Tooltip label="è¨­å®šã‚’é–‹ã" position="left">
        <ActionIcon
          variant="light"
          color="gray"
          size="lg"
          onClick={onSettingsClick}
        >
          <IconSettings size={20} />
        </ActionIcon>
      </Tooltip>
    </Group>
  );
}
````

## File: frontend/src/components/dashboard/HexIconButton.module.css
````css
/* å…­è§’å½¢ã‚¢ã‚¤ã‚³ãƒ³ãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ« */

.hexContainer {
  position: relative;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

/* å…­è§’å½¢ã®å¤–æ ï¼ˆSVGã§æç”»ï¼‰ */
.hexBorder {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 0;
}

.hexBorderPath {
  fill: none;
  stroke: #d1d5db;
  stroke-width: 1.5;
  transition: stroke 0.15s ease, stroke-width 0.15s ease;
}

/* é¸æŠæ™‚ã®å¤–æ ã‚¹ã‚¿ã‚¤ãƒ« */
.hexBorder.selected .hexBorderPath {
  stroke: var(--hex-color, #2563EB);
  stroke-width: 2;
}

/* ãƒ›ãƒãƒ¼æ™‚ã®å¤–æ ã‚¹ã‚¿ã‚¤ãƒ« */
.hexBorder.hovered .hexBorderPath {
  stroke: var(--hex-color, #2563EB);
  stroke-width: 1.5;
}

.hexButton {
  position: relative;
  border: none;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background 0.15s ease, box-shadow 0.15s ease, transform 0.15s ease;
  padding: 0;
  z-index: 1;
  
  /* å…­è§’å½¢ã®ã‚¯ãƒªãƒƒãƒ—ãƒ‘ã‚¹ */
  clip-path: polygon(
    25% 6.7%,
    75% 6.7%,
    100% 50%,
    75% 93.3%,
    25% 93.3%,
    0% 50%
  );
  
  /* ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã®ãƒªã‚»ãƒƒãƒˆï¼ˆã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ãƒªãƒ³ã‚°ã‚’ä½¿ç”¨ï¼‰ */
  outline: none;
}

/* ãƒ•ã‚©ãƒ¼ã‚«ã‚¹æ™‚ã®ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ï¼ˆã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£å¯¾å¿œï¼‰ */
.hexButton:focus-visible {
  outline: 2px solid #2563EB;
  outline-offset: 2px;
}

/* ãƒ›ãƒãƒ¼æ™‚ã®ã‚¹ã‚¿ã‚¤ãƒ« */
.hexButton.hovered {
  transform: scale(1.02);
}

/* é¸æŠæ™‚ã®ã‚¹ã‚¿ã‚¤ãƒ« */
.hexButton.selected {
  transform: translateY(-2px);
}

/* ãƒãƒƒã‚¸ã®é…ç½® */
.badge {
  position: absolute;
  top: -4px;
  right: -4px;
  min-width: 16px;
  height: 16px;
  font-size: 9px;
  padding: 0;
  border: 2px solid #FFFFFF;
  pointer-events: none;
  z-index: 2;
}
````

## File: frontend/src/components/dashboard/HexIconButton.tsx
````typescript
'use client';

import { type ReactNode } from 'react';
import { Badge } from '@mantine/core';
import styles from './HexIconButton.module.css';

/**
 * å…­è§’å½¢ã‚¢ã‚¤ã‚³ãƒ³ãƒœã‚¿ãƒ³ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
 */
export interface HexIconButtonProps {
  /** å¤–æ¥å††åŸºæº–ã®ã‚µã‚¤ã‚ºï¼ˆpxï¼‰ */
  size: number;
  /** é¸æŠçŠ¶æ…‹ */
  selected?: boolean;
  /** ãƒ›ãƒãƒ¼çŠ¶æ…‹ */
  hovered?: boolean;
  /** èƒŒæ™¯è‰²ï¼ˆé¸æŠæ™‚ï¼‰*/
  color?: string;
  /** ãƒãƒƒã‚¸è¡¨ç¤ºå†…å®¹ */
  badge?: string | number;
  /** ä¸­å¤®ã«è¡¨ç¤ºã™ã‚‹ã‚¢ã‚¤ã‚³ãƒ³ */
  children: ReactNode;
  /** ã‚¯ãƒªãƒƒã‚¯ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ */
  onClick?: () => void;
}

/**
 * å…­è§’å½¢ã®SVGãƒ‘ã‚¹ã‚’ç”Ÿæˆ
 * clip-pathã¨åŒã˜åº§æ¨™ç³»ã‚’ä½¿ç”¨
 */
function getHexPath(size: number): string {
  // clip-pathã®åº§æ¨™ã‚’SVGç”¨ã«å¤‰æ›
  // clip-path: polygon(25% 6.7%, 75% 6.7%, 100% 50%, 75% 93.3%, 25% 93.3%, 0% 50%)
  const points = [
    [0.25 * size, 0.067 * size],  // å·¦ä¸Š
    [0.75 * size, 0.067 * size],  // å³ä¸Š
    [1.0 * size, 0.5 * size],     // å³
    [0.75 * size, 0.933 * size],  // å³ä¸‹
    [0.25 * size, 0.933 * size],  // å·¦ä¸‹
    [0.0 * size, 0.5 * size],     // å·¦
  ];
  
  const pathData = points
    .map((point, i) => `${i === 0 ? 'M' : 'L'} ${point[0]} ${point[1]}`)
    .join(' ');
  
  return `${pathData} Z`;
}

/**
 * å…­è§’å½¢ã®ã‚¢ã‚¤ã‚³ãƒ³ãƒœã‚¿ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * CSS clip-path ã‚’ä½¿ç”¨ã—ã¦å…­è§’å½¢ã‚’æç”»ã—ã€SVGã§æ ç·šã‚’è¡¨ç¤º
 */
export function HexIconButton({
  size,
  selected = false,
  hovered = false,
  color = '#2563EB',
  badge,
  children,
  onClick,
}: HexIconButtonProps) {
  // é¸æŠçŠ¶æ…‹ã«å¿œã˜ãŸèƒŒæ™¯è‰²
  const backgroundColor = selected
    ? color
    : hovered
      ? `${color}15` // è‰²ã«é€æ˜åº¦ã‚’ä»˜ä¸
      : '#FFFFFF';

  // é¸æŠçŠ¶æ…‹ã«å¿œã˜ãŸã‚¢ã‚¤ã‚³ãƒ³è‰²
  const iconColor = selected ? '#FFFFFF' : color;

  // é¸æŠçŠ¶æ…‹ã«å¿œã˜ãŸå½±ï¼ˆ40%ã®é€æ˜åº¦ï¼‰
  const getBoxShadow = () => {
    if (!selected) {
      return '0 2px 8px rgba(0, 0, 0, 0.08)';
    }
    // colorã‚’RGBAã«å¤‰æ›ã—ã¦é€æ˜åº¦ã‚’è¿½åŠ 
    const rgb = color.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
    if (rgb) {
      const r = parseInt(rgb[1], 16);
      const g = parseInt(rgb[2], 16);
      const b = parseInt(rgb[3], 16);
      return `0 4px 12px rgba(${r}, ${g}, ${b}, 0.4)`;
    }
    return `0 4px 12px ${color}`;
  };

  const boxShadow = getBoxShadow();

  // ãƒãƒƒã‚¸ã®è¡¨ç¤ºåˆ¤å®šï¼ˆ0ã¯è¡¨ç¤ºã€undefined/null/ç©ºæ–‡å­—ã¯éè¡¨ç¤ºï¼‰
  const shouldShowBadge = badge !== undefined && badge !== null && badge !== '';

  // å…­è§’å½¢ã®æ ç·šã‚¯ãƒ©ã‚¹
  const hexBorderClass = `${styles.hexBorder} ${selected ? styles.selected : ''} ${hovered ? styles.hovered : ''}`;

  return (
    <div
      className={styles.hexContainer}
      style={{
        width: size,
        height: size,
        '--hex-color': color,
      } as React.CSSProperties}
    >
      {/* å…­è§’å½¢ã®å¤–æ ï¼ˆSVGï¼‰ */}
      <svg
        className={hexBorderClass}
        viewBox={`0 0 ${size} ${size}`}
        preserveAspectRatio="xMidYMid meet"
      >
        <path
          className={styles.hexBorderPath}
          d={getHexPath(size)}
        />
      </svg>

      <button
        type="button"
        className={`${styles.hexButton} ${selected ? styles.selected : ''} ${hovered ? styles.hovered : ''}`}
        style={{
          width: size * 0.92, // æ ç·šã®å†…å´ã«åã¾ã‚‹ã‚ˆã†ã«ã‚„ã‚„å°ã•ã
          height: size * 0.92,
          backgroundColor,
          boxShadow,
          color: iconColor,
        }}
        onClick={onClick}
        aria-label="ã‚¢ã‚¤ã‚³ãƒ³ãƒœã‚¿ãƒ³"
        aria-pressed={selected}
      >
        {children}
      </button>

      {shouldShowBadge && (
        <Badge
          variant="filled"
          color="red"
          size="sm"
          circle
          className={styles.badge}
        >
          {badge}
        </Badge>
      )}
    </div>
  );
}
````

## File: frontend/src/components/editable-field/editable-field.tsx
````typescript
'use client';

import { useState, useEffect, useRef } from 'react';
import { Box, Text } from '@mantine/core';
import { IconEdit } from '@tabler/icons-react';

interface EditableFieldProps {
  value: string | number | null | undefined;
  label?: string;
  onEdit: () => void;
  editable?: boolean;
  displayFormat?: (value: string | number | null | undefined) => string;
  style?: React.CSSProperties;
  size?: 'xs' | 'sm' | 'md' | 'lg' | 'xl';
}

export function EditableField({
  value,
  label,
  onEdit,
  editable = true,
  displayFormat,
  style,
  size = 'sm',
}: EditableFieldProps) {
  const [isHovered, setIsHovered] = useState(false);
  const [showEditIcon, setShowEditIcon] = useState(false);
  const lastTapRef = useRef<number>(0);
  const tapTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const displayValue = displayFormat ? displayFormat(value) : (value?.toString() || '-');

  // ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handleDoubleClick = () => {
    if (editable) {
      onEdit();
    }
  };

  // ãƒ¢ãƒã‚¤ãƒ«å‘ã‘ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handleTouchEnd = (e: React.TouchEvent) => {
    if (!editable) return;

    const now = Date.now();
    const timeSinceLastTap = now - lastTapRef.current;

    if (timeSinceLastTap < 300 && timeSinceLastTap > 0) {
      // ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—æ¤œçŸ¥
      e.preventDefault();
      onEdit();
      lastTapRef.current = 0;
      if (tapTimeoutRef.current) {
        clearTimeout(tapTimeoutRef.current);
        tapTimeoutRef.current = null;
      }
    } else {
      lastTapRef.current = now;
      // 300mså¾Œã«ãƒªã‚»ãƒƒãƒˆ
      if (tapTimeoutRef.current) {
        clearTimeout(tapTimeoutRef.current);
      }
      tapTimeoutRef.current = setTimeout(() => {
        lastTapRef.current = 0;
      }, 300);
    }
  };

  // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
  useEffect(() => {
    return () => {
      if (tapTimeoutRef.current) {
        clearTimeout(tapTimeoutRef.current);
      }
    };
  }, []);

  // ãƒ›ãƒãƒ¼æ™‚ã«å°‘ã—é…å»¶ã—ã¦ã‚¢ã‚¤ã‚³ãƒ³è¡¨ç¤º
  useEffect(() => {
    if (isHovered) {
      const timer = setTimeout(() => setShowEditIcon(true), 200);
      return () => clearTimeout(timer);
    } else {
      setShowEditIcon(false);
    }
  }, [isHovered]);

  return (
    <Box
      onDoubleClick={handleDoubleClick}
      onTouchEnd={handleTouchEnd}
      onMouseEnter={() => editable && setIsHovered(true)}
      onMouseLeave={() => editable && setIsHovered(false)}
      style={{
        cursor: editable ? 'pointer' : 'default',
        padding: '4px 8px',
        borderRadius: '4px',
        transition: 'all 0.2s ease',
        backgroundColor: isHovered ? 'var(--mantine-color-gray-0)' : 'transparent',
        border: `1px solid ${isHovered ? 'var(--mantine-color-gray-3)' : 'transparent'}`,
        position: 'relative',
        display: 'inline-block',
        minWidth: '50px',
        ...style,
      }}
      title={editable ? 'ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§ç·¨é›†' : undefined}
    >
      {label && (
        <Text size="xs" c="dimmed" mb={2}>
          {label}
        </Text>
      )}
      <Box style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
        <Text size={size} style={{ flex: 1 }}>
          {displayValue}
        </Text>
        {showEditIcon && (
          <IconEdit
            size={14}
            style={{
              color: 'var(--mantine-color-gray-6)',
              opacity: 0.6,
              transition: 'opacity 0.2s ease',
            }}
          />
        )}
      </Box>
    </Box>
  );
}
````

## File: frontend/src/components/forms/ColorInputField.tsx
````typescript
import { TextInput, TextInputProps } from '@mantine/core';
import { FormField } from './FormField';

export interface ColorInputFieldProps extends Omit<TextInputProps, 'value' | 'onChange'> {
  value: string | undefined;
  onChange: (value: string | undefined) => void;
  label?: React.ReactNode;
  description?: React.ReactNode;
  error?: React.ReactNode;
  required?: boolean;
}

/**
 * ã‚·ãƒ³ãƒ—ãƒ«ãªã‚«ãƒ©ãƒ¼/æŸ„å…¥åŠ›ã€‚å°†æ¥çš„ã«ã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼å·®ã—æ›¿ãˆå¯èƒ½ã€‚
 */
export function ColorInputField({
  value,
  onChange,
  label,
  description,
  error,
  required,
  ...rest
}: ColorInputFieldProps) {
  return (
    <FormField label={label} description={description} error={error} required={required}>
      <TextInput
        value={value || ''}
        onChange={(e) => onChange(e.target.value || undefined)}
        placeholder="ä¾‹: èŒ¶ãƒˆãƒ©ã€ä¸‰æ¯›"
        {...rest}
      />
    </FormField>
  );
}
````

## File: frontend/src/components/forms/DateInputField.tsx
````typescript
import { DateInput, DateInputProps } from '@mantine/dates';
import { FormField } from './FormField';

export interface DateInputFieldProps extends Omit<DateInputProps, 'value' | 'onChange'> {
  value: string | undefined;
  onChange: (value: string | undefined) => void;
  label?: React.ReactNode;
  description?: React.ReactNode;
  error?: React.ReactNode;
  required?: boolean;
}

export function DateInputField({
  value,
  onChange,
  label,
  description,
  error,
  required,
  ...rest
}: DateInputFieldProps) {
  return (
    <FormField label={label} description={description} error={error} required={required}>
      <DateInput
        value={value ? new Date(value) : null}
        // Mantine DateInput ã® onChangeå‹(DateStringValue | null)ã«å³å¯†åŒ–
        onChange={(d: string | null) => {
          let dateVal: Date | null = null;
          if (typeof d === 'string') {
            const parsed = new Date(d);
            dateVal = isNaN(parsed.getTime()) ? null : parsed;
          }
          onChange(dateVal ? dateVal.toISOString().split('T')[0] : undefined);
        }}
        valueFormat="YYYY-MM-DD"
        {...rest}
      />
    </FormField>
  );
}
````

## File: frontend/src/components/forms/FormField.tsx
````typescript
import { Box, Text } from '@mantine/core';
import { ReactNode } from 'react';

export interface FormFieldProps {
  label?: ReactNode;
  description?: ReactNode;
  error?: ReactNode;
  children: ReactNode;
  required?: boolean;
  spacing?: string | number;
}

/**
 * å…±é€šãƒ•ã‚©ãƒ¼ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãƒ©ãƒƒãƒ‘
 * - ãƒ©ãƒ™ãƒ«
 * - èª¬æ˜
 * - ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æœ¬ä½“ (children)
 * - ã‚¨ãƒ©ãƒ¼ï¼ˆå¸¸ã«ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ç›´ä¸‹ã«è¡¨ç¤ºï¼‰
 */
export function FormField({
  label,
  description,
  error,
  children,
  required,
  spacing = '0.5rem',
}: FormFieldProps) {
  return (
    <Box style={{ width: '100%' }}>
      {label && (
        <Box style={{ marginBottom: '0.25rem', display: 'flex', alignItems: 'center', gap: 4 }}>
          <Text size="sm" fw={600} style={{ lineHeight: 1.2 }}>
            {label}
            {required && <Text component="span" c="red" ml={4}>*</Text>}
          </Text>
        </Box>
      )}
      {description && (
        <Text size="xs" c="dimmed" mb={4}>
          {description}
        </Text>
      )}
      <Box style={{ marginBottom: error ? '0.35rem' : spacing }}>
        {children}
      </Box>
      {error && (
        <Text size="xs" c="red" style={{ fontWeight: 500 }}>
          {error}
        </Text>
      )}
    </Box>
  );
}
````

## File: frontend/src/components/forms/MasterDataCombobox.tsx
````typescript
'use client';

import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import {
  ActionIcon,
  Combobox,
  Group,
  InputBase,
  Loader,
  ScrollArea,
  Text,
  useCombobox,
} from '@mantine/core';
import { IconHistory, IconSelector, IconX } from '@tabler/icons-react';
import { FormField } from '@/components/forms/FormField';
import type { MasterOption } from '@/lib/master-data/master-options';

const DEFAULT_INPUT_SANITIZE_REGEX = /[^0-9a-zA-Z]/g;
export const ALPHANUM_SPACE_HYPHEN_PATTERN = /[^0-9a-zA-Z -]/g;
const MAX_VISIBLE_OPTIONS = 50;

export interface MasterDataComboboxProps {
  label: string;
  placeholder?: string;
  value?: string;
  onChange: (value: string | undefined) => void;
  options: MasterOption[];
  historyItems?: MasterOption[];
  required?: boolean;
  error?: string;
  description?: string;
  disabled?: boolean;
  loading?: boolean;
  historyLabel?: string;
  nothingFoundLabel?: string;
  onOptionSelected?: (option: MasterOption | undefined) => void;
  sanitizePattern?: RegExp;
}

function sanitizeInput(value: string, pattern: RegExp) {
  return value.replace(pattern, '');
}

function formatOptionLabel(option?: MasterOption | null) {
  if (!option) {
    return '';
  }

  if (option.code === undefined) {
    return option.label;
  }

  return `${option.label}:${option.code}`;
}

function computeMatchPriority(option: MasterOption, keyword: string): number | null {
  if (!keyword) {
    return 0;
  }

  const label = option.label.toLowerCase();
  const value = option.value.toLowerCase();
  const code = option.code !== undefined ? option.code.toString() : '';

  if (label === keyword || value === keyword || code === keyword) {
    return 0;
  }

  if (label.startsWith(keyword) || value.startsWith(keyword) || code.startsWith(keyword)) {
    return 1;
  }

  if (label.includes(keyword) || value.includes(keyword) || code.includes(keyword)) {
    return 2;
  }

  return null;
}

function findOptionByValue(value: string | undefined, options: MasterOption[], history?: MasterOption[]) {
  if (!value) {
    return undefined;
  }
  return options.find((item) => item.value === value) ?? history?.find((item) => item.value === value);
}

export function MasterDataCombobox({
  label,
  placeholder = 'ã‚³ãƒ¼ãƒ‰ã¾ãŸã¯åç§°ã‚’å…¥åŠ›',
  value,
  onChange,
  options,
  historyItems,
  required,
  error,
  description = 'åŠè§’è‹±æ•°å­—ã®ã¿å…¥åŠ›ã§ãã¾ã™ã€‚å…¥åŠ›ã™ã‚‹ã¨å€™è£œãŒçµã‚Šè¾¼ã¾ã‚Œã¾ã™ã€‚',
  disabled,
  loading,
  historyLabel = 'æœ€è¿‘ã®é¸æŠ',
  nothingFoundLabel = 'ä¸€è‡´ã™ã‚‹å€™è£œãŒã‚ã‚Šã¾ã›ã‚“',
  onOptionSelected,
  sanitizePattern,
}: MasterDataComboboxProps) {
  const combobox = useCombobox({
    onDropdownClose: () => combobox.resetSelectedOption(),
    onDropdownOpen: () => combobox.updateSelectedOptionIndex('active'),
  });

  const [inputValue, setInputValue] = useState('');
  const prevValueRef = useRef<string | undefined>(undefined);
  const effectiveSanitizePattern = sanitizePattern ?? DEFAULT_INPUT_SANITIZE_REGEX;

  useEffect(() => {
    if (prevValueRef.current === value) {
      return;
    }
    const option = findOptionByValue(value, options, historyItems);
    setInputValue(formatOptionLabel(option));
    prevValueRef.current = value;
  }, [value, options, historyItems]);

  const filteredOptions = useMemo(() => {
    if (!inputValue) {
      return options.slice(0, MAX_VISIBLE_OPTIONS);
    }
    const keyword = inputValue.trim().toLowerCase();
    if (!keyword) {
      return options.slice(0, MAX_VISIBLE_OPTIONS);
    }

    const matches = options
      .map((option) => ({ option, priority: computeMatchPriority(option, keyword) }))
      .filter((entry): entry is { option: MasterOption; priority: number } => entry.priority !== null)
      .sort((a, b) => {
        if (a.priority !== b.priority) {
          return a.priority - b.priority;
        }
        return a.option.label.localeCompare(b.option.label, 'ja');
      })
      .slice(0, MAX_VISIBLE_OPTIONS)
      .map((entry) => entry.option);

    return matches;
  }, [inputValue, options]);

  const handleInputChange = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    const sanitized = sanitizeInput(event.currentTarget.value, effectiveSanitizePattern);
    setInputValue(sanitized);
    combobox.openDropdown();
  }, [combobox, effectiveSanitizePattern]);

  const handleOptionSubmit = useCallback((optionValue: string) => {
    const option = findOptionByValue(optionValue, options, historyItems);
    onChange(option?.value);
    onOptionSelected?.(option);
    setInputValue(formatOptionLabel(option));
    combobox.closeDropdown();
  }, [historyItems, onChange, onOptionSelected, options, combobox]);

  const handleClear = useCallback(() => {
    onChange(undefined);
    onOptionSelected?.(undefined);
    setInputValue('');
    combobox.openDropdown();
  }, [combobox, onChange, onOptionSelected]);

  const nothingFound = loading ? (
    <Group gap="xs" px="xs">
      <Loader size="xs" />
      <Text size="sm">èª­ã¿è¾¼ã¿ä¸­...</Text>
    </Group>
  ) : (
    <Text size="sm" c="dimmed" px="xs">
      {nothingFoundLabel}
    </Text>
  );

  const showHistory = (historyItems?.length ?? 0) > 0;

  return (
    <FormField label={label} description={description} error={error} required={required}>
      <Combobox store={combobox} onOptionSubmit={handleOptionSubmit} disabled={disabled} withinPortal={false}>
        <Combobox.Target>
          <InputBase
            value={inputValue}
            onChange={handleInputChange}
            onFocus={() => combobox.openDropdown()}
            onClick={() => combobox.openDropdown()}
            placeholder={placeholder}
            disabled={disabled}
            styles={{
              input: {
                height: '36px',
                paddingTop: '0',
                paddingBottom: '0',
                lineHeight: '36px',
              },
            }}
            rightSection={(
              <Group gap={4} wrap="nowrap">
                {value && !disabled && (
                  <ActionIcon
                    size="sm"
                    variant="subtle"
                    onMouseDown={(event) => event.preventDefault()}
                    onClick={handleClear}
                    aria-label={`${label}ã‚’ã‚¯ãƒªã‚¢`}
                  >
                    <IconX size={14} stroke={1.5} />
                  </ActionIcon>
                )}
                {loading ? <Loader size="xs" /> : <IconSelector size={16} stroke={1.5} />}
              </Group>
            )}
            rightSectionPointerEvents="auto"
            data-autofocus={false}
          />
        </Combobox.Target>

        <Combobox.Dropdown>
          <ScrollArea.Autosize mah={280} type="always">
            <Combobox.Options>
              {showHistory && (
                <Combobox.Group label={historyLabel}>
                  {historyItems?.map((item) => (
                    <Combobox.Option value={item.value} key={`history-${item.value}`}>
                      <Group gap="xs">
                        <IconHistory size={14} />
                        <Text size="sm" fw={500}>
                          {formatOptionLabel(item)}
                        </Text>
                      </Group>
                    </Combobox.Option>
                  ))}
                </Combobox.Group>
              )}

              {filteredOptions.length > 0 ? (
                <Combobox.Group label="å€™è£œ">
                  {filteredOptions.map((item) => (
                    <Combobox.Option value={item.value} key={item.value}>
                      <Text size="sm" fw={500}>
                        {formatOptionLabel(item)}
                      </Text>
                    </Combobox.Option>
                  ))}
                </Combobox.Group>
              ) : (
                <Combobox.Empty>{nothingFound}</Combobox.Empty>
              )}
            </Combobox.Options>
          </ScrollArea.Autosize>
        </Combobox.Dropdown>
      </Combobox>
    </FormField>
  );
}
````

## File: frontend/src/components/pedigrees/__tests__/PedigreeFamilyTree.test.tsx
````typescript
import { isFamilyTreeData, type FamilyTreeData } from '../PedigreeFamilyTree';

const createNode = (
  id: string,
  father: FamilyTreeData | null = null,
  mother: FamilyTreeData | null = null,
): FamilyTreeData => ({
  id,
  pedigreeId: `ped-${id}`,
  catName: `Cat ${id}`,
  breedCode: null,
  gender: null,
  birthDate: null,
  coatColorCode: null,
  breed: null,
  color: null,
  father,
  mother,
});

describe('isFamilyTreeData', () => {
  afterEach(() => {
    jest.restoreAllMocks();
  });

  it('æœ‰åŠ¹ãªå®¶ç³»å›³ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œè¨¼ã§ãã‚‹', () => {
    const tree = createNode('root', createNode('father'), createNode('mother'));

    expect(isFamilyTreeData(tree)).toBe(true);
  });

  it('ç„¡åŠ¹ãªå‹ã¯ false ã‚’è¿”ã™', () => {
    expect(isFamilyTreeData('invalid')).toBe(false);
  });

  it('æ·±åº¦ãŒä¸Šé™ã‚’è¶…ãˆã‚‹å ´åˆã¯è­¦å‘Šã—ã¤ã¤æ¤œè¨¼ã‚’ç¶™ç¶šã™ã‚‹', () => {
    const deepTree = createNode(
      'root',
      createNode('f1', createNode('f2', createNode('f3', createNode('f4')))),
      null,
    );
    const warnSpy = jest.spyOn(console, 'warn').mockImplementation(() => {});

    expect(isFamilyTreeData(deepTree)).toBe(true);
    expect(warnSpy).toHaveBeenCalled();
  });

  it('null ã‚„ undefined ã¯ç„¡åŠ¹ã¨åˆ¤å®šã™ã‚‹', () => {
    expect(isFamilyTreeData(null)).toBe(false);
    expect(isFamilyTreeData(undefined)).toBe(false);
  });
});
````

## File: frontend/src/components/pedigrees/__tests__/PedigreeList.test.tsx
````typescript
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { MantineProvider } from '@mantine/core';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import type { ReactElement } from 'react';

import { PedigreeList } from '../PedigreeList';
import type { PedigreeListResponse } from '@/lib/api/hooks/use-pedigrees';
import { apiClient } from '@/lib/api/client';

let pushMock: jest.Mock<void, [string]>;

jest.mock('next/navigation', () => ({
  useRouter: () => ({
    push: (href: string) => pushMock(href),
  }),
}));

describe('PedigreeList', () => {
  const renderWithProviders = (ui: ReactElement) => {
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          retry: false,
        },
      },
    });

    return render(
      <QueryClientProvider client={queryClient}>
        <MantineProvider>{ui}</MantineProvider>
      </QueryClientProvider>,
    );
  };

  beforeEach(() => {
    pushMock = jest.fn<void, [string]>();
  });

  afterEach(() => {
    jest.clearAllMocks();
    jest.restoreAllMocks();
  });

  it('ã‚³ãƒ”ãƒ¼ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨ register ã¸é·ç§»ã™ã‚‹', async () => {
    const response: PedigreeListResponse = {
      success: true,
      data: [
        {
          id: 'p-1',
          pedigreeId: 'WCA-0001',
          catName: 'ãƒ†ã‚¹ãƒˆçŒ«',
          breedCode: 1,
          genderCode: 1,
          birthDate: '2025-01-01',
          breederName: 'ç¹æ®–è€…',
          ownerName: 'é£¼ã„ä¸»',
          registrationDate: '2025-02-01',
        },
      ],
      meta: {
        total: 1,
        page: 1,
        limit: 20,
        totalPages: 1,
      },
    };

    jest.spyOn(apiClient, 'get').mockResolvedValue(response);

    renderWithProviders(<PedigreeList />);

    await screen.findByLabelText('æ–°è¦ç™»éŒ²ã«ã‚³ãƒ”ãƒ¼');

    const user = userEvent.setup();
    await user.click(screen.getByLabelText('æ–°è¦ç™»éŒ²ã«ã‚³ãƒ”ãƒ¼'));

    expect(pushMock).toHaveBeenCalledWith(
      '/pedigrees?tab=register&copyFromId=p-1',
    );
  });

  it('å®¶ç³»å›³ã‚’è¦‹ã‚‹ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨ onSelectFamilyTree ãŒå‘¼ã°ã‚Œã‚‹', async () => {
    const response: PedigreeListResponse = {
      success: true,
      data: [
        {
          id: 'p-2',
          pedigreeId: 'WCA-0002',
          catName: 'ãƒ†ã‚¹ãƒˆçŒ«2',
        },
      ],
      meta: {
        total: 1,
        page: 1,
        limit: 20,
        totalPages: 1,
      },
    };

    jest.spyOn(apiClient, 'get').mockResolvedValue(response);

    const onSelectFamilyTree = jest.fn<void, [string]>();

    renderWithProviders(<PedigreeList onSelectFamilyTree={onSelectFamilyTree} />);

    await screen.findByLabelText('å®¶ç³»å›³ã‚’è¦‹ã‚‹');

    const user = userEvent.setup();
    await user.click(screen.getByLabelText('å®¶ç³»å›³ã‚’è¦‹ã‚‹'));

    expect(onSelectFamilyTree).toHaveBeenCalledWith('p-2');
  });

  it('è¡€çµ±æ›¸PDFã‚’å°åˆ·ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨PDFã‚’æ–°è¦ã‚¿ãƒ–ã§é–‹ã', async () => {
    const response: PedigreeListResponse = {
      success: true,
      data: [
        {
          id: 'p-3',
          pedigreeId: 'WCA-0003',
          catName: 'ãƒ†ã‚¹ãƒˆçŒ«3',
        },
      ],
      meta: {
        total: 1,
        page: 1,
        limit: 20,
        totalPages: 1,
      },
    };

    jest.spyOn(apiClient, 'get').mockResolvedValue(response);

    const originalApiUrl = process.env.NEXT_PUBLIC_API_URL;
    process.env.NEXT_PUBLIC_API_URL = 'http://example.test';

    const openSpy = jest.spyOn(window, 'open').mockImplementation(() => window);

    renderWithProviders(<PedigreeList />);

    await screen.findByLabelText('è¡€çµ±æ›¸PDFã‚’å°åˆ·');

    const user = userEvent.setup();
    await user.click(screen.getByLabelText('è¡€çµ±æ›¸PDFã‚’å°åˆ·'));

    expect(openSpy).toHaveBeenCalledWith(
      'http://example.test/api/v1/pedigrees/pedigree-id/WCA-0003/pdf',
      '_blank',
    );

    openSpy.mockRestore();
    if (typeof originalApiUrl === 'string') {
      process.env.NEXT_PUBLIC_API_URL = originalApiUrl;
    } else {
      delete process.env.NEXT_PUBLIC_API_URL;
    }
  });
});
````

## File: frontend/src/components/pedigrees/__tests__/PedigreeRegistrationForm.callid.test.tsx
````typescript
import { MantineProvider } from '@mantine/core';
import { act, fireEvent, render, screen, waitFor } from '@testing-library/react';

import { PedigreeRegistrationForm } from '../PedigreeRegistrationForm';
import { apiClient } from '@/lib/api/client';
import type { PedigreeRecord } from '@/lib/api/hooks/use-pedigrees';

type Deferred<T> = {
  promise: Promise<T>;
  resolve: (value: T) => void;
};

const createDeferred = <T,>(): Deferred<T> => {
  let resolve!: (value: T) => void;
  const promise = new Promise<T>((res) => {
    resolve = res;
  });
  return { promise, resolve };
};

jest.mock('next/navigation', () => ({
  useRouter: () => ({
    push: jest.fn(),
    back: jest.fn(),
  }),
  useSearchParams: () => ({
    get: () => null,
  }),
}));

jest.mock('@mantine/notifications', () => ({
  notifications: {
    show: jest.fn(),
  },
}));

jest.mock('@/lib/api/hooks/use-pedigrees', () => {
  return {
    useCreatePedigree: () => ({ mutateAsync: jest.fn() }),
    useUpdatePedigree: () => ({ mutateAsync: jest.fn() }),
    useGetPedigree: () => ({ data: null }),
    useGetPedigreeByNumber: () => ({ data: null, isLoading: false }),
  };
});

jest.mock('@/lib/api/client', () => {
  return {
    apiClient: {
      get: jest.fn(),
      post: jest.fn(),
      patch: jest.fn(),
      delete: jest.fn(),
    },
  };
});

describe('PedigreeRegistrationForm CallID', () => {
  const mockedGet = apiClient.get as jest.MockedFunction<typeof apiClient.get>;

  beforeEach(() => {
    jest.useFakeTimers();
    mockedGet.mockReset();
  });

  afterEach(() => {
    jest.useRealTimers();
    jest.restoreAllMocks();
  });

  it('ä¸¡è¦ªIDã®CallIDã§ã€ç¬¬3ä¸–ä»£ï¼ˆæ›¾ç¥–çˆ¶æ¯ï¼‰ã¾ã§å€¤ãŒåæ˜ ã•ã‚Œã‚‹', async () => {
    const breedsDeferred = createDeferred<{ success: boolean; data: [] }>();
    const coatColorsDeferred = createDeferred<{ success: boolean; data: [] }>();
    const gendersDeferred = createDeferred<{ success: boolean; data: [] }>();

    const callResult: PedigreeRecord = {
      id: 'p-1',
      pedigreeId: 'WCA-0001',
      catName: 'ãƒ†ã‚¹ãƒˆçŒ«',

      fatherTitle: 'SireTitle',
      fatherCatName: 'SireName',
      motherTitle: 'DamTitle',
      motherCatName: 'DamName',

      ffCatName: 'FFName',
      fmCatName: 'FMName',
      mfCatName: 'MFName',
      mmCatName: 'MMName',

      fffCatName: 'FFFName',
      ffmCatName: 'FFMName',
      fmfCatName: 'FMFName',
      fmmCatName: 'FMMName',
      mffCatName: 'MFFName',
      mfmCatName: 'MFMName',
      mmfCatName: 'MMFName',
      mmmCatName: 'MMMName',

      fffjcu: 'FFF-NO',
      mmmjcu: 'MMM-NO',
    };

    mockedGet.mockImplementation(async (path: string, options?: { pathParams?: { pedigreeId?: string } }) => {
      if (path === '/breeds') return breedsDeferred.promise;
      if (path === '/coat-colors') return coatColorsDeferred.promise;
      if (path === '/master/genders') return gendersDeferred.promise;

      if (path === '/pedigrees/pedigree-id/{pedigreeId}' && options?.pathParams?.pedigreeId === 'ABCDE') {
        return { success: true, data: callResult };
      }

      return { success: true, data: null };
    });

    render(
      <MantineProvider>
        <PedigreeRegistrationForm />
      </MantineProvider>,
    );

    await act(async () => {
      breedsDeferred.resolve({ success: true, data: [] });
      coatColorsDeferred.resolve({ success: true, data: [] });
      gendersDeferred.resolve({ success: true, data: [] });
    });

    expect(await screen.findByText('Call ID')).toBeInTheDocument();

    const bothInput = screen.getByLabelText('ä¸¡è¦ªID');
    fireEvent.change(bothInput, { target: { value: 'ABCDE' } });

    await act(async () => {
      jest.advanceTimersByTime(800);
    });

    await waitFor(() => {
      expect(mockedGet).toHaveBeenCalledWith('/pedigrees/pedigree-id/{pedigreeId}', {
        pathParams: { pedigreeId: 'ABCDE' },
      });
    });

    expect(screen.getByLabelText('çˆ¶è¦ªå')).toHaveValue('SireName');
    expect(screen.getByLabelText('æ¯è¦ªå')).toHaveValue('DamName');

    // ç¬¬3ä¸–ä»£ï¼ˆæ›¾ç¥–çˆ¶æ¯ï¼‰
    expect(screen.getByLabelText('FFFåå‰')).toHaveValue('FFFName');
    expect(screen.getByLabelText('MMMåå‰')).toHaveValue('MMMName');
    expect(screen.getByLabelText('FFFãƒŠãƒ³ãƒãƒ¼')).toHaveValue('FFF-NO');
    expect(screen.getByLabelText('MMMãƒŠãƒ³ãƒãƒ¼')).toHaveValue('MMM-NO');
  }, 20000);

  it('CallIDã¯5æ–‡å­—æœªæº€ã ã¨APIå‘¼ã³å‡ºã—ã•ã‚Œãªã„ï¼ˆãƒ‡ãƒã‚¦ãƒ³ã‚¹å«ã‚€ï¼‰', async () => {
    const breedsDeferred = createDeferred<{ success: boolean; data: [] }>();
    const coatColorsDeferred = createDeferred<{ success: boolean; data: [] }>();
    const gendersDeferred = createDeferred<{ success: boolean; data: [] }>();

    let callIdFetched = false;

    mockedGet.mockImplementation(async (path: string) => {
      if (path === '/breeds') return breedsDeferred.promise;
      if (path === '/coat-colors') return coatColorsDeferred.promise;
      if (path === '/master/genders') return gendersDeferred.promise;
      if (path === '/pedigrees/pedigree-id/{pedigreeId}') {
        callIdFetched = true;
        return { success: true, data: null };
      }
      return { success: true, data: null };
    });

    render(
      <MantineProvider>
        <PedigreeRegistrationForm />
      </MantineProvider>,
    );

    await act(async () => {
      breedsDeferred.resolve({ success: true, data: [] });
      coatColorsDeferred.resolve({ success: true, data: [] });
      gendersDeferred.resolve({ success: true, data: [] });
    });

    expect(await screen.findByText('Call ID')).toBeInTheDocument();

    const bothInput = screen.getByLabelText('ä¸¡è¦ªID');
    fireEvent.change(bothInput, { target: { value: 'ABCD' } });

    await act(async () => {
      jest.advanceTimersByTime(800);
    });

    expect(callIdFetched).toBe(false);
  }, 20000);
});
````

## File: frontend/src/components/pedigrees/__tests__/PedigreeRegistrationForm.create.test.tsx
````typescript
import { MantineProvider } from '@mantine/core';
import { act, render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

import { PedigreeRegistrationForm } from '../PedigreeRegistrationForm';
import { apiClient } from '@/lib/api/client';
import type { CreatePedigreeRequest } from '@/lib/api/hooks/use-pedigrees';

type Deferred<T> = {
  promise: Promise<T>;
  resolve: (value: T) => void;
};

const createDeferred = <T,>(): Deferred<T> => {
  let resolve!: (value: T) => void;
  const promise = new Promise<T>((res) => {
    resolve = res;
  });
  return { promise, resolve };
};

const pushMock = jest.fn<void, [string]>();
const backMock = jest.fn<void, []>();

jest.mock('next/navigation', () => ({
  useRouter: () => ({
    push: (href: string) => pushMock(href),
    back: () => backMock(),
  }),
  useSearchParams: () => ({
    get: () => null,
  }),
}));

const notificationsShowMock = jest.fn<void, [
  { title: string; message?: string; color?: string }
]>();

jest.mock('@mantine/notifications', () => ({
  notifications: {
    show: (payload: { title: string; message?: string; color?: string }) => notificationsShowMock(payload),
  },
}));

const createMutateAsyncMock = jest.fn<Promise<void>, [CreatePedigreeRequest]>();

jest.mock('@/lib/api/hooks/use-pedigrees', () => {
  return {
    useCreatePedigree: () => ({ mutateAsync: createMutateAsyncMock }),
    useUpdatePedigree: () => ({ mutateAsync: jest.fn() }),
    useGetPedigree: () => ({ data: null }),
    useGetPedigreeByNumber: () => ({ data: null, isLoading: false }),
  };
});

jest.mock('@/lib/api/client', () => {
  return {
    apiClient: {
      get: jest.fn(),
      post: jest.fn(),
      patch: jest.fn(),
      delete: jest.fn(),
      request: jest.fn(),
      put: jest.fn(),
    },
  };
});

describe('PedigreeRegistrationForm create smoke', () => {
  const mockedGet = apiClient.get as jest.MockedFunction<typeof apiClient.get>;

  beforeEach(() => {
    pushMock.mockReset();
    backMock.mockReset();
    notificationsShowMock.mockReset();
    createMutateAsyncMock.mockReset();
    mockedGet.mockReset();
  });

  it('è¡€çµ±æ›¸ç•ªå·ã‚’å…¥åŠ›ã—ã¦ã€Œæ–°è¦ç™»éŒ²ã€ã‚’æŠ¼ã™ã¨ createMutation ãŒå‘¼ã°ã‚Œã€onSuccess ãŒå‘¼ã°ã‚Œã‚‹', async () => {
    const breedsDeferred = createDeferred<{ success: boolean; data: [] }>();
    const coatColorsDeferred = createDeferred<{ success: boolean; data: [] }>();
    const gendersDeferred = createDeferred<{ success: boolean; data: [] }>();

    mockedGet.mockImplementation(async (path: string) => {
      if (path === '/breeds') return breedsDeferred.promise;
      if (path === '/coat-colors') return coatColorsDeferred.promise;
      if (path === '/master/genders') return gendersDeferred.promise;
      return { success: true, data: null };
    });

    createMutateAsyncMock.mockResolvedValue();

    const onSuccess = jest.fn<void, []>();

    render(
      <MantineProvider>
        <PedigreeRegistrationForm onSuccess={onSuccess} />
      </MantineProvider>,
    );

    await act(async () => {
      breedsDeferred.resolve({ success: true, data: [] });
      coatColorsDeferred.resolve({ success: true, data: [] });
      gendersDeferred.resolve({ success: true, data: [] });
    });

    const user = userEvent.setup();

    await user.type(screen.getByLabelText(/è¡€çµ±æ›¸ç•ªå·/), 'WCA-9999');

    await user.click(screen.getByRole('button', { name: 'è¡€çµ±æ›¸ã‚’ç™»éŒ²' }));
    await user.click(await screen.findByText('æ–°è¦ç™»éŒ²'));

    await waitFor(() => {
      expect(createMutateAsyncMock).toHaveBeenCalledWith(
        expect.objectContaining({ pedigreeId: 'WCA-9999' }),
      );
    });

    expect(onSuccess).toHaveBeenCalledTimes(1);
    expect(pushMock).not.toHaveBeenCalled();
  }, 20000);

  it('è¡€çµ±æ›¸ç•ªå·ãŒç©ºã®ã¾ã¾ã€Œæ–°è¦ç™»éŒ²ã€ã‚’æŠ¼ã™ã¨ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã§æ­¢ã¾ã‚Šã€createMutation ã¯å‘¼ã°ã‚Œãªã„', async () => {
    const breedsDeferred = createDeferred<{ success: boolean; data: [] }>();
    const coatColorsDeferred = createDeferred<{ success: boolean; data: [] }>();
    const gendersDeferred = createDeferred<{ success: boolean; data: [] }>();

    mockedGet.mockImplementation(async (path: string) => {
      if (path === '/breeds') return breedsDeferred.promise;
      if (path === '/coat-colors') return coatColorsDeferred.promise;
      if (path === '/master/genders') return gendersDeferred.promise;
      return { success: true, data: null };
    });

    render(
      <MantineProvider>
        <PedigreeRegistrationForm />
      </MantineProvider>,
    );

    await act(async () => {
      breedsDeferred.resolve({ success: true, data: [] });
      coatColorsDeferred.resolve({ success: true, data: [] });
      gendersDeferred.resolve({ success: true, data: [] });
    });

    const user = userEvent.setup();

    await user.click(screen.getByRole('button', { name: 'è¡€çµ±æ›¸ã‚’ç™»éŒ²' }));
    await user.click(await screen.findByText('æ–°è¦ç™»éŒ²'));

    expect(createMutateAsyncMock).not.toHaveBeenCalled();

    await waitFor(() => {
      expect(notificationsShowMock).toHaveBeenCalledWith(
        expect.objectContaining({
          title: 'ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼',
        }),
      );
    });
  }, 20000);
});
````

## File: frontend/src/components/pedigrees/__tests__/PedigreeRegistrationForm.update.test.tsx
````typescript
import { MantineProvider } from '@mantine/core';
import { act, render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

import { PedigreeRegistrationForm } from '../PedigreeRegistrationForm';
import { apiClient } from '@/lib/api/client';
import type { PedigreeRecord, UpdatePedigreeRequest } from '@/lib/api/hooks/use-pedigrees';

type Deferred<T> = {
  promise: Promise<T>;
  resolve: (value: T) => void;
};

const createDeferred = <T,>(): Deferred<T> => {
  let resolve: (value: T) => void = () => undefined;
  const promise = new Promise<T>((res) => {
    resolve = res;
  });
  return { promise, resolve };
};

const pushMock = jest.fn<void, [string]>();
const backMock = jest.fn<void, []>();

jest.mock('next/navigation', () => ({
  useRouter: () => ({
    push: (href: string) => pushMock(href),
    back: () => backMock(),
  }),
  useSearchParams: () => ({
    get: () => null,
  }),
}));

const notificationsShowMock = jest.fn<void, [
  { title: string; message?: string; color?: string }
]>();

jest.mock('@mantine/notifications', () => ({
  notifications: {
    show: (payload: { title: string; message?: string; color?: string }) =>
      notificationsShowMock(payload),
  },
}));

const updateMutateAsyncMock = jest.fn<Promise<void>, [UpdatePedigreeRequest]>();

let lastUseUpdatePedigreeId = '';

const existingRecord: PedigreeRecord = {
  id: 'p-1',
  pedigreeId: 'WCA-1234',
  catName: 'æ—¢å­˜ã®çŒ«å',
};

jest.mock('@/lib/api/hooks/use-pedigrees', () => {
  return {
    useCreatePedigree: () => ({ mutateAsync: jest.fn() }),
    useUpdatePedigree: (id: string) => {
      lastUseUpdatePedigreeId = id;
      return { mutateAsync: updateMutateAsyncMock };
    },
    useGetPedigree: () => ({ data: null }),
    useGetPedigreeByNumber: (pedigreeId: string) => ({
      data: pedigreeId === 'WCA-1234' ? existingRecord : null,
      isLoading: false,
    }),
  };
});

jest.mock('@/lib/api/client', () => {
  return {
    apiClient: {
      get: jest.fn(),
      post: jest.fn(),
      patch: jest.fn(),
      delete: jest.fn(),
      request: jest.fn(),
      put: jest.fn(),
    },
  };
});

describe('PedigreeRegistrationForm update smoke', () => {
  const mockedGet = apiClient.get as jest.MockedFunction<typeof apiClient.get>;

  beforeEach(() => {
    pushMock.mockReset();
    backMock.mockReset();
    notificationsShowMock.mockReset();
    updateMutateAsyncMock.mockReset();
    mockedGet.mockReset();
    lastUseUpdatePedigreeId = '';
  });

  it('è¡€çµ±æ›¸ç•ªå·ã®å…¥åŠ›ã§æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ãŒèª­ã¿è¾¼ã¾ã‚Œã€æ›´æ–°ã‚’æŠ¼ã™ã¨ updateMutation ãŒå‘¼ã°ã‚Œ onSuccess ãŒå‘¼ã°ã‚Œã‚‹', async () => {
    const breedsDeferred = createDeferred<{ success: boolean; data: [] }>();
    const coatColorsDeferred = createDeferred<{ success: boolean; data: [] }>();
    const gendersDeferred = createDeferred<{ success: boolean; data: [] }>();

    mockedGet.mockImplementation(async (path: string) => {
      if (path === '/breeds') return breedsDeferred.promise;
      if (path === '/coat-colors') return coatColorsDeferred.promise;
      if (path === '/master/genders') return gendersDeferred.promise;
      return { success: true, data: null };
    });

    updateMutateAsyncMock.mockResolvedValue();

    const onSuccess = jest.fn<void, []>();

    render(
      <MantineProvider>
        <PedigreeRegistrationForm onSuccess={onSuccess} />
      </MantineProvider>,
    );

    await act(async () => {
      breedsDeferred.resolve({ success: true, data: [] });
      coatColorsDeferred.resolve({ success: true, data: [] });
      gendersDeferred.resolve({ success: true, data: [] });
    });

    const user = userEvent.setup();

    await user.type(screen.getByLabelText(/è¡€çµ±æ›¸ç•ªå·/), 'WCA-1234');

    await waitFor(() => {
      expect(notificationsShowMock).toHaveBeenCalledWith(
        expect.objectContaining({ title: 'æ—¢å­˜ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ' }),
      );
    });

    // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ã‚ã‚‹ï¼ˆãƒœã‚¿ãƒ³è¡¨ç¤ºãŒæ›´æ–°ã«ãªã‚‹ï¼‰
    await screen.findByRole('button', { name: 'è¡€çµ±æ›¸ã‚’æ›´æ–°' });

    // ä½•ã‹å¤‰æ›´ã‚’å…¥ã‚Œã¦ã‹ã‚‰æ›´æ–°
    const catNameInput = screen.getByLabelText('çŒ«ã®åå‰');
    await user.clear(catNameInput);
    await user.type(catNameInput, 'æ›´æ–°å¾Œã®çŒ«å');

    await user.click(screen.getByRole('button', { name: 'è¡€çµ±æ›¸ã‚’æ›´æ–°' }));
    await user.click(await screen.findByText('æ›´æ–°'));

    await waitFor(() => {
      expect(updateMutateAsyncMock).toHaveBeenCalled();
    });

    const firstCall = updateMutateAsyncMock.mock.calls[0];
    if (!firstCall) {
      throw new Error('updateMutation ã®å‘¼ã³å‡ºã—ãŒç¢ºèªã§ãã¾ã›ã‚“ã§ã—ãŸ');
    }

    const [payload] = firstCall;

    expect(payload).toEqual(expect.objectContaining({ catName: 'æ›´æ–°å¾Œã®çŒ«å' }));
    expect(Object.prototype.hasOwnProperty.call(payload, 'pedigreeId')).toBe(false);

    // originalId ãŒåæ˜ ã•ã‚ŒãŸçŠ¶æ…‹ã§ hook ãŒå‘¼ã°ã‚Œã¦ã„ã‚‹ã“ã¨ï¼ˆåˆå›ã¯ç©ºæ–‡å­—ã«ãªã‚‹å¯èƒ½æ€§ã‚ã‚Šï¼‰
    expect(lastUseUpdatePedigreeId).toBe('p-1');

    expect(onSuccess).toHaveBeenCalledTimes(1);
    expect(pushMock).not.toHaveBeenCalled();
  }, 20000);
});
````

## File: frontend/src/components/pedigrees/__tests__/PrintSettingsEditor.test.tsx
````typescript
import { MantineProvider } from '@mantine/core';
import { act, fireEvent, render, screen, waitFor } from '@testing-library/react';

import { PrintSettingsEditor } from '../PrintSettingsEditor';

describe('PrintSettingsEditor', () => {
  const originalFetch: typeof fetch | undefined = (globalThis as { fetch?: typeof fetch }).fetch;

  const createPosition = (x: number, y: number) => ({ x, y });

  const createSettingsData = () => ({
    offsetX: 0,
    offsetY: 0,
    breed: createPosition(0, 0),
    sex: createPosition(0, 0),
    dateOfBirth: createPosition(0, 0),
    eyeColor: createPosition(0, 0),
    color: createPosition(0, 0),
    catName: { x: 0, y: 0, align: 'left' as const },
    wcaNo: { x: 0, y: 0, align: 'left' as const },
    owner: createPosition(0, 0),
    breeder: createPosition(0, 0),
    dateOfRegistration: createPosition(0, 0),
    littersM: createPosition(0, 0),
    littersF: createPosition(0, 0),
    sire: {
      name: createPosition(0, 0),
      color: createPosition(0, 0),
      eyeColor: createPosition(0, 0),
      jcu: createPosition(0, 0),
    },
    dam: {
      name: createPosition(0, 0),
      color: createPosition(0, 0),
      eyeColor: createPosition(0, 0),
      jcu: createPosition(0, 0),
    },
    grandParents: {
      ff: { name: createPosition(0, 0), color: createPosition(0, 0), jcu: createPosition(0, 0) },
      fm: { name: createPosition(0, 0), color: createPosition(0, 0), jcu: createPosition(0, 0) },
      mf: { name: createPosition(0, 0), color: createPosition(0, 0), jcu: createPosition(0, 0) },
      mm: { name: createPosition(0, 0), color: createPosition(0, 0), jcu: createPosition(0, 0) },
    },
    greatGrandParents: {
      fff: { name: createPosition(0, 0), jcu: createPosition(0, 0) },
      ffm: { name: createPosition(0, 0), jcu: createPosition(0, 0) },
      fmf: { name: createPosition(0, 0), jcu: createPosition(0, 0) },
      fmm: { name: createPosition(0, 0), jcu: createPosition(0, 0) },
      mff: { name: createPosition(0, 0), jcu: createPosition(0, 0) },
      mfm: { name: createPosition(0, 0), jcu: createPosition(0, 0) },
      mmf: { name: createPosition(0, 0), jcu: createPosition(0, 0) },
      mmm: { name: createPosition(0, 0), jcu: createPosition(0, 0) },
    },
    otherOrganizationsNo: createPosition(0, 0),
    fontSizes: {
      catName: 10,
      wcaNo: 10,
      headerInfo: 10,
      parentName: 10,
      parentDetail: 10,
      grandParentName: 10,
      grandParentDetail: 10,
      greatGrandParent: 10,
      footer: 10,
    },
  });

  afterEach(() => {
    Object.defineProperty(globalThis, 'fetch', {
      value: originalFetch,
      writable: true,
      configurable: true,
    });
    jest.restoreAllMocks();
  });

  it('è¨­å®šå–å¾—ã«å¤±æ•—ã—ãŸå ´åˆã¯ã‚¨ãƒ©ãƒ¼ã‚’è¡¨ç¤ºã™ã‚‹', async () => {
    const mockResponse = {
      ok: false,
      json: async () => ({}),
    } as Response;

    const fetchMock = jest
      .fn<Promise<Response>, Parameters<typeof fetch>>()
      .mockResolvedValue(mockResponse);

    Object.defineProperty(globalThis, 'fetch', {
      value: fetchMock,
      writable: true,
      configurable: true,
    });

    render(
      <MantineProvider>
        <PrintSettingsEditor />
      </MantineProvider>,
    );

    expect(await screen.findByText('è¨­å®šã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ')).toBeInTheDocument();
    expect(fetchMock).toHaveBeenCalled();
  });

  it('è¨­å®šå–å¾—ã«æˆåŠŸã—ãŸå ´åˆã€åˆæœŸçŠ¶æ…‹ã§ã¯ä¿å­˜ãŒç„¡åŠ¹ã§ã€å¤‰æ›´ã™ã‚‹ã¨æœ‰åŠ¹ã«ãªã‚‹', async () => {
    const settingsData = createSettingsData();

    const fetchMock = jest
      .fn<Promise<Response>, Parameters<typeof fetch>>()
      .mockResolvedValue({
        ok: true,
        json: async () => ({ success: true, data: settingsData }),
      } as Response);

    Object.defineProperty(globalThis, 'fetch', {
      value: fetchMock,
      writable: true,
      configurable: true,
    });

    render(
      <MantineProvider>
        <PrintSettingsEditor />
      </MantineProvider>,
    );

    expect(await screen.findByText('å°åˆ·ä½ç½®è¨­å®š')).toBeInTheDocument();

    const saveButton = screen.getByRole('button', { name: 'ä¿å­˜' });
    expect(saveButton).toBeDisabled();

    const offsetXInput = await screen.findByLabelText('X ã‚ªãƒ•ã‚»ãƒƒãƒˆ (mm)');
    fireEvent.change(offsetXInput, { target: { value: '1' } });

    await waitFor(() => {
      expect(saveButton).toBeEnabled();
    });
  }, 20000);

  it('ä¿å­˜ã‚’æŠ¼ã™ã¨PATCHãŒå‘¼ã°ã‚Œã€å¤‰æ›´ãŒä¿å­˜æ¸ˆã¿çŠ¶æ…‹ã«æˆ»ã‚‹', async () => {
    const settingsData = createSettingsData();

    const fetchMock = jest
      .fn<Promise<Response>, Parameters<typeof fetch>>()
      .mockResolvedValueOnce({
        ok: true,
        json: async () => ({ success: true, data: settingsData }),
      } as Response)
      .mockResolvedValueOnce({
        ok: true,
        json: async () => ({}),
      } as Response);

    Object.defineProperty(globalThis, 'fetch', {
      value: fetchMock,
      writable: true,
      configurable: true,
    });

    render(
      <MantineProvider>
        <PrintSettingsEditor />
      </MantineProvider>,
    );

    expect(await screen.findByText('å°åˆ·ä½ç½®è¨­å®š')).toBeInTheDocument();

    const saveButton = screen.getByRole('button', { name: 'ä¿å­˜' });
    const offsetXInput = await screen.findByLabelText('X ã‚ªãƒ•ã‚»ãƒƒãƒˆ (mm)');

    fireEvent.change(offsetXInput, { target: { value: '1' } });
    await waitFor(() => {
      expect(saveButton).toBeEnabled();
    });

    await act(async () => {
      fireEvent.click(saveButton);
    });

    await waitFor(() => {
      expect(fetchMock).toHaveBeenCalledTimes(2);
      expect(saveButton).toBeDisabled();
    });

    const patchCall = fetchMock.mock.calls[1];
    if (!patchCall) {
      throw new Error('PATCHã®å‘¼ã³å‡ºã—ãŒç¢ºèªã§ãã¾ã›ã‚“ã§ã—ãŸ');
    }

    const [url, options] = patchCall;
    expect(url).toBe('http://localhost:3004/api/v1/pedigrees/print-settings');
    expect(options).toBeDefined();
    expect(options?.method).toBe('PATCH');
    expect(options?.headers).toEqual({ 'Content-Type': 'application/json' });
    expect(typeof options?.body).toBe('string');
    if (typeof options?.body === 'string') {
      expect(options.body).toContain('"offsetX":1');
    }
  }, 20000);
});
````

## File: frontend/src/components/print-templates/index.ts
````typescript
export { PrintTemplateManager } from './PrintTemplateManager';
````

## File: frontend/src/components/ui/InputWithFloatingLabel.module.css
````css
/**
 * InputWithFloatingLabel ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ«å®šç¾©
 * PedigreeRegistrationForm ã®åŸºæœ¬é …ç›®å…¥åŠ›ã‚¹ã‚¿ã‚¤ãƒ«ã‚’å…±é€šåŒ–
 * é«˜ã• 36pxã€padding-top 11px ã§çµ±ä¸€ï¼ˆ2025-12-08 æ›´æ–°ï¼‰
 *
 * @see frontend/src/components/ui/InputWithFloatingLabel.tsx
 */

.root {
  position: relative;
}

.input {
  height: 36px;
  padding-top: 11px;
}

/* Textarea specific adjustment */
textarea.input {
  height: auto !important;
  min-height: 80px !important;
  padding-top: 22px !important;
  padding-left: 12px !important;
  padding-bottom: 8px !important;
  line-height: 1.5 !important;
}

/* Textarea placeholder positioning */
textarea.input::placeholder {
  line-height: 1.5;
}

/* Textarea label positioning - align with text start */
.root:has(textarea) .label {
  top: 6px;
  left: 12px;
}

/* Textarea floating label adjustment */
.root:has(textarea) .label[data-floating] {
  transform: translateY(-4px);
  font-size: 10px;
}

.label {
  position: absolute;
  z-index: 1;
  pointer-events: none;
  top: 9px;
  left: 10px;
  font-size: var(--mantine-font-size-sm);
  color: var(--mantine-color-dimmed);
  transition: transform 150ms ease, color 150ms ease, font-size 150ms ease;
}

.label[data-floating] {
  transform: translateY(-6px);
  font-size: 10px;
  color: var(--mantine-color-blue-4);
  font-weight: 600;
}
````

## File: frontend/src/components/ui/InputWithFloatingLabel.tsx
````typescript
'use client';

import { useState } from 'react';
import { TextInput, type TextInputProps } from '@mantine/core';
import classes from './InputWithFloatingLabel.module.css';

/**
 * PedigreeRegistrationForm ã®åŸºæœ¬é …ç›®å…¥åŠ›ã‚¹ã‚¿ã‚¤ãƒ«ã‚’å…±é€šåŒ–ã—ãŸãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã€‚
 * ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ãŠã‘ã‚‹æ¨™æº–çš„ãª1è¡Œãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ã¨ã—ã¦ä½¿ç”¨ã—ã¾ã™ã€‚
 *
 * - å…¥åŠ›å€¤ãŒã‚ã‚‹å ´åˆã€ã¾ãŸã¯ãƒ•ã‚©ãƒ¼ã‚«ã‚¹æ™‚ã«ãƒ©ãƒ™ãƒ«ãŒæµ®ãä¸ŠãŒã‚‹ï¼ˆ`data-floating` å±æ€§ã§åˆ¶å¾¡ï¼‰
 * - `value` ãŒ `null` ã‚„ `undefined` ã®å ´åˆã¯ç©ºæ–‡å­—ã¨ã—ã¦æ‰±ã†
 *
 * @example
 * ```tsx
 * const [name, setName] = useState('');
 * <InputWithFloatingLabel
 *   label="çŒ«ã®åå‰"
 *   value={name}
 *   onChange={(e) => setName(e.currentTarget.value)}
 * />
 * ```
 */
type InputWithFloatingLabelProps = Omit<TextInputProps, 'value'> & {
  /** å…¥åŠ›å€¤ï¼ˆnull/undefined ã®å ´åˆã¯ç©ºæ–‡å­—ã¨ã—ã¦æ‰±ã†ï¼‰ */
  value?: string | null;
};

export function InputWithFloatingLabel(props: InputWithFloatingLabelProps) {
  const {
    value,
    onFocus,
    onBlur,
    classNames,
    labelProps,
    autoComplete = 'off',
    ...rest
  } = props;

  const [focused, setFocused] = useState(false);
  // null/undefined ã‚’ç©ºæ–‡å­—ã¨ã—ã¦æ‰±ã†
  const normalizedValue = value ?? '';
  const floating = normalizedValue.length > 0 || focused || undefined;

  const handleFocus = (e: React.FocusEvent<HTMLInputElement>) => {
    setFocused(true);
    onFocus?.(e);
  };

  const handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {
    setFocused(false);
    onBlur?.(e);
  };

  return (
    <TextInput
      {...rest}
      value={normalizedValue}
      classNames={{
        root: classes.root,
        input: classes.input,
        label: classes.label,
        ...classNames,
      }}
      onFocus={handleFocus}
      onBlur={handleBlur}
      autoComplete={autoComplete}
      data-floating={floating}
      labelProps={{ 'data-floating': floating, ...labelProps }}
    />
  );
}
````

## File: frontend/src/components/ui/SelectWithFloatingLabel.tsx
````typescript
'use client';

import { useState } from 'react';
import { Select, type SelectProps } from '@mantine/core';
import classes from './InputWithFloatingLabel.module.css';

/**
 * InputWithFloatingLabel ã¨åŒã˜ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ©ãƒ™ãƒ«ã‚¹ã‚¿ã‚¤ãƒ«ã‚’é©ç”¨ã—ãŸã‚»ãƒ¬ã‚¯ãƒˆã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã€‚
 * ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³é¸æŠã«ä½¿ç”¨ã—ã¾ã™ã€‚
 *
 * - å€¤ãŒé¸æŠã•ã‚Œã¦ã„ã‚‹å ´åˆã€ã¾ãŸã¯ãƒ•ã‚©ãƒ¼ã‚«ã‚¹æ™‚ã«ãƒ©ãƒ™ãƒ«ãŒæµ®ãä¸ŠãŒã‚‹ï¼ˆ`data-floating` å±æ€§ã§åˆ¶å¾¡ï¼‰
 * - `value` ãŒ `null` ã‚„ `undefined` ã®å ´åˆã¯ç©ºæ–‡å­—ã¨ã—ã¦æ‰±ã†
 *
 * @example
 * ```tsx
 * const [gender, setGender] = useState('');
 * <SelectWithFloatingLabel
 *   label="æ€§åˆ¥"
 *   placeholder="æ€§åˆ¥ã‚’é¸æŠ"
 *   data={[
 *     { value: 'MALE', label: 'Male (ã‚ªã‚¹)' },
 *     { value: 'FEMALE', label: 'Female (ãƒ¡ã‚¹)' },
 *   ]}
 *   value={gender}
 *   onChange={(value) => setGender(value ?? '')}
 * />
 * ```
 */
type SelectWithFloatingLabelProps = Omit<SelectProps, 'value'> & {
  /** é¸æŠå€¤ï¼ˆnull/undefined ã®å ´åˆã¯ç©ºæ–‡å­—ã¨ã—ã¦æ‰±ã†ï¼‰ */
  value?: string | null;
};

export function SelectWithFloatingLabel(props: SelectWithFloatingLabelProps) {
  const {
    value,
    onFocus,
    onBlur,
    classNames,
    labelProps,
    ...rest
  } = props;

  const [focused, setFocused] = useState(false);
  const normalizedValue = value ?? '';
  const floating = normalizedValue.length > 0 || focused || undefined;

  const handleFocus = (e: React.FocusEvent<HTMLInputElement>) => {
    setFocused(true);
    onFocus?.(e);
  };

  const handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {
    setFocused(false);
    onBlur?.(e);
  };

  return (
    <Select
      {...rest}
      value={normalizedValue || null}
      classNames={{
        root: classes.root,
        input: classes.input,
        label: classes.label,
        ...classNames,
      }}
      onFocus={handleFocus}
      onBlur={handleBlur}
      data-floating={floating}
      labelProps={{ 'data-floating': floating, ...labelProps }}
    />
  );
}
````

## File: frontend/src/components/ui/TextareaWithFloatingLabel.tsx
````typescript
'use client';

import { useState } from 'react';
import { Textarea, type TextareaProps } from '@mantine/core';
import classes from './InputWithFloatingLabel.module.css';

/**
 * ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ©ãƒ™ãƒ«ã‚¹ã‚¿ã‚¤ãƒ«ã®Textareaã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã€‚
 * InputWithFloatingLabelã¨åŒã˜ãƒ‡ã‚¶ã‚¤ãƒ³ã‚’è¤‡æ•°è¡Œãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ã«é©ç”¨ã—ã¾ã™ã€‚
 *
 * - å…¥åŠ›å€¤ãŒã‚ã‚‹å ´åˆã€ã¾ãŸã¯ãƒ•ã‚©ãƒ¼ã‚«ã‚¹æ™‚ã«ãƒ©ãƒ™ãƒ«ãŒæµ®ãä¸ŠãŒã‚‹ï¼ˆ`data-floating` å±æ€§ã§åˆ¶å¾¡ï¼‰
 * - `value` ãŒ `null` ã‚„ `undefined` ã®å ´åˆã¯ç©ºæ–‡å­—ã¨ã—ã¦æ‰±ã†
 *
 * @example
 * ```tsx
 * const [description, setDescription] = useState('');
 * <TextareaWithFloatingLabel
 *   label="å‚™è€ƒ"
 *   value={description}
 *   onChange={(e) => setDescription(e.currentTarget.value)}
 *   minRows={3}
 * />
 * ```
 */
type TextareaWithFloatingLabelProps = Omit<TextareaProps, 'value'> & {
  /** å…¥åŠ›å€¤ï¼ˆnull/undefined ã®å ´åˆã¯ç©ºæ–‡å­—ã¨ã—ã¦æ‰±ã†ï¼‰ */
  value?: string | null;
};

export function TextareaWithFloatingLabel(props: TextareaWithFloatingLabelProps) {
  const {
    value,
    onFocus,
    onBlur,
    classNames,
    labelProps,
    autoComplete = 'off',
    ...rest
  } = props;

  const [focused, setFocused] = useState(false);
  // null/undefined ã‚’ç©ºæ–‡å­—ã¨ã—ã¦æ‰±ã†
  const normalizedValue = value ?? '';
  const floating = normalizedValue.length > 0 || focused || undefined;

  const handleFocus = (e: React.FocusEvent<HTMLTextAreaElement>) => {
    setFocused(true);
    onFocus?.(e);
  };

  const handleBlur = (e: React.FocusEvent<HTMLTextAreaElement>) => {
    setFocused(false);
    onBlur?.(e);
  };

  return (
    <Textarea
      {...rest}
      value={normalizedValue}
      classNames={{
        root: classes.root,
        input: classes.input,
        label: classes.label,
        ...classNames,
      }}
      onFocus={handleFocus}
      onBlur={handleBlur}
      autoComplete={autoComplete}
      data-floating={floating}
      labelProps={{ 'data-floating': floating, ...labelProps }}
    />
  );
}
````

## File: frontend/src/components/GenderBadge.tsx
````typescript
'use client';

import { Badge, MantineSize } from '@mantine/core';

type Gender = 'MALE' | 'FEMALE' | 'NEUTER' | 'SPAY' | 'ã‚ªã‚¹' | 'ãƒ¡ã‚¹';

interface GenderBadgeProps {
  gender: Gender;
  size?: MantineSize;
  variant?: 'filled' | 'light' | 'outline' | 'dot' | 'default';
}

/**
 * æ€§åˆ¥ãƒãƒƒã‚¸ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å…¨ä½“ã§çµ±ä¸€ã•ã‚ŒãŸãƒ‡ã‚¶ã‚¤ãƒ³ã®æ€§åˆ¥ãƒãƒƒã‚¸ã‚’æä¾›
 */
export function GenderBadge({ gender, size = 'sm', variant = 'light' }: GenderBadgeProps) {
  const getGenderConfig = (g: Gender) => {
    switch (g) {
      case 'MALE':
      case 'ã‚ªã‚¹':
        return {
          color: 'blue',
          label: 'ã‚ªã‚¹',
        };
      case 'FEMALE':
      case 'ãƒ¡ã‚¹':
        return {
          color: 'pink',
          label: 'ãƒ¡ã‚¹',
        };
      case 'NEUTER':
        return {
          color: 'gray',
          label: 'å»å‹¢',
        };
      case 'SPAY':
        return {
          color: 'gray',
          label: 'é¿å¦Š',
        };
      default:
        return {
          color: 'gray',
          label: 'ä¸æ˜',
        };
    }
  };

  const { color, label } = getGenderConfig(gender);

  return (
    <Badge size={size} color={color} variant={variant}>
      {label}
    </Badge>
  );
}

/**
 * æ€§åˆ¥ã‚’ãƒ†ã‚­ã‚¹ãƒˆã«å¤‰æ›ã™ã‚‹ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
 */
export function getGenderLabel(gender: Gender): string {
  switch (gender) {
    case 'MALE':
    case 'ã‚ªã‚¹':
      return 'ã‚ªã‚¹';
    case 'FEMALE':
    case 'ãƒ¡ã‚¹':
      return 'ãƒ¡ã‚¹';
    case 'NEUTER':
      return 'å»å‹¢';
    case 'SPAY':
      return 'é¿å¦Š';
    default:
      return 'ä¸æ˜';
  }
}

/**
 * æ€§åˆ¥ã®è‰²ã‚’å–å¾—ã™ã‚‹ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
 */
export function getGenderColor(gender: Gender): string {
  switch (gender) {
    case 'MALE':
    case 'ã‚ªã‚¹':
      return 'blue';
    case 'FEMALE':
    case 'ãƒ¡ã‚¹':
      return 'pink';
    case 'NEUTER':
    case 'SPAY':
      return 'gray';
    default:
      return 'gray';
  }
}
````

## File: frontend/src/components/PageTitle.tsx
````typescript
import { Title, TitleProps } from '@mantine/core';
import { ReactNode } from 'react';

/**
 * çµ±ä¸€ãƒšãƒ¼ã‚¸ã‚¿ã‚¤ãƒˆãƒ«ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * - ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º 18px å›ºå®š
 * - å¤ªã• 700
 * - ä½™ç™½ã‚„è‰²ã¯å¿…è¦ã«å¿œã˜ã¦è¦ªå´ã§è¿½åŠ 
 */
export interface PageTitleProps extends Omit<TitleProps, 'order'> {
  children: ReactNode;
  withMarginBottom?: boolean;
}

export function PageTitle({ children, withMarginBottom = true, ...rest }: PageTitleProps) {
  return (
    <Title
      order={2}
      {...rest}
      style={{
        fontSize: 18,
        fontWeight: 700,
        lineHeight: 1.3,
        ...(withMarginBottom ? { marginBottom: '0.75rem' } : {}),
        ...(rest.style || {}),
      }}
    >
      {children}
    </Title>
  );
}
````

## File: frontend/src/components/README.md
````markdown
# å…±é€šã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

## GenderBadge

æ€§åˆ¥ãƒãƒƒã‚¸ã‚’çµ±ä¸€ã•ã‚ŒãŸãƒ‡ã‚¶ã‚¤ãƒ³ã§è¡¨ç¤ºã™ã‚‹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã€‚

### ä½¿ç”¨æ–¹æ³•

```tsx
import { GenderBadge } from '@/components/GenderBadge';

// åŸºæœ¬çš„ãªä½¿ç”¨
<GenderBadge gender={cat.gender} />

// ã‚µã‚¤ã‚ºæŒ‡å®š
<GenderBadge gender="MALE" size="xs" />
<GenderBadge gender="FEMALE" size="sm" />
<GenderBadge gender="NEUTER" size="md" />

// ãƒãƒªã‚¢ãƒ³ãƒˆæŒ‡å®š
<GenderBadge gender={cat.gender} variant="filled" />
<GenderBadge gender={cat.gender} variant="light" />
```

### Props

- `gender`: `'MALE' | 'FEMALE' | 'NEUTER' | 'SPAY' | 'ã‚ªã‚¹' | 'ãƒ¡ã‚¹'`
- `size`: `MantineSize` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: `'sm'`)
- `variant`: `'filled' | 'light' | 'outline' | 'dot' | 'default'` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: `'light'`)

### ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°

```tsx
import { getGenderLabel, getGenderColor } from '@/components/GenderBadge';

// æ€§åˆ¥ã‚’ãƒ†ã‚­ã‚¹ãƒˆã«å¤‰æ›
const label = getGenderLabel('MALE'); // "ã‚ªã‚¹"

// æ€§åˆ¥ã®è‰²ã‚’å–å¾—
const color = getGenderColor('FEMALE'); // "pink"
```

### è‰²ã®å¯¾å¿œ

- **ã‚ªã‚¹ (MALE)**: é’ (blue)
- **ãƒ¡ã‚¹ (FEMALE)**: ãƒ”ãƒ³ã‚¯ (pink)
- **å»å‹¢ (NEUTER)**: ã‚°ãƒ¬ãƒ¼ (gray)
- **é¿å¦Š (SPAY)**: ã‚°ãƒ¬ãƒ¼ (gray)

---

## TagDisplay

ã‚¿ã‚°ã‚’çµ±ä¸€ã•ã‚ŒãŸãƒ‡ã‚¶ã‚¤ãƒ³ã§è¡¨ç¤ºã™ã‚‹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã€‚

### ä½¿ç”¨æ–¹æ³•

```tsx
import { TagDisplay } from '@/components/TagSelector';

<TagDisplay 
  tagIds={cat.tags.map(t => t.tag.id)} 
  size="sm" 
  categories={tagCategories} 
/>
```

### Props

- `tagIds`: ã‚¿ã‚°IDã®é…åˆ—
- `categories`: ã‚¿ã‚°ã‚«ãƒ†ã‚´ãƒªã®é…åˆ—ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
- `filters`: ã‚¿ã‚°ã‚«ãƒ†ã‚´ãƒªãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
- `size`: `'xs' | 'sm' | 'md' | 'lg'` (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: `'sm'`)

---

## ä½¿ç”¨ä¾‹

### çŒ«ä¸€è¦§ãƒšãƒ¼ã‚¸

```tsx
<Table.Td>
  <GenderBadge gender={cat.gender} size="sm" />
</Table.Td>
```

### å­çŒ«ç®¡ç†ãƒšãƒ¼ã‚¸

```tsx
<Group gap="md">
  <Text fw={500}>{kitten.name}</Text>
  <GenderBadge gender={kitten.gender} size="sm" />
  <TagDisplay 
    tagIds={kitten.tags} 
    size="xs" 
    categories={categories} 
  />
</Group>
```

### ã‚«ãƒ¼ãƒ‰ãƒ“ãƒ¥ãƒ¼

```tsx
<Card>
  <Group>
    <Text>{cat.name}</Text>
    <GenderBadge gender={cat.gender} size="xs" variant="filled" />
  </Group>
  <TagDisplay tagIds={cat.tags} size="xs" categories={categories} />
</Card>
```
````

## File: frontend/src/components/SectionTitle.tsx
````typescript
import { Title, TitleProps } from '@mantine/core';
import { ReactNode } from 'react';

/**
 * ã‚»ã‚¯ã‚·ãƒ§ãƒ³ç”¨ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆãƒšãƒ¼ã‚¸å†…éšå±¤ï¼‰
 * - ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º 16px
 * - å¤ªã• 600
 * - çµ±ä¸€ã•ã‚ŒãŸã‚»ã‚¯ã‚·ãƒ§ãƒ³é–“éš”ï¼ˆCSSå¤‰æ•° --section-gap-lgï¼‰
 */
export interface SectionTitleProps extends Omit<TitleProps, 'order'> {
  children: ReactNode;
  withTopMargin?: boolean;
  withBottomMargin?: boolean;
}

export function SectionTitle({
  children,
  withTopMargin = true,
  withBottomMargin = true,
  style,
  ...rest
}: SectionTitleProps) {
  return (
    <Title
      order={3}
      {...rest}
      style={{
        fontSize: 16,
        fontWeight: 600,
        lineHeight: 1.35,
        marginTop: withTopMargin ? 'var(--section-gap-lg)' : undefined,
        marginBottom: withBottomMargin ? 'var(--section-gap)' : undefined,
        ...style,
      }}
    >
      {children}
    </Title>
  );
}
````

## File: frontend/src/lib/api/generated/README.md
````markdown
# Generated OpenAPI Types

ã“ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ã¯ NestJS å´ã§ç”Ÿæˆã•ã‚ŒãŸ OpenAPI (Swagger) ã‚¹ã‚­ãƒ¼ãƒã‹ã‚‰è‡ªå‹•ç”Ÿæˆã•ã‚ŒãŸ TypeScript å‹å®šç¾©ãŒä¿å­˜ã•ã‚Œã¾ã™ã€‚

## ğŸ”„ æ›´æ–°æ‰‹é †

1. ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã§æœ€æ–°ã® Swagger ã‚¹ã‚­ãƒ¼ãƒã‚’å‡ºåŠ›ã—ã¾ã™ã€‚

   ```bash
   pnpm --filter backend swagger:gen
   ```

2. ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã§å‹ç”Ÿæˆã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’å®Ÿè¡Œã—ã¾ã™ã€‚

   ```bash
   pnpm --filter frontend generate:api-types
   ```

> **Note:** `schema.ts` ã¯è‡ªå‹•ç”Ÿæˆãƒ•ã‚¡ã‚¤ãƒ«ã§ã™ã€‚æ‰‹å‹•ã§ç·¨é›†ã›ãšã€å…ƒã¨ãªã‚‹ OpenAPI ã‚¹ã‚­ãƒ¼ãƒã‚’æ›´æ–°ã—ã¦å†ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚
````

## File: frontend/src/lib/api/generated/schema.ts
````typescript
/* eslint-disable */
/* tslint:disable */
/**
 * ğŸ”’ ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯è‡ªå‹•ç”Ÿæˆã•ã‚Œã¦ã„ã¾ã™ã€‚
 * ç”Ÿæˆã‚³ãƒãƒ³ãƒ‰: pnpm --filter frontend generate:api-types
 * ç›´æ¥ç·¨é›†ã›ãšã€OpenAPI ã‚¹ã‚­ãƒ¼ãƒã‚’æ›´æ–°ã—ã¦å†ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚
 */
export type paths = {
    "/api/v1/master/genders": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** æ€§åˆ¥ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆèªè¨¼ä¸è¦ï¼‰ */
        get: operations["MasterDataController_getGenders"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/auth/login": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** ãƒ­ã‚°ã‚¤ãƒ³ï¼ˆJWTç™ºè¡Œï¼‰ */
        post: operations["AuthController_login"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/auth/register": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²ï¼ˆãƒ¡ãƒ¼ãƒ«ï¼‹ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼‰ */
        post: operations["AuthController_register"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/auth/set-password": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰è¨­å®š/å¤‰æ›´ï¼ˆè¦JWTï¼‰ */
        post: operations["AuthController_setPassword"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/auth/change-password": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¤‰æ›´ï¼ˆç¾åœ¨ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ç¢ºèªå¿…è¦ï¼‰ */
        post: operations["AuthController_changePassword"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/auth/request-password-reset": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆè¦æ±‚ */
        post: operations["AuthController_requestPasswordReset"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/auth/reset-password": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆå®Ÿè¡Œ */
        post: operations["AuthController_resetPassword"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/auth/refresh": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã§ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³å†å–å¾— */
        post: operations["AuthController_refresh"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/auth/logout": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** ãƒ­ã‚°ã‚¢ã‚¦ãƒˆï¼ˆãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³å‰Šé™¤ï¼‰ */
        post: operations["AuthController_logout"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/cats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** çŒ«ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œç´¢ãƒ»ä¸€è¦§å–å¾— */
        get: operations["CatsController_findAll"];
        put?: never;
        /** çŒ«ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ */
        post: operations["CatsController_create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/cats/statistics": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** çŒ«ãƒ‡ãƒ¼ã‚¿ã®çµ±è¨ˆæƒ…å ±ã‚’å–å¾— */
        get: operations["CatsController_getStatistics"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/cats/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** IDã§çŒ«ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾— */
        get: operations["CatsController_findOne"];
        put?: never;
        post?: never;
        /** çŒ«ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ */
        delete: operations["CatsController_remove"];
        options?: never;
        head?: never;
        /** çŒ«ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–° */
        patch: operations["CatsController_update"];
        trace?: never;
    };
    "/api/v1/cats/{id}/breeding-history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** çŒ«ã®ç¹æ®–å±¥æ­´ã‚’å–å¾— */
        get: operations["CatsController_getBreedingHistory"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/cats/{id}/care-history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** çŒ«ã®ã‚±ã‚¢å±¥æ­´ã‚’å–å¾— */
        get: operations["CatsController_getCareHistory"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/cats/genders": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** æ€§åˆ¥ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾— */
        get: operations["CatsController_getGenders"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/pedigrees": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œç´¢ãƒ»ä¸€è¦§å–å¾— */
        get: operations["PedigreeController_findAll"];
        put?: never;
        /** è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆï¼ˆç®¡ç†è€…ã®ã¿ï¼‰ */
        post: operations["PedigreeController_create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/pedigrees/pedigree-id/{pedigreeId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** è¡€çµ±æ›¸ç•ªå·ã§è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾— */
        get: operations["PedigreeController_findByPedigreeId"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/pedigrees/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** IDã§è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾— */
        get: operations["PedigreeController_findOne"];
        put?: never;
        post?: never;
        /** è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰ */
        delete: operations["PedigreeController_remove"];
        options?: never;
        head?: never;
        /** è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰ */
        patch: operations["PedigreeController_update"];
        trace?: never;
    };
    "/api/v1/pedigrees/{id}/family-tree": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** è¡€çµ±æ›¸ã®å®¶ç³»å›³ã‚’å–å¾— */
        get: operations["PedigreeController_getFamilyTree"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/pedigrees/{id}/family": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®å®¶ç³»å›³ã‚’å–å¾— */
        get: operations["PedigreeController_getFamily"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/pedigrees/{id}/descendants": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®å­å­«ã‚’å–å¾— */
        get: operations["PedigreeController_getDescendants"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/breeds": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** å“ç¨®ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œç´¢ãƒ»ä¸€è¦§å–å¾— */
        get: operations["BreedsController_findAll"];
        put?: never;
        /** å“ç¨®ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆï¼ˆç®¡ç†è€…ã®ã¿ï¼‰ */
        post: operations["BreedsController_create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/breeds/statistics": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** å“ç¨®ãƒ‡ãƒ¼ã‚¿ã®çµ±è¨ˆæƒ…å ±ã‚’å–å¾— */
        get: operations["BreedsController_getStatistics"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/breeds/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** IDã§å“ç¨®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾— */
        get: operations["BreedsController_findOne"];
        put?: never;
        post?: never;
        /** å“ç¨®ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰ */
        delete: operations["BreedsController_remove"];
        options?: never;
        head?: never;
        /** å“ç¨®ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰ */
        patch: operations["BreedsController_update"];
        trace?: never;
    };
    "/api/v1/coat-colors": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œç´¢ãƒ»ä¸€è¦§å–å¾— */
        get: operations["CoatColorsController_findAll"];
        put?: never;
        /** æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆï¼ˆç®¡ç†è€…ã®ã¿ï¼‰ */
        post: operations["CoatColorsController_create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/coat-colors/statistics": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã®çµ±è¨ˆæƒ…å ±ã‚’å–å¾— */
        get: operations["CoatColorsController_getStatistics"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/coat-colors/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** IDã§æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾— */
        get: operations["CoatColorsController_findOne"];
        put?: never;
        post?: never;
        /** æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰ */
        delete: operations["CoatColorsController_remove"];
        options?: never;
        head?: never;
        /** æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰ */
        patch: operations["CoatColorsController_update"];
        trace?: never;
    };
    "/api/v1/breeding": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** äº¤é…è¨˜éŒ²ä¸€è¦§ã®å–å¾— */
        get: operations["BreedingController_findAll"];
        put?: never;
        /** äº¤é…è¨˜éŒ²ã®æ–°è¦ä½œæˆ */
        post: operations["BreedingController_create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/breeding/ng-rules": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** NGãƒšã‚¢ãƒ«ãƒ¼ãƒ«ä¸€è¦§ã®å–å¾— */
        get: operations["BreedingController_findNgRules"];
        put?: never;
        /** NGãƒšã‚¢ãƒ«ãƒ¼ãƒ«ã®ä½œæˆ */
        post: operations["BreedingController_createNgRule"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/breeding/ng-rules/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** NGãƒšã‚¢ãƒ«ãƒ¼ãƒ«ã®å‰Šé™¤ */
        delete: operations["BreedingController_removeNgRule"];
        options?: never;
        head?: never;
        /** NGãƒšã‚¢ãƒ«ãƒ¼ãƒ«ã®æ›´æ–° */
        patch: operations["BreedingController_updateNgRule"];
        trace?: never;
    };
    "/api/v1/breeding/test": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** ãƒ†ã‚¹ãƒˆ */
        get: operations["BreedingController_test"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/breeding/pregnancy-checks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** å¦Šå¨ ãƒã‚§ãƒƒã‚¯ä¸€è¦§ã®å–å¾— */
        get: operations["BreedingController_findAllPregnancyChecks"];
        put?: never;
        /** å¦Šå¨ ãƒã‚§ãƒƒã‚¯ã®æ–°è¦ä½œæˆ */
        post: operations["BreedingController_createPregnancyCheck"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/breeding/pregnancy-checks/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** å¦Šå¨ ãƒã‚§ãƒƒã‚¯ã®å‰Šé™¤ */
        delete: operations["BreedingController_removePregnancyCheck"];
        options?: never;
        head?: never;
        /** å¦Šå¨ ãƒã‚§ãƒƒã‚¯ã®æ›´æ–° */
        patch: operations["BreedingController_updatePregnancyCheck"];
        trace?: never;
    };
    "/api/v1/breeding/birth-plans": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** å‡ºç”£è¨ˆç”»ä¸€è¦§ã®å–å¾— */
        get: operations["BreedingController_findAllBirthPlans"];
        put?: never;
        /** å‡ºç”£è¨ˆç”»ã®æ–°è¦ä½œæˆ */
        post: operations["BreedingController_createBirthPlan"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/breeding/birth-plans/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** å‡ºç”£è¨ˆç”»ã®å‰Šé™¤ */
        delete: operations["BreedingController_removeBirthPlan"];
        options?: never;
        head?: never;
        /** å‡ºç”£è¨ˆç”»ã®æ›´æ–° */
        patch: operations["BreedingController_updateBirthPlan"];
        trace?: never;
    };
    "/api/v1/breeding/kitten-dispositions/{birthRecordId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** å‡ºç”£è¨˜éŒ²ã®å­çŒ«å‡¦é‡ä¸€è¦§å–å¾— */
        get: operations["BreedingController_findAllKittenDispositions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/breeding/kitten-dispositions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** å­çŒ«å‡¦é‡ã®ç™»éŒ² */
        post: operations["BreedingController_createKittenDisposition"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/breeding/kitten-dispositions/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** å­çŒ«å‡¦é‡ã®å‰Šé™¤ */
        delete: operations["BreedingController_removeKittenDisposition"];
        options?: never;
        head?: never;
        /** å­çŒ«å‡¦é‡ã®æ›´æ–° */
        patch: operations["BreedingController_updateKittenDisposition"];
        trace?: never;
    };
    "/api/v1/breeding/birth-plans/{id}/complete": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** å‡ºç”£è¨˜éŒ²ã®å®Œäº† */
        post: operations["BreedingController_completeBirthRecord"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/care/schedules": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ä¸€è¦§ã®å–å¾— */
        get: operations["CareController_findSchedules"];
        put?: never;
        /** ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®è¿½åŠ  */
        post: operations["CareController_addSchedule"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/care/schedules/{id}/complete": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** ã‚±ã‚¢å®Œäº†å‡¦ç†ï¼ˆPATCH/PUTå¯¾å¿œï¼‰ */
        patch: operations["CareController_complete"];
        trace?: never;
    };
    "/api/v1/care/schedules/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å‰Šé™¤ */
        delete: operations["CareController_deleteSchedule"];
        options?: never;
        head?: never;
        /** ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æ›´æ–° */
        patch: operations["CareController_updateSchedule"];
        trace?: never;
    };
    "/api/v1/care/medical-records": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** åŒ»ç™‚è¨˜éŒ²ä¸€è¦§ã®å–å¾— */
        get: operations["CareController_findMedicalRecords"];
        put?: never;
        /** åŒ»ç™‚è¨˜éŒ²ã®è¿½åŠ  */
        post: operations["CareController_addMedicalRecord"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/tags": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** ã‚¿ã‚°ä¸€è¦§ã®å–å¾— */
        get: operations["TagsController_findAll"];
        put?: never;
        /** ã‚¿ã‚°ã®ä½œæˆ */
        post: operations["TagsController_create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/tags/reorder": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** ã‚¿ã‚°ã®ä¸¦ã³æ›¿ãˆ */
        patch: operations["TagsController_reorder"];
        trace?: never;
    };
    "/api/v1/tags/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** ã‚¿ã‚°ã®å‰Šé™¤ */
        delete: operations["TagsController_remove"];
        options?: never;
        head?: never;
        /** ã‚¿ã‚°ã®æ›´æ–° */
        patch: operations["TagsController_update"];
        trace?: never;
    };
    "/api/v1/tags/cats/{id}/tags": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** çŒ«ã«ã‚¿ã‚°ã‚’ä»˜ä¸ */
        post: operations["TagsController_assign"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/tags/cats/{id}/tags/{tagId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** çŒ«ã‹ã‚‰ã‚¿ã‚°ã‚’å‰¥å¥ª */
        delete: operations["TagsController_unassign"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/tags/categories": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** ã‚¿ã‚°ã‚«ãƒ†ã‚´ãƒªä¸€è¦§ã®å–å¾— */
        get: operations["TagCategoriesController_findAll"];
        put?: never;
        /** ã‚¿ã‚°ã‚«ãƒ†ã‚´ãƒªã®ä½œæˆ */
        post: operations["TagCategoriesController_create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/tags/categories/reorder": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** ã‚¿ã‚°ã‚«ãƒ†ã‚´ãƒªã®ä¸¦ã³æ›¿ãˆ */
        patch: operations["TagCategoriesController_reorder"];
        trace?: never;
    };
    "/api/v1/tags/categories/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** ã‚¿ã‚°ã‚«ãƒ†ã‚´ãƒªã®å‰Šé™¤ */
        delete: operations["TagCategoriesController_remove"];
        options?: never;
        head?: never;
        /** ã‚¿ã‚°ã‚«ãƒ†ã‚´ãƒªã®æ›´æ–° */
        patch: operations["TagCategoriesController_update"];
        trace?: never;
    };
    "/api/v1/tags/groups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ã®ä½œæˆ */
        post: operations["TagGroupsController_create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/tags/groups/reorder": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ã®ä¸¦ã³æ›¿ãˆ */
        patch: operations["TagGroupsController_reorder"];
        trace?: never;
    };
    "/api/v1/tags/groups/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ã®å‰Šé™¤ */
        delete: operations["TagGroupsController_remove"];
        options?: never;
        head?: never;
        /** ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ã®æ›´æ–° */
        patch: operations["TagGroupsController_update"];
        trace?: never;
    };
    "/api/v1/tags/automation/rules": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ä¸€è¦§ã®å–å¾— */
        get: operations["TagAutomationController_findRules"];
        put?: never;
        /** è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ã®ä½œæˆ */
        post: operations["TagAutomationController_createRule"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/tags/automation/rules/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«è©³ç´°ã®å–å¾— */
        get: operations["TagAutomationController_findRuleById"];
        put?: never;
        post?: never;
        /** è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ã®å‰Šé™¤ */
        delete: operations["TagAutomationController_deleteRule"];
        options?: never;
        head?: never;
        /** è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ã®æ›´æ–° */
        patch: operations["TagAutomationController_updateRule"];
        trace?: never;
    };
    "/api/v1/tags/automation/runs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** ãƒ«ãƒ¼ãƒ«å®Ÿè¡Œå±¥æ­´ã®å–å¾— */
        get: operations["TagAutomationController_findRuns"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/tags/automation/rules/{id}/execute": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** ãƒ«ãƒ¼ãƒ«ã‚’æ‰‹å‹•å®Ÿè¡Œï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰ */
        post: operations["TagAutomationController_executeRule"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["HealthController_check"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/staff": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["StaffController_findAll"];
        put?: never;
        post: operations["StaffController_create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/staff/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["StaffController_findOne"];
        put?: never;
        post?: never;
        delete: operations["StaffController_remove"];
        options?: never;
        head?: never;
        patch: operations["StaffController_update"];
        trace?: never;
    };
    "/api/v1/staff/{id}/restore": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch: operations["StaffController_restore"];
        trace?: never;
    };
    "/api/v1/shifts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["ShiftController_findAll"];
        put?: never;
        post: operations["ShiftController_create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/shifts/calendar": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["ShiftController_getCalendarData"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/v1/shifts/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["ShiftController_findOne"];
        put?: never;
        post?: never;
        delete: operations["ShiftController_remove"];
        options?: never;
        head?: never;
        patch: operations["ShiftController_update"];
        trace?: never;
    };
};
export type webhooks = Record<string, never>;
export type components = {
    schemas: {
        LoginDto: {
            /**
             * @description ãƒ­ã‚°ã‚¤ãƒ³ã«ä½¿ç”¨ã™ã‚‹ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹
             * @example user@example.com
             */
            email: string;
            /**
             * @description ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ (8æ–‡å­—ä»¥ä¸Šæ¨å¥¨)
             * @example SecurePassword123!
             */
            password: string;
        };
        ChangePasswordDto: {
            /**
             * @description ç¾åœ¨ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰
             * @example oldPassword123!
             */
            currentPassword: string;
            /**
             * @description æ–°ã—ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼ˆ8æ–‡å­—ä»¥ä¸Šã€å¤§æ–‡å­—ãƒ»å°æ–‡å­—ãƒ»æ•°å­—ãƒ»ç‰¹æ®Šæ–‡å­—ã‚’å«ã‚€ï¼‰
             * @example NewSecurePassword123!
             */
            newPassword: string;
        };
        RequestPasswordResetDto: {
            /**
             * @description ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹
             * @example user@example.com
             */
            email: string;
        };
        ResetPasswordDto: {
            /**
             * @description ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆãƒˆãƒ¼ã‚¯ãƒ³
             * @example a1b2c3d4e5f6...
             */
            token: string;
            /**
             * @description æ–°ã—ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰
             * @example NewSecurePassword123!
             */
            newPassword: string;
        };
        RefreshTokenDto: {
            /**
             * @description ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ (Cookieåˆ©ç”¨æ™‚ã¯çœç•¥å¯)
             * @example eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
             */
            refreshToken?: string;
        };
        CreateCatDto: {
            /**
             * @description çŒ«ã®åå‰
             * @example Alpha
             */
            name: string;
            /**
             * @description æ€§åˆ¥
             * @example MALE
             * @enum {string}
             */
            gender: "MALE" | "FEMALE" | "NEUTER" | "SPAY";
            /**
             * @description ç”Ÿå¹´æœˆæ—¥
             * @example 2024-05-01
             */
            birthDate: string;
            /** @description å“ç¨®ID */
            breedId?: string;
            /** @description æ¯›è‰²ID */
            coatColorId?: string;
            /** @description ãƒã‚¤ã‚¯ãƒ­ãƒãƒƒãƒ—ç•ªå· */
            microchipNumber?: string;
            /** @description ç™»éŒ²ç•ªå· */
            registrationNumber?: string;
            /** @description èª¬æ˜ãƒ»å‚™è€ƒ */
            description?: string;
            /** @description æ–½è¨­å†…ã«åœ¨èˆã—ã¦ã„ã‚‹ã‹ */
            isInHouse?: boolean;
            /** @description çˆ¶çŒ«ã®ID */
            fatherId?: string;
            /** @description æ¯çŒ«ã®ID */
            motherId?: string;
            /** @description ã‚¿ã‚°IDé…åˆ— */
            tagIds?: string[];
        };
        UpdateCatDto: Record<string, never>;
        CreatePedigreeDto: {
            /**
             * @description è¡€çµ±æ›¸ç•ªå·
             * @example 700545
             */
            pedigreeId: string;
            /**
             * @description ã‚¿ã‚¤ãƒˆãƒ«
             * @example Champion
             */
            title?: string;
            /**
             * @description çŒ«ã®åå‰
             * @example Jolly Tokuichi
             */
            catName?: string;
            /**
             * @description ã‚­ãƒ£ãƒƒãƒ†ãƒªãƒ¼å
             * @example Jolly Tokuichi
             */
            catName2?: string;
            /**
             * @description å“ç¨®ã‚³ãƒ¼ãƒ‰
             * @example 92
             */
            breedCode?: number;
            /**
             * @description æ€§åˆ¥ã‚³ãƒ¼ãƒ‰ (1: ã‚ªã‚¹, 2: ãƒ¡ã‚¹)
             * @example 1
             */
            genderCode?: number;
            /**
             * @description ç›®ã®è‰²
             * @example Gold
             */
            eyeColor?: string;
            /**
             * @description æ¯›è‰²ã‚³ãƒ¼ãƒ‰
             * @example 190
             */
            coatColorCode?: number;
            /**
             * @description ç”Ÿå¹´æœˆæ—¥
             * @example 2019-01-05
             */
            birthDate?: string;
            /**
             * @description ãƒ–ãƒªãƒ¼ãƒ€ãƒ¼å
             * @example Hayato Inami
             */
            breederName?: string;
            /**
             * @description ã‚ªãƒ¼ãƒŠãƒ¼å
             * @example Hayato Inami
             */
            ownerName?: string;
            /**
             * @description ç™»éŒ²å¹´æœˆæ—¥
             * @example 2022-02-22
             */
            registrationDate?: string;
            /**
             * @description å…„å¼Ÿã®äººæ•°
             * @example 2
             */
            brotherCount?: number;
            /**
             * @description å§‰å¦¹ã®äººæ•°
             * @example 2
             */
            sisterCount?: number;
            /** @description å‚™è€ƒ */
            notes?: string;
            /** @description å‚™è€ƒï¼’ */
            notes2?: string;
            /**
             * @description ä»–å›£ä½“No
             * @example 921901-700545
             */
            otherNo?: string;
            /** @description çˆ¶è¦ªã‚¿ã‚¤ãƒˆãƒ« */
            fatherTitle?: string;
            /** @description çˆ¶è¦ªå */
            fatherCatName?: string;
            /** @description çˆ¶è¦ªã‚­ãƒ£ãƒƒãƒ†ãƒªãƒ¼å */
            fatherCatName2?: string;
            /** @description çˆ¶è¦ªæ¯›è‰² */
            fatherCoatColor?: string;
            /** @description çˆ¶è¦ªç›®ã®è‰² */
            fatherEyeColor?: string;
            /** @description çˆ¶è¦ªJCUç•ªå· */
            fatherJCU?: string;
            /** @description çˆ¶è¦ªä»–å›£ä½“ã‚³ãƒ¼ãƒ‰ */
            fatherOtherCode?: string;
            /** @description æ¯è¦ªã‚¿ã‚¤ãƒˆãƒ« */
            motherTitle?: string;
            /** @description æ¯è¦ªå */
            motherCatName?: string;
            /** @description æ¯è¦ªã‚­ãƒ£ãƒƒãƒ†ãƒªãƒ¼å */
            motherCatName2?: string;
            /** @description æ¯è¦ªæ¯›è‰² */
            motherCoatColor?: string;
            /** @description æ¯è¦ªç›®ã®è‰² */
            motherEyeColor?: string;
            /** @description æ¯è¦ªJCUç•ªå· */
            motherJCU?: string;
            /** @description æ¯è¦ªä»–å›£ä½“ã‚³ãƒ¼ãƒ‰ */
            motherOtherCode?: string;
            /** @description çˆ¶æ–¹ç¥–çˆ¶ã‚¿ã‚¤ãƒˆãƒ« */
            ffTitle?: string;
            /** @description çˆ¶æ–¹ç¥–çˆ¶å */
            ffCatName?: string;
            /** @description çˆ¶æ–¹ç¥–çˆ¶æ¯›è‰² */
            ffCatColor?: string;
            /** @description çˆ¶æ–¹ç¥–çˆ¶JCU */
            ffjcu?: string;
            /** @description çˆ¶æ–¹ç¥–æ¯ã‚¿ã‚¤ãƒˆãƒ« */
            fmTitle?: string;
            /** @description çˆ¶æ–¹ç¥–æ¯å */
            fmCatName?: string;
            /** @description çˆ¶æ–¹ç¥–æ¯æ¯›è‰² */
            fmCatColor?: string;
            /** @description çˆ¶æ–¹ç¥–æ¯JCU */
            fmjcu?: string;
            /** @description æ¯æ–¹ç¥–çˆ¶ã‚¿ã‚¤ãƒˆãƒ« */
            mfTitle?: string;
            /** @description æ¯æ–¹ç¥–çˆ¶å */
            mfCatName?: string;
            /** @description æ¯æ–¹ç¥–çˆ¶æ¯›è‰² */
            mfCatColor?: string;
            /** @description æ¯æ–¹ç¥–çˆ¶JCU */
            mfjcu?: string;
            /** @description æ¯æ–¹ç¥–æ¯ã‚¿ã‚¤ãƒˆãƒ« */
            mmTitle?: string;
            /** @description æ¯æ–¹ç¥–æ¯å */
            mmCatName?: string;
            /** @description æ¯æ–¹ç¥–æ¯æ¯›è‰² */
            mmCatColor?: string;
            /** @description æ¯æ–¹ç¥–æ¯JCU */
            mmjcu?: string;
            /** @description çˆ¶çˆ¶çˆ¶ã‚¿ã‚¤ãƒˆãƒ« */
            fffTitle?: string;
            /** @description çˆ¶çˆ¶çˆ¶å */
            fffCatName?: string;
            /** @description çˆ¶çˆ¶çˆ¶æ¯›è‰² */
            fffCatColor?: string;
            /** @description çˆ¶çˆ¶çˆ¶JCU */
            fffjcu?: string;
            /** @description çˆ¶çˆ¶æ¯ã‚¿ã‚¤ãƒˆãƒ« */
            ffmTitle?: string;
            /** @description çˆ¶çˆ¶æ¯å */
            ffmCatName?: string;
            /** @description çˆ¶çˆ¶æ¯æ¯›è‰² */
            ffmCatColor?: string;
            /** @description çˆ¶çˆ¶æ¯JCU */
            ffmjcu?: string;
            /** @description çˆ¶æ¯çˆ¶ã‚¿ã‚¤ãƒˆãƒ« */
            fmfTitle?: string;
            /** @description çˆ¶æ¯çˆ¶å */
            fmfCatName?: string;
            /** @description çˆ¶æ¯çˆ¶æ¯›è‰² */
            fmfCatColor?: string;
            /** @description çˆ¶æ¯çˆ¶JCU */
            fmfjcu?: string;
            /** @description çˆ¶æ¯æ¯ã‚¿ã‚¤ãƒˆãƒ« */
            fmmTitle?: string;
            /** @description çˆ¶æ¯æ¯å */
            fmmCatName?: string;
            /** @description çˆ¶æ¯æ¯æ¯›è‰² */
            fmmCatColor?: string;
            /** @description çˆ¶æ¯æ¯JCU */
            fmmjcu?: string;
            /** @description æ¯çˆ¶çˆ¶ã‚¿ã‚¤ãƒˆãƒ« */
            mffTitle?: string;
            /** @description æ¯çˆ¶çˆ¶å */
            mffCatName?: string;
            /** @description æ¯çˆ¶çˆ¶æ¯›è‰² */
            mffCatColor?: string;
            /** @description æ¯çˆ¶çˆ¶JCU */
            mffjcu?: string;
            /** @description æ¯çˆ¶æ¯ã‚¿ã‚¤ãƒˆãƒ« */
            mfmTitle?: string;
            /** @description æ¯çˆ¶æ¯å */
            mfmCatName?: string;
            /** @description æ¯çˆ¶æ¯æ¯›è‰² */
            mfmCatColor?: string;
            /** @description æ¯çˆ¶æ¯JCU */
            mfmjcu?: string;
            /** @description æ¯æ¯çˆ¶ã‚¿ã‚¤ãƒˆãƒ« */
            mmfTitle?: string;
            /** @description æ¯æ¯çˆ¶å */
            mmfCatName?: string;
            /** @description æ¯æ¯çˆ¶æ¯›è‰² */
            mmfCatColor?: string;
            /** @description æ¯æ¯çˆ¶JCU */
            mmfjcu?: string;
            /** @description æ¯æ¯æ¯ã‚¿ã‚¤ãƒˆãƒ« */
            mmmTitle?: string;
            /** @description æ¯æ¯æ¯å */
            mmmCatName?: string;
            /** @description æ¯æ¯æ¯æ¯›è‰² */
            mmmCatColor?: string;
            /** @description æ¯æ¯æ¯JCU */
            mmmjcu?: string;
            /** @description æ—§ã‚³ãƒ¼ãƒ‰ */
            oldCode?: string;
        };
        UpdatePedigreeDto: Record<string, never>;
        CreateBreedDto: {
            /** @description å“ç¨®ã‚³ãƒ¼ãƒ‰ */
            code: number;
            /** @description å“ç¨®å */
            name: string;
            /** @description å“ç¨®ã®èª¬æ˜ */
            description?: string;
        };
        UpdateBreedDto: Record<string, never>;
        CreateCoatColorDto: {
            /** @description æ¯›è‰²ã‚³ãƒ¼ãƒ‰ */
            code: number;
            /** @description æ¯›è‰²å */
            name: string;
            /** @description æ¯›è‰²ã®èª¬æ˜ */
            description?: string;
        };
        UpdateCoatColorDto: Record<string, never>;
        CreateBreedingDto: {
            /**
             * @description ãƒ¡ã‚¹çŒ«ã®ID
             * @example 11111111-1111-1111-1111-111111111111
             */
            femaleId: string;
            /**
             * @description ã‚ªã‚¹çŒ«ã®ID
             * @example 22222222-2222-2222-2222-222222222222
             */
            maleId: string;
            /**
             * @description äº¤é…æ—¥
             * @example 2025-08-01
             */
            breedingDate: string;
            /**
             * @description å‡ºç”£äºˆå®šæ—¥ (YYYY-MM-DD)
             * @example 2025-10-01
             */
            expectedDueDate?: string;
            /**
             * @description ãƒ¡ãƒ¢
             * @example åˆå›ã®äº¤é…ã€‚
             */
            notes?: string;
        };
        CreateBreedingNgRuleDto: {
            /**
             * @description ãƒ«ãƒ¼ãƒ«å
             * @example è¿‘è¦ªäº¤é…é˜²æ­¢
             */
            name: string;
            /**
             * @description èª¬æ˜
             * @example è¡€çµ±æ›¸ä»˜ãåŒå£«ã®äº¤é…ã‚’é¿ã‘ã‚‹
             */
            description?: string;
            /**
             * @example TAG_COMBINATION
             * @enum {string}
             */
            type: "TAG_COMBINATION" | "INDIVIDUAL_PROHIBITION" | "GENERATION_LIMIT";
            /**
             * @description æœ‰åŠ¹ãƒ•ãƒ©ã‚°
             * @default true
             */
            active: boolean;
            /** @description ã‚ªã‚¹å´ã®ã‚¿ã‚°æ¡ä»¶ */
            maleConditions?: string[];
            /** @description ãƒ¡ã‚¹å´ã®ã‚¿ã‚°æ¡ä»¶ */
            femaleConditions?: string[];
            /** @description ç¦æ­¢ã™ã‚‹ã‚ªã‚¹çŒ«ã®åå‰ */
            maleNames?: string[];
            /** @description ç¦æ­¢ã™ã‚‹ãƒ¡ã‚¹çŒ«ã®åå‰ */
            femaleNames?: string[];
            /** @description ä¸–ä»£åˆ¶é™ (è¦ªç­‰) */
            generationLimit?: number;
        };
        UpdateBreedingNgRuleDto: Record<string, never>;
        CreatePregnancyCheckDto: {
            /** @description å¦Šå¨ ãƒã‚§ãƒƒã‚¯å¯¾è±¡ã®çŒ«ID */
            motherId: string;
            /** @description çˆ¶çŒ«ã®ID */
            fatherId?: string;
            /** @description äº¤é…æ—¥ */
            matingDate?: string;
            /** @description å¦Šå¨ ãƒã‚§ãƒƒã‚¯æ—¥ */
            checkDate: string;
            /**
             * @description å¦Šå¨ çŠ¶æ…‹
             * @enum {string}
             */
            status: "CONFIRMED" | "SUSPECTED" | "NEGATIVE" | "ABORTED";
            /** @description ãƒ¡ãƒ¢ */
            notes?: string;
        };
        UpdatePregnancyCheckDto: {
            /** @description çˆ¶çŒ«ã®ID */
            fatherId?: string;
            /** @description äº¤é…æ—¥ */
            matingDate?: string;
            /** @description å¦Šå¨ ãƒã‚§ãƒƒã‚¯æ—¥ */
            checkDate?: string;
            /**
             * @description å¦Šå¨ çŠ¶æ…‹
             * @enum {string}
             */
            status?: "CONFIRMED" | "SUSPECTED" | "NEGATIVE" | "ABORTED";
            /** @description ãƒ¡ãƒ¢ */
            notes?: string;
        };
        CreateBirthPlanDto: {
            /** @description å‡ºç”£äºˆå®šã®æ¯è¦ªçŒ«ID */
            motherId: string;
            /** @description çˆ¶çŒ«ã®ID */
            fatherId?: string;
            /** @description äº¤é…æ—¥ */
            matingDate?: string;
            /** @description å‡ºç”£äºˆå®šæ—¥ */
            expectedBirthDate: string;
            /** @description å®Ÿéš›ã®å‡ºç”£æ—¥ */
            actualBirthDate?: string;
            /**
             * @description å‡ºç”£çŠ¶æ…‹
             * @enum {string}
             */
            status: "EXPECTED" | "BORN" | "ABORTED" | "STILLBORN";
            /** @description äºˆæƒ³ã•ã‚Œã‚‹å­çŒ«ã®æ•° */
            expectedKittens?: number;
            /** @description å®Ÿéš›ã®å­çŒ«ã®æ•° */
            actualKittens?: number;
            /** @description ãƒ¡ãƒ¢ */
            notes?: string;
        };
        UpdateBirthPlanDto: {
            /** @description çˆ¶çŒ«ã®ID */
            fatherId?: string;
            /** @description äº¤é…æ—¥ */
            matingDate?: string;
            /** @description å‡ºç”£äºˆå®šæ—¥ */
            expectedBirthDate?: string;
            /** @description å®Ÿéš›ã®å‡ºç”£æ—¥ */
            actualBirthDate?: string;
            /**
             * @description å‡ºç”£çŠ¶æ…‹
             * @enum {string}
             */
            status?: "EXPECTED" | "BORN" | "ABORTED" | "STILLBORN";
            /** @description äºˆæƒ³ã•ã‚Œã‚‹å­çŒ«ã®æ•° */
            expectedKittens?: number;
            /** @description å®Ÿéš›ã®å­çŒ«ã®æ•° */
            actualKittens?: number;
            /** @description ãƒ¡ãƒ¢ */
            notes?: string;
        };
        SaleInfoDto: {
            /** @description è­²æ¸¡å…ˆï¼ˆå€‹äººå/æ¥­è€…åï¼‰ */
            buyer: string;
            /** @description è­²æ¸¡é‡‘é¡ */
            price: number;
            /** @description è­²æ¸¡æ—¥ */
            saleDate: string;
            /** @description ãƒ¡ãƒ¢ */
            notes?: string;
        };
        CreateKittenDispositionDto: {
            /** @description å‡ºç”£è¨˜éŒ²ID */
            birthRecordId: string;
            /** @description å­çŒ«IDï¼ˆé¤Šæˆã®å ´åˆã®ã¿ï¼‰ */
            kittenId?: string;
            /** @description å­çŒ«å */
            name: string;
            /** @description æ€§åˆ¥ */
            gender: string;
            /**
             * @description å‡¦é‡ã‚¿ã‚¤ãƒ—
             * @enum {string}
             */
            disposition: "TRAINING" | "SALE" | "DECEASED";
            /** @description é¤Šæˆé–‹å§‹æ—¥ï¼ˆé¤Šæˆã®å ´åˆï¼‰ */
            trainingStartDate?: string;
            /** @description è­²æ¸¡æƒ…å ±ï¼ˆå‡ºè·ã®å ´åˆï¼‰ */
            saleInfo?: components["schemas"]["SaleInfoDto"];
            /** @description æ­»äº¡æ—¥ï¼ˆæ­»äº¡ã®å ´åˆï¼‰ */
            deathDate?: string;
            /** @description æ­»äº¡ç†ç”±ï¼ˆæ­»äº¡ã®å ´åˆï¼‰ */
            deathReason?: string;
            /** @description ãƒ¡ãƒ¢ */
            notes?: string;
        };
        UpdateKittenDispositionDto: {
            /** @description å­çŒ«IDï¼ˆé¤Šæˆã®å ´åˆã®ã¿ï¼‰ */
            kittenId?: string;
            /** @description å­çŒ«å */
            name?: string;
            /** @description æ€§åˆ¥ */
            gender?: string;
            /** @description å‡¦é‡ã‚¿ã‚¤ãƒ— */
            disposition?: string;
            /** @description é¤Šæˆé–‹å§‹æ—¥ï¼ˆé¤Šæˆã®å ´åˆï¼‰ */
            trainingStartDate?: string;
            /** @description è­²æ¸¡æƒ…å ±ï¼ˆå‡ºè·ã®å ´åˆï¼‰ */
            saleInfo?: components["schemas"]["SaleInfoDto"];
            /** @description æ­»äº¡æ—¥ï¼ˆæ­»äº¡ã®å ´åˆï¼‰ */
            deathDate?: string;
            /** @description æ­»äº¡ç†ç”±ï¼ˆæ­»äº¡ã®å ´åˆï¼‰ */
            deathReason?: string;
            /** @description ãƒ¡ãƒ¢ */
            notes?: string;
        };
        CareScheduleCatDto: {
            /** @example e7b6a7a7-2d7f-4b2f-9f3a-1c2b3d4e5f60 */
            id: string;
            /** @example ãƒ¬ã‚ª */
            name: string;
        };
        CareScheduleReminderDto: {
            /** @example f1e2d3c4-b5a6-7890-1234-56789abcdef0 */
            id: string;
            /**
             * @example ABSOLUTE
             * @enum {string}
             */
            timingType: "ABSOLUTE" | "RELATIVE";
            /** @example 2025-08-01T09:00:00.000Z */
            remindAt?: string;
            /** @example 2 */
            offsetValue?: number;
            /**
             * @example DAY
             * @enum {string}
             */
            offsetUnit?: "MINUTE" | "HOUR" | "DAY" | "WEEK" | "MONTH";
            /**
             * @example START_DATE
             * @enum {string}
             */
            relativeTo?: "START_DATE" | "END_DATE" | "CUSTOM_DATE";
            /**
             * @example IN_APP
             * @enum {string}
             */
            channel: "IN_APP" | "EMAIL" | "SMS" | "PUSH";
            /**
             * @example NONE
             * @enum {string}
             */
            repeatFrequency?: "NONE" | "DAILY" | "WEEKLY" | "MONTHLY" | "YEARLY" | "CUSTOM";
            /** @example 1 */
            repeatInterval?: number;
            /** @example 5 */
            repeatCount?: number;
            /** @example 2025-12-31T00:00:00.000Z */
            repeatUntil?: string;
            /** @example å‰æ—¥9æ™‚ã«é€šçŸ¥ */
            notes?: string;
            /** @example true */
            isActive: boolean;
        };
        CareScheduleTagDto: {
            /** @example a1b2c3d4-5678-90ab-cdef-1234567890ab */
            id: string;
            /** @example vaccination */
            slug: string;
            /** @example ãƒ¯ã‚¯ãƒãƒ³ */
            label: string;
            /** @example 1 */
            level: number;
            /** @example parent-tag-id */
            parentId?: string;
        };
        CareScheduleItemDto: {
            /** @example a6f7e52f-4a3b-4a76-9870-1234567890ab */
            id: string;
            /** @example å¹´æ¬¡å¥åº·è¨ºæ–­ */
            name: string;
            /** @example å¹´æ¬¡å¥åº·è¨ºæ–­ */
            title: string;
            /** @example æ¯å¹´ã®å®šæœŸå¥è¨º */
            description: string;
            /** @example 2025-09-01T00:00:00.000Z */
            scheduleDate: string;
            /** @example 2025-09-01T01:00:00.000Z */
            endDate?: string;
            /** @example Asia/Tokyo */
            timezone?: string;
            /**
             * @example CARE
             * @enum {string}
             */
            scheduleType: "BREEDING" | "CARE" | "APPOINTMENT" | "REMINDER" | "MAINTENANCE";
            /**
             * @example PENDING
             * @enum {string}
             */
            status: "PENDING" | "IN_PROGRESS" | "COMPLETED" | "CANCELLED";
            /**
             * @example HEALTH_CHECK
             * @enum {string|null}
             */
            careType: "VACCINATION" | "HEALTH_CHECK" | "GROOMING" | "DENTAL_CARE" | "MEDICATION" | "SURGERY" | "OTHER" | null;
            /**
             * @example MEDIUM
             * @enum {string}
             */
            priority: "LOW" | "MEDIUM" | "HIGH" | "URGENT";
            /** @example FREQ=YEARLY;INTERVAL=1 */
            recurrenceRule?: string;
            /** @example f3a2c1d7-1234-5678-90ab-cdef12345678 */
            assignedTo: string;
            cat: components["schemas"]["CareScheduleCatDto"] | null;
            /** @description å¯¾è±¡çŒ«ã®é…åˆ— */
            cats: components["schemas"]["CareScheduleCatDto"][];
            reminders: components["schemas"]["CareScheduleReminderDto"][];
            tags: components["schemas"]["CareScheduleTagDto"][];
            /** @example 2025-08-01T00:00:00.000Z */
            createdAt: string;
            /** @example 2025-08-15T12:34:56.000Z */
            updatedAt: string;
        };
        CareScheduleMetaDto: {
            /** @example 42 */
            total: number;
            /** @example 1 */
            page: number;
            /** @example 20 */
            limit: number;
            /** @example 3 */
            totalPages: number;
        };
        CareScheduleListResponseDto: {
            /** @example true */
            success: boolean;
            data: components["schemas"]["CareScheduleItemDto"][];
            meta: components["schemas"]["CareScheduleMetaDto"];
        };
        ScheduleReminderDto: {
            /** @enum {string} */
            timingType: "ABSOLUTE" | "RELATIVE";
            /**
             * @description æŒ‡å®šæ—¥æ™‚ (ISO8601)
             * @example 2025-08-01T09:00:00.000Z
             */
            remindAt?: string;
            /**
             * @description ç›¸å¯¾ãƒªãƒã‚¤ãƒ³ãƒ‰ã®å€¤
             * @example 2
             */
            offsetValue?: number;
            /**
             * @example DAY
             * @enum {string}
             */
            offsetUnit?: "MINUTE" | "HOUR" | "DAY" | "WEEK" | "MONTH";
            /**
             * @example START_DATE
             * @enum {string}
             */
            relativeTo?: "START_DATE" | "END_DATE" | "CUSTOM_DATE";
            /**
             * @example IN_APP
             * @enum {string}
             */
            channel: "IN_APP" | "EMAIL" | "SMS" | "PUSH";
            /**
             * @example NONE
             * @enum {string}
             */
            repeatFrequency?: "NONE" | "DAILY" | "WEEKLY" | "MONTHLY" | "YEARLY" | "CUSTOM";
            /**
             * @description ç¹°ã‚Šè¿”ã—é–“éš”
             * @example 1
             */
            repeatInterval?: number;
            /**
             * @description ç¹°ã‚Šè¿”ã—å›æ•°
             * @example 5
             */
            repeatCount?: number;
            /**
             * @description ç¹°ã‚Šè¿”ã—çµ‚äº†æ—¥æ™‚
             * @example 2025-12-31T00:00:00.000Z
             */
            repeatUntil?: string;
            /**
             * @description å‚™è€ƒ
             * @example å‰æ—¥9æ™‚ã«é€šçŸ¥
             */
            notes?: string;
            /**
             * @description æœ‰åŠ¹ãƒ•ãƒ©ã‚°
             * @example true
             */
            isActive?: boolean;
        };
        CreateCareScheduleDto: {
            /**
             * @description å¯¾è±¡çŒ«IDã®é…åˆ—
             * @example [
             *       "e7b6a7a7-2d7f-4b2f-9f3a-1c2b3d4e5f60"
             *     ]
             */
            catIds: string[];
            /**
             * @description ã‚±ã‚¢å
             * @example å¹´æ¬¡å¥åº·è¨ºæ–­
             */
            name: string;
            /**
             * @description ã‚±ã‚¢ç¨®åˆ¥
             * @example HEALTH_CHECK
             * @enum {string}
             */
            careType: "VACCINATION" | "HEALTH_CHECK" | "GROOMING" | "DENTAL_CARE" | "MEDICATION" | "SURGERY" | "OTHER";
            /**
             * @description äºˆå®šæ—¥ (ISO8601)
             * @example 2025-09-01
             */
            scheduledDate: string;
            /**
             * @description çµ‚äº†æ—¥æ™‚ (ISO8601)
             * @example 2025-09-01T10:00:00.000Z
             */
            endDate?: string;
            /**
             * @description ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³
             * @example Asia/Tokyo
             */
            timezone?: string;
            /**
             * @description ã‚±ã‚¢å/è©³ç´°
             * @example å¥åº·è¨ºæ–­ (å¹´1å›)
             */
            description?: string;
            /**
             * @example MEDIUM
             * @enum {string}
             */
            priority?: "LOW" | "MEDIUM" | "HIGH" | "URGENT";
            /**
             * @description RRULEå½¢å¼ãªã©ã®ç¹°ã‚Šè¿”ã—ãƒ«ãƒ¼ãƒ«
             * @example FREQ=YEARLY;INTERVAL=1
             */
            recurrenceRule?: string;
            /** @description ãƒªãƒã‚¤ãƒ³ãƒ€ãƒ¼è¨­å®š */
            reminders?: components["schemas"]["ScheduleReminderDto"][];
            /** @description é–¢é€£ã‚±ã‚¢ã‚¿ã‚°ID (æœ€å¤§3éšå±¤) */
            careTagIds?: string[];
        };
        CareScheduleResponseDto: {
            /** @example true */
            success: boolean;
            data: components["schemas"]["CareScheduleItemDto"];
        };
        CompleteCareMedicalRecordDto: Record<string, never>;
        CompleteCareDto: {
            /**
             * @description å®Œäº†æ—¥ (YYYY-MM-DD)
             * @example 2025-08-10
             */
            completedDate?: string;
            /**
             * @description æ¬¡å›äºˆå®šæ—¥ (YYYY-MM-DD)
             * @example 2026-08-10
             */
            nextScheduledDate?: string;
            /**
             * @description ãƒ¡ãƒ¢
             * @example ä½“èª¿è‰¯å¥½ã€‚æ¬¡å›ã¯ãƒ¯ã‚¯ãƒãƒ³Aã€‚
             */
            notes?: string;
            medicalRecord?: components["schemas"]["CompleteCareMedicalRecordDto"];
        };
        CareCompleteResponseDto: {
            /** @example true */
            success: boolean;
            /** @example {
             *       "scheduleId": "a6f7e52f-4a3b-4a76-9870-1234567890ab",
             *       "recordId": "bcdef123-4567-890a-bcde-f1234567890a",
             *       "medicalRecordId": "f1234567-89ab-cdef-0123-456789abcdef"
             *     } */
            data: Record<string, never>;
        };
        MedicalRecordSymptomDto: {
            /** @example ãã—ã‚ƒã¿ */
            label: string;
            /** @example 1é€±é–“ç¶™ç¶š */
            note?: string;
        };
        MedicalRecordMedicationDto: {
            /** @example æŠ—ç”Ÿç‰©è³ª */
            name: string;
            /** @example æœæ™©1éŒ  */
            dosage?: string;
        };
        MedicalRecordCatDto: {
            /** @example e7b6a7a7-2d7f-4b2f-9f3a-1c2b3d4e5f60 */
            id: string;
            /** @example ãƒŸã‚± */
            name: string;
        };
        MedicalRecordScheduleDto: {
            /** @example a6f7e52f-4a3b-4a76-9870-1234567890ab */
            id: string;
            /** @example ãƒ¯ã‚¯ãƒãƒ³æ¥ç¨® */
            name: string;
        };
        MedicalRecordTagDto: {
            /** @example tag-123 */
            id: string;
            /** @example vaccination */
            slug: string;
            /** @example ãƒ¯ã‚¯ãƒãƒ³ */
            label: string;
            /** @example 1 */
            level: number;
            /** @example parent-tag */
            parentId?: string;
        };
        MedicalRecordAttachmentDto: {
            /** @example https://cdn.example.com/xray.png */
            url: string;
            /** @example èƒ¸éƒ¨ãƒ¬ãƒ³ãƒˆã‚²ãƒ³ */
            description?: string;
            /** @example xray.png */
            fileName?: string;
            /** @example image/png */
            fileType?: string;
            /** @example 204800 */
            fileSize?: number;
            /** @example 2025-08-10T09:30:00.000Z */
            capturedAt?: string;
        };
        MedicalRecordItemDto: {
            /** @example bcdef123-4567-890a-bcde-f1234567890a */
            id: string;
            /** @example 2025-08-10T00:00:00.000Z */
            visitDate: string;
            /**
             * @example CHECKUP
             * @enum {string|null}
             */
            visitType: "CHECKUP" | "EMERGENCY" | "SURGERY" | "FOLLOW_UP" | "VACCINATION" | "OTHER" | null;
            /** @example ã­ã“ã‚¯ãƒªãƒ‹ãƒƒã‚¯æ±äº¬ */
            hospitalName?: string;
            /** @example ãã—ã‚ƒã¿ãŒæ­¢ã¾ã‚‰ãªã„ */
            symptom?: string;
            symptomDetails?: components["schemas"]["MedicalRecordSymptomDto"][];
            /** @example çŒ«é¢¨é‚ª */
            diseaseName?: string;
            /** @example çŒ«é¢¨é‚ªã®å…†å€™ */
            diagnosis?: string;
            /** @example æŠ—ç”Ÿç‰©è³ªã‚’5æ—¥é–“æŠ•ä¸ */
            treatmentPlan?: string;
            medications?: components["schemas"]["MedicalRecordMedicationDto"][];
            /** @example 2025-08-13T00:00:00.000Z */
            followUpDate?: string;
            /**
             * @example TREATING
             * @enum {string}
             */
            status: "TREATING" | "COMPLETED";
            /** @example é£Ÿæ¬²ã¯æˆ»ã£ã¦ããŸ */
            notes?: string;
            cat: components["schemas"]["MedicalRecordCatDto"];
            schedule?: components["schemas"]["MedicalRecordScheduleDto"] | null;
            tags: components["schemas"]["MedicalRecordTagDto"][];
            attachments: components["schemas"]["MedicalRecordAttachmentDto"][];
            /** @example f3a2c1d7-1234-5678-90ab-cdef12345678 */
            recordedBy: string;
            /** @example 2025-08-10T09:30:00.000Z */
            createdAt: string;
            /** @example 2025-08-15T12:34:56.000Z */
            updatedAt: string;
        };
        MedicalRecordMetaDto: {
            /** @example 42 */
            total: number;
            /** @example 1 */
            page: number;
            /** @example 20 */
            limit: number;
            /** @example 3 */
            totalPages: number;
        };
        MedicalRecordListResponseDto: {
            /** @example true */
            success: boolean;
            data: components["schemas"]["MedicalRecordItemDto"][];
            meta: components["schemas"]["MedicalRecordMetaDto"];
        };
        MedicalRecordAttachmentInputDto: {
            /** @example https://cdn.example.com/xray.png */
            url: string;
            /** @example èƒ¸éƒ¨ãƒ¬ãƒ³ãƒˆã‚²ãƒ³ */
            description?: string;
            /** @example xray.png */
            fileName?: string;
            /** @example image/png */
            fileType?: string;
            /** @example 204800 */
            fileSize?: number;
            /** @example 2025-08-10T09:30:00.000Z */
            capturedAt?: string;
        };
        CreateMedicalRecordDto: {
            /**
             * @description çŒ«ID
             * @example e7b6a7a7-2d7f-4b2f-9f3a-1c2b3d4e5f60
             */
            catId: string;
            /**
             * @description ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ID
             * @example a6f7e52f-4a3b-4a76-9870-1234567890ab
             */
            scheduleId?: string;
            /**
             * @description å—è¨ºæ—¥
             * @example 2025-08-10
             */
            visitDate: string;
            /**
             * @example CHECKUP
             * @enum {string}
             */
            visitType?: "CHECKUP" | "EMERGENCY" | "SURGERY" | "FOLLOW_UP" | "VACCINATION" | "OTHER";
            /** @example ã­ã“ã‚¯ãƒªãƒ‹ãƒƒã‚¯æ±äº¬ */
            hospitalName?: string;
            /** @example ãã—ã‚ƒã¿ãŒæ­¢ã¾ã‚‰ãªã„ */
            symptom?: string;
            symptomDetails?: components["schemas"]["MedicalRecordSymptomDto"][];
            /** @example çŒ«é¢¨é‚ª */
            diseaseName?: string;
            /** @example çŒ«é¢¨é‚ªã®å…†å€™ */
            diagnosis?: string;
            /** @example æŠ—ç”Ÿç‰©è³ªã‚’5æ—¥é–“æŠ•ä¸ */
            treatmentPlan?: string;
            medications?: components["schemas"]["MedicalRecordMedicationDto"][];
            /** @example 2025-08-13 */
            followUpDate?: string;
            /**
             * @default TREATING
             * @example TREATING
             * @enum {string}
             */
            status: "TREATING" | "COMPLETED";
            /** @example é£Ÿæ¬²ã‚‚æˆ»ã‚Šã¤ã¤ã‚ã‚Š */
            notes?: string;
            /** @description é–¢é€£ã‚±ã‚¢ã‚¿ã‚°ID */
            careTagIds?: string[];
            /** @description æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ« */
            attachments?: components["schemas"]["MedicalRecordAttachmentInputDto"][];
        };
        MedicalRecordResponseDto: {
            /** @example true */
            success: boolean;
            data: components["schemas"]["MedicalRecordItemDto"];
        };
        CreateTagDto: {
            /**
             * @description ã‚¿ã‚°å
             * @example Indoor
             */
            name: string;
            /**
             * @description ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ID
             * @example aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee
             */
            groupId: string;
            /**
             * @description ã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰
             * @example #3B82F6
             */
            color?: string;
            /**
             * @description ãƒ†ã‚­ã‚¹ãƒˆã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰
             * @example #FFFFFF
             */
            textColor?: string;
            /**
             * @description èª¬æ˜
             * @example å®¤å†…é£¼ã„ã‚¿ã‚°
             */
            description?: string;
            /**
             * @description æ‰‹å‹•æ“ä½œã§åˆ©ç”¨å¯èƒ½ã‹
             * @example true
             */
            allowsManual?: boolean;
            /**
             * @description è‡ªå‹•ãƒ«ãƒ¼ãƒ«ã§åˆ©ç”¨å¯èƒ½ã‹
             * @example true
             */
            allowsAutomation?: boolean;
            /**
             * @description è¡¨ç¤ºé †
             * @example 10
             */
            displayOrder?: number;
            /** @description ä»»æ„ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ */
            metadata?: Record<string, never>;
            /**
             * @description ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹
             * @example true
             */
            isActive?: boolean;
        };
        TagOrderItemDto: {
            /**
             * Format: uuid
             * @description ã‚¿ã‚°ID
             */
            id: string;
            /**
             * @description è¡¨ç¤ºé †
             * @example 12
             */
            displayOrder: number;
            /**
             * Format: uuid
             * @description æ‰€å±ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ID
             */
            groupId?: string;
        };
        ReorderTagsDto: {
            items: components["schemas"]["TagOrderItemDto"][];
        };
        UpdateTagDto: {
            /**
             * @description ã‚¿ã‚°å
             * @example Indoor
             */
            name?: string;
            /**
             * @description ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ID
             * @example aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee
             */
            groupId?: string;
            /**
             * @description ã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰
             * @example #3B82F6
             */
            color?: string;
            /**
             * @description ãƒ†ã‚­ã‚¹ãƒˆã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰
             * @example #FFFFFF
             */
            textColor?: string;
            /**
             * @description èª¬æ˜
             * @example å®¤å†…é£¼ã„ã‚¿ã‚°
             */
            description?: string;
            /**
             * @description æ‰‹å‹•æ“ä½œã§åˆ©ç”¨å¯èƒ½ã‹
             * @example true
             */
            allowsManual?: boolean;
            /**
             * @description è‡ªå‹•ãƒ«ãƒ¼ãƒ«ã§åˆ©ç”¨å¯èƒ½ã‹
             * @example true
             */
            allowsAutomation?: boolean;
            /**
             * @description è¡¨ç¤ºé †
             * @example 10
             */
            displayOrder?: number;
            /** @description ä»»æ„ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ */
            metadata?: Record<string, never>;
            /**
             * @description ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹
             * @example true
             */
            isActive?: boolean;
        };
        AssignTagDto: {
            /**
             * @description ã‚¿ã‚°ID
             * @example aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee
             */
            tagId: string;
        };
        CreateTagCategoryDto: {
            /**
             * @description ãƒ¦ãƒ‹ãƒ¼ã‚¯ã‚­ãƒ¼ (æœªæŒ‡å®šæ™‚ã¯åå‰ã‹ã‚‰ç”Ÿæˆ)
             * @example cats_status
             */
            key?: string;
            /**
             * @description ã‚«ãƒ†ã‚´ãƒªå
             * @example çŒ«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
             */
            name: string;
            /** @description ã‚«ãƒ†ã‚´ãƒªã®èª¬æ˜ */
            description?: string;
            /**
             * @description ã‚«ãƒ†ã‚´ãƒªã®ä»£è¡¨ã‚«ãƒ©ãƒ¼
             * @example #6366F1
             */
            color?: string;
            /**
             * @description ã‚«ãƒ†ã‚´ãƒªã«ä½¿ç”¨ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆã‚«ãƒ©ãƒ¼
             * @example #111827
             */
            textColor?: string;
            /** @description è¡¨ç¤ºé † */
            displayOrder?: number;
            /** @description åˆ©ç”¨ã™ã‚‹ã‚¹ã‚³ãƒ¼ãƒ—ä¸€è¦§ */
            scopes?: string[];
            /**
             * @description ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹
             * @example true
             */
            isActive?: boolean;
        };
        TagCategoryOrderItemDto: {
            /**
             * Format: uuid
             * @description ã‚«ãƒ†ã‚´ãƒªID
             */
            id: string;
            /**
             * @description è¡¨ç¤ºé †
             * @example 10
             */
            displayOrder: number;
        };
        ReorderTagCategoriesDto: {
            items: components["schemas"]["TagCategoryOrderItemDto"][];
        };
        UpdateTagCategoryDto: {
            /**
             * @description ãƒ¦ãƒ‹ãƒ¼ã‚¯ã‚­ãƒ¼ (æœªæŒ‡å®šæ™‚ã¯åå‰ã‹ã‚‰ç”Ÿæˆ)
             * @example cats_status
             */
            key?: string;
            /**
             * @description ã‚«ãƒ†ã‚´ãƒªå
             * @example çŒ«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
             */
            name?: string;
            /** @description ã‚«ãƒ†ã‚´ãƒªã®èª¬æ˜ */
            description?: string;
            /**
             * @description ã‚«ãƒ†ã‚´ãƒªã®ä»£è¡¨ã‚«ãƒ©ãƒ¼
             * @example #6366F1
             */
            color?: string;
            /**
             * @description ã‚«ãƒ†ã‚´ãƒªã«ä½¿ç”¨ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆã‚«ãƒ©ãƒ¼
             * @example #111827
             */
            textColor?: string;
            /** @description è¡¨ç¤ºé † */
            displayOrder?: number;
            /** @description åˆ©ç”¨ã™ã‚‹ã‚¹ã‚³ãƒ¼ãƒ—ä¸€è¦§ */
            scopes?: string[];
            /**
             * @description ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹
             * @example true
             */
            isActive?: boolean;
        };
        CreateTagGroupDto: {
            /**
             * @description æ‰€å±ã‚«ãƒ†ã‚´ãƒªID
             * @example aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee
             */
            categoryId: string;
            /**
             * @description ã‚°ãƒ«ãƒ¼ãƒ—å
             * @example å±‹å†…ç®¡ç†
             */
            name: string;
            /** @description ã‚°ãƒ«ãƒ¼ãƒ—ã®èª¬æ˜ */
            description?: string;
            /**
             * @description è¡¨ç¤ºé †
             * @example 10
             */
            displayOrder?: number;
            /**
             * @description ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹
             * @example true
             */
            isActive?: boolean;
            /**
             * @description ã‚°ãƒ«ãƒ¼ãƒ—è¡¨ç¤ºç”¨ã®ã‚«ãƒ©ãƒ¼
             * @example #3B82F6
             */
            color?: string;
            /**
             * @description ã‚°ãƒ«ãƒ¼ãƒ—ã‚¿ã‚¤ãƒˆãƒ«ã®ãƒ†ã‚­ã‚¹ãƒˆã‚«ãƒ©ãƒ¼
             * @example #111827
             */
            textColor?: string;
        };
        TagGroupOrderItemDto: {
            /**
             * Format: uuid
             * @description ã‚°ãƒ«ãƒ¼ãƒ—ID
             */
            id: string;
            /**
             * @description è¡¨ç¤ºé †
             * @example 10
             */
            displayOrder: number;
            /**
             * Format: uuid
             * @description ç§»å‹•å…ˆã‚«ãƒ†ã‚´ãƒªID
             */
            categoryId?: string;
        };
        ReorderTagGroupDto: {
            items: components["schemas"]["TagGroupOrderItemDto"][];
        };
        UpdateTagGroupDto: {
            /**
             * @description æ‰€å±ã‚«ãƒ†ã‚´ãƒªID
             * @example aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee
             */
            categoryId?: string;
            /**
             * @description ã‚°ãƒ«ãƒ¼ãƒ—å
             * @example å±‹å†…ç®¡ç†
             */
            name?: string;
            /** @description ã‚°ãƒ«ãƒ¼ãƒ—ã®èª¬æ˜ */
            description?: string;
            /**
             * @description è¡¨ç¤ºé †
             * @example 10
             */
            displayOrder?: number;
            /**
             * @description ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹
             * @example true
             */
            isActive?: boolean;
            /**
             * @description ã‚°ãƒ«ãƒ¼ãƒ—è¡¨ç¤ºç”¨ã®ã‚«ãƒ©ãƒ¼
             * @example #3B82F6
             */
            color?: string;
            /**
             * @description ã‚°ãƒ«ãƒ¼ãƒ—ã‚¿ã‚¤ãƒˆãƒ«ã®ãƒ†ã‚­ã‚¹ãƒˆã‚«ãƒ©ãƒ¼
             * @example #111827
             */
            textColor?: string;
        };
        CreateTagAutomationRuleDto: {
            /** @description ãƒ«ãƒ¼ãƒ«ã®ä¸€æ„ãªã‚­ãƒ¼ï¼ˆè‡ªå‹•ç”Ÿæˆå¯èƒ½ï¼‰ */
            key?: string;
            /** @description ãƒ«ãƒ¼ãƒ«å */
            name: string;
            /** @description ãƒ«ãƒ¼ãƒ«ã®èª¬æ˜ */
            description?: string;
            /**
             * @description ãƒˆãƒªã‚¬ãƒ¼ã‚¿ã‚¤ãƒ—
             * @example EVENT
             * @enum {string}
             */
            triggerType: "EVENT" | "SCHEDULE" | "MANUAL";
            /**
             * @description ã‚¤ãƒ™ãƒ³ãƒˆã‚¿ã‚¤ãƒ—
             * @example BREEDING_PLANNED
             * @enum {string}
             */
            eventType: "BREEDING_PLANNED" | "BREEDING_CONFIRMED" | "PREGNANCY_CONFIRMED" | "KITTEN_REGISTERED" | "AGE_THRESHOLD" | "PAGE_ACTION" | "CUSTOM";
            /**
             * @description é©ç”¨ç¯„å›²ï¼ˆã‚¹ã‚³ãƒ¼ãƒ—ï¼‰
             * @example breeding
             */
            scope?: string;
            /**
             * @description ãƒ«ãƒ¼ãƒ«ãŒæœ‰åŠ¹ã‹ã©ã†ã‹
             * @default true
             */
            isActive: boolean;
            /**
             * @description å„ªå…ˆåº¦ï¼ˆ-100ã‹ã‚‰100ã€å¤§ãã„ã»ã©å„ªå…ˆï¼‰
             * @default 0
             */
            priority: number;
            /**
             * @description ãƒ«ãƒ¼ãƒ«è¨­å®šï¼ˆJSONï¼‰
             * @example {
             *       "tagIds": [
             *         "tag-id-1",
             *         "tag-id-2"
             *       ]
             *     }
             */
            config?: Record<string, never>;
        };
        UpdateTagAutomationRuleDto: {
            /** @description ãƒ«ãƒ¼ãƒ«ã®ä¸€æ„ãªã‚­ãƒ¼ï¼ˆè‡ªå‹•ç”Ÿæˆå¯èƒ½ï¼‰ */
            key?: string;
            /** @description ãƒ«ãƒ¼ãƒ«å */
            name?: string;
            /** @description ãƒ«ãƒ¼ãƒ«ã®èª¬æ˜ */
            description?: string;
            /**
             * @description ãƒˆãƒªã‚¬ãƒ¼ã‚¿ã‚¤ãƒ—
             * @example EVENT
             * @enum {string}
             */
            triggerType?: "EVENT" | "SCHEDULE" | "MANUAL";
            /**
             * @description ã‚¤ãƒ™ãƒ³ãƒˆã‚¿ã‚¤ãƒ—
             * @example BREEDING_PLANNED
             * @enum {string}
             */
            eventType?: "BREEDING_PLANNED" | "BREEDING_CONFIRMED" | "PREGNANCY_CONFIRMED" | "KITTEN_REGISTERED" | "AGE_THRESHOLD" | "PAGE_ACTION" | "CUSTOM";
            /**
             * @description é©ç”¨ç¯„å›²ï¼ˆã‚¹ã‚³ãƒ¼ãƒ—ï¼‰
             * @example breeding
             */
            scope?: string;
            /**
             * @description ãƒ«ãƒ¼ãƒ«ãŒæœ‰åŠ¹ã‹ã©ã†ã‹
             * @default true
             */
            isActive: boolean;
            /**
             * @description å„ªå…ˆåº¦ï¼ˆ-100ã‹ã‚‰100ã€å¤§ãã„ã»ã©å„ªå…ˆï¼‰
             * @default 0
             */
            priority: number;
            /**
             * @description ãƒ«ãƒ¼ãƒ«è¨­å®šï¼ˆJSONï¼‰
             * @example {
             *       "tagIds": [
             *         "tag-id-1",
             *         "tag-id-2"
             *       ]
             *     }
             */
            config?: Record<string, never>;
        };
        CreateStaffDto: Record<string, never>;
        UpdateStaffDto: Record<string, never>;
        CreateShiftDto: Record<string, never>;
        UpdateShiftDto: Record<string, never>;
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
};
export type $defs = Record<string, never>;
export interface operations {
    MasterDataController_getGenders: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description æ€§åˆ¥ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’è¿”å´ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    AuthController_login: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LoginDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    AuthController_register: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LoginDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    AuthController_setPassword: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LoginDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    AuthController_changePassword: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ChangePasswordDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    AuthController_requestPasswordReset: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RequestPasswordResetDto"];
            };
        };
        responses: {
            /** @description ãƒªã‚»ãƒƒãƒˆæ‰‹é †ã‚’ãƒ¡ãƒ¼ãƒ«ã§é€ä¿¡ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    AuthController_resetPassword: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ResetPasswordDto"];
            };
        };
        responses: {
            /** @description ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã—ãŸ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ç„¡åŠ¹ã¾ãŸã¯æœŸé™åˆ‡ã‚Œã®ãƒˆãƒ¼ã‚¯ãƒ³ */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    AuthController_refresh: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RefreshTokenDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    AuthController_logout: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CatsController_findAll: {
        parameters: {
            query?: {
                /** @description ãƒšãƒ¼ã‚¸ç•ªå· */
                page?: number;
                /** @description 1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•° */
                limit?: number;
                /** @description æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ */
                search?: string;
                /** @description å“ç¨®ID */
                breedId?: string;
                /** @description æ¯›è‰²ID */
                coatColorId?: string;
                /** @description æ€§åˆ¥ */
                gender?: "MALE" | "FEMALE" | "NEUTER" | "SPAY" | "1" | "2" | "3" | "4";
                /** @description æœ€å°å¹´é½¢ */
                ageMin?: number;
                /** @description æœ€å¤§å¹´é½¢ */
                ageMax?: number;
                /** @description ã‚½ãƒ¼ãƒˆé …ç›® */
                sortBy?: string;
                /** @description ã‚½ãƒ¼ãƒˆé † */
                sortOrder?: string;
                /** @description ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ */
                status?: unknown;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description çŒ«ãƒ‡ãƒ¼ã‚¿ã®ä¸€è¦§ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CatsController_create: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateCatDto"];
            };
        };
        responses: {
            /** @description çŒ«ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«ä½œæˆã•ã‚Œã¾ã—ãŸ */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§ã™ */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CatsController_getStatistics: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description çµ±è¨ˆæƒ…å ± */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CatsController_findOne: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description çŒ«ãƒ‡ãƒ¼ã‚¿ã®ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description çŒ«ãƒ‡ãƒ¼ã‚¿ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description çŒ«ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CatsController_remove: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description çŒ«ãƒ‡ãƒ¼ã‚¿ã®ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description çŒ«ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«å‰Šé™¤ã•ã‚Œã¾ã—ãŸ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description çŒ«ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CatsController_update: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description çŒ«ãƒ‡ãƒ¼ã‚¿ã®ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateCatDto"];
            };
        };
        responses: {
            /** @description çŒ«ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«æ›´æ–°ã•ã‚Œã¾ã—ãŸ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§ã™ */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description çŒ«ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CatsController_getBreedingHistory: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description çŒ«ãƒ‡ãƒ¼ã‚¿ã®ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description ç¹æ®–å±¥æ­´ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description çŒ«ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CatsController_getCareHistory: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description çŒ«ãƒ‡ãƒ¼ã‚¿ã®ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description ã‚±ã‚¢å±¥æ­´ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description çŒ«ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CatsController_getGenders: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description æ€§åˆ¥ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’è¿”å´ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    PedigreeController_findAll: {
        parameters: {
            query?: {
                /** @description ãƒšãƒ¼ã‚¸ç•ªå· */
                page?: number;
                /** @description 1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•° */
                limit?: number;
                /** @description æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ */
                search?: string;
                /** @description å“ç¨®ID */
                breedId?: string;
                /** @description æ¯›è‰²ID */
                coatColorId?: string;
                /** @description æ€§åˆ¥ (1: ã‚ªã‚¹, 2: ãƒ¡ã‚¹) */
                gender?: string;
                /** @description ã‚­ãƒ£ãƒƒãƒ†ãƒªãƒ¼å */
                catName2?: string;
                /** @description ç›®ã®è‰² */
                eyeColor?: string;
                /** @description ã‚½ãƒ¼ãƒˆé …ç›® */
                sortBy?: string;
                /** @description ã‚½ãƒ¼ãƒˆé † */
                sortOrder?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®ä¸€è¦§ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    PedigreeController_create: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreatePedigreeDto"];
            };
        };
        responses: {
            /** @description è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«ä½œæˆã•ã‚Œã¾ã—ãŸ */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§ã™ */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™ */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    PedigreeController_findByPedigreeId: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description è¡€çµ±æ›¸ç•ªå· */
                pedigreeId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    PedigreeController_findOne: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    PedigreeController_remove: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«å‰Šé™¤ã•ã‚Œã¾ã—ãŸ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™ */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    PedigreeController_update: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdatePedigreeDto"];
            };
        };
        responses: {
            /** @description è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«æ›´æ–°ã•ã‚Œã¾ã—ãŸ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§ã™ */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™ */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    PedigreeController_getFamilyTree: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description å®¶ç³»å›³ãƒ‡ãƒ¼ã‚¿ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    PedigreeController_getFamily: {
        parameters: {
            query?: {
                /** @description å–å¾—ã™ã‚‹ä¸–ä»£æ•° */
                generations?: number;
            };
            header?: never;
            path: {
                /** @description è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description å®¶ç³»å›³ãƒ‡ãƒ¼ã‚¿ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    PedigreeController_getDescendants: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description å­å­«ãƒ‡ãƒ¼ã‚¿ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    BreedsController_findAll: {
        parameters: {
            query?: {
                /** @description ãƒšãƒ¼ã‚¸ç•ªå· */
                page?: number;
                /** @description 1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•° */
                limit?: number;
                /** @description æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ */
                search?: string;
                /** @description ã‚½ãƒ¼ãƒˆé …ç›® */
                sortBy?: string;
                /** @description ã‚½ãƒ¼ãƒˆé † */
                sortOrder?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description å“ç¨®ãƒ‡ãƒ¼ã‚¿ã®ä¸€è¦§ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    BreedsController_create: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateBreedDto"];
            };
        };
        responses: {
            /** @description å“ç¨®ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«ä½œæˆã•ã‚Œã¾ã—ãŸ */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§ã™ */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™ */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    BreedsController_getStatistics: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description çµ±è¨ˆæƒ…å ± */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    BreedsController_findOne: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description å“ç¨®ãƒ‡ãƒ¼ã‚¿ã®ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description å“ç¨®ãƒ‡ãƒ¼ã‚¿ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description å“ç¨®ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    BreedsController_remove: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description å“ç¨®ãƒ‡ãƒ¼ã‚¿ã®ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description å“ç¨®ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«å‰Šé™¤ã•ã‚Œã¾ã—ãŸ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™ */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description å“ç¨®ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    BreedsController_update: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description å“ç¨®ãƒ‡ãƒ¼ã‚¿ã®ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateBreedDto"];
            };
        };
        responses: {
            /** @description å“ç¨®ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«æ›´æ–°ã•ã‚Œã¾ã—ãŸ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§ã™ */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™ */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description å“ç¨®ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CoatColorsController_findAll: {
        parameters: {
            query?: {
                /** @description ãƒšãƒ¼ã‚¸ç•ªå· */
                page?: number;
                /** @description 1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•° */
                limit?: number;
                /** @description æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ */
                search?: string;
                /** @description ã‚½ãƒ¼ãƒˆé …ç›® */
                sortBy?: string;
                /** @description ã‚½ãƒ¼ãƒˆé † */
                sortOrder?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã®ä¸€è¦§ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CoatColorsController_create: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateCoatColorDto"];
            };
        };
        responses: {
            /** @description æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«ä½œæˆã•ã‚Œã¾ã—ãŸ */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§ã™ */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™ */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CoatColorsController_getStatistics: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description çµ±è¨ˆæƒ…å ± */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CoatColorsController_findOne: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã®ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CoatColorsController_remove: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã®ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«å‰Šé™¤ã•ã‚Œã¾ã—ãŸ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™ */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CoatColorsController_update: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã®ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateCoatColorDto"];
            };
        };
        responses: {
            /** @description æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«æ›´æ–°ã•ã‚Œã¾ã—ãŸ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã§ã™ */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™ */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    BreedingController_findAll: {
        parameters: {
            query?: {
                page?: number;
                limit?: number;
                /** @description ãƒ¡ã‚¹çŒ«ID */
                femaleId?: string;
                /** @description ã‚ªã‚¹çŒ«ID */
                maleId?: string;
                /** @description é–‹å§‹æ—¥(YYYY-MM-DD) */
                dateFrom?: string;
                /** @description çµ‚äº†æ—¥(YYYY-MM-DD) */
                dateTo?: string;
                sortBy?: string;
                sortOrder?: "asc" | "desc";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    BreedingController_create: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateBreedingDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    BreedingController_findNgRules: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    BreedingController_createNgRule: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateBreedingNgRuleDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    BreedingController_removeNgRule: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    BreedingController_updateNgRule: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateBreedingNgRuleDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    BreedingController_test: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    BreedingController_findAllPregnancyChecks: {
        parameters: {
            query?: {
                /** @description æ¯è¦ªã®çŒ«ID */
                motherId?: string;
                /** @description å¦Šå¨ çŠ¶æ…‹ */
                status?: "CONFIRMED" | "SUSPECTED" | "NEGATIVE" | "ABORTED";
                /** @description ãƒšãƒ¼ã‚¸ç•ªå· */
                page?: number;
                /** @description 1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•° */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    BreedingController_createPregnancyCheck: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreatePregnancyCheckDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    BreedingController_removePregnancyCheck: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    BreedingController_updatePregnancyCheck: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdatePregnancyCheckDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    BreedingController_findAllBirthPlans: {
        parameters: {
            query?: {
                /** @description æ¯è¦ªã®çŒ«ID */
                motherId?: string;
                /** @description å‡ºç”£çŠ¶æ…‹ */
                status?: "EXPECTED" | "BORN" | "ABORTED" | "STILLBORN";
                /** @description ãƒšãƒ¼ã‚¸ç•ªå· */
                page?: number;
                /** @description 1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•° */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    BreedingController_createBirthPlan: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateBirthPlanDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    BreedingController_removeBirthPlan: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    BreedingController_updateBirthPlan: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateBirthPlanDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    BreedingController_findAllKittenDispositions: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                birthRecordId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    BreedingController_createKittenDisposition: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateKittenDispositionDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    BreedingController_removeKittenDisposition: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    BreedingController_updateKittenDisposition: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateKittenDispositionDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    BreedingController_completeBirthRecord: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CareController_findSchedules: {
        parameters: {
            query?: {
                page?: number;
                limit?: number;
                /** @description çŒ«ID */
                catId?: string;
                /** @description ã‚±ã‚¢ç¨®åˆ¥ */
                careType?: "VACCINATION" | "HEALTH_CHECK" | "GROOMING" | "DENTAL_CARE" | "MEDICATION" | "SURGERY" | "OTHER";
                /** @description é–‹å§‹æ—¥ (YYYY-MM-DD) */
                dateFrom?: string;
                /** @description çµ‚äº†æ—¥ (YYYY-MM-DD) */
                dateTo?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CareScheduleListResponseDto"];
                };
            };
        };
    };
    CareController_addSchedule: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateCareScheduleDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CareScheduleResponseDto"];
                };
            };
        };
    };
    CareController_complete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CompleteCareDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CareCompleteResponseDto"];
                };
            };
        };
    };
    CareController_deleteSchedule: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description å‰Šé™¤æˆåŠŸ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    CareController_updateSchedule: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateCareScheduleDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CareScheduleResponseDto"];
                };
            };
        };
    };
    CareController_findMedicalRecords: {
        parameters: {
            query?: {
                page?: number;
                limit?: number;
                /** @description çŒ«ID */
                catId?: string;
                /** @description ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ID */
                scheduleId?: string;
                visitType?: "CHECKUP" | "EMERGENCY" | "SURGERY" | "FOLLOW_UP" | "VACCINATION" | "OTHER";
                status?: "TREATING" | "COMPLETED";
                /** @description å—è¨ºé–‹å§‹æ—¥ */
                dateFrom?: string;
                /** @description å—è¨ºçµ‚äº†æ—¥ */
                dateTo?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MedicalRecordListResponseDto"];
                };
            };
        };
    };
    CareController_addMedicalRecord: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateMedicalRecordDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MedicalRecordResponseDto"];
                };
            };
        };
    };
    TagsController_findAll: {
        parameters: {
            query?: {
                /** @description éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¿ã‚°ã‚’å«ã‚ã‚‹ã‹ */
                includeInactive?: boolean;
                /** @description å¯¾è±¡ã‚¹ã‚³ãƒ¼ãƒ— */
                scope?: string[];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TagsController_create: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateTagDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TagsController_reorder: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ReorderTagsDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TagsController_remove: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TagsController_update: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateTagDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TagsController_assign: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AssignTagDto"];
            };
        };
        responses: {
            /** @description ä»˜ä¸æˆåŠŸï¼ˆé‡è¤‡æ™‚ã‚‚OKï¼‰ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TagsController_unassign: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
                tagId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TagCategoriesController_findAll: {
        parameters: {
            query?: {
                /** @description éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ†ã‚´ãƒªã‚’å«ã‚ã‚‹ */
                includeInactive?: boolean;
                /** @description å¯¾è±¡ã‚¹ã‚³ãƒ¼ãƒ— */
                scope?: string[];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TagCategoriesController_create: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateTagCategoryDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TagCategoriesController_reorder: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ReorderTagCategoriesDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TagCategoriesController_remove: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TagCategoriesController_update: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateTagCategoryDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TagGroupsController_create: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateTagGroupDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TagGroupsController_reorder: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ReorderTagGroupDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TagGroupsController_remove: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TagGroupsController_update: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateTagGroupDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TagAutomationController_findRules: {
        parameters: {
            query?: {
                /** @description ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ«ãƒ¼ãƒ«ã®ã¿å–å¾— */
                active?: boolean;
                /** @description ã‚¹ã‚³ãƒ¼ãƒ—ã§ãƒ•ã‚£ãƒ«ã‚¿ */
                scope?: string;
                /** @description ãƒˆãƒªã‚¬ãƒ¼ã‚¿ã‚¤ãƒ—ã§ãƒ•ã‚£ãƒ«ã‚¿ */
                triggerType?: string;
                /** @description ã‚¤ãƒ™ãƒ³ãƒˆã‚¿ã‚¤ãƒ—ã§ãƒ•ã‚£ãƒ«ã‚¿ */
                eventType?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description ãƒ«ãƒ¼ãƒ«ä¸€è¦§ã‚’è¿”å´ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TagAutomationController_createRule: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateTagAutomationRuleDto"];
            };
        };
        responses: {
            /** @description ãƒ«ãƒ¼ãƒ«ã‚’ä½œæˆã—ã¾ã—ãŸ */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description å…¥åŠ›ã‚¨ãƒ©ãƒ¼ */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TagAutomationController_findRuleById: {
        parameters: {
            query?: {
                /** @description å®Ÿè¡Œå±¥æ­´ã‚’å«ã‚ã‚‹ */
                includeRuns?: boolean;
                /** @description ä»˜ä¸å±¥æ­´ä»¶æ•°ã‚’å«ã‚ã‚‹ */
                includeHistoryCount?: boolean;
            };
            header?: never;
            path: {
                /** @description ãƒ«ãƒ¼ãƒ«ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description ãƒ«ãƒ¼ãƒ«è©³ç´°ã‚’è¿”å´ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ãƒ«ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TagAutomationController_deleteRule: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ãƒ«ãƒ¼ãƒ«ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description ãƒ«ãƒ¼ãƒ«ã‚’å‰Šé™¤ã—ã¾ã—ãŸ */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ãƒ«ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TagAutomationController_updateRule: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ãƒ«ãƒ¼ãƒ«ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateTagAutomationRuleDto"];
            };
        };
        responses: {
            /** @description ãƒ«ãƒ¼ãƒ«ã‚’æ›´æ–°ã—ã¾ã—ãŸ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ãƒ«ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TagAutomationController_findRuns: {
        parameters: {
            query?: {
                /** @description ãƒ«ãƒ¼ãƒ«IDã§ãƒ•ã‚£ãƒ«ã‚¿ */
                ruleId?: string;
                /** @description ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã§ãƒ•ã‚£ãƒ«ã‚¿ (PENDING, COMPLETED, FAILED) */
                status?: string;
                /** @description å–å¾—ä»¶æ•°ã®ä¸Šé™ */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description å®Ÿè¡Œå±¥æ­´ä¸€è¦§ã‚’è¿”å´ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TagAutomationController_executeRule: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ãƒ«ãƒ¼ãƒ«ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description ãƒ«ãƒ¼ãƒ«å®Ÿè¡ŒæˆåŠŸ */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    HealthController_check: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StaffController_findAll: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StaffController_create: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateStaffDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StaffController_findOne: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StaffController_remove: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StaffController_update: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateStaffDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    StaffController_restore: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    ShiftController_findAll: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    ShiftController_create: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateShiftDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    ShiftController_getCalendarData: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    ShiftController_findOne: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    ShiftController_remove: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    ShiftController_update: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateShiftDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
}
````

## File: frontend/src/lib/api/hooks/query-key-factory.ts
````typescript
/**
 * Generic factory utility for building TanStack Query keys per domain.
 */

export type DomainQueryKeyFactory<Identifier = string, Filters = Record<string, unknown>> = {
  readonly all: readonly [string];
  lists: () => readonly [string, 'list'];
  list: (filters?: Filters) => readonly [string, 'list', Filters | undefined];
  details: () => readonly [string, 'detail'];
  detail: (id: Identifier) => readonly [string, 'detail', Identifier];
  extras?: Record<string, (...args: unknown[]) => readonly unknown[]>;
};

export function createDomainQueryKeys<Identifier = string, Filters = Record<string, unknown>>(
  domain: string,
  options?: {
    extras?: Record<string, (...args: unknown[]) => readonly unknown[]>;
  },
): DomainQueryKeyFactory<Identifier, Filters> {
  const base = [domain] as const;

  const factory: DomainQueryKeyFactory<Identifier, Filters> = {
    all: base,
    lists: () => [...base, 'list'] as const,
    list: (filters?: Filters) => [...base, 'list', filters] as const,
    details: () => [...base, 'detail'] as const,
    detail: (id: Identifier) => [...base, 'detail', id] as const,
  };

  if (options?.extras) {
    factory.extras = Object.fromEntries(
      Object.entries(options.extras).map(([key, builder]) => [
        key,
        (...args: unknown[]) => [...base, key, ...builder(...args)] as const,
      ]),
    );
  }

  return factory;
}
````

## File: frontend/src/lib/api/hooks/use-breeding.ts
````typescript
/**
 * äº¤é…ç®¡ç†APIãƒ•ãƒƒã‚¯
 */

import { useMutation, useQuery, useQueryClient, type UseQueryOptions } from '@tanstack/react-query';
import { notifications } from '@mantine/notifications';
import {
  apiClient,
  apiRequest,
  type ApiQueryParams,
  type ApiRequestBody,
  type ApiResponse,
} from '../client';
import { createDomainQueryKeys } from './query-key-factory';

export type BreedingStatus = 'PLANNED' | 'IN_PROGRESS' | 'COMPLETED' | 'FAILED';

export interface BreedingRecord {
  id: string;
  maleId: string;
  femaleId: string;
  breedingDate: string;
  expectedDueDate?: string | null;
  actualDueDate?: string | null;
  numberOfKittens?: number | null;
  notes?: string | null;
  status: BreedingStatus;
  recordedBy: string;
  createdAt: string;
  updatedAt: string;
  male?: { id: string; name: string | null } | null;
  female?: { id: string; name: string | null } | null;
}

export interface BreedingListMeta {
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export type GetBreedingParams = ApiQueryParams<'/breeding', 'get'>;

export interface BreedingListResponse {
  success: boolean;
  data?: BreedingRecord[];
  meta?: BreedingListMeta;
  message?: string;
  error?: string;
}

export type CreateBreedingRequest = ApiRequestBody<'/breeding', 'post'>;
export type UpdateBreedingRequest = Partial<CreateBreedingRequest>;

const breedingKeys = createDomainQueryKeys<string, GetBreedingParams>('breeding');

export type BreedingNgRuleType = 'TAG_COMBINATION' | 'INDIVIDUAL_PROHIBITION' | 'GENERATION_LIMIT';

export interface BreedingNgRule {
  id: string;
  name: string;
  description: string | null;
  type: BreedingNgRuleType;
  maleConditions: string[];
  femaleConditions: string[];
  maleNames: string[];
  femaleNames: string[];
  generationLimit: number | null;
  active: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface BreedingNgRuleFilter {
  active?: boolean;
  type?: BreedingNgRuleType;
  search?: string;
}

export type CreateBreedingNgRuleRequest = {
  name: string;
  description?: string;
  type: BreedingNgRuleType;
  active?: boolean;
  maleConditions?: string[];
  femaleConditions?: string[];
  maleNames?: string[];
  femaleNames?: string[];
  generationLimit?: number;
};

export type UpdateBreedingNgRuleRequest = Partial<CreateBreedingNgRuleRequest>;

export type BreedingNgRuleListResponse = ApiResponse<BreedingNgRule[]>;
export type BreedingNgRuleResponse = ApiResponse<BreedingNgRule>;

const breedingNgRuleKeys = createDomainQueryKeys<string, BreedingNgRuleFilter>('breeding-ng-rules', {
  extras: {
    filterState: (...args: unknown[]) => {
      const [filters] = args as [BreedingNgRuleFilter | undefined];
      return [filters ?? {}] as const;
    },
    type: (...args: unknown[]) => {
      const [type] = args as [BreedingNgRuleType | 'ALL' | undefined];
      return [type ?? 'ALL'] as const;
    },
    search: (...args: unknown[]) => {
      const [keyword] = args as [string | undefined];
      return [keyword ?? ''] as const;
    },
  },
});

// Pregnancy Check types and hooks
export type PregnancyStatus = 'CONFIRMED' | 'SUSPECTED' | 'NEGATIVE' | 'ABORTED';

export interface PregnancyCheck {
  id: string;
  motherId: string;
  fatherId?: string | null;
  matingDate?: string | null;
  checkDate: string;
  status: PregnancyStatus;
  notes?: string | null;
  createdAt: string;
  updatedAt: string;
  mother?: { id: string; name: string | null } | null;
  father?: { id: string; name: string | null } | null;
}

export interface PregnancyCheckListResponse {
  success: boolean;
  data?: PregnancyCheck[];
  meta?: BreedingListMeta;
  message?: string;
  error?: string;
}

export type CreatePregnancyCheckRequest = {
  motherId: string;
  fatherId?: string;
  matingDate?: string;
  checkDate: string;
  status: PregnancyStatus;
  notes?: string;
};

export type UpdatePregnancyCheckRequest = Partial<CreatePregnancyCheckRequest>;

const pregnancyCheckKeys = createDomainQueryKeys<string, Record<string, unknown>>('pregnancy-checks');

// Birth Plan types and hooks
export type BirthStatus = 'EXPECTED' | 'BORN' | 'ABORTED' | 'STILLBORN';

export interface BirthPlan {
  id: string;
  motherId: string;
  fatherId?: string | null;
  matingDate?: string | null;
  expectedBirthDate: string;
  actualBirthDate?: string | null;
  status: BirthStatus;
  expectedKittens?: number | null;
  actualKittens?: number | null;
  aliveCount?: number | null;
  notes?: string | null;
  completedAt?: string | null;
  createdAt: string;
  updatedAt: string;
  mother?: { id: string; name: string | null } | null;
  father?: { id: string; name: string | null } | null;
  kittenDispositions?: KittenDisposition[] | null;
}

export interface BirthPlanListResponse {
  success: boolean;
  data?: BirthPlan[];
  meta?: BreedingListMeta;
  message?: string;
  error?: string;
}

export type CreateBirthPlanRequest = {
  motherId: string;
  fatherId?: string;
  matingDate?: string;
  expectedBirthDate: string;
  actualBirthDate?: string;
  status: BirthStatus;
  expectedKittens?: number;
  actualKittens?: number;
  notes?: string;
};

export type UpdateBirthPlanRequest = Partial<CreateBirthPlanRequest>;

export type GetBirthPlanParams = ApiQueryParams<'/breeding/birth-plans', 'get'>;

const birthPlanKeys = createDomainQueryKeys<string, GetBirthPlanParams>('birth-plans');

export { breedingKeys };
export { breedingNgRuleKeys };
export { pregnancyCheckKeys };
export { birthPlanKeys };

export function useGetBreedingRecords(
  params: GetBreedingParams = {},
  options?: Omit<UseQueryOptions<BreedingListResponse>, 'queryKey' | 'queryFn'>,
) {
  return useQuery({
    queryKey: breedingKeys.list(params),
    queryFn: () =>
      apiClient.get('/breeding', {
        query: params,
      }) as Promise<BreedingListResponse>,
    ...options,
  });
}

export function useCreateBreedingRecord() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (payload: CreateBreedingRequest) =>
      apiClient.post('/breeding', {
        body: payload,
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: breedingKeys.lists() });
      notifications.show({
        title: 'äº¤é…è¨˜éŒ²ã‚’ç™»éŒ²ã—ã¾ã—ãŸ',
        message: 'äº¤é…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ç®¡ç†ç”»é¢ã«åæ˜ ã—ã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'äº¤é…è¨˜éŒ²ã®ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'å…¥åŠ›å†…å®¹ã‚’ã”ç¢ºèªã®ä¸Šã€å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}

// Note: /breeding/{id} endpoints (PATCH, DELETE) are not available in current API
// Use pregnancy-checks and birth-plans endpoints instead for post-breeding management

// export function useUpdateBreedingRecord(
//   id: string,
// ) {
//   const queryClient = useQueryClient();

//   return useMutation({
//     mutationFn: (payload: UpdateBreedingRequest) =>
//       apiClient.patch('/breeding/{id}', {
//         pathParams: { id } as ApiPathParams<'/breeding/{id}', 'patch'>,
//         body: payload as ApiRequestBody<'/breeding/{id}', 'patch'>,
//       }),
//     onSuccess: () => {
//       void queryClient.invalidateQueries({ queryKey: breedingKeys.lists() });
//       notifications.show({
//         title: 'äº¤é…è¨˜éŒ²ã‚’æ›´æ–°ã—ã¾ã—ãŸ',
//         message: 'æœ€æ–°ã®æƒ…å ±ã«æ›´æ–°ã•ã‚Œã¾ã—ãŸã€‚',
//         color: 'teal',
//       });
//     },
//     onError: (error: Error) => {
//       notifications.show({
//         title: 'äº¤é…è¨˜éŒ²ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ',
//         message: error.message ?? 'æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
//         color: 'red',
//       });
//     },
//   });
// }

// export function useDeleteBreedingRecord() {
//   const queryClient = useQueryClient();

//   return useMutation({
//     mutationFn: (recordId: string) =>
//       apiClient.delete('/breeding/{id}', {
//         pathParams: { id: recordId } as ApiPathParams<'/breeding/{id}', 'delete'>,
//       }),
//     onSuccess: () => {
//       void queryClient.invalidateQueries({ queryKey: breedingKeys.lists() });
//       notifications.show({
//         title: 'äº¤é…è¨˜éŒ²ã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
//         message: 'ãƒªã‚¹ãƒˆã‹ã‚‰è©²å½“ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚',
//         color: 'teal',
//       });
//     },
//     onError: (error: Error) => {
//       notifications.show({
//         title: 'äº¤é…è¨˜éŒ²ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ',
//         message: error.message ?? 'æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
//         color: 'red',
//       });
//     },
//   });
// }

const NG_RULES_ENDPOINT = '/breeding/ng-rules';

function buildNgRuleEndpoint(id?: string): string {
  if (!id) {
    return NG_RULES_ENDPOINT;
  }

  return `${NG_RULES_ENDPOINT}/${id}`;
}

export function useGetBreedingNgRules(
  options?: Omit<UseQueryOptions<BreedingNgRuleListResponse, Error, BreedingNgRuleListResponse>, 'queryKey' | 'queryFn'>,
) {
  return useQuery({
    queryKey: breedingNgRuleKeys.lists(),
    queryFn: () => apiRequest<BreedingNgRule[]>(buildNgRuleEndpoint(), { method: 'GET' }),
    staleTime: 60 * 1000,
    ...options,
  });
}

export function useCreateBreedingNgRule() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (payload: CreateBreedingNgRuleRequest) =>
      apiRequest<BreedingNgRule>(buildNgRuleEndpoint(), {
        method: 'POST',
        body: JSON.stringify(payload),
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: breedingNgRuleKeys.lists() });
      notifications.show({
        title: 'NGãƒ«ãƒ¼ãƒ«ã‚’ç™»éŒ²ã—ã¾ã—ãŸ',
        message: 'äº¤é…NGãƒ«ãƒ¼ãƒ«ã‚’è¿½åŠ ã—ã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'NGãƒ«ãƒ¼ãƒ«ã®ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}

export interface UpdateBreedingNgRuleVariables {
  id: string;
  payload: UpdateBreedingNgRuleRequest;
}

export function useUpdateBreedingNgRule() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, payload }: UpdateBreedingNgRuleVariables) =>
      apiRequest<BreedingNgRule>(buildNgRuleEndpoint(id), {
        method: 'PATCH',
        body: JSON.stringify(payload),
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: breedingNgRuleKeys.lists() });
      notifications.show({
        title: 'NGãƒ«ãƒ¼ãƒ«ã‚’æ›´æ–°ã—ã¾ã—ãŸ',
        message: 'äº¤é…NGãƒ«ãƒ¼ãƒ«ã®å†…å®¹ã‚’æ›´æ–°ã—ã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'NGãƒ«ãƒ¼ãƒ«ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}

export function useDeleteBreedingNgRule() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (ruleId: string) =>
      apiRequest<unknown>(buildNgRuleEndpoint(ruleId), {
        method: 'DELETE',
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: breedingNgRuleKeys.lists() });
      notifications.show({
        title: 'NGãƒ«ãƒ¼ãƒ«ã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
        message: 'äº¤é…NGãƒ«ãƒ¼ãƒ«ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'NGãƒ«ãƒ¼ãƒ«ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}

// Pregnancy Check hooks
export function useGetPregnancyChecks(
  params: Record<string, unknown> = {},
  options?: Omit<UseQueryOptions<PregnancyCheckListResponse>, 'queryKey' | 'queryFn'>,
) {
  return useQuery({
    queryKey: pregnancyCheckKeys.list(params),
    queryFn: () => {
      // ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰
      const searchParams = new URLSearchParams();
      Object.entries(params)
        .filter(([, value]) => value !== undefined && value !== null)
        .forEach(([key, value]) => {
          if (Array.isArray(value)) {
            value.forEach((v) => {
              searchParams.append(key, String(v));
            });
          } else {
            searchParams.append(key, String(value));
          }
        });
      const queryString = searchParams.toString();
      const url = queryString ? `/breeding/pregnancy-checks?${queryString}` : '/breeding/pregnancy-checks';
      
      return apiRequest<PregnancyCheck[]>(url, { 
        method: 'GET'
      }) as Promise<PregnancyCheckListResponse>;
    },
    ...options,
  });
}

export function useCreatePregnancyCheck() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (payload: CreatePregnancyCheckRequest) =>
      apiRequest<PregnancyCheck>('/breeding/pregnancy-checks', {
        method: 'POST',
        body: JSON.stringify(payload),
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: pregnancyCheckKeys.lists() });
      notifications.show({
        title: 'å¦Šå¨ ãƒã‚§ãƒƒã‚¯ã‚’ç™»éŒ²ã—ã¾ã—ãŸ',
        message: 'å¦Šå¨ ç¢ºèªãƒªã‚¹ãƒˆã«è¿½åŠ ã—ã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'å¦Šå¨ ãƒã‚§ãƒƒã‚¯ã®ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'å…¥åŠ›å†…å®¹ã‚’ã”ç¢ºèªã®ä¸Šã€å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}

export function useUpdatePregnancyCheck() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, payload }: { id: string; payload: UpdatePregnancyCheckRequest }) =>
      apiRequest<PregnancyCheck>(`/breeding/pregnancy-checks/${id}`, {
        method: 'PATCH',
        body: JSON.stringify(payload),
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: pregnancyCheckKeys.lists() });
      notifications.show({
        title: 'å¦Šå¨ ãƒã‚§ãƒƒã‚¯ã‚’æ›´æ–°ã—ã¾ã—ãŸ',
        message: 'æœ€æ–°ã®æƒ…å ±ã«æ›´æ–°ã•ã‚Œã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'å¦Šå¨ ãƒã‚§ãƒƒã‚¯ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}

export function useDeletePregnancyCheck() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id: string) =>
      apiRequest<unknown>(`/breeding/pregnancy-checks/${id}`, {
        method: 'DELETE',
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: pregnancyCheckKeys.lists() });
      notifications.show({
        title: 'å¦Šå¨ ãƒã‚§ãƒƒã‚¯ã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
        message: 'ãƒªã‚¹ãƒˆã‹ã‚‰è©²å½“ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'å¦Šå¨ ãƒã‚§ãƒƒã‚¯ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}

// Birth Plan hooks
export function useGetBirthPlans(
  params: GetBirthPlanParams = {},
  options?: Omit<UseQueryOptions<BirthPlanListResponse>, 'queryKey' | 'queryFn'>,
) {
  return useQuery({
    queryKey: birthPlanKeys.list(params),
    queryFn: () =>
      apiClient.get('/breeding/birth-plans', {
        query: params,
      }) as Promise<BirthPlanListResponse>,
    ...options,
  });
}

export function useCreateBirthPlan() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (payload: CreateBirthPlanRequest) =>
      apiRequest<BirthPlan>('/breeding/birth-plans', {
        method: 'POST',
        body: JSON.stringify(payload),
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: birthPlanKeys.lists() });
      notifications.show({
        title: 'å‡ºç”£è¨ˆç”»ã‚’ç™»éŒ²ã—ã¾ã—ãŸ',
        message: 'å‡ºç”£äºˆå®šãƒªã‚¹ãƒˆã«è¿½åŠ ã—ã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'å‡ºç”£è¨ˆç”»ã®ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'å…¥åŠ›å†…å®¹ã‚’ã”ç¢ºèªã®ä¸Šã€å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}

export function useUpdateBirthPlan() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, payload }: { id: string; payload: UpdateBirthPlanRequest }) =>
      apiRequest<BirthPlan>(`/breeding/birth-plans/${id}`, {
        method: 'PATCH',
        body: JSON.stringify(payload),
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: birthPlanKeys.lists() });
      notifications.show({
        title: 'å‡ºç”£è¨ˆç”»ã‚’æ›´æ–°ã—ã¾ã—ãŸ',
        message: 'æœ€æ–°ã®æƒ…å ±ã«æ›´æ–°ã•ã‚Œã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'å‡ºç”£è¨ˆç”»ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}

export function useDeleteBirthPlan() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id: string) =>
      apiRequest<unknown>(`/breeding/birth-plans/${id}`, {
        method: 'DELETE',
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: birthPlanKeys.lists() });
      notifications.show({
        title: 'å‡ºç”£è¨ˆç”»ã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
        message: 'ãƒªã‚¹ãƒˆã‹ã‚‰è©²å½“ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'å‡ºç”£è¨ˆç”»ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}

// ========== Kitten Disposition ==========

export type DispositionType = 'TRAINING' | 'SALE' | 'DECEASED';

export interface SaleInfo {
  buyer: string;
  price: number;
  saleDate: string;
  notes?: string;
}

export interface KittenDisposition {
  id: string;
  birthRecordId: string;
  kittenId?: string | null;
  name: string;
  gender: string;
  disposition: DispositionType;
  trainingStartDate?: string | null;
  saleInfo?: SaleInfo | null;
  deathDate?: string | null;
  deathReason?: string | null;
  notes?: string | null;
  createdAt: string;
  updatedAt: string;
  kitten?: { id: string; name: string } | null;
}

export type CreateKittenDispositionRequest = {
  birthRecordId: string;
  kittenId?: string;
  name: string;
  gender: string;
  disposition: DispositionType;
  trainingStartDate?: string;
  saleInfo?: SaleInfo;
  deathDate?: string;
  deathReason?: string;
  notes?: string;
};

export type UpdateKittenDispositionRequest = Partial<Omit<CreateKittenDispositionRequest, 'birthRecordId'>>;

export type KittenDispositionListResponse = ApiResponse<KittenDisposition[]>;

const kittenDispositionKeys = createDomainQueryKeys<string>('kitten-dispositions');

export function useGetKittenDispositions(birthRecordId: string) {
  return useQuery<KittenDispositionListResponse>({
    queryKey: kittenDispositionKeys.detail(birthRecordId),
    queryFn: () => apiRequest<KittenDisposition[]>(`/breeding/kitten-dispositions/${birthRecordId}`),
    enabled: !!birthRecordId,
  });
}

export function useCreateKittenDisposition() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (payload: CreateKittenDispositionRequest) =>
      apiRequest<KittenDisposition>('/breeding/kitten-dispositions', {
        method: 'POST',
        body: JSON.stringify(payload),
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: kittenDispositionKeys.all });
      void queryClient.invalidateQueries({ queryKey: birthPlanKeys.lists() });
      notifications.show({
        title: 'å­çŒ«å‡¦é‡ã‚’ç™»éŒ²ã—ã¾ã—ãŸ',
        message: 'å­çŒ«ã®å‡¦é‡ãŒæ­£å¸¸ã«ç™»éŒ²ã•ã‚Œã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'å­çŒ«å‡¦é‡ã®ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}

export function useUpdateKittenDisposition() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, payload }: { id: string; payload: UpdateKittenDispositionRequest }) =>
      apiRequest<KittenDisposition>(`/breeding/kitten-dispositions/${id}`, {
        method: 'PATCH',
        body: JSON.stringify(payload),
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: kittenDispositionKeys.all });
      void queryClient.invalidateQueries({ queryKey: birthPlanKeys.lists() });
      notifications.show({
        title: 'å­çŒ«å‡¦é‡ã‚’æ›´æ–°ã—ã¾ã—ãŸ',
        message: 'æœ€æ–°ã®æƒ…å ±ã«æ›´æ–°ã•ã‚Œã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'å­çŒ«å‡¦é‡ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}

export function useDeleteKittenDisposition() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id: string) =>
      apiRequest<unknown>(`/breeding/kitten-dispositions/${id}`, {
        method: 'DELETE',
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: kittenDispositionKeys.all });
      void queryClient.invalidateQueries({ queryKey: birthPlanKeys.lists() });
      notifications.show({
        title: 'å­çŒ«å‡¦é‡ã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
        message: 'ãƒªã‚¹ãƒˆã‹ã‚‰è©²å½“ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'å­çŒ«å‡¦é‡ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}

export function useCompleteBirthRecord() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id: string) =>
      apiRequest<unknown>(`/breeding/birth-plans/${id}/complete`, {
        method: 'POST',
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: birthPlanKeys.lists() });
      notifications.show({
        title: 'å‡ºç”£è¨˜éŒ²ã‚’å®Œäº†ã—ã¾ã—ãŸ',
        message: 'å‡ºç”£è¨˜éŒ²ãŒå®Œäº†æ¸ˆã¿ã¨ã—ã¦ãƒãƒ¼ã‚¯ã•ã‚Œã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'å‡ºç”£è¨˜éŒ²ã®å®Œäº†ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}

// ========== Breeding Schedule ==========

export type BreedingScheduleStatus = 'SCHEDULED' | 'IN_PROGRESS' | 'COMPLETED' | 'CANCELLED';

export interface MatingCheck {
  id: string;
  scheduleId: string;
  checkDate: string;
  count: number;
  createdAt: string;
}

export interface BreedingSchedule {
  id: string;
  maleId: string;
  femaleId: string;
  startDate: string;
  duration: number;
  status: BreedingScheduleStatus;
  notes?: string | null;
  recordedBy: string;
  createdAt: string;
  updatedAt: string;
  male?: { id: string; name: string | null } | null;
  female?: { id: string; name: string | null } | null;
  checks?: MatingCheck[];
}

export interface BreedingScheduleListResponse {
  success: boolean;
  data?: BreedingSchedule[];
  meta?: BreedingListMeta;
  message?: string;
  error?: string;
}

export type CreateBreedingScheduleRequest = {
  maleId: string;
  femaleId: string;
  startDate: string;
  duration: number;
  status?: BreedingScheduleStatus;
  notes?: string;
};

export type UpdateBreedingScheduleRequest = Partial<CreateBreedingScheduleRequest>;

export interface BreedingScheduleQueryParams {
  page?: number;
  limit?: number;
  maleId?: string;
  femaleId?: string;
  status?: BreedingScheduleStatus;
  dateFrom?: string;
  dateTo?: string;
}

const breedingScheduleKeys = createDomainQueryKeys<string, BreedingScheduleQueryParams>('breeding-schedules');

export { breedingScheduleKeys };

export function useGetBreedingSchedules(
  params: BreedingScheduleQueryParams = {},
  options?: Omit<UseQueryOptions<BreedingScheduleListResponse>, 'queryKey' | 'queryFn'>,
) {
  return useQuery({
    queryKey: breedingScheduleKeys.list(params),
    queryFn: async () => {
      const searchParams = new URLSearchParams();
      Object.entries(params)
        .filter(([, value]) => value !== undefined && value !== null)
        .forEach(([key, value]) => {
          searchParams.append(key, String(value));
        });
      const queryString = searchParams.toString();
      const url = queryString ? `/breeding/schedules?${queryString}` : '/breeding/schedules';
      
      // apiRequest ã¯ ApiResponse<T> ã‚’è¿”ã™ãŸã‚ã€å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«ã¯é…åˆ—å‹ã‚’æŒ‡å®š
      const response = await apiRequest<BreedingSchedule[]>(url, { 
        method: 'GET'
      });
      
      // ApiResponse å½¢å¼ã‚’ãã®ã¾ã¾ BreedingScheduleListResponse ã¨ã—ã¦è¿”ã™
      // apiRequest ã¯æ—¢ã« ApiResponse<BreedingSchedule[]> ã‚’è¿”ã™ãŸã‚ã€ã“ã‚ŒãŒæ­£ã—ã„å½¢å¼
      return response as BreedingScheduleListResponse;
    },
    ...options,
  });
}

export function useCreateBreedingSchedule() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (payload: CreateBreedingScheduleRequest) =>
      apiRequest<BreedingSchedule>('/breeding/schedules', {
        method: 'POST',
        body: JSON.stringify(payload),
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: breedingScheduleKeys.lists() });
      notifications.show({
        title: 'äº¤é…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ç™»éŒ²ã—ã¾ã—ãŸ',
        message: 'ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒæ­£å¸¸ã«ç™»éŒ²ã•ã‚Œã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'äº¤é…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'å…¥åŠ›å†…å®¹ã‚’ã”ç¢ºèªã®ä¸Šã€å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}

export function useUpdateBreedingSchedule() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, payload }: { id: string; payload: UpdateBreedingScheduleRequest }) =>
      apiRequest<BreedingSchedule>(`/breeding/schedules/${id}`, {
        method: 'PATCH',
        body: JSON.stringify(payload),
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: breedingScheduleKeys.lists() });
      notifications.show({
        title: 'äº¤é…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ›´æ–°ã—ã¾ã—ãŸ',
        message: 'æœ€æ–°ã®æƒ…å ±ã«æ›´æ–°ã•ã‚Œã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'äº¤é…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}

export function useDeleteBreedingSchedule() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id: string) =>
      apiRequest<unknown>(`/breeding/schedules/${id}`, {
        method: 'DELETE',
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: breedingScheduleKeys.lists() });
      notifications.show({
        title: 'äº¤é…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
        message: 'ãƒªã‚¹ãƒˆã‹ã‚‰è©²å½“ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'äº¤é…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}

// ========== Mating Check ==========

export type CreateMatingCheckRequest = {
  checkDate: string;
  count?: number;
};

export type UpdateMatingCheckRequest = Partial<CreateMatingCheckRequest>;

const matingCheckKeys = createDomainQueryKeys<string>('mating-checks');

export { matingCheckKeys };

export function useGetMatingChecks(scheduleId: string) {
  return useQuery<ApiResponse<MatingCheck[]>>({
    queryKey: matingCheckKeys.detail(scheduleId),
    queryFn: () => apiRequest<MatingCheck[]>(`/breeding/schedules/${scheduleId}/checks`),
    enabled: !!scheduleId,
  });
}

export function useCreateMatingCheck() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ scheduleId, payload }: { scheduleId: string; payload: CreateMatingCheckRequest }) =>
      apiRequest<MatingCheck>(`/breeding/schedules/${scheduleId}/checks`, {
        method: 'POST',
        body: JSON.stringify(payload),
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: matingCheckKeys.all });
      void queryClient.invalidateQueries({ queryKey: breedingScheduleKeys.lists() });
      notifications.show({
        title: 'äº¤é…ãƒã‚§ãƒƒã‚¯ã‚’ç™»éŒ²ã—ã¾ã—ãŸ',
        message: 'ãƒã‚§ãƒƒã‚¯ãŒæ­£å¸¸ã«ç™»éŒ²ã•ã‚Œã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'äº¤é…ãƒã‚§ãƒƒã‚¯ã®ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}

export function useUpdateMatingCheck() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, payload }: { id: string; payload: UpdateMatingCheckRequest }) =>
      apiRequest<MatingCheck>(`/breeding/mating-checks/${id}`, {
        method: 'PATCH',
        body: JSON.stringify(payload),
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: matingCheckKeys.all });
      void queryClient.invalidateQueries({ queryKey: breedingScheduleKeys.lists() });
      notifications.show({
        title: 'äº¤é…ãƒã‚§ãƒƒã‚¯ã‚’æ›´æ–°ã—ã¾ã—ãŸ',
        message: 'æœ€æ–°ã®æƒ…å ±ã«æ›´æ–°ã•ã‚Œã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'äº¤é…ãƒã‚§ãƒƒã‚¯ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}

export function useDeleteMatingCheck() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id: string) =>
      apiRequest<unknown>(`/breeding/mating-checks/${id}`, {
        method: 'DELETE',
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: matingCheckKeys.all });
      void queryClient.invalidateQueries({ queryKey: breedingScheduleKeys.lists() });
      notifications.show({
        title: 'äº¤é…ãƒã‚§ãƒƒã‚¯ã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
        message: 'ãƒªã‚¹ãƒˆã‹ã‚‰è©²å½“ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'äº¤é…ãƒã‚§ãƒƒã‚¯ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}
````

## File: frontend/src/lib/api/hooks/use-breeds.ts
````typescript
/**
 * å“ç¨®ç®¡ç†APIãƒ•ãƒƒã‚¯ (TanStack Query)
 */

import { useQuery, type UseQueryOptions } from '@tanstack/react-query';
import { apiClient, type ApiQueryParams, type ApiResponse } from '../client';
import { createDomainQueryKeys } from './query-key-factory';

/**
 * å“ç¨®æƒ…å ±ã®å‹å®šç¾©
 */
export interface Breed {
  id: string;
  name: string;
  description: string | null;
  createdAt: string;
  updatedAt: string;
}

/**
 * å“ç¨®ä¸€è¦§å–å¾—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
 */
export interface GetBreedsParams {
  page?: number;
  limit?: number;
  search?: string;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

type BreedsListQuery = ApiQueryParams<'/breeds', 'get'>;

/**
 * å“ç¨®ä¸€è¦§ãƒ¬ã‚¹ãƒãƒ³ã‚¹
 */
export interface GetBreedsResponse {
  data: Breed[];
  meta: {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
  };
}

/**
 * ã‚¯ã‚¨ãƒªã‚­ãƒ¼å®šç¾©
 */
const baseBreedKeys = createDomainQueryKeys<string, GetBreedsParams>('breeds');

export const breedKeys = {
  ...baseBreedKeys,
};

/**
 * å“ç¨®ä¸€è¦§ã‚’å–å¾—ã™ã‚‹ãƒ•ãƒƒã‚¯
 */
export function useGetBreeds(
  params: GetBreedsParams = {},
  options?: Omit<UseQueryOptions<ApiResponse<GetBreedsResponse>>, 'queryKey' | 'queryFn'>,
) {
  return useQuery({
    queryKey: breedKeys.list(params),
    queryFn: () => apiClient.get('/breeds', { query: params as BreedsListQuery }) as Promise<ApiResponse<GetBreedsResponse>>,
    ...options,
  });
}
````

## File: frontend/src/lib/api/hooks/use-care.ts
````typescript
/**
 * ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«APIãƒ•ãƒƒã‚¯
 */

import { useMutation, useQuery, useQueryClient, type UseQueryOptions } from '@tanstack/react-query';
import { notifications } from '@mantine/notifications';
import {
  apiClient,
  type ApiPathParams,
  type ApiQueryParams,
  type ApiRequestBody,
  type ApiSuccessData,
} from '../client';
import { createDomainQueryKeys } from './query-key-factory';

export type CareType =
  | 'VACCINATION'
  | 'HEALTH_CHECK'
  | 'GROOMING'
  | 'DENTAL_CARE'
  | 'MEDICATION'
  | 'SURGERY'
  | 'OTHER';

export type CareScheduleStatus = 'PENDING' | 'IN_PROGRESS' | 'COMPLETED' | 'CANCELLED';

export type ReminderTimingType = 'ABSOLUTE' | 'RELATIVE';
export type ReminderOffsetUnit = 'MINUTE' | 'HOUR' | 'DAY' | 'WEEK' | 'MONTH';
export type ReminderRelativeTo = 'START_DATE' | 'END_DATE' | 'CUSTOM_DATE';
export type ReminderChannel = 'IN_APP' | 'EMAIL' | 'SMS' | 'PUSH';
export type ReminderRepeatFrequency = 'NONE' | 'DAILY' | 'WEEKLY' | 'MONTHLY' | 'YEARLY' | 'CUSTOM';

export interface CareScheduleCat {
  id: string;
  name: string;
}

export interface CareScheduleReminder {
  id: string;
  timingType: ReminderTimingType;
  remindAt?: string | null;
  offsetValue?: number | null;
  offsetUnit?: ReminderOffsetUnit | null;
  relativeTo?: ReminderRelativeTo | null;
  channel: ReminderChannel;
  repeatFrequency?: ReminderRepeatFrequency | null;
  repeatInterval?: number | null;
  repeatCount?: number | null;
  repeatUntil?: string | null;
  notes?: string | null;
  isActive: boolean;
}

export interface CareScheduleTag {
  id: string;
  slug: string;
  label: string;
  level: number;
  parentId?: string | null;
}

export interface CareSchedule {
  id: string;
  name: string;
  title: string;
  description: string | null;
  scheduleDate: string;
  endDate?: string | null;
  timezone?: string | null;
  scheduleType: 'CARE' | string;
  status: CareScheduleStatus;
  careType: CareType | null;
  priority?: string;
  recurrenceRule?: string | null;
  assignedTo: string;
  cat: CareScheduleCat | null;
  cats: CareScheduleCat[];
  reminders?: CareScheduleReminder[];
  tags?: CareScheduleTag[];
  createdAt: string;
  updatedAt: string;
}

export interface CareScheduleMeta {
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export type CareScheduleListResponse = ApiSuccessData<'/care/schedules', 'get'>;

export type CareScheduleResponse = ApiSuccessData<'/care/schedules', 'post'>;

export type GetCareSchedulesParams = ApiQueryParams<'/care/schedules', 'get'>;
export type CreateCareScheduleRequest = ApiRequestBody<'/care/schedules', 'post'>;
export type CompleteCareScheduleRequest = ApiRequestBody<'/care/schedules/{id}/complete', 'patch'>;

const careScheduleKeys = createDomainQueryKeys<string, GetCareSchedulesParams>('care-schedules');

export { careScheduleKeys };

// ========== Medical Records ==========

export type MedicalVisitType = 'CHECKUP' | 'EMERGENCY' | 'SURGERY' | 'FOLLOW_UP' | 'VACCINATION' | 'OTHER';
export type MedicalRecordStatus = 'TREATING' | 'COMPLETED';

export interface MedicalRecordSymptom {
  label: string;
  note?: string | null;
}

export interface MedicalRecordMedication {
  name: string;
  dosage?: string | null;
}

export interface MedicalRecordAttachment {
  url: string;
  description?: string | null;
  fileName?: string | null;
  fileType?: string | null;
  fileSize?: number | null;
  capturedAt?: string | null;
}

export interface MedicalRecordTag {
  id: string;
  name: string;
  color: string | null;
  textColor: string | null;
  groupId: string;
  groupName: string | null;
  categoryId: string | null;
  categoryName: string | null;
}

export interface MedicalRecord {
  id: string;
  visitDate: string;
  visitType?: MedicalVisitType | null;
  hospitalName?: string | null;
  symptom?: string | null;
  symptomDetails?: MedicalRecordSymptom[];
  diseaseName?: string | null;
  diagnosis?: string | null;
  treatmentPlan?: string | null;
  medications?: MedicalRecordMedication[];
  followUpDate?: string | null;
  status: MedicalRecordStatus;
  notes?: string | null;
  cat: { id: string; name: string };
  schedule?: { id: string; name: string } | null;
  tags?: MedicalRecordTag[]; // æ›´æ–°ã•ã‚ŒãŸå‹å®šç¾©
  attachments?: MedicalRecordAttachment[];
  recordedBy: string;
  createdAt: string;
  updatedAt: string;
}

export interface MedicalRecordMeta {
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

// ä¿®æ­£: OpenAPIã‚¹ã‚­ãƒ¼ãƒã‹ã‚‰ç”Ÿæˆã•ã‚ŒãŸå‹ã‚’ä¸Šæ›¸ã
export interface MedicalRecordListResponse {
  success: boolean;
  data: MedicalRecord[];
  meta: MedicalRecordMeta;
}

export interface MedicalRecordResponse {
  success: boolean;
  data: MedicalRecord;
}

// export type MedicalRecordListResponse = ApiSuccessData<'/care/medical-records', 'get'>;
// export type MedicalRecordResponse = ApiSuccessData<'/care/medical-records', 'post'>;

export type GetMedicalRecordsParams = ApiQueryParams<'/care/medical-records', 'get'>;
export type CreateMedicalRecordRequest = ApiRequestBody<'/care/medical-records', 'post'>;

const medicalRecordKeys = createDomainQueryKeys<string, GetMedicalRecordsParams>('medical-records');

export { medicalRecordKeys };

export function useGetCareSchedules(
  params: GetCareSchedulesParams = {},
  options?: Omit<UseQueryOptions<CareScheduleListResponse>, 'queryKey' | 'queryFn'>,
) {
  return useQuery({
    queryKey: careScheduleKeys.list(params),
    queryFn: async () => {
      const response = await apiClient.get('/care/schedules', {
        query: params,
        init: {
          cache: 'no-store',
          headers: {
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'Pragma': 'no-cache',
          },
        },
      });

      if (!response.data) {
        throw new Error('ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒä¸æ­£ã§ã™');
      }

      return response as unknown as CareScheduleListResponse;
    },
    staleTime: 0,
    gcTime: 0,
    ...options,
  });
}

export function useAddCareSchedule() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (payload: CreateCareScheduleRequest) => {
      const response = await apiClient.post('/care/schedules', {
        body: payload,
      });

      if (!response.data) {
        throw new Error('ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒä¸æ­£ã§ã™ã€‚');
      }

      return response.data as CareScheduleResponse;
    },
    onSuccess: () => {
      void queryClient.invalidateQueries({ 
        queryKey: careScheduleKeys.lists(),
        refetchType: 'all' 
      });
      void queryClient.refetchQueries({ 
        queryKey: careScheduleKeys.lists() 
      });
      notifications.show({
        title: 'ã‚±ã‚¢äºˆå®šã‚’ç™»éŒ²ã—ã¾ã—ãŸ',
        message: 'ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¿½åŠ ã—ã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'ã‚±ã‚¢äºˆå®šã®ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}

export function useUpdateCareSchedule() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      id,
      payload,
    }: {
      id: string;
      payload: CreateCareScheduleRequest;
    }) =>
      apiClient.patch('/care/schedules/{id}', {
        pathParams: { id } as ApiPathParams<'/care/schedules/{id}', 'patch'>,
        body: payload,
      }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: careScheduleKeys.lists() });
      notifications.show({
        title: 'ã‚±ã‚¢äºˆå®šã‚’æ›´æ–°ã—ã¾ã—ãŸ',
        message: 'äºˆå®šãŒæ­£å¸¸ã«æ›´æ–°ã•ã‚Œã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'ã‚±ã‚¢äºˆå®šã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'å…¥åŠ›å†…å®¹ã‚’ã”ç¢ºèªãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}

export function useDeleteCareSchedule() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id: string) =>
      apiClient.delete('/care/schedules/{id}', {
        pathParams: { id } as ApiPathParams<'/care/schedules/{id}', 'delete'>,
      }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: careScheduleKeys.lists() });
      notifications.show({
        title: 'ã‚±ã‚¢äºˆå®šã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
        message: 'äºˆå®šãŒæ­£å¸¸ã«å‰Šé™¤ã•ã‚Œã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'ã‚±ã‚¢äºˆå®šã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}

export function useCompleteCareSchedule() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      id,
      payload,
    }: {
      id: string;
      payload: CompleteCareScheduleRequest;
    }) =>
      apiClient.patch('/care/schedules/{id}/complete', {
        pathParams: { id } as ApiPathParams<'/care/schedules/{id}/complete', 'patch'>,
        body: payload,
      }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: careScheduleKeys.lists() });
      notifications.show({
        title: 'ã‚±ã‚¢äºˆå®šã‚’å®Œäº†ã—ã¾ã—ãŸ',
        message: 'å®Œäº†å±¥æ­´ã«è¨˜éŒ²ã—ã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'ã‚±ã‚¢å®Œäº†å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'å…¥åŠ›å†…å®¹ã‚’ã”ç¢ºèªãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}

// ========== Medical Records Hooks ==========

export function useGetMedicalRecords(
  params: GetMedicalRecordsParams = {},
  options?: Omit<UseQueryOptions<MedicalRecordListResponse>, 'queryKey' | 'queryFn'>,
) {
  return useQuery({
    queryKey: medicalRecordKeys.list(params),
    queryFn: async () => {
      const response = await apiClient.get('/care/medical-records', {
        query: params,
        init: {
          cache: 'no-store',
          headers: {
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'Pragma': 'no-cache',
          },
        },
      });

      if (!response.data) {
        throw new Error('åŒ»ç™‚è¨˜éŒ²ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒä¸æ­£ã§ã™');
      }

      return response as unknown as MedicalRecordListResponse;
    },
    staleTime: 0,
    gcTime: 0,
    ...options,
  });
}

export function useCreateMedicalRecord() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (payload: CreateMedicalRecordRequest) => {
      const response = await apiClient.post('/care/medical-records', {
        body: payload,
      });

      if (!response.data) {
        throw new Error('åŒ»ç™‚è¨˜éŒ²ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒä¸æ­£ã§ã™ã€‚');
      }

      return response as unknown as MedicalRecordResponse;
    },
    onSuccess: () => {
      void queryClient.invalidateQueries({ 
        queryKey: medicalRecordKeys.lists(),
        refetchType: 'all' 
      });
      void queryClient.refetchQueries({ 
        queryKey: medicalRecordKeys.lists() 
      });
      notifications.show({
        title: 'åŒ»ç™‚è¨˜éŒ²ã‚’ç™»éŒ²ã—ã¾ã—ãŸ',
        message: 'åŒ»ç™‚è¨˜éŒ²ã‚’è¿½åŠ ã—ã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'åŒ»ç™‚è¨˜éŒ²ã®ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}
````

## File: frontend/src/lib/api/hooks/use-cats.ts
````typescript
/**
 * çŒ«ç®¡ç†APIãƒ•ãƒƒã‚¯ (TanStack Query)
 */

import { useQuery, useMutation, useQueryClient, type UseQueryOptions } from '@tanstack/react-query';
import { apiClient, apiRequest, type ApiPathParams, type ApiQueryParams, type ApiRequestBody, type ApiResponse } from '../client';
import { createDomainQueryKeys } from './query-key-factory';
import { notifications } from '@mantine/notifications';

/**
 * çŒ«æƒ…å ±ã®å‹å®šç¾©
 */
export interface Cat {
  id: string;
  name: string;
  gender: 'MALE' | 'FEMALE' | 'NEUTER' | 'SPAY';
  birthDate: string;
  breedId: string | null;
  coatColorId: string | null;
  microchipNumber: string | null;
  registrationNumber: string | null;
  description: string | null;
  isInHouse: boolean;
  fatherId: string | null;
  motherId: string | null;
  createdAt: string;
  updatedAt: string;
  // ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ï¼‰
  breed?: { id: string; name: string };
  coatColor?: { id: string; name: string };
  father?: Cat;
  mother?: Cat;
  tags?: Array<{ 
    tag: { 
      id: string; 
      name: string; 
      color: string;
      metadata?: Record<string, unknown>;
      group?: { 
        name: string;
        category?: { name: string };
      };
    } 
  }>;
}

/**
 * çŒ«ä¸€è¦§å–å¾—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
 */
export interface GetCatsParams {
  page?: number;
  limit?: number;
  search?: string;
  gender?: 'MALE' | 'FEMALE' | 'NEUTER' | 'SPAY';
  breedId?: string;
  coatColorId?: string;
  isInHouse?: boolean;
}

type CatsListQuery = ApiQueryParams<'/cats', 'get'>;
type CatDetailPathParams = ApiPathParams<'/cats/{id}', 'get'>;

/**
 * çŒ«ä¸€è¦§ãƒ¬ã‚¹ãƒãƒ³ã‚¹
 */
export interface GetCatsResponse {
  data: Cat[];
  meta: {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
  };
}

/**
 * çŒ«ä½œæˆ/æ›´æ–°ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
 */
export interface CreateCatRequest {
  name: string;
  gender: 'MALE' | 'FEMALE' | 'NEUTER' | 'SPAY';
  birthDate: string;
  breedId?: string | null;
  coatColorId?: string | null;
  microchipNumber?: string | null;
  registrationNumber?: string | null;
  description?: string | null;
  isInHouse?: boolean;
  fatherId?: string | null;
  motherId?: string | null;
  tagIds?: string[];
}

export type UpdateCatRequest = Partial<CreateCatRequest>;
export type UpdateCatVariables = UpdateCatRequest & { id?: string };

const resolveTargetCatId = (variables: UpdateCatVariables | undefined, fallbackId: string): string => {
  const targetId = variables?.id ?? fallbackId;
  if (!targetId) {
    throw new Error('çŒ«IDãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');
  }
  return targetId;
};

/**
 * å­çŒ«ä¸€è¦§å–å¾—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
 */
export interface GetKittensParams {
  motherId?: string;
  page?: number;
  limit?: number;
  search?: string;
  sortBy?: 'birthDate' | 'name' | 'createdAt';
  sortOrder?: 'asc' | 'desc';
}

/**
 * å­çŒ«ã‚°ãƒ«ãƒ¼ãƒ—ï¼ˆæ¯çŒ«ã”ã¨ï¼‰
 */
export interface KittenGroup {
  mother: {
    id: string;
    name: string;
    gender: string;
    birthDate: string;
    breed: { id: string; name: string } | null;
    coatColor: { id: string; name: string } | null;
  };
  father: {
    id: string;
    name: string;
    gender: string;
    breed: { id: string; name: string } | null;
    coatColor: { id: string; name: string } | null;
  } | null;
  kittens: Cat[];
  kittenCount: number;
  deliveryDate: string | null;
}

/**
 * å­çŒ«ä¸€è¦§ãƒ¬ã‚¹ãƒãƒ³ã‚¹
 */
export interface GetKittensResponse {
  data: KittenGroup[];
  meta: {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
    totalGroups: number;
  };
}

/**
 * ç¥–å…ˆï¼ˆç¥–çˆ¶æ¯ãƒ»æ›¾ç¥–çˆ¶æ¯ï¼‰ã®æƒ…å ±
 */
export interface AncestorInfo {
  pedigreeId: string | null;
  catName: string | null;
  coatColor: string | null;
  title: string | null;
  jcu: string | null;
}

/**
 * è¦ªæƒ…å ±ï¼ˆçˆ¶ã¾ãŸã¯æ¯ï¼‰
 */
export interface ParentInfo {
  id: string | null;
  pedigreeId: string | null;
  name: string;
  gender: string | null;
  birthDate: string | null;
  breed: { id: string; name: string } | null;
  coatColor: { id: string; name: string } | string | null;
  father: AncestorInfo | null;
  mother: AncestorInfo | null;
}

/**
 * å…„å¼Ÿå§‰å¦¹æƒ…å ±
 */
export interface SiblingInfo {
  id: string;
  name: string;
  gender: string;
  birthDate: string;
  breed: { id: string; name: string } | null;
  coatColor: { id: string; name: string } | null;
  pedigreeId: string | null;
}

/**
 * å­çŒ«æƒ…å ±
 */
export interface OffspringInfo {
  id: string;
  name: string;
  gender: string;
  birthDate: string;
  breed: { id: string; name: string } | null;
  coatColor: { id: string; name: string } | null;
  pedigreeId: string | null;
  otherParent: {
    id: string;
    name: string;
    gender: string;
    pedigreeId: string | null;
  } | null;
}

/**
 * çŒ«ã®å®¶æ—æƒ…å ±ãƒ¬ã‚¹ãƒãƒ³ã‚¹
 */
export interface CatFamilyResponse {
  cat: {
    id: string;
    name: string;
    gender: string;
    birthDate: string;
    pedigreeId: string | null;
    breed: { id: string; name: string } | null;
    coatColor: { id: string; name: string } | null;
  };
  father: ParentInfo | null;
  mother: ParentInfo | null;
  siblings: SiblingInfo[];
  offspring: OffspringInfo[];
}

/**
 * ã‚¿ãƒ–åˆ¥ã‚«ã‚¦ãƒ³ãƒˆæƒ…å ±ï¼ˆçŒ«ä¸€è¦§ãƒšãƒ¼ã‚¸ç”¨ï¼‰
 */
export interface TabCounts {
  /** å…¨æˆçŒ«æ•°ï¼ˆå­çŒ«é™¤å¤–ï¼‰ */
  total: number;
  /** ã‚ªã‚¹æˆçŒ«æ•° */
  male: number;
  /** ãƒ¡ã‚¹æˆçŒ«æ•° */
  female: number;
  /** å­çŒ«æ•°ï¼ˆç”Ÿå¾Œ3ãƒ¶æœˆä»¥å†… + æ¯çŒ«ã‚ã‚Šï¼‰ */
  kitten: number;
  /** é¤Šæˆä¸­ã‚¿ã‚°ä»˜ãçŒ«æ•° */
  raising: number;
  /** å’æ¥­äºˆå®šã‚¿ã‚°ä»˜ãçŒ«æ•° */
  grad: number;
}

/**
 * çŒ«çµ±è¨ˆãƒ¬ã‚¹ãƒãƒ³ã‚¹
 */
export interface CatStatisticsResponse {
  /** å…¨çŒ«æ•° */
  total: number;
  /** æ€§åˆ¥åˆ†å¸ƒ */
  genderDistribution: {
    MALE: number;
    FEMALE: number;
    NEUTER: number;
    SPAY: number;
  };
  /** å“ç¨®åˆ†å¸ƒï¼ˆä¸Šä½10ä»¶ï¼‰ */
  breedDistribution: Array<{
    breed: { id: string; name: string } | null;
    count: number;
  }>;
  /** ã‚¿ãƒ–åˆ¥ã‚«ã‚¦ãƒ³ãƒˆï¼ˆçŒ«ä¸€è¦§ãƒšãƒ¼ã‚¸ç”¨ï¼‰ */
  tabCounts: TabCounts;
}

/**
 * ã‚¯ã‚¨ãƒªã‚­ãƒ¼å®šç¾©
 */
const baseCatKeys = createDomainQueryKeys<string, GetCatsParams>('cats');

export const catKeys = {
  ...baseCatKeys,
  statistics: () => [...baseCatKeys.all, 'statistics'] as const,
  breedingHistory: (id: string) => [...baseCatKeys.all, 'breeding-history', id] as const,
  careHistory: (id: string) => [...baseCatKeys.all, 'care-history', id] as const,
  kittens: (params?: GetKittensParams) => [...baseCatKeys.all, 'kittens', params ?? {}] as const,
  family: (id: string) => [...baseCatKeys.all, 'family', id] as const,
};

/**
 * çŒ«ä¸€è¦§ã‚’å–å¾—ã™ã‚‹ãƒ•ãƒƒã‚¯
 */
export function useGetCats(
  params: GetCatsParams = {},
  options?: Omit<UseQueryOptions<GetCatsResponse>, 'queryKey' | 'queryFn'>,
) {
  return useQuery({
    queryKey: catKeys.list(params),
    queryFn: () => apiClient.get('/cats', { query: params as CatsListQuery }).then(res => ({
      data: res.data as Cat[],
      meta: res.meta as { total: number; page: number; limit: number; totalPages: number },
    })),
    ...options,
  });
}

/**
 * çŒ«è©³ç´°ã‚’å–å¾—ã™ã‚‹ãƒ•ãƒƒã‚¯
 */
export function useGetCat(
  id: string,
  options?: Omit<UseQueryOptions<ApiResponse<Cat>>, 'queryKey' | 'queryFn'>,
) {
  return useQuery({
    queryKey: catKeys.detail(id),
  queryFn: () => apiClient.get('/cats/{id}', { pathParams: { id } as CatDetailPathParams }) as Promise<ApiResponse<Cat>>,
    enabled: !!id,
    ...options,
  });
}

/**
 * çŒ«çµ±è¨ˆã‚’å–å¾—ã™ã‚‹ãƒ•ãƒƒã‚¯
 */
export function useGetCatStatistics(
  options?: Omit<UseQueryOptions<CatStatisticsResponse>, 'queryKey' | 'queryFn'>,
) {
  return useQuery({
    queryKey: catKeys.statistics(),
    queryFn: async () => {
      const response = await apiClient.get('/cats/statistics');
      
      // ApiResponse<T> å½¢å¼ã®æˆ»ã‚Šå€¤ã‚’å‹å®‰å…¨ã«å‡¦ç†
      if (!response.success || !response.data) {
        throw new Error('çµ±è¨ˆæƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }
      
      const data = response.data;
      
      // ãƒ‡ãƒ¼ã‚¿å½¢å¼ã‚’æ¤œè¨¼ã—ã€å¿…è¦ãªãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æŒã¤ã“ã¨ã‚’ç¢ºèª
      if (typeof data === 'object' && data !== null && 'tabCounts' in data) {
        return data as CatStatisticsResponse;
      }
      
      // å¤ã„å½¢å¼ã®å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¿½åŠ 
      if (typeof data === 'object' && data !== null) {
        const legacyData = data as Record<string, unknown>;
        return {
          total: typeof legacyData.total === 'number' ? legacyData.total : 0,
          genderDistribution: typeof legacyData.genderDistribution === 'object' && legacyData.genderDistribution !== null
            ? legacyData.genderDistribution as CatStatisticsResponse['genderDistribution']
            : { MALE: 0, FEMALE: 0, NEUTER: 0, SPAY: 0 },
          breedDistribution: Array.isArray(legacyData.breedDistribution)
            ? legacyData.breedDistribution as CatStatisticsResponse['breedDistribution']
            : [],
          tabCounts: { total: 0, male: 0, female: 0, kitten: 0, raising: 0, grad: 0 },
        };
      }
      
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ç©ºã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
      return {
        total: 0,
        genderDistribution: { MALE: 0, FEMALE: 0, NEUTER: 0, SPAY: 0 },
        breedDistribution: [],
        tabCounts: { total: 0, male: 0, female: 0, kitten: 0, raising: 0, grad: 0 },
      };
    },
    ...options,
  });
}

/**
 * çŒ«ã‚’ä½œæˆã™ã‚‹ãƒ•ãƒƒã‚¯
 */
export function useCreateCat() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: CreateCatRequest) =>
      apiClient.post('/cats', {
        body: data as unknown as ApiRequestBody<'/cats', 'post'>,
      }) as Promise<ApiResponse<Cat>>,
  onSuccess: (_response) => {
      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ç„¡åŠ¹åŒ–ã—ã¦å†ãƒ•ã‚§ãƒƒãƒ
      void queryClient.invalidateQueries({ queryKey: catKeys.lists() });
      void queryClient.invalidateQueries({ queryKey: catKeys.statistics() });
      
      notifications.show({
        title: 'æˆåŠŸ',
        message: 'çŒ«æƒ…å ±ã‚’ç™»éŒ²ã—ã¾ã—ãŸ',
        color: 'green',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: error.message || 'çŒ«æƒ…å ±ã®ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ',
        color: 'red',
      });
    },
  });
}

/**
 * çŒ«æƒ…å ±ã‚’æ›´æ–°ã™ã‚‹ãƒ•ãƒƒã‚¯
 */
export function useUpdateCat(id: string) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: UpdateCatVariables) => {
      const targetId = resolveTargetCatId(data, id);

      const { id: _unusedId, ...payload } = data;

      return apiClient.patch('/cats/{id}', {
        pathParams: { id: targetId } as ApiPathParams<'/cats/{id}', 'patch'>,
        body: payload as unknown as ApiRequestBody<'/cats/{id}', 'patch'>,
      }) as Promise<ApiResponse<Cat>>;
    },
  onSuccess: (_response, variables) => {
      const targetId = resolveTargetCatId(variables, id);
      // ç‰¹å®šã®çŒ«ã®è©³ç´°ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æ›´æ–°
      void queryClient.invalidateQueries({ queryKey: catKeys.detail(targetId) });
      // ä¸€è¦§ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚‚ç„¡åŠ¹åŒ–
      void queryClient.invalidateQueries({ queryKey: catKeys.lists() });
      void queryClient.invalidateQueries({ queryKey: catKeys.statistics() });
      
      notifications.show({
        title: 'æˆåŠŸ',
        message: 'çŒ«æƒ…å ±ã‚’æ›´æ–°ã—ã¾ã—ãŸ',
        color: 'green',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: error.message || 'çŒ«æƒ…å ±ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ',
        color: 'red',
      });
    },
  });
}

/**
 * çŒ«ã‚’å‰Šé™¤ã™ã‚‹ãƒ•ãƒƒã‚¯
 */
export function useDeleteCat() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id: string) => apiClient.delete('/cats/{id}', {
      pathParams: { id } as ApiPathParams<'/cats/{id}', 'delete'>,
    }),
  onSuccess: (_response, id) => {
      // å‰Šé™¤ã—ãŸçŒ«ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’å‰Šé™¤
      void queryClient.removeQueries({ queryKey: catKeys.detail(id) });
      // ä¸€è¦§ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚‚ç„¡åŠ¹åŒ–
      void queryClient.invalidateQueries({ queryKey: catKeys.lists() });
      void queryClient.invalidateQueries({ queryKey: catKeys.statistics() });
      
      notifications.show({
        title: 'æˆåŠŸ',
        message: 'çŒ«æƒ…å ±ã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
        color: 'green',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: error.message || 'çŒ«æƒ…å ±ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ',
        color: 'red',
      });
    },
  });
}

/**
 * çŒ«ã®ç¹æ®–å±¥æ­´ã‚’å–å¾—ã™ã‚‹ãƒ•ãƒƒã‚¯
 */
export function useGetCatBreedingHistory(
  id: string,
  options?: Omit<UseQueryOptions<ApiResponse<unknown>>, 'queryKey' | 'queryFn'>,
) {
  return useQuery({
    queryKey: catKeys.breedingHistory(id),
    queryFn: () => apiClient.get('/cats/{id}/breeding-history', { pathParams: { id } }),
    enabled: !!id,
    ...options,
  });
}

/**
 * å­çŒ«ä¸€è¦§ã‚’å–å¾—ã™ã‚‹ãƒ•ãƒƒã‚¯ï¼ˆæ¯çŒ«ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ï¼‰
 * 
 * NOTE: OpenAPI ã‚¹ã‚­ãƒ¼ãƒã« /cats/kittens ãŒè¿½åŠ ã•ã‚Œã‚‹ã¾ã§ã¯
 * apiRequest ã‚’ç›´æ¥ä½¿ç”¨ã—ã¦ãƒ‘ã‚¹ã‚’æŒ‡å®šã—ã¦ã„ã¾ã™ã€‚
 * ã‚¹ã‚­ãƒ¼ãƒæ›´æ–°å¾Œã¯ apiClient.get ã«ç§»è¡Œã—ã¦ãã ã•ã„ã€‚
 */
export function useGetKittens(
  params: GetKittensParams = {},
  options?: Omit<UseQueryOptions<GetKittensResponse>, 'queryKey' | 'queryFn'>,
) {
  // ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰
  const queryString = new URLSearchParams();
  if (params.motherId) queryString.set('motherId', params.motherId);
  if (params.page) queryString.set('page', String(params.page));
  if (params.limit) queryString.set('limit', String(params.limit));
  if (params.search) queryString.set('search', params.search);
  if (params.sortBy) queryString.set('sortBy', params.sortBy);
  if (params.sortOrder) queryString.set('sortOrder', params.sortOrder);

  const urlPath = `/cats/kittens${queryString.toString() ? `?${queryString.toString()}` : ''}`;

  return useQuery({
    queryKey: catKeys.kittens(params),
    queryFn: async () => {
      // OpenAPI å‹ãŒç”Ÿæˆã•ã‚Œã‚‹ã¾ã§ã¯ apiRequest ã‚’ç›´æ¥ä½¿ç”¨
      // apiRequest ã¯ { success, data, meta } å½¢å¼ã® ApiResponse<T> ã‚’è¿”ã™
      const response = await apiRequest<KittenGroup[]>(urlPath);

      return {
        data: response.data ?? [],
        meta: (response.meta as GetKittensResponse['meta'] | undefined) ?? {
          total: 0,
          page: 1,
          limit: 50,
          totalPages: 0,
          totalGroups: 0,
        },
      };
    },
    ...options,
  });
}

/**
 * çŒ«ã®å®¶æ—æƒ…å ±ã‚’å–å¾—ã™ã‚‹ãƒ•ãƒƒã‚¯ï¼ˆè¡€çµ±ã‚¿ãƒ–ç”¨ï¼‰
 */
export function useGetCatFamily(
  id: string,
  options?: Omit<UseQueryOptions<CatFamilyResponse>, 'queryKey' | 'queryFn'>,
) {
  return useQuery({
    queryKey: catKeys.family(id),
    queryFn: async () => {
      const response = await apiRequest<CatFamilyResponse>(`/cats/${id}/family`);
      if (!response.data) {
        throw new Error('å®¶æ—æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
      }
      return response.data;
    },
    enabled: !!id,
    ...options,
  });
}
````

## File: frontend/src/lib/api/hooks/use-coat-colors.ts
````typescript
/**
 * æ¯›è‰²ç®¡ç†APIãƒ•ãƒƒã‚¯ (TanStack Query)
 */

import { useQuery, type UseQueryOptions } from '@tanstack/react-query';
import { apiClient, type ApiQueryParams, type ApiResponse } from '../client';
import { createDomainQueryKeys } from './query-key-factory';

/**
 * æ¯›è‰²æƒ…å ±ã®å‹å®šç¾©
 */
export interface CoatColor {
  id: string;
  name: string;
  description: string | null;
  createdAt: string;
  updatedAt: string;
}

/**
 * æ¯›è‰²ä¸€è¦§å–å¾—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
 */
export interface GetCoatColorsParams {
  page?: number;
  limit?: number;
  search?: string;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

type CoatColorsListQuery = ApiQueryParams<'/coat-colors', 'get'>;

/**
 * æ¯›è‰²ä¸€è¦§ãƒ¬ã‚¹ãƒãƒ³ã‚¹
 */
export interface GetCoatColorsResponse {
  data: CoatColor[];
  meta: {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
  };
}

/**
 * ã‚¯ã‚¨ãƒªã‚­ãƒ¼å®šç¾©
 */
const baseCoatColorKeys = createDomainQueryKeys<string, GetCoatColorsParams>('coat-colors');

export const coatColorKeys = {
  ...baseCoatColorKeys,
};

/**
 * æ¯›è‰²ä¸€è¦§ã‚’å–å¾—ã™ã‚‹ãƒ•ãƒƒã‚¯
 */
export function useGetCoatColors(
  params: GetCoatColorsParams = {},
  options?: Omit<UseQueryOptions<ApiResponse<GetCoatColorsResponse>>, 'queryKey' | 'queryFn'>,
) {
  return useQuery({
    queryKey: coatColorKeys.list(params),
    queryFn: () => apiClient.get('/coat-colors', { query: params as CoatColorsListQuery }) as Promise<ApiResponse<GetCoatColorsResponse>>,
    ...options,
  });
}
````

## File: frontend/src/lib/api/hooks/use-gallery-upload.ts
````typescript
'use client';
// ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã§ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å‡¦ç†ã®ãŸã‚ use client ãŒå¿…è¦

import { useState, useCallback } from 'react';
import {
  resizeImage,
  isImageFile,
  formatFileSize,
} from '@/lib/utils/image-resizer';
import { getPublicApiBaseUrl } from '@/lib/api/public-api-base-url';

const apiBaseUrl = getPublicApiBaseUrl();

/**
 * ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰é€²æ—çŠ¶æ…‹
 */
export interface UploadProgress {
  /** ãƒ•ã‚¡ã‚¤ãƒ«ã‚­ãƒ¼ï¼ˆä¸€æ™‚ã‚­ãƒ¼ã¾ãŸã¯GCSã‚­ãƒ¼ï¼‰ */
  fileKey: string;
  /** å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«å */
  fileName: string;
  /** ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰çŠ¶æ…‹ */
  status:
    | 'pending'
    | 'resizing'
    | 'uploading'
    | 'confirming'
    | 'completed'
    | 'error';
  /** é€²æ—ï¼ˆ0-100ï¼‰ */
  progress: number;
  /** ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ */
  error?: string;
  /** ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº†å¾Œã®URL */
  url?: string;
}

/**
 * Signed URL ãƒ¬ã‚¹ãƒãƒ³ã‚¹
 */
interface SignedUrlResponse {
  success: boolean;
  data: {
    uploadUrl: string;
    fileKey: string;
    publicUrl: string;
  };
}

/**
 * ã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹
 */
interface ErrorResponse {
  message?: string;
}

/**
 * Response ã‹ã‚‰ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å®‰å…¨ã«æŠ½å‡ºã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼
 */
async function extractErrorMessage(
  response: Response,
  defaultMessage: string
): Promise<string> {
  try {
    const json: unknown = await response.json();
    if (
      typeof json === 'object' &&
      json !== null &&
      'message' in json &&
      typeof (json as ErrorResponse).message === 'string'
    ) {
      return (json as ErrorResponse).message ?? defaultMessage;
    }
    return defaultMessage;
  } catch {
    return defaultMessage;
  }
}

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç”¨ãƒ•ãƒƒã‚¯
 *
 * @example
 * ```tsx
 * const { uploads, uploadFile, clearUploads } = useGalleryUpload();
 *
 * const handleFileSelect = async (file: File) => {
 *   try {
 *     const url = await uploadFile(file);
 *     console.log('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº†:', url);
 *   } catch (error) {
 *     console.error('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å¤±æ•—:', error);
 *   }
 * };
 * ```
 */
export function useGalleryUpload() {
  const [uploads, setUploads] = useState<Map<string, UploadProgress>>(
    new Map()
  );

  /**
   * æŒ‡å®šã•ã‚ŒãŸã‚­ãƒ¼ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰çŠ¶æ…‹ã‚’æ›´æ–°
   */
  const updateUpload = useCallback(
    (fileKey: string, updates: Partial<UploadProgress>) => {
      setUploads((prev) => {
        const newMap = new Map(prev);
        const current = newMap.get(fileKey);
        if (current) {
          newMap.set(fileKey, { ...current, ...updates });
        }
        return newMap;
      });
    },
    []
  );

  /**
   * å˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
   *
   * @param file - ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«
   * @returns ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº†å¾Œã®å…¬é–‹URL
   * @throws éå¯¾å¿œå½¢å¼ã‚„ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å¤±æ•—æ™‚ã«ã‚¨ãƒ©ãƒ¼
   */
  const uploadFile = useCallback(
    async (file: File): Promise<string> => {
      if (!isImageFile(file)) {
        throw new Error('JPEGã€PNGã€WebPå½¢å¼ã®ç”»åƒã®ã¿ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã§ãã¾ã™');
      }

      const tempKey = `temp-${Date.now()}-${file.name}`;

      // åˆæœŸçŠ¶æ…‹ã‚’è¨­å®š
      setUploads((prev) => {
        const newMap = new Map(prev);
        newMap.set(tempKey, {
          fileKey: tempKey,
          fileName: file.name,
          status: 'resizing',
          progress: 0,
        });
        return newMap;
      });

      try {
        // 1. ç”»åƒã‚’ãƒªã‚µã‚¤ã‚º
        const resizedBlob = await resizeImage(file);
        updateUpload(tempKey, { status: 'uploading', progress: 20 });

        // 2. Signed URLã‚’å–å¾—
        const signedUrlRes = await fetch(
          `${apiBaseUrl}/gallery/upload/signed-url`,
          {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              fileName: file.name,
              contentType: 'image/jpeg',
              fileSize: resizedBlob.size,
            }),
          }
        );

        if (!signedUrlRes.ok) {
          const errorMessage = await extractErrorMessage(
            signedUrlRes,
            'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰URLã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ'
          );
          throw new Error(errorMessage);
        }

        const signedUrlData: SignedUrlResponse =
          (await signedUrlRes.json()) as SignedUrlResponse;
        const { data } = signedUrlData;
        updateUpload(tempKey, { fileKey: data.fileKey, progress: 40 });

        // 3. GCSã¸ç›´æ¥ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
        const uploadRes = await fetch(data.uploadUrl, {
          method: 'PUT',
          headers: { 'Content-Type': 'image/jpeg' },
          body: resizedBlob,
        });

        if (!uploadRes.ok) {
          throw new Error('ç”»åƒã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ');
        }

        updateUpload(tempKey, { status: 'confirming', progress: 80 });

        // 4. ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº†ã‚’ç¢ºèª
        const confirmRes = await fetch(
          `${apiBaseUrl}/gallery/upload/confirm`,
          {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ fileKey: data.fileKey }),
          }
        );

        if (!confirmRes.ok) {
          const errorMessage = await extractErrorMessage(
            confirmRes,
            'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã®ç¢ºèªã«å¤±æ•—ã—ã¾ã—ãŸ'
          );
          throw new Error(errorMessage);
        }

        // ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç¢ºèªå®Œäº†
        updateUpload(tempKey, {
          status: 'completed',
          progress: 100,
          url: data.publicUrl,
        });

        return data.publicUrl;
      } catch (error) {
        const errorMessage =
          error instanceof Error ? error.message : 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ';
        updateUpload(tempKey, { status: 'error', error: errorMessage });
        throw error;
      }
    },
    [updateUpload]
  );

  /**
   * è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¸¦åˆ—ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
   *
   * @param files - ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«é…åˆ—
   * @returns æˆåŠŸã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã®å…¬é–‹URLé…åˆ—
   */
  const uploadMultiple = useCallback(
    async (files: File[]): Promise<string[]> => {
      const results = await Promise.allSettled(files.map(uploadFile));
      return results
        .filter(
          (r): r is PromiseFulfilledResult<string> => r.status === 'fulfilled'
        )
        .map((r) => r.value);
    },
    [uploadFile]
  );

  /**
   * ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰çŠ¶æ…‹ã‚’ã‚¯ãƒªã‚¢
   */
  const clearUploads = useCallback(() => {
    setUploads(new Map());
  }, []);

  /**
   * ç‰¹å®šã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚’å‰Šé™¤
   */
  const removeUpload = useCallback((fileKey: string) => {
    setUploads((prev) => {
      const newMap = new Map(prev);
      newMap.delete(fileKey);
      return newMap;
    });
  }, []);

  return {
    /** ç¾åœ¨ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰çŠ¶æ…‹ä¸€è¦§ */
    uploads: Array.from(uploads.values()),
    /** å˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ */
    uploadFile,
    /** è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ä¸¦åˆ—ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ */
    uploadMultiple,
    /** ã™ã¹ã¦ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰çŠ¶æ…‹ã‚’ã‚¯ãƒªã‚¢ */
    clearUploads,
    /** ç‰¹å®šã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚’å‰Šé™¤ */
    removeUpload,
    /** ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆé–¢æ•°ï¼ˆãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ï¼‰ */
    formatFileSize,
  };
}
````

## File: frontend/src/lib/api/hooks/use-gallery.ts
````typescript
/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼APIç”¨ãƒ•ãƒƒã‚¯ (TanStack Query)
 * ã‚«ãƒ†ã‚´ãƒªåˆ¥ï¼ˆKittens / Fathers / Mothers / Graduationsï¼‰ã®ã‚®ãƒ£ãƒ©ãƒªãƒ¼ç®¡ç†
 */

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { createDomainQueryKeys } from './query-key-factory';
import { notifications } from '@mantine/notifications';
import { getPublicApiBaseUrl } from '@/lib/api/public-api-base-url';

const apiBaseUrl = getPublicApiBaseUrl();

// ============================================================================
// å‹å®šç¾©
// ============================================================================

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚«ãƒ†ã‚´ãƒª
 */
export type GalleryCategory = 'KITTEN' | 'FATHER' | 'MOTHER' | 'GRADUATION';

/**
 * ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¿ã‚¤ãƒ—
 */
export type GalleryMediaType = 'IMAGE' | 'YOUTUBE';

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ãƒ¡ãƒ‡ã‚£ã‚¢
 */
export interface GalleryMedia {
  id: string;
  type: GalleryMediaType;
  url: string;
  thumbnailUrl?: string;
  order: number;
  createdAt: string;
}

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒª
 */
export interface GalleryEntry {
  id: string;
  category: GalleryCategory;
  name: string;
  gender: string;
  coatColor?: string;
  breed?: string;
  catId?: string;
  transferDate?: string;
  destination?: string;
  externalLink?: string;
  notes?: string;
  media: GalleryMedia[];
  createdAt: string;
  updatedAt: string;
}

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ä¸€è¦§ãƒ¬ã‚¹ãƒãƒ³ã‚¹
 */
export interface GalleryResponse {
  success: boolean;
  data: GalleryEntry[];
  meta: {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
  };
}

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªä½œæˆDTO
 */
export interface CreateGalleryEntryDto {
  category: GalleryCategory;
  name: string;
  gender: string;
  coatColor?: string;
  breed?: string;
  catId?: string;
  transferDate?: string;
  destination?: string;
  externalLink?: string;
  notes?: string;
  media?: {
    type: GalleryMediaType;
    url: string;
    thumbnailUrl?: string;
    order?: number;
  }[];
}

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªæ›´æ–°DTO
 */
export type UpdateGalleryEntryDto = Partial<CreateGalleryEntryDto>;

/**
 * ãƒ¡ãƒ‡ã‚£ã‚¢è¿½åŠ DTO
 */
export interface AddMediaDto {
  type: GalleryMediaType;
  url: string;
  thumbnailUrl?: string;
}

/**
 * å–å¾—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
 */
export interface GetGalleryParams {
  category?: GalleryCategory;
  page?: number;
  limit?: number;
}

// ============================================================================
// ã‚¯ã‚¨ãƒªã‚­ãƒ¼
// ============================================================================

const galleryKeys = createDomainQueryKeys<string, GetGalleryParams>('gallery');

// ============================================================================
// ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
// ============================================================================

/**
 * Response ã‹ã‚‰ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å®‰å…¨ã«æŠ½å‡º
 */
async function extractErrorMessage(
  response: Response,
  defaultMessage: string
): Promise<string> {
  try {
    const json: unknown = await response.json();
    if (
      typeof json === 'object' &&
      json !== null &&
      'message' in json &&
      typeof (json as { message?: string }).message === 'string'
    ) {
      return (json as { message: string }).message;
    }
    return defaultMessage;
  } catch {
    return defaultMessage;
  }
}

// ============================================================================
// ãƒ•ãƒƒã‚¯
// ============================================================================

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ä¸€è¦§å–å¾—
 *
 * @param category - ãƒ•ã‚£ãƒ«ã‚¿ã™ã‚‹ã‚«ãƒ†ã‚´ãƒªï¼ˆçœç•¥æ™‚ã¯å…¨ä»¶ï¼‰
 * @param page - ãƒšãƒ¼ã‚¸ç•ªå·ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 1ï¼‰
 * @param limit - 1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ä»¶æ•°ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 20ï¼‰
 */
export function useGalleryEntries(
  category?: GalleryCategory,
  page: number = 1,
  limit: number = 20
) {
  return useQuery<GalleryResponse>({
    queryKey: galleryKeys.list({ category, page, limit }),
    queryFn: async () => {
      const params = new URLSearchParams();
      if (category) params.append('category', category);
      params.append('page', String(page));
      params.append('limit', String(limit));

      const res = await fetch(`${apiBaseUrl}/gallery?${params.toString()}`);
      if (!res.ok) {
        const message = await extractErrorMessage(
          res,
          'ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ'
        );
        throw new Error(message);
      }
      return res.json() as Promise<GalleryResponse>;
    },
    // Kittens ã¯æ›´æ–°é »åº¦ãŒé«˜ã„ãŸã‚çŸ­ã‚ã€ä»–ã‚«ãƒ†ã‚´ãƒªã¯é•·ã‚ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    staleTime: category === 'KITTEN' ? 5 * 60 * 1000 : 60 * 60 * 1000,
  });
}

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼è©³ç´°å–å¾—
 *
 * @param id - ã‚¨ãƒ³ãƒˆãƒªIDï¼ˆnullæ™‚ã¯ç„¡åŠ¹åŒ–ï¼‰
 */
export function useGalleryEntry(id: string | null) {
  return useQuery<{ success: boolean; data: GalleryEntry }>({
    queryKey: galleryKeys.detail(id ?? ''),
    queryFn: async () => {
      if (!id) throw new Error('IDãŒå¿…è¦ã§ã™');
      const res = await fetch(`${apiBaseUrl}/gallery/${id}`);
      if (!res.ok) {
        const message = await extractErrorMessage(
          res,
          'ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ'
        );
        throw new Error(message);
      }
      return res.json() as Promise<{ success: boolean; data: GalleryEntry }>;
    },
    enabled: !!id,
  });
}

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªä½œæˆ
 */
export function useCreateGalleryEntry() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (dto: CreateGalleryEntryDto) => {
      const res = await fetch(`${apiBaseUrl}/gallery`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(dto),
      });
      if (!res.ok) {
        const message = await extractErrorMessage(res, 'ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ');
        throw new Error(message);
      }
      return res.json() as Promise<{ success: boolean; data: GalleryEntry }>;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: galleryKeys.all });
      notifications.show({
        title: 'ç™»éŒ²å®Œäº†',
        message: 'ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã«è¿½åŠ ã—ã¾ã—ãŸ',
        color: 'green',
      });
    },
    onError: (error) => {
      notifications.show({
        title: 'ç™»éŒ²å¤±æ•—',
        message: error instanceof Error ? error.message : 'ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ',
        color: 'red',
      });
    },
  });
}

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªä¸€æ‹¬ä½œæˆ
 */
export function useBulkCreateGalleryEntries() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (entries: CreateGalleryEntryDto[]) => {
      const res = await fetch(`${apiBaseUrl}/gallery/bulk`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(entries),
      });
      if (!res.ok) {
        const message = await extractErrorMessage(
          res,
          'ä¸€æ‹¬ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ'
        );
        throw new Error(message);
      }
      return res.json() as Promise<{
        success: boolean;
        data: GalleryEntry[];
        count: number;
      }>;
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: galleryKeys.all });
      notifications.show({
        title: 'ä¸€æ‹¬ç™»éŒ²å®Œäº†',
        message: `${data.count}ä»¶ã®ã‚¨ãƒ³ãƒˆãƒªã‚’è¿½åŠ ã—ã¾ã—ãŸ`,
        color: 'green',
      });
    },
    onError: (error) => {
      notifications.show({
        title: 'ä¸€æ‹¬ç™»éŒ²å¤±æ•—',
        message:
          error instanceof Error ? error.message : 'ä¸€æ‹¬ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ',
        color: 'red',
      });
    },
  });
}

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªæ›´æ–°
 */
export function useUpdateGalleryEntry() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      id,
      dto,
    }: {
      id: string;
      dto: UpdateGalleryEntryDto;
    }) => {
      const res = await fetch(`${apiBaseUrl}/gallery/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(dto),
      });
      if (!res.ok) {
        const message = await extractErrorMessage(res, 'æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ');
        throw new Error(message);
      }
      return res.json() as Promise<{ success: boolean; data: GalleryEntry }>;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: galleryKeys.all });
      notifications.show({
        title: 'æ›´æ–°å®Œäº†',
        message: 'ã‚®ãƒ£ãƒ©ãƒªãƒ¼æƒ…å ±ã‚’æ›´æ–°ã—ã¾ã—ãŸ',
        color: 'green',
      });
    },
    onError: (error) => {
      notifications.show({
        title: 'æ›´æ–°å¤±æ•—',
        message: error instanceof Error ? error.message : 'æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ',
        color: 'red',
      });
    },
  });
}

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¨ãƒ³ãƒˆãƒªå‰Šé™¤
 */
export function useDeleteGalleryEntry() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (id: string) => {
      const res = await fetch(`${apiBaseUrl}/gallery/${id}`, {
        method: 'DELETE',
      });
      if (!res.ok) {
        const message = await extractErrorMessage(res, 'å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ');
        throw new Error(message);
      }
      return res.json() as Promise<{ success: boolean }>;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: galleryKeys.all });
      notifications.show({
        title: 'å‰Šé™¤å®Œäº†',
        message: 'ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‹ã‚‰å‰Šé™¤ã—ã¾ã—ãŸ',
        color: 'green',
      });
    },
    onError: (error) => {
      notifications.show({
        title: 'å‰Šé™¤å¤±æ•—',
        message: error instanceof Error ? error.message : 'å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ',
        color: 'red',
      });
    },
  });
}

/**
 * ãƒ¡ãƒ‡ã‚£ã‚¢è¿½åŠ 
 */
export function useAddGalleryMedia() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      entryId,
      media,
    }: {
      entryId: string;
      media: AddMediaDto;
    }) => {
      const res = await fetch(`${apiBaseUrl}/gallery/${entryId}/media`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(media),
      });
      if (!res.ok) {
        const message = await extractErrorMessage(
          res,
          'ãƒ¡ãƒ‡ã‚£ã‚¢è¿½åŠ ã«å¤±æ•—ã—ã¾ã—ãŸ'
        );
        throw new Error(message);
      }
      return res.json() as Promise<{ success: boolean; data: GalleryMedia }>;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: galleryKeys.all });
      notifications.show({
        title: 'è¿½åŠ å®Œäº†',
        message: 'ãƒ¡ãƒ‡ã‚£ã‚¢ã‚’è¿½åŠ ã—ã¾ã—ãŸ',
        color: 'green',
      });
    },
    onError: (error) => {
      notifications.show({
        title: 'è¿½åŠ å¤±æ•—',
        message:
          error instanceof Error ? error.message : 'ãƒ¡ãƒ‡ã‚£ã‚¢è¿½åŠ ã«å¤±æ•—ã—ã¾ã—ãŸ',
        color: 'red',
      });
    },
  });
}

/**
 * ãƒ¡ãƒ‡ã‚£ã‚¢å‰Šé™¤
 */
export function useDeleteGalleryMedia() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (mediaId: string) => {
      const res = await fetch(`${apiBaseUrl}/gallery/media/${mediaId}`, {
        method: 'DELETE',
      });
      if (!res.ok) {
        const message = await extractErrorMessage(
          res,
          'ãƒ¡ãƒ‡ã‚£ã‚¢å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ'
        );
        throw new Error(message);
      }
      return res.json() as Promise<{ success: boolean }>;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: galleryKeys.all });
      notifications.show({
        title: 'å‰Šé™¤å®Œäº†',
        message: 'ãƒ¡ãƒ‡ã‚£ã‚¢ã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
        color: 'green',
      });
    },
    onError: (error) => {
      notifications.show({
        title: 'å‰Šé™¤å¤±æ•—',
        message:
          error instanceof Error ? error.message : 'ãƒ¡ãƒ‡ã‚£ã‚¢å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ',
        color: 'red',
      });
    },
  });
}

/**
 * ãƒ¡ãƒ‡ã‚£ã‚¢é †åºæ›´æ–°
 */
export function useReorderGalleryMedia() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      entryId,
      mediaIds,
    }: {
      entryId: string;
      mediaIds: string[];
    }) => {
      const res = await fetch(
        `${apiBaseUrl}/gallery/${entryId}/media/reorder`,
        {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ mediaIds }),
        }
      );
      if (!res.ok) {
        const message = await extractErrorMessage(
          res,
          'é †åºå¤‰æ›´ã«å¤±æ•—ã—ã¾ã—ãŸ'
        );
        throw new Error(message);
      }
      return res.json() as Promise<{ success: boolean }>;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: galleryKeys.all });
    },
    onError: (error) => {
      notifications.show({
        title: 'é †åºå¤‰æ›´å¤±æ•—',
        message:
          error instanceof Error ? error.message : 'é †åºå¤‰æ›´ã«å¤±æ•—ã—ã¾ã—ãŸ',
        color: 'red',
      });
    },
  });
}
````

## File: frontend/src/lib/api/hooks/use-graduation.ts
````typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import type { Cat } from './use-cats';
import { getPublicApiBaseUrl } from '@/lib/api/public-api-base-url';

// Graduationå‹å®šç¾©
export interface Graduation {
  id: string;
  catId: string;
  transferDate: string;
  destination: string;
  notes?: string;
  catSnapshot: Cat; // è­²æ¸¡æ™‚ç‚¹ã®çŒ«ãƒ‡ãƒ¼ã‚¿
  transferredBy?: string;
  createdAt: string;
  updatedAt: string;
  cat?: {
    id: string;
    name: string;
    gender: string;
    birthDate: string;
  };
}

export interface GraduationsResponse {
  success: boolean;
  data: Graduation[];
  meta: {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
  };
}

export interface GraduationDetailResponse {
  success: boolean;
  data: Graduation;
}

export interface TransferCatDto {
  transferDate: string; // ISO 8601 date string
  destination: string;
  notes?: string;
}

export interface TransferCatResponse {
  success: boolean;
  data: Graduation;
}

/**
 * çŒ«ã‚’è­²æ¸¡ï¼ˆå’æ¥­ï¼‰ã™ã‚‹
 */
export function useTransferCat() {
  const queryClient = useQueryClient();

  return useMutation<TransferCatResponse, Error, { catId: string; data: TransferCatDto }>({
    mutationFn: async ({ catId, data }) => {
      const apiBaseUrl = getPublicApiBaseUrl();
      const response = await fetch(`${apiBaseUrl}/graduations/cats/${catId}/transfer`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data),
      });

      if (!response.ok) {
        const errorData = await response.json() as { message?: string };
        throw new Error(errorData.message || 'Failed to transfer cat');
      }

      return response.json() as Promise<TransferCatResponse>;
    },
    onSuccess: () => {
      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ç„¡åŠ¹åŒ–
      queryClient.invalidateQueries({ queryKey: ['cats'] });
      queryClient.invalidateQueries({ queryKey: ['graduations'] });
    },
  });
}

/**
 * å’æ¥­çŒ«ä¸€è¦§å–å¾—
 */
export function useGetGraduations(page = 1, limit = 50) {
  return useQuery<GraduationsResponse, Error>({
    queryKey: ['graduations', page, limit],
    queryFn: async () => {
      const apiBaseUrl = getPublicApiBaseUrl();
      const response = await fetch(
        `${apiBaseUrl}/graduations?page=${page}&limit=${limit}`
      );

      if (!response.ok) {
        throw new Error('Failed to fetch graduations');
      }

      return response.json() as Promise<GraduationsResponse>;
    },
  });
}

/**
 * å’æ¥­çŒ«è©³ç´°å–å¾—
 */
export function useGetGraduationDetail(id: string | null) {
  return useQuery<GraduationDetailResponse, Error>({
    queryKey: ['graduation', id],
    queryFn: async () => {
      if (!id) throw new Error('Graduation ID is required');

      const apiBaseUrl = getPublicApiBaseUrl();

      const response = await fetch(`${apiBaseUrl}/graduations/${id}`);

      if (!response.ok) {
        throw new Error('Failed to fetch graduation detail');
      }

      return response.json() as Promise<GraduationDetailResponse>;
    },
    enabled: !!id, // idãŒnullã®å ´åˆã¯ã‚¯ã‚¨ãƒªã‚’å®Ÿè¡Œã—ãªã„
  });
}

/**
 * å’æ¥­å–ã‚Šæ¶ˆã—ï¼ˆç·Šæ€¥æ™‚ç”¨ï¼‰
 */
export function useCancelGraduation() {
  const queryClient = useQueryClient();

  return useMutation<{ success: boolean; message: string }, Error, string>({
    mutationFn: async (graduationId: string) => {
      const apiBaseUrl = getPublicApiBaseUrl();
      const response = await fetch(`${apiBaseUrl}/graduations/${graduationId}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        const errorData = await response.json() as { message?: string };
        throw new Error(errorData.message || 'Failed to cancel graduation');
      }

      return response.json() as Promise<{ success: boolean; message: string }>;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['cats'] });
      queryClient.invalidateQueries({ queryKey: ['graduations'] });
    },
  });
}
````

## File: frontend/src/lib/api/hooks/use-master-data.ts
````typescript
import { useQuery, type UseQueryOptions } from '@tanstack/react-query';
import { apiRequest, type ApiResponse } from '../client';

export type DisplayNameMode = 'CANONICAL' | 'CODE_AND_NAME' | 'CUSTOM';

export interface MasterDataItem {
  code: number;
  name: string;
  displayName?: string | null;
  displayNameMode?: DisplayNameMode;
  isOverridden?: boolean;
}

const MASTER_DATA_STALE_TIME = 1000 * 60 * 10; // 10 minutes

async function fetchBreedMasterData() {
  return apiRequest<MasterDataItem[]>('/breeds/master-data');
}

async function fetchCoatColorMasterData() {
  return apiRequest<MasterDataItem[]>('/coat-colors/master-data');
}

export function useBreedMasterData(
  options?: Omit<UseQueryOptions<ApiResponse<MasterDataItem[]>>, 'queryKey' | 'queryFn'>,
) {
  return useQuery({
    queryKey: ['master-data', 'breeds'],
    queryFn: fetchBreedMasterData,
    staleTime: MASTER_DATA_STALE_TIME,
    gcTime: MASTER_DATA_STALE_TIME,
    ...options,
  });
}

export function useCoatColorMasterData(
  options?: Omit<UseQueryOptions<ApiResponse<MasterDataItem[]>>, 'queryKey' | 'queryFn'>,
) {
  return useQuery({
    queryKey: ['master-data', 'coat-colors'],
    queryFn: fetchCoatColorMasterData,
    staleTime: MASTER_DATA_STALE_TIME,
    gcTime: MASTER_DATA_STALE_TIME,
    ...options,
  });
}
````

## File: frontend/src/lib/api/hooks/use-pedigrees.ts
````typescript
/**
 * è¡€çµ±æ›¸ç®¡ç†APIãƒ•ãƒƒã‚¯
 */

import { useMutation, useQuery, useQueryClient, type UseQueryOptions } from '@tanstack/react-query';
import { notifications } from '@mantine/notifications';
import { apiClient, type ApiPathParams, type ApiQueryParams, type ApiRequestBody } from '../client';
import { createDomainQueryKeys } from './query-key-factory';

export interface PedigreeRecord {
  id: string;
  pedigreeId: string;
  catName?: string | null;
  title?: string | null;
  genderCode?: number | null;
  eyeColor?: string | null;
  breedCode?: number | null;
  coatColorCode?: number | null;
  birthDate?: string | null;
  breederName?: string | null;
  ownerName?: string | null;
  registrationDate?: string | null;
  createdAt?: string;
  updatedAt?: string;
  [key: string]: unknown;
}

export interface PedigreeListMeta {
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export type GetPedigreesParams = ApiQueryParams<'/pedigrees', 'get'>;

export interface PedigreeListResponse {
  success: boolean;
  data?: PedigreeRecord[];
  meta?: PedigreeListMeta;
  message?: string;
  error?: string;
}

export type CreatePedigreeRequest = ApiRequestBody<'/pedigrees', 'post'>;
export type UpdatePedigreeRequest = ApiRequestBody<'/pedigrees/{id}', 'patch'>;

const basePedigreeKeys = createDomainQueryKeys<string, GetPedigreesParams>('pedigrees');

export const pedigreeKeys = {
  ...basePedigreeKeys,
  byNumber: (pedigreeId: string) => [...basePedigreeKeys.all, 'by-number', pedigreeId] as const,
  family: (id: string, generations?: number) =>
    [...basePedigreeKeys.all, 'family', id, generations ?? 'default'] as const,
  familyTree: (id: string) => [...basePedigreeKeys.all, 'family-tree', id] as const,
  descendants: (id: string) => [...basePedigreeKeys.all, 'descendants', id] as const,
};

export function useGetPedigrees(
  params: GetPedigreesParams = {},
  options?: Omit<UseQueryOptions<PedigreeListResponse>, 'queryKey' | 'queryFn'>,
) {
  return useQuery({
    queryKey: pedigreeKeys.list(params),
    queryFn: () =>
      apiClient.get('/pedigrees', {
        query: params,
      }) as Promise<PedigreeListResponse>,
    ...options,
  });
}

export function useGetPedigree(
  id: string,
  options?: Omit<UseQueryOptions<PedigreeRecord | null>, 'queryKey' | 'queryFn'>,
) {
  return useQuery({
    queryKey: pedigreeKeys.detail(id),
    queryFn: async () => {
      if (!id) return null;
      const response = await apiClient.get('/pedigrees/{id}', {
        pathParams: { id } as ApiPathParams<'/pedigrees/{id}', 'get'>,
      });
      return (response.data ?? null) as PedigreeRecord | null;
    },
    enabled: !!id,
    ...options,
  });
}

export function useGetPedigreeByNumber(
  pedigreeId: string,
  options?: Omit<UseQueryOptions<PedigreeRecord | null>, 'queryKey' | 'queryFn'>,
) {
  return useQuery({
    queryKey: pedigreeKeys.byNumber(pedigreeId),
    queryFn: async () => {
      if (!pedigreeId) return null;
      const response = await apiClient.get('/pedigrees/pedigree-id/{pedigreeId}', {
        pathParams: { pedigreeId } as ApiPathParams<'/pedigrees/pedigree-id/{pedigreeId}', 'get'>,
      });
      return (response.data ?? null) as PedigreeRecord | null;
    },
    enabled: !!pedigreeId,
    ...options,
  });
}

export function useGetPedigreeFamily(
  id: string,
  generations?: number,
  options?: Omit<UseQueryOptions<unknown>, 'queryKey' | 'queryFn'>,
) {
  return useQuery({
    queryKey: pedigreeKeys.family(id, generations),
    queryFn: () =>
      apiClient.get('/pedigrees/{id}/family', {
        pathParams: { id } as ApiPathParams<'/pedigrees/{id}/family', 'get'>,
        query: generations
          ? ({ generations } as unknown as ApiQueryParams<'/pedigrees/{id}/family', 'get'>)
          : undefined,
      }),
    enabled: !!id,
    ...options,
  });
}

export function useGetPedigreeDescendants(
  id: string,
  options?: Omit<UseQueryOptions<unknown>, 'queryKey' | 'queryFn'>,
) {
  return useQuery({
    queryKey: pedigreeKeys.descendants(id),
    queryFn: () =>
      apiClient.get('/pedigrees/{id}/descendants', {
        pathParams: { id } as ApiPathParams<'/pedigrees/{id}/descendants', 'get'>,
      }),
    enabled: !!id,
    ...options,
  });
}

export function useGetPedigreeFamilyTree(
  id: string,
  options?: Omit<UseQueryOptions<unknown>, 'queryKey' | 'queryFn'>,
) {
  return useQuery({
    queryKey: pedigreeKeys.familyTree(id),
    queryFn: () =>
      apiClient.get('/pedigrees/{id}/family-tree', {
        pathParams: { id } as ApiPathParams<'/pedigrees/{id}/family-tree', 'get'>,
      }),
    enabled: !!id,
    ...options,
  });
}

export function useCreatePedigree() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (payload: CreatePedigreeRequest) =>
      apiClient.post('/pedigrees', {
        body: payload,
      }),
    onSuccess: (response) => {
      const createdId = (response.data as PedigreeRecord | undefined)?.id;
      void queryClient.invalidateQueries({ queryKey: pedigreeKeys.lists() });
      if (createdId) {
        void queryClient.invalidateQueries({ queryKey: pedigreeKeys.detail(createdId) });
      }
      notifications.show({
        title: 'è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’ç™»éŒ²ã—ã¾ã—ãŸ',
        message: 'è¡€çµ±æ›¸æƒ…å ±ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'å…¥åŠ›å†…å®¹ã‚’ã”ç¢ºèªã®ä¸Šã€å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}

export function useUpdatePedigree(id: string) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (payload: UpdatePedigreeRequest) =>
      apiClient.patch('/pedigrees/{id}', {
        pathParams: { id } as ApiPathParams<'/pedigrees/{id}', 'patch'>,
        body: payload,
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: pedigreeKeys.lists() });
      void queryClient.invalidateQueries({ queryKey: pedigreeKeys.detail(id) });
      notifications.show({
        title: 'è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°ã—ã¾ã—ãŸ',
        message: 'è¡€çµ±æ›¸æƒ…å ±ã‚’æ›´æ–°ã—ã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}

export function useDeletePedigree() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id: string) =>
      apiClient.delete('/pedigrees/{id}', {
        pathParams: { id } as ApiPathParams<'/pedigrees/{id}', 'delete'>,
      }),
    onSuccess: (_response, id) => {
      void queryClient.invalidateQueries({ queryKey: pedigreeKeys.lists() });
      void queryClient.invalidateQueries({ queryKey: pedigreeKeys.detail(id) });
      notifications.show({
        title: 'è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
        message: 'è¡€çµ±æ›¸æƒ…å ±ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ',
        message: error.message ?? 'æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        color: 'red',
      });
    },
  });
}
````

## File: frontend/src/lib/api/hooks/use-tag-automation.ts
````typescript
import { useMutation, useQuery, useQueryClient, type UseQueryOptions } from '@tanstack/react-query';
import { notifications } from '@mantine/notifications';

import { apiClient, type ApiResponse } from '../client';
import { createDomainQueryKeys } from './query-key-factory';
import { tagCategoryKeys } from './use-tags';

// å‹å®šç¾©
export type TagAutomationTriggerType = 'EVENT' | 'SCHEDULE' | 'MANUAL';
export type TagAutomationEventType =
  | 'BREEDING_PLANNED'
  | 'BREEDING_CONFIRMED'
  | 'PREGNANCY_CONFIRMED'
  | 'KITTEN_REGISTERED'
  | 'AGE_THRESHOLD'
  | 'PAGE_ACTION'
  | 'TAG_ASSIGNED'
  | 'CUSTOM';
export type TagAutomationRunStatus = 'PENDING' | 'COMPLETED' | 'FAILED';

export interface TagAutomationRule {
  id: string;
  key: string;
  name: string;
  description?: string;
  triggerType: TagAutomationTriggerType;
  eventType?: TagAutomationEventType;
  scope?: string;
  config?: Record<string, unknown>;
  priority: number;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
  _count?: {
    runs?: number;
    assignmentHistory?: number;
  };
}

export interface TagAutomationRun {
  id: string;
  ruleId: string;
  status: TagAutomationRunStatus;
  eventPayload?: Record<string, unknown>;
  error?: string;
  createdAt: string;
  completedAt?: string;
}

export interface CreateTagAutomationRuleRequest {
  key: string;
  name: string;
  description?: string;
  triggerType: TagAutomationTriggerType;
  eventType?: TagAutomationEventType;
  scope?: string;
  config?: Record<string, unknown>;
  priority?: number;
  isActive?: boolean;
}

export interface UpdateTagAutomationRuleRequest {
  name?: string;
  description?: string;
  triggerType?: TagAutomationTriggerType;
  eventType?: TagAutomationEventType;
  scope?: string;
  config?: Record<string, unknown>;
  priority?: number;
  isActive?: boolean;
}

export interface TagAutomationRuleFilters {
  active?: boolean;
  scope?: string;
  triggerType?: TagAutomationTriggerType;
  eventType?: TagAutomationEventType;
}

export type TagAutomationRulesResponse = ApiResponse<TagAutomationRule[]>;
export type TagAutomationRuleResponse = ApiResponse<TagAutomationRule>;
export type TagAutomationRunsResponse = ApiResponse<TagAutomationRun[]>;

const automationRuleKeys = createDomainQueryKeys<string, TagAutomationRuleFilters>(
  'tagAutomationRules',
);

export { automationRuleKeys };

function buildAutomationRuleQuery(
  filters?: TagAutomationRuleFilters,
): { active?: boolean; scope?: string; triggerType?: string; eventType?: string } | undefined {
  if (!filters) {
    return undefined;
  }

  const query: { active?: boolean; scope?: string; triggerType?: string; eventType?: string } = {};

  if (filters.active !== undefined) {
    query.active = filters.active;
  }

  if (filters.scope) {
    query.scope = filters.scope;
  }

  if (filters.triggerType) {
    query.triggerType = filters.triggerType;
  }

  if (filters.eventType) {
    query.eventType = filters.eventType;
  }

  return Object.keys(query).length > 0 ? query : undefined;
}

function showErrorNotification(title: string, error: unknown) {
  notifications.show({
    title,
    message: error instanceof Error ? error.message : 'æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
    color: 'red',
  });
}

// ãƒ«ãƒ¼ãƒ«ä¸€è¦§å–å¾—
export function useGetAutomationRules(
  filters?: TagAutomationRuleFilters,
  options?: Omit<UseQueryOptions<TagAutomationRulesResponse>, 'queryKey' | 'queryFn'>,
) {
  return useQuery({
    queryKey: automationRuleKeys.list(filters),
    queryFn: async () => {
      try {
        const query = buildAutomationRuleQuery(filters);
        const response = await apiClient.get('/tags/automation/rules', {
          query: query,
        });

        // Validate response.data is an array
        if (!response.data || !Array.isArray(response.data)) {
          return { ...response, data: [] } satisfies TagAutomationRulesResponse;
        }

        return response as TagAutomationRulesResponse;
      } catch (error) {
        console.error('Failed to fetch automation rules:', error);
        throw error;
      }
    },
    ...options,
  });
}

// ãƒ«ãƒ¼ãƒ«è©³ç´°å–å¾—
export function useGetAutomationRule(
  ruleId: string,
  options?: Omit<UseQueryOptions<TagAutomationRuleResponse>, 'queryKey' | 'queryFn'>,
) {
  return useQuery({
    queryKey: automationRuleKeys.detail(ruleId),
    queryFn: async () => {
      try {
        const response = await apiClient.get('/tags/automation/rules/{id}', {
          pathParams: { id: ruleId },
          query: {
            includeRuns: true,
            includeHistoryCount: true,
          },
        });

        return response as TagAutomationRuleResponse;
      } catch (error) {
        console.error('Failed to fetch automation rule:', error);
        throw error;
      }
    },
    enabled: !!ruleId,
    ...options,
  });
}

// ãƒ«ãƒ¼ãƒ«ä½œæˆ
export function useCreateAutomationRule() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (payload: CreateTagAutomationRuleRequest) =>
      apiClient.post('/tags/automation/rules', {
        // Schema defines config as Record<string, never>, so we need to cast to any to pass actual config
        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment
        body: payload as any,
        retryOnUnauthorized: false,
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: automationRuleKeys.lists() });
      void queryClient.invalidateQueries({ queryKey: tagCategoryKeys.lists() });
      notifications.show({
        title: 'è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ã‚’ä½œæˆã—ã¾ã—ãŸ',
        message: 'æ–°ã—ã„ãƒ«ãƒ¼ãƒ«ãŒåˆ©ç”¨å¯èƒ½ã«ãªã‚Šã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: unknown) => {
      showErrorNotification('ãƒ«ãƒ¼ãƒ«ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ', error);
    },
  });
}

// ãƒ«ãƒ¼ãƒ«æ›´æ–°
export function useUpdateAutomationRule() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, payload }: { id: string; payload: UpdateTagAutomationRuleRequest }) =>
      apiClient.patch('/tags/automation/rules/{id}', {
        pathParams: { id },
        // Schema defines config as Record<string, never>, so we need to cast to any to pass actual config
        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment
        body: payload as any,
        retryOnUnauthorized: false,
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: automationRuleKeys.lists() });
      void queryClient.invalidateQueries({ queryKey: tagCategoryKeys.lists() });
      notifications.show({
        title: 'è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ã‚’æ›´æ–°ã—ã¾ã—ãŸ',
        message: 'ãƒ«ãƒ¼ãƒ«æƒ…å ±ã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: unknown) => {
      showErrorNotification('ãƒ«ãƒ¼ãƒ«ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ', error);
    },
  });
}

// ãƒ«ãƒ¼ãƒ«å‰Šé™¤
export function useDeleteAutomationRule() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id: string) =>
      apiClient.delete('/tags/automation/rules/{id}', {
        pathParams: { id },
        retryOnUnauthorized: false,
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: automationRuleKeys.lists() });
      void queryClient.invalidateQueries({ queryKey: tagCategoryKeys.lists() });
      notifications.show({
        title: 'è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
        message: 'ãƒ«ãƒ¼ãƒ«ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: unknown) => {
      showErrorNotification('ãƒ«ãƒ¼ãƒ«ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ', error);
    },
  });
}

// å®Ÿè¡Œå±¥æ­´å–å¾—
export function useGetAutomationRuns(
  filters?: { ruleId?: string; status?: TagAutomationRunStatus; limit?: number },
  options?: Omit<UseQueryOptions<TagAutomationRunsResponse>, 'queryKey' | 'queryFn'>,
) {
  return useQuery({
    queryKey: ['tagAutomationRuns', filters],
    queryFn: async () => {
      try {
        const query: { ruleId?: string; status?: string; limit?: number } = {};
        if (filters?.ruleId) query.ruleId = filters.ruleId;
        if (filters?.status) query.status = filters.status;
        if (filters?.limit) query.limit = filters.limit;

        const response = await apiClient.get('/tags/automation/runs', {
          query: Object.keys(query).length > 0 ? query : undefined,
        });

        if (!response.data || !Array.isArray(response.data)) {
          return { ...response, data: [] } satisfies TagAutomationRunsResponse;
        }

        return response as TagAutomationRunsResponse;
      } catch (error) {
        console.error('Failed to fetch automation runs:', error);
        throw error;
      }
    },
    ...options,
  });
}

// æ‰‹å‹•å®Ÿè¡Œ
export function useExecuteAutomationRule() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id }: { id: string }) =>
      apiClient.post('/tags/automation/rules/{id}/execute', {
        pathParams: { id },
        retryOnUnauthorized: false,
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: automationRuleKeys.lists() });
      void queryClient.invalidateQueries({ queryKey: ['tagAutomationRuns'] });
      notifications.show({
        title: 'ãƒ«ãƒ¼ãƒ«ã‚’å®Ÿè¡Œã—ã¾ã—ãŸ',
        message: 'å®Ÿè¡ŒãŒå®Œäº†ã—ã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: unknown) => {
      showErrorNotification('ãƒ«ãƒ¼ãƒ«ã®å®Ÿè¡Œã«å¤±æ•—ã—ã¾ã—ãŸ', error);
    },
  });
}
````

## File: frontend/src/lib/api/hooks/use-tags.ts
````typescript
import { useMutation, useQuery, useQueryClient, type UseQueryOptions } from '@tanstack/react-query';
import { notifications } from '@mantine/notifications';

import {
  apiClient,
  type ApiPathParams,
  type ApiQueryParams,
  type ApiRequestBody,
  type ApiResponse,
} from '../client';
import { createDomainQueryKeys } from './query-key-factory';
import { catKeys } from './use-cats';

export interface TagView {
  id: string;
  groupId: string;
  categoryId: string;
  name: string;
  color: string;
  textColor?: string;
  description?: string;
  displayOrder: number;
  allowsManual: boolean;
  allowsAutomation: boolean;
  metadata?: Record<string, unknown> | null;
  isActive: boolean;
  usageCount: number;
}

export interface TagGroupView {
  id: string;
  categoryId: string;
  name: string;
  description?: string;
  color?: string;
  textColor?: string;
  displayOrder: number;
  isActive: boolean;
  tags: TagView[];
}

export interface TagCategoryView {
  id: string;
  key: string;
  name: string;
  description?: string;
  color?: string;
  textColor?: string;
  displayOrder: number;
  scopes: string[];
  isActive: boolean;
  groups: TagGroupView[];
  tags: TagView[];
}

export type TagCategoriesResponse = ApiResponse<TagCategoryView[]>;

export interface TagCategoryFilters {
  scope?: string[];
  includeInactive?: boolean;
}

export type CreateTagCategoryRequest = ApiRequestBody<'/tags/categories', 'post'>;
export type UpdateTagCategoryRequest = ApiRequestBody<'/tags/categories/{id}', 'patch'>;
export type ReorderTagCategoriesRequest = ApiRequestBody<'/tags/categories/reorder', 'patch'>;

export type CreateTagRequest = ApiRequestBody<'/tags', 'post'>;
export type UpdateTagRequest = ApiRequestBody<'/tags/{id}', 'patch'>;
export type ReorderTagsRequest = ApiRequestBody<'/tags/reorder', 'patch'>;

export type CreateTagGroupRequest = ApiRequestBody<'/tags/groups', 'post'>;
export type UpdateTagGroupRequest = ApiRequestBody<'/tags/groups/{id}', 'patch'>;
export type ReorderTagGroupsRequest = ApiRequestBody<'/tags/groups/reorder', 'patch'>;

type AssignTagRequest = ApiRequestBody<'/tags/cats/{id}/tags', 'post'>;

const tagCategoryKeys = createDomainQueryKeys<string, TagCategoryFilters>('tagCategories');

export { tagCategoryKeys };

type TagCategoryQueryParams = ApiQueryParams<'/tags', 'get'>;

function buildTagCategoryQuery(filters?: TagCategoryFilters): TagCategoryQueryParams | undefined {
  if (!filters) {
    return undefined;
  }

  const query: Record<string, unknown> = {};

  if (filters.scope && filters.scope.length > 0) {
    query.scope = filters.scope;
  }

  if (filters.includeInactive) {
    query.includeInactive = true;
  }

  return Object.keys(query).length > 0 ? (query as TagCategoryQueryParams) : undefined;
}

function showErrorNotification(title: string, error: unknown) {
  notifications.show({
    title,
    message: error instanceof Error ? error.message : 'æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
    color: 'red',
  });
}

export function useGetTagCategories(
  filters?: TagCategoryFilters,
  options?: Omit<UseQueryOptions<TagCategoriesResponse>, 'queryKey' | 'queryFn'>,
) {
  return useQuery({
    queryKey: tagCategoryKeys.list(filters),
    queryFn: async () => {
      try {
        const response = (await apiClient.get('/tags/categories', {
          query: buildTagCategoryQuery(filters),
        })) as TagCategoriesResponse;

        // Validate response.data is an array
        if (!response.data || !Array.isArray(response.data)) {
          return { ...response, data: [] } satisfies TagCategoriesResponse;
        }

        // Filter out null/undefined categories and safely process them
        const data = response.data
          .filter((category): category is TagCategoryView => category != null && typeof category === 'object')
          .map((category) => {
            // Safely handle groups - filter out nulls and ensure it's an array
            const groups = Array.isArray(category.groups) 
              ? category.groups.filter((group) => group != null && typeof group === 'object')
              : [];
            
            // Flatten tags from all groups, filtering out nulls
            const tags = groups.flatMap((group) => {
              const groupTags = Array.isArray(group.tags) 
                ? group.tags.filter((tag) => tag != null && typeof tag === 'object')
                : [];
              return groupTags;
            });

            return {
              ...category,
              groups,
              tags,
            };
          });

        return { ...response, data } satisfies TagCategoriesResponse;
      } catch (error) {
        // Return empty data on error to prevent crashes
        console.error('Error fetching tag categories:', error);
        return { success: false, data: [] } as TagCategoriesResponse;
      }
    },
    staleTime: 1000 * 60,
    ...options,
  });
}

export function useCreateTagCategory() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (payload: CreateTagCategoryRequest) =>
      apiClient.post('/tags/categories', {
        body: payload,
        retryOnUnauthorized: false,
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: tagCategoryKeys.lists() });
      notifications.show({
        title: 'ã‚«ãƒ†ã‚´ãƒªã‚’ä½œæˆã—ã¾ã—ãŸ',
        message: 'æ–°ã—ã„ã‚«ãƒ†ã‚´ãƒªãŒåˆ©ç”¨å¯èƒ½ã«ãªã‚Šã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: unknown) => {
      showErrorNotification('ã‚«ãƒ†ã‚´ãƒªã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ', error);
    },
  });
}

export function useUpdateTagCategory() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, payload }: { id: string; payload: UpdateTagCategoryRequest }) =>
      apiClient.patch('/tags/categories/{id}', {
        pathParams: { id } as ApiPathParams<'/tags/categories/{id}', 'patch'>,
        body: payload,
        retryOnUnauthorized: false,
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: tagCategoryKeys.lists() });
      notifications.show({
        title: 'ã‚«ãƒ†ã‚´ãƒªã‚’æ›´æ–°ã—ã¾ã—ãŸ',
        message: 'ã‚«ãƒ†ã‚´ãƒªæƒ…å ±ã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: unknown) => {
      showErrorNotification('ã‚«ãƒ†ã‚´ãƒªã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ', error);
    },
  });
}

export function useDeleteTagCategory() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id: string) =>
      apiClient.delete('/tags/categories/{id}', {
        pathParams: { id } as ApiPathParams<'/tags/categories/{id}', 'delete'>,
        retryOnUnauthorized: false,
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: tagCategoryKeys.lists() });
      notifications.show({
        title: 'ã‚«ãƒ†ã‚´ãƒªã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
        message: 'ã‚«ãƒ†ã‚´ãƒªã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: unknown) => {
      showErrorNotification('ã‚«ãƒ†ã‚´ãƒªã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ', error);
    },
  });
}

export function useReorderTagCategories() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (payload: ReorderTagCategoriesRequest) =>
      apiClient.patch('/tags/categories/reorder', {
        body: payload,
        retryOnUnauthorized: false,
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: tagCategoryKeys.lists() });
    },
    onError: (error: unknown) => {
      showErrorNotification('ã‚«ãƒ†ã‚´ãƒªã®ä¸¦ã³æ›¿ãˆã«å¤±æ•—ã—ã¾ã—ãŸ', error);
    },
  });
}

export function useCreateTagGroup() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (payload: CreateTagGroupRequest) =>
      apiClient.post('/tags/groups', {
        body: payload,
        retryOnUnauthorized: false,
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: tagCategoryKeys.lists() });
      notifications.show({
        title: 'ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆã—ã¾ã—ãŸ',
        message: 'æ–°ã—ã„ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ãŒåˆ©ç”¨å¯èƒ½ã«ãªã‚Šã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: unknown) => {
      showErrorNotification('ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ', error);
    },
  });
}

export function useUpdateTagGroup() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, payload }: { id: string; payload: UpdateTagGroupRequest }) =>
      apiClient.patch('/tags/groups/{id}', {
        pathParams: { id } as ApiPathParams<'/tags/groups/{id}', 'patch'>,
        body: payload,
        retryOnUnauthorized: false,
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: tagCategoryKeys.lists() });
      notifications.show({
        title: 'ã‚°ãƒ«ãƒ¼ãƒ—ã‚’æ›´æ–°ã—ã¾ã—ãŸ',
        message: 'ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—æƒ…å ±ã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: unknown) => {
      showErrorNotification('ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ', error);
    },
  });
}

export function useDeleteTagGroup() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id: string) =>
      apiClient.delete('/tags/groups/{id}', {
        pathParams: { id } as ApiPathParams<'/tags/groups/{id}', 'delete'>,
        retryOnUnauthorized: false,
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: tagCategoryKeys.lists() });
      notifications.show({
        title: 'ã‚°ãƒ«ãƒ¼ãƒ—ã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
        message: 'ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: unknown) => {
      showErrorNotification('ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ', error);
    },
  });
}

export function useReorderTagGroups() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (payload: ReorderTagGroupsRequest) =>
      apiClient.patch('/tags/groups/reorder', {
        body: payload,
        retryOnUnauthorized: false,
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: tagCategoryKeys.lists() });
    },
    onError: (error: unknown) => {
      showErrorNotification('ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ã®ä¸¦ã³æ›¿ãˆã«å¤±æ•—ã—ã¾ã—ãŸ', error);
    },
  });
}

export function useCreateTag() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (payload: CreateTagRequest) =>
      apiClient.post('/tags', {
        body: payload,
        retryOnUnauthorized: false,
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: tagCategoryKeys.lists() });
      notifications.show({
        title: 'ã‚¿ã‚°ã‚’ä½œæˆã—ã¾ã—ãŸ',
        message: 'æ–°ã—ã„ã‚¿ã‚°ãŒåˆ©ç”¨å¯èƒ½ã«ãªã‚Šã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: unknown) => {
      showErrorNotification('ã‚¿ã‚°ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ', error);
    },
  });
}

export function useUpdateTag() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, payload }: { id: string; payload: UpdateTagRequest }) =>
      apiClient.patch('/tags/{id}', {
        pathParams: { id } as ApiPathParams<'/tags/{id}', 'patch'>,
        body: payload,
        retryOnUnauthorized: false,
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: tagCategoryKeys.lists() });
      notifications.show({
        title: 'ã‚¿ã‚°ã‚’æ›´æ–°ã—ã¾ã—ãŸ',
        message: 'ã‚¿ã‚°æƒ…å ±ã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: unknown) => {
      showErrorNotification('ã‚¿ã‚°ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ', error);
    },
  });
}

export function useDeleteTag() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id: string) =>
      apiClient.delete('/tags/{id}', {
        pathParams: { id } as ApiPathParams<'/tags/{id}', 'delete'>,
        retryOnUnauthorized: false,
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: tagCategoryKeys.lists() });
      notifications.show({
        title: 'ã‚¿ã‚°ã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
        message: 'ã‚¿ã‚°ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: unknown) => {
      showErrorNotification('ã‚¿ã‚°ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ', error);
    },
  });
}

export function useReorderTags() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (payload: ReorderTagsRequest) =>
      apiClient.patch('/tags/reorder', {
        body: payload,
        retryOnUnauthorized: false,
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: tagCategoryKeys.lists() });
    },
    onError: (error: unknown) => {
      showErrorNotification('ã‚¿ã‚°ã®ä¸¦ã³æ›¿ãˆã«å¤±æ•—ã—ã¾ã—ãŸ', error);
    },
  });
}

export function useAssignTagToCat(catId: string) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (payload: AssignTagRequest) =>
      apiClient.post('/tags/cats/{id}/tags', {
        pathParams: { id: catId } as ApiPathParams<'/tags/cats/{id}/tags', 'post'>,
        body: payload,
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: catKeys.detail(catId) });
      void queryClient.invalidateQueries({ queryKey: catKeys.lists() });
      void queryClient.invalidateQueries({ queryKey: tagCategoryKeys.lists() });
      notifications.show({
        title: 'ã‚¿ã‚°ã‚’ä»˜ä¸ã—ã¾ã—ãŸ',
        message: 'çŒ«ã®ã‚¿ã‚°æƒ…å ±ã‚’æ›´æ–°ã—ã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: unknown) => {
      showErrorNotification('ã‚¿ã‚°ä»˜ä¸ã«å¤±æ•—ã—ã¾ã—ãŸ', error);
    },
  });
}

export function useUnassignTagFromCat(catId: string) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (tagId: string) =>
      apiClient.delete('/tags/cats/{id}/tags/{tagId}', {
        pathParams: { id: catId, tagId } as ApiPathParams<'/tags/cats/{id}/tags/{tagId}', 'delete'>,
      }),
    onSuccess: () => {
      void queryClient.invalidateQueries({ queryKey: catKeys.detail(catId) });
      void queryClient.invalidateQueries({ queryKey: catKeys.lists() });
      void queryClient.invalidateQueries({ queryKey: tagCategoryKeys.lists() });
      notifications.show({
        title: 'ã‚¿ã‚°ã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
        message: 'çŒ«ã‹ã‚‰ã‚¿ã‚°ã‚’è§£é™¤ã—ã¾ã—ãŸã€‚',
        color: 'teal',
      });
    },
    onError: (error: unknown) => {
      showErrorNotification('ã‚¿ã‚°è§£é™¤ã«å¤±æ•—ã—ã¾ã—ãŸ', error);
    },
  });
}
````

## File: frontend/src/lib/api/hooks/use-tenant-settings.ts
````typescript
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { apiClient } from '../client';
import { createDomainQueryKeys } from './query-key-factory';

// ãƒ†ãƒŠãƒ³ãƒˆè¨­å®šç”¨ã®ã‚¯ã‚¨ãƒªã‚­ãƒ¼ãƒ•ã‚¡ã‚¯ãƒˆãƒª
const tenantSettingsKeys = createDomainQueryKeys('tenant-settings', {
  extras: {
    tagColorDefaults: () => [] as const,
  },
});

/**
 * ã‚«ãƒ©ãƒ¼è¨­å®šï¼ˆèƒŒæ™¯è‰²ã¨ãƒ†ã‚­ã‚¹ãƒˆè‰²ï¼‰
 */
export interface ColorSetting {
  color: string;
  textColor: string;
}

/**
 * ã‚¿ã‚°ã‚«ãƒ©ãƒ¼ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š
 */
export interface TagColorDefaults {
  category?: ColorSetting;
  group?: ColorSetting;
  tag?: ColorSetting;
}

/**
 * ã‚¿ã‚°ã‚«ãƒ©ãƒ¼ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šæ›´æ–°ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
 * éƒ¨åˆ†æ›´æ–°ã‚’ã‚µãƒãƒ¼ãƒˆ
 */
export interface UpdateTagColorDefaultsRequest {
  category?: Partial<ColorSetting>;
  group?: Partial<ColorSetting>;
  tag?: Partial<ColorSetting>;
}

/**
 * ãƒ†ãƒŠãƒ³ãƒˆã®ã‚¿ã‚°ã‚«ãƒ©ãƒ¼ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’å–å¾—
 */
export function useGetTagColorDefaults() {
  const queryKey = tenantSettingsKeys.extras?.tagColorDefaults?.() ?? ['tenant-settings', 'tagColorDefaults'];
  
  return useQuery<TagColorDefaults>({
    queryKey,
    queryFn: async () => {
      const response = await apiClient.get('/tenant-settings/tag-color-defaults' as never);
      return (response.data ?? {}) as TagColorDefaults;
    },
    staleTime: 5 * 60 * 1000, // 5åˆ†é–“ã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨
  });
}

/**
 * ãƒ†ãƒŠãƒ³ãƒˆã®ã‚¿ã‚°ã‚«ãƒ©ãƒ¼ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’æ›´æ–°
 */
export function useUpdateTagColorDefaults() {
  const queryClient = useQueryClient();
  const queryKey = tenantSettingsKeys.extras?.tagColorDefaults?.() ?? ['tenant-settings', 'tagColorDefaults'];

  return useMutation<TagColorDefaults, Error, UpdateTagColorDefaultsRequest>({
    mutationFn: async (request: UpdateTagColorDefaultsRequest) => {
      const response = await apiClient.put(
        '/tenant-settings/tag-color-defaults' as never,
        { body: request } as never
      );
      return (response.data ?? {}) as TagColorDefaults;
    },
    onSuccess: (data) => {
      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æ›´æ–°
      queryClient.setQueryData(queryKey, data);
    },
  });
}
````

## File: frontend/src/lib/api/hooks/use-weight-records.ts
````typescript
/**
 * ä½“é‡è¨˜éŒ²APIãƒ•ãƒƒã‚¯ (TanStack Query)
 */

import { useQuery, useMutation, useQueryClient, type UseQueryOptions } from '@tanstack/react-query';
import { apiRequest } from '../client';
import { createDomainQueryKeys } from './query-key-factory';
import { notifications } from '@mantine/notifications';

/**
 * ä½“é‡è¨˜éŒ²ã®å‹å®šç¾©
 */
export interface WeightRecord {
  id: string;
  catId: string;
  weight: number;
  recordedAt: string;
  notes: string | null;
  recordedBy: string;
  createdAt: string;
  updatedAt: string;
  recorder?: {
    id: string;
    firstName: string | null;
    lastName: string | null;
    email: string;
  };
}

/**
 * ä½“é‡è¨˜éŒ²ã‚µãƒãƒªãƒ¼
 */
export interface WeightRecordSummary {
  latestWeight: number | null;
  previousWeight: number | null;
  weightChange: number | null;
  latestRecordedAt: string | null;
  recordCount: number;
}

/**
 * ä½“é‡è¨˜éŒ²ä¸€è¦§å–å¾—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
 */
export interface GetWeightRecordsParams {
  catId: string;
  page?: number;
  limit?: number;
  startDate?: string;
  endDate?: string;
  sortOrder?: 'asc' | 'desc';
}

/**
 * ä½“é‡è¨˜éŒ²ä¸€è¦§ãƒ¬ã‚¹ãƒãƒ³ã‚¹
 */
export interface GetWeightRecordsResponse {
  data: WeightRecord[];
  meta: {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
  };
  summary?: WeightRecordSummary;
}

/**
 * ä½“é‡è¨˜éŒ²ä½œæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆ
 */
export interface CreateWeightRecordRequest {
  weight: number;
  recordedAt?: string;
  notes?: string;
}

/**
 * ä½“é‡è¨˜éŒ²æ›´æ–°ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
 */
export interface UpdateWeightRecordRequest {
  weight?: number;
  recordedAt?: string;
  notes?: string;
}

/**
 * ä¸€æ‹¬ä½“é‡è¨˜éŒ²ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
 */
export interface BulkWeightRecordItem {
  catId: string;
  weight: number;
  notes?: string;
}

export interface CreateBulkWeightRecordsRequest {
  recordedAt: string;
  records: BulkWeightRecordItem[];
}

/**
 * ä¸€æ‹¬ä½“é‡è¨˜éŒ²ãƒ¬ã‚¹ãƒãƒ³ã‚¹
 */
export interface CreateBulkWeightRecordsResponse {
  success: boolean;
  created: number;
  records: WeightRecord[];
}

/**
 * ã‚¯ã‚¨ãƒªã‚­ãƒ¼å®šç¾©
 */
const baseWeightRecordKeys = createDomainQueryKeys<string, GetWeightRecordsParams>('weightRecords');

export const weightRecordKeys = {
  ...baseWeightRecordKeys,
  byCat: (catId: string, params?: Omit<GetWeightRecordsParams, 'catId'>) =>
    [...baseWeightRecordKeys.all, 'byCat', catId, params ?? {}] as const,
};

/**
 * çŒ«ã®ä½“é‡è¨˜éŒ²ä¸€è¦§ã‚’å–å¾—ã™ã‚‹ãƒ•ãƒƒã‚¯
 */
export function useGetWeightRecords(
  params: GetWeightRecordsParams,
  options?: Omit<UseQueryOptions<GetWeightRecordsResponse>, 'queryKey' | 'queryFn'>,
) {
  const { catId, ...queryParams } = params;

  // ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰
  const queryString = new URLSearchParams();
  if (queryParams.page) queryString.set('page', String(queryParams.page));
  if (queryParams.limit) queryString.set('limit', String(queryParams.limit));
  if (queryParams.startDate) queryString.set('startDate', queryParams.startDate);
  if (queryParams.endDate) queryString.set('endDate', queryParams.endDate);
  if (queryParams.sortOrder) queryString.set('sortOrder', queryParams.sortOrder);

  const urlPath = `/cats/${catId}/weight-records${queryString.toString() ? `?${queryString.toString()}` : ''}`;

  return useQuery({
    queryKey: weightRecordKeys.byCat(catId, queryParams),
    queryFn: async () => {
      const response = await apiRequest<WeightRecord[]>(urlPath);
      return {
        data: response.data ?? [],
        meta: (response.meta as GetWeightRecordsResponse['meta'] | undefined) ?? {
          total: 0,
          page: 1,
          limit: 50,
          totalPages: 0,
        },
        summary: (response as unknown as { summary?: WeightRecordSummary }).summary,
      };
    },
    enabled: !!catId,
    ...options,
  });
}

/**
 * ä½“é‡è¨˜éŒ²ã‚’ä½œæˆã™ã‚‹ãƒ•ãƒƒã‚¯
 */
export function useCreateWeightRecord(catId: string) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (data: CreateWeightRecordRequest) => {
      const response = await apiRequest<WeightRecord>(`/cats/${catId}/weight-records`, {
        method: 'POST',
        body: JSON.stringify(data),
        headers: {
          'Content-Type': 'application/json',
        },
      });
      return response.data;
    },
    onSuccess: () => {
      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ç„¡åŠ¹åŒ–ã—ã¦å†ãƒ•ã‚§ãƒƒãƒ
      void queryClient.invalidateQueries({ queryKey: weightRecordKeys.byCat(catId) });

      notifications.show({
        title: 'æˆåŠŸ',
        message: 'ä½“é‡è¨˜éŒ²ã‚’è¿½åŠ ã—ã¾ã—ãŸ',
        color: 'green',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: error.message || 'ä½“é‡è¨˜éŒ²ã®è¿½åŠ ã«å¤±æ•—ã—ã¾ã—ãŸ',
        color: 'red',
      });
    },
  });
}

/**
 * ä½“é‡è¨˜éŒ²ã‚’æ›´æ–°ã™ã‚‹ãƒ•ãƒƒã‚¯
 */
export function useUpdateWeightRecord(catId: string) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ recordId, data }: { recordId: string; data: UpdateWeightRecordRequest }) => {
      const response = await apiRequest<WeightRecord>(`/cats/weight-records/${recordId}`, {
        method: 'PATCH',
        body: JSON.stringify(data),
        headers: {
          'Content-Type': 'application/json',
        },
      });
      return response.data;
    },
    onSuccess: () => {
      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ç„¡åŠ¹åŒ–ã—ã¦å†ãƒ•ã‚§ãƒƒãƒ
      void queryClient.invalidateQueries({ queryKey: weightRecordKeys.byCat(catId) });

      notifications.show({
        title: 'æˆåŠŸ',
        message: 'ä½“é‡è¨˜éŒ²ã‚’æ›´æ–°ã—ã¾ã—ãŸ',
        color: 'green',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: error.message || 'ä½“é‡è¨˜éŒ²ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ',
        color: 'red',
      });
    },
  });
}

/**
 * ä½“é‡è¨˜éŒ²ã‚’å‰Šé™¤ã™ã‚‹ãƒ•ãƒƒã‚¯
 */
export function useDeleteWeightRecord(catId: string) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (recordId: string) => {
      await apiRequest(`/cats/weight-records/${recordId}`, {
        method: 'DELETE',
      });
    },
    onSuccess: () => {
      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ç„¡åŠ¹åŒ–ã—ã¦å†ãƒ•ã‚§ãƒƒãƒ
      void queryClient.invalidateQueries({ queryKey: weightRecordKeys.byCat(catId) });

      notifications.show({
        title: 'æˆåŠŸ',
        message: 'ä½“é‡è¨˜éŒ²ã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
        color: 'green',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: error.message || 'ä½“é‡è¨˜éŒ²ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ',
        color: 'red',
      });
    },
  });
}

/**
 * è¤‡æ•°ã®çŒ«ã®ä½“é‡ã‚’ä¸€æ‹¬ç™»éŒ²ã™ã‚‹ãƒ•ãƒƒã‚¯
 */
export function useCreateBulkWeightRecords() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (data: CreateBulkWeightRecordsRequest) => {
      const response = await apiRequest<CreateBulkWeightRecordsResponse>('/cats/weight-records/bulk', {
        method: 'POST',
        body: JSON.stringify(data),
        headers: {
          'Content-Type': 'application/json',
        },
      });
      return response.data;
    },
    onSuccess: (data) => {
      // é–¢é€£ã™ã‚‹å…¨ã¦ã®çŒ«ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ç„¡åŠ¹åŒ–
      void queryClient.invalidateQueries({ queryKey: weightRecordKeys.all });

      notifications.show({
        title: 'æˆåŠŸ',
        message: `${data?.created ?? 0}ä»¶ã®ä½“é‡è¨˜éŒ²ã‚’è¿½åŠ ã—ã¾ã—ãŸ`,
        color: 'green',
      });
    },
    onError: (error: Error) => {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: error.message || 'ä½“é‡è¨˜éŒ²ã®ä¸€æ‹¬è¿½åŠ ã«å¤±æ•—ã—ã¾ã—ãŸ',
        color: 'red',
      });
    },
  });
}
````

## File: frontend/src/lib/api/auth-store.ts
````typescript
export * from '../auth/store';
````

## File: frontend/src/lib/api/client.ts
````typescript
/**
 * API Client
 * ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰APIã¨ã®é€šä¿¡ã‚’è¡Œã†å…±é€šã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
 */

import type { paths } from './generated/schema';
import { getPublicApiBaseUrl } from './public-api-base-url';

// NOTE: generated/schema.ts ã¯æœ€åˆã®å‹ç”Ÿæˆå¾Œã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¯èƒ½ã«ãªã‚Šã¾ã™
async function parseJson(response: Response): Promise<unknown> {
  const text = await response.text();

  if (text.length === 0) {
    return null;
  }

  try {
    return JSON.parse(text) as unknown;
  } catch (error) {
    const parseError = error instanceof Error ? error : undefined;
    if (parseError) {
      throw parseError;
    }
    throw new Error('JSONãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸ');
  }
}
// import type { paths } from './generated/schema';

/**
 * APIåŸºåº•URL
 */
const apiBaseUrl = getPublicApiBaseUrl();

/**
 * APIãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®å…±é€šå‹
 */
export interface ApiResponse<T = unknown, M = unknown> {
  success: boolean;
  data?: T;
  meta?: M;
  error?: string;
  message?: string;
}

/**
 * APIã‚¨ãƒ©ãƒ¼ã‚¯ãƒ©ã‚¹
 */
export class ApiError extends Error {
  constructor(
    message: string,
    public status: number,
    public response?: unknown,
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

type HttpMethod = 'get' | 'post' | 'put' | 'patch' | 'delete';
export type ApiHttpMethod = HttpMethod;

type ApiPrefix = '/api/v1';

type NormalizePath<Path extends string> = Path extends `${ApiPrefix}${infer Rest}`
  ? Rest extends ''
    ? '/'
    : Rest extends `/${string}`
      ? Rest
      : `/${Rest}`
  : Path;

type CanonicalPath<Path extends string> = Path extends `${ApiPrefix}${string}`
  ? Path
  : `${ApiPrefix}${Path extends `/${string}` ? Path : `/${Path}`}`;

type FilterPathsByMethod<M extends HttpMethod> = {
  [P in keyof paths]: paths[P][M] extends never ? never : NormalizePath<P & string>;
}[keyof paths];

type ExtractOperation<P extends string, M extends HttpMethod> = CanonicalPath<P> extends infer Canonical
  ? Canonical extends keyof paths
    ? M extends keyof paths[Canonical]
      ? paths[Canonical][M]
      : never
    : never
  : never;

type PathParamsFor<P extends string, M extends HttpMethod> = ExtractOperation<P, M> extends {
  parameters: { path: infer Params };
}
  ? Params
  : Record<string, never>;

type QueryParamsFor<P extends string, M extends HttpMethod> = ExtractOperation<P, M> extends {
  parameters: { query?: infer Params };
}
  ? Params
  : Record<string, never>;

type RequestBodyFor<P extends string, M extends HttpMethod> = ExtractOperation<P, M> extends {
  requestBody: { content: infer Content };
}
  ? Content extends { 'application/json': infer Json }
    ? Json
    : Content extends Record<string, unknown>
      ? Content[keyof Content]
      : unknown
  : never;

type ResponsesOf<Operation> = Operation extends { responses: infer Responses } ? Responses : never;

type ExtractJsonContent<Response> = Response extends { content: { 'application/json': infer Json } }
  ? Json
  : Response extends { content: infer Content }
    ? Content extends Record<string, unknown>
      ? Content[keyof Content]
      : unknown
    : unknown;

type ExtractResponsePayload<Responses, Status extends number> = Responses extends Record<number | string, unknown>
  ? Status extends keyof Responses
    ? ExtractJsonContent<Responses[Status]>
    : undefined
  : undefined;

type ExtractSuccessResponse<Operation> = Operation extends never
  ? unknown
  : ResponsesOf<Operation> extends infer Responses
    ? Responses extends Record<number | string, unknown>
      ? ExtractResponsePayload<Responses, 200> extends infer R200
        ? [R200] extends [undefined]
          ? ExtractResponsePayload<Responses, 201> extends infer R201
            ? [R201] extends [undefined]
              ? ExtractResponsePayload<Responses, 202> extends infer R202
                ? [R202] extends [undefined]
                  ? ExtractResponsePayload<Responses, 204> extends infer R204
                    ? [R204] extends [undefined]
                      ? unknown
                      : R204
                    : unknown
                  : R202
                : unknown
              : R201
            : unknown
          : R200
        : unknown
      : unknown
    : unknown;

export type ApiSuccessData<P extends FilterPathsByMethod<M>, M extends HttpMethod> = ExtractSuccessResponse<
  ExtractOperation<P, M>
>;

export type ApiRequestOptions<P extends FilterPathsByMethod<M>, M extends HttpMethod> = {
  pathParams?: PathParamsFor<P, M>;
  query?: QueryParamsFor<P, M>;
  body?: RequestBodyFor<P, M>;
  init?: Omit<RequestInit, 'method' | 'body'>;
  retryOnUnauthorized?: boolean;
};

type AllPaths = {
  [P in keyof paths]: NormalizePath<P & string>;
}[keyof paths];

export type ApiPath = AllPaths;
export type ApiMethodPaths<M extends HttpMethod> = FilterPathsByMethod<M>;
export type ApiPathParams<P extends FilterPathsByMethod<M>, M extends HttpMethod> = PathParamsFor<P, M>;
export type ApiQueryParams<P extends FilterPathsByMethod<M>, M extends HttpMethod> = QueryParamsFor<P, M>;
export type ApiRequestBody<P extends FilterPathsByMethod<M>, M extends HttpMethod> = RequestBodyFor<P, M>;

function isRecord(value: unknown): value is Record<string, unknown> {
  return typeof value === 'object' && value !== null;
}

function isApiResponse(value: unknown): value is ApiResponse<unknown> {
  if (!isRecord(value)) {
    return false;
  }

  if (typeof value.success !== 'boolean') {
    return false;
  }

  if ('message' in value && value.message !== undefined && typeof value.message !== 'string') {
    return false;
  }

  if ('error' in value && value.error !== undefined && typeof value.error !== 'string') {
    return false;
  }

  return true;
}

function applyPathParams(path: string, params?: Record<string, unknown>): string {
  if (!params || Object.keys(params).length === 0) {
    if (/\{[^}]+\}/.test(path)) {
      throw new Error(`å¿…é ˆã®ãƒ‘ã‚¹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“: ${path}`);
    }
    return path;
  }

  const resolved = path.replace(/\{([^}]+)\}/g, (_segment, key: string) => {
    if (!(key in params)) {
      throw new Error(`ãƒ‘ã‚¹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ '${key}' ãŒä¸è¶³ã—ã¦ã„ã¾ã™`);
    }

    const value = params[key];

    if (value === undefined || value === null) {
      throw new Error(`ãƒ‘ã‚¹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ '${key}' ãŒç„¡åŠ¹ã§ã™`);
    }

    return encodeURIComponent(String(value));
  });

  if (/\{[^}]+\}/.test(resolved)) {
    throw new Error(`æœªè§£æ±ºã®ãƒ‘ã‚¹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒå­˜åœ¨ã—ã¾ã™: ${resolved}`);
  }

  return resolved;
}

function serializeQueryValue(value: unknown): string {
  if (value instanceof Date) {
    return value.toISOString();
  }

  if (typeof value === 'string') {
    return value;
  }

  if (typeof value === 'number' || typeof value === 'boolean') {
    return String(value);
  }

  if (typeof value === 'object') {
    return JSON.stringify(value);
  }

  return String(value ?? '');
}

function buildQueryString(query?: Record<string, unknown>): string {
  if (!query) {
    return '';
  }

  const searchParams = new URLSearchParams();

  Object.entries(query).forEach(([key, value]) => {
    if (value === undefined || value === null) {
      return;
    }

    if (Array.isArray(value)) {
      value.forEach((item) => {
        if (item === undefined || item === null) {
          return;
        }
        searchParams.append(key, serializeQueryValue(item));
      });
      return;
    }

    searchParams.append(key, serializeQueryValue(value));
  });

  const queryString = searchParams.toString();
  return queryString ? `?${queryString}` : '';
}

function buildRequestUrl<Method extends HttpMethod, PathKey extends FilterPathsByMethod<Method>>(
  path: PathKey,
  options: Pick<ApiRequestOptions<PathKey, Method>, 'pathParams' | 'query'> = {},
): string {
  const resolvedPath = applyPathParams(
    path as string,
    options.pathParams as unknown as Record<string, unknown> | undefined,
  );
  const queryString = buildQueryString(options.query as unknown as Record<string, unknown> | undefined);
  return `${resolvedPath}${queryString}`;
}

/**
 * ãƒˆãƒ¼ã‚¯ãƒ³ç®¡ç†
 */
let accessToken: string | null = null;
let refreshToken: string | null = null;

/**
 * Cookie ã«å€¤ã‚’è¨­å®š
 */
function setCookie(name: string, value: string, days = 7): void {
  if (typeof document === 'undefined') return;
  
  const expires = new Date();
  expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);
  document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/;SameSite=Lax`;
}

/**
 * Cookie ã‹ã‚‰å€¤ã‚’å–å¾—
 */
function getCookie(name: string): string | null {
  if (typeof document === 'undefined') return null;
  
  const nameEQ = name + '=';
  const ca = document.cookie.split(';');
  for (let i = 0; i < ca.length; i++) {
    let c = ca[i];
    while (c.charAt(0) === ' ') c = c.substring(1, c.length);
    if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
  }
  return null;
}

/**
 * Cookie ã‚’å‰Šé™¤
 */
function deleteCookie(name: string): void {
  if (typeof document === 'undefined') return;
  document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 UTC;path=/;`;
}

/**
 * Set authentication tokens
 * 
 * âš ï¸ SECURITY WARNING: Current implementation stores tokens in localStorage
 * which is vulnerable to XSS attacks. This is a known security issue that needs
 * to be addressed.
 * 
 * TODO (P1 - High Priority):
 * - Migrate to HttpOnly cookies for refresh tokens
 * - Consider HttpOnly cookies for access tokens
 * - Remove localStorage storage completely
 * - See: docs/IMPROVEMENT_ACTION_PLAN.md for migration steps
 * 
 * @param access - Access token
 * @param refresh - Optional refresh token
 */
export function setTokens(access: string | null, refresh?: string | null): void {
  accessToken = access ?? null;

  if (refresh !== undefined) {
    refreshToken = refresh ?? null;
  }

  if (typeof window !== 'undefined') {
    if (access) {
      // TODO: Remove localStorage storage in favor of HttpOnly cookies
      localStorage.setItem('accessToken', access);
      setCookie('accessToken', access, 7);
    } else {
      localStorage.removeItem('accessToken');
      deleteCookie('accessToken');
    }

    if (refresh !== undefined) {
      if (refresh) {
        // TODO: Remove localStorage storage in favor of HttpOnly cookies
        localStorage.setItem('refreshToken', refresh);
        setCookie('refreshToken', refresh, 7);
      } else {
        localStorage.removeItem('refreshToken');
        deleteCookie('refreshToken');
      }
    }
  }
}

export function getAccessToken(): string | null {
  if (!accessToken && typeof window !== 'undefined') {
    accessToken = localStorage.getItem('accessToken') || getCookie('accessToken');
  }
  return accessToken;
}

export function getRefreshToken(): string | null {
  if (!refreshToken && typeof window !== 'undefined') {
    refreshToken = localStorage.getItem('refreshToken') || getCookie('refreshToken');
  }
  return refreshToken;
}

export function clearTokens(): void {
  accessToken = null;
  refreshToken = null;
  
  if (typeof window !== 'undefined') {
    localStorage.removeItem('accessToken');
    localStorage.removeItem('refreshToken');
    deleteCookie('accessToken');
    deleteCookie('refreshToken');
  }
}

/**
 * ãƒˆãƒ¼ã‚¯ãƒ³ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
 */
function isTokenPair(value: unknown): value is { accessToken: string; refreshToken: string } {
  return (
    isRecord(value)
    && typeof value.accessToken === 'string'
    && typeof value.refreshToken === 'string'
  );
}

async function refreshAccessToken(): Promise<string | null> {
  const token = getRefreshToken();

  try {
    const response = await fetch(`${apiBaseUrl}/auth/refresh`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: token ? JSON.stringify({ refreshToken: token }) : JSON.stringify({}),
      credentials: 'include',
    });

    if (!response.ok) {
      clearTokens();
      return null;
    }

    const data = await parseJson(response);

    if (!isApiResponse(data)) {
      throw new ApiError('ãƒˆãƒ¼ã‚¯ãƒ³ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹å½¢å¼ãŒä¸æ­£ã§ã™', response.status, data);
    }

    if (data.success && data.data && isTokenPair(data.data)) {
      setTokens(data.data.accessToken, data.data.refreshToken);
      return data.data.accessToken;
    }

    if (data.success && data.data && isRecord(data.data) && typeof data.data.access_token === 'string') {
      const access = data.data.access_token;
      const refresh = 'refresh_token' in data.data && typeof data.data.refresh_token === 'string'
        ? data.data.refresh_token
        : undefined;
      setTokens(access, refresh ?? null);
      return access;
    }

    return null;
  } catch (error) {
    console.error('Token refresh failed:', error);
    clearTokens();
    return null;
  }
}

/**
 * API ãƒªã‚¯ã‚¨ã‚¹ãƒˆå…±é€šå‡¦ç†
 */
export async function apiRequest<T = unknown>(
  url: string,
  options: RequestInit = {},
  retryOnUnauthorized = true,
): Promise<ApiResponse<T>> {
  const fullUrl = url.startsWith('http') ? url : `${apiBaseUrl}${url}`;
  const headers = new Headers(options.headers);

  if (!headers.has('Accept')) {
    headers.set('Accept', 'application/json');
  }

  if (options.body && typeof options.body === 'string' && !headers.has('Content-Type')) {
    headers.set('Content-Type', 'application/json');
  }

  // ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã‚’è¿½åŠ 
  const token = getAccessToken();
  if (token && !headers.has('Authorization')) {
    headers.set('Authorization', `Bearer ${token}`);
  }

  const method = (options.method || 'GET').toUpperCase();

  const requestInit: RequestInit = {
    ...options,
    method,
    headers,
    credentials: options.credentials ?? 'include',
  };

  try {
    let response = await fetch(fullUrl, requestInit);

    if (response.status === 401 && retryOnUnauthorized) {
      const newToken = await refreshAccessToken();
      if (newToken) {
        headers.set('Authorization', `Bearer ${newToken}`);
        response = await fetch(fullUrl, {
          ...requestInit,
          headers,
        });
      } else {
        if (typeof window !== 'undefined') {
          window.location.href = '/login';
        }
        throw new ApiError('èªè¨¼ãŒå¿…è¦ã§ã™', 401);
      }
    }

    return await handleResponse<T>(response);
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    }
    throw new ApiError(
      error instanceof Error ? error.message : 'é€šä¿¡ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ',
      0,
    );
  }
}

/**
 * ãƒ¬ã‚¹ãƒãƒ³ã‚¹å‡¦ç†
 */
async function handleResponse<T>(response: Response): Promise<ApiResponse<T>> {
  const contentType = response.headers.get('content-type');
  const isJson = contentType?.includes('application/json');

  if (!response.ok) {
    let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
    let errorData: unknown;

    if (isJson) {
      try {
        errorData = await parseJson(response);
        if (isRecord(errorData) && 'message' in errorData && typeof errorData.message === 'string') {
          errorMessage = errorData.message;
        }
      } catch {
        // JSONè§£æå¤±æ•—
      }
    }

    throw new ApiError(errorMessage, response.status, errorData);
  }

  if (isJson) {
    try {
      const data = await parseJson(response);
      if (!isApiResponse(data)) {
        throw new ApiError('APIãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®å½¢å¼ãŒä¸æ­£ã§ã™', response.status, data);
      }
      return data as ApiResponse<T>;
    } catch (error) {
      if (error instanceof ApiError) {
        throw error;
      }
      throw new ApiError(
        error instanceof Error ? error.message : 'JSONãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸ',
        response.status,
      );
    }
  }

  return {
    success: true,
    data: undefined as T,
  };
}

export async function request<M extends HttpMethod, P extends FilterPathsByMethod<M>>(
  path: P,
  method: M,
  options: ApiRequestOptions<P, M> = {},
): Promise<ApiResponse<ApiSuccessData<P, M>>> {
  const { pathParams, query, body, init, retryOnUnauthorized } = options;
  const url = buildRequestUrl<M, P>(path, { pathParams, query });
  const requestInit: RequestInit = {
    ...init,
    method: method.toUpperCase() as Uppercase<M>,
    body: body !== undefined ? JSON.stringify(body) : undefined,
  };

  return apiRequest<ApiSuccessData<P, M>>(url, requestInit, retryOnUnauthorized);
}

export async function get<P extends FilterPathsByMethod<'get'>>(
  path: P,
  options: ApiRequestOptions<P, 'get'> = {},
): Promise<ApiResponse<ApiSuccessData<P, 'get'>>> {
  return request(path, 'get', options);
}

export async function post<P extends FilterPathsByMethod<'post'>>(
  path: P,
  options: ApiRequestOptions<P, 'post'> = {},
): Promise<ApiResponse<ApiSuccessData<P, 'post'>>> {
  return request(path, 'post', options);
}

export async function put<P extends FilterPathsByMethod<'put'>>(
  path: P,
  options: ApiRequestOptions<P, 'put'> = {},
): Promise<ApiResponse<ApiSuccessData<P, 'put'>>> {
  return request(path, 'put', options);
}

export async function patch<P extends FilterPathsByMethod<'patch'>>(
  path: P,
  options: ApiRequestOptions<P, 'patch'> = {},
): Promise<ApiResponse<ApiSuccessData<P, 'patch'>>> {
  return request(path, 'patch', options);
}

export async function del<P extends FilterPathsByMethod<'delete'>>(
  path: P,
  options: ApiRequestOptions<P, 'delete'> = {},
): Promise<ApiResponse<ApiSuccessData<P, 'delete'>>> {
  return request(path, 'delete', options);
}

export type ApiClient = {
  request: typeof request;
  get: typeof get;
  post: typeof post;
  put: typeof put;
  patch: typeof patch;
  delete: typeof del;
};

export const apiClient: ApiClient = {
  request,
  get,
  post,
  put,
  patch,
  delete: del,
};
````

## File: frontend/src/lib/api/index.ts
````typescript
/**
 * API ãƒ©ã‚¤ãƒ–ãƒ©ãƒª ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
 */

// APIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
export * from './client';

// èªè¨¼ã‚¹ãƒˆã‚¢
export * from '../auth/store';

// React Query Provider
export { QueryClientProvider } from './query-client';

// APIãƒ•ãƒƒã‚¯
export * from './hooks/use-cats';
export * from './hooks/use-tags';
export * from './hooks/use-breeding';
export * from './hooks/use-care';
export * from './hooks/use-pedigrees';

// å‹å®šç¾©ï¼ˆç”Ÿæˆå¾Œã«åˆ©ç”¨å¯èƒ½ï¼‰
export type { paths, components, operations } from './generated/schema';
````

## File: frontend/src/lib/api/public-api-base-url.ts
````typescript
/**
 * å…¬é–‹å‘ã‘ API Base URL ã‚’æ­£è¦åŒ–ã—ã¦è¿”ã—ã¾ã™ã€‚
 *
 * - `NEXT_PUBLIC_API_URL` ãŒ `https://example.com` ã®å ´åˆã¯ `/api/v1` ã‚’è£œå®Œ
 * - `NEXT_PUBLIC_API_URL` ãŒ `https://example.com/api/v1` ã®å ´åˆã¯ãã®ã¾ã¾åˆ©ç”¨
 *
 * æœ¬ç•ª/é–‹ç™ºã§ã®è¨­å®šã‚†ã‚Œï¼ˆ/api/v1 ã‚’å«ã‚ã‚‹/å«ã‚ãªã„ï¼‰ã«ã‚ˆã‚‹ä¸å…·åˆã‚’é¿ã‘ã‚‹ãŸã‚ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼ã€‚
 */
export function getPublicApiBaseUrl(): string {
  const fallback = 'http://localhost:3004/api/v1';
  const raw = process.env.NEXT_PUBLIC_API_URL;

  const normalized = (raw ?? fallback).replace(/\/+$/, '');
  if (normalized.endsWith('/api/v1')) {
    return normalized;
  }

  return `${normalized}/api/v1`;
}
````

## File: frontend/src/lib/api/query-client.tsx
````typescript
/**
 * React Query (TanStack Query) è¨­å®š
 */

'use client';

import { QueryClient, QueryClientProvider as TanStackQueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import { useState, type ReactNode } from 'react';

/**
 * ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¯ã‚¨ãƒªè¨­å®š
 */
const defaultQueryClientOptions = {
  defaultOptions: {
    queries: {
      staleTime: 0, // ãƒ‡ãƒ¼ã‚¿ã‚’å¸¸ã«æ–°é®®ã¨ã¿ãªã™
      gcTime: 1000 * 60 * 10, // 10åˆ†é–“ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä¿æŒ
      refetchOnWindowFocus: false, // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒ•ã‚©ãƒ¼ã‚«ã‚¹æ™‚ã®è‡ªå‹•å†ãƒ•ã‚§ãƒƒãƒã‚’ç„¡åŠ¹åŒ–
      refetchOnReconnect: true, // å†æ¥ç¶šæ™‚ã«å†ãƒ•ã‚§ãƒƒãƒ
      retry: 1, // ã‚¨ãƒ©ãƒ¼æ™‚ã®ãƒªãƒˆãƒ©ã‚¤å›æ•°
    },
    mutations: {
      retry: 0, // ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã¯ãƒªãƒˆãƒ©ã‚¤ã—ãªã„
    },
  },
};

/**
 * QueryClientProvider ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å…¨ä½“ã‚’ãƒ©ãƒƒãƒ—ã—ã¦React Queryã‚’æœ‰åŠ¹åŒ–
 */
export function QueryClientProvider({ children }: { children: ReactNode }) {
  // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§ã®ã¿QueryClientã‚’ä½œæˆï¼ˆSSRå¯¾å¿œï¼‰
  const [queryClient] = useState(() => new QueryClient(defaultQueryClientOptions));

  return (
    <TanStackQueryClientProvider client={queryClient}>
      {children}
      {process.env.NODE_ENV === 'development' && (
        <ReactQueryDevtools initialIsOpen={false} position="bottom" />
      )}
    </TanStackQueryClientProvider>
  );
}
````

## File: frontend/src/lib/api/typesafe-client.ts
````typescript
import {
  ApiResponse,
  StaffResponseDto,
  StaffListResponseDto,
  CreateStaffRequest,
  UpdateStaffRequest,
  ShiftResponseDto,
  CreateShiftRequest,
  UpdateShiftRequest,
  CalendarShiftEvent,
} from '@/types/api.types';
import { getPublicApiBaseUrl } from '@/lib/api/public-api-base-url';

/**
 * APIãƒ™ãƒ¼ã‚¹URLï¼ˆç’°å¢ƒå¤‰æ•°ã‹ã‚‰å–å¾—ã€æ—¢ã«/api/v1ã‚’å«ã‚“ã§ã„ã‚‹æƒ³å®šï¼‰
 */
const apiBaseUrl = getPublicApiBaseUrl();

/**
 * APIã‚¨ãƒ©ãƒ¼ã‚¯ãƒ©ã‚¹
 */
export class ApiError extends Error {
  constructor(
    message: string,
    public statusCode?: number,
    public details?: unknown,
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

/**
 * å‹å®‰å…¨ãªAPIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
 */
class TypeSafeApiClient {
  private baseUrl: string;

  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
  }

  /**
   * fetchãƒ©ãƒƒãƒ‘ãƒ¼ï¼ˆå‹å®‰å…¨ï¼‰
   */
  private async request<T>(
    endpoint: string,
    options?: RequestInit,
  ): Promise<ApiResponse<T>> {
    const url = `${this.baseUrl}${endpoint}`;
    const method = (options?.method ?? 'GET').toUpperCase();
    const headers = new Headers({
      'Content-Type': 'application/json',
    });

    if (options?.headers) {
      const incomingHeaders = new Headers(options.headers);
      incomingHeaders.forEach((value, key) => headers.set(key, value));
    }

    const requestInit: RequestInit = {
      ...options,
      method,
      headers,
      credentials: options?.credentials ?? 'include',
    };

    try {
      const response = await fetch(url, requestInit);

      const data = await response.json() as ApiResponse<T>;

      if (!response.ok) {
        throw new ApiError(
          data.error || `HTTP Error ${response.status}`,
          response.status,
          data.details,
        );
      }

      if (!data.success) {
        throw new ApiError(
          data.error || 'API request failed',
          response.status,
          data.details,
        );
      }

      return data;
    } catch (error) {
      if (error instanceof ApiError) {
        throw error;
      }

      throw new ApiError(
        error instanceof Error ? error.message : 'Unknown error occurred',
      );
    }
  }

  private ensureResponseData<T>(response: ApiResponse<T>, errorMessage: string): T {
    if (response.data === undefined || response.data === null) {
      throw new ApiError(errorMessage);
    }

    return response.data;
  }

  // ==========================================
  // Staff API
  // ==========================================

  /**
   * ã‚¹ã‚¿ãƒƒãƒ•ä¸€è¦§ã‚’å–å¾—
   */
  async getStaffList(): Promise<StaffListResponseDto> {
    const response = await this.request<StaffListResponseDto>(`/staff`);
    return this.ensureResponseData(response, 'ã‚¹ã‚¿ãƒƒãƒ•ä¸€è¦§ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
  }

  /**
   * æŒ‡å®šIDã®ã‚¹ã‚¿ãƒƒãƒ•ã‚’å–å¾—
   */
  async getStaff(id: string): Promise<StaffResponseDto> {
    const response = await this.request<StaffResponseDto>(`/staff/${id}`);
    return this.ensureResponseData(response, 'ã‚¹ã‚¿ãƒƒãƒ•æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
  }

  /**
   * ã‚¹ã‚¿ãƒƒãƒ•ã‚’ä½œæˆ
   */
  async createStaff(data: CreateStaffRequest): Promise<StaffResponseDto> {
    const response = await this.request<StaffResponseDto>(`/staff`, {
      method: 'POST',
      body: JSON.stringify(data),
    });
    return this.ensureResponseData(response, 'ã‚¹ã‚¿ãƒƒãƒ•ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
  }

  /**
   * ã‚¹ã‚¿ãƒƒãƒ•ã‚’æ›´æ–°
   */
  async updateStaff(id: string, data: UpdateStaffRequest): Promise<StaffResponseDto> {
    const response = await this.request<StaffResponseDto>(`/staff/${id}`, {
      method: 'PATCH',
      body: JSON.stringify(data),
    });
    return this.ensureResponseData(response, 'ã‚¹ã‚¿ãƒƒãƒ•ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ');
  }

  /**
   * ã‚¹ã‚¿ãƒƒãƒ•ã‚’å‰Šé™¤ï¼ˆè«–ç†å‰Šé™¤ï¼‰
   */
  async deleteStaff(id: string): Promise<StaffResponseDto> {
    const response = await this.request<StaffResponseDto>(`/staff/${id}`, {
      method: 'DELETE',
    });
    return this.ensureResponseData(response, 'ã‚¹ã‚¿ãƒƒãƒ•ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ');
  }

  // ==========================================
  // Shift API
  // ==========================================

  /**
   * ã‚·ãƒ•ãƒˆä¸€è¦§ã‚’å–å¾—
   */
  async getShifts(params?: {
    startDate?: string;
    endDate?: string;
    staffId?: string;
  }): Promise<ShiftResponseDto[]> {
    const searchParams = new URLSearchParams();
    if (params?.startDate) searchParams.set('startDate', params.startDate);
    if (params?.endDate) searchParams.set('endDate', params.endDate);
    if (params?.staffId) searchParams.set('staffId', params.staffId);

    const queryString = searchParams.toString();
    const endpoint = queryString ? `/shifts?${queryString}` : '/shifts';

    const response = await this.request<ShiftResponseDto[]>(endpoint);
    return this.ensureResponseData(response, 'ã‚·ãƒ•ãƒˆä¸€è¦§ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
  }

  /**
   * ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ç”¨ã‚·ãƒ•ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
   */
  async getCalendarShifts(params: {
    startDate: string;
    endDate: string;
    staffId?: string;
  }): Promise<CalendarShiftEvent[]> {
    const searchParams = new URLSearchParams({
      startDate: params.startDate,
      endDate: params.endDate,
    });
    if (params.staffId) {
      searchParams.set('staffId', params.staffId);
    }

    const response = await this.request<CalendarShiftEvent[]>(
      `/shifts/calendar?${searchParams.toString()}`,
    );
    return this.ensureResponseData(response, 'ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚·ãƒ•ãƒˆã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
  }

  /**
   * æŒ‡å®šIDã®ã‚·ãƒ•ãƒˆã‚’å–å¾—
   */
  async getShift(id: string): Promise<ShiftResponseDto> {
    const response = await this.request<ShiftResponseDto>(`/shifts/${id}`);
    return this.ensureResponseData(response, 'ã‚·ãƒ•ãƒˆæƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
  }

  /**
   * ã‚·ãƒ•ãƒˆã‚’ä½œæˆ
   */
  async createShift(data: CreateShiftRequest): Promise<ShiftResponseDto> {
    const response = await this.request<ShiftResponseDto>(`/shifts`, {
      method: 'POST',
      body: JSON.stringify(data),
    });
    return this.ensureResponseData(response, 'ã‚·ãƒ•ãƒˆã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
  }

  /**
   * ã‚·ãƒ•ãƒˆã‚’æ›´æ–°
   */
  async updateShift(id: string, data: UpdateShiftRequest): Promise<ShiftResponseDto> {
    const response = await this.request<ShiftResponseDto>(`/shifts/${id}`, {
      method: 'PATCH',
      body: JSON.stringify(data),
    });
    return this.ensureResponseData(response, 'ã‚·ãƒ•ãƒˆã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ');
  }

  /**
   * ã‚·ãƒ•ãƒˆã‚’å‰Šé™¤
   */
  async deleteShift(id: string): Promise<void> {
    await this.request<{ id: string }>(`/shifts/${id}`, {
      method: 'DELETE',
    });
  }
}

/**
 * å‹å®‰å…¨ãªAPIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
 */
export const apiClient = new TypeSafeApiClient(apiBaseUrl);
````

## File: frontend/src/lib/auth/routes.ts
````typescript
export const AUTH_ROUTES = ['/login', '/register', '/forgot-password', '/reset-password'] as const;

export const PUBLIC_ROUTES = [...AUTH_ROUTES] as const;

function matchesRoute(pathname: string, route: string): boolean {
  if (route === '/') {
    return pathname === '/';
  }

  return pathname === route || pathname.startsWith(`${route}/`);
}

export function isAuthRoute(pathname: string): boolean {
  return AUTH_ROUTES.some((route) => matchesRoute(pathname, route));
}

export function isPublicRoute(pathname: string): boolean {
  return PUBLIC_ROUTES.some((route) => matchesRoute(pathname, route));
}

export function isProtectedRoute(pathname: string): boolean {
  return !isPublicRoute(pathname);
}
````

## File: frontend/src/lib/auth/store.ts
````typescript
import { create } from 'zustand';
import { apiClient, clearTokens, setTokens } from '../api/client';

export interface AuthUser {
  id: string;
  email: string;
  role: string;
  firstName?: string | null;
  lastName?: string | null;
  tenantId?: string | null;
}

export interface LoginRequest {
  email: string;
  password: string;
}

interface AuthState {
  user: AuthUser | null;
  accessToken: string | null;
  refreshToken: string | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  initialized: boolean;
  error: string | null;
}

interface AuthActions {
  login: (credentials: LoginRequest) => Promise<void>;
  logout: () => Promise<void>;
  bootstrap: (payload: unknown) => void;
  updateUser: (updates: Partial<AuthUser>) => void;
  setError: (message: string | null) => void;
  clearError: () => void;
}

type AuthStore = AuthState & AuthActions;

type RawAuthPayload = {
  accessToken?: unknown;
  access_token?: unknown;
  refreshToken?: unknown;
  refresh_token?: unknown;
  user?: unknown;
};

function isRecord(value: unknown): value is Record<string, unknown> {
  return typeof value === 'object' && value !== null;
}

function toAuthUser(value: unknown): AuthUser | null {
  if (!isRecord(value)) {
    return null;
  }

  const idCandidate = typeof value.id === 'string' ? value.id : typeof value.userId === 'string' ? value.userId : null;
  const emailCandidate = typeof value.email === 'string' ? value.email : null;
  const roleCandidate = typeof value.role === 'string' ? value.role : null;

  if (!idCandidate || !emailCandidate || !roleCandidate) {
    return null;
  }

  const firstName = 'firstName' in value && typeof value.firstName === 'string' ? value.firstName : null;
  const lastName = 'lastName' in value && typeof value.lastName === 'string' ? value.lastName : null;
  const tenantId = 'tenantId' in value && typeof value.tenantId === 'string' ? value.tenantId : null;

  return {
    id: idCandidate,
    email: emailCandidate,
    role: roleCandidate,
    firstName,
    lastName,
    tenantId,
  };
}

function extractAuthPayload(value: unknown) {
  if (!isRecord(value)) {
    return null;
  }

  const payload = value as RawAuthPayload;
  const accessToken = typeof payload.accessToken === 'string'
    ? payload.accessToken
    : typeof payload.access_token === 'string'
      ? payload.access_token
      : null;

  if (!accessToken) {
    return null;
  }

  const refreshToken = typeof payload.refreshToken === 'string'
    ? payload.refreshToken
    : typeof payload.refresh_token === 'string'
      ? payload.refresh_token
      : null;

  const user = toAuthUser(payload.user ?? null);

  return {
    accessToken,
    refreshToken,
    user,
  };
}

export const useAuthStore = create<AuthStore>((set) => ({
  user: null,
  accessToken: null,
  refreshToken: null,
  isAuthenticated: false,
  isLoading: false,
  initialized: false,
  error: null,

  login: async (credentials) => {
    set({ isLoading: true, error: null });

    try {
      const response = await apiClient.post('/auth/login', {
        body: credentials,
        retryOnUnauthorized: false,
      });

      if (!response.success) {
        throw new Error(response.error || response.message || 'ãƒ­ã‚°ã‚¤ãƒ³ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }

      const payload = extractAuthPayload(response.data);
      if (!payload || !payload.user) {
        throw new Error('ãƒ­ã‚°ã‚¤ãƒ³ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“');
      }

      setTokens(payload.accessToken, payload.refreshToken ?? null);

      set({
        user: payload.user,
        accessToken: payload.accessToken,
        refreshToken: payload.refreshToken ?? null,
        isAuthenticated: true,
        isLoading: false,
        initialized: true,
        error: null,
      });
    } catch (error) {
      const message = error instanceof Error ? error.message : 'ãƒ­ã‚°ã‚¤ãƒ³ã«å¤±æ•—ã—ã¾ã—ãŸ';
      clearTokens();
      set({
        user: null,
        accessToken: null,
        refreshToken: null,
        isAuthenticated: false,
        isLoading: false,
        initialized: true,
        error: message,
      });
      throw error;
    }
  },

  logout: async () => {
    set({ isLoading: true });
    try {
      await apiClient.post('/auth/logout', {
        retryOnUnauthorized: false,
      });
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      clearTokens();
      set({
        user: null,
        accessToken: null,
        refreshToken: null,
        isAuthenticated: false,
        isLoading: false,
        initialized: true,
        error: null,
      });
    }
  },

  bootstrap: (payload) => {
    const data = extractAuthPayload(payload ?? null);

    if (data) {
      setTokens(data.accessToken, data.refreshToken ?? null);
    }

    set({
      user: data?.user ?? null,
      accessToken: data?.accessToken ?? null,
      refreshToken: data?.refreshToken ?? null,
      isAuthenticated: !!(data?.accessToken && data?.user),
      isLoading: false,
      initialized: true,
      error: null,
    });
  },

  updateUser: (updates) => set((state) => ({
    user: state.user ? { ...state.user, ...updates } : null,
  })),

  setError: (message) => set({ error: message ?? null }),

  clearError: () => set({ error: null }),
}));

export function useAuth() {
  const user = useAuthStore((state) => state.user);
  const accessToken = useAuthStore((state) => state.accessToken);
  const refreshToken = useAuthStore((state) => state.refreshToken);
  const isAuthenticated = useAuthStore((state) => state.isAuthenticated);
  const isLoading = useAuthStore((state) => state.isLoading);
  const initialized = useAuthStore((state) => state.initialized);
  const error = useAuthStore((state) => state.error);
  const login = useAuthStore((state) => state.login);
  const logout = useAuthStore((state) => state.logout);
  const updateUser = useAuthStore((state) => state.updateUser);
  const clearError = useAuthStore((state) => state.clearError);

  return {
    user,
    accessToken,
    refreshToken,
    isAuthenticated,
    isLoading,
    initialized,
    error,
    login,
    logout,
    updateUser,
    clearError,
  };
}
````

## File: frontend/src/lib/auth/useBootstrapAuth.ts
````typescript
import { useEffect } from 'react';
import { useAuthStore } from './store';
import { getPublicApiBaseUrl } from '@/lib/api/public-api-base-url';

function isRecord(value: unknown): value is Record<string, unknown> {
  return typeof value === 'object' && value !== null;
}

const apiBaseUrl = getPublicApiBaseUrl();

export function useBootstrapAuth() {
  const bootstrap = useAuthStore((state) => state.bootstrap);

  useEffect(() => {
    let cancelled = false;

    async function run() {
      try {
        const res = await fetch(`${apiBaseUrl}/auth/refresh`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({}),
          credentials: 'include',
        });

        if (!res.ok) {
          throw new Error('refresh failed');
        }

        const json: unknown = await res.json();
        const data = isRecord(json) && 'data' in json ? (json as Record<string, unknown>).data : null;

        if (!cancelled) {
          bootstrap(data ?? null);
        }
      } catch {
        if (!cancelled) {
          bootstrap(null);
        }
      }
    }

    run();

    return () => {
      cancelled = true;
    };
  }, [bootstrap]);
}
````

## File: frontend/src/lib/contexts/page-header-context.tsx
````typescript
'use client';

import { createContext, useContext, useState, ReactNode, useCallback } from 'react';

interface PageHeaderContextType {
  pageTitle: string | null;
  pageActions: ReactNode | null;
  setPageTitle: (title: string | null) => void;
  setPageActions: (actions: ReactNode | null) => void;
  setPageHeader: (title: string | null, actions?: ReactNode) => void;
}

const PageHeaderContext = createContext<PageHeaderContextType | undefined>(undefined);

export function PageHeaderProvider({ children }: { children: ReactNode }) {
  const [pageTitle, setPageTitle] = useState<string | null>(null);
  const [pageActions, setPageActions] = useState<ReactNode | null>(null);

  const setPageHeader = useCallback((title: string | null, actions?: ReactNode) => {
    setPageTitle(title);
    setPageActions(actions || null);
  }, []);

  return (
    <PageHeaderContext.Provider value={{ pageTitle, pageActions, setPageTitle, setPageActions, setPageHeader }}>
      {children}
    </PageHeaderContext.Provider>
  );
}

export function usePageHeader() {
  const context = useContext(PageHeaderContext);
  if (context === undefined) {
    throw new Error('usePageHeader must be used within a PageHeaderProvider');
  }
  return context;
}
````

## File: frontend/src/lib/hooks/use-bottom-nav-settings.ts
````typescript
'use client';

import { useEffect, useState } from 'react';
import type { Icon } from '@tabler/icons-react';

const STORAGE_KEY = 'bottom-nav-settings';

export interface BottomNavItem {
  id: string;
  label: string;
  href: string;
  icon: Icon;
  visible: boolean;
}

/**
 * ãƒœãƒˆãƒ ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®šã‚’ç®¡ç†ã™ã‚‹ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯
 * localStorageã«ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è¨­å®šã‚’ä¿å­˜
 */
export function useBottomNavSettings(defaultItems: Omit<BottomNavItem, 'visible'>[]) {
  const [items, setItems] = useState<BottomNavItem[]>(() => {
    // åˆæœŸçŠ¶æ…‹ã¯å…¨ã¦è¡¨ç¤º
    return defaultItems.map(item => ({ ...item, visible: true }));
  });
  const [isLoading, setIsLoading] = useState(true);
  const [hasChanges, setHasChanges] = useState(false);

  // localStorageã‹ã‚‰è¨­å®šã‚’èª­ã¿è¾¼ã‚€ï¼ˆåˆå›ã®ã¿ï¼‰
  useEffect(() => {
    try {
      const stored = localStorage.getItem(STORAGE_KEY);
      if (stored) {
        const savedSettings = JSON.parse(stored) as Record<string, boolean>;
        setItems(defaultItems.map(item => ({
          ...item,
          visible: savedSettings[item.id] ?? true,
        })));
      }
    } catch (error) {
      console.error('Failed to load footer nav settings:', error);
    } finally {
      setIsLoading(false);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); // åˆå›ã®ã¿å®Ÿè¡Œ

  // è¨­å®šã‚’ä¿å­˜
  const saveSettings = () => {
    try {
      const settings = items.reduce((acc, item) => {
        acc[item.id] = item.visible;
        return acc;
      }, {} as Record<string, boolean>);
      localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
      setHasChanges(false);
      // ä¿å­˜å®Œäº†ã‚’é€šçŸ¥
      return true;
    } catch (error) {
      console.error('Failed to save footer nav settings:', error);
      return false;
    }
  };

  // é …ç›®ã®è¡¨ç¤º/éè¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆ
  const toggleItem = (id: string) => {
    setItems(prev => prev.map(item =>
      item.id === id ? { ...item, visible: !item.visible } : item
    ));
    setHasChanges(true);
  };

  // å…¨ã¦è¡¨ç¤º
  const showAll = () => {
    setItems(prev => prev.map(item => ({ ...item, visible: true })));
    setHasChanges(true);
  };

  // å…¨ã¦éè¡¨ç¤º
  const hideAll = () => {
    setItems(prev => prev.map(item => ({ ...item, visible: false })));
    setHasChanges(true);
  };

  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«æˆ»ã™
  const resetToDefault = () => {
    localStorage.removeItem(STORAGE_KEY);
    setItems(defaultItems.map(item => ({ ...item, visible: true })));
    setHasChanges(false);
  };

  return {
    items,
    isLoading,
    hasChanges,
    toggleItem,
    showAll,
    hideAll,
    resetToDefault,
    saveSettings,
    visibleItems: items.filter(item => item.visible),
  };
}
````

## File: frontend/src/lib/hooks/use-selection-history.ts
````typescript
'use client';

import { useLocalStorage } from '@mantine/hooks';
import { useCallback } from 'react';
import type { MasterOption } from '@/lib/master-data/master-options';

const HISTORY_LIMIT = 10;

export type SelectionHistoryDomain = 'breed' | 'coat-color';

interface StoredHistoryItem extends MasterOption {
  updatedAt: number;
}

export function useSelectionHistory(domain: SelectionHistoryDomain) {
  const storageKey = `master-selection-history:${domain}`;
  const [history, setHistory] = useLocalStorage<StoredHistoryItem[]>({
    key: storageKey,
    defaultValue: [],
    getInitialValueInEffect: true,
  });

  const recordSelection = useCallback((item: MasterOption | undefined) => {
    if (!item) {
      return;
    }

    setHistory((prev) => {
      const filtered = prev.filter((entry) => entry.value !== item.value);
      const next: StoredHistoryItem[] = [
        {
          value: item.value,
          label: item.label,
          code: item.code,
          updatedAt: Date.now(),
        },
        ...filtered,
      ];
      return next.slice(0, HISTORY_LIMIT);
    });
  }, [setHistory]);

  const clearHistory = useCallback(() => {
    setHistory([]);
  }, [setHistory]);

  return {
    history,
    recordSelection,
    clearHistory,
  };
}
````

## File: frontend/src/lib/master-data/constants.ts
````typescript

````

## File: frontend/src/lib/master-data/master-options.ts
````typescript
import type { MasterDataItem } from '@/lib/api/hooks/use-master-data';

export interface MasterOption {
  value: string;
  label: string;
  code?: number;
}

export type MasterDisplayMap = Map<number, string>;

export function createDisplayNameMap(items?: MasterDataItem[] | null): MasterDisplayMap {
  if (!items || items.length === 0) {
    return new Map();
  }

  return items.reduce<MasterDisplayMap>((acc, item) => {
    const baseLabel = (item.displayName ?? item.name ?? '').trim();
    acc.set(item.code, baseLabel);
    return acc;
  }, new Map());
}

interface HasDataProperty<T> {
  data?: ReadonlyArray<T> | null;
}

interface OptionSource {
  id: string;
  name: string;
  code?: number | null;
}

type OptionRecords<T extends OptionSource> =
  | ReadonlyArray<T>
  | HasDataProperty<T>
  | null
  | undefined;

export function buildMasterOptions<T extends OptionSource>(
  records: OptionRecords<T>,
  displayMap?: MasterDisplayMap,
): MasterOption[] {
  const normalized = resolveRecords(records).filter((record) => !isPlaceholderRecord(record));
  if (normalized.length === 0) {
    return [];
  }

  return normalized.map((record) => ({
    value: record.id,
    code: typeof record.code === 'number' ? record.code : undefined,
    label: resolveLabel(record, displayMap),
  }));
}

function isPlaceholderRecord(record: OptionSource): boolean {
  const noName = !record.name || record.name.trim().length === 0;
  return record.code === 0 && noName;
}

function resolveRecords<T extends OptionSource>(records: OptionRecords<T>): ReadonlyArray<T> {
  if (!records) {
    return [];
  }

  if (isOptionArray(records)) {
    return records;
  }

  if (hasArrayData(records)) {
    return records.data;
  }

  return [];
}

function hasDataProperty<T extends OptionSource>(value: OptionRecords<T>): value is HasDataProperty<T> {
  return typeof value === 'object' && value !== null && 'data' in value;
}

function isOptionArray<T extends OptionSource>(value: OptionRecords<T>): value is ReadonlyArray<T> {
  return Array.isArray(value);
}

function hasArrayData<T extends OptionSource>(value: OptionRecords<T>): value is HasDataProperty<T> & { data: ReadonlyArray<T> } {
  return hasDataProperty(value) && Array.isArray(value.data);
}

function resolveLabel(record: OptionSource, displayMap?: MasterDisplayMap): string {
  if (typeof record.code === 'number') {
    const display = displayMap?.get(record.code);
    if (display) {
      return display;
    }
    const baseName = record.name?.trim() ?? '';
    if (baseName) {
      return baseName;
    }
    return String(record.code);
  }

  return record.name;
}
````

## File: frontend/src/lib/schemas/cat.ts
````typescript
import { z } from 'zod';
import { optionalTrimmedString } from './common';

const genderErrorMap = () => ({ message: 'æ€§åˆ¥ã‚’é¸æŠã—ã¦ãã ã•ã„' });

export const catFormSchema = z.object({
  name: z.string().min(1, 'åå‰ã¯å¿…é ˆã§ã™'),
  gender: z.enum(['MALE', 'FEMALE', 'NEUTER', 'SPAY'], {
    errorMap: genderErrorMap,
  }),
  birthDate: z
    .string()
    .min(1, 'ç”Ÿå¹´æœˆæ—¥ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„')
    .regex(/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/u, 'ç”Ÿå¹´æœˆæ—¥ã¯YYYY-MM-DDå½¢å¼ã§å…¥åŠ›ã—ã¦ãã ã•ã„'),
  breedId: optionalTrimmedString,
  coatColorId: optionalTrimmedString,
  microchipNumber: optionalTrimmedString,
  registrationId: optionalTrimmedString,
  description: optionalTrimmedString,
  isInHouse: z.boolean().default(true),
  tagIds: z.array(z.string()).default([]),
});

export type CatFormSchema = z.infer<typeof catFormSchema>;
````

## File: frontend/src/lib/schemas/common.ts
````typescript
import { z } from 'zod';

/**
 * ç©ºæ–‡å­—åˆ—ã‚’ undefined ã«æ­£è¦åŒ–ã™ã‚‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³æ–‡å­—åˆ—
 */
export const optionalTrimmedString = z
  .string()
  .optional()
  .transform((value) => {
    if (!value) {
      return undefined;
    }
    const trimmed = value.trim();
    return trimmed.length > 0 ? trimmed : undefined;
  });
````

## File: frontend/src/lib/schemas/index.ts
````typescript
export * from './common';
export * from './cat';
````

## File: frontend/src/lib/storage/dashboard-settings.ts
````typescript
import { DashboardCardConfig } from '@/components/dashboard/DashboardCardSettings';

const STORAGE_KEY = 'dashboard_card_settings';
const DISPLAY_MODE_STORAGE_KEY = 'home_display_mode';

export interface DashboardSettings {
  cards: {
    id: string;
    visible: boolean;
    order: number;
  }[];
  version: number;
}

/**
 * ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰è¨­å®šã‚’LocalStorageã‹ã‚‰èª­ã¿è¾¼ã‚€
 */
export function loadDashboardSettings(): DashboardSettings | null {
  if (typeof window === 'undefined') return null;
  
  try {
    const stored = localStorage.getItem(STORAGE_KEY);
    if (!stored) return null;
    
    const settings = JSON.parse(stored) as DashboardSettings;
    return settings;
  } catch (error) {
    console.error('Failed to load dashboard settings:', error);
    return null;
  }
}

/**
 * ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰è¨­å®šã‚’LocalStorageã«ä¿å­˜
 */
export function saveDashboardSettings(cards: DashboardCardConfig[]): void {
  if (typeof window === 'undefined') return;
  
  try {
    const settings: DashboardSettings = {
      cards: cards.map((card) => ({
        id: card.id,
        visible: card.visible,
        order: card.order,
      })),
      version: 1,
    };
    
    localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
  } catch (error) {
    console.error('Failed to save dashboard settings:', error);
  }
}

/**
 * ä¿å­˜ã•ã‚ŒãŸè¨­å®šã‚’ã‚«ãƒ¼ãƒ‰ãƒªã‚¹ãƒˆã«é©ç”¨
 */
export function applyDashboardSettings(
  defaultCards: DashboardCardConfig[],
  settings: DashboardSettings | null
): DashboardCardConfig[] {
  if (!settings) {
    // è¨­å®šãŒãªã„å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’è¿”ã™
    return defaultCards.map((card, index) => ({
      ...card,
      visible: true,
      order: index,
    }));
  }
  
  // è¨­å®šã‚’é©ç”¨
  const cardsMap = new Map(defaultCards.map((card) => [card.id, card]));
  
  // è¨­å®šã«åŸºã¥ã„ã¦ã‚«ãƒ¼ãƒ‰ã‚’å†æ§‹ç¯‰
  const result: DashboardCardConfig[] = [];
  
  // ä¿å­˜ã•ã‚Œã¦ã„ã‚‹é †åºã§ã‚«ãƒ¼ãƒ‰ã‚’è¿½åŠ 
  for (const savedCard of settings.cards) {
    const defaultCard = cardsMap.get(savedCard.id);
    if (defaultCard) {
      result.push({
        ...defaultCard,
        visible: savedCard.visible,
        order: savedCard.order,
      });
      cardsMap.delete(savedCard.id);
    }
  }
  
  // æ–°ã—ãè¿½åŠ ã•ã‚ŒãŸã‚«ãƒ¼ãƒ‰ï¼ˆè¨­å®šã«ãªã„ã‚«ãƒ¼ãƒ‰ï¼‰ã‚’æœ«å°¾ã«è¿½åŠ 
  for (const [, card] of cardsMap) {
    result.push({
      ...card,
      visible: true,
      order: result.length,
    });
  }
  
  // é †åºã§ã‚½ãƒ¼ãƒˆ
  return result.sort((a, b) => a.order - b.order);
}

/**
 * ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰è¨­å®šã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆå‰Šé™¤ï¼‰
 */
export function resetDashboardSettings(): void {
  if (typeof window === 'undefined') return;
  
  try {
    localStorage.removeItem(STORAGE_KEY);
  } catch (error) {
    console.error('Failed to reset dashboard settings:', error);
  }
}

// ============================================
// ãƒ›ãƒ¼ãƒ ç”»é¢è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰è¨­å®š
// ============================================

/** ãƒ›ãƒ¼ãƒ ç”»é¢ã®è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ */
export type HomeDisplayMode = 'auto' | 'card' | 'dial';

/** è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ã®ãƒ©ãƒ™ãƒ«ï¼ˆæ—¥æœ¬èªï¼‰ */
export const HOME_DISPLAY_MODE_LABELS: Record<HomeDisplayMode, string> = {
  auto: 'è‡ªå‹•åˆ‡ã‚Šæ›¿ãˆ',
  card: 'ã‚«ãƒ¼ãƒ‰è¡¨ç¤º',
  dial: 'ãƒ€ã‚¤ã‚¢ãƒ«è¡¨ç¤º',
};

/**
 * ãƒ›ãƒ¼ãƒ ç”»é¢ã®è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ã‚’LocalStorageã‹ã‚‰èª­ã¿è¾¼ã‚€
 */
export function loadHomeDisplayMode(): HomeDisplayMode {
  if (typeof window === 'undefined') return 'auto';
  
  try {
    const stored = localStorage.getItem(DISPLAY_MODE_STORAGE_KEY);
    if (!stored) return 'auto';
    
    if (stored === 'auto' || stored === 'card' || stored === 'dial') {
      return stored;
    }
    return 'auto';
  } catch (error) {
    console.error('Failed to load home display mode:', error);
    return 'auto';
  }
}

/**
 * ãƒ›ãƒ¼ãƒ ç”»é¢ã®è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ã‚’LocalStorageã«ä¿å­˜
 */
export function saveHomeDisplayMode(mode: HomeDisplayMode): void {
  if (typeof window === 'undefined') return;
  
  try {
    localStorage.setItem(DISPLAY_MODE_STORAGE_KEY, mode);
  } catch (error) {
    console.error('Failed to save home display mode:', error);
  }
}

// ============================================
// ãƒ€ã‚¤ã‚¢ãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼è¨­å®šï¼ˆãƒ¢ãƒã‚¤ãƒ«ç”¨ï¼‰
// ============================================

const DIAL_STORAGE_KEY = 'dial_menu_settings';
const DIAL_SIZE_STORAGE_KEY = 'dial_size_preset';

/** ãƒ€ã‚¤ã‚¢ãƒ«ã‚µã‚¤ã‚ºãƒ—ãƒªã‚»ãƒƒãƒˆã®ç¨®é¡ */
export type DialSizePreset = 'small' | 'medium' | 'large';

/** ã‚µã‚¤ã‚ºãƒ—ãƒªã‚»ãƒƒãƒˆã®å®šç¾© */
export interface DialSizeConfig {
  dialSize: number;        // ãƒ€ã‚¤ã‚¢ãƒ«å…¨ä½“ã®ã‚µã‚¤ã‚º
  centerSize: number;      // ä¸­å¤®ã®ç©´ã®ã‚µã‚¤ã‚º
  iconButtonSize: number;  // ã‚¢ã‚¤ã‚³ãƒ³ãƒœã‚¿ãƒ³ã‚µã‚¤ã‚º
  iconOrbitRadius: number; // ã‚¢ã‚¤ã‚³ãƒ³é…ç½®ã®å††è»Œé“åŠå¾„
  subRadius: number;       // ã‚µãƒ–ã‚¢ã‚¯ã‚·ãƒ§ãƒ³é…ç½®åŠå¾„
  iconSize: number;        // ã‚¢ã‚¤ã‚³ãƒ³è‡ªä½“ã®ã‚µã‚¤ã‚º
}

/** ã‚µã‚¤ã‚ºãƒ—ãƒªã‚»ãƒƒãƒˆã®ãƒãƒƒãƒ— */
export const DIAL_SIZE_PRESETS: Record<DialSizePreset, DialSizeConfig> = {
  small: {
    dialSize: 220,
    centerSize: 64,
    iconButtonSize: 40,
    iconOrbitRadius: 68,
    subRadius: 98,
    iconSize: 24,
  },
  medium: {
    dialSize: 260,
    centerSize: 76,
    iconButtonSize: 48,
    iconOrbitRadius: 80,
    subRadius: 115,
    iconSize: 28,
  },
  large: {
    dialSize: 320,
    centerSize: 92,
    iconButtonSize: 58,
    iconOrbitRadius: 100,
    subRadius: 140,
    iconSize: 34,
  },
};

/** ãƒ—ãƒªã‚»ãƒƒãƒˆã®ãƒ©ãƒ™ãƒ«ï¼ˆæ—¥æœ¬èªï¼‰ */
export const DIAL_SIZE_PRESET_LABELS: Record<DialSizePreset, string> = {
  small: 'å°',
  medium: 'ä¸­',
  large: 'å¤§',
};

/**
 * ãƒ€ã‚¤ã‚¢ãƒ«ã‚µã‚¤ã‚ºãƒ—ãƒªã‚»ãƒƒãƒˆã‚’LocalStorageã‹ã‚‰èª­ã¿è¾¼ã‚€
 */
export function loadDialSizePreset(): DialSizePreset {
  if (typeof window === 'undefined') return 'medium';
  
  try {
    const stored = localStorage.getItem(DIAL_SIZE_STORAGE_KEY);
    if (!stored) return 'medium';
    
    if (stored === 'small' || stored === 'medium' || stored === 'large') {
      return stored;
    }
    return 'medium';
  } catch (error) {
    console.error('Failed to load dial size preset:', error);
    return 'medium';
  }
}

/**
 * ãƒ€ã‚¤ã‚¢ãƒ«ã‚µã‚¤ã‚ºãƒ—ãƒªã‚»ãƒƒãƒˆã‚’LocalStorageã«ä¿å­˜
 */
export function saveDialSizePreset(preset: DialSizePreset): void {
  if (typeof window === 'undefined') return;
  
  try {
    localStorage.setItem(DIAL_SIZE_STORAGE_KEY, preset);
  } catch (error) {
    console.error('Failed to save dial size preset:', error);
  }
}

/**
 * ãƒ—ãƒªã‚»ãƒƒãƒˆã‹ã‚‰ã‚µã‚¤ã‚ºè¨­å®šã‚’å–å¾—
 */
export function getDialSizeConfig(preset: DialSizePreset): DialSizeConfig {
  return DIAL_SIZE_PRESETS[preset];
}

export interface DialMenuSettings {
  items: {
    id: string;
    visible: boolean;
    order: number;
  }[];
  version: number;
}

/**
 * ãƒ€ã‚¤ã‚¢ãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼è¨­å®šã‚’LocalStorageã‹ã‚‰èª­ã¿è¾¼ã‚€
 */
export function loadDialMenuSettings(): DialMenuSettings | null {
  if (typeof window === 'undefined') return null;
  
  try {
    const stored = localStorage.getItem(DIAL_STORAGE_KEY);
    if (!stored) return null;
    
    const settings = JSON.parse(stored) as DialMenuSettings;
    return settings;
  } catch (error) {
    console.error('Failed to load dial menu settings:', error);
    return null;
  }
}

/**
 * ãƒ€ã‚¤ã‚¢ãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼è¨­å®šã‚’LocalStorageã«ä¿å­˜
 */
export function saveDialMenuSettings(items: { id: string; visible: boolean; order: number }[]): void {
  if (typeof window === 'undefined') return;
  
  try {
    const settings: DialMenuSettings = {
      items: items.map((item) => ({
        id: item.id,
        visible: item.visible,
        order: item.order,
      })),
      version: 1,
    };
    
    localStorage.setItem(DIAL_STORAGE_KEY, JSON.stringify(settings));
  } catch (error) {
    console.error('Failed to save dial menu settings:', error);
  }
}

/**
 * ä¿å­˜ã•ã‚ŒãŸè¨­å®šã‚’ãƒ€ã‚¤ã‚¢ãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›®ã«é©ç”¨
 */
export function applyDialMenuSettings<T extends { id: string; visible?: boolean; order?: number }>(
  defaultItems: T[],
  settings: DialMenuSettings | null
): (T & { visible: boolean; order: number })[] {
  if (!settings) {
    // è¨­å®šãŒãªã„å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼ˆæœ€åˆã®8é …ç›®ã®ã¿è¡¨ç¤ºï¼‰ã‚’è¿”ã™
    return defaultItems.map((item, index) => ({
      ...item,
      visible: index < 8,
      order: index,
    }));
  }
  
  // è¨­å®šã‚’é©ç”¨
  const itemsMap = new Map(defaultItems.map((item) => [item.id, item]));
  
  // è¨­å®šã«åŸºã¥ã„ã¦ã‚¢ã‚¤ãƒ†ãƒ ã‚’å†æ§‹ç¯‰
  const result: (T & { visible: boolean; order: number })[] = [];
  
  // ä¿å­˜ã•ã‚Œã¦ã„ã‚‹é †åºã§ã‚¢ã‚¤ãƒ†ãƒ ã‚’è¿½åŠ 
  for (const savedItem of settings.items) {
    const defaultItem = itemsMap.get(savedItem.id);
    if (defaultItem) {
      result.push({
        ...defaultItem,
        visible: savedItem.visible,
        order: savedItem.order,
      });
      itemsMap.delete(savedItem.id);
    }
  }
  
  // æ–°ã—ãè¿½åŠ ã•ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ ï¼ˆè¨­å®šã«ãªã„ã‚¢ã‚¤ãƒ†ãƒ ï¼‰ã‚’æœ«å°¾ã«è¿½åŠ ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆéè¡¨ç¤ºï¼‰
  for (const [, item] of itemsMap) {
    result.push({
      ...item,
      visible: false,
      order: result.length,
    });
  }
  
  // é †åºã§ã‚½ãƒ¼ãƒˆ
  return result.sort((a, b) => a.order - b.order);
}
````

## File: frontend/src/lib/utils/image-resizer.ts
````typescript
/**
 * ç”»åƒãƒªã‚µã‚¤ã‚ºè¨­å®š
 */
export interface ImageResizeOptions {
  /** æœ€å¤§å¹…ï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰ */
  maxWidth?: number;
  /** æœ€å¤§é«˜ã•ï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰ */
  maxHeight?: number;
  /** åœ§ç¸®å“è³ªï¼ˆ0-1ï¼‰ */
  quality?: number;
  /** å‡ºåŠ›ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ */
  format?: 'image/jpeg' | 'image/png' | 'image/webp';
}

const DEFAULT_OPTIONS: Required<ImageResizeOptions> = {
  maxWidth: 1200,
  maxHeight: 1200,
  quality: 0.85,
  format: 'image/jpeg',
};

/**
 * ç”»åƒã‚’ãƒªã‚µã‚¤ã‚ºã—ã¦Blobã‚’è¿”ã™
 * - ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒ
 * - 1200px / 85%å“è³ªã§æœ€é©åŒ–
 *
 * @param file - ãƒªã‚µã‚¤ã‚ºå¯¾è±¡ã®ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«
 * @param options - ãƒªã‚µã‚¤ã‚ºã‚ªãƒ—ã‚·ãƒ§ãƒ³
 * @returns ãƒªã‚µã‚¤ã‚ºå¾Œã® Blob
 */
export async function resizeImage(
  file: File,
  options: ImageResizeOptions = {}
): Promise<Blob> {
  const opts = { ...DEFAULT_OPTIONS, ...options };

  return new Promise((resolve, reject) => {
    const img = new Image();

    img.onload = () => {
      URL.revokeObjectURL(img.src);

      let { width, height } = img;

      // ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒã—ã¦ãƒªã‚µã‚¤ã‚º
      if (width > opts.maxWidth || height > opts.maxHeight) {
        const ratio = Math.min(opts.maxWidth / width, opts.maxHeight / height);
        width = Math.round(width * ratio);
        height = Math.round(height * ratio);
      }

      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;

      const ctx = canvas.getContext('2d');
      if (!ctx) {
        reject(new Error('Canvas context ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ'));
        return;
      }

      // é«˜å“è³ªãƒªã‚µã‚¤ã‚º
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(img, 0, 0, width, height);

      canvas.toBlob(
        (blob) => {
          if (blob) {
            resolve(blob);
          } else {
            reject(new Error('ç”»åƒã®å¤‰æ›ã«å¤±æ•—ã—ã¾ã—ãŸ'));
          }
        },
        opts.format,
        opts.quality
      );
    };

    img.onerror = () => {
      URL.revokeObjectURL(img.src);
      reject(new Error('ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ'));
    };

    img.src = URL.createObjectURL(file);
  });
}

/**
 * ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã‚’äººé–“ãŒèª­ã‚ã‚‹å½¢å¼ã«å¤‰æ›
 *
 * @param bytes - ãƒã‚¤ãƒˆæ•°
 * @returns ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ¸ˆã¿ã‚µã‚¤ã‚ºæ–‡å­—åˆ—
 */
export function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(1))} ${sizes[i]}`;
}

/**
 * ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‹ã©ã†ã‹ã‚’åˆ¤å®š
 *
 * @param file - åˆ¤å®šå¯¾è±¡ã®ãƒ•ã‚¡ã‚¤ãƒ«
 * @returns å¯¾å¿œå½¢å¼ã®ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆ true
 */
export function isImageFile(file: File): boolean {
  return ['image/jpeg', 'image/png', 'image/webp'].includes(file.type);
}

/**
 * å¯¾å¿œã—ã¦ã„ã‚‹ç”»åƒå½¢å¼
 */
export const SUPPORTED_IMAGE_TYPES = ['image/jpeg', 'image/png', 'image/webp'] as const;

/**
 * æœ€å¤§ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºï¼ˆ10MBï¼‰
 */
export const MAX_FILE_SIZE = 10 * 1024 * 1024;
````

## File: frontend/src/lib/api.ts
````typescript
/**
 * API utility functions and configuration
 *
 * @deprecated æ–°è¦ã‚³ãƒ¼ãƒ‰ã§ã¯ `src/lib/api/client.ts` ã® `apiClient` ã¨ React Query ãƒ•ãƒƒã‚¯ã‚’åˆ©ç”¨ã—ã¦ãã ã•ã„ã€‚
 * ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ãƒ¬ã‚¬ã‚·ãƒ¼äº’æ›ç”¨é€”ã®ã¿ã«æ®‹ã•ã‚Œã¦ãŠã‚Šã€æ®µéšçš„ã«å‰Šé™¤äºˆå®šã§ã™ã€‚
 */

import { getPublicApiBaseUrl } from '@/lib/api/public-api-base-url';

const apiBaseUrl = getPublicApiBaseUrl();

/**
 * Constructs a full API URL from a relative path
 * @param path - The API endpoint path (e.g., '/breeds', '/pedigrees')
 * @returns Complete API URL
 */
export function getApiUrl(path: string): string {
  // Ensure path starts with '/'
  const normalizedPath = path.startsWith('/') ? path : `/${path}`;
  return `${apiBaseUrl}${normalizedPath}`;
}

/**
 * Makes an authenticated API request
 * @param url - The API URL
 * @param options - Fetch options
 * @returns Promise with the response
 */
export async function apiRequest(url: string, options: RequestInit = {}): Promise<Response> {
  // Add default headers
  const defaultHeaders: HeadersInit = {
    'Content-Type': 'application/json',
  };

  const mergedOptions: RequestInit = {
    ...options,
    headers: {
      ...defaultHeaders,
      ...options.headers,
    },
  };

  return fetch(url, mergedOptions);
}

/**
 * Makes a GET request to the API
 * @param path - The API endpoint path
 * @param params - Optional query parameters
 * @returns Promise with the response
 */
export async function apiGet(path: string, params?: Record<string, string>): Promise<Response> {
  let url = getApiUrl(path);
  
  if (params) {
    const searchParams = new URLSearchParams(params);
    url += `?${searchParams.toString()}`;
  }

  return apiRequest(url, { method: 'GET' });
}

/**
 * Makes a POST request to the API
 * @param path - The API endpoint path
 * @param data - Request body data
 * @returns Promise with the response
 */
export async function apiPost(path: string, data: unknown): Promise<Response> {
  return apiRequest(getApiUrl(path), {
    method: 'POST',
    body: JSON.stringify(data),
  });
}
````

## File: frontend/src/lib/invitation-utils.ts
````typescript
/**
 * æ‹›å¾…é–¢é€£ã®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
 */

/**
 * æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³ã‹ã‚‰æ‹›å¾…URLã‚’ç”Ÿæˆã™ã‚‹
 * 
 * @param token - æ‹›å¾…ãƒˆãƒ¼ã‚¯ãƒ³
 * @returns æ‹›å¾…URL
 */
export function getInvitationUrl(token: string): string {
  if (typeof window !== 'undefined') {
    return `${window.location.origin}/accept-invitation?token=${token}`;
  }
  return `/accept-invitation?token=${token}`;
}
````

## File: frontend/src/styles/page-header.css
````css
/* ãƒšãƒ¼ã‚¸ãƒ˜ãƒƒãƒ€ãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã®ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ã‚¹ã‚¿ã‚¤ãƒ« */
.page-actions-container {
  display: flex;
  gap: 0.75rem;
  align-items: center;
  flex-shrink: 0;
}

/* å°å‹ãƒ¢ãƒã‚¤ãƒ«: ã‚¢ã‚¤ã‚³ãƒ³ã®ã¿è¡¨ç¤º (575pxæœªæº€) */
@media (max-width: 575px) {
  .page-actions-container button,
  .page-actions-container .mantine-Button-root {
    min-width: 40px !important;
    max-width: 40px !important;
    width: 40px !important;
    height: 40px !important;
    padding: 0 !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    border-radius: 50% !important;
  }

  /* ãƒœã‚¿ãƒ³ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’éè¡¨ç¤º */
  .page-actions-container button .mantine-Button-label,
  .page-actions-container .mantine-Button-root .mantine-Button-label {
    display: none !important;
  }

  /* ã‚¢ã‚¤ã‚³ãƒ³ã‚’ä¸­å¤®é…ç½® */
  .page-actions-container button .mantine-Button-section,
  .page-actions-container .mantine-Button-root .mantine-Button-section {
    margin: 0 !important;
  }
  
  .page-actions-container button svg,
  .page-actions-container .mantine-Button-root svg {
    width: 20px !important;
    height: 20px !important;
  }
}
````

## File: frontend/src/types/api.types.ts
````typescript
/**
 * APIãƒ¬ã‚¹ãƒãƒ³ã‚¹å‹ï¼ˆãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã¨å®Œå…¨ä¸€è‡´ï¼‰
 */
export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  details?: unknown;
  timestamp: string;
}

/**
 * æ›œæ—¥å‹
 */
export type Weekday = 'mon' | 'tue' | 'wed' | 'thu' | 'fri' | 'sat' | 'sun';

/**
 * å‡ºå‹¤æ™‚é–“ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
 */
export interface WorkTimeTemplate {
  startHour: number; // 0â€“23
  endHour: number; // 1â€“24, must be > startHour
}

/**
 * ã‚¹ã‚¿ãƒƒãƒ•ãƒ¬ã‚¹ãƒãƒ³ã‚¹DTO
 */
export interface StaffResponseDto {
  id: string;
  name: string;
  email: string | null;
  role: string;
  color: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
  workingDays?: Weekday[];
  workTimeTemplate?: WorkTimeTemplate | null;
}

/**
 * ã‚¹ã‚¿ãƒƒãƒ•ä¸€è¦§ãƒ¬ã‚¹ãƒãƒ³ã‚¹
 */
export interface StaffListResponseDto {
  staffList: StaffResponseDto[];
  total: number;
}

/**
 * ã‚¹ã‚¿ãƒƒãƒ•ä½œæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆ
 */
export interface CreateStaffRequest {
  name: string;
  email?: string | null;
  role?: string;
  color?: string;
  workingDays?: Weekday[];
  workTimeTemplate?: WorkTimeTemplate | null;
}

/**
 * ã‚¹ã‚¿ãƒƒãƒ•æ›´æ–°ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
 */
export interface UpdateStaffRequest {
  name?: string;
  email?: string | null;
  role?: string;
  color?: string;
  isActive?: boolean;
  workingDays?: Weekday[];
  workTimeTemplate?: WorkTimeTemplate | null;
}

/**
 * ã‚·ãƒ•ãƒˆãƒ¬ã‚¹ãƒãƒ³ã‚¹DTO
 */
export interface ShiftResponseDto {
  id: string;
  staffId: string;
  staffName: string;
  staffColor: string;
  shiftDate: string; // YYYY-MM-DD
  displayName: string | null;
  status: string;
  notes: string | null;
  createdAt: string;
  updatedAt: string;
}

/**
 * ã‚·ãƒ•ãƒˆä½œæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆ
 */
export interface CreateShiftRequest {
  staffId: string;
  shiftDate: string; // YYYY-MM-DD
  displayName?: string | null;
  notes?: string | null;
}

/**
 * ã‚·ãƒ•ãƒˆæ›´æ–°ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
 */
export interface UpdateShiftRequest {
  staffId?: string;
  shiftDate?: string; // YYYY-MM-DD
  displayName?: string | null;
  notes?: string | null;
  status?: string;
}

/**
 * ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ç”¨ã‚·ãƒ•ãƒˆã‚¤ãƒ™ãƒ³ãƒˆ
 */
export interface CalendarShiftEvent {
  id: string;
  title: string;
  start: string; // ISO 8601
  end: string;   // ISO 8601
  backgroundColor: string;
  borderColor: string;
  extendedProps: {
    shiftId: string;
    staffId: string;
    staffName: string;
    displayName: string | null;
    notes: string | null;
  };
}
````

## File: frontend/src/middleware.ts
````typescript
/**
 * Next.js Middleware
 * èªè¨¼ãŒå¿…è¦ãªãƒ«ãƒ¼ãƒˆã‚’ä¿è­·
 *
 * é–‹ç™ºä¸€æ™‚å¯¾å¿œ: UIå´ã§ãƒ­ã‚°ã‚¤ãƒ³ãƒ•ãƒ­ãƒ¼ã‚’ç„¡åŠ¹åŒ–ã—ãŸã„å ´åˆã¯
 *  .env.local ã« NEXT_PUBLIC_AUTH_DISABLED=1 ã‚’è¨­å®šã™ã‚‹ã¨
 *  ã™ã¹ã¦ã®ãƒšãƒ¼ã‚¸ã‚’ãƒ‘ãƒ–ãƒªãƒƒã‚¯æ‰±ã„ã«ã— /login /register ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã¯ /
 *  ã¸ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã™ã‚‹ã€‚
 * â€» æœ¬ç•ªã§æœ‰åŠ¹åŒ–ã—ãªã„ã“ã¨ã€‚
 */

import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

/**
 * èªè¨¼ä¸è¦ã®å…¬é–‹ãƒ«ãƒ¼ãƒˆ
 */
const PUBLIC_ROUTES = ['/login', '/register', '/api/health'];

/**
 * èªè¨¼ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
 */
export function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;

  // The development-only authentication bypass has been removed for security.
  // All routes are now subject to the standard authentication checks.

  // å…¬é–‹ãƒ«ãƒ¼ãƒˆã¯èªè¨¼ä¸è¦
  if (PUBLIC_ROUTES.some((route) => pathname.startsWith(route))) {
    return NextResponse.next();
  }

  // Nextå†…éƒ¨/é™çš„/ãƒ“ãƒ«ãƒ‰ç”Ÿæˆ/ã‚¢ã‚»ãƒƒãƒˆè¦æ±‚ã¯é™¤å¤–
  if (
    pathname.startsWith('/_next') ||
    pathname.startsWith('/static') ||
    pathname.includes('.')
  ) {
    return NextResponse.next();
  }

  // ç¾æ™‚ç‚¹ã§ã¯ accessToken ã‚’ Cookie ã«ä¿æŒã—ã¦ã„ãªã„ï¼ˆZustandãƒ¡ãƒ¢ãƒªï¼‰ãŸã‚
  // SSRæ®µéšã§ã®å³æ ¼ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã¯è¡Œã‚ãš pass-throughã€‚
  // å°†æ¥ accessToken ã‚’ Cookie åŒ–ã—ãŸéš›ã¯ä»¥ä¸‹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã‚’æœ‰åŠ¹åŒ–ã™ã‚‹:
  // const accessToken = request.cookies.get('accessToken')?.value;
  // if (!accessToken) {
  //   const loginUrl = new URL('/login', request.url);
  //   loginUrl.searchParams.set('redirect', pathname);
  //   return NextResponse.redirect(loginUrl);
  // }

  return NextResponse.next();
}

/**
 * ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã‚’é©ç”¨ã™ã‚‹ãƒ‘ã‚¹ã®è¨­å®š
 */
export const config = {
  matcher: [
    /*
     * ä»¥ä¸‹ã‚’é™¤ãå…¨ã¦ã®ãƒ‘ã‚¹ã«ãƒãƒƒãƒ:
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     */
    '/((?!api|_next/static|_next/image|favicon.ico).*)',
  ],
};
````

## File: frontend/.gitignore
````
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
````

## File: frontend/AGENTS.md
````markdown
# mycats-pro Frontend AGENTS ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³

## 0. ã‚¯ã‚¤ãƒƒã‚¯ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹

- ãƒ«ãƒ¼ãƒˆã§ `pnpm install` æ¸ˆã¿ã§ã‚ã‚Œã° `cd frontend && pnpm install` ã®ã¿ã§ä¾å­˜åŒæœŸã€‚
- é–‹ç™ºã‚µãƒ¼ãƒãƒ¼: `pnpm --filter frontend dev`ï¼ˆPORT=3000ã€`pnpm dev` ã§ã‚‚ backend èµ·å‹•å¾…ã¡ã‚’è€ƒæ…®ï¼‰ã€‚
- ãƒ“ãƒ«ãƒ‰ / æœ¬ç•ªèµ·å‹•: `pnpm --filter frontend build` â†’ `pnpm --filter frontend start`ã€‚
- Lint / å‹ãƒã‚§ãƒƒã‚¯: `pnpm --filter frontend lint`, `pnpm --filter frontend type-check`ã€‚
- ãƒ†ã‚¹ãƒˆ: `pnpm --filter frontend test`ï¼ˆJestï¼‰ / `pnpm --filter frontend test:watch`ã€‚
- OpenAPI å‹æ›´æ–°: ãƒ«ãƒ¼ãƒˆã§ backend ã® Swagger ç”Ÿæˆå¾Œã€`pnpm --filter frontend generate:api-types`ã€‚

## 1. ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ç›®çš„ã¨å„ªå…ˆåº¦

- ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰é…ä¸‹ã§ä½œæ¥­ã™ã‚‹ AI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«å¯¾ã—ã€App Routerã€React 19ã€Mantineã€Tailwindã€Zustand/TanStack Query ã¨ã„ã£ãŸæŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯å›ºæœ‰ã®ãƒ«ãƒ¼ãƒ«ã‚’æ˜ç¤ºã€‚
- ãƒ«ãƒ¼ãƒˆ `AGENTS.md` ã®å…±é€šæ–¹é‡ã«åŠ ãˆã¦ã€ãƒ•ãƒ­ãƒ³ãƒˆç‰¹åŒ–ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã‚’æä¾›ã—ã€ã‚¿ã‚¹ã‚¯ã‚ãŸã‚Šã®èªè­˜é½Ÿé½¬ã‚’æœ€å°åŒ–ã€‚
- ã‚‚ã£ã¨ã‚‚è¿‘ã„ `AGENTS.md` ãŒå„ªå…ˆã•ã‚Œã‚‹ãŸã‚ã€frontend é…ä¸‹ã§ã¯æœ¬ãƒ•ã‚¡ã‚¤ãƒ«ã®æŒ‡ç¤ºãŒãƒ«ãƒ¼ãƒˆã‚ˆã‚Šä¸Šæ›¸ãã•ã‚Œã‚‹ã€‚

## 2. æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯ã¨å‚ç…§ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

| é ˜åŸŸ | ãƒãƒ¼ã‚¸ãƒ§ãƒ³ / ãƒ„ãƒ¼ãƒ« | å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ |
| --- | --- | --- |
| Next.js App Router | 15.x (React Server Components) | [Docs](https://nextjs.org/docs/app) |
| React | 19.x | [React Learn](https://react.dev/learn) |
| UI | Mantine 8.x / Tailwind CSS 4.x | [Mantine](https://mantine.dev) / [Tailwind Docs](https://tailwindcss.com/docs) |
| çŠ¶æ…‹ç®¡ç† | TanStack Query + Zustand | [TanStack Query](https://tanstack.com/query/latest) |
| å‹ | TypeScript 5.x (strict) | [TypeScript Docs](https://www.typescriptlang.org/docs) |

> å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¨çŸ›ç›¾ã—ãŸå ´åˆã¯å…¬å¼ã‚’å„ªå…ˆã—ã€å·®åˆ†ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã‹ PR èª¬æ˜ã§å…±æœ‰ã™ã‚‹ã“ã¨ã€‚

## 3. è¨€èªè¨­å®šã¨ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³

- ã™ã¹ã¦ã®å¯¾è©±ãƒ»ã‚³ãƒ¡ãƒ³ãƒˆãƒ»ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯æ—¥æœ¬èªã€‚ãƒ¦ãƒ¼ã‚¶å‘ã‘ UI æ–‡è¨€ã‚‚æ—¥æœ¬èªã§çµ±ä¸€ã€‚
- å¤‰æ•°ãƒ»é–¢æ•°ãƒ»å‹åã¯è‹±èªã§å‘½åã€‚ãƒ†ã‚¹ãƒˆåã¯ã€Œæ—¥æœ¬èªèª¬æ˜ + è‹±èªè­˜åˆ¥å­ã€ã®ä½µè¨˜å¯ã€‚
- ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯æ—¥æœ¬èªã‚’å„ªå…ˆã—ã€ãƒ­ã‚°ã«æŠ€è¡“çš„è£œè¶³ã‚’ä»˜ã‘ã‚‹ã€‚

## 4. ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª / ä¾å­˜ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿æ–¹

- `src/app/**`: App Router ã®ãƒšãƒ¼ã‚¸ãƒ»ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆãƒ»Server Actionsã€‚`page.tsx`, `layout.tsx`, `loading.tsx`, `error.tsx` ã‚’ Next.js ãƒ•ã‚¡ã‚¤ãƒ«è¦ç´„ã«å¾“ã„é…ç½®ã€‚
- `src/components/**`: å†åˆ©ç”¨ UIã€‚æ–°è¦ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè¿½åŠ æ™‚ã¯æ—¢å­˜ã® `AppLayout`, `TagSelector` ãªã©é¡ä¼¼å®Ÿè£…ã‚’å†åˆ©ç”¨ã€‚
- `src/lib/api/**`: OpenAPI ç”Ÿæˆå‹ (`generated/`) ã¨æ‰‹æ›¸ãã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ (`client.ts`)ã€‚API å‘¼ã³å‡ºã—ã¯ã“ã“çµŒç”±ã€‚
- `src/styles/**`: Tailwind / Mantine ãƒ†ãƒ¼ãƒè¨­å®šã€‚ãƒ†ãƒ¼ãƒæ”¹ä¿®ã¯ `src/styles/theme.ts`ï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆï¼‰ã‚’å„ªå…ˆã€‚
- `docs/` ã‚„ `../docs` é…ä¸‹ã®è¨­è¨ˆè³‡æ–™ã‚‚å‚ç…§ã—ã€UI/UX ã®èƒŒæ™¯ã‚’æŠŠæ¡ã€‚

## 5. ä½œæ¥­ãƒ•ãƒ­ãƒ¼ï¼ˆã‚¿ã‚¤ãƒ—ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆï¼‰

1. **èª¿æŸ»**: å¯¾è±¡ãƒšãƒ¼ã‚¸ / ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ / API ã‚’ç‰¹å®šã—ã€`CODE_GUIDE.md` ãŒã‚ã‚Œã°å…ˆã«èª­ã‚€ã€‚
2. **å‹å®šç¾©**: DTO / Zod schema / Props / Hooks å‹ã‚’æœ€åˆã«æ›´æ–°ã€‚`any` / `unknown` ç¦æ­¢ï¼ˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªåˆ¶ç´„æ™‚ã®ã¿ç†ç”±ã‚³ãƒ¡ãƒ³ãƒˆï¼‰ã€‚
3. **å®Ÿè£…**: Server Component ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¨ã—ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§ã®ã¿å¿…è¦ãªç®‡æ‰€ã« `"use client"` ã‚’ä»˜ä¸ï¼ˆç†ç”±ã‚³ãƒ¡ãƒ³ãƒˆå¿…é ˆï¼‰ã€‚
4. **æ¤œè¨¼**: `pnpm --filter frontend lint`, `type-check`, `test`, å¿…è¦ãªã‚‰ `pnpm frontend:build`ã€‚
5. **è‡ªå·±ãƒ¬ãƒ“ãƒ¥ãƒ¼**: i18nã€ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ï¼ˆARIA, focus trapï¼‰ã€ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å´©ã‚Œã‚’ç¢ºèªã€‚

## 6. Next.js App Router ã‚¬ã‚¤ãƒ‰ (å…¬å¼ Doc æº–æ‹ )

- **Server Components å„ªå…ˆ**: ãƒ•ã‚©ãƒ¼ãƒ ã‚’é™¤ãå¯èƒ½ãªé™ã‚Š Server Component ã§çµ„ã¿ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆçŠ¶æ…‹ãŒå¿…è¦ãªæœ€å°ç¯„å›²ã ã‘ã‚’ Client Component ã«åˆ‡ã‚Šå‡ºã™ï¼ˆNext.js Docs: App Router > Server and Client Componentsï¼‰ã€‚
- **ãƒ‡ãƒ¼ã‚¿å–å¾—**: `fetch` / `cache()` / `revalidateTag` ã‚’æ´»ç”¨ã—ã€`fetch` ã«ã¯ `next: { revalidate: number }` ã‚‚ã—ãã¯ `cache: 'no-cache'` ã‚’å¿…ãšè¨­å®šã€‚TanStack Query ã‚’ä½¿ã†å ´åˆã‚‚ã€åˆæœŸãƒ‡ãƒ¼ã‚¿ã¯ Server Component ã§å–å¾—ã—ã¦ `dehydrate` ã‹ã‚‰å…±æœ‰ã€‚
- **Route Handler / Server Actions**: å¯èƒ½ãªé™ã‚Š Server Action ã‚’åˆ©ç”¨ã—ã€CSRF ã¨ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆZod ãªã©ï¼‰ã‚’å¿…é ˆåŒ–ã€‚`"use server"` ã®é–¢æ•°ã¯ `src/app/(routes)/actions.ts` ç­‰ã«æ•´ç†ã€‚
- **ã‚¨ãƒ©ãƒ¼ãƒã‚¦ãƒ³ãƒ€ãƒª**: `error.tsx`, `not-found.tsx`, `loading.tsx` ã‚’å„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆç›´ä¸‹ã«ç”¨æ„ã—ã€ãƒ¦ãƒ¼ã‚¶å‘ã‘æ—¥æœ¬èªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã€‚`error.tsx` å†…ã§ `reset()` ã‚’æä¾›ã€‚
- **Metadata / SEO**: `generateMetadata` ã§ã‚¿ã‚¤ãƒˆãƒ«ãƒ»OGP ã‚’å®šç¾©ã—ã€`robots` / `sitemap` ãªã© Next.js metadata API ã‚’æ´»ç”¨ã€‚
- **é™çš„æœ€é©åŒ–**: `Route Segment Config`ï¼ˆ`export const dynamic = 'force-static' | 'force-dynamic'` ç­‰ï¼‰ã‚’é©åˆ‡ã«è¨­å®šã—ã€ä¸è¦ãªå‹•çš„ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚’é¿ã‘ã‚‹ã€‚

## 7. React 19 / çŠ¶æ…‹ç®¡ç†ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

- React Hooks ã¯ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã®ã¿ã§å‘¼ã³å‡ºã—ã€‚æ¡ä»¶åˆ†å²å†…ã§ã® Hook å‘¼ã³å‡ºã—ç¦æ­¢ï¼ˆReact Docs: Using Hooksï¼‰ã€‚
- çŠ¶æ…‹ã¯ã€Œã‚µãƒ¼ãƒãƒ¼ãƒ‡ãƒ¼ã‚¿ (TanStack Query)ã€ã€Œä¸€æ™‚ UI çŠ¶æ…‹ (Zustand/Mantine state)ã€ã€Œãƒ•ã‚©ãƒ¼ãƒ çŠ¶æ…‹ (react-hook-form ãªã©)ã€ã‚’å½¹å‰²ã”ã¨ã«åˆ†é›¢ã€‚
- `useEffect` ã®ä¹±ç”¨ã‚’é¿ã‘ã€å¯èƒ½ãªé™ã‚Š Server Component + props ä¼æ¬ã§å®Œçµã•ã›ã‚‹ã€‚
- `Suspense` ã‚’åˆ©ç”¨ã—ã€API ãƒ•ã‚§ãƒƒãƒæ™‚ã®ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° UI ã‚’ `loading.tsx` ã‹ `React.Suspense` ã§æä¾›ã€‚

## 8. Mantine + Tailwind ã‚¹ã‚¿ã‚¤ãƒ«æŒ‡é‡

- Mantine ã® `MantineProvider` ã¨ `ColorSchemeScript` ã¯ `src/app/layout.tsx` ã§ä¸€åº¦ã ã‘è¨­å®šã—ã€`createTheme` ã§ãƒ–ãƒ©ãƒ³ãƒ‰ã‚«ãƒ©ãƒ¼ã‚’çµ±ä¸€ã€‚ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå´ã§ã®ãƒ†ãƒ¼ãƒä¸Šæ›¸ãã¯æœ€å°é™ã€‚
- ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå†…ã‚¹ã‚¿ã‚¤ãƒ«ã¯ã€ŒMantine props â†’ Mantine `classNames` â†’ Tailwind utilityã€ã®é †ã«æ¤œè¨ã€‚Tailwind ã¯ `styles/tailwind.css`ï¼ˆã¾ãŸã¯åŒç­‰ãƒ•ã‚¡ã‚¤ãƒ«ï¼‰ã§ `@tailwind base/components/utilities` ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ¸ˆã¿ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã€‚
- Tailwind ã‚¯ãƒ©ã‚¹ã¯å†—é•·åŒ–ã‚’é¿ã‘ã€`clsx` ã‚„ `tailwind-merge` ã‚’ç”¨ã„ã¦é‡è¤‡æ’é™¤ã€‚ä»»æ„ã‚«ãƒ©ãƒ¼æŒ‡å®šã‚ˆã‚Šãƒ†ãƒ¼ãƒãƒˆãƒ¼ã‚¯ãƒ³ã‚’å„ªå…ˆã€‚
- Mantine ã® `Styles API` ã‚’ä½¿ã†å ´åˆã¯ `styles` ãƒ—ãƒ­ãƒƒãƒ—ã«å‹ä»˜ã‘ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¸¡ã—ã€`style` ç”ŸæŒ‡å®šã¯é¿ã‘ã‚‹ã€‚
- PostCSS / `postcss-preset-mantine` ã‚’å¤‰æ›´ã™ã‚‹å ´åˆã¯ãƒ«ãƒ¼ãƒˆã§å…±æœ‰ã•ã‚Œã‚‹å½±éŸ¿ã«æ³¨æ„ã—ã€PR èª¬æ˜ã§ç†ç”±ã‚’æ˜è¨˜ã€‚

## 9. API é€šä¿¡ã¨ãƒ‡ãƒ¼ã‚¿å±¤

- ã™ã¹ã¦ã® HTTP é€šä¿¡ã¯ `src/lib/api/client.ts` ã‚‚ã—ãã¯ `src/lib/api/hooks/**` çµŒç”±ã€‚ç›´æ¥ `fetch` ã‚’æ›¸ã‹ãªã„ã€‚
- OpenAPI ã‹ã‚‰ç”Ÿæˆã•ã‚ŒãŸå‹ (`generated/`) ã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆ/ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®å˜ä¸€æƒ…å ±æºã¨ã—ã€é‡è¤‡å‹ã‚’å®šç¾©ã—ãªã„ã€‚
- React Query ãƒ•ãƒƒã‚¯ã‚’è¿½åŠ ã™ã‚‹éš›ã¯ `queryKey` ã‚’å…±é€šåŒ–ã—ã€`invalidateQueries` / `revalidateTag` ã®çµ„ã¿åˆã‚ã›ã§ãƒ•ãƒ­ãƒ³ãƒˆãƒ»ãƒãƒƒã‚¯é–“ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’åŒæœŸã€‚
- ã‚¨ãƒ©ãƒ¼æ™‚ã¯ `useQuery` / `useMutation` ã® `onError` ã§ Mantine Notifications ã‚’ç™ºç«ã—ã€æ—¥æœ¬èªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã€‚

## 10. å¤‰æ›´ã‚¹ã‚³ãƒ¼ãƒ—ã¨ UI å†åˆ©ç”¨

- ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚„å¤§è¦æ¨¡ãƒ‡ã‚¶ã‚¤ãƒ³æ”¹ä¿®ã¯ãƒ—ãƒ­ãƒ€ã‚¯ãƒˆã‚ªãƒ¼ãƒŠãƒ¼ã®æ˜ç¤ºæŒ‡ç¤ºãŒã‚ã‚‹å ´åˆã®ã¿å®Ÿæ–½ã€‚
- `src/components` ã«é¡ä¼¼æ©Ÿèƒ½ãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯å¿…ãšå†åˆ©ç”¨ã‚’æ¤œè¨ã€‚é‡è¤‡ãŒã‚„ã‚€ã‚’å¾—ãªã„å ´åˆã¯æ ¹æ‹ ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã«æ®‹ã™ã€‚
- Storybookï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆï¼‰ã¯ä¸»è¦ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®å†ç¾ãƒ†ã‚¹ãƒˆã¨ã—ã¦æ›´æ–°ã—ã€ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã®å·®åˆ†ã‚‚ç¢ºèªã€‚

## 11. ãƒ†ã‚¹ãƒˆ / å“è³ªã‚²ãƒ¼ãƒˆ

| ç¨®åˆ¥ | ã‚³ãƒãƒ³ãƒ‰ | å‚™è€ƒ |
| --- | --- | --- |
| Lint | `pnpm --filter frontend lint` | ESLint + TypeScript pluginã€‚è­¦å‘Šã‚‚è§£æ¶ˆã™ã‚‹ã€‚ |
| å‹ãƒã‚§ãƒƒã‚¯ | `pnpm --filter frontend type-check` | `tsc --noEmit`ã€‚App Router ã¯ `tsconfig.json` ã® `paths` ã‚’åˆ©ç”¨ã€‚ |
| ãƒ¦ãƒ‹ãƒƒãƒˆ/çµ±åˆ | `pnpm --filter frontend test` | Jest + React Testing Libraryã€‚`__tests__` / `*.test.tsx` ã‚’å„ªå…ˆã€‚ |
| E2Eï¼ˆå¿…è¦æ™‚ï¼‰ | `pnpm --filter frontend test:e2e`ï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆï¼‰ | Playwright/Cypress ãªã©ãƒ„ãƒ¼ãƒ«ã«åˆã‚ã›ã¦å®Ÿè¡Œã€‚ |
| ãƒ“ãƒ«ãƒ‰ | `pnpm --filter frontend build` | Next.js `next build`ã€‚å¤±æ•—æ™‚ã¯ `NEXT_PUBLIC_*` ã‚’ç¢ºèªã€‚ |

> ãƒ«ãƒ¼ãƒˆ AGENTS ã®å“è³ªã‚²ãƒ¼ãƒˆ (`pnpm lint`, `pnpm frontend:build` ç­‰) ã‚‚åˆã‚ã›ã¦å®Ÿè¡Œã™ã‚‹ã“ã¨ã€‚

## 12. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ / ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£

- Next.js æ¨å¥¨ã® [Production Checklist](https://nextjs.org/docs/app/guides/production-checklist) ã‚’è¸è¥²ã€‚`next/image`, `next/font` ã‚’æ´»ç”¨ã—ã€LCP å‘ä¸Šã‚’æ„è­˜ã€‚
- `useMemo` / `useCallback` ã¯å¿…è¦æœ€å°é™ã«ç•™ã‚ã€ã¾ãšã¯ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°éšå±¤ã‚’æ•´ç†ã€‚
- Mantine ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ ARIA å¯¾å¿œã ãŒã€ã‚«ã‚¹ã‚¿ãƒ å®Ÿè£…æ™‚ã¯ `role`, `aria-*`, `aria-live` ã‚’é©åˆ‡ã«è¨­å®šã€‚
- å›½éš›åŒ–ãŒå¿…è¦ãªå ´åˆã‚‚ã¾ãšã¯æ—¥æœ¬èª UI ã‚’å®Œæˆã•ã›ã€`next-intl` ç­‰ã®å°å…¥ã¯åˆ¥ã‚¿ã‚¹ã‚¯ã¨ã™ã‚‹ã€‚

## 13. ã‚ˆãã‚ã‚‹ã‚¿ã‚¹ã‚¯åˆ¥ Tips

| ã‚¿ã‚¹ã‚¯ | æŒ‡é‡ |
| --- | --- |
| **ãƒ•ã‚©ãƒ¼ãƒ è¿½åŠ ** | Server Action + Zod ã§ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ â†’ `useForm` (Mantine) + `Controller`ã€‚API å‘¼ã³å‡ºã—ã¯ `useMutation` ã§çµ±ä¸€ã€‚ |
| **ä¸€è¦§ãƒ†ãƒ¼ãƒ–ãƒ«** | æ—¢å­˜ã® `DataTable` ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚„ Mantine `Table` + Tailwind ã‚’å†åˆ©ç”¨ã€‚ç„¡é™ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã¯ TanStack Query ã® `useInfiniteQuery` ã‚’ä½¿ç”¨ã€‚ |
| **ãƒ¢ãƒ¼ãƒ€ãƒ«** | Mantine `ModalsProvider` ã‚’æ´»ç”¨ã—ã€`modals.openContextModal` ã§çŠ¶æ…‹ç®¡ç†ã‚’ä¸€å…ƒåŒ–ã€‚ |
| **é€šçŸ¥** | Mantine `notifications.show` ã‚’ä½¿ã„ã€æˆåŠŸ/å¤±æ•—ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ—¥æœ¬èªã§è¡¨ç¤ºã€‚ |
| **ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ** | Tailwind ã® `md:` ãƒ–ãƒ¬ãƒ¼ã‚¯ãƒã‚¤ãƒ³ãƒˆã‹ Mantine ã® `useMediaQuery` ã‚’ä½¿ç”¨ã—ã€Figma æŒ‡ç¤ºãŒã‚ã‚Œã° `docs/ui-button-design-guide.md` ã‚’å‚ç…§ã€‚ |
| **ãƒ‡ã‚¶ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ«** |ã€€çŒ«æƒ…å ±ã‚’è¡¨ç¤ºã™ã‚‹æ™‚ã¯ã€1è¡Œï¼1é ­ã®åŸå‰‡
è©³ç´°ãƒšãƒ¼ã‚¸ãªã©ã®ä¾‹å¤–ã‚’é™¤ã„ã¦ã€çŒ«ã®æ¦‚è¦ã‚’è¡¨ç¤ºã™ã‚‹ã¨ãã¯1è¡Œã«1é ­ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’ã¾ã¨ã‚ã‚‹ã“ã¨ãŒç†æƒ³ã€‚ |

## 14. ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰å‘ã‘ä¾é ¼ãƒ†ãƒ³ãƒ—ãƒ¬ï¼ˆæ¨å¥¨ï¼‰

```text
ã‚ãªãŸã¯ mycats-pro ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰å°‚ä»» AI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§ã™ã€‚Next.js 15 App Router + React 19 + Mantine + Tailwind ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã¨ frontend/AGENTS.md ã‚’éµå®ˆã—ã¦ãã ã•ã„ã€‚

ã€ã‚„ã‚ŠãŸã„ã“ã¨ã€‘
- èƒŒæ™¯ / ç›®çš„
- å¯¾è±¡ãƒšãƒ¼ã‚¸ or ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ (ä¾‹: src/app/cats/page.tsx)

ã€åˆ¶ç´„ã€‘
- Server Component å„ªå…ˆ / "use client" ã¯ç†ç”±ã‚³ãƒ¡ãƒ³ãƒˆå¿…é ˆ
- å‹å®šç¾© â†’ å®Ÿè£… â†’ ãƒ†ã‚¹ãƒˆ ã®é †
- æ—¢å­˜ UI ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’å†åˆ©ç”¨ã—ã€i18n (æ—¥æœ¬èª) ã‚’çµ±ä¸€

ã€å‡ºåŠ›ã—ã¦ã»ã—ã„ã“ã¨ã€‘
1. å¤‰æ›´ãƒ•ã‚¡ã‚¤ãƒ«ã¨å½¹å‰²
2. ä¸»è¦ãªå®Ÿè£…ãƒã‚¤ãƒ³ãƒˆï¼ˆå‹å®‰å…¨æ€§ã€ãƒ‡ãƒ¼ã‚¿å–å¾—ã€çŠ¶æ…‹ç®¡ç†ï¼‰
3. è¿½åŠ  / æ›´æ–°ã—ãŸãƒ†ã‚¹ãƒˆã®å†…å®¹
4. å®Ÿè¡Œã—ãŸã‚³ãƒãƒ³ãƒ‰ï¼ˆpnpm --filter frontend ...ï¼‰
```

---

ä¸Šè¨˜ã«è¨˜è¼‰ãŒãªã„äº‹é …ã¯ãƒ«ãƒ¼ãƒˆ `AGENTS.md` ã®æŒ‡ç¤ºã«å¾“ã„ã€ç–‘ç¾©ãŒã‚ã‚Œã° PR ã‹ã‚³ãƒ¡ãƒ³ãƒˆã§å‘¨çŸ¥ã—ã¦ãã ã•ã„ã€‚
````

## File: frontend/GEMINI.md
````markdown
# frontend GEMINI ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³

## 0. ç›®çš„ã¨å‚ç…§

- æœ¬æ›¸ã¯ `frontend/AGENTS.md` ã‚’ Gemini ç³» LLM ã§å†åˆ©ç”¨ã—ã‚„ã™ãã—ãŸè¤‡è£½ç‰ˆã§ã™ã€‚App Router / React / UI æ”¹ä¿®æ™‚ã¯å¿…ãš `AGENTS.md` ã¨å†…å®¹ã‚’åŒæœŸã—ã¦ãã ã•ã„ã€‚
- å‚è€ƒã«ã—ãŸ Gemini å…¬å¼æƒ…å ±ï¼ˆæœ€çµ‚æ›´æ–° 2025-11-18 UTCï¼‰:
  - [Gemini API Docs](https://ai.google.dev/gemini-api/docs)
  - [ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆè¨­è¨ˆæˆ¦ç•¥](https://ai.google.dev/gemini-api/docs/prompting-strategies)
- æ–°ãŸãª Gemini ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã‚’å–ã‚Šè¾¼ã‚€å ´åˆã¯ã€æ ¹æ‹  URL ã¨æ—¥ä»˜ã‚’æ˜è¨˜ã—ã€`AGENTS.md` ã‚‚åˆã‚ã›ã¦æ›´æ–°ã—ã¦ãã ã•ã„ã€‚

## 1. Gemini ã§ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ä½œæ¥­ã‚’è¡Œã†ã¨ãã®ã‚¬ã‚¤ãƒ‰

1. **æ®µéšçš„æ€è€ƒ**: `Plan â†’ Implement â†’ Validate â†’ Format` ã® 4 ã‚¹ãƒ†ãƒƒãƒ—ã‚’ system æŒ‡ç¤ºã«å«ã‚ã€UI å¤‰æ›´ç‚¹ã€ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ã€i18n ã‚’ãƒã‚§ãƒƒã‚¯ã•ã›ã‚‹ã€‚
2. **æ§‹é€ åŒ–ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ**: `<context>` ã«å¯¾è±¡ãƒšãƒ¼ã‚¸/ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã€`<constraints>` ã«ã€ŒServer Component å„ªå…ˆã€ã€Œ"use client" ç†ç”±å¿…é ˆã€ã€Œæ—¥æœ¬èª UIã€ãªã©ã‚’åˆ—æŒ™ã™ã‚‹ã¨ Gemini 3 ã§ã‚‚è§£é‡ˆã—ã‚„ã™ã„ã€‚
3. **few-shot**: æˆåŠŸä¾‹ã¨ã—ã¦ã€Œå‹ã‚’æ›´æ–°â†’å®Ÿè£…â†’ãƒ†ã‚¹ãƒˆâ†’ã‚³ãƒãƒ³ãƒ‰å…±æœ‰ã€ã¨ã„ã†ä¸€é€£ã®å¿œç­”ãƒ†ãƒ³ãƒ—ãƒ¬ã‚’æ·»ä»˜ã—ã€åŒã˜ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§å›ç­”ã•ã›ã‚‹ã€‚
4. **ãƒãƒ«ãƒãƒ¢ãƒ¼ãƒ€ãƒ«**: ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã‚„ Figma å‚ç…§ãŒå¿…è¦ãªå ´åˆã¯ Files API ã§ç”»åƒã‚’æ¸¡ã—ã€`<media>` ã‚¿ã‚°ã§å‚ç…§æŒ‡ç¤ºã‚’åŠ ãˆã‚‹ã€‚
5. **ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿**: ã‚³ãƒ¼ãƒ‰ç”Ÿæˆã¯ `temperature=0.4`, `topK=1`, `topP=0.5` ã‚’åŸºæœ¬ã€‚Gemini 3 ã‚’åˆ©ç”¨ã™ã‚‹å ´åˆã¯æ¸©åº¦ 1.0 å›ºå®šæ¨å¥¨ã®ãŸã‚ã€ç¢ºå®šæ€§ãŒå¿…è¦ãªã‚‰ `gemini-2.5-pro` ã‚’åˆ©ç”¨ã€‚
6. **æ¤œè¨¼**: å›ç­”å‰ã«ã€ŒServer/Client Component åˆ¤å®šã€ã€ŒTailwind/Mantine ãƒ«ãƒ¼ãƒ«ã€ã€Œå“è³ªã‚²ãƒ¼ãƒˆã€ã® 3 ã¤ã‚’æº€ãŸã—ãŸã‹ã‚’è‡ªå·±ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã‚ˆã† system æŒ‡ç¤ºã‚’åŠ ãˆã‚‹ã€‚

---

ä»¥ä¸‹ã¯ 2025-11-24 æ™‚ç‚¹ã® `frontend/AGENTS.md` ã‚’è¤‡è£½ã—ãŸã‚‚ã®ã§ã™ã€‚å·®åˆ†ã¯å¿…ãšä¸¡ãƒ•ã‚¡ã‚¤ãƒ«ã«åæ˜ ã—ã¦ãã ã•ã„ã€‚

# mycats-pro Frontend AGENTS ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³

## 0. ã‚¯ã‚¤ãƒƒã‚¯ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹

- ãƒ«ãƒ¼ãƒˆã§ `pnpm install` æ¸ˆã¿ã§ã‚ã‚Œã° `cd frontend && pnpm install` ã®ã¿ã§ä¾å­˜åŒæœŸã€‚
- é–‹ç™ºã‚µãƒ¼ãƒãƒ¼: `pnpm --filter frontend dev`ï¼ˆPORT=3000ã€`pnpm dev` ã§ã‚‚ backend èµ·å‹•å¾…ã¡ã‚’è€ƒæ…®ï¼‰ã€‚
- ãƒ“ãƒ«ãƒ‰ / æœ¬ç•ªèµ·å‹•: `pnpm --filter frontend build` â†’ `pnpm --filter frontend start`ã€‚
- Lint / å‹ãƒã‚§ãƒƒã‚¯: `pnpm --filter frontend lint`, `pnpm --filter frontend type-check`ã€‚
- ãƒ†ã‚¹ãƒˆ: `pnpm --filter frontend test`ï¼ˆJestï¼‰ / `pnpm --filter frontend test:watch`ã€‚
- OpenAPI å‹æ›´æ–°: ãƒ«ãƒ¼ãƒˆã§ backend ã® Swagger ç”Ÿæˆå¾Œã€`pnpm --filter frontend generate:api-types`ã€‚

## 1. ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ç›®çš„ã¨å„ªå…ˆåº¦

- ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰é…ä¸‹ã§ä½œæ¥­ã™ã‚‹ AI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«å¯¾ã—ã€App Routerã€React 19ã€Mantineã€Tailwindã€Zustand/TanStack Query ã¨ã„ã£ãŸæŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯å›ºæœ‰ã®ãƒ«ãƒ¼ãƒ«ã‚’æ˜ç¤ºã€‚
- ãƒ«ãƒ¼ãƒˆ `AGENTS.md` ã®å…±é€šæ–¹é‡ã«åŠ ãˆã¦ã€ãƒ•ãƒ­ãƒ³ãƒˆç‰¹åŒ–ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã‚’æä¾›ã—ã€ã‚¿ã‚¹ã‚¯ã‚ãŸã‚Šã®èªè­˜é½Ÿé½¬ã‚’æœ€å°åŒ–ã€‚
- ã‚‚ã£ã¨ã‚‚è¿‘ã„ `AGENTS.md` ãŒå„ªå…ˆã•ã‚Œã‚‹ãŸã‚ã€frontend é…ä¸‹ã§ã¯æœ¬ãƒ•ã‚¡ã‚¤ãƒ«ã®æŒ‡ç¤ºãŒãƒ«ãƒ¼ãƒˆã‚ˆã‚Šä¸Šæ›¸ãã•ã‚Œã‚‹ã€‚

## 2. æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯ã¨å‚ç…§ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

| é ˜åŸŸ | ãƒãƒ¼ã‚¸ãƒ§ãƒ³ / ãƒ„ãƒ¼ãƒ« | å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ |
| --- | --- | --- |
| Next.js App Router | 15.x (React Server Components) | [Docs](https://nextjs.org/docs/app) |
| React | 19.x | [React Learn](https://react.dev/learn) |
| UI | Mantine 8.x / Tailwind CSS 4.x | [Mantine](https://mantine.dev) / [Tailwind Docs](https://tailwindcss.com/docs) |
| çŠ¶æ…‹ç®¡ç† | TanStack Query + Zustand | [TanStack Query](https://tanstack.com/query/latest) |
| å‹ | TypeScript 5.x (strict) | [TypeScript Docs](https://www.typescriptlang.org/docs) |

> å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¨çŸ›ç›¾ã—ãŸå ´åˆã¯å…¬å¼ã‚’å„ªå…ˆã—ã€å·®åˆ†ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã‹ PR èª¬æ˜ã§å…±æœ‰ã™ã‚‹ã“ã¨ã€‚

## 3. è¨€èªè¨­å®šã¨ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³

- ã™ã¹ã¦ã®å¯¾è©±ãƒ»ã‚³ãƒ¡ãƒ³ãƒˆãƒ»ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯æ—¥æœ¬èªã€‚ãƒ¦ãƒ¼ã‚¶å‘ã‘ UI æ–‡è¨€ã‚‚æ—¥æœ¬èªã§çµ±ä¸€ã€‚
- å¤‰æ•°ãƒ»é–¢æ•°ãƒ»å‹åã¯è‹±èªã§å‘½åã€‚ãƒ†ã‚¹ãƒˆåã¯ã€Œæ—¥æœ¬èªèª¬æ˜ + è‹±èªè­˜åˆ¥å­ã€ã®ä½µè¨˜å¯ã€‚
- ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯æ—¥æœ¬èªã‚’å„ªå…ˆã—ã€ãƒ­ã‚°ã«æŠ€è¡“çš„è£œè¶³ã‚’ä»˜ã‘ã‚‹ã€‚

## 4. ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª / ä¾å­˜ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿æ–¹

- `src/app/**`: App Router ã®ãƒšãƒ¼ã‚¸ãƒ»ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆãƒ»Server Actionsã€‚`page.tsx`, `layout.tsx`, `loading.tsx`, `error.tsx` ã‚’ Next.js ãƒ•ã‚¡ã‚¤ãƒ«è¦ç´„ã«å¾“ã„é…ç½®ã€‚
- `src/components/**`: å†åˆ©ç”¨ UIã€‚æ–°è¦ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè¿½åŠ æ™‚ã¯æ—¢å­˜ã® `AppLayout`, `TagSelector` ãªã©é¡ä¼¼å®Ÿè£…ã‚’å†åˆ©ç”¨ã€‚
- `src/lib/api/**`: OpenAPI ç”Ÿæˆå‹ (`generated/`) ã¨æ‰‹æ›¸ãã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ (`client.ts`)ã€‚API å‘¼ã³å‡ºã—ã¯ã“ã“çµŒç”±ã€‚
- `src/styles/**`: Tailwind / Mantine ãƒ†ãƒ¼ãƒè¨­å®šã€‚ãƒ†ãƒ¼ãƒæ”¹ä¿®ã¯ `src/styles/theme.ts`ï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆï¼‰ã‚’å„ªå…ˆã€‚
- `docs/` ã‚„ `../docs` é…ä¸‹ã®è¨­è¨ˆè³‡æ–™ã‚‚å‚ç…§ã—ã€UI/UX ã®èƒŒæ™¯ã‚’æŠŠæ¡ã€‚

## 5. ä½œæ¥­ãƒ•ãƒ­ãƒ¼ï¼ˆã‚¿ã‚¤ãƒ—ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆï¼‰

1. **èª¿æŸ»**: å¯¾è±¡ãƒšãƒ¼ã‚¸ / ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ / API ã‚’ç‰¹å®šã—ã€`CODE_GUIDE.md` ãŒã‚ã‚Œã°å…ˆã«èª­ã‚€ã€‚
2. **å‹å®šç¾©**: DTO / Zod schema / Props / Hooks å‹ã‚’æœ€åˆã«æ›´æ–°ã€‚`any` / `unknown` ç¦æ­¢ï¼ˆãƒ©ã‚¤ãƒ–ãƒ©ãƒªåˆ¶ç´„æ™‚ã®ã¿ç†ç”±ã‚³ãƒ¡ãƒ³ãƒˆï¼‰ã€‚
3. **å®Ÿè£…**: Server Component ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¨ã—ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§ã®ã¿å¿…è¦ãªç®‡æ‰€ã« `"use client"` ã‚’ä»˜ä¸ï¼ˆç†ç”±ã‚³ãƒ¡ãƒ³ãƒˆå¿…é ˆï¼‰ã€‚
4. **æ¤œè¨¼**: `pnpm --filter frontend lint`, `type-check`, `test`, å¿…è¦ãªã‚‰ `pnpm frontend:build`ã€‚
5. **è‡ªå·±ãƒ¬ãƒ“ãƒ¥ãƒ¼**: i18nã€ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ï¼ˆARIA, focus trapï¼‰ã€ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å´©ã‚Œã‚’ç¢ºèªã€‚

## 6. Next.js App Router ã‚¬ã‚¤ãƒ‰ (å…¬å¼ Doc æº–æ‹ )

- **Server Components å„ªå…ˆ**: ãƒ•ã‚©ãƒ¼ãƒ ã‚’é™¤ãå¯èƒ½ãªé™ã‚Š Server Component ã§çµ„ã¿ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆçŠ¶æ…‹ãŒå¿…è¦ãªæœ€å°ç¯„å›²ã ã‘ã‚’ Client Component ã«åˆ‡ã‚Šå‡ºã™ï¼ˆNext.js Docs: App Router > Server and Client Componentsï¼‰ã€‚
- **ãƒ‡ãƒ¼ã‚¿å–å¾—**: `fetch` / `cache()` / `revalidateTag` ã‚’æ´»ç”¨ã—ã€`fetch` ã«ã¯ `next: { revalidate: number }` ã‚‚ã—ãã¯ `cache: 'no-cache'` ã‚’å¿…ãšè¨­å®šã€‚TanStack Query ã‚’ä½¿ã†å ´åˆã‚‚ã€åˆæœŸãƒ‡ãƒ¼ã‚¿ã¯ Server Component ã§å–å¾—ã—ã¦ `dehydrate` ã‹ã‚‰å…±æœ‰ã€‚
- **Route Handler / Server Actions**: å¯èƒ½ãªé™ã‚Š Server Action ã‚’åˆ©ç”¨ã—ã€CSRF ã¨ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆZod ãªã©ï¼‰ã‚’å¿…é ˆåŒ–ã€‚`"use server"` ã®é–¢æ•°ã¯ `src/app/(routes)/actions.ts` ç­‰ã«æ•´ç†ã€‚
- **ã‚¨ãƒ©ãƒ¼ãƒã‚¦ãƒ³ãƒ€ãƒª**: `error.tsx`, `not-found.tsx`, `loading.tsx` ã‚’å„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆç›´ä¸‹ã«ç”¨æ„ã—ã€ãƒ¦ãƒ¼ã‚¶å‘ã‘æ—¥æœ¬èªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã€‚`error.tsx` å†…ã§ `reset()` ã‚’æä¾›ã€‚
- **Metadata / SEO**: `generateMetadata` ã§ã‚¿ã‚¤ãƒˆãƒ«ãƒ»OGP ã‚’å®šç¾©ã—ã€`robots` / `sitemap` ãªã© Next.js metadata API ã‚’æ´»ç”¨ã€‚
- **é™çš„æœ€é©åŒ–**: `Route Segment Config`ï¼ˆ`export const dynamic = 'force-static' | 'force-dynamic'` ç­‰ï¼‰ã‚’é©åˆ‡ã«è¨­å®šã—ã€ä¸è¦ãªå‹•çš„ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚’é¿ã‘ã‚‹ã€‚

## 7. React 19 / çŠ¶æ…‹ç®¡ç†ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

- React Hooks ã¯ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã®ã¿ã§å‘¼ã³å‡ºã—ã€‚æ¡ä»¶åˆ†å²å†…ã§ã® Hook å‘¼ã³å‡ºã—ç¦æ­¢ï¼ˆReact Docs: Using Hooksï¼‰ã€‚
- çŠ¶æ…‹ã¯ã€Œã‚µãƒ¼ãƒãƒ¼ãƒ‡ãƒ¼ã‚¿ (TanStack Query)ã€ã€Œä¸€æ™‚ UI çŠ¶æ…‹ (Zustand/Mantine state)ã€ã€Œãƒ•ã‚©ãƒ¼ãƒ çŠ¶æ…‹ (react-hook-form ãªã©)ã€ã‚’å½¹å‰²ã”ã¨ã«åˆ†é›¢ã€‚
- `useEffect` ã®ä¹±ç”¨ã‚’é¿ã‘ã€å¯èƒ½ãªé™ã‚Š Server Component + props ä¼æ¬ã§å®Œçµã•ã›ã‚‹ã€‚
- `Suspense` ã‚’åˆ©ç”¨ã—ã€API ãƒ•ã‚§ãƒƒãƒæ™‚ã®ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° UI ã‚’ `loading.tsx` ã‹ `React.Suspense` ã§æä¾›ã€‚

## 8. Mantine + Tailwind ã‚¹ã‚¿ã‚¤ãƒ«æŒ‡é‡

- Mantine ã® `MantineProvider` ã¨ `ColorSchemeScript` ã¯ `src/app/layout.tsx` ã§ä¸€åº¦ã ã‘è¨­å®šã—ã€`createTheme` ã§ãƒ–ãƒ©ãƒ³ãƒ‰ã‚«ãƒ©ãƒ¼ã‚’çµ±ä¸€ã€‚ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå´ã§ã®ãƒ†ãƒ¼ãƒä¸Šæ›¸ãã¯æœ€å°é™ã€‚
- ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå†…ã‚¹ã‚¿ã‚¤ãƒ«ã¯ã€ŒMantine props â†’ Mantine `classNames` â†’ Tailwind utilityã€ã®é †ã«æ¤œè¨ã€‚Tailwind ã¯ `styles/tailwind.css`ï¼ˆã¾ãŸã¯åŒç­‰ãƒ•ã‚¡ã‚¤ãƒ«ï¼‰ã§ `@tailwind base/components/utilities` ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ¸ˆã¿ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã€‚
- Tailwind ã‚¯ãƒ©ã‚¹ã¯å†—é•·åŒ–ã‚’é¿ã‘ã€`clsx` ã‚„ `tailwind-merge` ã‚’ç”¨ã„ã¦é‡è¤‡æ’é™¤ã€‚ä»»æ„ã‚«ãƒ©ãƒ¼æŒ‡å®šã‚ˆã‚Šãƒ†ãƒ¼ãƒãƒˆãƒ¼ã‚¯ãƒ³ã‚’å„ªå…ˆã€‚
- Mantine ã® `Styles API` ã‚’ä½¿ã†å ´åˆã¯ `styles` ãƒ—ãƒ­ãƒƒãƒ—ã«å‹ä»˜ã‘ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¸¡ã—ã€`style` ç”ŸæŒ‡å®šã¯é¿ã‘ã‚‹ã€‚
- PostCSS / `postcss-preset-mantine` ã‚’å¤‰æ›´ã™ã‚‹å ´åˆã¯ãƒ«ãƒ¼ãƒˆã§å…±æœ‰ã•ã‚Œã‚‹å½±éŸ¿ã«æ³¨æ„ã—ã€PR èª¬æ˜ã§ç†ç”±ã‚’æ˜è¨˜ã€‚

## 9. API é€šä¿¡ã¨ãƒ‡ãƒ¼ã‚¿å±¤

- ã™ã¹ã¦ã® HTTP é€šä¿¡ã¯ `src/lib/api/client.ts` ã‚‚ã—ãã¯ `src/lib/api/hooks/**` çµŒç”±ã€‚ç›´æ¥ `fetch` ã‚’æ›¸ã‹ãªã„ã€‚
- OpenAPI ã‹ã‚‰ç”Ÿæˆã•ã‚ŒãŸå‹ (`generated/`) ã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆ/ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®å˜ä¸€æƒ…å ±æºã¨ã—ã€é‡è¤‡å‹ã‚’å®šç¾©ã—ãªã„ã€‚
- React Query ãƒ•ãƒƒã‚¯ã‚’è¿½åŠ ã™ã‚‹éš›ã¯ `queryKey` ã‚’å…±é€šåŒ–ã—ã€`invalidateQueries` / `revalidateTag` ã®çµ„ã¿åˆã‚ã›ã§ãƒ•ãƒ­ãƒ³ãƒˆãƒ»ãƒãƒƒã‚¯é–“ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’åŒæœŸã€‚
- ã‚¨ãƒ©ãƒ¼æ™‚ã¯ `useQuery` / `useMutation` ã® `onError` ã§ Mantine Notifications ã‚’ç™ºç«ã—ã€æ—¥æœ¬èªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã€‚

## 10. å¤‰æ›´ã‚¹ã‚³ãƒ¼ãƒ—ã¨ UI å†åˆ©ç”¨

- ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚„å¤§è¦æ¨¡ãƒ‡ã‚¶ã‚¤ãƒ³æ”¹ä¿®ã¯ãƒ—ãƒ­ãƒ€ã‚¯ãƒˆã‚ªãƒ¼ãƒŠãƒ¼ã®æ˜ç¤ºæŒ‡ç¤ºãŒã‚ã‚‹å ´åˆã®ã¿å®Ÿæ–½ã€‚
- `src/components` ã«é¡ä¼¼æ©Ÿèƒ½ãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯å¿…ãšå†åˆ©ç”¨ã‚’æ¤œè¨ã€‚é‡è¤‡ãŒã‚„ã‚€ã‚’å¾—ãªã„å ´åˆã¯æ ¹æ‹ ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã«æ®‹ã™ã€‚
- Storybookï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆï¼‰ã¯ä¸»è¦ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®å†ç¾ãƒ†ã‚¹ãƒˆã¨ã—ã¦æ›´æ–°ã—ã€ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã®å·®åˆ†ã‚‚ç¢ºèªã€‚

## 11. ãƒ†ã‚¹ãƒˆ / å“è³ªã‚²ãƒ¼ãƒˆ

| ç¨®åˆ¥ | ã‚³ãƒãƒ³ãƒ‰ | å‚™è€ƒ |
| --- | --- | --- |
| Lint | `pnpm --filter frontend lint` | ESLint + TypeScript pluginã€‚è­¦å‘Šã‚‚è§£æ¶ˆã™ã‚‹ã€‚ |
| å‹ãƒã‚§ãƒƒã‚¯ | `pnpm --filter frontend type-check` | `tsc --noEmit`ã€‚App Router ã¯ `tsconfig.json` ã® `paths` ã‚’åˆ©ç”¨ã€‚ |
| ãƒ¦ãƒ‹ãƒƒãƒˆ/çµ±åˆ | `pnpm --filter frontend test` | Jest + React Testing Libraryã€‚`__tests__` / `*.test.tsx` ã‚’å„ªå…ˆã€‚ |
| E2Eï¼ˆå¿…è¦æ™‚ï¼‰ | `pnpm --filter frontend test:e2e`ï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆï¼‰ | Playwright/Cypress ãªã©ãƒ„ãƒ¼ãƒ«ã«åˆã‚ã›ã¦å®Ÿè¡Œã€‚ |
| ãƒ“ãƒ«ãƒ‰ | `pnpm --filter frontend build` | Next.js `next build`ã€‚å¤±æ•—æ™‚ã¯ `NEXT_PUBLIC_*` ã‚’ç¢ºèªã€‚ |

> ãƒ«ãƒ¼ãƒˆ AGENTS ã®å“è³ªã‚²ãƒ¼ãƒˆ (`pnpm lint`, `pnpm frontend:build` ç­‰) ã‚‚åˆã‚ã›ã¦å®Ÿè¡Œã™ã‚‹ã“ã¨ã€‚

## 12. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ / ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£

- Next.js æ¨å¥¨ã® [Production Checklist](https://nextjs.org/docs/app/guides/production-checklist) ã‚’è¸è¥²ã€‚`next/image`, `next/font` ã‚’æ´»ç”¨ã—ã€LCP å‘ä¸Šã‚’æ„è­˜ã€‚
- `useMemo` / `useCallback` ã¯å¿…è¦æœ€å°é™ã«ç•™ã‚ã€ã¾ãšã¯ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°éšå±¤ã‚’æ•´ç†ã€‚
- Mantine ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ ARIA å¯¾å¿œã ãŒã€ã‚«ã‚¹ã‚¿ãƒ å®Ÿè£…æ™‚ã¯ `role`, `aria-*`, `aria-live` ã‚’é©åˆ‡ã«è¨­å®šã€‚
- å›½éš›åŒ–ãŒå¿…è¦ãªå ´åˆã‚‚ã¾ãšã¯æ—¥æœ¬èª UI ã‚’å®Œæˆã•ã›ã€`next-intl` ç­‰ã®å°å…¥ã¯åˆ¥ã‚¿ã‚¹ã‚¯ã¨ã™ã‚‹ã€‚

## 13. ã‚ˆãã‚ã‚‹ã‚¿ã‚¹ã‚¯åˆ¥ Tips

| ã‚¿ã‚¹ã‚¯ | æŒ‡é‡ |
| --- | --- |
| **ãƒ•ã‚©ãƒ¼ãƒ è¿½åŠ ** | Server Action + Zod ã§ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ â†’ `useForm` (Mantine) + `Controller`ã€‚API å‘¼ã³å‡ºã—ã¯ `useMutation` ã§çµ±ä¸€ã€‚ |
| **ä¸€è¦§ãƒ†ãƒ¼ãƒ–ãƒ«** | æ—¢å­˜ã® `DataTable` ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚„ Mantine `Table` + Tailwind ã‚’å†åˆ©ç”¨ã€‚ç„¡é™ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã¯ TanStack Query ã® `useInfiniteQuery` ã‚’ä½¿ç”¨ã€‚ |
| **ãƒ¢ãƒ¼ãƒ€ãƒ«** | Mantine `ModalsProvider` ã‚’æ´»ç”¨ã—ã€`modals.openContextModal` ã§çŠ¶æ…‹ç®¡ç†ã‚’ä¸€å…ƒåŒ–ã€‚ |
| **é€šçŸ¥** | Mantine `notifications.show` ã‚’ä½¿ã„ã€æˆåŠŸ/å¤±æ•—ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ—¥æœ¬èªã§è¡¨ç¤ºã€‚ |
| **ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ** | Tailwind ã® `md:` ãƒ–ãƒ¬ãƒ¼ã‚¯ãƒã‚¤ãƒ³ãƒˆã‹ Mantine ã® `useMediaQuery` ã‚’ä½¿ç”¨ã—ã€Figma æŒ‡ç¤ºãŒã‚ã‚Œã° `docs/ui-button-design-guide.md` ã‚’å‚ç…§ã€‚ |
| **ãƒ‡ã‚¶ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ«** |ã€€çŒ«æƒ…å ±ã‚’è¡¨ç¤ºã™ã‚‹æ™‚ã¯ã€1è¡Œï¼1é ­ã®åŸå‰‡
è©³ç´°ãƒšãƒ¼ã‚¸ãªã©ã®ä¾‹å¤–ã‚’é™¤ã„ã¦ã€çŒ«ã®æ¦‚è¦ã‚’è¡¨ç¤ºã™ã‚‹ã¨ãã¯1è¡Œã«1é ­ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’ã¾ã¨ã‚ã‚‹ã“ã¨ãŒç†æƒ³ã€‚ |

## 14. ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰å‘ã‘ä¾é ¼ãƒ†ãƒ³ãƒ—ãƒ¬ï¼ˆæ¨å¥¨ï¼‰

```
ã‚ãªãŸã¯ mycats-pro ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰å°‚ä»» AI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§ã™ã€‚Next.js 15 App Router + React 19 + Mantine + Tailwind ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã¨ frontend/AGENTS.md ã‚’éµå®ˆã—ã¦ãã ã•ã„ã€‚

ã€ã‚„ã‚ŠãŸã„ã“ã¨ã€‘
- èƒŒæ™¯ / ç›®çš„
- å¯¾è±¡ãƒšãƒ¼ã‚¸ or ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ (ä¾‹: src/app/cats/page.tsx)

ã€åˆ¶ç´„ã€‘
- Server Component å„ªå…ˆ / "use client" ã¯ç†ç”±ã‚³ãƒ¡ãƒ³ãƒˆå¿…é ˆ
- å‹å®šç¾© â†’ å®Ÿè£… â†’ ãƒ†ã‚¹ãƒˆ ã®é †
- æ—¢å­˜ UI ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’å†åˆ©ç”¨ã—ã€i18n (æ—¥æœ¬èª) ã‚’çµ±ä¸€

ã€å‡ºåŠ›ã—ã¦ã»ã—ã„ã“ã¨ã€‘
1. å¤‰æ›´ãƒ•ã‚¡ã‚¤ãƒ«ã¨å½¹å‰²
2. ä¸»è¦ãªå®Ÿè£…ãƒã‚¤ãƒ³ãƒˆï¼ˆå‹å®‰å…¨æ€§ã€ãƒ‡ãƒ¼ã‚¿å–å¾—ã€çŠ¶æ…‹ç®¡ç†ï¼‰
3. è¿½åŠ  / æ›´æ–°ã—ãŸãƒ†ã‚¹ãƒˆã®å†…å®¹
4. å®Ÿè¡Œã—ãŸã‚³ãƒãƒ³ãƒ‰ï¼ˆpnpm --filter frontend ...ï¼‰
```

---

ä¸Šè¨˜ã«è¨˜è¼‰ãŒãªã„äº‹é …ã¯ãƒ«ãƒ¼ãƒˆ `AGENTS.md` ã®æŒ‡ç¤ºã«å¾“ã„ã€ç–‘ç¾©ãŒã‚ã‚Œã° PR ã‹ã‚³ãƒ¡ãƒ³ãƒˆã§å‘¨çŸ¥ã—ã¦ãã ã•ã„ã€‚
````

## File: frontend/jest.config.js
````javascript
const nextJest = require('next/jest')

const createJestConfig = nextJest({
  // Provide the path to your Next.js app to load next.config.js and .env files
  dir: './',
})

// Add any custom config to be passed to Jest
const customJestConfig = {
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  testEnvironment: 'jsdom',
  testPathIgnorePatterns: ['<rootDir>/.next/', '<rootDir>/node_modules/'],
  collectCoverageFrom: [
    'src/components/**/*.{js,jsx,ts,tsx}',
    'src/lib/**/*.{js,jsx,ts,tsx}',
    'src/app/**/_components/**/*.{js,jsx,ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.stories.{js,jsx,ts,tsx}',
    '!src/**/*.types.ts',
    '!src/**/*.interface.ts',
    '!src/**/*.constants.ts',
    '!src/**/*.enum.ts',
    '!src/**/types/**',
    '!src/**/interfaces/**',
    '!src/**/constants/**',
    '!src/**/enums/**',
    '!src/app/layout.tsx',
    '!src/app/**/layout.tsx',
    '!src/lib/api/client.ts',
    '!src/lib/api/types.ts',
  ],
  coverageReporters: ['text', 'lcov', 'html'],
  coverageDirectory: 'coverage',
  coverageThreshold: {
    global: {
      branches: 40,
      functions: 40,
      lines: 40,
      statements: 40,
    },
  },
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  transform: {
    '^.+\\.(js|jsx|ts|tsx)$': ['babel-jest', { presets: ['next/babel'] }],
  },
  transformIgnorePatterns: [
    'node_modules/(?!(.*\\.mjs$|@mantine))',
  ],
}

// createJestConfig is exported this way to ensure that next/jest can load the Next.js config which is async
module.exports = createJestConfig(customJestConfig)
````

## File: frontend/jest.setup.js
````javascript
import '@testing-library/jest-dom'

// Mantine / UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒå‚ç…§ã™ã‚‹ãƒ–ãƒ©ã‚¦ã‚¶APIã®ãƒãƒªãƒ•ã‚£ãƒ«

const win = typeof globalThis.window !== 'undefined' ? globalThis.window : undefined

if (win && !win.matchMedia) {
	Object.defineProperty(win, 'matchMedia', {
		writable: true,
		value: (query) => ({
			matches: false,
			media: query,
			onchange: null,
			addListener: () => {},
			removeListener: () => {},
			addEventListener: () => {},
			removeEventListener: () => {},
			dispatchEvent: () => false,
		}),
	})
}

if (!('ResizeObserver' in globalThis)) {
	globalThis.ResizeObserver = class {
		observe() {}
		unobserve() {}
		disconnect() {}
	}
}

if (!('IntersectionObserver' in globalThis)) {
	globalThis.IntersectionObserver = class {
		observe() {}
		unobserve() {}
		disconnect() {}
	}
}
````

## File: frontend/postcss.config.mjs
````javascript
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
````

## File: frontend/README.md
````markdown
# MyCats Pro - ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰

çŒ«ç”Ÿä½“ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã€‚Next.js 15ã¨Mantine UIã‚’ä½¿ç”¨ã—ãŸæœ€æ–°ã®Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã™ã€‚

## ğŸ›  æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯

- **ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯**: Next.js 15.5.3 (App Router)
- **ãƒ©ã‚¤ãƒ–ãƒ©ãƒª**: React 19.1.0
- **UI**: Mantine UI 8.2.4 + Tailwind CSS 4.x
- **è¨€èª**: TypeScript 5.x
- **çŠ¶æ…‹ç®¡ç†**: Zustand + TanStack Query
- **APIé€šä¿¡**: å‹å®‰å…¨ãªAPIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆï¼ˆOpenAPIç”Ÿæˆå‹ï¼‰
- **æ—¥ä»˜å‡¦ç†**: Day.js
- **ã‚¢ã‚¤ã‚³ãƒ³**: Tabler Icons

## ğŸš€ é–‹ç™ºç’°å¢ƒã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

### å‰ææ¡ä»¶

- Node.js 20.x ä»¥ä¸Š
- pnpm 9.x ä»¥ä¸Š

### ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

```bash
# ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ç§»å‹•
cd frontend

# ä¾å­˜é–¢ä¿‚ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
pnpm install

# ç’°å¢ƒå¤‰æ•°ã®è¨­å®š
cp .env.example .env.local
```

### ç’°å¢ƒå¤‰æ•°

`.env.local` ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã€ä»¥ä¸‹ã®ç’°å¢ƒå¤‰æ•°ã‚’è¨­å®šã—ã¦ãã ã•ã„:

```env
# ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰API URLï¼ˆå¿…é ˆï¼‰
NEXT_PUBLIC_API_URL=http://localhost:3004/api/v1

# ç’°å¢ƒè­˜åˆ¥å­
NEXT_PUBLIC_ENV=development

# èªè¨¼ãƒã‚¤ãƒ‘ã‚¹ï¼ˆé–‹ç™ºç’°å¢ƒã®ã¿ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒªã‚¹ã‚¯ã‚ã‚Šï¼‰
# NEXT_PUBLIC_AUTH_DISABLED=0
```

> âš ï¸ **é‡è¦**: `NEXT_PUBLIC_API_URL`ã«ã¯å¿…ãš`/api/v1`ã‚’å«ã‚ã¦ãã ã•ã„ã€‚

## ğŸ“ é–‹ç™ºã‚³ãƒãƒ³ãƒ‰

```bash
# é–‹ç™ºã‚µãƒ¼ãƒãƒ¼èµ·å‹•ï¼ˆãƒãƒ¼ãƒˆ3000ï¼‰
pnpm dev

# ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ãƒ“ãƒ«ãƒ‰
pnpm build

# ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ã‚µãƒ¼ãƒãƒ¼èµ·å‹•
pnpm start

# Lintå®Ÿè¡Œ
pnpm lint

# å‹ãƒã‚§ãƒƒã‚¯
pnpm type-check

# OpenAPIå‹å®šç¾©ã®ç”Ÿæˆ
pnpm generate:api-types
```

## ğŸ“ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ 

```
src/
â”œâ”€â”€ app/                    # Next.js App Router
â”‚   â”œâ”€â”€ layout.tsx         # ãƒ«ãƒ¼ãƒˆãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
â”‚   â”œâ”€â”€ page.tsx           # ãƒ›ãƒ¼ãƒ ç”»é¢
â”‚   â”œâ”€â”€ cats/              # çŒ«ç®¡ç†ãƒšãƒ¼ã‚¸
â”‚   â”œâ”€â”€ pedigrees/         # è¡€çµ±æ›¸ç®¡ç†ãƒšãƒ¼ã‚¸
â”‚   â”œâ”€â”€ breeding/          # äº¤é…ç®¡ç†ãƒšãƒ¼ã‚¸
â”‚   â”œâ”€â”€ care/              # ã‚±ã‚¢ç®¡ç†ãƒšãƒ¼ã‚¸
â”‚   â”œâ”€â”€ kittens/           # å­çŒ«ç®¡ç†ãƒšãƒ¼ã‚¸
â”‚   â”œâ”€â”€ tags/              # ã‚¿ã‚°ç®¡ç†ãƒšãƒ¼ã‚¸
â”‚   â””â”€â”€ more/              # ãã®ä»–æ©Ÿèƒ½
â”œâ”€â”€ components/            # å†åˆ©ç”¨å¯èƒ½ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”‚   â”œâ”€â”€ AppLayout.tsx      # ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å…±é€šãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
â”‚   â”œâ”€â”€ PageTitle.tsx      # ãƒšãƒ¼ã‚¸ã‚¿ã‚¤ãƒˆãƒ«ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”‚   â”œâ”€â”€ GenderBadge.tsx    # æ€§åˆ¥ãƒãƒƒã‚¸
â”‚   â”œâ”€â”€ TagSelector.tsx    # ã‚¿ã‚°é¸æŠUI
â”‚   â””â”€â”€ forms/             # ãƒ•ã‚©ãƒ¼ãƒ ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”œâ”€â”€ lib/                   # ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ»ãƒ©ã‚¤ãƒ–ãƒ©ãƒª
â”‚   â”œâ”€â”€ api/               # APIé€šä¿¡ãƒ¬ã‚¤ãƒ¤ãƒ¼
â”‚   â”‚   â”œâ”€â”€ client.ts      # APIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
â”‚   â”‚   â”œâ”€â”€ hooks/         # React Query ãƒ•ãƒƒã‚¯
â”‚   â”‚   â””â”€â”€ generated/     # OpenAPIç”Ÿæˆå‹
â”‚   â””â”€â”€ utils/             # ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
â””â”€â”€ styles/                # ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚¿ã‚¤ãƒ«
```

## ğŸ¨ ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè¨­è¨ˆ

### å…±é€šã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

- **AppLayout**: ã‚µã‚¤ãƒ‰ãƒãƒ¼ãƒ»ãƒ˜ãƒƒãƒ€ãƒ¼ä»˜ãå…±é€šãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
- **PageTitle**: çµ±ä¸€ã•ã‚ŒãŸãƒšãƒ¼ã‚¸ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆ18px/700ï¼‰
- **GenderBadge**: æ€§åˆ¥ãƒãƒƒã‚¸ï¼ˆã‚ªã‚¹/ãƒ¡ã‚¹/å»å‹¢/é¿å¦Šï¼‰
- **TagDisplay**: ã‚¿ã‚°è¡¨ç¤ºã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
- **TagSelector**: ã‚¿ã‚°é¸æŠUI

è©³ç´°ã¯ [src/components/README.md](src/components/README.md) ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

## ğŸ”Œ APIçµ±åˆ

### APIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ

å‹å®‰å…¨ãªAPIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’ä½¿ç”¨:

```typescript
import { apiClient } from '@/lib/api/client';

// GET ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
const response = await apiClient.get('/cats', {
  query: { limit: 20, page: 1 }
});

// POST ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
const result = await apiClient.post('/cats', {
  body: { name: 'Fluffy', breed_id: 'breed-001' }
});
```

### React Query ãƒ•ãƒƒã‚¯

```typescript
import { useGetCats, useCreateCat } from '@/lib/api/hooks/use-cats';

function CatList() {
  const { data, isLoading } = useGetCats({ limit: 20 });
  const createCat = useCreateCat();

  // ...
}
```

### OpenAPIå‹å®šç¾©ã®æ›´æ–°

ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®APIãŒæ›´æ–°ã•ã‚ŒãŸå ´åˆ:

```bash
# 1. ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã§OpenAPIã‚¹ã‚­ãƒ¼ãƒã‚’ç”Ÿæˆ
cd ../backend
pnpm swagger:gen

# 2. ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã§å‹å®šç¾©ã‚’ç”Ÿæˆ
cd ../frontend
pnpm generate:api-types
```

## ğŸ§ª ãƒ†ã‚¹ãƒˆ

```bash
# ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
pnpm test

# ãƒ†ã‚¹ãƒˆã‚¦ã‚©ãƒƒãƒãƒ¢ãƒ¼ãƒ‰
pnpm test:watch

# ã‚«ãƒãƒ¬ãƒƒã‚¸
pnpm test:coverage
```

ãƒ†ã‚¹ãƒˆæ§‹é€ ã®è©³ç´°ã¯ [src/__tests__/README.md](src/__tests__/README.md) ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

## ğŸ¯ ä¸»è¦æ©Ÿèƒ½

### å®Ÿè£…æ¸ˆã¿æ©Ÿèƒ½

- âœ… ãƒ›ãƒ¼ãƒ ç”»é¢ / ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰
- âœ… çŒ«ç®¡ç†ï¼ˆä¸€è¦§ãƒ»è©³ç´°ãƒ»ç™»éŒ²ãƒ»ç·¨é›†ï¼‰
- âœ… è¡€çµ±æ›¸ç®¡ç†ï¼ˆä¸€è¦§ãƒ»è©³ç´°ãƒ»å®¶ç³»å›³ï¼‰
- âœ… å­çŒ«ç®¡ç†ï¼ˆã‚°ãƒ«ãƒ¼ãƒ—è¡¨ç¤ºãƒ»æˆé•·è¨˜éŒ²ï¼‰
- âœ… äº¤é…ç®¡ç†ï¼ˆè¨˜éŒ²ãƒ»äºˆå®šï¼‰
- âœ… ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆãƒ¯ã‚¯ãƒãƒ³ãƒ»é§†è™«ãƒ»å¥åº·è¨ºæ–­ï¼‰
- âœ… ã‚¿ã‚°ç®¡ç†ï¼ˆä½œæˆãƒ»ç·¨é›†ãƒ»ã‚«ãƒ†ã‚´ãƒªåˆ¥ï¼‰
- âœ… ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ‡ã‚¶ã‚¤ãƒ³

### é–‹ç™ºä¸­ãƒ»è¨ˆç”»ä¸­

- ğŸš§ ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½
- ğŸš§ ãƒ‡ãƒ¼ã‚¿ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ/ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
- ğŸš§ è©³ç´°ãªçµ±è¨ˆãƒ»ãƒ¬ãƒãƒ¼ãƒˆæ©Ÿèƒ½
- ğŸš§ é€šçŸ¥æ©Ÿèƒ½
- ğŸš§ å¤šè¨€èªå¯¾å¿œ

## ğŸ” èªè¨¼

JWT Bearer Tokenã«ã‚ˆã‚‹èªè¨¼ã‚’å®Ÿè£…ã€‚`apiClient`ãŒè‡ªå‹•çš„ã«ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç®¡ç†ã—ã¾ã™ã€‚

```typescript
// ãƒ­ã‚°ã‚¤ãƒ³
await apiClient.post('/auth/login', {
  body: { email, password }
});
// ãƒˆãƒ¼ã‚¯ãƒ³ã¯è‡ªå‹•ä¿å­˜

// è‡ªå‹•çš„ã«ãƒˆãƒ¼ã‚¯ãƒ³ãŒä»˜ä¸ã•ã‚Œã‚‹
await apiClient.get('/cats'); // Authorization: Bearer <token>

// ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ
await apiClient.post('/auth/logout');
// ãƒˆãƒ¼ã‚¯ãƒ³ã¯è‡ªå‹•å‰Šé™¤
```

## ğŸ“š é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- **ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“**: [../README.md](../README.md)
- **ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚¬ã‚¤ãƒ‰**: [../SETUP_GUIDE.md](../SETUP_GUIDE.md)
- **ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°**: [../TROUBLESHOOTING.md](../TROUBLESHOOTING.md)
- **APIä»•æ§˜**: [../docs/api-specification.md](../docs/api-specification.md)
- **æ©Ÿèƒ½ãƒ–ãƒ«ãƒ¼ãƒ—ãƒªãƒ³ãƒˆ**: [../docs/functional-blueprint.md](../docs/functional-blueprint.md)

## ğŸ¤ é–‹ç™ºã¸ã®å‚åŠ 

ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’æ­“è¿ã—ã¾ã™ï¼ä»¥ä¸‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„:

1. ESLintã¨TypeScriptã®å‹ãƒã‚§ãƒƒã‚¯ã‚’é€šã™ã“ã¨
2. æ—¢å­˜ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè¨­è¨ˆã«å¾“ã†ã“ã¨
3. å‘½åè¦å‰‡ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã«æº–æ‹ ã™ã‚‹ã“ã¨ï¼ˆ[../docs/naming_convention_guidelines_v2.md](../docs/naming_convention_guidelines_v2.md)ï¼‰

---

**æœ€çµ‚æ›´æ–°**: 2025å¹´11æœˆ13æ—¥  
**ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: Next.js 15.5.3 + React 19.1.0 + Mantine 8.2.4
````

## File: frontend/sentry.client.config.ts
````typescript
import * as Sentry from '@sentry/nextjs';

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  tracesSampleRate: Number(process.env.NEXT_PUBLIC_SENTRY_TRACES_SAMPLE_RATE || 0.1),
  replaysSessionSampleRate: 0.0,
  replaysOnErrorSampleRate: 0.1,
  enabled: !!process.env.NEXT_PUBLIC_SENTRY_DSN,
});
````

## File: frontend/sentry.server.config.ts
````typescript
import * as Sentry from '@sentry/nextjs';

Sentry.init({
  dsn: process.env.SENTRY_DSN || process.env.NEXT_PUBLIC_SENTRY_DSN,
  tracesSampleRate: Number(process.env.SENTRY_TRACES_SAMPLE_RATE || 0.1),
  enabled: !!(process.env.SENTRY_DSN || process.env.NEXT_PUBLIC_SENTRY_DSN),
});
````

## File: init_database.sql
````sql
-- Database initialization for Cat Management System
-- This script creates all necessary tables based on the Prisma schema

-- Create enums
CREATE TYPE "UserRole" AS ENUM ('USER', 'ADMIN', 'SUPER_ADMIN');
CREATE TYPE "Gender" AS ENUM ('MALE', 'FEMALE');
CREATE TYPE "BreedingStatus" AS ENUM ('PLANNED', 'IN_PROGRESS', 'COMPLETED', 'FAILED');
CREATE TYPE "CareType" AS ENUM ('VACCINATION', 'HEALTH_CHECK', 'GROOMING', 'DENTAL_CARE', 'MEDICATION', 'SURGERY', 'OTHER');
CREATE TYPE "ScheduleType" AS ENUM ('BREEDING', 'CARE', 'APPOINTMENT', 'REMINDER', 'MAINTENANCE');
CREATE TYPE "ScheduleStatus" AS ENUM ('PENDING', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED');
CREATE TYPE "Priority" AS ENUM ('LOW', 'MEDIUM', 'HIGH', 'URGENT');
CREATE TYPE "TagAssignmentAction" AS ENUM ('ASSIGNED', 'UNASSIGNED');
CREATE TYPE "TagAssignmentSource" AS ENUM ('MANUAL', 'AUTOMATION', 'SYSTEM');
CREATE TYPE "TagAutomationTriggerType" AS ENUM ('EVENT', 'SCHEDULE', 'MANUAL');
CREATE TYPE "TagAutomationEventType" AS ENUM (
    'BREEDING_PLANNED',
    'BREEDING_CONFIRMED',
    'PREGNANCY_CONFIRMED',
    'KITTEN_REGISTERED',
    'AGE_THRESHOLD',
    'CUSTOM'
);
CREATE TYPE "TagAutomationRunStatus" AS ENUM ('PENDING', 'COMPLETED', 'FAILED');

-- Create users table
CREATE TABLE IF NOT EXISTS "users" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "clerkId" TEXT NOT NULL UNIQUE,
    "email" TEXT NOT NULL UNIQUE,
    "firstName" TEXT,
    "lastName" TEXT,
    "role" "UserRole" NOT NULL DEFAULT 'USER',
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Create cats table
CREATE TABLE IF NOT EXISTS "cats" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "registrationId" TEXT NOT NULL UNIQUE,
    "name" TEXT NOT NULL,
    "breed" TEXT NOT NULL,
    "color" TEXT NOT NULL,
    "pattern" TEXT,
    "gender" "Gender" NOT NULL,
    "birthDate" TIMESTAMP(3) NOT NULL,
    "weight" DOUBLE PRECISION,
    "microchipId" TEXT UNIQUE,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "notes" TEXT,
    "imageUrl" TEXT,
    "fatherId" TEXT,
    "motherId" TEXT,
    "ownerId" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT "cats_fatherId_fkey" FOREIGN KEY ("fatherId") REFERENCES "cats"("id") ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT "cats_motherId_fkey" FOREIGN KEY ("motherId") REFERENCES "cats"("id") ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT "cats_ownerId_fkey" FOREIGN KEY ("ownerId") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- Create breeding_records table
CREATE TABLE IF NOT EXISTS "breeding_records" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "maleId" TEXT NOT NULL,
    "femaleId" TEXT NOT NULL,
    "breedingDate" TIMESTAMP(3) NOT NULL,
    "expectedDueDate" TIMESTAMP(3),
    "actualDueDate" TIMESTAMP(3),
    "numberOfKittens" INTEGER,
    "notes" TEXT,
    "status" "BreedingStatus" NOT NULL DEFAULT 'PLANNED',
    "recordedBy" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT "breeding_records_maleId_fkey" FOREIGN KEY ("maleId") REFERENCES "cats"("id") ON DELETE RESTRICT ON UPDATE CASCADE,
    CONSTRAINT "breeding_records_femaleId_fkey" FOREIGN KEY ("femaleId") REFERENCES "cats"("id") ON DELETE RESTRICT ON UPDATE CASCADE,
    CONSTRAINT "breeding_records_recordedBy_fkey" FOREIGN KEY ("recordedBy") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- Create care_records table
CREATE TABLE IF NOT EXISTS "care_records" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "catId" TEXT NOT NULL,
    "careType" "CareType" NOT NULL,
    "description" TEXT NOT NULL,
    "careDate" TIMESTAMP(3) NOT NULL,
    "nextDueDate" TIMESTAMP(3),
    "cost" DOUBLE PRECISION,
    "veterinarian" TEXT,
    "notes" TEXT,
    "recordedBy" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT "care_records_catId_fkey" FOREIGN KEY ("catId") REFERENCES "cats"("id") ON DELETE RESTRICT ON UPDATE CASCADE,
    CONSTRAINT "care_records_recordedBy_fkey" FOREIGN KEY ("recordedBy") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- Create schedules table
CREATE TABLE IF NOT EXISTS "schedules" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "title" TEXT NOT NULL,
    "description" TEXT,
    "scheduleDate" TIMESTAMP(3) NOT NULL,
    "scheduleType" "ScheduleType" NOT NULL,
    "status" "ScheduleStatus" NOT NULL DEFAULT 'PENDING',
    "priority" "Priority" NOT NULL DEFAULT 'MEDIUM',
    "catId" TEXT,
    "assignedTo" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT "schedules_catId_fkey" FOREIGN KEY ("catId") REFERENCES "cats"("id") ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT "schedules_assignedTo_fkey" FOREIGN KEY ("assignedTo") REFERENCES "users"("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

-- Create tag_categories table
CREATE TABLE IF NOT EXISTS "tag_categories" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "key" TEXT NOT NULL UNIQUE,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "color" TEXT DEFAULT '#3B82F6',
    "display_order" INTEGER NOT NULL DEFAULT 0,
    "scopes" TEXT[] NOT NULL DEFAULT ARRAY[]::TEXT[],
    "is_active" BOOLEAN NOT NULL DEFAULT true,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Create tags table
CREATE TABLE IF NOT EXISTS "tags" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "category_id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "color" TEXT NOT NULL DEFAULT '#3B82F6',
    "description" TEXT,
    "display_order" INTEGER NOT NULL DEFAULT 0,
    "allows_manual" BOOLEAN NOT NULL DEFAULT true,
    "allows_automation" BOOLEAN NOT NULL DEFAULT true,
    "metadata" JSONB,
    "is_active" BOOLEAN NOT NULL DEFAULT true,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT "tags_category_id_fkey" FOREIGN KEY ("category_id") REFERENCES "tag_categories"("id") ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE UNIQUE INDEX IF NOT EXISTS "tag_categories_key_key" ON "tag_categories"("key");
CREATE UNIQUE INDEX IF NOT EXISTS "tags_category_id_name_key" ON "tags"("category_id", "name");

-- Create tag automation tables
CREATE TABLE IF NOT EXISTS "tag_automation_rules" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "key" TEXT NOT NULL UNIQUE,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "trigger_type" "TagAutomationTriggerType" NOT NULL,
    "event_type" "TagAutomationEventType" NOT NULL,
    "scope" TEXT,
    "is_active" BOOLEAN NOT NULL DEFAULT true,
    "priority" INTEGER NOT NULL DEFAULT 0,
    "config" JSONB,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS "tag_automation_runs" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "rule_id" TEXT NOT NULL,
    "event_payload" JSONB,
    "status" "TagAutomationRunStatus" NOT NULL DEFAULT 'PENDING',
    "started_at" TIMESTAMP(3),
    "completed_at" TIMESTAMP(3),
    "error_message" TEXT,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updated_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT "tag_automation_runs_rule_id_fkey" FOREIGN KEY ("rule_id") REFERENCES "tag_automation_rules"("id") ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE TABLE IF NOT EXISTS "tag_assignment_history" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "cat_id" TEXT NOT NULL,
    "tag_id" TEXT NOT NULL,
    "rule_id" TEXT,
    "automation_run_id" TEXT,
    "action" "TagAssignmentAction" NOT NULL DEFAULT 'ASSIGNED',
    "source" "TagAssignmentSource" NOT NULL DEFAULT 'MANUAL',
    "reason" TEXT,
    "metadata" JSONB,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT "tag_assignment_history_cat_id_fkey" FOREIGN KEY ("cat_id") REFERENCES "cats"("id") ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT "tag_assignment_history_tag_id_fkey" FOREIGN KEY ("tag_id") REFERENCES "tags"("id") ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT "tag_assignment_history_rule_id_fkey" FOREIGN KEY ("rule_id") REFERENCES "tag_automation_rules"("id") ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT "tag_assignment_history_automation_run_id_fkey" FOREIGN KEY ("automation_run_id") REFERENCES "tag_automation_runs"("id") ON DELETE SET NULL ON UPDATE CASCADE
);

CREATE INDEX IF NOT EXISTS "tag_automation_runs_rule_id_idx" ON "tag_automation_runs"("rule_id");
CREATE INDEX IF NOT EXISTS "tag_assignment_history_cat_id_idx" ON "tag_assignment_history"("cat_id");
CREATE INDEX IF NOT EXISTS "tag_assignment_history_tag_id_idx" ON "tag_assignment_history"("tag_id");
CREATE INDEX IF NOT EXISTS "tag_assignment_history_rule_id_idx" ON "tag_assignment_history"("rule_id");
CREATE INDEX IF NOT EXISTS "tag_assignment_history_automation_run_id_idx" ON "tag_assignment_history"("automation_run_id");

-- Create cat_tags table (many-to-many relationship)
CREATE TABLE IF NOT EXISTS "cat_tags" (
    "catId" TEXT NOT NULL,
    "tagId" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY ("catId", "tagId"),
    CONSTRAINT "cat_tags_catId_fkey" FOREIGN KEY ("catId") REFERENCES "cats"("id") ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT "cat_tags_tagId_fkey" FOREIGN KEY ("tagId") REFERENCES "tags"("id") ON DELETE CASCADE ON UPDATE CASCADE
);

-- Create Prisma migration table
CREATE TABLE IF NOT EXISTS "_prisma_migrations" (
    "id" TEXT NOT NULL PRIMARY KEY,
    "checksum" TEXT NOT NULL,
    "finished_at" TIMESTAMP(3),
    "migration_name" TEXT NOT NULL,
    "logs" TEXT,
    "rolled_back_at" TIMESTAMP(3),
    "started_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "applied_steps_count" INTEGER NOT NULL DEFAULT 0
);

-- Insert initial migration record
INSERT INTO "_prisma_migrations" ("id", "checksum", "migration_name", "started_at", "applied_steps_count")
VALUES ('manual-init-' || extract(epoch from now())::text, 'manual-init', 'manual_database_initialization', CURRENT_TIMESTAMP, 1)
ON CONFLICT ("id") DO NOTHING;

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS "idx_cats_owner" ON "cats"("ownerId");
CREATE INDEX IF NOT EXISTS "idx_cats_registration" ON "cats"("registrationId");
CREATE INDEX IF NOT EXISTS "idx_breeding_records_male" ON "breeding_records"("maleId");
CREATE INDEX IF NOT EXISTS "idx_breeding_records_female" ON "breeding_records"("femaleId");
CREATE INDEX IF NOT EXISTS "idx_care_records_cat" ON "care_records"("catId");
CREATE INDEX IF NOT EXISTS "idx_schedules_cat" ON "schedules"("catId");
CREATE INDEX IF NOT EXISTS "idx_schedules_assignee" ON "schedules"("assignedTo");
CREATE INDEX IF NOT EXISTS "idx_schedules_date" ON "schedules"("scheduleDate");
````

## File: nginx/conf.d/default.conf
````ini
# Upstream for backend API
upstream backend_api {
    server backend:3001;
}

# Upstream for cat-management frontend
upstream cat_management_frontend {
    server frontend-cat-management:3000;
}

# Upstream for new-pedigree frontend
upstream new_pedigree_frontend {
    server frontend-new-pedigree:3000;
}

# Main cat-management application
server {
    listen 80;
    server_name localhost cat-management.local;

    # API routes
    location /api/ {
        limit_req zone=api burst=20 nodelay;
        proxy_pass http://backend_api;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        proxy_read_timeout 300;
        proxy_connect_timeout 300;
        proxy_send_timeout 300;
    }

    # Frontend routes
    location / {
        limit_req zone=app burst=50 nodelay;
        proxy_pass http://cat_management_frontend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }

    # Health check endpoint
    location /health {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }
}

# New pedigree application
server {
    listen 80;
    server_name pedigree.local;

    # API routes (shared with main app)
    location /api/ {
        limit_req zone=api burst=20 nodelay;
        proxy_pass http://backend_api;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        proxy_read_timeout 300;
        proxy_connect_timeout 300;
        proxy_send_timeout 300;
    }

    # Frontend routes
    location / {
        limit_req zone=app burst=50 nodelay;
        proxy_pass http://new_pedigree_frontend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }
}
````

## File: nginx/nginx.conf
````ini
events {
    worker_connections 1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    # Logging format
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';

    access_log /var/log/nginx/access.log main;
    error_log /var/log/nginx/error.log warn;

    # Basic settings
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/json
        application/javascript
        application/xml+rss
        application/atom+xml
        image/svg+xml;

    # Security headers
    add_header X-Frame-Options DENY always;
    add_header X-Content-Type-Options nosniff always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    # Rate limiting
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
    limit_req_zone $binary_remote_addr zone=app:10m rate=30r/s;

    # Include additional configuration files
    include /etc/nginx/conf.d/*.conf;
}
````

## File: pnpm-workspace.yaml
````yaml
packages:
  - "frontend"
  - "backend"
````

## File: scripts/build-production.sh
````bash
#!/bin/bash

# Production Build and Deployment Script
# This script prepares the application for production deployment

set -e  # Exit on any error

echo "ğŸ—ï¸  Starting production build process..."

# Check Node.js version
NODE_VERSION=$(node --version)
echo "ğŸ“¦ Node.js version: $NODE_VERSION"

# Install dependencies
echo "ğŸ“¦ Installing dependencies with frozen lockfile..."
pnpm install --frozen-lockfile

# Run security audit
echo "ğŸ”’ Running security audit..."
pnpm audit --audit-level moderate

# Generate Prisma client
echo "ğŸ”§ Generating Prisma client..."
pnpm -w run db:generate

# Lint code
echo "ğŸ§¹ Linting code..."
pnpm run lint:backend
pnpm run lint:frontend

# Type checking
echo "ğŸ” Type checking..."
pnpm --filter backend run type-check
pnpm --filter frontend run type-check

# Build backend
echo "ğŸ—ï¸  Building backend..."
pnpm run backend:build

# Build frontend
echo "ğŸ—ï¸  Building frontend..."
pnpm run frontend:build

# Run tests (optional, uncomment if tests exist)
# echo "ğŸ§ª Running tests..."
# pnpm run test:e2e

echo "âœ… Production build completed successfully!"
echo ""
echo "ğŸ“‹ Deployment checklist:"
echo "  1. Set production environment variables"
echo "  2. Run database migrations: pnpm -w run db:deploy"
echo "  3. Start application: pnpm run frontend:start"
echo "  4. Verify health check: curl http://localhost:3004/health"
echo ""
echo "ğŸš€ Ready for deployment!"
````

## File: scripts/check-memory.mjs
````javascript
#!/usr/bin/env node
/**
 * ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãƒã‚§ãƒƒã‚¯ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
 * Node.jsãƒ—ãƒ­ã‚»ã‚¹ã®ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã‚’è¡¨ç¤ºã—ã¾ã™
 */

import { execSync } from 'node:child_process';
import { platform } from 'node:os';

const isWindows = platform() === 'win32';

function getNodeProcesses() {
  try {
    if (isWindows) {
      // Windows: PowerShellã‚’ä½¿ç”¨
      const command = `powershell -Command "Get-Process node -ErrorAction SilentlyContinue | Select-Object Id, ProcessName, @{Name='Memory(MB)';Expression={[math]::Round($_.WS / 1MB, 2)}}, @{Name='CPU(s)';Expression={$_.CPU}} | Format-Table -AutoSize"`;
      const output = execSync(command, { encoding: 'utf-8' });
      return output;
    } else {
      // macOS/Linux: psã‚³ãƒãƒ³ãƒ‰ã‚’ä½¿ç”¨ï¼ˆç’°å¢ƒã«ä¾å­˜ã—ãªã„å½¢å¼ï¼‰
      // ps auxã®å‡ºåŠ›ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ç’°å¢ƒã«ã‚ˆã‚Šç•°ãªã‚‹ãŸã‚ã€ã‚ˆã‚Šå …ç‰¢ãªæ–¹æ³•ã‚’ä½¿ç”¨
      const command = `ps -eo pid,pmem,pcpu,comm | grep -E 'node|next|nest' | grep -v grep | awk '{printf "PID: %-8s Memory: %6s%% CPU: %6s%% Command: %s\\n", $1, $2, $3, $4}'`;
      try {
        const output = execSync(command, { encoding: 'utf-8' });
        return output;
      } catch {
        // ps -eoãŒä½¿ãˆãªã„å ´åˆã¯ps auxã‚’ä½¿ç”¨ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
        const fallbackCommand = `ps aux | grep -E 'node|next|nest' | grep -v grep | awk '{printf "PID: %-8s Memory: %6s%% CPU: %6s%% Command: %s\\n", $2, $4, $3, $11}'`;
        const output = execSync(fallbackCommand, { encoding: 'utf-8' });
        return output;
      }
    }
  } catch (error) {
    return `ã‚¨ãƒ©ãƒ¼: ãƒ—ãƒ­ã‚»ã‚¹æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ\n${error.message}`;
  }
}

function getTotalMemory() {
  try {
    if (isWindows) {
      const command = `powershell -Command "[math]::Round((Get-CimInstance Win32_ComputerSystem).TotalPhysicalMemory / 1GB, 2)"`;
      const totalGB = parseFloat(execSync(command, { encoding: 'utf-8' }).trim());
      return totalGB;
    } else {
      // macOS/Linux: freeã‚³ãƒãƒ³ãƒ‰ã¾ãŸã¯sysctlã‚’ä½¿ç”¨
      try {
        const command = `free -g | grep Mem | awk '{print $2}'`;
        const totalGB = parseFloat(execSync(command, { encoding: 'utf-8' }).trim());
        return totalGB;
      } catch {
        // macOSã®å ´åˆ
        const command = `sysctl -n hw.memsize | awk '{print $1/1024/1024/1024}'`;
        const totalGB = parseFloat(execSync(command, { encoding: 'utf-8' }).trim());
        return totalGB;
      }
    }
  } catch (error) {
    return null;
  }
}

function getNodeProcessMemory() {
  try {
    if (isWindows) {
      const command = `powershell -Command "(Get-Process node -ErrorAction SilentlyContinue | Measure-Object -Property WS -Sum).Sum / 1MB"`;
      const memoryMB = parseFloat(execSync(command, { encoding: 'utf-8' }).trim() || '0');
      return memoryMB;
    } else {
      // macOS/Linux: ã‚ˆã‚Šå …ç‰¢ãªãƒ¡ãƒ¢ãƒªå–å¾—æ–¹æ³•
      // ps -eo rssã‚’ä½¿ç”¨ï¼ˆRSSã¯KBå˜ä½ã§çµ±ä¸€ã•ã‚Œã¦ã„ã‚‹ï¼‰
      try {
        const command = `ps -eo rss,comm | grep -E 'node|next|nest' | grep -v grep | awk '{sum+=$1} END {print sum/1024}'`;
        const memoryMB = parseFloat(execSync(command, { encoding: 'utf-8' }).trim() || '0');
        return memoryMB;
      } catch {
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ps auxã‚’ä½¿ç”¨ï¼ˆç’°å¢ƒä¾å­˜ã®å¯èƒ½æ€§ã‚ã‚Šï¼‰
        const fallbackCommand = `ps aux | grep -E 'node|next|nest' | grep -v grep | awk '{sum+=$6} END {print sum/1024}'`;
        const memoryMB = parseFloat(execSync(fallbackCommand, { encoding: 'utf-8' }).trim() || '0');
        return memoryMB;
      }
    }
  } catch (error) {
    return 0;
  }
}

console.log('ğŸ“Š Node.js ãƒ—ãƒ­ã‚»ã‚¹ã®ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡\n');
console.log('='.repeat(60));

const processes = getNodeProcesses();
console.log(processes);

console.log('\n' + '='.repeat(60));

const totalMemoryGB = getTotalMemory();
const nodeMemoryMB = getNodeProcessMemory();

if (totalMemoryGB && nodeMemoryMB > 0) {
  const nodeMemoryGB = nodeMemoryMB / 1024;
  const percentage = ((nodeMemoryGB / totalMemoryGB) * 100).toFixed(1);
  
  console.log(`\nğŸ’¾ ã‚·ã‚¹ãƒ†ãƒ æƒ…å ±:`);
  console.log(`   ç·ãƒ¡ãƒ¢ãƒª: ${totalMemoryGB} GB`);
  console.log(`   Node.jsä½¿ç”¨é‡: ${nodeMemoryGB.toFixed(2)} GB (${percentage}%)`);
  
  if (percentage > 50) {
    console.log(`\nâš ï¸  è­¦å‘Š: Node.jsãƒ—ãƒ­ã‚»ã‚¹ãŒç·ãƒ¡ãƒ¢ãƒªã®50%ä»¥ä¸Šã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™`);
    console.log(`   æ¨å¥¨: pnpm dev:low-memory ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„`);
  } else if (percentage > 30) {
    console.log(`\nğŸ’¡ ãƒ’ãƒ³ãƒˆ: ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒé«˜ã„ã§ã™ã€‚å¿…è¦ã«å¿œã˜ã¦ pnpm dev:low-memory ã‚’æ¤œè¨ã—ã¦ãã ã•ã„`);
  } else {
    console.log(`\nâœ… ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã¯æ­£å¸¸ç¯„å›²å†…ã§ã™`);
  }
}

console.log('\nğŸ“ ãƒ¡ãƒ¢ãƒªæœ€é©åŒ–ã‚³ãƒãƒ³ãƒ‰:');
console.log('   pnpm dev:low-memory        - ãƒ¡ãƒ¢ãƒªåˆ¶é™ä»˜ãã§é–‹ç™ºã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•');
console.log('   pnpm dev:no-prisma-sync    - Prisma syncãªã—ã§èµ·å‹•');
console.log('   pnpm dev:memory-check      - ã“ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’å®Ÿè¡Œ');
````

## File: scripts/diagnose.sh
````bash
#!/bin/bash

# Troubleshooting Script for MyCats Development Environment
# This script helps diagnose common issues

echo "ğŸ”§ MyCats Development Environment Troubleshooter"
echo "================================================="
echo ""

# Check Node.js version
echo "ğŸ“¦ Node.js Version:"
node --version
echo ""

# Check pnpm availability
echo "ğŸ“¦ pnpm Availability:"
if command -v pnpm &> /dev/null; then
  pnpm --version
else
  echo "âŒ pnpm not found. Install with: npm install -g pnpm"
fi
echo ""

# Check PostgreSQL status
echo "ğŸ—„ï¸  PostgreSQL Status:"
if command -v pg_isready &> /dev/null; then
  if pg_isready -h localhost -p 5432 > /dev/null 2>&1; then
    echo "âœ… PostgreSQL is running"
  else
    echo "âŒ PostgreSQL is not running or not accessible"
    echo "   Start with: sudo systemctl start postgresql (Linux) or brew services start postgresql (macOS)"
  fi
else
  echo "âŒ PostgreSQL not found. Install PostgreSQL."
fi
echo ""

# Check for environment file
echo "âš™ï¸  Environment Configuration:"
if [ -f "backend/.env" ]; then
  echo "âœ… backend/.env found"
  # Test database connection if DATABASE_URL exists
  if grep -q "DATABASE_URL" backend/.env; then
    DATABASE_URL=$(grep DATABASE_URL backend/.env | cut -d '=' -f 2 | tr -d '"')
    if psql "$DATABASE_URL" -c "SELECT 1;" > /dev/null 2>&1; then
      echo "âœ… Database connection successful"
    else
      echo "âŒ Database connection failed"
      echo "   Check DATABASE_URL in backend/.env"
    fi
  fi
else
  echo "âŒ backend/.env not found"
  echo "   Copy from backend/.env.example and configure"
fi
echo ""

# Check port availability
echo "ğŸŒ Port Availability:"
check_port() {
  local port=$1
  if lsof -i :$port > /dev/null 2>&1; then
    echo "âŒ Port $port is in use"
    echo "   Process: $(lsof -i :$port | tail -n 1 | awk '{print $2}' | xargs ps -p | tail -n 1)"
  else
    echo "âœ… Port $port is available"
  fi
}

check_port 3000
check_port 3004
echo ""

# Check dependencies
echo "ğŸ“¦ Dependencies Status:"
if [ -d "node_modules" ]; then
  echo "âœ… Root dependencies installed"
else
  echo "âŒ Root dependencies missing. Run: pnpm install"
fi

if [ -d "backend/node_modules" ]; then
  echo "âœ… Backend dependencies installed"
else
  echo "âŒ Backend dependencies missing"
fi

if [ -d "frontend/node_modules" ]; then
  echo "âœ… Frontend dependencies installed"
else
  echo "âŒ Frontend dependencies missing"
fi
echo ""

# Check Prisma client
echo "ğŸ”§ Prisma Status:"
if [ -d "node_modules/.pnpm/@prisma+client"* ] 2>/dev/null; then
  echo "âœ… Prisma client generated"
else
  echo "âŒ Prisma client not generated. Run: pnpm run db:generate"
fi

# Check if migrations are applied
cd backend 2>/dev/null
if [ -f ".env" ]; then
  # Load env vars and check migration status
  set -a; source .env; set +a
  if npx prisma migrate status > /dev/null 2>&1; then
    echo "âœ… Database migrations up to date"
  else
    echo "âŒ Database migrations pending. Run: pnpm run db:migrate"
  fi
fi
cd ..
echo ""

# Quick fixes section
echo "ğŸš€ Quick Fixes:"
echo "   1. Install all dependencies:   pnpm install"
echo "   2. Generate Prisma client:     pnpm run db:generate"
echo "   3. Run migrations:             pnpm run db:migrate"
echo "   4. Kill ports in use:          pnpm run predev"
echo "   5. Start development servers:  pnpm run dev"
echo "   6. Full setup from scratch:    pnpm run setup"
echo ""

echo "ğŸ“š Documentation:"
echo "   - docs/README.md: Documentation index"
echo "   - docs/functional-blueprint.md: UI/API/DB overview"
echo "   - docs/troubleshooting.md: Detailed troubleshooting"
````

## File: scripts/export-cats-seed.ps1
````powershell
# åœ¨èˆçŒ«ãƒ‡ãƒ¼ã‚¿ã‚’ã‚·ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ã‚¹ã‚¯ãƒªãƒ—ãƒˆ (PowerShell)

$ErrorActionPreference = "Stop"

# ç’°å¢ƒå¤‰æ•°ã®è¨­å®š
$env:PGPASSWORD = "mycats_dev_password"
$DB_HOST = "localhost"
$DB_PORT = "5433"
$DB_NAME = "mycats_development"
$DB_USER = "mycats"
$OUTPUT_FILE = "..\backend\prisma\seed-cats-data.sql"

Write-Host "ğŸ”„ åœ¨èˆçŒ«ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆä¸­..." -ForegroundColor Cyan

# ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’æ›¸ãè¾¼ã¿
@"
-- åœ¨èˆçŒ«ãƒ‡ãƒ¼ã‚¿ã®ã‚·ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ (è‡ªå‹•ç”Ÿæˆ: $(Get-Date -Format "yyyy-MM-dd HH:mm:ss"))
-- ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ç¾åœ¨ã®åœ¨èˆçŒ«ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ç”Ÿæˆã•ã‚Œã¾ã—ãŸ

"@ | Out-File -FilePath $OUTPUT_FILE -Encoding UTF8

# å“ç¨®ãƒ‡ãƒ¼ã‚¿ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
Write-Host "ğŸ“¦ å“ç¨®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆä¸­..." -ForegroundColor Yellow
$breedQuery = @"
SELECT 
  'INSERT INTO "breeds" ("id", "name", "description", "createdAt", "updatedAt") VALUES (' ||
  quote_literal(id) || ', ' || quote_literal(name) || ', ' || 
  COALESCE(quote_literal(description), 'NULL') || ', ' || 
  quote_literal("createdAt"::text) || ', ' ||
  quote_literal("updatedAt"::text) || ');'
FROM breeds
WHERE id IN (SELECT DISTINCT "breedId" FROM cats WHERE "isInHouse" = true AND "breedId" IS NOT NULL)
ORDER BY name;
"@

"-- å“ç¨®ãƒ‡ãƒ¼ã‚¿" | Add-Content -Path $OUTPUT_FILE -Encoding UTF8
psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME -t -A -c $breedQuery | Add-Content -Path $OUTPUT_FILE -Encoding UTF8
"" | Add-Content -Path $OUTPUT_FILE -Encoding UTF8

# æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
Write-Host "ğŸ¨ æ¯›è‰²ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆä¸­..." -ForegroundColor Yellow
$colorQuery = @"
SELECT 
  'INSERT INTO "coat_colors" ("id", "name", "description", "createdAt", "updatedAt") VALUES (' ||
  quote_literal(id) || ', ' || quote_literal(name) || ', ' || 
  COALESCE(quote_literal(description), 'NULL') || ', ' || 
  quote_literal("createdAt"::text) || ', ' ||
  quote_literal("updatedAt"::text) || ');'
FROM coat_colors
WHERE id IN (SELECT DISTINCT "coatColorId" FROM cats WHERE "isInHouse" = true AND "coatColorId" IS NOT NULL)
ORDER BY name;
"@

"-- æ¯›è‰²ãƒ‡ãƒ¼ã‚¿" | Add-Content -Path $OUTPUT_FILE -Encoding UTF8
psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME -t -A -c $colorQuery | Add-Content -Path $OUTPUT_FILE -Encoding UTF8
"" | Add-Content -Path $OUTPUT_FILE -Encoding UTF8

# åœ¨èˆçŒ«ãƒ‡ãƒ¼ã‚¿ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
Write-Host "ğŸ± åœ¨èˆçŒ«ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆä¸­..." -ForegroundColor Yellow
$catsQuery = @"
SELECT 
  'INSERT INTO "cats" ("id", "name", "gender", "birthDate", "breedId", "coatColorId", ' ||
  '"microchipNumber", "registrationNumber", "description", "isInHouse", "adoptedAt", ' ||
  '"deathDate", "fatherId", "motherId", "ownerId", "createdAt", "updatedAt") VALUES (' ||
  quote_literal(id) || ', ' || 
  quote_literal(name) || ', ' || 
  quote_literal(gender) || ', ' || 
  quote_literal("birthDate"::text) || ', ' || 
  COALESCE(quote_literal("breedId"), 'NULL') || ', ' || 
  COALESCE(quote_literal("coatColorId"), 'NULL') || ', ' || 
  COALESCE(quote_literal("microchipNumber"), 'NULL') || ', ' || 
  COALESCE(quote_literal("registrationNumber"), 'NULL') || ', ' || 
  COALESCE(quote_literal(description), 'NULL') || ', ' || 
  "isInHouse"::text || ', ' || 
  COALESCE(quote_literal("adoptedAt"::text), 'NULL') || ', ' || 
  COALESCE(quote_literal("deathDate"::text), 'NULL') || ', ' || 
  COALESCE(quote_literal("fatherId"), 'NULL') || ', ' || 
  COALESCE(quote_literal("motherId"), 'NULL') || ', ' || 
  quote_literal("ownerId") || ', ' || 
  quote_literal("createdAt"::text) || ', ' ||
  quote_literal("updatedAt"::text) || ') ON CONFLICT (id) DO NOTHING;'
FROM cats
WHERE "isInHouse" = true
ORDER BY name;
"@

"-- åœ¨èˆçŒ«ãƒ‡ãƒ¼ã‚¿" | Add-Content -Path $OUTPUT_FILE -Encoding UTF8
psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME -t -A -c $catsQuery | Add-Content -Path $OUTPUT_FILE -Encoding UTF8

Write-Host ""
Write-Host "âœ… ã‚·ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãŒå®Œäº†ã—ã¾ã—ãŸ: $OUTPUT_FILE" -ForegroundColor Green
Write-Host ""
Write-Host "ğŸ“ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—:" -ForegroundColor Cyan
Write-Host "   1. backend/prisma/seed-cats-data.sql ã‚’ç¢ºèª"
Write-Host "   2. docker-compose.yml ã® database/init ã«ã‚³ãƒ”ãƒ¼"
Write-Host "   3. Macã§docker-compose upã‚’å®Ÿè¡Œ"
````

## File: scripts/generate-secrets.ts
````typescript
#!/usr/bin/env tsx

import { randomBytes } from 'crypto';

const SECTION_SEPARATOR = '-'.repeat(60);

const generateBase64Secret = (bytes: number): string => randomBytes(bytes).toString('base64');

const generateAlphanumericSecret = (length: number): string => {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  const randomBuffer = randomBytes(length);

  let result = '';
  for (let i = 0; i < length; i += 1) {
    result += chars[randomBuffer[i] % chars.length];
  }
  return result;
};

const printHeading = (): void => {
  console.log('ğŸ” MyCats Pro - ã‚»ã‚­ãƒ¥ã‚¢ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆç”Ÿæˆ');
  console.log('='.repeat(SECTION_SEPARATOR.length));
  console.log('\nä»¥ä¸‹ã®å€¤ã‚’ .env ãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚³ãƒ”ãƒ¼ã—ã¦ãã ã•ã„ (Git ç®¡ç†ç¦æ­¢)\n');
};

const printSecretBlock = (title: string, secrets: Array<{ key: string; value: string }>): void => {
  console.log(SECTION_SEPARATOR);
  console.log(`\n# ${title}`);
  secrets.forEach((secret) => {
    console.log(`${secret.key}="${secret.value}"`);
  });
  console.log('');
};

const printNotes = (): void => {
  console.log(SECTION_SEPARATOR);
  console.log('\nğŸ“ æ³¨æ„äº‹é …:');
  console.log('  - JWT_SECRET ã¨ JWT_REFRESH_SECRET ã¯å¿…ãšç•°ãªã‚‹å€¤ã«ã—ã¦ãã ã•ã„');
  console.log('  - CSRF_TOKEN_SECRET ã‚‚åŒæ§˜ã«ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªå€¤ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„');
  console.log('  - æœ¬ç•ªç’°å¢ƒã®ç’°å¢ƒå¤‰æ•°ã¯å¿…ãš Secrets Manager ç­‰ã§å®‰å…¨ã«ç®¡ç†ã—ã¦ãã ã•ã„');
  console.log('  - å€¤ã¯å…±æœ‰ã—ãªã„ & å®šæœŸçš„ãªãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ¨å¥¨ã—ã¾ã™');
  console.log('');
};

const main = (): void => {
  printHeading();

  printSecretBlock('JWT ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆ (Base64 / 48 bytes)', [
    { key: 'JWT_SECRET', value: generateBase64Secret(48) },
    { key: 'JWT_REFRESH_SECRET', value: generateBase64Secret(48) },
  ]);

  printSecretBlock('CSRF ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆ (Base64 / 48 bytes)', [
    { key: 'CSRF_TOKEN_SECRET', value: generateBase64Secret(48) },
  ]);

  printSecretBlock('è‹±æ•°å­—ã®ã¿ã‚’ä½¿ç”¨ã—ãŸã„å ´åˆ (64 chars)', [
    { key: '# JWT_SECRET', value: generateAlphanumericSecret(64) },
    { key: '# JWT_REFRESH_SECRET', value: generateAlphanumericSecret(64) },
    { key: '# CSRF_TOKEN_SECRET', value: generateAlphanumericSecret(64) },
  ]);

  printNotes();
};

try {
  main();
} catch (error) {
  console.error('âŒ ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ:', error);
  process.exit(1);
}
````

## File: scripts/health-check.sh
````bash
#!/bin/bash

# Health Check Script for Development Servers

echo "ğŸ¥ MyCats Development Servers Health Check"
echo "=========================================="
echo ""

check_service() {
  local name=$1
  local url=$2
  local pid_file=$3
  
  echo "Checking $name..."
  
  # Check if PID file exists
  if [ -f "$pid_file" ]; then
    PID=$(cat "$pid_file")
    if ps -p $PID > /dev/null 2>&1; then
      echo "  âœ… Process running (PID: $PID)"
    else
      echo "  âŒ PID file exists but process not running"
      return 1
    fi
  else
    echo "  âš ï¸  No PID file found"
  fi
  
  # Check if service responds
  if curl -s "$url" > /dev/null 2>&1; then
    echo "  âœ… Service responding at $url"
    return 0
  else
    echo "  âŒ Service not responding at $url"
    return 1
  fi
}

cd "$(dirname "$0")/.."

echo "Backend Server:"
check_service "Backend" "http://localhost:3004/health" "backend.pid"
BACKEND_STATUS=$?

echo ""
echo "Frontend Server:"
check_service "Frontend" "http://localhost:3000" "frontend.pid"
FRONTEND_STATUS=$?

echo ""
echo "=========================================="
if [ $BACKEND_STATUS -eq 0 ] && [ $FRONTEND_STATUS -eq 0 ]; then
  echo "âœ… All services are healthy"
  exit 0
else
  echo "âŒ Some services are not healthy"
  echo ""
  echo "To restart servers:"
  echo "  ./scripts/stop-dev.sh"
  echo "  ./scripts/start-dev-stable.sh"
  exit 1
fi
````

## File: scripts/kill-backend.sh
````bash
#!/usr/bin/env bash
set -euo pipefail

PORT="3004"

if [ "${1:-}" != "" ]; then
  PORT="$1"
fi

echo "[kill-backend] Checking processes listening on :$PORT" >&2
if command -v lsof >/dev/null 2>&1; then
  PIDS=$(lsof -t -iTCP:"$PORT" -sTCP:LISTEN || true)
else
  echo "lsof ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“" >&2
  exit 1
fi

if [ -z "${PIDS}" ]; then
  echo "[kill-backend] No process is listening on :$PORT" >&2
  exit 0
fi

echo "[kill-backend] Found PIDs: $PIDS" >&2
for PID in $PIDS; do
  echo "[kill-backend] Sending SIGTERM to $PID" >&2
  kill "$PID" 2>/dev/null || true
done

sleep 1

LEFT=$(lsof -t -iTCP:"$PORT" -sTCP:LISTEN || true)
if [ -n "$LEFT" ]; then
  echo "[kill-backend] Still alive: $LEFT -> SIGKILL" >&2
  kill -9 $LEFT 2>/dev/null || true
else
  echo "[kill-backend] Successfully freed :$PORT" >&2
fi

exit 0
````

## File: scripts/local-postgres.sh
````bash
#!/usr/bin/env bash
# Local isolated PostgreSQL cluster manager for development
# Creates a private cluster under .dev/postgres using port 55432 (not to clash with system 5432)
# Usage: scripts/local-postgres.sh [start|stop|status|psql]
set -euo pipefail

BASE_DIR="$(cd "$(dirname "$0")/.." && pwd)"
DATA_DIR="${BASE_DIR}/.dev/postgres/data"
LOG_FILE="${BASE_DIR}/.dev/postgres/postgres.log"
PORT=55432
ROLE=runner
PASSWORD=password
DB=mycats_development

cyan() { printf "\033[36m%s\033[0m\n" "$*"; }
err() { printf "\033[31m%s\033[0m\n" "$*" 1>&2; }

ensure_tools() {
  for c in initdb pg_ctl psql createdb createuser; do
    command -v "$c" >/dev/null 2>&1 || { err "Required command '$c' not found. On macOS: brew install postgresql@15 (and add its bin to PATH)."; exit 1; }
  done
}

init_cluster() {
  if [ ! -d "$DATA_DIR" ]; then
    cyan "Initializing cluster in $DATA_DIR"
    mkdir -p "$(dirname "$DATA_DIR")"
    initdb -D "$DATA_DIR" >/dev/null
    # postgresql.conf tweak: custom port
    echo "port = ${PORT}" >> "$DATA_DIR/postgresql.conf"
  fi
}

start() {
  ensure_tools
  init_cluster
  if pg_isready -h localhost -p ${PORT} >/dev/null 2>&1; then
    cyan "PostgreSQL already running on port ${PORT}"; return 0; fi
  cyan "Starting PostgreSQL (port ${PORT})"
  pg_ctl -D "$DATA_DIR" -l "$LOG_FILE" start
  # Wait until ready
  for i in {1..20}; do
    if pg_isready -h localhost -p ${PORT} >/dev/null 2>&1; then break; fi
    sleep 0.3
  done
  if ! pg_isready -h localhost -p ${PORT} >/dev/null 2>&1; then
    err "Failed to start PostgreSQL (see $LOG_FILE)"; exit 1; fi
  cyan "PostgreSQL started (log: $LOG_FILE)"
  bootstrap
}

bootstrap() {
  # Fresh cluster: trust auth allows connecting without specifying -U.
  # Create role if missing
  if ! psql -h localhost -p ${PORT} -d template1 -tAc "SELECT 1 FROM pg_roles WHERE rolname='${ROLE}'" | grep -q 1; then
    cyan "Creating role ${ROLE}"
    psql -h localhost -p ${PORT} -d template1 -c "CREATE ROLE ${ROLE} WITH LOGIN PASSWORD '${PASSWORD}' CREATEDB;" >/dev/null
  fi
  # Create database if missing
  if ! psql -h localhost -p ${PORT} -d template1 -tAc "SELECT 1 FROM pg_database WHERE datname='${DB}'" | grep -q 1; then
    cyan "Creating database ${DB} (owner ${ROLE})"
    psql -h localhost -p ${PORT} -d template1 -c "CREATE DATABASE ${DB} OWNER ${ROLE};" >/dev/null
  fi
  cyan "Bootstrap complete. Connection URL: postgresql://${ROLE}:${PASSWORD}@localhost:${PORT}/${DB}"
}

stop_cluster() {
  if [ -d "$DATA_DIR" ]; then
    if pg_isready -h localhost -p ${PORT} >/dev/null 2>&1; then
      cyan "Stopping PostgreSQL (port ${PORT})"
      pg_ctl -D "$DATA_DIR" stop -m fast || true
    else
      cyan "Cluster not running."
    fi
  else
    cyan "No cluster directory ($DATA_DIR)"
  fi
}

status() {
  if pg_isready -h localhost -p ${PORT} >/dev/null 2>&1; then
    cyan "RUNNING on port ${PORT}"; else cyan "STOPPED (expected port ${PORT})"; fi
}

psql_shell() {
  psql "postgresql://${ROLE}:${PASSWORD}@localhost:${PORT}/${DB}" "$@"
}

case "${1:-}" in
  start) start ;;
  stop) stop_cluster ;;
  status) status ;;
  psql) shift; psql_shell "$@" ;;
  *) echo "Usage: $0 {start|stop|status|psql}"; exit 1 ;;
 esac
````

## File: scripts/preflight-backend.sh
````bash
#!/usr/bin/env bash
set -euo pipefail

WAIT=false
for arg in "$@"; do
  case "$arg" in
    --wait) WAIT=true ;;
  esac
done

echo "[preflight] Backend preflight checks starting..."

PORT=${PORT:-3004}
DB_URL=${DATABASE_URL:-}

if [ ! -f backend/.env ]; then
  echo "[preflight] WARNING: backend/.env ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ (backend/.env.example) ã‹ã‚‰ä½œæˆã—ã¦ãã ã•ã„" >&2
fi

# æ—¢å­˜ãƒ—ãƒ­ã‚»ã‚¹ã®æ®‹éª¸å¾…æ©Ÿ (watch å†èµ·å‹•ç›´å¾Œãªã©)
ATTEMPTS=0
MAX_ATTEMPTS=10
SLEEP=0.3
while lsof -nP -iTCP:"$PORT" -sTCP:LISTEN >/dev/null 2>&1; do
  if [ "$WAIT" = false ]; then
    echo "[preflight] ERROR: Port $PORT is already in use (use --wait toå¾…æ©Ÿ)" >&2
    exit 2
  fi
  ATTEMPTS=$((ATTEMPTS+1))
  if [ $ATTEMPTS -ge $MAX_ATTEMPTS ]; then
    echo "[preflight] ERROR: Port $PORT is still busy after $MAX_ATTEMPTS attempts" >&2
    exit 2
  fi
  echo "[preflight] Port $PORT busy -> waiting ($ATTEMPTS/$MAX_ATTEMPTS)" >&2
  sleep $SLEEP
done
echo "[preflight] Port $PORT is free"

if [ -z "$DB_URL" ]; then
  if grep -q '^DATABASE_URL=' backend/.env 2>/dev/null; then
    echo "[preflight] DATABASE_URL detected in backend/.env"
  else
    echo "[preflight] WARNING: DATABASE_URL ãŒæœªè¨­å®š" >&2
  fi
else
  echo "[preflight] DATABASE_URL provided via environment"
fi

echo "[preflight] Running prisma generate (idempotent)" 
pnpm --filter backend run prisma:generate >/dev/null 2>&1 || echo "[preflight] prisma generate skipped/error"

echo "[preflight] OK"
````

## File: scripts/prestart-migrate.sh
````bash
#!/usr/bin/env bash
set -euo pipefail

echo "[prestart] Running prisma migrate deploy..." >&2
pnpm --filter backend prisma:deploy
echo "[prestart] Migration deploy completed." >&2
````

## File: scripts/quick-start.sh
````bash
#!/usr/bin/env bash
# Quick start script for strategy A (use existing PostgreSQL on port 5432)
# Idempotent: safe to re-run. Only creates role/DB if missing.
set -euo pipefail

print() { printf "\033[36m[quick-start]\033[0m %s\n" "$*"; }
err() { printf "\033[31m[error]\033[0m %s\n" "$*" 1>&2; }

REQUIRED_PORT=5432
ROLE=runner
PASSWORD=password
DB=mycats_development
ENV_FILE=backend/.env

print "Checking pg_isready on port ${REQUIRED_PORT}..."
if ! command -v pg_isready >/dev/null 2>&1; then
  err "pg_isready command not found. Ensure PostgreSQL client tools are installed (brew install libpq && echo 'export PATH=\"/opt/homebrew/opt/libpq/bin:$PATH\"' >> ~/.zshrc)."; exit 1; fi

if ! pg_isready -h localhost -p ${REQUIRED_PORT} >/dev/null 2>&1; then
  err "PostgreSQL not accepting connections on port ${REQUIRED_PORT}. Start it: 'brew services start postgresql@15' (or adjust port)."; exit 1; fi
print "PostgreSQL is reachable."

print "Ensuring role '${ROLE}' exists..."
if ! psql -U postgres -tAc "SELECT 1 FROM pg_roles WHERE rolname='${ROLE}'" | grep -q 1; then
  psql -U postgres -c "CREATE ROLE ${ROLE} WITH LOGIN PASSWORD '${PASSWORD}' CREATEDB;"
  print "Role created."
else
  print "Role already present."
fi

print "Ensuring database '${DB}' exists owned by '${ROLE}'..."
if ! psql -U postgres -tAc "SELECT 1 FROM pg_database WHERE datname='${DB}'" | grep -q 1; then
  createdb -U postgres -O ${ROLE} ${DB}
  print "Database created."
else
  OWNER=$(psql -U postgres -tAc "SELECT pg_catalog.pg_get_userbyid(datdba) FROM pg_database WHERE datname='${DB}'")
  if [ "${OWNER}" != " ${ROLE}" ] && [ "${OWNER}" != "${ROLE}" ]; then
    print "Database exists with owner '${OWNER}'. (Leave as-is unless you need ownership change)"
  else
    print "Database already present."
  fi
fi

print "Creating '${ENV_FILE}' if missing..."
if [ ! -f "${ENV_FILE}" ]; then
  cat > "${ENV_FILE}" <<EOF
DATABASE_URL="postgresql://${ROLE}:${PASSWORD}@localhost:${REQUIRED_PORT}/${DB}"
JWT_SECRET="development-jwt-secret-at-least-32-characters-long-for-security"
JWT_EXPIRES_IN="1h"
NODE_ENV="development"
PORT=3004
CORS_ORIGIN="http://localhost:3000"
BCRYPT_ROUNDS=10
THROTTLE_TTL=60000
THROTTLE_LIMIT=100
LOG_LEVEL=debug
HEALTH_CHECK_DATABASE=true
HEALTH_CHECK_MEMORY_THRESHOLD=0.9
SESSION_SECRET="development-session-secret-here"
PRISMA_CLIENT_ENGINE_TYPE="library"
EOF
  print "Created ${ENV_FILE}"
else
  print "${ENV_FILE} already exists (left untouched)."
fi

print "Installing dependencies (pnpm)..."
if ! command -v pnpm >/dev/null 2>&1; then
  err "pnpm not found. Install: 'npm install -g pnpm'"; exit 1; fi
pnpm install

print "Generating Prisma client..."
pnpm run db:generate

print "Applying migrations..."
pnpm run db:migrate

print "(Optional) Seeding database if script exists..."
if pnpm run | grep -q "db:seed"; then
  pnpm run db:seed || print "Seed step failed/skipped (continuing)."
else
  print "No db:seed script defined. Skipping."
fi

print "Starting dev servers (backend + frontend)..."
print "Use Ctrl+C to stop."
exec pnpm run dev
````

## File: scripts/setup-custom-domain.sh
````bash
#!/usr/bin/env bash
#
# GCP Load Balancer & Custom Domain Setup Script
# ã“ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯ nekoya.co.jp ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’GCP Cloud Runã‚µãƒ¼ãƒ“ã‚¹ã«ç´ä»˜ã‘ã¾ã™
#
# å‰ææ¡ä»¶:
# - gcloud CLI ãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ¸ˆã¿
# - æ­£ã—ã„GCPãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿ (my-cats-pro)
# - Cloud Run ã‚µãƒ¼ãƒ“ã‚¹ãŒãƒ‡ãƒ—ãƒ­ã‚¤æ¸ˆã¿

set -euo pipefail

# ã‚«ãƒ©ãƒ¼å‡ºåŠ›ç”¨
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¨­å®š
PROJECT_ID="my-cats-pro"
REGION="asia-northeast1"
DOMAIN="nekoya.co.jp"
API_DOMAIN="api.nekoya.co.jp"
WWW_DOMAIN="www.nekoya.co.jp"

# Cloud Runã‚µãƒ¼ãƒ“ã‚¹å
BACKEND_SERVICE="mycats-pro-backend"
FRONTEND_SERVICE="mycats-pro-frontend"

# ãƒªã‚½ãƒ¼ã‚¹å
STATIC_IP_NAME="mycats-pro-lb-ip"
SSL_CERT_NAME="mycats-ssl-cert"
FRONTEND_NEG="mycats-frontend-neg"
BACKEND_NEG="mycats-backend-neg"
FRONTEND_BACKEND_SVC="mycats-frontend-backend"
BACKEND_BACKEND_SVC="mycats-backend-backend"
URL_MAP="mycats-lb-urlmap"
HTTPS_PROXY="mycats-https-proxy"
HTTP_PROXY="mycats-http-proxy"
HTTP_REDIRECT_MAP="mycats-http-redirect"
HTTPS_FWD_RULE="mycats-https-forwarding-rule"
HTTP_FWD_RULE="mycats-http-forwarding-rule"

# ãƒ­ã‚°é–¢æ•°
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç¢ºèª
check_project() {
    log_info "ç¾åœ¨ã®GCPãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ç¢ºèªä¸­..."
    CURRENT_PROJECT=$(gcloud config get-value project 2>/dev/null || echo "")
    
    if [ "$CURRENT_PROJECT" != "$PROJECT_ID" ]; then
        log_warning "ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãŒ $PROJECT_ID ã«è¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“"
        log_info "ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ $PROJECT_ID ã«åˆ‡ã‚Šæ›¿ãˆã¾ã™"
        gcloud config set project "$PROJECT_ID"
    fi
    
    log_success "ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ: $PROJECT_ID"
}

# Cloud Runã‚µãƒ¼ãƒ“ã‚¹ã®å­˜åœ¨ç¢ºèª
check_cloud_run_services() {
    log_info "Cloud Runã‚µãƒ¼ãƒ“ã‚¹ã®å­˜åœ¨ã‚’ç¢ºèªä¸­..."
    
    if ! gcloud run services describe "$BACKEND_SERVICE" --region="$REGION" &>/dev/null; then
        log_error "ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒ“ã‚¹ $BACKEND_SERVICE ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
        exit 1
    fi
    
    if ! gcloud run services describe "$FRONTEND_SERVICE" --region="$REGION" &>/dev/null; then
        log_error "ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒ“ã‚¹ $FRONTEND_SERVICE ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
        exit 1
    fi
    
    log_success "Cloud Runã‚µãƒ¼ãƒ“ã‚¹ãŒç¢ºèªã•ã‚Œã¾ã—ãŸ"
}

# ã‚¹ãƒ†ãƒƒãƒ—1: é™çš„IPã‚¢ãƒ‰ãƒ¬ã‚¹ã®äºˆç´„
reserve_static_ip() {
    log_info "ã‚¹ãƒ†ãƒƒãƒ—1: é™çš„IPã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’äºˆç´„ä¸­..."
    
    if gcloud compute addresses describe "$STATIC_IP_NAME" --global &>/dev/null; then
        log_warning "é™çš„IPã‚¢ãƒ‰ãƒ¬ã‚¹ $STATIC_IP_NAME ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™"
        STATIC_IP=$(gcloud compute addresses describe "$STATIC_IP_NAME" --global --format="get(address)")
    else
        gcloud compute addresses create "$STATIC_IP_NAME" \
            --ip-version=IPV4 \
            --global
        
        STATIC_IP=$(gcloud compute addresses describe "$STATIC_IP_NAME" --global --format="get(address)")
        log_success "é™çš„IPã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’äºˆç´„ã—ã¾ã—ãŸ: $STATIC_IP"
    fi
    
    echo ""
    echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${GREEN}  é™çš„IPã‚¢ãƒ‰ãƒ¬ã‚¹: ${YELLOW}$STATIC_IP${NC}"
    echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
    echo "ãŠåå‰.comã®DNSè¨­å®šã§ä»¥ä¸‹ã®Aãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’è¿½åŠ ã—ã¦ãã ã•ã„:"
    echo ""
    echo "  nekoya.co.jp.     A  3600  $STATIC_IP"
    echo "  www.nekoya.co.jp. A  3600  $STATIC_IP"
    echo "  api.nekoya.co.jp. A  3600  $STATIC_IP"
    echo ""
    read -p "DNSè¨­å®šã‚’å®Œäº†ã—ãŸã‚‰Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„... " -r
}

# ã‚¹ãƒ†ãƒƒãƒ—2: Serverless NEGã®ä½œæˆ
create_serverless_negs() {
    log_info "ã‚¹ãƒ†ãƒƒãƒ—2: Serverless NEGã‚’ä½œæˆä¸­..."
    
    # ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰NEG
    if gcloud compute network-endpoint-groups describe "$FRONTEND_NEG" --region="$REGION" &>/dev/null; then
        log_warning "ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰NEG $FRONTEND_NEG ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™"
    else
        gcloud compute network-endpoint-groups create "$FRONTEND_NEG" \
            --region="$REGION" \
            --network-endpoint-type=SERVERLESS \
            --cloud-run-service="$FRONTEND_SERVICE"
        log_success "ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰NEGã‚’ä½œæˆã—ã¾ã—ãŸ"
    fi
    
    # ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰NEG
    if gcloud compute network-endpoint-groups describe "$BACKEND_NEG" --region="$REGION" &>/dev/null; then
        log_warning "ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰NEG $BACKEND_NEG ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™"
    else
        gcloud compute network-endpoint-groups create "$BACKEND_NEG" \
            --region="$REGION" \
            --network-endpoint-type=SERVERLESS \
            --cloud-run-service="$BACKEND_SERVICE"
        log_success "ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰NEGã‚’ä½œæˆã—ã¾ã—ãŸ"
    fi
}

# ã‚¹ãƒ†ãƒƒãƒ—3: ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒ“ã‚¹ã®ä½œæˆ
create_backend_services() {
    log_info "ã‚¹ãƒ†ãƒƒãƒ—3: ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒ“ã‚¹ã‚’ä½œæˆä¸­..."
    
    # ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒ“ã‚¹
    if gcloud compute backend-services describe "$FRONTEND_BACKEND_SVC" --global &>/dev/null; then
        log_warning "ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒ“ã‚¹ $FRONTEND_BACKEND_SVC ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™"
    else
        gcloud compute backend-services create "$FRONTEND_BACKEND_SVC" \
            --global \
            --load-balancing-scheme=EXTERNAL_MANAGED
        
        gcloud compute backend-services add-backend "$FRONTEND_BACKEND_SVC" \
            --global \
            --network-endpoint-group="$FRONTEND_NEG" \
            --network-endpoint-group-region="$REGION"
        
        log_success "ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒ“ã‚¹ã‚’ä½œæˆã—ã¾ã—ãŸ"
    fi
    
    # ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒ“ã‚¹
    if gcloud compute backend-services describe "$BACKEND_BACKEND_SVC" --global &>/dev/null; then
        log_warning "ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒ“ã‚¹ $BACKEND_BACKEND_SVC ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™"
    else
        gcloud compute backend-services create "$BACKEND_BACKEND_SVC" \
            --global \
            --load-balancing-scheme=EXTERNAL_MANAGED
        
        gcloud compute backend-services add-backend "$BACKEND_BACKEND_SVC" \
            --global \
            --network-endpoint-group="$BACKEND_NEG" \
            --network-endpoint-group-region="$REGION"
        
        log_success "ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒ“ã‚¹ã‚’ä½œæˆã—ã¾ã—ãŸ"
    fi
}

# ã‚¹ãƒ†ãƒƒãƒ—4: URLãƒãƒƒãƒ—ã®ä½œæˆ
create_url_map() {
    log_info "ã‚¹ãƒ†ãƒƒãƒ—4: URLãƒãƒƒãƒ—ã‚’ä½œæˆä¸­..."
    
    if gcloud compute url-maps describe "$URL_MAP" --global &>/dev/null; then
        log_warning "URLãƒãƒƒãƒ— $URL_MAP ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™"
    else
        gcloud compute url-maps create "$URL_MAP" \
            --default-service="$FRONTEND_BACKEND_SVC"
        
        log_success "URLãƒãƒƒãƒ—ã‚’ä½œæˆã—ã¾ã—ãŸ"
    fi
    
    # ãƒ‘ã‚¹ãƒãƒƒãƒãƒ£ãƒ¼ã‚’è¿½åŠ  (api.nekoya.co.jpç”¨)
    log_info "APIç”¨ã®ãƒ›ã‚¹ãƒˆãƒ«ãƒ¼ãƒ«ã‚’è¿½åŠ ä¸­..."
    
    # URLãƒãƒƒãƒ—ã«ãƒ›ã‚¹ãƒˆãƒ«ãƒ¼ãƒ«ã‚’è¿½åŠ 
    gcloud compute url-maps add-host-rule "$URL_MAP" \
        --hosts="$API_DOMAIN" \
        --path-matcher-name=api-matcher \
        --global 2>/dev/null || log_warning "ãƒ›ã‚¹ãƒˆãƒ«ãƒ¼ãƒ«ã¯æ—¢ã«å­˜åœ¨ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™"
    
    gcloud compute url-maps add-path-matcher "$URL_MAP" \
        --path-matcher-name=api-matcher \
        --default-service="$BACKEND_BACKEND_SVC" \
        --global 2>/dev/null || log_warning "ãƒ‘ã‚¹ãƒãƒƒãƒãƒ£ãƒ¼ã¯æ—¢ã«å­˜åœ¨ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™"
    
    log_success "APIãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚’è¨­å®šã—ã¾ã—ãŸ"
}

# ã‚¹ãƒ†ãƒƒãƒ—5: SSLè¨¼æ˜æ›¸ã®ä½œæˆ
create_ssl_certificate() {
    log_info "ã‚¹ãƒ†ãƒƒãƒ—5: Google Managed SSLè¨¼æ˜æ›¸ã‚’ä½œæˆä¸­..."
    
    if gcloud compute ssl-certificates describe "$SSL_CERT_NAME" --global &>/dev/null; then
        log_warning "SSLè¨¼æ˜æ›¸ $SSL_CERT_NAME ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™"
        
        # è¨¼æ˜æ›¸ã®çŠ¶æ…‹ã‚’ç¢ºèª
        CERT_STATUS=$(gcloud compute ssl-certificates describe "$SSL_CERT_NAME" --global --format="get(managed.status)")
        log_info "SSLè¨¼æ˜æ›¸ã®çŠ¶æ…‹: $CERT_STATUS"
    else
        gcloud compute ssl-certificates create "$SSL_CERT_NAME" \
            --domains="$DOMAIN,$WWW_DOMAIN,$API_DOMAIN" \
            --global
        
        log_success "SSLè¨¼æ˜æ›¸ã‚’ä½œæˆã—ã¾ã—ãŸ (ãƒ—ãƒ­ãƒ“ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°ã«ã¯15åˆ†ã€œ24æ™‚é–“ã‹ã‹ã‚Šã¾ã™)"
    fi
}

# ã‚¹ãƒ†ãƒƒãƒ—6: HTTPSãƒ—ãƒ­ã‚­ã‚·ã®ä½œæˆ
create_https_proxy() {
    log_info "ã‚¹ãƒ†ãƒƒãƒ—6: HTTPSãƒ—ãƒ­ã‚­ã‚·ã‚’ä½œæˆä¸­..."
    
    if gcloud compute target-https-proxies describe "$HTTPS_PROXY" --global &>/dev/null; then
        log_warning "HTTPSãƒ—ãƒ­ã‚­ã‚· $HTTPS_PROXY ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™"
    else
        gcloud compute target-https-proxies create "$HTTPS_PROXY" \
            --url-map="$URL_MAP" \
            --ssl-certificates="$SSL_CERT_NAME"
        
        log_success "HTTPSãƒ—ãƒ­ã‚­ã‚·ã‚’ä½œæˆã—ã¾ã—ãŸ"
    fi
}

# ã‚¹ãƒ†ãƒƒãƒ—7: HTTPSè»¢é€ãƒ«ãƒ¼ãƒ«ã®ä½œæˆ
create_https_forwarding_rule() {
    log_info "ã‚¹ãƒ†ãƒƒãƒ—7: HTTPSè»¢é€ãƒ«ãƒ¼ãƒ«ã‚’ä½œæˆä¸­..."
    
    if gcloud compute forwarding-rules describe "$HTTPS_FWD_RULE" --global &>/dev/null; then
        log_warning "HTTPSè»¢é€ãƒ«ãƒ¼ãƒ« $HTTPS_FWD_RULE ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™"
    else
        gcloud compute forwarding-rules create "$HTTPS_FWD_RULE" \
            --global \
            --load-balancing-scheme=EXTERNAL_MANAGED \
            --address="$STATIC_IP_NAME" \
            --target-https-proxy="$HTTPS_PROXY" \
            --ports=443
        
        log_success "HTTPSè»¢é€ãƒ«ãƒ¼ãƒ«ã‚’ä½œæˆã—ã¾ã—ãŸ"
    fi
}

# ã‚¹ãƒ†ãƒƒãƒ—8: HTTP â†’ HTTPS ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ
create_http_redirect() {
    log_info "ã‚¹ãƒ†ãƒƒãƒ—8: HTTP â†’ HTTPS ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã‚’è¨­å®šä¸­..."
    
    # HTTPãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆç”¨URLãƒãƒƒãƒ—
    if gcloud compute url-maps describe "$HTTP_REDIRECT_MAP" --global &>/dev/null; then
        log_warning "HTTPãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆãƒãƒƒãƒ— $HTTP_REDIRECT_MAP ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™"
    else
        cat <<EOF | gcloud compute url-maps import "$HTTP_REDIRECT_MAP" --global --source=-
kind: compute#urlMap
name: $HTTP_REDIRECT_MAP
defaultUrlRedirect:
  httpsRedirect: true
  redirectResponseCode: MOVED_PERMANENTLY_DEFAULT
EOF
        log_success "HTTPãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆãƒãƒƒãƒ—ã‚’ä½œæˆã—ã¾ã—ãŸ"
    fi
    
    # HTTPãƒ—ãƒ­ã‚­ã‚·
    if gcloud compute target-http-proxies describe "$HTTP_PROXY" --global &>/dev/null; then
        log_warning "HTTPãƒ—ãƒ­ã‚­ã‚· $HTTP_PROXY ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™"
    else
        gcloud compute target-http-proxies create "$HTTP_PROXY" \
            --url-map="$HTTP_REDIRECT_MAP"
        log_success "HTTPãƒ—ãƒ­ã‚­ã‚·ã‚’ä½œæˆã—ã¾ã—ãŸ"
    fi
    
    # HTTPè»¢é€ãƒ«ãƒ¼ãƒ«
    if gcloud compute forwarding-rules describe "$HTTP_FWD_RULE" --global &>/dev/null; then
        log_warning "HTTPè»¢é€ãƒ«ãƒ¼ãƒ« $HTTP_FWD_RULE ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™"
    else
        gcloud compute forwarding-rules create "$HTTP_FWD_RULE" \
            --global \
            --load-balancing-scheme=EXTERNAL_MANAGED \
            --address="$STATIC_IP_NAME" \
            --target-http-proxy="$HTTP_PROXY" \
            --ports=80
        log_success "HTTPè»¢é€ãƒ«ãƒ¼ãƒ«ã‚’ä½œæˆã—ã¾ã—ãŸ"
    fi
}

# SSLè¨¼æ˜æ›¸ã®çŠ¶æ…‹ç¢ºèª
check_ssl_status() {
    log_info "SSLè¨¼æ˜æ›¸ã®çŠ¶æ…‹ã‚’ç¢ºèªä¸­..."
    
    CERT_STATUS=$(gcloud compute ssl-certificates describe "$SSL_CERT_NAME" --global --format="get(managed.status)")
    
    if [ "$CERT_STATUS" == "ACTIVE" ]; then
        log_success "SSLè¨¼æ˜æ›¸ãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ã™ âœ…"
    else
        log_warning "SSLè¨¼æ˜æ›¸ã®çŠ¶æ…‹: $CERT_STATUS"
        log_info "DNSä¼æ’­å¾Œã€15åˆ†ã€œ24æ™‚é–“ã§ACTIVEã«ãªã‚Šã¾ã™"
        echo ""
        echo "æ¬¡ã®ã‚³ãƒãƒ³ãƒ‰ã§çŠ¶æ…‹ã‚’ç›£è¦–ã§ãã¾ã™:"
        echo "  watch -n 60 'gcloud compute ssl-certificates describe $SSL_CERT_NAME --global --format=\"get(managed.status)\"'"
    fi
}

# CORSè¨­å®šã®æ›´æ–°æ¡ˆå†…
update_cors_instructions() {
    echo ""
    echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${GREEN}  æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—: Cloud Runç’°å¢ƒå¤‰æ•°ã®æ›´æ–°${NC}"
    echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
    echo "ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®CORSè¨­å®šã‚’æ›´æ–°ã—ã¦ãã ã•ã„:"
    echo ""
    echo "  gcloud run services update $BACKEND_SERVICE \\"
    echo "    --region=$REGION \\"
    echo "    --set-env-vars=\"CORS_ORIGIN=https://$DOMAIN,https://$WWW_DOMAIN\""
    echo ""
    echo "æ¬¡å›ã®ãƒ‡ãƒ—ãƒ­ã‚¤æ™‚ã« cloudbuild.yaml ã§ä»¥ä¸‹ã‚’è¨­å®šã—ã¦ãã ã•ã„:"
    echo "  _NEXT_PUBLIC_API_URL=https://$API_DOMAIN/api/v1"
    echo "  _CORS_ORIGIN=https://$DOMAIN,https://$WWW_DOMAIN"
    echo ""
}

# ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œ
main() {
    echo -e "${BLUE}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "  GCP Load Balancer & Custom Domain Setup"
    echo "  Domain: $DOMAIN"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo -e "${NC}"
    
    check_project
    check_cloud_run_services
    reserve_static_ip
    create_serverless_negs
    create_backend_services
    create_url_map
    create_ssl_certificate
    create_https_proxy
    create_https_forwarding_rule
    create_http_redirect
    check_ssl_status
    update_cors_instructions
    
    echo ""
    log_success "ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãŒå®Œäº†ã—ã¾ã—ãŸ! ğŸ‰"
    echo ""
    echo "å‹•ä½œç¢ºèª:"
    echo "  curl -I https://$DOMAIN"
    echo "  curl -I https://$API_DOMAIN/api/v1/health"
    echo ""
}

# ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œ
main
````

## File: scripts/setup-dev-docker.bat
````batch
@echo off
REM ###############################################
REM MyCats Pro - Windowsç”¨é–‹ç™ºç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
REM Dockerç’°å¢ƒã§ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã€ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã€DBã‚’èµ·å‹•ã—ã¾ã™
REM ###############################################

setlocal enabledelayedexpansion

echo ğŸ± MyCats Pro é–‹ç™ºç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚’é–‹å§‹ã—ã¾ã™...
echo.

REM ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã‚’å–å¾—
set "SCRIPT_DIR=%~dp0"
set "PROJECT_ROOT=%SCRIPT_DIR%.."
cd /d "%PROJECT_ROOT%"

echo ğŸ“ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆ: %PROJECT_ROOT%
echo.

REM 1. ç’°å¢ƒå¤‰æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã®ç¢ºèª
echo [1/5] ç’°å¢ƒå¤‰æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç¢ºèªä¸­...

if not exist "backend\.env" (
    echo âš ï¸  backend\.env ãŒå­˜åœ¨ã—ã¾ã›ã‚“ã€‚ä½œæˆã—ã¾ã™...
    copy ".env.development" "backend\.env"
    echo âœ“ backend\.env ã‚’ä½œæˆã—ã¾ã—ãŸ
) else (
    echo âœ“ backend\.env ãŒå­˜åœ¨ã—ã¾ã™
)

if not exist "frontend\.env.local" (
    echo âš ï¸  frontend\.env.local ãŒå­˜åœ¨ã—ã¾ã›ã‚“ã€‚ä½œæˆã—ã¾ã™...
    (
        echo # ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ç’°å¢ƒå¤‰æ•° ^(é–‹ç™ºç’°å¢ƒ^)
        echo NEXT_PUBLIC_API_URL=http://localhost:3004
        echo NEXT_PUBLIC_ENV=development
    ) > "frontend\.env.local"
    echo âœ“ frontend\.env.local ã‚’ä½œæˆã—ã¾ã—ãŸ
) else (
    echo âœ“ frontend\.env.local ãŒå­˜åœ¨ã—ã¾ã™
)

echo.

REM 2. Docker Composeã§ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’èµ·å‹•
echo [2/5] Docker Compose ã§ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’èµ·å‹•ä¸­...

REM æ—¢å­˜ã®ã‚³ãƒ³ãƒ†ãƒŠã‚’åœæ­¢ï¼ˆã‚ã‚Œã°ï¼‰
docker ps -a -q -f name=mycats_postgres >nul 2>&1
if not errorlevel 1 (
    echo æ—¢å­˜ã® mycats_postgres ã‚³ãƒ³ãƒ†ãƒŠã‚’åœæ­¢ã—ã¾ã™...
    docker-compose down
)

REM ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’èµ·å‹•
docker-compose up -d postgres

echo PostgreSQL ã®èµ·å‹•ã‚’å¾…æ©Ÿä¸­...
timeout /t 5 /nobreak >nul

REM ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
set /a RETRY_COUNT=0
set /a MAX_RETRIES=30

:HEALTHCHECK_LOOP
docker exec mycats_postgres pg_isready -U mycats -d mycats_development >nul 2>&1
if not errorlevel 1 (
    echo âœ“ PostgreSQL ãŒèµ·å‹•ã—ã¾ã—ãŸ
    goto :HEALTHCHECK_DONE
)

set /a RETRY_COUNT+=1
if %RETRY_COUNT% geq %MAX_RETRIES% (
    echo âŒ PostgreSQL ã®èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ
    exit /b 1
)

echo PostgreSQL ã®èµ·å‹•ã‚’å¾…æ©Ÿä¸­... ^(%RETRY_COUNT%/%MAX_RETRIES%^)
timeout /t 2 /nobreak >nul
goto :HEALTHCHECK_LOOP

:HEALTHCHECK_DONE
echo.

REM 3. ä¾å­˜é–¢ä¿‚ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
echo [3/5] ä¾å­˜é–¢ä¿‚ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ä¸­...

if not exist "node_modules" (
    echo ãƒ«ãƒ¼ãƒˆã®ä¾å­˜é–¢ä¿‚ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«...
    call pnpm install
)

if not exist "backend\node_modules" (
    echo ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®ä¾å­˜é–¢ä¿‚ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«...
    cd backend
    call pnpm install
    cd ..
)

if not exist "frontend\node_modules" (
    echo ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®ä¾å­˜é–¢ä¿‚ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«...
    cd frontend
    call pnpm install
    cd ..
)

echo âœ“ ä¾å­˜é–¢ä¿‚ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãŒå®Œäº†ã—ã¾ã—ãŸ
echo.

REM 4. Prisma ã®åˆæœŸåŒ–
echo [4/5] Prisma ã‚’åˆæœŸåŒ–ä¸­...
cd backend

echo Prisma Client ã‚’ç”Ÿæˆ...
call pnpm prisma:generate

echo ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œ...
call pnpm prisma:migrate

echo ã‚·ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã‚’æŠ•å…¥...
call pnpm run seed 2>nul || echo âš ï¸  ã‚·ãƒ¼ãƒ‰ã®å®Ÿè¡Œã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆæ—¢ã«ãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ï¼‰

cd ..
echo âœ“ Prisma ã®åˆæœŸåŒ–ãŒå®Œäº†ã—ã¾ã—ãŸ
echo.

REM 5. å®Œäº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
echo ========================================
echo ğŸ‰ ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãŒå®Œäº†ã—ã¾ã—ãŸï¼
echo ========================================
echo.
echo ğŸ“ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—:
echo.
echo   ã€ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚’èµ·å‹•ã€‘
echo   $ cd backend
echo   $ pnpm run start:dev
echo.
echo   ã€ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚’èµ·å‹•ï¼ˆåˆ¥ã®ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã§ï¼‰ã€‘
echo   $ cd frontend
echo   $ pnpm run dev
echo.
echo   ã¾ãŸã¯ã€ä¸¦åˆ—èµ·å‹•ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ä½¿ç”¨:
echo   $ pnpm run dev
echo.
echo   ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’åœæ­¢ã€‘
echo   $ docker-compose down
echo.
echo ğŸŒ ã‚¢ã‚¯ã‚»ã‚¹ URL:
echo   - ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰: http://localhost:3000
echo   - ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰API: http://localhost:3004
echo   - pgAdmin: http://localhost:5050
echo.
echo ğŸ“Š ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šæƒ…å ±:
echo   - Host: localhost
echo   - Port: 5433
echo   - Database: mycats_development
echo   - User: mycats
echo   - Password: mycats_dev_password
echo.

endlocal
````

## File: scripts/setup-dev-docker.sh
````bash
#!/bin/bash

###############################################
# MyCats Pro - é–‹ç™ºç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
# Dockerç’°å¢ƒã§ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã€ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã€DBã‚’èµ·å‹•ã—ã¾ã™
###############################################

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

echo "ğŸ± MyCats Pro é–‹ç™ºç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚’é–‹å§‹ã—ã¾ã™..."
echo "ğŸ“ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆ: $PROJECT_ROOT"
echo ""

# ã‚«ãƒ©ãƒ¼å‡ºåŠ›
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# 1. ç’°å¢ƒå¤‰æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã®ç¢ºèª
echo -e "${BLUE}1. ç’°å¢ƒå¤‰æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç¢ºèªä¸­...${NC}"

if [ ! -f "$PROJECT_ROOT/backend/.env" ]; then
    echo -e "${YELLOW}âš ï¸  backend/.env ãŒå­˜åœ¨ã—ã¾ã›ã‚“ã€‚ä½œæˆã—ã¾ã™...${NC}"
    cp "$PROJECT_ROOT/.env.development" "$PROJECT_ROOT/backend/.env"
    echo -e "${GREEN}âœ“ backend/.env ã‚’ä½œæˆã—ã¾ã—ãŸ${NC}"
else
    echo -e "${GREEN}âœ“ backend/.env ãŒå­˜åœ¨ã—ã¾ã™${NC}"
fi

if [ ! -f "$PROJECT_ROOT/frontend/.env.local" ]; then
    echo -e "${YELLOW}âš ï¸  frontend/.env.local ãŒå­˜åœ¨ã—ã¾ã›ã‚“ã€‚ä½œæˆã—ã¾ã™...${NC}"
    cat > "$PROJECT_ROOT/frontend/.env.local" << 'EOF'
# ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ç’°å¢ƒå¤‰æ•° (é–‹ç™ºç’°å¢ƒ)
NEXT_PUBLIC_API_URL=http://localhost:3004
NEXT_PUBLIC_ENV=development
EOF
    echo -e "${GREEN}âœ“ frontend/.env.local ã‚’ä½œæˆã—ã¾ã—ãŸ${NC}"
else
    echo -e "${GREEN}âœ“ frontend/.env.local ãŒå­˜åœ¨ã—ã¾ã™${NC}"
fi

echo ""

# 2. Docker Composeã§ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’èµ·å‹•
echo -e "${BLUE}2. Docker Compose ã§ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’èµ·å‹•ä¸­...${NC}"
cd "$PROJECT_ROOT"

# æ—¢å­˜ã®ã‚³ãƒ³ãƒ†ãƒŠã‚’åœæ­¢ï¼ˆã‚ã‚Œã°ï¼‰
if [ "$(docker ps -a -q -f name=mycats_postgres)" ]; then
    echo "æ—¢å­˜ã® mycats_postgres ã‚³ãƒ³ãƒ†ãƒŠã‚’åœæ­¢ã—ã¾ã™..."
    docker-compose down
fi

# ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’èµ·å‹•
docker-compose up -d postgres

echo "PostgreSQL ã®èµ·å‹•ã‚’å¾…æ©Ÿä¸­..."
sleep 5

# ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
MAX_RETRIES=30
RETRY_COUNT=0
while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
    if docker exec mycats_postgres pg_isready -U mycats -d mycats_development > /dev/null 2>&1; then
        echo -e "${GREEN}âœ“ PostgreSQL ãŒèµ·å‹•ã—ã¾ã—ãŸ${NC}"
        break
    fi
    RETRY_COUNT=$((RETRY_COUNT + 1))
    echo "PostgreSQL ã®èµ·å‹•ã‚’å¾…æ©Ÿä¸­... ($RETRY_COUNT/$MAX_RETRIES)"
    sleep 2
done

if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
    echo -e "${RED}âŒ PostgreSQL ã®èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ${NC}"
    exit 1
fi

echo ""

# 3. ä¾å­˜é–¢ä¿‚ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
echo -e "${BLUE}3. ä¾å­˜é–¢ä¿‚ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ä¸­...${NC}"

if [ ! -d "$PROJECT_ROOT/node_modules" ]; then
    echo "ãƒ«ãƒ¼ãƒˆã®ä¾å­˜é–¢ä¿‚ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«..."
    cd "$PROJECT_ROOT"
    pnpm install
fi

if [ ! -d "$PROJECT_ROOT/backend/node_modules" ]; then
    echo "ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®ä¾å­˜é–¢ä¿‚ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«..."
    cd "$PROJECT_ROOT/backend"
    pnpm install
fi

if [ ! -d "$PROJECT_ROOT/frontend/node_modules" ]; then
    echo "ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®ä¾å­˜é–¢ä¿‚ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«..."
    cd "$PROJECT_ROOT/frontend"
    pnpm install
fi

echo -e "${GREEN}âœ“ ä¾å­˜é–¢ä¿‚ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãŒå®Œäº†ã—ã¾ã—ãŸ${NC}"
echo ""

# 4. Prisma ã®åˆæœŸåŒ–
echo -e "${BLUE}4. Prisma ã‚’åˆæœŸåŒ–ä¸­...${NC}"
cd "$PROJECT_ROOT/backend"

# Prisma Client ã‚’ç”Ÿæˆ
echo "Prisma Client ã‚’ç”Ÿæˆ..."
pnpm prisma:generate

# ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œ
echo "ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œ..."
pnpm prisma:migrate

# ã‚·ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã‚’æŠ•å…¥ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
if [ -f "$PROJECT_ROOT/backend/src/prisma/seed.ts" ]; then
    echo "ã‚·ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã‚’æŠ•å…¥..."
    pnpm run seed || echo -e "${YELLOW}âš ï¸  ã‚·ãƒ¼ãƒ‰ã®å®Ÿè¡Œã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆæ—¢ã«ãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ï¼‰${NC}"
fi

echo -e "${GREEN}âœ“ Prisma ã®åˆæœŸåŒ–ãŒå®Œäº†ã—ã¾ã—ãŸ${NC}"
echo ""

# 5. å®Œäº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
echo -e "${GREEN}========================================${NC}"
echo -e "${GREEN}ğŸ‰ ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãŒå®Œäº†ã—ã¾ã—ãŸï¼${NC}"
echo -e "${GREEN}========================================${NC}"
echo ""
echo "ğŸ“ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—:"
echo ""
echo "  ã€ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚’èµ·å‹•ã€‘"
echo "  $ cd backend"
echo "  $ pnpm run start:dev"
echo ""
echo "  ã€ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚’èµ·å‹•ï¼ˆåˆ¥ã®ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã§ï¼‰ã€‘"
echo "  $ cd frontend"
echo "  $ pnpm run dev"
echo ""
echo "  ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’åœæ­¢ã€‘"
echo "  $ docker-compose down"
echo ""
echo "  ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’å«ã‚ã¦å®Œå…¨ã«å‰Šé™¤ã€‘"
echo "  $ docker-compose down -v"
echo ""
echo "ğŸŒ ã‚¢ã‚¯ã‚»ã‚¹ URL:"
echo "  - ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰: http://localhost:3000"
echo "  - ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰API: http://localhost:3004"
echo "  - pgAdmin: http://localhost:5050"
echo ""
echo "ğŸ“Š ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šæƒ…å ±:"
echo "  - Host: localhost"
echo "  - Port: 5433"
echo "  - Database: mycats_development"
echo "  - User: mycats"
echo "  - Password: mycats_dev_password"
echo ""
````

## File: scripts/setup-dev.sh
````bash
#!/bin/bash

# Development Environment Setup Script
# This script automates the development environment setup

set -e  # Exit on any error

echo "ğŸš€ Starting development environment setup..."

# Check if we're in the right directory
if [ ! -f "package.json" ]; then
  echo "âŒ Error: package.json not found. Please run this script from the project root."
  exit 1
fi

# Check Node.js version
NODE_VERSION=$(node --version | cut -d 'v' -f 2)
REQUIRED_NODE_MAJOR="20"
NODE_MAJOR=$(echo $NODE_VERSION | cut -d '.' -f 1)

if [ "$NODE_MAJOR" -lt "$REQUIRED_NODE_MAJOR" ]; then
  echo "âŒ Error: Node.js $REQUIRED_NODE_MAJOR+ required, but found $NODE_VERSION"
  exit 1
fi

echo "âœ… Node.js $NODE_VERSION detected"

# Install pnpm if not available
if ! command -v pnpm &> /dev/null; then
  echo "ğŸ“¦ Installing pnpm..."
  npm install -g pnpm
fi

# Install dependencies
echo "ğŸ“¦ Installing dependencies..."
pnpm install

# Check if PostgreSQL is running
if ! pg_isready -h localhost -p 5432 > /dev/null 2>&1; then
  echo "âŒ Error: PostgreSQL is not running. Please start PostgreSQL:"
  echo "   - Linux: sudo systemctl start postgresql"
  echo "   - macOS: brew services start postgresql"
  exit 1
fi

echo "âœ… PostgreSQL is running"

# Check if .env exists in backend
if [ ! -f "backend/.env" ]; then
  echo "âš™ï¸ Creating backend/.env file..."
  cat > backend/.env << EOF
# Development Environment Configuration
DATABASE_URL="postgresql://runner:password@localhost:5432/mycats_development"
JWT_SECRET="development-jwt-secret-at-least-32-characters-long-for-security"
JWT_EXPIRES_IN="1h"
NODE_ENV="development"
PORT=3004
CORS_ORIGIN="http://localhost:3000"
BCRYPT_ROUNDS=10
THROTTLE_TTL=60000
THROTTLE_LIMIT=100
LOG_LEVEL=debug
HEALTH_CHECK_DATABASE=true
HEALTH_CHECK_MEMORY_THRESHOLD=0.9
SESSION_SECRET="development-session-secret-here"
# Prisma settings for development
PRISMA_CLIENT_ENGINE_TYPE="library"
EOF
  echo "âœ… Created backend/.env file"
else
  echo "âœ… backend/.env file already exists"
fi

# Test database connection
echo "ğŸ”Œ Testing database connection..."
if ! psql $(<backend/.env grep DATABASE_URL | cut -d '=' -f 2 | tr -d '"') -c "SELECT 1;" > /dev/null 2>&1; then
  echo "âŒ Error: Cannot connect to database. Please check:"
  echo "   1. PostgreSQL is running"
  echo "   2. Database 'mycats_development' exists"
  echo "   3. User credentials are correct"
  echo ""
  echo "To create the database and user, run:"
  echo "   sudo -u postgres createuser --createdb --password runner"
  echo "   sudo -u postgres createdb --owner=runner mycats_development"
  exit 1
fi

echo "âœ… Database connection successful"

# Generate Prisma client
echo "ğŸ”§ Generating Prisma client..."
pnpm run db:generate

# Run migrations
echo "ğŸ—ï¸ Running database migrations..."
pnpm run db:migrate

# Test builds
echo "ğŸ—ï¸ Testing builds..."
pnpm run backend:build
pnpm run frontend:build

echo ""
echo "ğŸ‰ Development environment setup complete!"
echo ""
echo "ğŸ“‹ Quick start commands:"
echo "   pnpm run dev          # Start development servers"
echo "   pnpm run db:studio    # Open Prisma Studio"
echo "   pnpm run test:health  # Test API health"
echo ""
echo "ğŸŒ URLs:"
echo "   Frontend: http://localhost:3000"
echo "   Backend:  http://localhost:3004"
echo "   API Docs: http://localhost:3004/api/docs"
echo "   Health:   http://localhost:3004/health"
````

## File: scripts/setup-domain-and-email.sh
````bash
#!/usr/bin/env bash
#
# GCP Load Balancer + ã‚«ã‚¹ã‚¿ãƒ ãƒ‰ãƒ¡ã‚¤ãƒ³ + ãƒ¡ãƒ¼ãƒ«é€ä¿¡æ©Ÿèƒ½ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
# ã“ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’å®Ÿè¡Œã™ã‚‹å‰ã«ã€ãŠåå‰.comã§ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’å–å¾—ã—ã€Resendã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ä½œæˆã—ã¦ãã ã•ã„
#
# å®Ÿè¡Œæ‰‹é †:
# 1. chmod +x scripts/setup-domain-and-email.sh
# 2. ./scripts/setup-domain-and-email.sh

set -euo pipefail

# ã‚«ãƒ©ãƒ¼å‡ºåŠ›
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

PROJECT_ID="my-cats-pro"

echo -e "${BLUE}"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "  ã‚«ã‚¹ã‚¿ãƒ ãƒ‰ãƒ¡ã‚¤ãƒ³ + ãƒ¡ãƒ¼ãƒ«é€ä¿¡æ©Ÿèƒ½ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—"
echo "  Project: $PROJECT_ID"
echo "  Domain: nekoya.co.jp"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo -e "${NC}"

# ã‚¹ãƒ†ãƒƒãƒ—1: GCP Load Balancerã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
echo -e "${GREEN}[ã‚¹ãƒ†ãƒƒãƒ— 1/3]${NC} GCP Load Balancerã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã—ã¾ã™"
echo ""
echo "ä»¥ä¸‹ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’å®Ÿè¡Œã—ã¾ã™:"
echo "  ./scripts/setup-custom-domain.sh"
echo ""
read -p "å®Ÿè¡Œã—ã¾ã™ã‹? (y/N): " -r
if [[ $REPLY =~ ^[Yy]$ ]]; then
    bash ./scripts/setup-custom-domain.sh
else
    echo -e "${YELLOW}ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸ${NC}"
fi

# ã‚¹ãƒ†ãƒƒãƒ—2: Resend APIã‚­ãƒ¼ã®ç™»éŒ²
echo ""
echo -e "${GREEN}[ã‚¹ãƒ†ãƒƒãƒ— 2/3]${NC} Resend APIã‚­ãƒ¼ã‚’Secret Managerã«ç™»éŒ²ã—ã¾ã™"
echo ""
echo "äº‹å‰æº–å‚™:"
echo "  1. https://resend.com ã«ã‚µã‚¤ãƒ³ã‚¢ãƒƒãƒ—"
echo "  2. ãƒ‰ãƒ¡ã‚¤ãƒ³ nekoya.co.jp ã‚’è¿½åŠ "
echo "  3. APIã‚­ãƒ¼ã‚’ä½œæˆ (Sending access)"
echo ""
read -p "APIã‚­ãƒ¼ã‚’å–å¾—ã—ã¾ã—ãŸã‹? (y/N): " -r
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo -e "${RED}Resend APIã‚­ãƒ¼ã‚’å–å¾—ã—ã¦ã‹ã‚‰å†åº¦å®Ÿè¡Œã—ã¦ãã ã•ã„${NC}"
    echo "è©³ç´°: docs/EMAIL_INTEGRATION_GUIDE.md"
    exit 1
fi

echo ""
read -p "Resend APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„: " -s RESEND_API_KEY
echo ""

# æœ¬ç•ªç’°å¢ƒç”¨ã®ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã‚’ä½œæˆ
echo "ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã‚’ä½œæˆä¸­..."

# Resend APIã‚­ãƒ¼
if gcloud secrets describe RESEND_API_KEY --project=$PROJECT_ID &>/dev/null; then
    echo "RESEND_API_KEY ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™ã€‚ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’è¿½åŠ ã—ã¾ã™ã€‚"
    echo -n "$RESEND_API_KEY" | gcloud secrets versions add RESEND_API_KEY \
        --data-file=- \
        --project=$PROJECT_ID
else
    gcloud secrets create RESEND_API_KEY \
        --replication-policy="automatic" \
        --project=$PROJECT_ID
    
    echo -n "$RESEND_API_KEY" | gcloud secrets versions add RESEND_API_KEY \
        --data-file=- \
        --project=$PROJECT_ID
fi

echo -e "${GREEN}âœ“${NC} RESEND_API_KEY ã‚’ç™»éŒ²ã—ã¾ã—ãŸ"

# æ¨©é™ä»˜ä¸
echo "Cloud Runã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«æ¨©é™ã‚’ä»˜ä¸ä¸­..."
gcloud secrets add-iam-policy-binding RESEND_API_KEY \
    --member="serviceAccount:cloud-run-backend@${PROJECT_ID}.iam.gserviceaccount.com" \
    --role="roles/secretmanager.secretAccessor" \
    --project=$PROJECT_ID

echo -e "${GREEN}âœ“${NC} æ¨©é™ã‚’ä»˜ä¸ã—ã¾ã—ãŸ"

# ã‚¹ãƒ†ãƒƒãƒ—3: Cloud Runã‚µãƒ¼ãƒ“ã‚¹ã®æ›´æ–°
echo ""
echo -e "${GREEN}[ã‚¹ãƒ†ãƒƒãƒ— 3/3]${NC} Cloud Runã‚µãƒ¼ãƒ“ã‚¹ã‚’æ›´æ–°ã—ã¾ã™"
echo ""
echo "ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒ“ã‚¹ã«ä»¥ä¸‹ã®ç’°å¢ƒå¤‰æ•°ã‚’è¿½åŠ ã—ã¾ã™:"
echo "  - RESEND_API_KEY (Secret)"
echo "  - EMAIL_FROM=noreply@nekoya.co.jp"
echo "  - EMAIL_FROM_NAME=MyCats Pro"
echo "  - CORS_ORIGIN=https://nekoya.co.jp,https://www.nekoya.co.jp"
echo ""
read -p "å®Ÿè¡Œã—ã¾ã™ã‹? (y/N): " -r
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo -e "${YELLOW}ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸ${NC}"
    echo ""
    echo "æ‰‹å‹•ã§ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„:"
    echo ""
    echo "gcloud run services update mycats-pro-backend \\"
    echo "  --region=asia-northeast1 \\"
    echo "  --update-secrets=RESEND_API_KEY=RESEND_API_KEY_production:latest \\"
    echo "  --set-env-vars=\"EMAIL_FROM=noreply@nekoya.co.jp,EMAIL_FROM_NAME=MyCats Pro,CORS_ORIGIN=https://nekoya.co.jp,https://www.nekoya.co.jp\" \\"
    echo "  --project=$PROJECT_ID"
    exit 0
fi

gcloud run services update mycats-pro-backend \
    --region=asia-northeast1 \
    --update-secrets=RESEND_API_KEY=RESEND_API_KEY_production:latest \
    --set-env-vars="EMAIL_FROM=noreply@nekoya.co.jp,EMAIL_FROM_NAME=MyCats Pro,CORS_ORIGIN=https://nekoya.co.jp,https://www.nekoya.co.jp" \
    --project=$PROJECT_ID

echo ""
echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo -e "${GREEN}  ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—å®Œäº†! ğŸ‰${NC}"
echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo ""
echo "æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—:"
echo ""
echo "1. SSLè¨¼æ˜æ›¸ã®ãƒ—ãƒ­ãƒ“ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°ã‚’ç¢ºèª"
echo "   gcloud compute ssl-certificates describe mycats-ssl-cert --global"
echo ""
echo "2. ãƒ¡ãƒ¼ãƒ«é€ä¿¡ãƒ†ã‚¹ãƒˆ"
echo "   curl -X POST https://api.nekoya.co.jp/api/v1/auth/test-email \\"
echo "     -H \"Content-Type: application/json\" \\"
echo "     -d '{\"email\":\"your-email@example.com\"}'"
echo ""
echo "3. ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚¢ã‚¯ã‚»ã‚¹ãƒ†ã‚¹ãƒˆ"
echo "   https://nekoya.co.jp"
echo "   https://api.nekoya.co.jp/api/v1/health"
echo ""
````

## File: scripts/start-all.bat
````batch
@echo off
REM ###############################################
REM MyCats Pro - Windowsç”¨é–‹ç™ºã‚µãƒ¼ãƒãƒ¼èµ·å‹•ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
REM ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã¨ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚’åŒæ™‚ã«èµ·å‹•ã—ã¾ã™
REM ###############################################

setlocal

set "SCRIPT_DIR=%~dp0"
set "PROJECT_ROOT=%SCRIPT_DIR%.."
cd /d "%PROJECT_ROOT%"

echo ğŸ± MyCats Pro é–‹ç™ºã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•ã—ã¾ã™...
echo.

REM Dockerã‚³ãƒ³ãƒ†ãƒŠã®çŠ¶æ…‹ã‚’ç¢ºèª
docker ps | findstr mycats_postgres >nul
if errorlevel 1 (
    echo âš ï¸  ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãŒèµ·å‹•ã—ã¦ã„ã¾ã›ã‚“ã€‚èµ·å‹•ã—ã¾ã™...
    docker-compose up -d postgres
    
    echo PostgreSQL ã®èµ·å‹•ã‚’å¾…æ©Ÿä¸­...
    timeout /t 5 /nobreak >nul
    
    REM ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
    set /a RETRY_COUNT=0
    set /a MAX_RETRIES=15
    
    :HEALTHCHECK_LOOP
    docker exec mycats_postgres pg_isready -U mycats -d mycats_development >nul 2>&1
    if not errorlevel 1 (
        echo âœ“ PostgreSQL ãŒèµ·å‹•ã—ã¾ã—ãŸ
        goto :HEALTHCHECK_DONE
    )
    
    set /a RETRY_COUNT+=1
    if %RETRY_COUNT% geq %MAX_RETRIES% (
        echo âŒ PostgreSQL ã®èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ
        exit /b 1
    )
    
    timeout /t 2 /nobreak >nul
    goto :HEALTHCHECK_LOOP
)

:HEALTHCHECK_DONE
echo.
echo ========================================
echo ã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•ã—ã¦ã„ã¾ã™...
echo ========================================
echo.
echo ğŸ“ ãƒ­ã‚°ã‚’ç¢ºèªã™ã‚‹ã«ã¯:
echo   - ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰: backend/ã®ã‚¿ãƒ¼ãƒŸãƒŠãƒ«
echo   - ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰: frontend/ã®ã‚¿ãƒ¼ãƒŸãƒŠãƒ«
echo.
echo ğŸŒ ã‚¢ã‚¯ã‚»ã‚¹ URL:
echo   - ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰: http://localhost:3000
echo   - ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰API: http://localhost:3004
echo.
echo â¹ï¸  åœæ­¢ã™ã‚‹ã«ã¯: Ctrl+C ã‚’æŠ¼ã—ã¦ãã ã•ã„
echo.

REM Windowsç”¨ã®ä¸¦åˆ—å®Ÿè¡Œï¼ˆæ¨å¥¨: pnpm run devã‚’ä½¿ç”¨ï¼‰
echo Windowsç’°å¢ƒã§ã¯ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„:
echo   pnpm run dev
echo.
echo ã¾ãŸã¯ã€2ã¤ã®ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã§å€‹åˆ¥ã«èµ·å‹•:
echo   ã‚¿ãƒ¼ãƒŸãƒŠãƒ«1: cd backend ^&^& pnpm run start:dev
echo   ã‚¿ãƒ¼ãƒŸãƒŠãƒ«2: cd frontend ^&^& pnpm run dev
echo.

pause

endlocal
````

## File: scripts/start-all.sh
````bash
#!/bin/bash

###############################################
# MyCats Pro - é–‹ç™ºã‚µãƒ¼ãƒãƒ¼èµ·å‹•ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
# ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã¨ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚’åŒæ™‚ã«èµ·å‹•ã—ã¾ã™
###############################################

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# ã‚«ãƒ©ãƒ¼å‡ºåŠ›
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m'

echo -e "${BLUE}ğŸ± MyCats Pro é–‹ç™ºã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•ã—ã¾ã™...${NC}"
echo ""

# Dockerã‚³ãƒ³ãƒ†ãƒŠã®çŠ¶æ…‹ã‚’ç¢ºèª
if ! docker ps | grep -q mycats_postgres; then
    echo -e "${YELLOW}âš ï¸  ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãŒèµ·å‹•ã—ã¦ã„ã¾ã›ã‚“ã€‚èµ·å‹•ã—ã¾ã™...${NC}"
    cd "$PROJECT_ROOT"
    docker-compose up -d postgres
    
    echo "PostgreSQL ã®èµ·å‹•ã‚’å¾…æ©Ÿä¸­..."
    sleep 5
    
    # ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
    MAX_RETRIES=15
    RETRY_COUNT=0
    while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
        if docker exec mycats_postgres pg_isready -U mycats -d mycats_development > /dev/null 2>&1; then
            echo -e "${GREEN}âœ“ PostgreSQL ãŒèµ·å‹•ã—ã¾ã—ãŸ${NC}"
            break
        fi
        RETRY_COUNT=$((RETRY_COUNT + 1))
        sleep 2
    done
fi

echo ""
echo -e "${GREEN}========================================${NC}"
echo -e "${GREEN}ã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•ã—ã¦ã„ã¾ã™...${NC}"
echo -e "${GREEN}========================================${NC}"
echo ""
echo "ğŸ“ ãƒ­ã‚°ã‚’ç¢ºèªã™ã‚‹ã«ã¯:"
echo "  - ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰: backend/ã®ã‚¿ãƒ¼ãƒŸãƒŠãƒ«"
echo "  - ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰: frontend/ã®ã‚¿ãƒ¼ãƒŸãƒŠãƒ«"
echo ""
echo "ğŸŒ ã‚¢ã‚¯ã‚»ã‚¹ URL:"
echo "  - ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰: http://localhost:3000"
echo "  - ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰API: http://localhost:3004"
echo ""
echo "â¹ï¸  åœæ­¢ã™ã‚‹ã«ã¯: Ctrl+C ã‚’æŠ¼ã—ã¦ãã ã•ã„"
echo ""

# ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã¨ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚’åŒæ™‚ã«èµ·å‹•
cd "$PROJECT_ROOT"

# ä¸¦åˆ—å®Ÿè¡Œï¼ˆã©ã¡ã‚‰ã‹ãŒçµ‚äº†ã—ãŸã‚‰ä¸¡æ–¹çµ‚äº†ï¼‰
trap 'kill $(jobs -p) 2>/dev/null' EXIT

# ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚’èµ·å‹•
(
    cd backend
    echo -e "${BLUE}[Backend] Starting...${NC}"
    pnpm run start:dev
) &

# ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚’èµ·å‹•
(
    cd frontend
    echo -e "${BLUE}[Frontend] Starting...${NC}"
    pnpm run dev
) &

# ä¸¡æ–¹ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’å¾…æ©Ÿ
wait
````

## File: scripts/start-dev-stable.mjs
````javascript
#!/usr/bin/env node
import { spawn } from "node:child_process";
import { createWriteStream, writeFileSync, rmSync } from "node:fs";
import { dirname, resolve } from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const projectRoot = resolve(__dirname, "..");
const pnpmCommand = "pnpm";
const useShell = process.platform === "win32";
const processes = [];
let cleaningUp = false;

const promiseTimeout = (ms) => new Promise((resolveFn) => setTimeout(resolveFn, ms));

async function runCommand(command, args, { cwd, ignoreFailure = false } = {}) {
  await new Promise((resolvePromise, rejectPromise) => {
    const child = spawn(command, args, {
      cwd,
      stdio: "inherit",
      shell: useShell,
    });

    child.on("error", (error) => {
      if (ignoreFailure) {
        resolvePromise();
        return;
      }
      rejectPromise(error);
    });

    child.on("close", (code) => {
      if (code === 0 || ignoreFailure) {
        resolvePromise();
        return;
      }
      rejectPromise(new Error(`${command} ${args.join(" ")} exited with code ${code}`));
    });
  });
}

function safeRemove(path) {
  try {
    rmSync(path);
  } catch (error) {
    if (error.code !== "ENOENT") {
      throw error;
    }
  }
}

function spawnBackground(label, command, args) {
  const stdoutPath = resolve(projectRoot, `${label}.out`);
  const stderrPath = resolve(projectRoot, `${label}.log`);
  const pidPath = resolve(projectRoot, `${label}.pid`);

  safeRemove(stdoutPath);
  safeRemove(stderrPath);
  safeRemove(pidPath);

  const child = spawn(command, args, {
    cwd: projectRoot,
    stdio: ["ignore", "pipe", "pipe"],
    shell: useShell,
  });

  const stdoutStream = createWriteStream(stdoutPath, { flags: "w" });
  const stderrStream = createWriteStream(stderrPath, { flags: "w" });

  child.stdout.on("data", (chunk) => {
    stdoutStream.write(chunk);
    process.stdout.write(`[${label}] ${chunk}`);
  });

  child.stderr.on("data", (chunk) => {
    stderrStream.write(chunk);
    process.stderr.write(`[${label}] ${chunk}`);
  });

  child.on("close", (code) => {
    stdoutStream.end();
    stderrStream.end();
    safeRemove(pidPath);
    if (!cleaningUp) {
      console.error(`\n${label} exited with code ${code ?? "unknown"}`);
      cleanup("SIGTERM").finally(() => {
        process.exit(typeof code === "number" ? code : 1);
      });
    }
  });

  writeFileSync(pidPath, String(child.pid));

  processes.push({ label, child, stdoutStream, stderrStream, pidPath });

  console.log(`   ${label} PID: ${child.pid}`);
  console.log(`   Logs: ${stdoutPath} / ${stderrPath}`);

  return child;
}

async function waitForHttp(url, retries, delayMs) {
  for (let attempt = 1; attempt <= retries; attempt += 1) {
    try {
      const response = await fetch(url, { cache: "no-store" });
      if (response.ok) {
        return true;
      }
    } catch (error) {
      // Intentionally ignore fetch errors during polling.
    }
    await promiseTimeout(delayMs);
  }
  return false;
}

async function cleanup(signal = "SIGINT") {
  if (cleaningUp) {
    return;
  }
  cleaningUp = true;

  for (const proc of processes) {
    if (!proc.child.killed) {
      try {
        proc.child.kill(signal);
      } catch (error) {
        // If the process is already gone we can ignore the error.
      }
    }
    proc.stdoutStream.end();
    proc.stderrStream.end();
    safeRemove(proc.pidPath);
  }
}

async function main() {
  console.log("\nStarting MyCats Development Environment (Stable Mode)");
  console.log("====================================================\n");

  console.log("Cleaning up ports...");
  await runCommand(pnpmCommand, ["run", "predev"], { cwd: projectRoot, ignoreFailure: true });
  console.log("");

  console.log("Starting backend server...");
  spawnBackground("backend", pnpmCommand, ["run", "backend:dev"]);
  console.log("");

  console.log("Waiting for backend to start...");
  const backendReady = await waitForHttp("http://localhost:3004/health", 30, 1000);
  if (!backendReady) {
    console.error("Backend failed to start within 30 seconds\n   Check backend.log for errors");
    await cleanup("SIGTERM");
    process.exit(1);
  }
  console.log("Backend is ready!\n");

  console.log("Starting frontend server...");
  spawnBackground("frontend", pnpmCommand, ["run", "frontend:dev:wait"]);
  console.log("");

  console.log("Waiting for frontend to start...");
  const frontendReady = await waitForHttp("http://localhost:3000", 30, 1000);
  if (frontendReady) {
    console.log("Frontend is ready!\n");
  } else {
    console.log("Frontend might still be starting (this can be normal)\n   Check frontend.log if issues persist\n");
  }

  console.log("Development servers are running!\n");
  console.log("Available endpoints:");
  console.log("   Backend:  http://localhost:3004");
  console.log("   Frontend: http://localhost:3000");
  console.log("   API Docs: http://localhost:3004/api/docs");
  console.log("   Health:   http://localhost:3004/health\n");
  console.log("Process IDs saved to:");
  console.log("   backend.pid");
  console.log("   frontend.pid\n");
  console.log("To stop servers:");
  console.log("   npm run dev:stop");
  console.log("   or terminate the PIDs listed in backend.pid and frontend.pid\n");
  console.log("To view logs:");
  console.log("   backend.out    (backend stdout)");
  console.log("   backend.log    (backend stderr)");
  console.log("   frontend.out   (frontend stdout)");
  console.log("   frontend.log   (frontend stderr)\n");
}

process.on("SIGINT", async () => {
  await cleanup("SIGINT");
  process.exit(0);
});

process.on("SIGTERM", async () => {
  await cleanup("SIGTERM");
  process.exit(0);
});

main().catch(async (error) => {
  console.error("Unexpected error during startup:", error);
  await cleanup("SIGTERM");
  process.exit(1);
});
````

## File: scripts/start-dev-stable.sh
````bash
#!/bin/bash

# Stable Development Server Startup Script
# This script starts the development servers and keeps them running

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

cd "$PROJECT_ROOT"

echo "ğŸš€ Starting MyCats Development Environment (Stable Mode)"
echo "========================================================"
echo ""

# Kill any existing processes on the ports
echo "ğŸ§¹ Cleaning up ports..."
pnpm run predev || true
echo ""

# Start backend in background
echo "ğŸ”§ Starting backend server..."
nohup pnpm run backend:dev > backend.out 2> backend.log &
BACKEND_PID=$!
echo $BACKEND_PID > backend.pid
echo "   Backend PID: $BACKEND_PID"
echo "   Logs: backend.out / backend.log"
echo ""

# Wait for backend to be ready
echo "â³ Waiting for backend to start..."
for i in {1..30}; do
  if curl -s http://localhost:3004/health > /dev/null 2>&1; then
    echo "âœ… Backend is ready!"
    break
  fi
  if [ $i -eq 30 ]; then
    echo "âŒ Backend failed to start within 30 seconds"
    echo "   Check backend.log for errors"
    exit 1
  fi
  sleep 1
  echo -n "."
done
echo ""

# Start frontend in background  
echo "ğŸ¨ Starting frontend server..."
cd frontend
nohup pnpm run dev > ../frontend.out 2> ../frontend.log &
FRONTEND_PID=$!
cd ..
echo $FRONTEND_PID > frontend.pid
echo "   Frontend PID: $FRONTEND_PID"
echo "   Logs: frontend.out / frontend.log"
echo ""

# Wait for frontend to be ready
echo "â³ Waiting for frontend to start..."
for i in {1..30}; do
  if curl -s http://localhost:3000 > /dev/null 2>&1; then
    echo "âœ… Frontend is ready!"
    break
  fi
  if [ $i -eq 30 ]; then
    echo "âš ï¸  Frontend might still be starting (this is normal)"
    echo "   Check frontend.log if issues persist"
  fi
  sleep 1
  echo -n "."
done
echo ""

echo "âœ¨ Development servers are running!"
echo ""
echo "ğŸ“ URLs:"
echo "   Backend:  http://localhost:3004"
echo "   Frontend: http://localhost:3000"
echo "   API Docs: http://localhost:3004/api/docs"
echo "   Health:   http://localhost:3004/health"
echo ""
echo "ğŸ“ Process IDs saved to:"
echo "   backend.pid  (PID: $BACKEND_PID)"
echo "   frontend.pid (PID: $FRONTEND_PID)"
echo ""
echo "ğŸ›‘ To stop servers:"
echo "   ./scripts/stop-dev.sh"
echo "   or"
echo "   kill $(cat backend.pid) $(cat frontend.pid)"
echo ""
echo "ğŸ“Š To view logs:"
echo "   tail -f backend.out    # Backend stdout"
echo "   tail -f backend.log    # Backend stderr"
echo "   tail -f frontend.out   # Frontend stdout"
echo "   tail -f frontend.log   # Frontend stderr"
````

## File: scripts/stop-dev.sh
````bash
#!/bin/bash

# Stop Development Servers Script

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

cd "$PROJECT_ROOT"

echo "ğŸ›‘ Stopping MyCats Development Servers"
echo "======================================"
echo ""

# Stop backend
if [ -f backend.pid ]; then
  BACKEND_PID=$(cat backend.pid)
  echo "Stopping backend (PID: $BACKEND_PID)..."
  kill $BACKEND_PID 2>/dev/null || echo "   Backend process not found"
  rm backend.pid
else
  echo "No backend.pid found"
fi

# Stop frontend
if [ -f frontend.pid ]; then
  FRONTEND_PID=$(cat frontend.pid)
  echo "Stopping frontend (PID: $FRONTEND_PID)..."
  kill $FRONTEND_PID 2>/dev/null || echo "   Frontend process not found"
  rm frontend.pid
else
  echo "No frontend.pid found"
fi

# Extra cleanup - kill any process on the ports
echo ""
echo "ğŸ§¹ Cleaning up ports..."
pnpm run predev || true

echo ""
echo "âœ… Development servers stopped"
````

## File: scripts/test-session-persistence.sh
````bash
#!/usr/bin/env bash
set -euo pipefail

API_BASE="http://localhost:3004/api/v1"
EMAIL="admin@example.com"
PASSWORD="Passw0rd!"
COOKIES="/tmp/test-session-cookies.txt"
COLOR="#10B981"
TAG_NAME="persistence-check-$$"

log() { printf "[test] %s\n" "$*"; }

warn_jq_once() {
  if [[ -z "${__WARNED_JQ:-}" ]]; then
    log "jq ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚é«˜é€Ÿ/å³å¯†ãª JSON ãƒ‘ãƒ¼ã‚¹ã‚’è¡Œã†ã«ã¯ jq ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã‚’æ¨å¥¨ã—ã¾ã™ (brew install jq)ã€‚fallback æ–‡å­—åˆ—ãƒãƒƒãƒã§ç¶™ç¶šã—ã¾ã™ã€‚";
    __WARNED_JQ=1
  fi
}

cleanup() { rm -f "$COOKIES" || true; }
trap cleanup EXIT

log "1. Login (capture refresh cookie)"
curl -s -D /tmp/login-headers.txt -c "$COOKIES" -o /tmp/login-body.json -X POST "$API_BASE/auth/login" \
  -H 'Content-Type: application/json' \
  -d "{\"email\":\"$EMAIL\",\"password\":\"$PASSWORD\"}" || { log "Login HTTP error"; exit 1; }
STATUS_LOGIN=$(awk 'NR==1 {print $2}' /tmp/login-headers.txt || echo "")
BODY_LOGIN=$(cat /tmp/login-body.json)
if [[ "$STATUS_LOGIN" != "201" && "$STATUS_LOGIN" != "200" ]]; then
  log "Login failed status=$STATUS_LOGIN"; printf '%s\n' "$BODY_LOGIN"; exit 1; fi
if command -v jq >/dev/null 2>&1; then
  echo "$BODY_LOGIN" | jq -e '.data.access_token' >/dev/null 2>&1 || { log "No access_token in login body"; printf '%s\n' "$BODY_LOGIN"; exit 1; }
else
  warn_jq_once
  # jq ãŒç„¡ã„å ´åˆã¯å˜ç´”ãƒ‘ã‚¿ãƒ¼ãƒ³æŠ½å‡º
  printf '%s' "$BODY_LOGIN" | grep -q '"access_token"' || { log "No access_token pattern (no jq)"; printf '%s\n' "$BODY_LOGIN"; exit 1; }
fi

log "2. Backend restart (graceful)"
if pgrep -f 'node.*backend' >/dev/null; then pkill -f 'node.*backend'; sleep 1; fi
pnpm run backend:dev > /tmp/backend-restart.log 2>&1 &
# wait for ready
for _ in {1..20}; do
  if curl -sf http://localhost:3004/health >/dev/null; then break; fi; sleep 0.4; done
if ! curl -sf http://localhost:3004/health >/dev/null; then
  log "Backend did not come up"; tail -n 80 /tmp/backend-restart.log; exit 1; fi

log "3. Refresh using only cookie"
REFRESH_BODY=$(curl -s -b "$COOKIES" -c "$COOKIES" -X POST "$API_BASE/auth/refresh" -H 'Content-Type: application/json' -d '{}') || { log "Refresh request failed"; exit 1; }
if command -v jq >/null 2>&1; then
  if ! printf '%s' "$REFRESH_BODY" | jq -e '.data.access_token' >/dev/null 2>&1; then
    log "Refresh missing access_token"; printf '%s\n' "$REFRESH_BODY"; exit 1; fi
  ACCESS_TOKEN=$(printf '%s' "$REFRESH_BODY" | jq -r '.data.access_token')
else
  warn_jq_once
  echo "$REFRESH_BODY" | grep -q '"access_token"' || { log "Refresh missing access_token (no jq)"; printf '%s\n' "$REFRESH_BODY"; exit 1; }
  ACCESS_TOKEN=$(printf '%s' "$REFRESH_BODY" | sed -n 's/.*"access_token":"\([^"]*\)".*/\1/p')
fi

log "4. Call protected endpoint (create tag)"
CREATE_BODY=$(curl -s -X POST "$API_BASE/tags" -H "Authorization: Bearer $ACCESS_TOKEN" -H 'Content-Type: application/json' \
  -d "{\"name\":\"$TAG_NAME\",\"color\":\"$COLOR\"}") || { log "Create tag request failed"; exit 1; }
if command -v jq >/dev/null 2>&1; then
  if ! printf '%s' "$CREATE_BODY" | jq -e '.success==true' >/dev/null 2>&1; then
    log "Create tag failed"; printf '%s\n' "$CREATE_BODY"; exit 1; fi
  TAG_ID=$(printf '%s' "$CREATE_BODY" | jq -r '.data.id')
else
  warn_jq_once
  echo "$CREATE_BODY" | grep -q '"success":true' || { log "Create tag failed(no jq)"; printf '%s\n' "$CREATE_BODY"; exit 1; }
  TAG_ID=$(printf '%s' "$CREATE_BODY" | sed -n 's/.*"id":"\([^"]*\)".*/\1/p' | head -n1)
fi

log "5. List tags and assert presence"
LIST_BODY=$(curl -s "$API_BASE/tags") || { log "List tags failed"; exit 1; }
if command -v jq >/dev/null 2>&1; then
  if ! printf '%s' "$LIST_BODY" | jq -e --arg id "$TAG_ID" '.data[] | select(.id==$id)' >/dev/null 2>&1; then
    log "Tag $TAG_ID not found in listing"; printf '%s\n' "$LIST_BODY"; exit 1; fi
else
  warn_jq_once
  echo "$LIST_BODY" | grep -q "$TAG_ID" || { log "Tag $TAG_ID not found in listing (no jq)"; printf '%s\n' "$LIST_BODY"; exit 1; }
fi

log "âœ… Session persistence test passed (tag id=$TAG_ID)"

# Optional: cleanup created tag (uncomment if necessary)
# curl -s -X DELETE "$API_BASE/tags/$TAG_ID" -H "Authorization: Bearer $ACCESS_TOKEN" >/dev/null 2>&1 || true
````

## File: seed_data.sql
````sql
-- Sample data for Cat Management System
-- Insert test users
INSERT INTO "users" ("id", "clerkId", "email", "firstName", "lastName", "role", "createdAt", "updatedAt")
VALUES 
  ('user-1', 'clerk_test_admin', 'admin@catmanagement.com', 'Admin', 'User', 'ADMIN', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
  ('user-2', 'clerk_test_user', 'user@catmanagement.com', 'Regular', 'User', 'USER', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
ON CONFLICT ("clerkId") DO NOTHING;

-- Insert sample cats
INSERT INTO "cats" ("id", "registrationId", "name", "legacyBreed", "legacyColor", "pattern", "gender", "birthDate", "weight", "ownerId", "createdAt", "updatedAt")
VALUES 
  ('cat-1', 'REG001', 'Luna', 'Persian', 'White', 'Solid', 'FEMALE', '2020-03-15', 4.2, 'user-1', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
  ('cat-2', 'REG002', 'Shadow', 'Maine Coon', 'Black', 'Solid', 'MALE', '2019-08-22', 6.8, 'user-1', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
  ('cat-3', 'REG003', 'Bella', 'British Shorthair', 'Gray', 'Solid', 'FEMALE', '2021-01-10', 3.9, 'user-2', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
  ('cat-4', 'REG004', 'Max', 'Scottish Fold', 'Orange', 'Tabby', 'MALE', '2020-11-05', 4.5, 'user-2', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
ON CONFLICT ("registrationId") DO NOTHING;

-- Insert sample tag categories
INSERT INTO "tag_categories" ("id", "key", "name", "description", "color", "display_order", "scopes", "is_active", "created_at", "updated_at")
VALUES
  ('tag-cat-1', 'cats_status', 'çŒ«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹', 'ç¹æ®–ãƒ»å­è‚²ã¦ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç®¡ç†ç”¨ã‚«ãƒ†ã‚´ãƒª', '#6366F1', 10, ARRAY['cats', 'breeding'], true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
  ('tag-cat-2', 'general_traits', 'ä¸€èˆ¬å±æ€§', 'çŒ«ã®ç‰¹å¾´ã‚„åˆ†é¡ã®ãŸã‚ã®æ±ç”¨ã‚«ãƒ†ã‚´ãƒª', '#0EA5E9', 20, ARRAY['cats'], true, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
ON CONFLICT ("key") DO NOTHING;

-- Insert sample tags
INSERT INTO "tags" ("id", "category_id", "name", "color", "description", "created_at", "updated_at")
VALUES 
  ('tag-1', 'tag-cat-1', 'Breeding Program', '#10B981', 'Cats in active breeding program', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
  ('tag-2', 'tag-cat-2', 'Show Quality', '#F59E0B', 'Cats suitable for cat shows', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
  ('tag-3', 'tag-cat-2', 'Medical Attention', '#EF4444', 'Cats requiring special medical care', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
  ('tag-4', 'tag-cat-1', 'Retired', '#6B7280', 'Retired breeding cats', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
ON CONFLICT ("category_id", "name") DO NOTHING;

-- Insert sample breeding records
INSERT INTO "breeding_records" ("id", "maleId", "femaleId", "breedingDate", "expectedDueDate", "status", "recordedBy", "createdAt", "updatedAt")
VALUES 
  ('breeding-1', 'cat-2', 'cat-1', '2023-06-15', '2023-08-20', 'COMPLETED', 'user-1', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
  ('breeding-2', 'cat-4', 'cat-3', '2024-01-10', '2024-03-15', 'PLANNED', 'user-1', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
ON CONFLICT ("id") DO NOTHING;

-- Insert sample care records
INSERT INTO "care_records" ("id", "catId", "careType", "description", "careDate", "nextDueDate", "cost", "veterinarian", "recordedBy", "createdAt", "updatedAt")
VALUES 
  ('care-1', 'cat-1', 'VACCINATION', 'Annual vaccination - FVRCP', '2024-01-15', '2025-01-15', 85.00, 'Dr. Smith', 'user-1', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
  ('care-2', 'cat-2', 'HEALTH_CHECK', 'Routine health examination', '2024-02-20', '2024-08-20', 120.00, 'Dr. Johnson', 'user-1', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
  ('care-3', 'cat-3', 'GROOMING', 'Professional grooming session', '2024-03-10', '2024-06-10', 60.00, NULL, 'user-2', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
ON CONFLICT ("id") DO NOTHING;

-- Insert sample schedules
INSERT INTO "schedules" ("id", "title", "description", "scheduleDate", "scheduleType", "priority", "catId", "assignedTo", "createdAt", "updatedAt")
VALUES 
  ('schedule-1', 'Luna Vaccination Due', 'Annual vaccination for Luna', '2025-01-15', 'CARE', 'HIGH', 'cat-1', 'user-1', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
  ('schedule-2', 'Breeding Evaluation', 'Evaluate Max for breeding program', '2025-02-01', 'BREEDING', 'MEDIUM', 'cat-4', 'user-1', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP),
  ('schedule-3', 'Grooming Appointment', 'Regular grooming for Bella', '2025-02-10', 'CARE', 'LOW', 'cat-3', 'user-2', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
ON CONFLICT ("id") DO NOTHING;

-- Link some cats with tags
INSERT INTO "cat_tags" ("catId", "tagId", "createdAt")
VALUES 
  ('cat-1', 'tag-1', CURRENT_TIMESTAMP), -- Luna in breeding program
  ('cat-1', 'tag-2', CURRENT_TIMESTAMP), -- Luna is show quality
  ('cat-2', 'tag-1', CURRENT_TIMESTAMP), -- Shadow in breeding program
  ('cat-3', 'tag-2', CURRENT_TIMESTAMP), -- Bella is show quality
  ('cat-4', 'tag-1', CURRENT_TIMESTAMP)  -- Max in breeding program
ON CONFLICT ("catId", "tagId") DO NOTHING;
````

## File: supabase/.gitignore
````
# Supabase
.branches
.temp

# dotenvx
.env.keys
.env.local
.env.*.local
````

## File: supabase/config.toml
````toml
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "my-cats-pro"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false
# Paths to self-signed certificate pair.
# cert_path = "../certs/my-cert.pem"
# key_path = "../certs/my-key.pem"

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# Maximum amount of time to wait for health check when starting the local database.
health_timeout = "2m"
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 17

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

# [db.vault]
# secret_key = "env(SECRET_VALUE)"

[db.migrations]
# If disabled, migrations will be skipped during a db push or reset.
enabled = true
# Specifies an ordered list of schema files that describe your database.
# Supports glob patterns relative to supabase directory: "./schemas/*.sql"
schema_paths = []

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[db.network_restrictions]
# Enable management of network restrictions.
enabled = false
# List of IPv4 CIDR blocks allowed to connect to the database.
# Defaults to allow all IPv4 connections. Set empty array to block all IPs.
allowed_cidrs = ["0.0.0.0/0"]
# List of IPv6 CIDR blocks allowed to connect to the database.
# Defaults to allow all IPv6 connections. Set empty array to block all IPs.
allowed_cidrs_v6 = ["::/0"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

# Allow connections via S3 compatible clients
[storage.s3_protocol]
enabled = true

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Store analytical data in S3 for running ETL jobs over Iceberg Catalog
# This feature is only available on the hosted platform.
[storage.analytics]
enabled = false
max_namespaces = 5
max_tables = 10
max_catalogs = 2

# Analytics Buckets is available to Supabase Pro plan.
# [storage.analytics.buckets.my-warehouse]

# Store vector embeddings in S3 for large and durable datasets
# This feature is only available on the hosted platform.
[storage.vector]
enabled = false
max_buckets = 10
max_indexes = 5

# Vector Buckets is available to Supabase Pro plan.
# [storage.vector.buckets.documents-openai]

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# JWT issuer URL. If not set, defaults to the local API URL (http://127.0.0.1:<port>/auth/v1).
# jwt_issuer = ""
# Path to JWT signing key. DO NOT commit your signing keys file to git.
# signing_keys_path = "./signing_keys.json"
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

[auth.rate_limit]
# Number of emails that can be sent per hour. Requires auth.email.smtp to be enabled.
email_sent = 2
# Number of SMS messages that can be sent per hour. Requires auth.sms to be enabled.
sms_sent = 30
# Number of anonymous sign-ins that can be made per hour per IP address. Requires enable_anonymous_sign_ins = true.
anonymous_users = 30
# Number of sessions that can be refreshed in a 5 minute interval per IP address.
token_refresh = 150
# Number of sign up and sign-in requests that can be made in a 5 minute interval per IP address (excludes anonymous users).
sign_in_sign_ups = 30
# Number of OTP / Magic link verifications that can be made in a 5 minute interval per IP address.
token_verifications = 30
# Number of Web3 logins that can be made in a 5 minute interval per IP address.
web3 = 30

# Configure one of the supported captcha providers: `hcaptcha`, `turnstile`.
# [auth.captcha]
# enabled = true
# provider = "hcaptcha"
# secret = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

# Uncomment to customize notification email template
# [auth.email.notification.password_changed]
# enabled = true
# subject = "Your password has been changed"
# content_path = "./templates/password_changed_notification.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a new user is created and allows developers to reject the request based on the incoming user object.
# [auth.hook.before_user_created]
# enabled = true
# uri = "pg-functions://postgres/auth/before-user-created-hook"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `x`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false
# If enabled, it will allow the user to successfully authenticate when the provider does not return an email address.
email_optional = false

# Allow Solana wallet holders to sign in to your project via the Sign in with Solana (SIWS, EIP-4361) standard.
# You can configure "web3" rate limit in the [auth.rate_limit] section and set up [auth.captcha] if self-hosting.
[auth.web3.solana]
enabled = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

# Use Clerk as a third-party provider alongside Supabase Auth.
[auth.third_party.clerk]
enabled = false
# Obtain from https://clerk.com/setup/supabase
# domain = "example.clerk.accounts.dev"

# OAuth server configuration
[auth.oauth_server]
# Enable OAuth server functionality
enabled = false
# Path for OAuth consent flow UI
authorization_url_path = "/oauth/consent"
# Allow dynamic client registration
allow_dynamic_registration = false

[edge_runtime]
enabled = true
# Supported request policies: `oneshot`, `per_worker`.
# `per_worker` (default) â€” enables hot reload during local development.
# `oneshot` â€” fallback mode if hot reload causes issues (e.g. in large repos or with symlinks).
policy = "per_worker"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083
# The Deno major version to use.
deno_version = 2

# [edge_runtime.secrets]
# secret_key = "env(SECRET_VALUE)"

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"
````

## File: frontend/src/app/breeding/components/BirthPlanTab.tsx
````typescript
'use client';

import {
  Card,
  Text,
  Group,
  Flex,
  Stack,
  ActionIcon,
} from '@mantine/core';
import type { BirthPlan } from '@/lib/api/hooks/use-breeding';
import type { Cat } from '@/lib/api/hooks/use-cats';

export interface BirthPlanTabProps {
  birthPlans: BirthPlan[];
  allCats: Cat[];
  onBirthConfirm: (item: BirthPlan) => void;
  onBirthCancel: (item: BirthPlan) => void;
}

export function BirthPlanTab({
  birthPlans,
  allCats,
  onBirthConfirm,
  onBirthCancel,
}: BirthPlanTabProps) {
  // EXPECTED ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®ã¿è¡¨ç¤º
  const expectedPlans = birthPlans.filter((item) => item.status === 'EXPECTED');

  return (
    <Stack gap="sm">
      {expectedPlans.map((item) => {
        // çˆ¶çŒ«ã®åå‰ã‚’å–å¾—ï¼ˆfatherIdã‹ã‚‰ï¼‰
        const fatherName = item.fatherId 
          ? allCats.find((cat) => cat.id === item.fatherId)?.name || 'ä¸æ˜'
          : 'ä¸æ˜';
        
        return (
          <Card key={item.id} shadow="sm" padding="sm" radius="md" withBorder>
            <Flex justify="space-between" align="center" wrap="nowrap">
              <Group gap="md" wrap="nowrap">
                <Text fw={600} size="sm">
                  {item.mother?.name || 'ä¸æ˜'} ({fatherName})
                </Text>
                <Group gap={4} wrap="nowrap">
                  <Text size="sm" c="dimmed">
                    äº¤é…æ—¥: {item.matingDate ? new Date(item.matingDate).toLocaleDateString('ja-JP', { month: 'numeric', day: 'numeric' }) : 'ä¸æ˜'}
                  </Text>
                  <Text size="sm" c="dimmed">
                    å‡ºç”£äºˆå®šæ—¥: {new Date(item.expectedBirthDate).toLocaleDateString('ja-JP', { month: 'numeric', day: 'numeric' })}
                  </Text>
                </Group>
              </Group>
              <Group gap="xs" wrap="nowrap">
                <ActionIcon
                  color="green"
                  variant="light"
                  size="md"
                  onClick={() => onBirthConfirm(item)}
                  title="å‡ºç”£ç¢ºèª"
                >
                  â—‹
                </ActionIcon>
                <ActionIcon
                  color="red"
                  variant="light"
                  size="md"
                  onClick={() => onBirthCancel(item)}
                  title="å‡ºç”£ãªã—"
                >
                  Ã—
                </ActionIcon>
              </Group>
            </Flex>
          </Card>
        );
      })}
      {expectedPlans.length === 0 && (
        <Text ta="center" c="dimmed" py="xl">
          ç¾åœ¨å‡ºç”£äºˆå®šã®çŒ«ã¯ã„ã¾ã›ã‚“
        </Text>
      )}
    </Stack>
  );
}
````

## File: frontend/src/app/breeding/components/BreedingScheduleTab.tsx
````typescript
'use client';

import {
  Box,
  Card,
  Text,
  Button,
  Group,
  Flex,
  Badge,
  Table,
  Select,
  ActionIcon,
  ScrollArea,
} from '@mantine/core';
import { notifications } from '@mantine/notifications';
import { ActionButton } from '@/components/ActionButton';
import { ContextMenuProvider } from '@/components/context-menu';
import type { Cat } from '@/lib/api/hooks/use-cats';
import type { BreedingScheduleEntry } from '../types';
import { generateMonthDates } from '../utils';

export interface BreedingScheduleTabProps {
  // çŠ¶æ…‹
  isFullscreen: boolean;
  selectedYear: number;
  selectedMonth: number;
  activeMales: Cat[];
  breedingSchedule: Record<string, BreedingScheduleEntry>;
  selectedMaleForEdit: string | null;
  
  // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
  onYearChange: (year: number) => void;
  onMonthChange: (month: number) => void;
  onOpenMaleModal: () => void;
  onMaleSelect: (maleId: string, date: string) => void;
  onMaleNameClick: (maleId: string) => void;
  onRemoveMale: (maleId: string) => void;
  onSaveMaleEdit: () => void;
  onMatingCheck: (maleId: string, femaleId: string, date: string) => void;
  onMatingResult: (maleId: string, femaleId: string, femaleName: string, date: string, result: 'success' | 'failure') => void;
  onScheduleContextAction: (action: string, entity: BreedingScheduleEntry) => void;
  onClearData: () => void;
  
  // ãƒ˜ãƒ«ãƒ‘ãƒ¼
  getMatingCheckCount: (maleId: string, femaleId: string, date: string) => number;
}

export function BreedingScheduleTab({
  isFullscreen,
  selectedYear,
  selectedMonth,
  activeMales,
  breedingSchedule,
  selectedMaleForEdit,
  onYearChange,
  onMonthChange,
  onOpenMaleModal,
  onMaleSelect,
  onMaleNameClick,
  onRemoveMale,
  onSaveMaleEdit,
  onMatingCheck,
  onMatingResult,
  onScheduleContextAction,
  onClearData,
  getMatingCheckCount,
}: BreedingScheduleTabProps) {
  const monthDates = generateMonthDates(selectedYear, selectedMonth);

  const handleClearData = () => {
    if (window.confirm('äº¤é…ç®¡ç†è¡¨ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã‹ï¼Ÿ\nï¼ˆå¦Šå¨ ç¢ºèªä¸­ãƒ»å‡ºç”£äºˆå®šãªã©ã®ãƒ‡ãƒ¼ã‚¿ã¯å‰Šé™¤ã•ã‚Œã¾ã›ã‚“ï¼‰')) {
      onClearData();
      notifications.show({
        title: 'ã‚¯ãƒªã‚¢å®Œäº†',
        message: 'äº¤é…ç®¡ç†è¡¨ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ',
        color: 'teal',
      });
    }
  };

  return (
    <Card 
      shadow="sm" 
      padding={isFullscreen ? "xs" : "md"} 
      radius="md" 
      withBorder 
      mb="md"
      style={{ height: isFullscreen ? 'calc(100vh - 180px)' : 'auto' }}
    >
      <Group gap="xs" mb="md" align="flex-end">
        <Select
          value={selectedYear.toString()}
          onChange={(value) => onYearChange(parseInt(value || '2024'))}
          data={['2024', '2025', '2026'].map(year => ({ value: year, label: year }))}
          size={isFullscreen ? "xs" : "sm"}
          styles={{ input: { width: '80px' } }}
        />
        <Text size="sm" pb={isFullscreen ? 4 : 8}>å¹´</Text>
        <Select
          value={selectedMonth.toString()}
          onChange={(value) => onMonthChange(parseInt(value || '8'))}
          data={Array.from({ length: 12 }, (_, i) => ({
            value: (i + 1).toString(),
            label: String(i + 1).padStart(2, '0')
          }))}
          size={isFullscreen ? "xs" : "sm"}
          styles={{ input: { width: '70px' } }}
        />
        <Text size="sm" pb={isFullscreen ? 4 : 8}>æœˆ</Text>
        <ActionButton
          action="create"
          onClick={onOpenMaleModal}
          isSectionAction
        >
          ã‚ªã‚¹è¿½åŠ 
        </ActionButton>
        <ActionButton
          action="cancel"
          onClick={handleClearData}
          isSectionAction
          title="localStorageã«ä¿å­˜ã•ã‚ŒãŸäº¤é…ç®¡ç†è¡¨ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢"
        >
          ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªã‚¢
        </ActionButton>
      </Group>
      
      <ScrollArea 
        style={{ 
          height: isFullscreen ? 'calc(100% - 80px)' : '600px',
          width: '100%'
        }}
      >
        <Table
          style={{ 
            fontSize: isFullscreen ? '11px' : '14px',
            minWidth: isFullscreen ? '1200px' : '800px',
            position: 'relative'
          }}
        >
          <Table.Thead 
            style={{ 
              position: 'sticky',
              top: 0,
              backgroundColor: 'var(--surface)',
              zIndex: 10,
              borderBottom: '2px solid var(--border-subtle)'
            }}
          >
            <Table.Tr>
              <Table.Th 
                style={{ 
                  width: isFullscreen ? 60 : 80,
                  minWidth: isFullscreen ? 60 : 80,
                  maxWidth: isFullscreen ? 60 : 80,
                  position: 'sticky',
                  left: 0,
                  backgroundColor: 'var(--surface)',
                  zIndex: 11,
                  borderRight: '2px solid var(--border-subtle)'
                }}
              >
                <Flex align="center" gap={4} justify="center">
                  <Text size={isFullscreen ? "xs" : "sm"} fw={600}>
                    æ—¥ä»˜
                  </Text>
                </Flex>
              </Table.Th>
              {activeMales.map((male) => (
                <Table.Th 
                  key={male.id} 
                  style={{ 
                    minWidth: isFullscreen ? 100 : 120,
                    borderRight: '1px solid var(--border-subtle)'
                  }}
                >
                  <Box
                    onClick={() => onMaleNameClick(male.id)}
                    style={{ cursor: 'pointer', position: 'relative' }}
                  >
                    <Text fw={600} size={isFullscreen ? "xs" : "sm"} ta="center">
                      {male.name}
                    </Text>
                  </Box>
                  {selectedMaleForEdit === male.id && (
                    <Group gap="xs" justify="center" mt="xs">
                      <Button
                        size="xs"
                        color="red"
                        onClick={() => onRemoveMale(male.id)}
                      >
                        å‰Šé™¤
                      </Button>
                      <Button
                        size="xs"
                        onClick={onSaveMaleEdit}
                      >
                        ä¿å­˜
                      </Button>
                    </Group>
                  )}
                </Table.Th>
              ))}
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>
            {monthDates.map(({ date, dateString, dayOfWeek }) => (
              <Table.Tr key={date}>
                <Table.Td
                  style={{
                    width: isFullscreen ? 60 : 80,
                    minWidth: isFullscreen ? 60 : 80,
                    maxWidth: isFullscreen ? 60 : 80,
                    position: 'sticky',
                    left: 0,
                    backgroundColor: 'var(--surface)',
                    zIndex: 5,
                    borderRight: '1px solid var(--border-subtle)'
                  }}
                >
                  <Flex align="center" gap={4} justify="center">
                    <Text 
                      size={isFullscreen ? "xs" : "sm"} 
                      fw={dayOfWeek === 0 || dayOfWeek === 6 ? 600 : 400}
                      c={dayOfWeek === 0 ? 'red' : dayOfWeek === 6 ? 'blue' : undefined}
                    >
                      {date}æ—¥
                    </Text>
                    <Text 
                      size={isFullscreen ? "8px" : "xs"} 
                      c={dayOfWeek === 0 ? 'red' : dayOfWeek === 6 ? 'blue' : 'dimmed'}
                    >
                      ({['æ—¥', 'æœˆ', 'ç«', 'æ°´', 'æœ¨', 'é‡‘', 'åœŸ'][dayOfWeek]})
                    </Text>
                  </Flex>
                </Table.Td>
                {activeMales.map((male) => {
                  const scheduleKey = `${male.id}-${dateString}`;
                  const schedule = breedingSchedule[scheduleKey];
                  
                  // æ¬¡ã®æ—¥ã‚‚åŒã˜äº¤é…æœŸé–“ã‹ãƒã‚§ãƒƒã‚¯
                  const nextDate = new Date(selectedYear, selectedMonth, date + 1);
                  const nextDateString = `${nextDate.getFullYear()}-${String(nextDate.getMonth() + 1).padStart(2, '0')}-${String(nextDate.getDate()).padStart(2, '0')}`;
                  const nextScheduleKey = `${male.id}-${nextDateString}`;
                  const nextSchedule = breedingSchedule[nextScheduleKey];
                  const hasNextSameMating = schedule && nextSchedule && 
                    schedule.femaleName === nextSchedule.femaleName && 
                    !schedule.isHistory && !nextSchedule.isHistory;
                  
                  return (
                    <Table.Td 
                      key={male.id} 
                      style={{ 
                        textAlign: 'center',
                        borderRight: hasNextSameMating ? 'none' : '1px solid var(--border-subtle)',
                        backgroundColor: schedule && !schedule.isHistory ? '#fffacd' : 'transparent'
                      }}
                    >
                      {schedule ? (
                        <ScheduleCell
                          schedule={schedule}
                          maleId={male.id}
                          dateString={dateString}
                          isFullscreen={isFullscreen}
                          getMatingCheckCount={getMatingCheckCount}
                          onMatingCheck={onMatingCheck}
                          onMatingResult={onMatingResult}
                          onScheduleContextAction={onScheduleContextAction}
                        />
                      ) : (
                        <Button
                          variant="subtle"
                          size={isFullscreen ? "xs" : "sm"}
                          onClick={() => onMaleSelect(male.id, dateString)}
                          style={{ 
                            width: '100%',
                            height: isFullscreen ? '24px' : '32px'
                          }}
                        >
                          +
                        </Button>
                      )}
                    </Table.Td>
                  );
                })}
              </Table.Tr>
            ))}
          </Table.Tbody>
        </Table>
      </ScrollArea>
    </Card>
  );
}

// ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚»ãƒ«å†…éƒ¨ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
interface ScheduleCellProps {
  schedule: BreedingScheduleEntry;
  maleId: string;
  dateString: string;
  isFullscreen: boolean;
  getMatingCheckCount: (maleId: string, femaleId: string, date: string) => number;
  onMatingCheck: (maleId: string, femaleId: string, date: string) => void;
  onMatingResult: (maleId: string, femaleId: string, femaleName: string, date: string, result: 'success' | 'failure') => void;
  onScheduleContextAction: (action: string, entity: BreedingScheduleEntry) => void;
}

function ScheduleCell({
  schedule,
  maleId,
  dateString,
  isFullscreen,
  getMatingCheckCount,
  onMatingCheck,
  onMatingResult,
  onScheduleContextAction,
}: ScheduleCellProps) {
  const checkCount = getMatingCheckCount(maleId, schedule.femaleId, dateString);

  if (schedule.isHistory) {
    // å±¥æ­´ï¼šåå‰ã¨ãƒã‚§ãƒƒã‚¯ãƒãƒ¼ã‚¯ã‚’ä¸€è¡Œè¡¨ç¤º
    return (
      <ContextMenuProvider
        entity={schedule}
        actions={['edit', 'delete']}
        onAction={(action) => onScheduleContextAction(action, schedule)}
      >
        <Box 
          style={{ 
            position: 'relative', 
            width: '100%', 
            height: '100%', 
            minHeight: isFullscreen ? '28px' : '32px', 
            display: 'flex', 
            flexDirection: 'column', 
            justifyContent: 'center', 
            opacity: 0.6, 
            cursor: 'pointer' 
          }}
          title="ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯å³ã‚¯ãƒªãƒƒã‚¯ã§æ“ä½œ"
        >
          <Flex align="center" gap={4} style={{ minHeight: isFullscreen ? '24px' : '28px' }}>
            {(schedule.dayIndex === 0 || schedule.dayIndex === schedule.duration - 1) && (
              <Badge size={isFullscreen ? "xs" : "sm"} color="gray" variant="light">
                {schedule.femaleName}
              </Badge>
            )}
            <Box
              style={{
                flex: 1,
                minHeight: isFullscreen ? '20px' : '24px',
                padding: '2px 4px',
                borderRadius: '3px',
                border: '1px dashed #d3d3d3',
                backgroundColor: checkCount > 0 ? '#f8f8f8' : 'transparent',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center'
              }}
            >
              {checkCount > 0 ? (
                <Text size={isFullscreen ? "8px" : "xs"} c="dimmed" ta="center" lh={1}>
                  {'âœ“'.repeat(checkCount)}
                </Text>
              ) : (
                <Text size="8px" c="dimmed" ta="center" style={{ opacity: 0.3 }} lh={1}>
                  -
                </Text>
              )}
            </Box>
          </Flex>
        </Box>
      </ContextMenuProvider>
    );
  }

  // ç¾åœ¨ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
  return (
    <ContextMenuProvider
      entity={schedule}
      actions={['edit', 'delete']}
      onAction={(action) => onScheduleContextAction(action, schedule)}
    >
      <Box 
        style={{ 
          position: 'relative', 
          width: '100%', 
          height: '100%', 
          minHeight: isFullscreen ? '28px' : '32px', 
          display: 'flex', 
          flexDirection: 'column', 
          justifyContent: 'center', 
          cursor: 'pointer' 
        }}
        title="ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯å³ã‚¯ãƒªãƒƒã‚¯ã§æ“ä½œ"
      >
        <Flex align="center" gap={4} style={{ minHeight: isFullscreen ? '24px' : '28px' }}>
          {(schedule.dayIndex === 0 || schedule.dayIndex === schedule.duration - 1) && (
            <Badge size={isFullscreen ? "xs" : "sm"} color="pink">
              {schedule.femaleName}
            </Badge>
          )}
          
          {schedule.dayIndex === schedule.duration - 1 ? (
            <Group gap={2}>
              <ActionIcon
                size={isFullscreen ? "xs" : "sm"}
                variant="light"
                color="green"
                onClick={(e) => {
                  e.stopPropagation();
                  onMatingResult(maleId, schedule.femaleId, schedule.femaleName, schedule.date, 'success');
                }}
                title="äº¤é…æˆåŠŸ"
              >
                â—‹
              </ActionIcon>
              <ActionIcon
                size={isFullscreen ? "xs" : "sm"}
                variant="light"
                color="red"
                onClick={(e) => {
                  e.stopPropagation();
                  onMatingResult(maleId, schedule.femaleId, schedule.femaleName, schedule.date, 'failure');
                }}
                title="äº¤é…å¤±æ•—"
              >
                Ã—
              </ActionIcon>
            </Group>
          ) : (
            <Box
              style={{
                flex: 1,
                minHeight: isFullscreen ? '16px' : '18px',
                cursor: 'pointer',
                padding: '1px 4px',
                borderRadius: '3px',
                border: '1px dashed var(--border-subtle)',
                backgroundColor: checkCount > 0 ? '#f0f9f0' : 'transparent',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center'
              }}
              onClick={(e) => {
                e.stopPropagation();
                onMatingCheck(maleId, schedule.femaleId, dateString);
              }}
              title="ã‚¯ãƒªãƒƒã‚¯ã—ã¦äº¤é…è¨˜éŒ²ã‚’è¿½åŠ "
            >
              {checkCount > 0 ? (
                <Text size={isFullscreen ? "8px" : "xs"} c="green" ta="center" lh={1}>
                  {'âœ“'.repeat(checkCount)}
                </Text>
              ) : (
                <Text size="8px" c="dimmed" ta="center" style={{ opacity: 0.5 }} lh={1}>
                  +
                </Text>
              )}
            </Box>
          )}
        </Flex>
      </Box>
    </ContextMenuProvider>
  );
}
````

## File: frontend/src/app/breeding/components/PregnancyCheckTab.tsx
````typescript
'use client';

import {
  Card,
  Text,
  Group,
  Flex,
  Stack,
  ActionIcon,
} from '@mantine/core';
import type { PregnancyCheck } from '@/lib/api/hooks/use-breeding';
import type { Cat } from '@/lib/api/hooks/use-cats';

export interface PregnancyCheckTabProps {
  pregnancyChecks: PregnancyCheck[];
  allCats: Cat[];
  onPregnancyCheck: (item: PregnancyCheck, isPregnant: boolean) => void;
}

export function PregnancyCheckTab({
  pregnancyChecks,
  allCats,
  onPregnancyCheck,
}: PregnancyCheckTabProps) {
  return (
    <Stack gap="sm">
      {pregnancyChecks.map((item) => {
        // çˆ¶çŒ«ã®åå‰ã‚’å–å¾—ï¼ˆfatherIdã‹ã‚‰ï¼‰
        const fatherName = item.fatherId 
          ? allCats.find((cat) => cat.id === item.fatherId)?.name || 'ä¸æ˜'
          : 'ä¸æ˜';
        
        // ç¢ºèªäºˆå®šæ—¥ã‚’è¨ˆç®—ï¼ˆäº¤é…æ—¥ã®25æ—¥å¾Œï¼‰
        const scheduledCheckDate = item.matingDate 
          ? (() => {
              const date = new Date(item.matingDate);
              date.setDate(date.getDate() + 25);
              return date.toLocaleDateString('ja-JP', { month: 'numeric', day: 'numeric' });
            })()
          : 'ä¸æ˜';
        
        return (
          <Card key={item.id} shadow="sm" padding="sm" radius="md" withBorder>
            <Flex justify="space-between" align="center" wrap="nowrap">
              <Group gap="md" wrap="nowrap">
                <Text fw={600} size="sm">
                  {item.mother?.name || 'ä¸æ˜'} ({fatherName})
                </Text>
                <Group gap={4} wrap="nowrap">
                  <Text size="sm" c="dimmed">
                    äº¤é…æ—¥: {item.matingDate ? new Date(item.matingDate).toLocaleDateString('ja-JP', { month: 'numeric', day: 'numeric' }) : 'ä¸æ˜'}
                  </Text>
                  <Text size="sm" c="dimmed">
                    å¦Šå¨ ç¢ºèªäºˆå®šæ—¥: {scheduledCheckDate}
                  </Text>
                </Group>
              </Group>
              <Group gap="xs" wrap="nowrap">
                <ActionIcon
                  color="green"
                  variant="light"
                  size="md"
                  onClick={() => onPregnancyCheck(item, true)}
                  title="å¦Šå¨ ç¢ºå®š"
                >
                  â—‹
                </ActionIcon>
                <ActionIcon
                  color="red"
                  variant="light"
                  size="md"
                  onClick={() => onPregnancyCheck(item, false)}
                  title="éå¦Šå¨ "
                >
                  Ã—
                </ActionIcon>
              </Group>
            </Flex>
          </Card>
        );
      })}
      {pregnancyChecks.length === 0 && (
        <Text ta="center" c="dimmed" py="xl">
          ç¾åœ¨å¦Šå¨ ç¢ºèªä¸­ã®çŒ«ã¯ã„ã¾ã›ã‚“
        </Text>
      )}
    </Stack>
  );
}
````

## File: frontend/src/app/breeding/components/WeightTab.tsx
````typescript
'use client';

import { useState } from 'react';
import { useDisclosure } from '@mantine/hooks';
import WeightRecordTable from '@/components/kittens/WeightRecordTable';
import { WeightRecordModal } from '@/components/kittens/WeightRecordModal';
import BulkWeightRecordModal from '@/components/kittens/BulkWeightRecordModal';
import type { Cat } from '@/lib/api/hooks/use-cats';
import type { BirthPlan } from '@/lib/api/hooks/use-breeding';
import { calculateAgeInDays } from '../utils';

interface MotherWithKittens {
  id: string;
  name: string;
  fatherName: string;
  kittens: {
    id: string;
    name: string;
    color: string;
    gender: 'ã‚ªã‚¹' | 'ãƒ¡ã‚¹';
  }[];
  deliveryDate: string;
  daysOld: number;
}

export interface WeightTabProps {
  /**
   * ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®çŒ«ä¸€è¦§ï¼ˆæ¯çŒ«ãƒ»çˆ¶çŒ«ãƒ»å­çŒ«ã‚’å«ã‚€ï¼‰
   */
  allCats: Cat[];
  /**
   * å‡ºç”£äºˆå®šãŠã‚ˆã³å‡ºç”£æ¸ˆã¿ã®è¨ˆç”»ä¸€è¦§ï¼ˆæ¯çŒ«ã‚„å­çŒ«ã®æƒ…å ±ã‚’å«ã‚€ï¼‰
   */
  birthPlans: BirthPlan[];
  /**
   * ä½“é‡è¨˜éŒ²ã‚„é–¢é€£ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­ã‹ã©ã†ã‹
   */
  isLoading: boolean;
  /**
   * ä½“é‡è¨˜éŒ²ã®ç™»éŒ²ãƒ»æ›´æ–°å¾Œã«ãƒ‡ãƒ¼ã‚¿ã‚’å†å–å¾—ã™ã‚‹ãŸã‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯
   */
  onRefetch: () => void;
}

/**
 * ä½“é‡ç®¡ç†ã‚¿ãƒ–ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * å­çŒ«ã®ä½“é‡è¨˜éŒ²ã‚’ç®¡ç†ã™ã‚‹
 */
export function WeightTab({
  allCats,
  birthPlans,
  isLoading,
  onRefetch,
}: WeightTabProps) {
  // ä½“é‡è¨˜éŒ²ãƒ¢ãƒ¼ãƒ€ãƒ«
  const [weightModalOpened, { open: openWeightModal, close: closeWeightModal }] = useDisclosure(false);
  const [selectedKittenForWeight, setSelectedKittenForWeight] = useState<{ id: string; name: string } | null>(null);

  // ä¸€æ‹¬ä½“é‡è¨˜éŒ²ãƒ¢ãƒ¼ãƒ€ãƒ«
  const [bulkWeightModalOpened, { open: openBulkWeightModal, close: closeBulkWeightModal }] = useDisclosure(false);

  // å­çŒ«ã‚’æŒã¤æ¯çŒ«ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
  const mothersWithKittens: MotherWithKittens[] = allCats
    .filter((cat) => {
      // æœªå®Œäº†ã®å‡ºç”£è¨˜éŒ²ã‚’æŒã¤æ¯çŒ«ã‚’ç¢ºèª
      const activeBirthPlan = birthPlans.find(
        (bp) => bp.motherId === cat.id && bp.status === 'BORN' && !bp.completedAt
      );
      
      if (!activeBirthPlan) return false;
      
      // ç”Ÿå¾Œ90æ—¥ä»¥å†…ã®å­çŒ«ãŒã„ã‚‹æ¯çŒ«ã‚’æŠ½å‡º
      const hasYoungKittens = allCats.some((kitten) => {
        if (kitten.motherId !== cat.id) return false;
        
        const ageInDays = calculateAgeInDays(kitten.birthDate);
        
        return ageInDays <= 90;
      });
      
      return hasYoungKittens;
    })
    .map((mother) => {
      // ã“ã®æ¯çŒ«ã®å­çŒ«ã‚’å–å¾—
      const kittens = allCats.filter((kitten) => {
        if (kitten.motherId !== mother.id) return false;
        
        const ageInDays = calculateAgeInDays(kitten.birthDate);
        
        return ageInDays <= 90;
      });

      // çˆ¶çŒ«ã‚’å–å¾—
      const birthPlan = birthPlans.find(
        (bp) => bp.motherId === mother.id && bp.status === 'BORN'
      );
      const father = birthPlan?.fatherId
        ? allCats.find((c) => c.id === birthPlan.fatherId)
        : null;

      // å‡ºç”£æ—¥ã‚’å–å¾—
      const oldestKitten = kittens.length > 0
        ? kittens.reduce((oldest, k) =>
            new Date(k.birthDate) < new Date(oldest.birthDate) ? k : oldest
          )
        : null;

      const deliveryDate = oldestKitten
        ? new Date(oldestKitten.birthDate).toLocaleDateString('ja-JP')
        : '';

      const daysOld = oldestKitten
        ? calculateAgeInDays(oldestKitten.birthDate)
        : 0;

      return {
        id: mother.id,
        name: mother.name,
        fatherName: father?.name ?? 'ä¸æ˜',
        kittens: kittens.map((k) => ({
          id: k.id,
          name: k.name,
          color: k.coatColor?.name ?? 'æœªç¢ºèª',
          gender: k.gender === 'MALE' ? 'ã‚ªã‚¹' as const : 'ãƒ¡ã‚¹' as const,
        })),
        deliveryDate,
        daysOld,
      };
    });

  const handleRecordWeight = (kitten: { id: string; name: string }) => {
    setSelectedKittenForWeight(kitten);
    openWeightModal();
  };

  if (isLoading) {
    return null;
  }

  return (
    <>
      <WeightRecordTable
        motherCats={mothersWithKittens}
        onRecordWeight={handleRecordWeight}
        onBulkRecord={openBulkWeightModal}
      />

      {/* ä½“é‡è¨˜éŒ²ãƒ¢ãƒ¼ãƒ€ãƒ« */}
      {selectedKittenForWeight && (
        <WeightRecordModal
          opened={weightModalOpened}
          onClose={closeWeightModal}
          catId={selectedKittenForWeight.id}
          catName={selectedKittenForWeight.name}
          onSuccess={onRefetch}
        />
      )}

      {/* ä¸€æ‹¬ä½“é‡è¨˜éŒ²ãƒ¢ãƒ¼ãƒ€ãƒ« */}
      <BulkWeightRecordModal
        opened={bulkWeightModalOpened}
        onClose={closeBulkWeightModal}
        motherGroups={mothersWithKittens.map((mother) => ({
          motherId: mother.id,
          motherName: mother.name,
          fatherName: mother.fatherName,
          deliveryDate: mother.deliveryDate,
          kittens: mother.kittens.map((k) => ({
            id: k.id,
            name: k.name,
            gender: k.gender,
            color: k.color,
          })),
        }))}
        onSuccess={onRefetch}
      />
    </>
  );
}
````

## File: frontend/src/app/cats/[id]/pedigree/page.tsx
````typescript
'use client';

import { useRouter } from 'next/navigation';
import {
  Box,
  Button,
  Card,
  Container,
  Stack,
  Title,
  Text,
  Flex,
  Grid,
} from '@mantine/core';
import { IconArrowLeft } from '@tabler/icons-react';

// ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿
const pedigreeData = {
  id: '1',
  name: 'ãƒ¬ã‚ª',
  generation1: { // è¦ª
    father: { name: 'ãƒ‘ãƒ‘çŒ«', color: 'èŒ¶ãƒˆãƒ©' },
    mother: { name: 'ãƒãƒçŒ«', color: 'ä¸‰æ¯›' }
  },
  generation2: { // ç¥–çˆ¶æ¯
    paternalGrandfather: { name: 'ç¥–çˆ¶1', color: 'èŒ¶ãƒˆãƒ©' },
    paternalGrandmother: { name: 'ç¥–æ¯1', color: 'ç™½' },
    maternalGrandfather: { name: 'ç¥–çˆ¶2', color: 'é»’' },
    maternalGrandmother: { name: 'ç¥–æ¯2', color: 'ä¸‰æ¯›' }
  },
  generation3: { // æ›¾ç¥–çˆ¶æ¯
    ppgf: { name: 'æ›¾ç¥–çˆ¶1', color: 'èŒ¶ãƒˆãƒ©' }, // paternal paternal grandfather
    ppgm: { name: 'æ›¾ç¥–æ¯1', color: 'ç™½' },     // paternal paternal grandmother
    pmgf: { name: 'æ›¾ç¥–çˆ¶2', color: 'èŒ¶' },     // paternal maternal grandfather
    pmgm: { name: 'æ›¾ç¥–æ¯2', color: 'ç™½' },     // paternal maternal grandmother
    mpgf: { name: 'æ›¾ç¥–çˆ¶3', color: 'é»’' },     // maternal paternal grandfather
    mpgm: { name: 'æ›¾ç¥–æ¯3', color: 'ç°' },     // maternal paternal grandmother
    mmgf: { name: 'æ›¾ç¥–çˆ¶4', color: 'ä¸‰æ¯›' },   // maternal maternal grandfather
    mmgm: { name: 'æ›¾ç¥–æ¯4', color: 'èŒ¶' }      // maternal maternal grandmother
  }
};

const CatCard = ({ cat, level = 0 }: { cat: { name: string; color: string } | null; level?: number }) => {
  if (!cat) {
    return (
      <Card shadow="sm" padding="sm" radius="md" withBorder style={{ minHeight: 60, opacity: 0.3 }}>
        <Text size="sm" c="dimmed">ä¸æ˜</Text>
      </Card>
    );
  }

  const colors = {
    0: '#e3f2fd', // æœ¬äºº: ãƒ©ã‚¤ãƒˆãƒ–ãƒ«ãƒ¼
    1: '#f3e5f5', // è¦ª: ãƒ©ã‚¤ãƒˆãƒ‘ãƒ¼ãƒ—ãƒ«
    2: '#e8f5e8', // ç¥–çˆ¶æ¯: ãƒ©ã‚¤ãƒˆã‚°ãƒªãƒ¼ãƒ³
    3: '#fff3e0'  // æ›¾ç¥–çˆ¶æ¯: ãƒ©ã‚¤ãƒˆã‚ªãƒ¬ãƒ³ã‚¸
  };

  return (
    <Card
      shadow="sm"
      padding="sm"
      radius="md"
      withBorder
      style={{
        backgroundColor: colors[level as keyof typeof colors] || '#f5f5f5',
        minHeight: 60
      }}
    >
      <Stack gap="xs">
        <Text fw={600} size="sm">{cat.name}</Text>
        <Text size="xs" c="dimmed">{cat.color}</Text>
      </Stack>
    </Card>
  );
};

export default function PedigreePage() {
  const router = useRouter();
  // const params = useParams();

  return (
    <Box style={{ minHeight: '100vh', backgroundColor: 'var(--background-base)' }}>
      {/* ãƒ˜ãƒƒãƒ€ãƒ¼ */}
      <Box
        style={{
          backgroundColor: 'var(--surface)',
          borderBottom: '1px solid var(--border-subtle)',
          padding: '1rem 0',
          boxShadow: '0 6px 20px rgba(15, 23, 42, 0.04)',
        }}
      >
        <Container size="xl">
          <Flex justify="space-between" align="center">
            <Button
              variant="light"
              leftSection={<IconArrowLeft size={16} />}
              onClick={() => router.back()}
            >
              æˆ»ã‚‹
            </Button>
          </Flex>
        </Container>
      </Box>

      <Container size="xl" style={{ paddingTop: '2rem' }}>
        <Title order={1} mb="lg" ta="center">
          {pedigreeData.name}ã®è¡€çµ±è¡¨ï¼ˆ4ä¸–ä»£ï¼‰
        </Title>

        {/* è¡€çµ±è¡¨ã‚°ãƒªãƒƒãƒ‰ */}
        <Box style={{ overflowX: 'auto' }}>
          <Grid style={{ minWidth: '1200px' }}>
            {/* ç¬¬1åˆ—: æœ¬äºº */}
            <Grid.Col span={3}>
              <Stack gap="md" style={{ height: '100%', justifyContent: 'center' }}>
                <CatCard cat={{ name: pedigreeData.name, color: 'èŒ¶ãƒˆãƒ©' }} level={0} />
              </Stack>
            </Grid.Col>

            {/* ç¬¬2åˆ—: è¦ª */}
            <Grid.Col span={3}>
              <Stack gap="md" style={{ height: '100%' }}>
                <CatCard cat={pedigreeData.generation1.father} level={1} />
                <CatCard cat={pedigreeData.generation1.mother} level={1} />
              </Stack>
            </Grid.Col>

            {/* ç¬¬3åˆ—: ç¥–çˆ¶æ¯ */}
            <Grid.Col span={3}>
              <Stack gap="md" style={{ height: '100%' }}>
                <CatCard cat={pedigreeData.generation2.paternalGrandfather} level={2} />
                <CatCard cat={pedigreeData.generation2.paternalGrandmother} level={2} />
                <CatCard cat={pedigreeData.generation2.maternalGrandfather} level={2} />
                <CatCard cat={pedigreeData.generation2.maternalGrandmother} level={2} />
              </Stack>
            </Grid.Col>

            {/* ç¬¬4åˆ—: æ›¾ç¥–çˆ¶æ¯ */}
            <Grid.Col span={3}>
              <Stack gap="md" style={{ height: '100%' }}>
                <CatCard cat={pedigreeData.generation3.ppgf} level={3} />
                <CatCard cat={pedigreeData.generation3.ppgm} level={3} />
                <CatCard cat={pedigreeData.generation3.pmgf} level={3} />
                <CatCard cat={pedigreeData.generation3.pmgm} level={3} />
                <CatCard cat={pedigreeData.generation3.mpgf} level={3} />
                <CatCard cat={pedigreeData.generation3.mpgm} level={3} />
                <CatCard cat={pedigreeData.generation3.mmgf} level={3} />
                <CatCard cat={pedigreeData.generation3.mmgm} level={3} />
              </Stack>
            </Grid.Col>
          </Grid>
        </Box>

        {/* ä¸–ä»£ãƒ©ãƒ™ãƒ« */}
        <Box mt="xl">
          <Grid>
            <Grid.Col span={3}>
              <Text ta="center" fw={600} c="blue">æœ¬äºº</Text>
            </Grid.Col>
            <Grid.Col span={3}>
              <Text ta="center" fw={600} c="purple">è¦ªï¼ˆç¬¬1ä¸–ä»£ï¼‰</Text>
            </Grid.Col>
            <Grid.Col span={3}>
              <Text ta="center" fw={600} c="green">ç¥–çˆ¶æ¯ï¼ˆç¬¬2ä¸–ä»£ï¼‰</Text>
            </Grid.Col>
            <Grid.Col span={3}>
              <Text ta="center" fw={600} c="orange">æ›¾ç¥–çˆ¶æ¯ï¼ˆç¬¬3ä¸–ä»£ï¼‰</Text>
            </Grid.Col>
          </Grid>
        </Box>

        {/* æ³¨æ„æ›¸ã */}
        <Card shadow="sm" padding="lg" radius="md" withBorder mt="xl">
          <Title order={3} mb="md">è¡€çµ±è¡¨ã«ã¤ã„ã¦</Title>
          <Stack gap="sm">
            <Text size="sm">â€¢ ã“ã®è¡€çµ±è¡¨ã¯4ä¸–ä»£ï¼ˆæœ¬äºº + è¦ªã€ç¥–çˆ¶æ¯ã€æ›¾ç¥–çˆ¶æ¯ï¼‰ã‚’è¡¨ç¤ºã—ã¦ã„ã¾ã™</Text>
            <Text size="sm">â€¢ å„ä¸–ä»£ã¯è‰²åˆ†ã‘ã•ã‚Œã¦ãŠã‚Šã€ä¸–ä»£ãŒå¤ããªã‚‹ã»ã©è–„ã„è‰²ã«ãªã‚Šã¾ã™</Text>
            <Text size="sm">â€¢ ä¸æ˜ãªå€‹ä½“ã¯ã€Œä¸æ˜ã€ã¨è¡¨ç¤ºã•ã‚Œã¾ã™</Text>
            <Text size="sm">â€¢ ã‚ˆã‚Šè©³ç´°ãªè¡€çµ±æƒ…å ±ãŒå¿…è¦ãªå ´åˆã¯ã€å€‹åˆ¥ã«ãŠå•ã„åˆã‚ã›ãã ã•ã„</Text>
          </Stack>
        </Card>
      </Container>
    </Box>
  );
}
````

## File: frontend/src/app/demo/action-buttons/page.tsx
````typescript
'use client';

/**
 * ActionButtonã®ä½¿ç”¨ä¾‹ãƒ‡ãƒ¢ãƒšãƒ¼ã‚¸
 * çµ±ä¸€ã•ã‚ŒãŸCRUDæ“ä½œãƒœã‚¿ãƒ³ã®ãƒ‡ã‚¶ã‚¤ãƒ³ã‚¬ã‚¤ãƒ‰
 */

import { Container, Title, Text, Stack, Group, Card, Divider, Code, Paper, SimpleGrid, Center, Badge } from '@mantine/core';
import { ActionButton, ActionIconButton } from '@/components/ActionButton';
import {
  IconPaw,
  IconCat,
  IconDog,
  IconBone,
  IconHeart,
  IconHeartFilled,
  IconBabyCarriage,
  IconUsers,
  IconCalendar,
  IconClock,
  IconPill,
  IconVaccine,
  IconStethoscope,
  IconPrescription,
  IconReportMedical,
  IconActivity,
  IconEye,
  IconEyeOff,
  IconGenderMale,
  IconGenderFemale,
  IconMoodHappy,
  IconMoodSad,
  IconStar,
  IconStarFilled,
  IconCertificate,
  IconBriefcase,
  IconHome,
  IconBuildingStore,
  IconScale,
  IconRuler,
  IconTemperature,
} from '@tabler/icons-react';
import { CatTexturedCard, CardSpreadDemo, type TextureType, type HoloPatternType, type RarityType, type DemoCat } from '@/components/cards';

// ã‚µãƒ³ãƒ—ãƒ«çŒ«ãƒ‡ãƒ¼ã‚¿ï¼ˆãƒ¬ã‚¢ãƒªãƒ†ã‚£åˆ¥ï¼‰
const SAMPLE_CATS: Record<string, DemoCat> = {
  common: { 
    id: '1', 
    name: 'ãƒŸã‚±', 
    gender: 'FEMALE', 
    breed: { id: '1', name: 'é›‘ç¨®' }, 
    coatColor: { id: '1', name: 'ä¸‰æ¯›' } 
  },
  uncommon: { 
    id: '2', 
    name: 'ã‚¿ãƒ', 
    gender: 'MALE', 
    breed: { id: '2', name: 'ã‚¢ãƒ¡ã‚·ãƒ§ãƒ¼' }, 
    coatColor: { id: '2', name: 'ã‚·ãƒ«ãƒãƒ¼ã‚¿ãƒ“ãƒ¼' } 
  },
  rare: { 
    id: '3', 
    name: 'ã‚½ãƒ©', 
    gender: 'MALE', 
    breed: { id: '3', name: 'ã‚¹ã‚³ãƒ†ã‚£ãƒƒã‚·ãƒ¥' }, 
    coatColor: { id: '3', name: 'ãƒ–ãƒ«ãƒ¼' } 
  },
  superRare: { 
    id: '4', 
    name: 'ãƒ«ãƒŠ', 
    gender: 'FEMALE', 
    breed: { id: '4', name: 'ãƒšãƒ«ã‚·ãƒ£' }, 
    coatColor: { id: '4', name: 'ãƒãƒ³ãƒãƒ©ã‚·ãƒ«ãƒãƒ¼' }, 
    registrationNumber: 'ABC-12345' 
  },
  ultraRare: { 
    id: '5', 
    name: 'ãƒ¬ã‚ª', 
    gender: 'MALE', 
    breed: { id: '5', name: 'ãƒ™ãƒ³ã‚¬ãƒ«' }, 
    coatColor: { id: '5', name: 'ãƒ–ãƒ©ã‚¦ãƒ³ã‚¹ãƒãƒ†ãƒƒãƒ‰' }, 
    registrationNumber: 'XYZ-67890' 
  },
  legendary: { 
    id: '6', 
    name: 'ã‚­ãƒ³ã‚°', 
    gender: 'MALE', 
    breed: { id: '6', name: 'ãƒ¡ã‚¤ãƒ³ã‚¯ãƒ¼ãƒ³' }, 
    coatColor: { id: '6', name: 'ãƒ–ãƒ©ã‚¦ãƒ³ã‚¿ãƒ“ãƒ¼' }, 
    registrationNumber: 'LEGEND-001'
  },
};

// è³ªæ„Ÿä¸€è¦§ï¼ˆ9ç¨®é¡ï¼‰
const TEXTURE_TYPES: TextureType[] = ['matte', 'glossy', 'embossed', 'linen', 'washi', 'metallic', 'metallicGold', 'leather', 'wood'];

// ãƒ›ãƒ­ã‚°ãƒ©ãƒ åŠ å·¥ä¸€è¦§ï¼ˆ4ç¨®é¡ï¼‰
const HOLO_PATTERNS: HoloPatternType[] = ['stripe', 'dot', 'prism', 'stardust'];

// ãƒ¬ã‚¢ãƒªãƒ†ã‚£ä¸€è¦§ï¼ˆ6æ®µéšï¼‰
const RARITY_TYPES: RarityType[] = ['common', 'uncommon', 'rare', 'superRare', 'ultraRare', 'legendary'];

export default function ActionButtonDemoPage() {
  return (
    <Container size="lg" py="xl">
      <Stack gap="xl">
        <div>
          <Title order={1} mb="md">
            çµ±ä¸€ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã‚¬ã‚¤ãƒ‰
          </Title>
          <Text c="dimmed">
            ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“ã§çµ±ä¸€ã•ã‚ŒãŸCRUDæ“ä½œãƒœã‚¿ãƒ³ã®ãƒ‡ã‚¶ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ 
          </Text>
        </div>

        <Divider />

        {/* åŸºæœ¬çš„ãªä½¿ã„æ–¹ */}
        <Card shadow="sm" padding="lg" radius="md" withBorder>
          <Title order={3} mb="md">
            åŸºæœ¬çš„ãªä½¿ã„æ–¹
          </Title>
          <Stack gap="lg">
            <div>
              <Text size="sm" fw={500} mb="xs">
                ä½œæˆãƒ»è¿½åŠ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
              </Text>
              <Group>
                <ActionButton action="create">æ–°è¦ç™»éŒ²</ActionButton>
                <ActionButton action="create" size="sm">
                  è¿½åŠ 
                </ActionButton>
                <ActionButton action="create" size="xs">
                  å°ã•ã„ãƒœã‚¿ãƒ³
                </ActionButton>
              </Group>
              <Paper bg="gray.0" p="xs" mt="xs">
                <Code block>
                  {`<ActionButton action="create">æ–°è¦ç™»éŒ²</ActionButton>`}
                </Code>
              </Paper>
            </div>

            <div>
              <Text size="sm" fw={500} mb="xs">
                ç·¨é›†ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
              </Text>
              <Group>
                <ActionButton action="edit">ç·¨é›†</ActionButton>
                <ActionButton action="edit" size="sm">
                  ç·¨é›†
                </ActionButton>
              </Group>
              <Paper bg="gray.0" p="xs" mt="xs">
                <Code block>
                  {`<ActionButton action="edit">ç·¨é›†</ActionButton>`}
                </Code>
              </Paper>
            </div>

            <div>
              <Text size="sm" fw={500} mb="xs">
                å‰Šé™¤ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
              </Text>
              <Group>
                <ActionButton action="delete">å‰Šé™¤</ActionButton>
                <ActionButton action="delete" size="sm">
                  å‰Šé™¤
                </ActionButton>
              </Group>
              <Paper bg="gray.0" p="xs" mt="xs">
                <Code block>
                  {`<ActionButton action="delete">å‰Šé™¤</ActionButton>`}
                </Code>
              </Paper>
            </div>

            <div>
              <Text size="sm" fw={500} mb="xs">
                è¡¨ç¤ºãƒ»è©³ç´°ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
              </Text>
              <Group>
                <ActionButton action="view">è©³ç´°</ActionButton>
                <ActionButton action="view" size="sm">
                  è¡¨ç¤º
                </ActionButton>
              </Group>
              <Paper bg="gray.0" p="xs" mt="xs">
                <Code block>
                  {`<ActionButton action="view">è©³ç´°</ActionButton>`}
                </Code>
              </Paper>
            </div>

            <div>
              <Text size="sm" fw={500} mb="xs">
                ä¿å­˜ãƒ»ç¢ºèªã‚¢ã‚¯ã‚·ãƒ§ãƒ³
              </Text>
              <Group>
                <ActionButton action="save">ä¿å­˜</ActionButton>
                <ActionButton action="confirm">ç¢ºèª</ActionButton>
              </Group>
              <Paper bg="gray.0" p="xs" mt="xs">
                <Code block>
                  {`<ActionButton action="save">ä¿å­˜</ActionButton>
<ActionButton action="confirm">ç¢ºèª</ActionButton>`}
                </Code>
              </Paper>
            </div>

            <div>
              <Text size="sm" fw={500} mb="xs">
                ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒ»æˆ»ã‚‹ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
              </Text>
              <Group>
                <ActionButton action="cancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</ActionButton>
                <ActionButton action="back">æˆ»ã‚‹</ActionButton>
              </Group>
              <Paper bg="gray.0" p="xs" mt="xs">
                <Code block>
                  {`<ActionButton action="cancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</ActionButton>
<ActionButton action="back">æˆ»ã‚‹</ActionButton>`}
                </Code>
              </Paper>
            </div>
          </Stack>
        </Card>

        {/* ãƒ¢ãƒ¼ãƒ€ãƒ«ã§ã®ä½¿ç”¨ä¾‹ */}
        <Card shadow="sm" padding="lg" radius="md" withBorder>
          <Title order={3} mb="md">
            ãƒ¢ãƒ¼ãƒ€ãƒ«ã§ã®ä½¿ç”¨ä¾‹
          </Title>
          <Stack gap="md">
            <div>
              <Text size="sm" fw={500} mb="xs">
                ä½œæˆãƒ¢ãƒ¼ãƒ€ãƒ«ã®ãƒ•ãƒƒã‚¿ãƒ¼
              </Text>
              <Group justify="flex-end">
                <ActionButton action="cancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</ActionButton>
                <ActionButton action="create">ç™»éŒ²</ActionButton>
              </Group>
            </div>

            <div>
              <Text size="sm" fw={500} mb="xs">
                ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ«ã®ãƒ•ãƒƒã‚¿ãƒ¼
              </Text>
              <Group justify="flex-end">
                <ActionButton action="cancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</ActionButton>
                <ActionButton action="save">ä¿å­˜</ActionButton>
              </Group>
            </div>

            <div>
              <Text size="sm" fw={500} mb="xs">
                å‰Šé™¤ç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ«ã®ãƒ•ãƒƒã‚¿ãƒ¼
              </Text>
              <Group justify="flex-end">
                <ActionButton action="cancel">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</ActionButton>
                <ActionButton action="delete">å‰Šé™¤</ActionButton>
              </Group>
            </div>
          </Stack>
        </Card>

        {/* ãƒ†ãƒ¼ãƒ–ãƒ«ã§ã®ä½¿ç”¨ä¾‹ */}
        <Card shadow="sm" padding="lg" radius="md" withBorder>
          <Title order={3} mb="md">
            ãƒ†ãƒ¼ãƒ–ãƒ«è¡Œã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã§ã®ä½¿ç”¨ä¾‹
          </Title>
          <Stack gap="md">
            <Text size="sm" c="dimmed">
              ãƒ†ãƒ¼ãƒ–ãƒ«ã®å„è¡Œã«è¡¨ç¤ºã™ã‚‹å°ã•ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³
            </Text>
            <Group>
              <ActionIconButton action="view" />
              <ActionIconButton action="edit" />
              <ActionIconButton action="delete" />
            </Group>
            <Paper bg="gray.0" p="xs">
              <Code block>
                {`<ActionIconButton action="view" />
<ActionIconButton action="edit" />
<ActionIconButton action="delete" />`}
              </Code>
            </Paper>
          </Stack>
        </Card>

        {/* ã‚µã‚¤ã‚ºãƒ—ãƒªã‚»ãƒƒãƒˆ */}
        <Card shadow="sm" padding="lg" radius="md" withBorder>
          <Title order={3} mb="md">
            ã‚µã‚¤ã‚ºãƒ—ãƒªã‚»ãƒƒãƒˆï¼ˆicon / small / medium / largeï¼‰
          </Title>
          <Text size="sm" c="dimmed" mb="lg">
            sizePreset ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§çµ±ä¸€ã•ã‚ŒãŸã‚µã‚¤ã‚ºã‚’é¸æŠã§ãã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ 'small' ã§ã™ã€‚
          </Text>
          <Stack gap="lg">
            <div>
              <Text size="sm" fw={500} mb="xs">
                ã‚¢ã‚¤ã‚³ãƒ³ãƒ—ãƒªã‚»ãƒƒãƒˆï¼ˆiconï¼‰
              </Text>
              <Text size="xs" c="dimmed" mb="xs">
                æœ€å°é™ã®ã‚µã‚¤ã‚ºã€‚ãƒ†ãƒ¼ãƒ–ãƒ«ãƒ˜ãƒƒãƒ€ãƒ¼ã‚„ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç”¨ã€‚
              </Text>
              <Group>
                <ActionButton action="create" sizePreset="icon">
                  ä½œæˆ
                </ActionButton>
                <ActionButton action="edit" sizePreset="icon">
                  ç·¨é›†
                </ActionButton>
                <ActionButton action="delete" sizePreset="icon">
                  å‰Šé™¤
                </ActionButton>
              </Group>
            </div>

            <div>
              <Text size="sm" fw={500} mb="xs">
                å°ãƒ—ãƒªã‚»ãƒƒãƒˆï¼ˆsmallï¼‰- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
              </Text>
              <Text size="xs" c="dimmed" mb="xs">
                ãƒ•ã‚©ãƒ¼ãƒ ã‚„ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã§æ¨å¥¨ã€‚ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆãªãŒã‚‰æ“ä½œã—ã‚„ã™ã„ã€‚
              </Text>
              <Group>
                <ActionButton action="create" sizePreset="small">
                  ä½œæˆ
                </ActionButton>
                <ActionButton action="edit" sizePreset="small">
                  ç·¨é›†
                </ActionButton>
                <ActionButton action="delete" sizePreset="small">
                  å‰Šé™¤
                </ActionButton>
              </Group>
            </div>

            <div>
              <Text size="sm" fw={500} mb="xs">
                ä¸­ãƒ—ãƒªã‚»ãƒƒãƒˆï¼ˆmediumï¼‰
              </Text>
              <Text size="xs" c="dimmed" mb="xs">
                ã‚»ã‚¯ã‚·ãƒ§ãƒ³å†…ã®ä¸»è¦ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç”¨ã€‚ã‚ˆã‚Šè¦–èªæ€§ãŒé«˜ã„ã€‚
              </Text>
              <Group>
                <ActionButton action="create" sizePreset="medium">
                  ä½œæˆ
                </ActionButton>
                <ActionButton action="edit" sizePreset="medium">
                  ç·¨é›†
                </ActionButton>
                <ActionButton action="delete" sizePreset="medium">
                  å‰Šé™¤
                </ActionButton>
              </Group>
            </div>

            <div>
              <Text size="sm" fw={500} mb="xs">
                å¤§ãƒ—ãƒªã‚»ãƒƒãƒˆï¼ˆlargeï¼‰
              </Text>
              <Text size="xs" c="dimmed" mb="xs">
                ä¸»è¦ãª CTAï¼ˆCall To Actionï¼‰ç”¨ã€‚æœ€å¤§é™ã®è¦–èªæ€§ã€‚
              </Text>
              <Group>
                <ActionButton action="create" sizePreset="large">
                  ä½œæˆ
                </ActionButton>
                <ActionButton action="edit" sizePreset="large">
                  ç·¨é›†
                </ActionButton>
                <ActionButton action="delete" sizePreset="large">
                  å‰Šé™¤
                </ActionButton>
              </Group>
            </div>

            <Paper bg="gray.0" p="xs">
              <Code block>
                {`<ActionButton action="create" sizePreset="icon">ä½œæˆ</ActionButton>
<ActionButton action="create" sizePreset="small">ä½œæˆ</ActionButton>
<ActionButton action="create" sizePreset="medium">ä½œæˆ</ActionButton>
<ActionButton action="create" sizePreset="large">ä½œæˆ</ActionButton>`}
              </Code>
            </Paper>
          </Stack>
        </Card>

        {/* ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºä¾‹ */}
        <Card shadow="sm" padding="lg" radius="md" withBorder>
          <Title order={3} mb="md">
            ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºä¾‹
          </Title>
          <Stack gap="lg">
            <div>
              <Text size="sm" fw={500} mb="xs">
                ã‚¢ã‚¤ã‚³ãƒ³ã‚’éè¡¨ç¤º
              </Text>
              <Group>
                <ActionButton action="create" hideIcon>
                  æ–°è¦ç™»éŒ²
                </ActionButton>
                <ActionButton action="edit" hideIcon>
                  ç·¨é›†
                </ActionButton>
              </Group>
              <Paper bg="gray.0" p="xs" mt="xs">
                <Code block>
                  {`<ActionButton action="create" hideIcon>æ–°è¦ç™»éŒ²</ActionButton>`}
                </Code>
              </Paper>
            </div>

            <div>
              <Text size="sm" fw={500} mb="xs">
                ãƒ•ãƒ«ãƒ¯ã‚¤ãƒ‰ãƒœã‚¿ãƒ³
              </Text>
              <ActionButton action="create" fullWidth>
                ãƒ•ãƒ«ãƒ¯ã‚¤ãƒ‰ãƒœã‚¿ãƒ³
              </ActionButton>
              <Paper bg="gray.0" p="xs" mt="xs">
                <Code block>
                  {`<ActionButton action="create" fullWidth>ãƒ•ãƒ«ãƒ¯ã‚¤ãƒ‰ãƒœã‚¿ãƒ³</ActionButton>`}
                </Code>
              </Paper>
            </div>

            <div>
              <Text size="sm" fw={500} mb="xs">
                ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹
              </Text>
              <Group>
                <ActionButton action="save" loading>
                  ä¿å­˜ä¸­...
                </ActionButton>
                <ActionButton action="delete" loading>
                  å‰Šé™¤ä¸­...
                </ActionButton>
              </Group>
              <Paper bg="gray.0" p="xs" mt="xs">
                <Code block>
                  {`<ActionButton action="save" loading>ä¿å­˜ä¸­...</ActionButton>`}
                </Code>
              </Paper>
            </div>

            <div>
              <Text size="sm" fw={500} mb="xs">
                ç„¡åŠ¹åŒ–çŠ¶æ…‹
              </Text>
              <Group>
                <ActionButton action="create" disabled>
                  æ–°è¦ç™»éŒ²
                </ActionButton>
                <ActionButton action="edit" disabled>
                  ç·¨é›†
                </ActionButton>
              </Group>
              <Paper bg="gray.0" p="xs" mt="xs">
                <Code block>
                  {`<ActionButton action="create" disabled>æ–°è¦ç™»éŒ²</ActionButton>`}
                </Code>
              </Paper>
            </div>
          </Stack>
        </Card>

        {/* ãƒ‡ã‚¶ã‚¤ãƒ³ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ */}
        <Card shadow="sm" padding="lg" radius="md" withBorder>
          <Title order={3} mb="md">
            ãƒ‡ã‚¶ã‚¤ãƒ³ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³
          </Title>
          <Stack gap="md">
            <div>
              <Text fw={500} mb="xs">
                ğŸ“˜ ä½œæˆãƒ»è¿½åŠ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆé’ãƒ»outlineï¼‰
              </Text>
              <Text size="sm" c="dimmed">
                æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆã™ã‚‹éš›ã«ä½¿ç”¨ã€‚è¦–èªæ€§ãŒé«˜ãã€ä¸»è¦ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¨ã—ã¦ç›®ç«‹ã¤ã€‚
              </Text>
            </div>

            <div>
              <Text fw={500} mb="xs">
                âœï¸ ç·¨é›†ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆé»„ãƒ»outlineï¼‰
              </Text>
              <Text size="sm" c="dimmed">
                æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’ç·¨é›†ã™ã‚‹éš›ã«ä½¿ç”¨ã€‚è­¦å‘Šè‰²ã§ã¯ãªã„ãŒæ³¨ç›®ã‚’é›†ã‚ã‚‹é»„è‰²ã€‚
              </Text>
            </div>

            <div>
              <Text fw={500} mb="xs">
                ğŸ—‘ï¸ å‰Šé™¤ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆèµ¤ãƒ»outlineï¼‰
              </Text>
              <Text size="sm" c="dimmed">
                ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã™ã‚‹éš›ã«ä½¿ç”¨ã€‚å±é™ºãªæ“ä½œã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã™èµ¤è‰²ã€‚
              </Text>
            </div>

            <div>
              <Text fw={500} mb="xs">
                ğŸ‘ï¸ è¡¨ç¤ºãƒ»è©³ç´°ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆã‚°ãƒ¬ãƒ¼ãƒ»outlineï¼‰
              </Text>
              <Text size="sm" c="dimmed">
                ãƒ‡ãƒ¼ã‚¿ã‚’é–²è¦§ã™ã‚‹ã ã‘ã®å®‰å…¨ãªæ“ä½œã€‚æ§ãˆã‚ãªã‚°ãƒ¬ãƒ¼ã€‚
              </Text>
            </div>

            <div>
              <Text fw={500} mb="xs">
                ğŸ’¾ ä¿å­˜ãƒ»ç¢ºèªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆé’ãƒ»outlineï¼‰
              </Text>
              <Text size="sm" c="dimmed">
                ãƒ•ã‚©ãƒ¼ãƒ é€ä¿¡ãªã©ã®æœ€çµ‚ç¢ºèªã€‚ä½œæˆã‚¢ã‚¯ã‚·ãƒ§ãƒ³åŒæ§˜ã«é’ã‚’åŸºèª¿ã¨ã—ã¦çµ±ä¸€ã€‚
              </Text>
            </div>

            <div>
              <Text fw={500} mb="xs">
                âŒ ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒ»æˆ»ã‚‹ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆã‚°ãƒ¬ãƒ¼ãƒ»subtleï¼‰
              </Text>
              <Text size="sm" c="dimmed">
                æ“ä½œã‚’ä¸­æ­¢ã™ã‚‹å ´åˆã«ä½¿ç”¨ã€‚æœ€ã‚‚æ§ãˆã‚ãªãƒ‡ã‚¶ã‚¤ãƒ³ã€‚
              </Text>
            </div>
          </Stack>
        </Card>

        {/* çŒ«é–¢é€£ã‚¢ã‚¤ã‚³ãƒ³ä¸€è¦§ */}
        <Card shadow="sm" padding="lg" radius="md" withBorder>
          <Title order={3} mb="md">
            ğŸ± çŒ«ãƒ»å‹•ç‰©é–¢é€£ã‚¢ã‚¤ã‚³ãƒ³ä¸€è¦§
          </Title>
          <Text size="sm" c="dimmed" mb="md">
            ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ä½¿ç”¨å¯èƒ½ãªçŒ«ã‚„å‹•ç‰©ã«é–¢é€£ã™ã‚‹ã‚¢ã‚¤ã‚³ãƒ³ã§ã™ã€‚Tabler Iconsã¨çµµæ–‡å­—ã®2ç¨®é¡ãŒã‚ã‚Šã¾ã™ã€‚
          </Text>

          {/* çµµæ–‡å­—ã‚»ã‚¯ã‚·ãƒ§ãƒ³ */}
          <Card withBorder padding="md" mb="lg" style={{ backgroundColor: 'var(--mantine-color-blue-0)' }}>
            <Stack gap="md">
              <div>
                <Group gap="xs" mb="xs">
                  <Title order={4}>ğŸ¨ çµµæ–‡å­—ã‚¢ã‚¤ã‚³ãƒ³</Title>
                  <Badge color="blue" variant="light">æ¨å¥¨</Badge>
                </Group>
                <Text size="sm" c="dimmed">
                  iPhone/Androidã§è¡¨ç¤ºã•ã‚Œã‚‹çµµæ–‡å­—ã§ã™ã€‚ã‚³ãƒ¼ãƒ‰ã¯ä¸è¦ã§ã€ãã®ã¾ã¾è²¼ã‚Šä»˜ã‘ã‚‹ã ã‘ã§ä½¿ãˆã¾ã™ã€‚
                </Text>
              </div>

              <div>
                <Text fw={500} mb="sm" size="sm">çŒ«ã®çµµæ–‡å­—</Text>
                <SimpleGrid cols={{ base: 4, sm: 6, md: 8 }} spacing="md">
                  {[
                    { emoji: 'ğŸ±', name: 'çŒ«ã®é¡”' },
                    { emoji: 'ğŸˆ', name: 'çŒ«' },
                    { emoji: 'ğŸˆâ€â¬›', name: 'é»’çŒ«' },
                    { emoji: 'ğŸ˜º', name: 'ç¬‘é¡”ã®çŒ«' },
                    { emoji: 'ğŸ˜¸', name: 'ã«ã‚„ã‘ã‚‹çŒ«' },
                    { emoji: 'ğŸ˜¹', name: 'ç¬‘ã†çŒ«' },
                    { emoji: 'ğŸ˜»', name: 'ãƒãƒ¼ãƒˆã®ç›®ã®çŒ«' },
                    { emoji: 'ğŸ˜¼', name: 'ã«ã‚„ã‚Šã¨ã™ã‚‹çŒ«' },
                    { emoji: 'ğŸ˜½', name: 'ã‚­ã‚¹ã™ã‚‹çŒ«' },
                    { emoji: 'ğŸ™€', name: 'ã³ã£ãã‚Šã—ãŸçŒ«' },
                    { emoji: 'ğŸ˜¿', name: 'æ³£ãçŒ«' },
                    { emoji: 'ğŸ˜¾', name: 'æ€’ã£ãŸçŒ«' },
                    { emoji: 'ğŸ¾', name: 'è‚‰çƒ' },
                  ].map(({ emoji, name }) => (
                    <Card key={name} withBorder padding="xs" style={{ cursor: 'pointer' }} onClick={() => navigator.clipboard.writeText(emoji)}>
                      <Center>
                        <Text size="2rem" style={{ lineHeight: 1 }}>{emoji}</Text>
                      </Center>
                      <Text size="9px" ta="center" c="dimmed" mt={4} style={{ lineHeight: 1.2 }}>
                        {name}
                      </Text>
                    </Card>
                  ))}
                </SimpleGrid>
                <Text size="xs" c="dimmed" mt="xs">ğŸ’¡ ã‚¯ãƒªãƒƒã‚¯ã§ã‚³ãƒ”ãƒ¼ã§ãã¾ã™</Text>
              </div>

              <div>
                <Text fw={500} mb="sm" size="sm">ãã®ä»–ã®å‹•ç‰©çµµæ–‡å­—</Text>
                <SimpleGrid cols={{ base: 4, sm: 6, md: 8 }} spacing="md">
                  {[
                    { emoji: 'ğŸ•', name: 'çŠ¬' },
                    { emoji: 'ğŸ¶', name: 'çŠ¬ã®é¡”' },
                    { emoji: 'ğŸ©', name: 'ãƒ—ãƒ¼ãƒ‰ãƒ«' },
                    { emoji: 'ğŸ¦®', name: 'ç›²å°çŠ¬' },
                    { emoji: 'ğŸ•â€ğŸ¦º', name: 'ä»‹åŠ©çŠ¬' },
                    { emoji: 'ğŸ°', name: 'ã†ã•ã' },
                    { emoji: 'ğŸ¹', name: 'ãƒãƒ ã‚¹ã‚¿ãƒ¼' },
                    { emoji: 'ğŸ­', name: 'ãƒã‚ºãƒŸ' },
                    { emoji: 'ğŸ¦Š', name: 'ã‚­ãƒ„ãƒ' },
                    { emoji: 'ğŸ»', name: 'ã‚¯ãƒ' },
                    { emoji: 'ğŸ¼', name: 'ãƒ‘ãƒ³ãƒ€' },
                    { emoji: 'ğŸ¦', name: 'ãƒ©ã‚¤ã‚ªãƒ³' },
                    { emoji: 'ğŸ¯', name: 'ãƒˆãƒ©' },
                  ].map(({ emoji, name }) => (
                    <Card key={name} withBorder padding="xs" style={{ cursor: 'pointer' }} onClick={() => navigator.clipboard.writeText(emoji)}>
                      <Center>
                        <Text size="2rem" style={{ lineHeight: 1 }}>{emoji}</Text>
                      </Center>
                      <Text size="9px" ta="center" c="dimmed" mt={4} style={{ lineHeight: 1.2 }}>
                        {name}
                      </Text>
                    </Card>
                  ))}
                </SimpleGrid>
              </div>

              <div>
                <Text fw={500} mb="sm" size="sm">é–¢é€£çµµæ–‡å­—</Text>
                <SimpleGrid cols={{ base: 4, sm: 6, md: 8 }} spacing="md">
                  {[
                    { emoji: 'â¤ï¸', name: 'ãƒãƒ¼ãƒˆ' },
                    { emoji: 'ğŸ’™', name: 'é’ãƒãƒ¼ãƒˆ' },
                    { emoji: 'ğŸ’š', name: 'ç·‘ãƒãƒ¼ãƒˆ' },
                    { emoji: 'ğŸ©·', name: 'ãƒ”ãƒ³ã‚¯ãƒãƒ¼ãƒˆ' },
                    { emoji: 'ğŸ¼', name: 'å“ºä¹³ç“¶' },
                    { emoji: 'ğŸ‘¶', name: 'èµ¤ã¡ã‚ƒã‚“' },
                    { emoji: 'ğŸ ', name: 'å®¶' },
                    { emoji: 'ğŸ¥', name: 'ç—…é™¢' },
                    { emoji: 'ğŸ’Š', name: 'è–¬' },
                    { emoji: 'ğŸ’‰', name: 'æ³¨å°„' },
                    { emoji: 'ğŸ“…', name: 'ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼' },
                    { emoji: 'â°', name: 'æ™‚è¨ˆ' },
                    { emoji: 'ğŸ“', name: 'ãƒ¡ãƒ¢' },
                    { emoji: 'â­', name: 'æ˜Ÿ' },
                    { emoji: 'âœ¨', name: 'ãã‚‰ãã‚‰' },
                  ].map(({ emoji, name }) => (
                    <Card key={name} withBorder padding="xs" style={{ cursor: 'pointer' }} onClick={() => navigator.clipboard.writeText(emoji)}>
                      <Center>
                        <Text size="2rem" style={{ lineHeight: 1 }}>{emoji}</Text>
                      </Center>
                      <Text size="9px" ta="center" c="dimmed" mt={4} style={{ lineHeight: 1.2 }}>
                        {name}
                      </Text>
                    </Card>
                  ))}
                </SimpleGrid>
              </div>

              <Paper bg="white" p="sm" withBorder>
                <Text fw={500} size="sm" mb="xs">ä½¿ç”¨æ–¹æ³•</Text>
                <Code block>
{`// ãã®ã¾ã¾æ–‡å­—åˆ—ã¨ã—ã¦ä½¿ç”¨
<Text>ğŸ± çŒ«ã®æƒ…å ±</Text>
<Button>ğŸ¾ è‚‰çƒã‚’æŠ¼ã™</Button>

// ã‚¢ãƒ—ãƒªã‚¿ã‚¤ãƒˆãƒ«ã®ã‚ˆã†ã«
<Text fw={700}>
  <span style={{ fontSize: '1.4rem' }}>ğŸˆ</span> MyCats
</Text>

// ãƒãƒƒã‚¸ã‚„ã‚¢ã‚¤ã‚³ãƒ³ã¨ã—ã¦
<Badge leftSection="ğŸ±">çŒ«</Badge>
<Avatar>ğŸˆ</Avatar>`}
                </Code>
              </Paper>
            </Stack>
          </Card>

          {/* Tabler Iconsã‚»ã‚¯ã‚·ãƒ§ãƒ³ */}
          <div>
            <Group gap="xs" mb="sm">
              <Title order={4}>ğŸ¨ Tabler Icons</Title>
              <Badge color="gray" variant="light">SVGã‚¢ã‚¤ã‚³ãƒ³</Badge>
            </Group>
            <Text size="sm" c="dimmed" mb="md">
              ãƒ—ãƒ­ã‚°ãƒ©ãƒãƒ–ãƒ«ãªSVGã‚¢ã‚¤ã‚³ãƒ³ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã™ã€‚ã‚µã‚¤ã‚ºã‚„è‰²ã‚’è‡ªç”±ã«èª¿æ•´ã§ãã¾ã™ã€‚
            </Text>
          </div>
          
          <Stack gap="lg">
            <div>
              <Text fw={500} mb="sm">åŸºæœ¬çš„ãªçŒ«ãƒ»å‹•ç‰©ã‚¢ã‚¤ã‚³ãƒ³</Text>
              <SimpleGrid cols={{ base: 2, sm: 3, md: 4 }} spacing="md">
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconPaw size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconPaw</Text>
                  <Text size="xs" ta="center" c="dimmed">è‚‰çƒ</Text>
                </Card>
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconCat size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconCat</Text>
                  <Text size="xs" ta="center" c="dimmed">çŒ«</Text>
                </Card>
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconDog size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconDog</Text>
                  <Text size="xs" ta="center" c="dimmed">çŠ¬</Text>
                </Card>
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconBone size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconBone</Text>
                  <Text size="xs" ta="center" c="dimmed">éª¨</Text>
                </Card>
              </SimpleGrid>
            </div>

            <div>
              <Text fw={500} mb="sm">ç¹æ®–ãƒ»å®¶æ—é–¢é€£</Text>
              <SimpleGrid cols={{ base: 2, sm: 3, md: 4 }} spacing="md">
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconHeart size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconHeart</Text>
                  <Text size="xs" ta="center" c="dimmed">ãƒãƒ¼ãƒˆï¼ˆç·šï¼‰</Text>
                </Card>
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconHeartFilled size={32} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconHeartFilled</Text>
                  <Text size="xs" ta="center" c="dimmed">ãƒãƒ¼ãƒˆï¼ˆå¡—ï¼‰</Text>
                </Card>
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconBabyCarriage size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconBabyCarriage</Text>
                  <Text size="xs" ta="center" c="dimmed">ãƒ™ãƒ“ãƒ¼ã‚«ãƒ¼</Text>
                </Card>
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconUsers size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconUsers</Text>
                  <Text size="xs" ta="center" c="dimmed">è¤‡æ•°ãƒ¦ãƒ¼ã‚¶ãƒ¼</Text>
                </Card>
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconGenderMale size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconGenderMale</Text>
                  <Text size="xs" ta="center" c="dimmed">ã‚ªã‚¹</Text>
                </Card>
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconGenderFemale size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconGenderFemale</Text>
                  <Text size="xs" ta="center" c="dimmed">ãƒ¡ã‚¹</Text>
                </Card>
              </SimpleGrid>
            </div>

            <div>
              <Text fw={500} mb="sm">å¥åº·ãƒ»åŒ»ç™‚é–¢é€£</Text>
              <SimpleGrid cols={{ base: 2, sm: 3, md: 4 }} spacing="md">
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconPill size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconPill</Text>
                  <Text size="xs" ta="center" c="dimmed">è–¬</Text>
                </Card>
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconVaccine size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconVaccine</Text>
                  <Text size="xs" ta="center" c="dimmed">ãƒ¯ã‚¯ãƒãƒ³</Text>
                </Card>
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconStethoscope size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconStethoscope</Text>
                  <Text size="xs" ta="center" c="dimmed">è´è¨ºå™¨</Text>
                </Card>
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconPrescription size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconPrescription</Text>
                  <Text size="xs" ta="center" c="dimmed">å‡¦æ–¹ç®‹</Text>
                </Card>
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconReportMedical size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconReportMedical</Text>
                  <Text size="xs" ta="center" c="dimmed">åŒ»ç™‚è¨˜éŒ²</Text>
                </Card>
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconActivity size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconActivity</Text>
                  <Text size="xs" ta="center" c="dimmed">æ´»å‹•é‡</Text>
                </Card>
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconTemperature size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconTemperature</Text>
                  <Text size="xs" ta="center" c="dimmed">ä½“æ¸©</Text>
                </Card>
              </SimpleGrid>
            </div>

            <div>
              <Text fw={500} mb="sm">ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ»è¨˜éŒ²é–¢é€£</Text>
              <SimpleGrid cols={{ base: 2, sm: 3, md: 4 }} spacing="md">
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconCalendar size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconCalendar</Text>
                  <Text size="xs" ta="center" c="dimmed">ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼</Text>
                </Card>
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconClock size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconClock</Text>
                  <Text size="xs" ta="center" c="dimmed">æ™‚è¨ˆ</Text>
                </Card>
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconCertificate size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconCertificate</Text>
                  <Text size="xs" ta="center" c="dimmed">è¨¼æ˜æ›¸</Text>
                </Card>
              </SimpleGrid>
            </div>

            <div>
              <Text fw={500} mb="sm">çŠ¶æ…‹ãƒ»è©•ä¾¡é–¢é€£</Text>
              <SimpleGrid cols={{ base: 2, sm: 3, md: 4 }} spacing="md">
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconEye size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconEye</Text>
                  <Text size="xs" ta="center" c="dimmed">è¡¨ç¤º</Text>
                </Card>
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconEyeOff size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconEyeOff</Text>
                  <Text size="xs" ta="center" c="dimmed">éè¡¨ç¤º</Text>
                </Card>
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconMoodHappy size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconMoodHappy</Text>
                  <Text size="xs" ta="center" c="dimmed">è‰¯å¥½</Text>
                </Card>
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconMoodSad size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconMoodSad</Text>
                  <Text size="xs" ta="center" c="dimmed">ä¸èª¿</Text>
                </Card>
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconStar size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconStar</Text>
                  <Text size="xs" ta="center" c="dimmed">æ˜Ÿï¼ˆç·šï¼‰</Text>
                </Card>
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconStarFilled size={32} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconStarFilled</Text>
                  <Text size="xs" ta="center" c="dimmed">æ˜Ÿï¼ˆå¡—ï¼‰</Text>
                </Card>
              </SimpleGrid>
            </div>

            <div>
              <Text fw={500} mb="sm">å ´æ‰€ãƒ»æ–½è¨­é–¢é€£</Text>
              <SimpleGrid cols={{ base: 2, sm: 3, md: 4 }} spacing="md">
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconHome size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconHome</Text>
                  <Text size="xs" ta="center" c="dimmed">å®¶</Text>
                </Card>
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconBuildingStore size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconBuildingStore</Text>
                  <Text size="xs" ta="center" c="dimmed">åº—èˆ—</Text>
                </Card>
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconBriefcase size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconBriefcase</Text>
                  <Text size="xs" ta="center" c="dimmed">ã‚±ãƒ¼ã‚¹</Text>
                </Card>
              </SimpleGrid>
            </div>

            <div>
              <Text fw={500} mb="sm">æ¸¬å®šãƒ»è¨ˆæ¸¬é–¢é€£</Text>
              <SimpleGrid cols={{ base: 2, sm: 3, md: 4 }} spacing="md">
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconScale size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconScale</Text>
                  <Text size="xs" ta="center" c="dimmed">ä½“é‡è¨ˆ</Text>
                </Card>
                <Card withBorder padding="sm">
                  <Center mb="xs">
                    <IconRuler size={32} stroke={1.5} />
                  </Center>
                  <Text size="xs" ta="center" fw={500}>IconRuler</Text>
                  <Text size="xs" ta="center" c="dimmed">å®šè¦</Text>
                </Card>
              </SimpleGrid>
            </div>
          </Stack>

          <Divider my="lg" />

          <Stack gap="sm">
            <Text fw={500}>ä½¿ç”¨æ–¹æ³•</Text>
            <Paper bg="gray.0" p="sm">
              <Code block>
{`import { IconPaw, IconCat } from '@tabler/icons-react';

// ãƒœã‚¿ãƒ³ã«ä½¿ç”¨
<Button leftSection={<IconPaw size={16} />}>
  çŒ«ä¸€è¦§
</Button>

// å˜ç‹¬ã§ä½¿ç”¨
<IconCat size={32} stroke={1.5} color="blue" />

// ã‚µã‚¤ã‚ºèª¿æ•´
size: æ•°å€¤ï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰
stroke: ç·šã®å¤ªã•ï¼ˆ1.5ãŒæ¨™æº–ï¼‰
color: è‰²æŒ‡å®š`}
              </Code>
            </Paper>
            <Text size="sm" c="dimmed">
              ãã®ä»–ã®ã‚¢ã‚¤ã‚³ãƒ³ã¯ <a href="https://tabler.io/icons" target="_blank" rel="noopener noreferrer" style={{ color: 'var(--mantine-color-blue-6)' }}>Tabler Iconså…¬å¼ã‚µã‚¤ãƒˆ</a> ã§æ¤œç´¢ã§ãã¾ã™ã€‚
            </Text>
          </Stack>
        </Card>

        {/* ã‚«ãƒ¼ãƒ‰UIãƒ‡ã‚¶ã‚¤ãƒ³ã‚»ã‚¯ã‚·ãƒ§ãƒ³ */}
        <Card shadow="sm" padding="lg" radius="md" withBorder>
          <Title order={3} mb="md">
            ğŸ´ ã‚«ãƒ¼ãƒ‰UI ãƒ‡ã‚¶ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ 
          </Title>
          <Text size="sm" c="dimmed" mb="lg">
            ãƒ™ãƒ¼ã‚¹è³ªæ„Ÿ + ãƒ›ãƒ­ã‚°ãƒ©ãƒ åŠ å·¥ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼æ§‹é€ ã‚«ãƒ¼ãƒ‰ã€‚ãƒ›ãƒãƒ¼ã§æ¼”å‡ºãŒç¢ºèªã§ãã¾ã™ã€‚
          </Text>
          
          <Stack gap="xl">
            {/* ãƒ™ãƒ¼ã‚¹è³ªæ„Ÿä¸€è¦§ */}
            <div>
              <Title order={4} mb="md">ãƒ™ãƒ¼ã‚¹è³ªæ„Ÿï¼ˆ9ç¨®é¡ï¼‰</Title>
              <Text size="sm" c="dimmed" mb="md">
                ã‚«ãƒ¼ãƒ‰ã®åŸºæœ¬ã¨ãªã‚‹è³ªæ„Ÿã‚¹ã‚¿ã‚¤ãƒ«ã€‚ãƒ›ãƒãƒ¼ã™ã‚‹ã¨è»½ã„ã‚·ãƒãƒ¼æ¼”å‡ºãŒç¢ºèªã§ãã¾ã™ã€‚
              </Text>
              <SimpleGrid cols={{ base: 2, sm: 3, md: 4 }} spacing="md">
                {TEXTURE_TYPES.map((texture, index) => (
                  <CatTexturedCard
                    key={texture}
                    cat={Object.values(SAMPLE_CATS)[index % Object.values(SAMPLE_CATS).length]}
                    texture={texture}
                    holoPattern="none"
                  />
                ))}
              </SimpleGrid>
            </div>
            
            <Divider />
            
            {/* ãƒ›ãƒ­ã‚°ãƒ©ãƒ åŠ å·¥ä¸€è¦§ */}
            <div>
              <Title order={4} mb="md">ãƒ›ãƒ­ã‚°ãƒ©ãƒ åŠ å·¥ï¼ˆãƒ¡ã‚¿ãƒªãƒƒã‚¯ãƒ™ãƒ¼ã‚¹ï¼‰</Title>
              <Text size="sm" c="dimmed" mb="md">
                4ç¨®é¡ã®ãƒ›ãƒ­ã‚°ãƒ©ãƒ åŠ å·¥ãƒ‘ã‚¿ãƒ¼ãƒ³ã€‚ãƒ™ãƒ¼ã‚¹è³ªæ„Ÿã®ä¸Šã«ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã¨ã—ã¦é‡ãªã‚Šã¾ã™ã€‚
              </Text>
              <SimpleGrid cols={{ base: 2, sm: 4 }} spacing="md">
                {HOLO_PATTERNS.map((holo) => (
                  <CatTexturedCard
                    key={holo}
                    cat={SAMPLE_CATS.superRare}
                    texture="metallic"
                    holoPattern={holo}
                  />
                ))}
              </SimpleGrid>
            </div>
            
            <Divider />
            
            {/* ãƒ¬ã‚¢ãƒªãƒ†ã‚£åˆ¥ã‚«ãƒ¼ãƒ‰ */}
            <div>
              <Title order={4} mb="md">ãƒ¬ã‚¢ãƒªãƒ†ã‚£åˆ¥ã‚«ãƒ¼ãƒ‰ï¼ˆ6æ®µéšï¼‰</Title>
              <Text size="sm" c="dimmed" mb="md">
                ãƒ¬ã‚¢ãƒªãƒ†ã‚£ã«å¿œã˜ã¦è³ªæ„Ÿãƒ»ãƒ›ãƒ­ã‚°ãƒ©ãƒ åŠ å·¥ãƒ»ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ãƒœãƒ¼ãƒ€ãƒ¼ãŒè‡ªå‹•æ±ºå®šã•ã‚Œã¾ã™ã€‚
              </Text>
              <SimpleGrid cols={{ base: 2, sm: 3, md: 6 }} spacing="md">
                {RARITY_TYPES.map((rarity) => (
                  <Stack key={rarity} gap="xs" align="center">
                    <CatTexturedCard
                      cat={SAMPLE_CATS[rarity]}
                      rarity={rarity}
                    />
                  </Stack>
                ))}
              </SimpleGrid>
            </div>
            
            <Divider />

            {/* ã‚«ã‚¹ã‚¿ãƒ çµ„ã¿åˆã‚ã›ä¾‹ */}
            <div>
              <Title order={4} mb="md">ã‚«ã‚¹ã‚¿ãƒ çµ„ã¿åˆã‚ã›ä¾‹</Title>
              <Text size="sm" c="dimmed" mb="md">
                ãƒ™ãƒ¼ã‚¹è³ªæ„Ÿã¨ãƒ›ãƒ­ã‚°ãƒ©ãƒ åŠ å·¥ã‚’è‡ªç”±ã«çµ„ã¿åˆã‚ã›ã¦ç‹¬è‡ªã®ã‚«ãƒ¼ãƒ‰ã‚’ä½œæˆã§ãã¾ã™ã€‚
              </Text>
              <SimpleGrid cols={{ base: 1, sm: 2, md: 3 }} spacing="md">
                <Stack gap="xs" align="center">
                  <CatTexturedCard 
                    cat={SAMPLE_CATS.legendary} 
                    texture="metallicGold" 
                    holoPattern="stardust" 
                    rainbowBorder 
                  />
                  <Text size="xs" c="dimmed">ã‚´ãƒ¼ãƒ«ãƒ‰ + ã‚¹ã‚¿ãƒ¼ãƒ€ã‚¹ãƒˆ + ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼æ </Text>
                </Stack>
                <Stack gap="xs" align="center">
                  <CatTexturedCard 
                    cat={SAMPLE_CATS.rare} 
                    texture="glossy" 
                    holoPattern="dot" 
                  />
                  <Text size="xs" c="dimmed">ã‚°ãƒ­ãƒƒã‚·ãƒ¼ + ãƒ‰ãƒƒãƒˆãƒ›ãƒ­</Text>
                </Stack>
                <Stack gap="xs" align="center">
                  <CatTexturedCard 
                    cat={SAMPLE_CATS.ultraRare} 
                    texture="leather" 
                    holoPattern="prism" 
                  />
                  <Text size="xs" c="dimmed">ãƒ¬ã‚¶ãƒ¼ + ãƒ—ãƒªã‚ºãƒ ãƒ›ãƒ­</Text>
                </Stack>
              </SimpleGrid>
            </div>
            
            <Divider />
            
            {/* ä½¿ç”¨æ–¹æ³• */}
            <div>
              <Title order={4} mb="md">ä½¿ç”¨æ–¹æ³•</Title>
              <Paper bg="gray.0" p="sm">
                <Code block>
{`import { CatTexturedCard } from '@/components/cards';

// ãƒ™ãƒ¼ã‚¹è³ªæ„Ÿã®ã¿
<CatTexturedCard cat={cat} texture="metallic" />

// ãƒ™ãƒ¼ã‚¹è³ªæ„Ÿ + ãƒ›ãƒ­ã‚°ãƒ©ãƒ åŠ å·¥
<CatTexturedCard cat={cat} texture="metallicGold" holoPattern="prism" />

// ãƒ¬ã‚¢ãƒªãƒ†ã‚£ã§è‡ªå‹•æ±ºå®š
<CatTexturedCard cat={cat} rarity="legendary" />

// ãƒ•ãƒ«ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º
<CatTexturedCard 
  cat={cat} 
  texture="metallic" 
  holoPattern="stardust" 
  rainbowBorder 
  enableHoverEffect={false}  // ã‚®ãƒ£ãƒ©ãƒªãƒ¼ç­‰ã§å¤§é‡è¡¨ç¤ºæ™‚
/>`}
                </Code>
              </Paper>
            </div>

            {/* ãƒ¬ã‚¢ãƒªãƒ†ã‚£ãƒ—ãƒªã‚»ãƒƒãƒˆè¨­å®šè¡¨ */}
            <div>
              <Title order={4} mb="md">ãƒ¬ã‚¢ãƒªãƒ†ã‚£ãƒ—ãƒªã‚»ãƒƒãƒˆè¨­å®š</Title>
              <Paper bg="gray.0" p="sm">
                <Code block>
{`const RARITY_PRESETS = {
  common:    { texture: 'matte',       holoPattern: 'none',     rainbowBorder: false },
  uncommon:  { texture: 'linen',       holoPattern: 'none',     rainbowBorder: false },
  rare:      { texture: 'glossy',      holoPattern: 'none',     rainbowBorder: false },
  superRare: { texture: 'metallic',    holoPattern: 'stripe',   rainbowBorder: false },
  ultraRare: { texture: 'metallicGold',holoPattern: 'prism',    rainbowBorder: false },
  legendary: { texture: 'embossed',    holoPattern: 'stardust', rainbowBorder: true  },
};`}
                </Code>
              </Paper>
            </div>
          </Stack>
        </Card>

        {/* ã‚«ãƒ¼ãƒ‰å±•é–‹ãƒ‡ãƒ¢ */}
        <Card shadow="sm" padding="lg" radius="md" withBorder>
          <Title order={3} mb="md">
            ğŸƒ ã‚«ãƒ¼ãƒ‰å±•é–‹ãƒ‡ãƒ¢
          </Title>
          <Text size="sm" c="dimmed" mb="lg">
            ã‚«ã‚¸ãƒãƒ‡ã‚£ãƒ¼ãƒ©ãƒ¼é¢¨ã®ã‚«ãƒ¼ãƒ‰å±•é–‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã€‚ãƒ•ã‚¡ãƒ³ãƒ»ãƒªãƒœãƒ³ãƒ»ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰ã®3ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç¢ºèªã§ãã¾ã™ã€‚
          </Text>
          
          <CardSpreadDemo />
          
          <Divider my="lg" />
          
          <div>
            <Title order={4} mb="md">ä½¿ç”¨æ–¹æ³•</Title>
            <Paper bg="gray.0" p="sm">
              <Code block>
{`import { CardSpreadDemo } from '@/components/cards';

// ãƒ‡ãƒ¢ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’ãã®ã¾ã¾é…ç½®
<CardSpreadDemo />

// ã‚«ã‚¹ã‚¿ãƒ ã®çŒ«ãƒ‡ãƒ¼ã‚¿ã‚’æ¸¡ã™å ´åˆï¼ˆå°†æ¥æ‹¡å¼µç”¨ï¼‰
<CardSpreadDemo cats={myCats} />`}
              </Code>
            </Paper>
          </div>
          
          <Stack gap="xs" mt="md">
            <Text size="sm" fw={500}>å±•é–‹ãƒ‘ã‚¿ãƒ¼ãƒ³</Text>
            <SimpleGrid cols={{ base: 1, sm: 3 }} spacing="md">
              <Paper p="sm" withBorder>
                <Group gap="xs" mb="xs">
                  <Text size="lg">ğŸŒ€</Text>
                  <Text fw={500}>ãƒ•ã‚¡ãƒ³</Text>
                </Group>
                <Text size="xs" c="dimmed">æ‰‡çŠ¶ã«åºƒã’ã‚‹ã€‚ãƒˆãƒ©ãƒ³ãƒ—ã®æ‰‹æœ­è¡¨ç¤ºé¢¨ã€‚</Text>
              </Paper>
              <Paper p="sm" withBorder>
                <Group gap="xs" mb="xs">
                  <Text size="lg">â¡ï¸</Text>
                  <Text fw={500}>ãƒªãƒœãƒ³</Text>
                </Group>
                <Text size="xs" c="dimmed">æ¨ªä¸€åˆ—ã«åºƒã’ã‚‹ã€‚ã‚«ãƒ¼ãƒ‰ä¸€è¦§è¡¨ç¤ºé¢¨ã€‚</Text>
              </Paper>
              <Paper p="sm" withBorder>
                <Group gap="xs" mb="xs">
                  <Text size="lg">ğŸ“</Text>
                  <Text fw={500}>ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰</Text>
                </Group>
                <Text size="xs" c="dimmed">éšæ®µçŠ¶ã«é‡ã­ã‚‹ã€‚ã‚½ãƒªãƒ†ã‚£ã‚¢é¢¨ã€‚</Text>
              </Paper>
            </SimpleGrid>
          </Stack>
        </Card>
      </Stack>
    </Container>
  );
}
````

## File: frontend/src/app/demo/unified-modal/page.tsx
````typescript
'use client';

import { Container, Title, Text, Stack, Button, Paper, Code, Group } from '@mantine/core';
import { UnifiedModalSectionsDemo } from '@/components/common/UnifiedModalSectionsDemo';

/**
 * UnifiedModal ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ã®ãƒ‡ãƒ¢ãƒšãƒ¼ã‚¸
 * 
 * ã‚»ã‚¯ã‚·ãƒ§ãƒ³åˆ†å‰²ã•ã‚ŒãŸãƒ¢ãƒ¼ãƒ€ãƒ«ã®ä½¿ç”¨ä¾‹ã¨ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒ‡ãƒ¢
 */
export default function UnifiedModalDemoPage() {
  return (
    <Container size="lg" py="xl">
      <Stack gap="xl">
        <div>
          <Title order={1} mb="sm">UnifiedModal ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ãƒ‡ãƒ¢</Title>
          <Text c="dimmed" size="lg">
            ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§åˆ†å‰²ã—ã€è‡ªå‹•çš„ã«ãƒ©ãƒ™ãƒ«ä»˜ãDividerã‚’æŒ¿å…¥ã™ã‚‹æ©Ÿèƒ½ã®ãƒ‡ãƒ¢
          </Text>
        </div>

        <Paper shadow="sm" p="xl" withBorder>
          <Stack gap="lg">
            <div>
              <Title order={2} size="h3" mb="sm">æ©Ÿèƒ½æ¦‚è¦</Title>
              <Text>
                UnifiedModalã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«<Code>sections</Code>ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¿½åŠ ã—ã¾ã—ãŸã€‚
                ã“ã‚Œã«ã‚ˆã‚Šã€ãƒ¢ãƒ¼ãƒ€ãƒ«å†…ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’è¤‡æ•°ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«åˆ†å‰²ã—ã€å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³é–“ã«
                è‡ªå‹•çš„ã«ãƒ©ãƒ™ãƒ«ä»˜ãDividerã‚’æŒ¿å…¥ã§ãã¾ã™ã€‚
              </Text>
            </div>

            <div>
              <Title order={3} size="h4" mb="xs">ä¸»ãªåˆ©ç‚¹</Title>
              <Stack gap="xs" ml="md">
                <Text>â€¢ <strong>å¢ƒç•Œã®æ˜ç¢ºåŒ–</strong>: ã‚»ã‚¯ã‚·ãƒ§ãƒ³é–“ã«ãƒ©ãƒ™ãƒ«ä»˜ãDividerãŒè‡ªå‹•æŒ¿å…¥ã•ã‚Œã€ã©ã“ã¾ã§ãŒ1ã¤ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‹æ˜ç¢º</Text>
                <Text>â€¢ <strong>çµ±ä¸€æ€§</strong>: ã™ã¹ã¦ã®ãƒ¢ãƒ¼ãƒ€ãƒ«ã§ä¸€è²«ã—ãŸã‚»ã‚¯ã‚·ãƒ§ãƒ³åŒºåˆ‡ã‚Šã‚¹ã‚¿ã‚¤ãƒ«</Text>
                <Text>â€¢ <strong>ä¿å®ˆæ€§å‘ä¸Š</strong>: ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ§‹é€ ã‚’é…åˆ—ã§ç®¡ç†ã§ãã‚‹ãŸã‚ã€è¿½åŠ ãƒ»å‰Šé™¤ãƒ»ä¸¦ã³æ›¿ãˆãŒå®¹æ˜“</Text>
                <Text>â€¢ <strong>å¯èª­æ€§</strong>: ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã”ã¨ã«è«–ç†çš„ã«ã‚³ãƒ¼ãƒ‰ã‚’åˆ†å‰²ã§ãã€ã‚³ãƒ¼ãƒ‰ã®å¯èª­æ€§ãŒå‘ä¸Š</Text>
              </Stack>
            </div>

            <div>
              <Title order={3} size="h4" mb="xs">ãƒ‡ãƒ¢</Title>
              <Text mb="md">
                ä»¥ä¸‹ã®ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³åˆ†å‰²ã•ã‚ŒãŸãƒ¢ãƒ¼ãƒ€ãƒ«ã®å‹•ä½œã‚’ç¢ºèªã§ãã¾ã™ã€‚
              </Text>
              <UnifiedModalSectionsDemo />
            </div>
          </Stack>
        </Paper>

        <Paper shadow="sm" p="xl" withBorder>
          <Stack gap="md">
            <Title order={2} size="h3">åŸºæœ¬çš„ãªä½¿ã„æ–¹</Title>
            
            <div>
              <Title order={3} size="h4" mb="xs">1. å‹ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</Title>
              <Code block>
{`import { UnifiedModal, type ModalSection } from '@/components/common';`}
              </Code>
            </div>

            <div>
              <Title order={3} size="h4" mb="xs">2. ã‚»ã‚¯ã‚·ãƒ§ãƒ³é…åˆ—ã‚’å®šç¾©</Title>
              <Code block>
{`const sections: ModalSection[] = [
  {
    label: 'åŸºæœ¬æƒ…å ±',
    content: (
      <>
        <TextInput label="åå‰" />
        <TextInput label="ãƒ¡ãƒ¼ãƒ«" />
      </>
    ),
  },
  {
    label: 'è©³ç´°è¨­å®š',
    content: (
      <>
        <Select label="ç¨®åˆ¥" data={[...]} />
        <Textarea label="å‚™è€ƒ" />
      </>
    ),
  },
  {
    // ãƒ©ãƒ™ãƒ«ãªã—ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚‚å¯èƒ½
    content: (
      <Group justify="flex-end">
        <Button>ä¿å­˜</Button>
      </Group>
    ),
  },
];`}
              </Code>
            </div>

            <div>
              <Title order={3} size="h4" mb="xs">3. ãƒ¢ãƒ¼ãƒ€ãƒ«ã«æ¸¡ã™</Title>
              <Code block>
{`<UnifiedModal 
  opened={opened} 
  onClose={onClose} 
  title="ç·¨é›†"
  sections={sections}
/>`}
              </Code>
            </div>
          </Stack>
        </Paper>

        <Paper shadow="sm" p="xl" withBorder>
          <Stack gap="md">
            <Title order={2} size="h3">å‹å®šç¾©</Title>
            
            <Code block>
{`interface ModalSection {
  /** ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ©ãƒ™ãƒ«ï¼ˆDividerã«è¡¨ç¤ºï¼‰ã€‚çœç•¥å¯èƒ½ */
  label?: string;
  /** ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ */
  content: ReactNode;
}

type UnifiedModalProps = Omit<ModalProps, 'children'> & {
  addContentPadding?: boolean;
} & (
  | {
      children: ReactNode;
      sections?: never;
    }
  | {
      children?: never;
      sections: ModalSection[];
    }
);`}
            </Code>

            <Text mt="md" c="dimmed">
              <Code>children</Code>ã¨<Code>sections</Code>ã¯ç›¸äº’æ’ä»–çš„ã§ã™ã€‚
              TypeScriptãŒå‹ãƒ¬ãƒ™ãƒ«ã§ä¸¡æ–¹ã‚’åŒæ™‚ã«ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’é˜²ãã¾ã™ã€‚
            </Text>
          </Stack>
        </Paper>

        <Paper shadow="sm" p="xl" withBorder>
          <Stack gap="md">
            <Title order={2} size="h3">å¾Œæ–¹äº’æ›æ€§</Title>
            
            <Text>
              æ—¢å­˜ã®ãƒ¢ãƒ¼ãƒ€ãƒ«ã¯<Code>children</Code>ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ä½¿ã„ç¶šã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
              å¤‰æ›´ã¯ä¸è¦ã§ã€å¾Œæ–¹äº’æ›æ€§ãŒå®Œå…¨ã«ä¿ãŸã‚Œã¦ã„ã¾ã™ã€‚
            </Text>

            <Code block>
{`// å¾“æ¥ã®æ–¹æ³•ï¼ˆå¼•ãç¶šãå‹•ä½œï¼‰
<UnifiedModal opened={opened} onClose={onClose} title="ç·¨é›†">
  <TextInput label="åå‰" />
  <Button>ä¿å­˜</Button>
</UnifiedModal>`}
            </Code>
          </Stack>
        </Paper>

        <Paper shadow="sm" p="xl" withBorder bg="blue.0">
          <Stack gap="sm">
            <Title order={2} size="h3">å‚è€ƒè³‡æ–™</Title>
            <Group gap="md">
              <Button
                component="a"
                href="https://github.com/NekoyaJolly/my-cats-pro"
                target="_blank"
                variant="light"
              >
                GitHub ãƒªãƒã‚¸ãƒˆãƒª
              </Button>
              <Text c="dimmed">
                è©³ç´°ãªå®Ÿè£…ä¾‹ã¨ãƒ†ã‚¹ãƒˆã¯
                <Code>frontend/src/components/common/UNIFIED_MODAL_SECTIONS.md</Code>
                ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚
              </Text>
            </Group>
          </Stack>
        </Paper>
      </Stack>
    </Container>
  );
}
````

## File: frontend/src/app/export/page.tsx
````typescript
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import {
  Container,
  Card,
  Stack,
  Select,
  Button,
  Group,
  Alert,
  Loader,
} from '@mantine/core';
import { DateInput } from '@mantine/dates';
import { notifications } from '@mantine/notifications';
import { IconDownload, IconAlertCircle, IconFileExport } from '@tabler/icons-react';
import { PageTitle } from '@/components/PageTitle';

type ExportDataType = 'cats' | 'pedigrees' | 'medical_records' | 'care_schedules' | 'tags';
type ExportFormat = 'csv' | 'json';

export default function ExportPage() {
  const router = useRouter();
  const [dataType, setDataType] = useState<ExportDataType>('cats');
  const [format, setFormat] = useState<ExportFormat>('csv');
  const [startDate, setStartDate] = useState<Date | null>(null);
  const [endDate, setEndDate] = useState<Date | null>(null);
  const [loading, setLoading] = useState(false);

  const handleExport = async () => {
    setLoading(true);
    try {
      const token = localStorage.getItem('access_token');
      if (!token) {
        notifications.show({
          title: 'ã‚¨ãƒ©ãƒ¼',
          message: 'ãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ã§ã™',
          color: 'red',
        });
        router.push('/login');
        return;
      }

      const response = await fetch(`${process.env.NEXT_PUBLIC_API_BASE_URL}/export`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify({
          dataType,
          format,
          startDate: startDate?.toISOString(),
          endDate: endDate?.toISOString(),
        }),
      });

      if (!response.ok) {
        throw new Error('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ');
      }

      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      
      const contentDisposition = response.headers.get('Content-Disposition');
      const filenameMatch = contentDisposition?.match(/filename="(.+)"/);
      const filename = filenameMatch ? filenameMatch[1] : `export_${dataType}.${format}`;
      
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      window.URL.revokeObjectURL(url);
      document.body.removeChild(a);

      notifications.show({
        title: 'ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Œäº†',
        message: 'ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãŒé–‹å§‹ã•ã‚Œã¾ã—ãŸ',
        color: 'green',
        icon: <IconDownload size={16} />,
      });
    } catch (error) {
      console.error('Export error:', error);
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: 'ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ',
        color: 'red',
        icon: <IconAlertCircle size={16} />,
      });
    } finally {
      setLoading(false);
    }
  };

  return (
    <Container size="sm" style={{ minHeight: '100vh', paddingTop: '2rem', paddingBottom: '5rem' }}>
      <Stack gap="lg">
        <Group justify="center">
          <PageTitle>ãƒ‡ãƒ¼ã‚¿ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</PageTitle>
        </Group>

        <Alert icon={<IconFileExport size={16} />} title="ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæ©Ÿèƒ½" color="blue">
          ãƒ‡ãƒ¼ã‚¿ã‚’CSVã¾ãŸã¯JSONå½¢å¼ã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã§ãã¾ã™ã€‚
        </Alert>

        <Card shadow="sm" padding="lg" radius="md" withBorder>
          <Stack gap="md">
            <Select
              label="ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå¯¾è±¡"
              description="ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã®ç¨®é¡ã‚’é¸æŠã—ã¦ãã ã•ã„"
              data={[
                { value: 'cats', label: 'çŒ«ãƒ‡ãƒ¼ã‚¿' },
                { value: 'pedigrees', label: 'è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿' },
                { value: 'care_schedules', label: 'ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«' },
                { value: 'tags', label: 'ã‚¿ã‚°ãƒ‡ãƒ¼ã‚¿' },
              ]}
              value={dataType}
              onChange={(value) => setDataType(value as ExportDataType)}
              required
            />

            <Select
              label="ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå½¢å¼"
              description="ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã‚’é¸æŠã—ã¦ãã ã•ã„"
              data={[
                { value: 'csv', label: 'CSVå½¢å¼' },
                { value: 'json', label: 'JSONå½¢å¼' },
              ]}
              value={format}
              onChange={(value) => setFormat(value as ExportFormat)}
              required
            />

            <DateInput
              label="é–‹å§‹æ—¥ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰"
              description="æŒ‡å®šã—ãŸæ—¥ä»˜ä»¥é™ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ"
              placeholder="æ—¥ä»˜ã‚’é¸æŠ"
              value={startDate}
              onChange={(value) => {
                if (typeof value === 'string') {
                  setStartDate(new Date(value));
                } else {
                  setStartDate(value);
                }
              }}
              clearable
            />

            <DateInput
              label="çµ‚äº†æ—¥ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰"
              description="æŒ‡å®šã—ãŸæ—¥ä»˜ä»¥å‰ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ"
              placeholder="æ—¥ä»˜ã‚’é¸æŠ"
              value={endDate}
              onChange={(value) => {
                if (typeof value === 'string') {
                  setEndDate(new Date(value));
                } else {
                  setEndDate(value);
                }
              }}
              clearable
            />

            <Group justify="flex-end" mt="md">
              <Button variant="subtle" onClick={() => router.push('/more')}>
                ã‚­ãƒ£ãƒ³ã‚»ãƒ«
              </Button>
              <Button
                leftSection={loading ? <Loader size="xs" /> : <IconDownload size={16} />}
                onClick={handleExport}
                disabled={loading}
              >
                {loading ? 'ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆä¸­...' : 'ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Ÿè¡Œ'}
              </Button>
            </Group>
          </Stack>
        </Card>
      </Stack>
    </Container>
  );
}
````

## File: frontend/src/app/gallery/page.tsx
````typescript
'use client';

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ãƒšãƒ¼ã‚¸
 * 4ã¤ã®ã‚«ãƒ†ã‚´ãƒªï¼ˆå­çŒ« / çˆ¶çŒ« / æ¯çŒ« / å’æ¥­çŒ«ï¼‰ã‚’ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆã§è¡¨ç¤º
 */

import { Suspense, useState, useEffect } from 'react';
import {
  Container,
  Stack,
  Group,
  Skeleton,
  Text,
} from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { modals } from '@mantine/modals';
import { usePageHeader } from '@/lib/contexts/page-header-context';
import { ActionButton } from '@/components/ActionButton';
import {
  useGalleryEntries,
  useCreateGalleryEntry,
  useDeleteGalleryEntry,
  type GalleryEntry,
  type GalleryCategory,
} from '@/lib/api/hooks/use-gallery';
import { GalleryTabs } from './components/GalleryTabs';
import { GalleryGrid } from './components/GalleryGrid';
import { GalleryAddModal } from './components/GalleryAddModal';
import { MediaLightbox } from './components/MediaLightbox';
import { useGalleryTab, useGalleryPagination } from './hooks/useGalleryTab';

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * Suspenseå¢ƒç•Œå†…ã§ä½¿ç”¨
 */
function GalleryContent() {
  const { setPageHeader } = usePageHeader();
  const { currentTab } = useGalleryTab();
  const { currentPage, setPage } = useGalleryPagination();

  // ãƒ¢ãƒ¼ãƒ€ãƒ«çŠ¶æ…‹ï¼ˆuseEffectã‚ˆã‚Šå‰ã«å®£è¨€ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ï¼‰
  const [addModalOpened, { open: openAddModal, close: closeAddModal }] =
    useDisclosure(false);

  // ãƒšãƒ¼ã‚¸ãƒ˜ãƒƒãƒ€ãƒ¼è¨­å®š
  useEffect(() => {
    setPageHeader(
      'ã‚®ãƒ£ãƒ©ãƒªãƒ¼',
      <ActionButton
        action="create"
        onClick={openAddModal}
      >
        è¿½åŠ 
      </ActionButton>
    );
    return () => setPageHeader(null);
  }, [setPageHeader, openAddModal]);
  const [lightboxOpened, { open: openLightbox, close: closeLightbox }] =
    useDisclosure(false);
  const [selectedEntry, setSelectedEntry] = useState<GalleryEntry | null>(null);
  const [lightboxIndex, setLightboxIndex] = useState(0);

  // API ãƒ•ãƒƒã‚¯
  const {
    data: galleryData,
    isLoading,
    error,
  } = useGalleryEntries(currentTab, currentPage, 20);

  const { mutate: createEntry, isPending: isCreating } =
    useCreateGalleryEntry();
  const { mutate: deleteEntry } =
    useDeleteGalleryEntry();

  // å…¨ã‚«ãƒ†ã‚´ãƒªã®ä»¶æ•°å–å¾—ï¼ˆã‚«ã‚¦ãƒ³ãƒˆç”¨ï¼‰
  const { data: kittenData } = useGalleryEntries('KITTEN', 1, 1);
  const { data: fatherData } = useGalleryEntries('FATHER', 1, 1);
  const { data: motherData } = useGalleryEntries('MOTHER', 1, 1);
  const { data: graduationData } = useGalleryEntries('GRADUATION', 1, 1);

  const counts: Record<GalleryCategory, number> = {
    KITTEN: kittenData?.meta?.total ?? 0,
    FATHER: fatherData?.meta?.total ?? 0,
    MOTHER: motherData?.meta?.total ?? 0,
    GRADUATION: graduationData?.meta?.total ?? 0,
  };

  // ãƒãƒ³ãƒ‰ãƒ©
  const handleCardClick = (entry: GalleryEntry) => {
    if (entry.media.length > 0) {
      setSelectedEntry(entry);
      setLightboxIndex(0);
      openLightbox();
    }
  };

  const handleEditClick = (entry: GalleryEntry) => {
    // TODO: ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’å®Ÿè£…
    console.log('Edit entry:', entry.id);
  };

  const handleDeleteClick = (entry: GalleryEntry) => {
    modals.openConfirmModal({
      title: 'å‰Šé™¤ã®ç¢ºèª',
      children: (
        <Text size="sm">
          ã€Œ{entry.name}ã€ã‚’ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‹ã‚‰å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ
          <br />
          ã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚
        </Text>
      ),
      labels: { confirm: 'å‰Šé™¤', cancel: 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«' },
      confirmProps: { color: 'red' },
      onConfirm: () => {
        deleteEntry(entry.id);
      },
    });
  };

  const handleAddSubmit = (dto: Parameters<typeof createEntry>[0]) => {
    createEntry(dto, {
      onSuccess: () => {
        closeAddModal();
      },
    });
  };

  const handleCloseLightbox = () => {
    closeLightbox();
    setSelectedEntry(null);
  };

  return (
    <Container size="xl">
      <Stack gap="lg">
        {/* ãƒ˜ãƒƒãƒ€ãƒ¼: ã‚¿ãƒ–ã¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ */}
        <Group justify="space-between" align="flex-start" wrap="wrap">
          <GalleryTabs counts={counts} loading={isLoading} />
          <ActionButton
            action="create"
            onClick={openAddModal}
            disabled={isLoading}
          >
            è¿½åŠ 
          </ActionButton>
        </Group>

        {/* ã‚°ãƒªãƒƒãƒ‰ */}
        <GalleryGrid
          entries={galleryData?.data ?? []}
          loading={isLoading}
          error={error ? (error instanceof Error ? error.message : 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ') : null}
          category={currentTab}
          onCardClick={handleCardClick}
          onEditClick={handleEditClick}
          onDeleteClick={handleDeleteClick}
          currentPage={currentPage}
          totalPages={galleryData?.meta?.totalPages}
          onPageChange={setPage}
        />
      </Stack>

      {/* è¿½åŠ ãƒ¢ãƒ¼ãƒ€ãƒ« */}
      <GalleryAddModal
        opened={addModalOpened}
        onClose={closeAddModal}
        category={currentTab}
        onSubmit={handleAddSubmit}
        loading={isCreating}
      />

      {/* ãƒ©ã‚¤ãƒˆãƒœãƒƒã‚¯ã‚¹ */}
      {selectedEntry && (
        <MediaLightbox
          media={selectedEntry.media}
          opened={lightboxOpened}
          onClose={handleCloseLightbox}
          initialIndex={lightboxIndex}
        />
      )}
    </Container>
  );
}

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¹ã‚±ãƒ«ãƒˆãƒ³
 */
function GalleryLoading() {
  return (
    <Container size="xl" py="md">
      <Stack gap="lg">
        <Skeleton height={42} width={400} />
        <Skeleton height={600} />
      </Stack>
    </Container>
  );
}

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ãƒšãƒ¼ã‚¸
 */
export default function GalleryPage() {
  return (
    <Suspense fallback={<GalleryLoading />}>
      <GalleryContent />
    </Suspense>
  );
}
````

## File: frontend/src/app/import/page.tsx
````typescript
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import {
  Container,
  Card,
  Stack,
  Title,
  Text,
  Select,
  Button,
  Group,
  Alert,
  Table,
  Badge,
  Progress,
} from '@mantine/core';
import { Dropzone, MIME_TYPES } from '@mantine/dropzone';
import { notifications } from '@mantine/notifications';
import {
  IconUpload,
  IconFileTypeCsv,
  IconAlertCircle,
  IconCheck,
  IconX,
  IconFileImport,
} from '@tabler/icons-react';
import { PageTitle } from '@/components/PageTitle';

type ImportDataType = 'cats' | 'pedigrees' | 'tags';

interface ImportResult {
  successCount: number;
  errorCount: number;
  totalCount: number;
  errors?: string[];
}

interface PreviewData {
  previewCount: number;
  sampleData: Record<string, unknown>[];
  columns: string[];
  totalCount: number;
}

/**
 * ãƒ‡ãƒ¼ã‚¿ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒšãƒ¼ã‚¸
 * 
 * CSVå½¢å¼ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã§ãã¾ã™
 */
export default function ImportPage() {
  const router = useRouter();
  const [dataType, setDataType] = useState<ImportDataType>('cats');
  const [file, setFile] = useState<File | null>(null);
  const [preview, setPreview] = useState<PreviewData | null>(null);
  const [result, setResult] = useState<ImportResult | null>(null);
  const [loading, setLoading] = useState(false);
  const [importing, setImporting] = useState(false);

  /**
   * ãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚ŒãŸæ™‚ã®å‡¦ç†
   */
  const handleFileDrop = async (files: File[]) => {
    const selectedFile = files[0];
    setFile(selectedFile);
    setResult(null);

    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’å–å¾—
    setLoading(true);
    try {
      const token = localStorage.getItem('access_token');
      if (!token) {
        notifications.show({
          title: 'ã‚¨ãƒ©ãƒ¼',
          message: 'ãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ã§ã™',
          color: 'red',
        });
        router.push('/login');
        return;
      }

      const formData = new FormData();
      formData.append('file', selectedFile);

      const response = await fetch(
        `${process.env.NEXT_PUBLIC_API_BASE_URL}/import/preview`,
        {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
          },
          body: formData,
        }
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(
          errorData?.message || 'ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ'
        );
      }

      const data = await response.json();
      setPreview(data.data);

      notifications.show({
        title: 'ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å–å¾—æˆåŠŸ',
        message: `${data.data.totalCount}ä»¶ã®ãƒ‡ãƒ¼ã‚¿ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ`,
        color: 'green',
      });
    } catch (error) {
      console.error('Preview error:', error);
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: error instanceof Error ? error.message : 'ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ',
        color: 'red',
      });
      setFile(null);
    } finally {
      setLoading(false);
    }
  };

  /**
   * ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’å®Ÿè¡Œ
   */
  const handleImport = async () => {
    if (!file) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„',
        color: 'red',
      });
      return;
    }

    setImporting(true);
    try {
      const token = localStorage.getItem('access_token');
      if (!token) {
        notifications.show({
          title: 'ã‚¨ãƒ©ãƒ¼',
          message: 'ãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ã§ã™',
          color: 'red',
        });
        router.push('/login');
        return;
      }

      const formData = new FormData();
      formData.append('file', file);

      const response = await fetch(
        `${process.env.NEXT_PUBLIC_API_BASE_URL}/import/${dataType}`,
        {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
          },
          body: formData,
        }
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(
          errorData?.message || 'ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ'
        );
      }

      const data = await response.json();
      setResult(data.data);

      if (data.data.errorCount === 0) {
        notifications.show({
          title: 'ã‚¤ãƒ³ãƒãƒ¼ãƒˆå®Œäº†',
          message: `${data.data.successCount}ä»¶ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ`,
          color: 'green',
          icon: <IconCheck size={16} />,
        });
      } else {
        notifications.show({
          title: 'ã‚¤ãƒ³ãƒãƒ¼ãƒˆå®Œäº†ï¼ˆä¸€éƒ¨ã‚¨ãƒ©ãƒ¼ï¼‰',
          message: `æˆåŠŸ: ${data.data.successCount}ä»¶ã€å¤±æ•—: ${data.data.errorCount}ä»¶`,
          color: 'yellow',
          icon: <IconAlertCircle size={16} />,
        });
      }
    } catch (error) {
      console.error('Import error:', error);
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: error instanceof Error ? error.message : 'ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ',
        color: 'red',
        icon: <IconX size={16} />,
      });
    } finally {
      setImporting(false);
    }
  };

  /**
   * ãƒªã‚»ãƒƒãƒˆå‡¦ç†
   */
  const handleReset = () => {
    setFile(null);
    setPreview(null);
    setResult(null);
  };

  return (
    <Container 
      size="md" 
      style={{ minHeight: '100vh', paddingTop: '2rem', paddingBottom: '5rem' }}
    >
      <Stack gap="lg">
        <Group justify="center">
          <PageTitle>ãƒ‡ãƒ¼ã‚¿ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</PageTitle>
        </Group>

        <Alert 
          icon={<IconFileImport size={16} />} 
          title="ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿèƒ½" 
          color="blue"
        >
          CSVå½¢å¼ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’ä¸€æ‹¬ç™»éŒ²ã§ãã¾ã™ã€‚
        </Alert>

        <Card shadow="sm" padding="lg" radius="md" withBorder>
          <Stack gap="md">
            <Select
              label="ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¯¾è±¡"
              description="ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã®ç¨®é¡ã‚’é¸æŠã—ã¦ãã ã•ã„"
              data={[
                { value: 'cats', label: 'çŒ«ãƒ‡ãƒ¼ã‚¿' },
                { value: 'pedigrees', label: 'è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿' },
                { value: 'tags', label: 'ã‚¿ã‚°ãƒ‡ãƒ¼ã‚¿' },
              ]}
              value={dataType}
              onChange={(value) => setDataType(value as ImportDataType)}
              required
              disabled={!!file}
            />

            {!file && (
              <Dropzone
                onDrop={handleFileDrop}
                accept={[MIME_TYPES.csv]}
                maxSize={5 * 1024 * 1024} // 5MB
                loading={loading}
              >
                <Group 
                  justify="center" 
                  gap="xl" 
                  style={{ minHeight: 120, pointerEvents: 'none' }}
                >
                  <Dropzone.Accept>
                    <IconUpload size={50} stroke={1.5} />
                  </Dropzone.Accept>
                  <Dropzone.Reject>
                    <IconX size={50} stroke={1.5} />
                  </Dropzone.Reject>
                  <Dropzone.Idle>
                    <IconFileTypeCsv size={50} stroke={1.5} />
                  </Dropzone.Idle>

                  <div>
                    <Text size="xl" inline>
                      CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—
                    </Text>
                    <Text size="sm" c="dimmed" inline mt={7}>
                      ã¾ãŸã¯ã€ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠï¼ˆæœ€å¤§5MBï¼‰
                    </Text>
                  </div>
                </Group>
              </Dropzone>
            )}

            {file && preview && (
              <>
                <Alert 
                  icon={<IconCheck size={16} />} 
                  title="ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿å®Œäº†" 
                  color="green"
                >
                  <Stack gap={4}>
                    <Text size="sm">ãƒ•ã‚¡ã‚¤ãƒ«å: {file.name}</Text>
                    <Text size="sm">ç·ä»¶æ•°: {preview.totalCount}ä»¶</Text>
                    <Text size="sm">æ¤œå‡ºã‚«ãƒ©ãƒ : {preview.columns.join(', ')}</Text>
                  </Stack>
                </Alert>

                <div>
                  <Text fw={600} mb="xs">
                    ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆæœ€åˆã®{preview.previewCount}ä»¶ï¼‰
                  </Text>
                  <div style={{ overflowX: 'auto' }}>
                    <Table striped highlightOnHover>
                      <Table.Thead>
                        <Table.Tr>
                          {preview.columns.map((col) => (
                            <Table.Th key={col}>{col}</Table.Th>
                          ))}
                        </Table.Tr>
                      </Table.Thead>
                      <Table.Tbody>
                        {preview.sampleData.map((row, i) => (
                          <Table.Tr key={i}>
                            {preview.columns.map((col) => (
                              <Table.Td key={col}>
                                {String(row[col] ?? '')}
                              </Table.Td>
                            ))}
                          </Table.Tr>
                        ))}
                      </Table.Tbody>
                    </Table>
                  </div>
                </div>
              </>
            )}

            {result && (
              <>
                <Alert
                  icon={result.errorCount === 0 ? <IconCheck size={16} /> : <IconAlertCircle size={16} />}
                  title="ã‚¤ãƒ³ãƒãƒ¼ãƒˆçµæœ"
                  color={result.errorCount === 0 ? 'green' : 'yellow'}
                >
                  <Stack gap="xs">
                    <Group gap="md">
                      <Badge color="green" variant="filled">
                        æˆåŠŸ: {result.successCount}ä»¶
                      </Badge>
                      <Badge color="red" variant="filled">
                        å¤±æ•—: {result.errorCount}ä»¶
                      </Badge>
                      <Badge color="gray" variant="filled">
                        ç·ä»¶æ•°: {result.totalCount}ä»¶
                      </Badge>
                    </Group>
                    <Progress
                      value={(result.successCount / result.totalCount) * 100}
                      color="green"
                      size="lg"
                    />
                  </Stack>
                </Alert>

                {result.errors && result.errors.length > 0 && (
                  <Alert 
                    icon={<IconAlertCircle size={16} />} 
                    title="ã‚¨ãƒ©ãƒ¼è©³ç´°" 
                    color="red"
                  >
                    <Stack gap="xs">
                      {result.errors.map((error, i) => (
                        <Text key={i} size="sm">
                          {error}
                        </Text>
                      ))}
                    </Stack>
                  </Alert>
                )}
              </>
            )}

            <Group justify="space-between" mt="md">
              <Group>
                {file && (
                  <Button variant="subtle" onClick={handleReset}>
                    ãƒªã‚»ãƒƒãƒˆ
                  </Button>
                )}
                <Button variant="subtle" onClick={() => router.push('/more')}>
                  æˆ»ã‚‹
                </Button>
              </Group>
              
              {file && !result && (
                <Button
                  leftSection={<IconUpload size={16} />}
                  onClick={handleImport}
                  loading={importing}
                  disabled={!preview}
                >
                  {importing ? 'ã‚¤ãƒ³ãƒãƒ¼ãƒˆä¸­...' : 'ã‚¤ãƒ³ãƒãƒ¼ãƒˆå®Ÿè¡Œ'}
                </Button>
              )}
            </Group>
          </Stack>
        </Card>

        {/* CSV ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆèª¬æ˜ */}
        <Card shadow="sm" padding="lg" radius="md" withBorder>
          <Stack gap="xs">
            <Title order={4}>CSV ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ</Title>
            <Text size="sm" c="dimmed">
              <strong>çŒ«ãƒ‡ãƒ¼ã‚¿:</strong> name, gender, birthDate, breed, color, registrationNumber, microchipNumber, notes
            </Text>
            <Text size="sm" c="dimmed">
              <strong>è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿:</strong> pedigreeId, catName, title, breedCode, genderCode, coatColorCode
            </Text>
            <Text size="sm" c="dimmed">
              <strong>ã‚¿ã‚°ãƒ‡ãƒ¼ã‚¿:</strong> name, category, group, color, isActive
            </Text>
          </Stack>
        </Card>
      </Stack>
    </Container>
  );
}
````

## File: frontend/src/app/pedigrees/[id]/family-tree/client.tsx
````typescript
'use client'

import { useState, useEffect } from 'react';
import {
  Container,
  Title,
  Paper,
  Text,
  Badge,
  Group,
  Stack,
  Button,
  Card,
  LoadingOverlay,
  Alert,
  Grid,
  Select,
} from '@mantine/core';
import { IconArrowLeft, IconDna } from '@tabler/icons-react';
import { useRouter, useParams } from 'next/navigation';
import { apiGet } from '../../../../lib/api';

interface FamilyTreeData {
  id: string;
  pedigreeId: string;
  catName: string;
  breedCode: number | null;
  gender: number | null;
  birthDate: string | null;
  coatColorCode: number | null;
  breed?: { name: string } | null;
  color?: { name: string } | null;
  father?: FamilyTreeData | null;
  mother?: FamilyTreeData | null;
}

export default function FamilyTreeClient() {
  const router = useRouter();
  const params = useParams();
  const pedigreeId = params.id as string;
  
  const [familyTree, setFamilyTree] = useState<FamilyTreeData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [generations, setGenerations] = useState('3');

  const generationOptions = [
    { value: '2', label: '2ä¸–ä»£' },
    { value: '3', label: '3ä¸–ä»£' },
    { value: '4', label: '4ä¸–ä»£' },
    { value: '5', label: '5ä¸–ä»£' },
  ];

  useEffect(() => {
    const fetchFamilyTree = async () => {
      try {
        setLoading(true);
        const response = await apiGet(`/pedigrees/${pedigreeId}/family-tree`, {
          generations: generations.toString()
        });
        
        if (!response.ok) {
          throw new Error('å®¶ç³»å›³ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
        }

        const data = await response.json();
        setFamilyTree(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
      } finally {
        setLoading(false);
      }
    };

    if (pedigreeId) {
      fetchFamilyTree();
    }
  }, [pedigreeId, generations]);

  const formatDate = (dateString: string | null) => {
    if (!dateString) return 'ä¸æ˜';
    return new Date(dateString).toLocaleDateString('ja-JP', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
    });
  };

  const formatGender = (gender: number | null) => {
    switch (gender) {
      case 1: return 'é›„';
      case 2: return 'é›Œ';
      default: return 'ä¸æ˜';
    }
  };

  const getGenderColor = (gender: number | null) => {
    switch (gender) {
      case 1: return 'blue';
      case 2: return 'pink';
      default: return 'gray';
    }
  };

  const PedigreeCard: React.FC<{ 
    pedigree: FamilyTreeData | null;
    level: number;
    position?: 'father' | 'mother';
  }> = ({ pedigree, level: _level, position }) => {
    if (!pedigree) {
      return (
        <Card 
          p="sm" 
          style={{ 
            border: '2px dashed #dee2e6',
            minHeight: '120px',
            backgroundColor: 'var(--background-base)'
          }}
        >
          <Text c="dimmed" ta="center" mt="md">
            æƒ…å ±ãªã—
          </Text>
        </Card>
      );
    }

    const borderColor = position === 'father' ? '#228be6' : position === 'mother' ? '#e64980' : '#868e96';
    
    return (
      <Card 
        p="sm" 
        style={{ 
          border: `2px solid ${borderColor}`,
          cursor: 'pointer',
          transition: 'all 0.2s',
          minHeight: '120px'
        }}
        onClick={() => router.push(`/pedigrees/${pedigree.id}`)}
      >
        <Stack gap="xs">
          <Group justify="space-between" align="flex-start">
            <div>
              <Text fw={600} size="sm" lineClamp={1}>
                {pedigree.catName || 'åå‰ãªã—'}
              </Text>
            </div>
            <Badge size="xs" color={getGenderColor(pedigree.gender)}>
              {formatGender(pedigree.gender)}
            </Badge>
          </Group>
          
          <div>
            <Text size="xs" fw={500} c="blue">
              {pedigree.pedigreeId}
            </Text>
            <Text size="xs" c="dimmed">
              {formatDate(pedigree.birthDate)}
            </Text>
          </div>

          {pedigree.breed && (
            <Badge size="xs" variant="light">
              {pedigree.breed.name}
            </Badge>
          )}
        </Stack>
      </Card>
    );
  };

  const renderFamilyLevel = (pedigree: FamilyTreeData | null, currentLevel: number, maxLevel: number): React.ReactNode => {
    if (!pedigree || currentLevel > maxLevel) {
      return null;
    }

    return (
      <div key={`level-${currentLevel}-${pedigree.id}`}>
        <Grid gutter="md" mb="md">
          {/* ç¾åœ¨ã®å€‹ä½“ */}
          <Grid.Col span={12}>
            <Text fw={600} mb="sm" ta="center">
              {currentLevel === 0 ? 'æœ¬çŒ«' : `ç¬¬${currentLevel}ä¸–ä»£`}
            </Text>
            <Group justify="center">
              <div style={{ width: currentLevel === 0 ? '300px' : '250px' }}>
                <PedigreeCard pedigree={pedigree} level={currentLevel} />
              </div>
            </Group>
          </Grid.Col>

          {/* ä¸¡è¦ª */}
          {(pedigree.father || pedigree.mother) && currentLevel < maxLevel && (
            <Grid.Col span={12}>
              <Text fw={600} mb="sm" ta="center">
                ä¸¡è¦ª
              </Text>
              <Grid>
                <Grid.Col span={6}>
                  <Text size="sm" fw={500} mb="xs" ta="center" c="blue">
                    <Group justify="center" gap="xs">
                      <IconDna size={16} />
                      çˆ¶è¦ª
                    </Group>
                  </Text>
                  <PedigreeCard pedigree={pedigree.father || null} level={currentLevel + 1} position="father" />
                </Grid.Col>
                <Grid.Col span={6}>
                  <Text size="sm" fw={500} mb="xs" ta="center" c="pink">
                    <Group justify="center" gap="xs">
                      <IconDna size={16} />
                      æ¯è¦ª
                    </Group>
                  </Text>
                  <PedigreeCard pedigree={pedigree.mother || null} level={currentLevel + 1} position="mother" />
                </Grid.Col>
              </Grid>
            </Grid.Col>
          )}
        </Grid>

        {/* ç¥–çˆ¶æ¯ä»¥ä¸Šã®ä¸–ä»£ã‚’å†å¸°çš„ã«è¡¨ç¤º */}
        {currentLevel < maxLevel - 1 && (pedigree.father || pedigree.mother) && (
          <div style={{ marginLeft: '20px', paddingLeft: '20px', borderLeft: '2px solid #dee2e6' }}>
            {pedigree.father && renderFamilyLevel(pedigree.father as FamilyTreeData, currentLevel + 1, maxLevel)}
            {pedigree.mother && renderFamilyLevel(pedigree.mother as FamilyTreeData, currentLevel + 1, maxLevel)}
          </div>
        )}
      </div>
    );
  };

  if (loading) {
    return (
      <Container size="xl" py="md">
        <Paper p="md" style={{ position: 'relative', minHeight: '400px' }}>
          <LoadingOverlay visible={true} overlayProps={{ radius: "sm", blur: 2 }} />
        </Paper>
      </Container>
    );
  }

  if (error || !familyTree) {
    return (
      <Container size="xl" py="md">
        <Alert color="red" title="ã‚¨ãƒ©ãƒ¼">
          {error || 'å®¶ç³»å›³ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ'}
        </Alert>
        <Button mt="md" leftSection={<IconArrowLeft size={16} />} onClick={() => router.back()}>
          æˆ»ã‚‹
        </Button>
      </Container>
    );
  }

  return (
    <Container size="xl" py="md">
      <Stack gap="md">
        {/* ãƒ˜ãƒƒãƒ€ãƒ¼ */}
        <Group justify="space-between">
          <Button
            variant="light"
            leftSection={<IconArrowLeft size={16} />}
            onClick={() => router.back()}
          >
            è¡€çµ±æ›¸è©³ç´°ã«æˆ»ã‚‹
          </Button>
          <Group>
            <Select
              label="è¡¨ç¤ºä¸–ä»£æ•°"
              data={generationOptions}
              value={generations}
              onChange={(value) => setGenerations(value || '3')}
              w={120}
            />
          </Group>
        </Group>

        <div>
          <Title order={1} mb="xs">
            {familyTree.catName}ã®å®¶ç³»å›³
          </Title>
          <Group>
            <Badge size="lg" color="blue">
              è¡€çµ±æ›¸ç•ªå·: {familyTree.pedigreeId}
            </Badge>
            <Badge size="lg" color={getGenderColor(familyTree.gender)}>
              {formatGender(familyTree.gender)}
            </Badge>
            {familyTree.breed && (
              <Badge size="lg" variant="light">
                {familyTree.breed.name}
              </Badge>
            )}
          </Group>
        </div>

        {/* å®¶ç³»å›³è¡¨ç¤º */}
        <Paper p="md" shadow="sm" style={{ overflow: 'auto' }}>
          <div style={{ minWidth: '800px' }}>
            {renderFamilyLevel(familyTree, 0, parseInt(generations))}
          </div>
        </Paper>

        {/* èª¬æ˜ */}
  <Paper p="md" style={{ backgroundColor: 'var(--background-soft)' }}>
          <Text size="sm" c="dimmed">
            <strong>ä½¿ã„æ–¹:</strong> å„ã‚«ãƒ¼ãƒ‰ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨ã€ãã®å€‹ä½“ã®è©³ç´°æƒ…å ±ã«ç§»å‹•ã§ãã¾ã™ã€‚
            ä¸–ä»£æ•°ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ã§ã€è¡¨ç¤ºã™ã‚‹ç¥–å…ˆã®æ•°ã‚’èª¿æ•´ã§ãã¾ã™ã€‚
          </Text>
        </Paper>
      </Stack>
    </Container>
  );
}
````

## File: frontend/src/app/pedigrees/[id]/family-tree/page.tsx
````typescript
import FamilyTreeClient from './client';

export default function FamilyTreePage() {
  return <FamilyTreeClient />;
}
````

## File: frontend/src/app/pedigrees/[id]/client.tsx
````typescript
'use client'

import { useState, useEffect } from 'react';
import {
  Container,
  Title,
  Paper,
  Grid,
  Text,
  Badge,
  Group,
  Stack,
  Button,
  Card,
  LoadingOverlay,
  Alert,
} from '@mantine/core';
import { IconArrowLeft, IconCalendar, IconUser, IconDna, IconFileText } from '@tabler/icons-react';
import { useRouter, useParams } from 'next/navigation';
import { apiGet } from '../../../lib/api';

interface PedigreeDetail {
  id: string;
  pedigreeId: string;
  catId: string | null;
  title: string | null;
  catName: string;
  breedCode: number | null;
  gender: number | null;
  eyeColor: string | null;
  coatColorCode: number | null;
  birthDate: string | null;
  registrationDate: string | null;
  breederName: string | null;
  ownerName: string | null;
  brotherCount: number | null;
  sisterCount: number | null;
  notes: string | null;
  notes2: string | null;
  otherNo: string | null;
  oldCode: string | null;
  breed: { id: string; name: string; code: number } | null;
  color: { id: string; name: string; code: number } | null;
  fatherPedigree: {
    id: string;
    pedigreeId: string;
    catName: string;
    breedCode: number | null;
    coatColorCode: number | null;
  } | null;
  motherPedigree: {
    id: string;
    pedigreeId: string;
    catName: string;
    breedCode: number | null;
    coatColorCode: number | null;
  } | null;
  fatherOf: Array<{ id: string; pedigreeId: string; catName: string }>;
  motherOf: Array<{ id: string; pedigreeId: string; catName: string }>;
}

export default function PedigreeDetailClient() {
  const router = useRouter();
  const params = useParams();
  const pedigreeId = params.id as string;
  
  const [pedigree, setPedigree] = useState<PedigreeDetail | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchPedigree = async () => {
      try {
        setLoading(true);
        const response = await apiGet(`/pedigrees/${pedigreeId}`);
        
        if (!response.ok) {
          throw new Error('è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
        }

        const data = await response.json();
        setPedigree(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
      } finally {
        setLoading(false);
      }
    };

    if (pedigreeId) {
      fetchPedigree();
    }
  }, [pedigreeId]);

  const formatDate = (dateString: string | null) => {
    if (!dateString) return 'ä¸æ˜';
    return new Date(dateString).toLocaleDateString('ja-JP', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    });
  };

  const formatGender = (gender: number | null) => {
    switch (gender) {
      case 1: return 'é›„';
      case 2: return 'é›Œ';
      default: return 'ä¸æ˜';
    }
  };

  const getGenderColor = (gender: number | null) => {
    switch (gender) {
      case 1: return 'blue';
      case 2: return 'pink';
      default: return 'gray';
    }
  };

  if (loading) {
    return (
      <Container size="lg" py="md">
        <Paper p="md" style={{ position: 'relative', minHeight: '400px' }}>
          <LoadingOverlay visible={true} overlayProps={{ radius: "sm", blur: 2 }} />
        </Paper>
      </Container>
    );
  }

  if (error || !pedigree) {
    return (
      <Container size="lg" py="md">
        <Alert color="red" title="ã‚¨ãƒ©ãƒ¼">
          {error || 'è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ'}
        </Alert>
        <Button mt="md" leftSection={<IconArrowLeft size={16} />} onClick={() => router.back()}>
          æˆ»ã‚‹
        </Button>
      </Container>
    );
  }

  return (
    <Container size="lg" py="md">
      <Stack gap="md">
        {/* ãƒ˜ãƒƒãƒ€ãƒ¼ */}
        <Group justify="space-between">
          <Button
            variant="light"
            leftSection={<IconArrowLeft size={16} />}
            onClick={() => router.back()}
          >
            è¡€çµ±æ›¸ä¸€è¦§ã«æˆ»ã‚‹
          </Button>
          <Group>
            <Button
              variant="light"
              color="green"
              leftSection={<IconFileText size={16} />}
              onClick={() => router.push(`/pedigrees/${pedigree.id}/family-tree`)}
            >
              å®¶ç³»å›³ã‚’è¦‹ã‚‹
            </Button>
          </Group>
        </Group>

        <Title order={1}>è¡€çµ±æ›¸è©³ç´°æƒ…å ±</Title>

        {/* åŸºæœ¬æƒ…å ± */}
        <Paper p="md" shadow="sm">
          <Title order={2} size="h3" mb="md">åŸºæœ¬æƒ…å ±</Title>
          <Grid>
            <Grid.Col span={{ base: 12, md: 6 }}>
              <Stack gap="xs">
                <Group>
                  <Text fw={600}>è¡€çµ±æ›¸ç•ªå·:</Text>
                  <Badge size="lg" color="blue">{pedigree.pedigreeId}</Badge>
                </Group>
                <Group>
                  <Text fw={600}>çŒ«å:</Text>
                  <Text size="lg" fw={500}>{pedigree.catName || 'åå‰ãªã—'}</Text>
                </Group>
                <Group>
                  <Text fw={600}>ã‚¿ã‚¤ãƒˆãƒ«:</Text>
                  <Text>{pedigree.title || '-'}</Text>
                </Group>
                <Group>
                  <Text fw={600}>æ€§åˆ¥:</Text>
                  <Badge color={getGenderColor(pedigree.gender)}>
                    {formatGender(pedigree.gender)}
                  </Badge>
                </Group>
              </Stack>
            </Grid.Col>
            <Grid.Col span={{ base: 12, md: 6 }}>
              <Stack gap="xs">
                <Group>
                  <IconCalendar size={16} />
                  <Text fw={600}>ç”Ÿå¹´æœˆæ—¥:</Text>
                  <Text>{formatDate(pedigree.birthDate)}</Text>
                </Group>
                <Group>
                  <IconCalendar size={16} />
                  <Text fw={600}>ç™»éŒ²å¹´æœˆæ—¥:</Text>
                  <Text>{formatDate(pedigree.registrationDate)}</Text>
                </Group>
                <Group>
                  <Text fw={600}>å“ç¨®ã‚³ãƒ¼ãƒ‰:</Text>
                  <Text>{pedigree.breedCode || '-'}</Text>
                  {pedigree.breed && (
                    <Badge variant="light">{pedigree.breed.name}</Badge>
                  )}
                </Group>
                <Group>
                  <Text fw={600}>æ¯›è‰²ã‚³ãƒ¼ãƒ‰:</Text>
                  <Text>{pedigree.coatColorCode || '-'}</Text>
                  {pedigree.color && (
                    <Badge variant="light" color="orange">{pedigree.color.name}</Badge>
                  )}
                </Group>
                <Group>
                  <Text fw={600}>ç›®è‰²:</Text>
                  <Text>{pedigree.eyeColor || '-'}</Text>
                </Group>
              </Stack>
            </Grid.Col>
          </Grid>
        </Paper>

        {/* é–¢ä¿‚è€…æƒ…å ± */}
        <Paper p="md" shadow="sm">
          <Title order={2} size="h3" mb="md">é–¢ä¿‚è€…æƒ…å ±</Title>
          <Grid>
            <Grid.Col span={{ base: 12, md: 6 }}>
              <Group>
                <IconUser size={16} />
                <Text fw={600}>ç¹æ®–è€…:</Text>
                <Text>{pedigree.breederName || '-'}</Text>
              </Group>
            </Grid.Col>
            <Grid.Col span={{ base: 12, md: 6 }}>
              <Group>
                <IconUser size={16} />
                <Text fw={600}>æ‰€æœ‰è€…:</Text>
                <Text>{pedigree.ownerName || '-'}</Text>
              </Group>
            </Grid.Col>
          </Grid>
        </Paper>

        {/* å®¶æ—æƒ…å ± */}
        <Paper p="md" shadow="sm">
          <Title order={2} size="h3" mb="md">å®¶æ—æƒ…å ±</Title>
          
          <Grid>
            {/* å…„å¼Ÿå§‰å¦¹æƒ…å ± */}
            <Grid.Col span={12}>
              <Group>
                <Text fw={600}>å…„å¼Ÿ:</Text>
                <Badge>{pedigree.brotherCount ?? 0}åŒ¹</Badge>
                <Text fw={600}>å§‰å¦¹:</Text>
                <Badge>{pedigree.sisterCount ?? 0}åŒ¹</Badge>
              </Group>
            </Grid.Col>

            {/* ä¸¡è¦ªæƒ…å ± */}
            <Grid.Col span={{ base: 12, md: 6 }}>
              <Card p="md" style={{ border: '2px solid #228be6' }}>
                <Group mb="xs">
                  <IconDna size={16} />
                  <Text fw={600} c="blue">çˆ¶è¦ª</Text>
                </Group>
                {pedigree.fatherPedigree ? (
                  <Stack gap="xs">
                    <Text size="sm">
                      <Text span fw={500}>è¡€çµ±æ›¸ç•ªå·:</Text> {pedigree.fatherPedigree.pedigreeId}
                    </Text>
                    <Text size="sm">
                      <Text span fw={500}>çŒ«å:</Text> {pedigree.fatherPedigree.catName}
                    </Text>
                    <Text size="sm">
                      <Text span fw={500}>å“ç¨®ã‚³ãƒ¼ãƒ‰:</Text> {pedigree.fatherPedigree.breedCode || '-'}
                    </Text>
                    <Button
                      size="xs"
                      variant="light"
                      onClick={() => {
                        if (!pedigree.fatherPedigree) return;
                        router.push(`/pedigrees/${pedigree.fatherPedigree.id}`);
                      }}
                    >
                      è©³ç´°ã‚’è¦‹ã‚‹
                    </Button>
                  </Stack>
                ) : (
                  <Text c="dimmed">æƒ…å ±ãªã—</Text>
                )}
              </Card>
            </Grid.Col>

            <Grid.Col span={{ base: 12, md: 6 }}>
              <Card p="md" style={{ border: '2px solid #e64980' }}>
                <Group mb="xs">
                  <IconDna size={16} />
                  <Text fw={600} c="pink">æ¯è¦ª</Text>
                </Group>
                {pedigree.motherPedigree ? (
                  <Stack gap="xs">
                    <Text size="sm">
                      <Text span fw={500}>è¡€çµ±æ›¸ç•ªå·:</Text> {pedigree.motherPedigree.pedigreeId}
                    </Text>
                    <Text size="sm">
                      <Text span fw={500}>çŒ«å:</Text> {pedigree.motherPedigree.catName}
                    </Text>
                    <Text size="sm">
                      <Text span fw={500}>å“ç¨®ã‚³ãƒ¼ãƒ‰:</Text> {pedigree.motherPedigree.breedCode || '-'}
                    </Text>
                    <Button
                      size="xs"
                      variant="light"
                      onClick={() => {
                        if (!pedigree.motherPedigree) return;
                        router.push(`/pedigrees/${pedigree.motherPedigree.id}`);
                      }}
                    >
                      è©³ç´°ã‚’è¦‹ã‚‹
                    </Button>
                  </Stack>
                ) : (
                  <Text c="dimmed">æƒ…å ±ãªã—</Text>
                )}
              </Card>
            </Grid.Col>
          </Grid>
        </Paper>

        {/* å­ä¾›æƒ…å ± */}
        {(pedigree.fatherOf.length > 0 || pedigree.motherOf.length > 0) && (
          <Paper p="md" shadow="sm">
            <Title order={2} size="h3" mb="md">å­ä¾›</Title>
            <Grid>
              {pedigree.fatherOf.length > 0 && (
                <Grid.Col span={{ base: 12, md: 6 }}>
                  <Text fw={600} mb="xs">çˆ¶è¦ªã¨ã—ã¦</Text>
                  <Stack gap="xs">
                    {pedigree.fatherOf.map((child) => (
                      <Card key={child.id} p="xs" style={{ border: '1px solid #dee2e6' }}>
                        <Group justify="space-between">
                          <div>
                            <Text size="sm" fw={500}>{child.catName}</Text>
                            <Text size="xs" c="dimmed">{child.pedigreeId}</Text>
                          </div>
                          <Button
                            size="xs"
                            variant="light"
                            onClick={() => router.push(`/pedigrees/${child.id}`)}
                          >
                            è©³ç´°
                          </Button>
                        </Group>
                      </Card>
                    ))}
                  </Stack>
                </Grid.Col>
              )}
              
              {pedigree.motherOf.length > 0 && (
                <Grid.Col span={{ base: 12, md: 6 }}>
                  <Text fw={600} mb="xs">æ¯è¦ªã¨ã—ã¦</Text>
                  <Stack gap="xs">
                    {pedigree.motherOf.map((child) => (
                      <Card key={child.id} p="xs" style={{ border: '1px solid #dee2e6' }}>
                        <Group justify="space-between">
                          <div>
                            <Text size="sm" fw={500}>{child.catName}</Text>
                            <Text size="xs" c="dimmed">{child.pedigreeId}</Text>
                          </div>
                          <Button
                            size="xs"
                            variant="light"
                            onClick={() => router.push(`/pedigrees/${child.id}`)}
                          >
                            è©³ç´°
                          </Button>
                        </Group>
                      </Card>
                    ))}
                  </Stack>
                </Grid.Col>
              )}
            </Grid>
          </Paper>
        )}

        {/* ãã®ä»–ã®æƒ…å ± */}
        <Paper p="md" shadow="sm">
          <Title order={2} size="h3" mb="md">ãã®ä»–ã®æƒ…å ±</Title>
          <Grid>
            <Grid.Col span={{ base: 12, md: 6 }}>
              <Stack gap="xs">
                <Group>
                  <Text fw={600}>ä»–å›£ä½“No:</Text>
                  <Text>{pedigree.otherNo || '-'}</Text>
                </Group>
                <Group>
                  <Text fw={600}>æ—§ã‚³ãƒ¼ãƒ‰:</Text>
                  <Text>{pedigree.oldCode || '-'}</Text>
                </Group>
              </Stack>
            </Grid.Col>
            <Grid.Col span={{ base: 12, md: 6 }}>
              <Stack gap="xs">
                <div>
                  <Text fw={600} mb="xs">æ‘˜è¦:</Text>
                  <Text size="sm" style={{ whiteSpace: 'pre-wrap' }}>
                    {pedigree.notes || 'è¨˜è¼‰ãªã—'}
                  </Text>
                </div>
                {pedigree.notes2 && (
                  <div>
                    <Text fw={600} mb="xs">æ‘˜è¦2:</Text>
                    <Text size="sm" style={{ whiteSpace: 'pre-wrap' }}>
                      {pedigree.notes2}
                    </Text>
                  </div>
                )}
              </Stack>
            </Grid.Col>
          </Grid>
        </Paper>
      </Stack>
    </Container>
  );
}
````

## File: frontend/src/app/pedigrees/[id]/layout.tsx
````typescript
// Static export support - return empty array for dynamic routes
export function generateStaticParams() {
  return [];
}

export default function PedigreeLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return <>{children}</>;
}
````

## File: frontend/src/app/pedigrees/[id]/page.tsx
````typescript
import PedigreeDetailClient from './client';

export default function PedigreeDetailPage() {
  return <PedigreeDetailClient />;
}
````

## File: frontend/src/app/staff/shifts/page.tsx
````typescript
'use client';

import { useState, useEffect, useRef, useCallback } from 'react';
import { useRouter } from 'next/navigation';
import {
  Container,
  Text,
  Group,
  Stack,
  Button,
  Paper,
  TextInput,
  ColorInput,
  ScrollArea,
  LoadingOverlay,
  Alert,
  Badge,
  ActionIcon,
  Menu,
  Checkbox,
  NumberInput,
  Textarea,
  CopyButton,
  Tooltip,
  Box,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure, useMediaQuery, useLocalStorage } from '@mantine/hooks';
import {
  IconPlus,
  IconUser,
  IconEdit,
  IconTrash,
  IconDotsVertical,
  IconDeviceFloppy,
  IconX,
  IconAlertCircle,
  IconGripVertical,
  IconChevronDown,
  IconCalendarPlus,
  IconUsers,
  IconCalendarEvent,
} from '@tabler/icons-react';
import { notifications } from '@mantine/notifications';
import { ActionMenu } from '@/app/tenants/_components/ActionMenu';
import FullCalendar from '@fullcalendar/react';
import dayGridPlugin from '@fullcalendar/daygrid';
import interactionPlugin, { Draggable, EventReceiveArg } from '@fullcalendar/interaction';
import type { EventDropArg, EventClickArg, EventContentArg, DayCellContentArg } from '@fullcalendar/core';
import { UnifiedModal } from '@/components/common';
import { usePageHeader } from '@/lib/contexts/page-header-context';
import { apiClient, ApiError } from '@/lib/api/typesafe-client';
import type {
  StaffResponseDto,
  CreateStaffRequest,
  UpdateStaffRequest,
  CalendarShiftEvent,
  Weekday,
  WorkTimeTemplate,
} from '@/types/api.types';

/**
 * å…±é€šãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³é–¢æ•°
 */
const validateName = (value: string | undefined): string | null => {
  return !value ? 'åå‰ã¯å¿…é ˆã§ã™' : null;
};

const validateColor = (value: string | undefined): string | null => {
  if (!value) return 'ã‚«ãƒ©ãƒ¼ã¯å¿…é ˆã§ã™';
  if (!/^#[0-9A-Fa-f]{6}$/.test(value)) {
    return 'ã‚«ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ã¯#000000å½¢å¼ã§æŒ‡å®šã—ã¦ãã ã•ã„';
  }
  return null;
};

const validateWorkingDays = (value: Weekday[] | undefined): string | null => {
  return !value || value.length === 0 ? 'å°‘ãªãã¨ã‚‚1ã¤ã®å‡ºå‹¤æ›œæ—¥ã‚’é¸æŠã—ã¦ãã ã•ã„' : null;
};

const validateWorkTimeTemplate = (value: WorkTimeTemplate | undefined): string | null => {
  if (!value) return null;
  const { startHour, endHour } = value;
  // NumberInput ã¯ 0 ã‚’å«ã‚€æ•°å€¤ã¾ãŸã¯ NaN ã‚’è¿”ã™å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€å‹ãƒã‚§ãƒƒã‚¯ã§æ¤œè¨¼
  if (
    typeof startHour !== 'number' ||
    typeof endHour !== 'number' ||
    Number.isNaN(startHour) ||
    Number.isNaN(endHour)
  ) {
    return 'é–‹å§‹ï¼çµ‚äº†æ™‚é–“ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„';
  }
  if (startHour < 0 || startHour > 23 || endHour < 1 || endHour > 24) {
    return 'é–‹å§‹æ™‚é–“ã¯0ã€œ23ã€çµ‚äº†æ™‚é–“ã¯1ã€œ24ã®ç¯„å›²ã§æŒ‡å®šã—ã¦ãã ã•ã„';
  }
  if (endHour <= startHour) {
    return 'çµ‚äº†æ™‚é–“ã¯é–‹å§‹æ™‚é–“ã‚ˆã‚Šå¾Œã«ã—ã¦ãã ã•ã„';
  }
  return null;
};

export default function StaffShiftsPage() {
  const calendarRef = useRef<FullCalendar>(null);
  const { setPageHeader } = usePageHeader();
  useRouter();

  // ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–åˆ¤å®šï¼ˆã‚¿ãƒ–ãƒ¬ãƒƒãƒˆä»¥ä¸‹: 768pxæœªæº€ï¼‰
  const isMobile = useMediaQuery('(max-width: 768px)');

  // ãƒªã‚µã‚¤ã‚ºå¯èƒ½ãªã‚»ã‚¯ã‚·ãƒ§ãƒ³å¹…/é«˜ã•ï¼ˆlocalStorageã«ä¿å­˜ï¼‰
  const [staffListWidth, setStaffListWidth] = useLocalStorage<number>({
    key: 'shift-staff-list-width',
    defaultValue: 200,
  });
  const [textShiftHeight, setTextShiftHeight] = useLocalStorage<number>({
    key: 'shift-text-shift-height',
    defaultValue: 200,
  });

  // ãƒªã‚µã‚¤ã‚ºçŠ¶æ…‹ç®¡ç†
  const [isResizingWidth, setIsResizingWidth] = useState(false);
  const [isResizingHeight, setIsResizingHeight] = useState(false);
  const resizeRef = useRef<{ startX: number; startY: number; startWidth: number; startHeight: number } | null>(null);

  // æ¨ªå¹…ãƒªã‚µã‚¤ã‚ºé–‹å§‹
  const handleWidthResizeStart = useCallback((e: React.MouseEvent) => {
    e.preventDefault();
    setIsResizingWidth(true);
    resizeRef.current = {
      startX: e.clientX,
      startY: e.clientY,
      startWidth: staffListWidth,
      startHeight: textShiftHeight,
    };
  }, [staffListWidth, textShiftHeight]);

  // é«˜ã•ãƒªã‚µã‚¤ã‚ºé–‹å§‹
  const handleHeightResizeStart = useCallback((e: React.MouseEvent) => {
    e.preventDefault();
    setIsResizingHeight(true);
    resizeRef.current = {
      startX: e.clientX,
      startY: e.clientY,
      startWidth: staffListWidth,
      startHeight: textShiftHeight,
    };
  }, [staffListWidth, textShiftHeight]);

  // ãƒªã‚µã‚¤ã‚ºä¸­ã®å‡¦ç†
  useEffect(() => {
    if (!isResizingWidth && !isResizingHeight) return;

    const handleMouseMove = (e: MouseEvent) => {
      if (!resizeRef.current) return;

      if (isResizingWidth) {
        const diff = e.clientX - resizeRef.current.startX;
        const newWidth = Math.max(150, Math.min(400, resizeRef.current.startWidth + diff));
        setStaffListWidth(newWidth);
      }

      if (isResizingHeight) {
        const diff = resizeRef.current.startY - e.clientY;
        const newHeight = Math.max(100, Math.min(400, resizeRef.current.startHeight + diff));
        setTextShiftHeight(newHeight);
      }
    };

    const handleMouseUp = () => {
      setIsResizingWidth(false);
      setIsResizingHeight(false);
      resizeRef.current = null;
    };

    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);

    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
  }, [isResizingWidth, isResizingHeight, setStaffListWidth, setTextShiftHeight]);

  // Stateç®¡ç†
  const [staffList, setStaffList] = useState<StaffResponseDto[]>([]);
  const [shifts, setShifts] = useState<CalendarShiftEvent[]>([]);
  const [selectedStaff, setSelectedStaff] = useState<StaffResponseDto | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // ãƒ¢ãƒ¼ãƒ€ãƒ«åˆ¶å¾¡
  const [createOpened, { open: openCreate, close: closeCreate }] = useDisclosure(false);
  const [editOpened, { open: openEdit, close: closeEdit }] = useDisclosure(false);
  const [deleteOpened, { open: openDelete, close: closeDelete }] = useDisclosure(false);
  const [selectStaffOpened, { open: openSelectStaff, close: closeSelectStaff }] = useDisclosure(false);
  const [operationLoading, setOperationLoading] = useState(false);

  // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå…¥åŠ›ç”¨ã‚¹ã‚¿ãƒƒãƒ•é¸æŠ
  const [selectedStaffIds, setSelectedStaffIds] = useState<string[]>([]);

  // ã‚¹ã‚¿ãƒƒãƒ•ä½œæˆãƒ•ã‚©ãƒ¼ãƒ 
  // ãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ workingDays ã¨ workTimeTemplate ã‚’å¿…é ˆã¨ã—ã¦æ‰±ã†
  // APIã¸é€ä¿¡æ™‚ã¯ãã®ã¾ã¾ CreateStaffRequest ã¨ã—ã¦ä½¿ç”¨å¯èƒ½ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ãŸã‚ï¼‰
  const createForm = useForm<
    Omit<CreateStaffRequest, 'workingDays' | 'workTimeTemplate' | 'email'> & {
      workingDays: Weekday[];
      workTimeTemplate: WorkTimeTemplate;
      email: string;
    }
  >({
    initialValues: {
      name: '',
      email: '',
      role: 'ã‚¹ã‚¿ãƒƒãƒ•',
      color: '#4dabf7',
      workingDays: [],
      workTimeTemplate: { startHour: 9, endHour: 18 },
    },
    validate: {
      name: validateName,
      color: validateColor,
      workingDays: validateWorkingDays,
      workTimeTemplate: validateWorkTimeTemplate,
    },
  });

  // ã‚¹ã‚¿ãƒƒãƒ•ç·¨é›†ãƒ•ã‚©ãƒ¼ãƒ 
  // ãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ workingDays ã¨ workTimeTemplate ã‚’å¿…é ˆã¨ã—ã¦æ‰±ã†
  // APIã¸é€ä¿¡æ™‚ã¯ãã®ã¾ã¾ UpdateStaffRequest ã¨ã—ã¦ä½¿ç”¨å¯èƒ½ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ãŸã‚ï¼‰
  const editForm = useForm<
    Omit<UpdateStaffRequest, 'workingDays' | 'workTimeTemplate' | 'email'> & {
      workingDays: Weekday[];
      workTimeTemplate: WorkTimeTemplate;
      email: string;
    }
  >({
    initialValues: {
      name: '',
      email: '',
      role: 'ã‚¹ã‚¿ãƒƒãƒ•',
      color: '#4dabf7',
      workingDays: [],
      workTimeTemplate: { startHour: 9, endHour: 18 },
    },
    validate: {
      name: validateName,
      color: validateColor,
      workingDays: validateWorkingDays,
      workTimeTemplate: validateWorkTimeTemplate,
    },
  });

  // ãƒšãƒ¼ã‚¸ãƒ˜ãƒƒãƒ€ãƒ¼è¨­å®š
  useEffect(() => {
    setPageHeader(
      'ã‚¹ã‚¿ãƒƒãƒ•ã‚·ãƒ•ãƒˆç®¡ç†',
      <ActionMenu
        buttonLabel="æ“ä½œ"
        buttonIcon={IconPlus}
        action="create"
        items={[
          {
            id: 'add-staff',
            label: 'ã‚¹ã‚¿ãƒƒãƒ•è¿½åŠ ',
            icon: <IconPlus size={16} />,
            onClick: openCreate,
          },
          {
            id: 'bulk-input',
            label: 'å…¨å“¡ä¸€æ‹¬å…¥åŠ›',
            icon: <IconCalendarPlus size={16} />,
            onClick: handleBulkTemplateInput,
          },
          {
            id: 'select-input',
            label: 'é¸æŠå…¥åŠ›...',
            icon: <IconUsers size={16} />,
            onClick: openSelectStaff,
          }
        ]}
      />
    );

    return () => setPageHeader(null);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // åˆæœŸãƒ‡ãƒ¼ã‚¿å–å¾—
  useEffect(() => {
    fetchInitialData();
  }, []);

  // ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½ãªè¦ç´ ã®åˆæœŸåŒ–
  useEffect(() => {
    let draggable: Draggable | null = null;

    // isMobile ãŒ undefined ã®é–“ï¼ˆSSR / åˆæœŸãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ï¼‰ã¯ã‚¹ã‚­ãƒƒãƒ—
    if (isMobile === undefined) return;

    const staffListElement = document.getElementById('staff-list');
    if (staffListElement && staffList.length > 0) {
      draggable = new Draggable(staffListElement, {
        itemSelector: '.draggable-staff',
        eventData: function (eventEl: HTMLElement) {
          const staffId = eventEl.getAttribute('data-staff-id') || '';
          const staffName = eventEl.getAttribute('data-staff-name') || '';
          const staffColor = eventEl.getAttribute('data-staff-color') || '#4c6ef5';
          return {
            title: staffName,
            backgroundColor: staffColor,
            borderColor: staffColor,
            extendedProps: {
              staffId: staffId,
              staffName: staffName,
            },
          };
        },
      });
    }

    return () => {
      if (draggable) {
        draggable.destroy();
      }
    };
  }, [staffList, isMobile]);

  /**
   * åˆæœŸãƒ‡ãƒ¼ã‚¿å–å¾—
   */
  const fetchInitialData = async () => {
    setLoading(true);
    setError(null);

    try {
      // ã‚¹ã‚¿ãƒƒãƒ•ä¸€è¦§ã‚’å–å¾—
      const staffData = await apiClient.getStaffList();
      setStaffList(staffData.staffList);

      // ä»Šæœˆã®ã‚·ãƒ•ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
      const now = new Date();
      const startDate = new Date(now.getFullYear(), now.getMonth(), 1)
        .toISOString()
        .split('T')[0];
      const endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0)
        .toISOString()
        .split('T')[0];

      const shiftsData = await apiClient.getCalendarShifts({ startDate, endDate });
      setShifts(shiftsData);
    } catch (err) {
      const errorMessage = err instanceof ApiError ? err.message : 'ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ';
      setError(errorMessage);
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: errorMessage,
        color: 'red',
      });
    } finally {
      setLoading(false);
    }
  };

  /**
   * ã‚¹ã‚¿ãƒƒãƒ•ä½œæˆ
   */
  const handleCreateStaff = async (values: CreateStaffRequest & { workingDays: Weekday[]; workTimeTemplate: WorkTimeTemplate }) => {
    setOperationLoading(true);

    try {
      // ç©ºæ–‡å­—åˆ—ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’undefinedã«å¤‰æ›ï¼ˆãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼å›é¿ï¼‰
      const sanitizedValues = {
        ...values,
        email: values.email === '' ? undefined : values.email,
      };
      const newStaff = await apiClient.createStaff(sanitizedValues);
      setStaffList((prev) => [...prev, newStaff]);

      notifications.show({
        title: 'ã‚¹ã‚¿ãƒƒãƒ•ä½œæˆæˆåŠŸ',
        message: `${newStaff.name}ã‚’è¿½åŠ ã—ã¾ã—ãŸ`,
        color: 'green',
      });

      closeCreate();
      createForm.reset();
    } catch (err) {
      const errorMessage = err instanceof ApiError ? err.message : 'ã‚¹ã‚¿ãƒƒãƒ•ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ';
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: errorMessage,
        color: 'red',
      });
    } finally {
      setOperationLoading(false);
    }
  };

  /**
   * ã‚¹ã‚¿ãƒƒãƒ•ç·¨é›†
   */
  const handleEditStaff = async (values: UpdateStaffRequest & { workingDays: Weekday[]; workTimeTemplate: WorkTimeTemplate }) => {
    if (!selectedStaff) return;

    setOperationLoading(true);

    try {
      // ç©ºæ–‡å­—åˆ—ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’undefinedã«å¤‰æ›ï¼ˆãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼å›é¿ï¼‰
      const sanitizedValues = {
        ...values,
        email: values.email === '' ? undefined : values.email,
      };
      const updatedStaff = await apiClient.updateStaff(selectedStaff.id, sanitizedValues);
      setStaffList((prev) => prev.map((s) => (s.id === updatedStaff.id ? updatedStaff : s)));

      notifications.show({
        title: 'ã‚¹ã‚¿ãƒƒãƒ•æ›´æ–°æˆåŠŸ',
        message: `${updatedStaff.name}ã®æƒ…å ±ã‚’æ›´æ–°ã—ã¾ã—ãŸ`,
        color: 'green',
      });

      closeEdit();
      setSelectedStaff(null);
    } catch (err) {
      const errorMessage = err instanceof ApiError ? err.message : 'ã‚¹ã‚¿ãƒƒãƒ•ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ';
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: errorMessage,
        color: 'red',
      });
    } finally {
      setOperationLoading(false);
    }
  };

  /**
   * ã‚¹ã‚¿ãƒƒãƒ•å‰Šé™¤
   */
  const handleDeleteStaff = async () => {
    if (!selectedStaff) return;

    setOperationLoading(true);

    try {
      await apiClient.deleteStaff(selectedStaff.id);
      setStaffList((prev) => prev.filter((s) => s.id !== selectedStaff.id));

      notifications.show({
        title: 'ã‚¹ã‚¿ãƒƒãƒ•å‰Šé™¤æˆåŠŸ',
        message: `${selectedStaff.name}ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`,
        color: 'blue',
      });

      closeDelete();
      setSelectedStaff(null);
    } catch (err) {
      const errorMessage = err instanceof ApiError ? err.message : 'ã‚¹ã‚¿ãƒƒãƒ•ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ';
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: errorMessage,
        color: 'red',
      });
    } finally {
      setOperationLoading(false);
    }
  };

  /**
   * ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
   */
  const openEditModal = (staff: StaffResponseDto) => {
    setSelectedStaff(staff);
    editForm.setValues({
      name: staff.name,
      email: staff.email ?? '',
      role: staff.role,
      color: staff.color,
      workingDays: staff.workingDays ?? [],
      workTimeTemplate: staff.workTimeTemplate ?? { startHour: 9, endHour: 18 },
    });
    openEdit();
  };

  /**
   * å‰Šé™¤ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
   */
  const openDeleteModal = (staff: StaffResponseDto) => {
    setSelectedStaff(staff);
    openDelete();
  };

  /**
   * ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã¸ã®ãƒ‰ãƒ­ãƒƒãƒ—ã‚¤ãƒ™ãƒ³ãƒˆ
   */
  const handleEventReceive = async (info: EventReceiveArg) => {
    const staffId = info.event.extendedProps.staffId;
    const shiftDate = info.event.startStr.split('T')[0]; // YYYY-MM-DD

    try {
      const newShift = await apiClient.createShift({
        staffId,
        shiftDate,
      });

      // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆã‚’æ›´æ–°
      info.event.setExtendedProp('shiftId', newShift.id);

      // ã‚·ãƒ•ãƒˆãƒªã‚¹ãƒˆã‚’æ›´æ–°
      await refreshShifts();

      notifications.show({
        title: 'ã‚·ãƒ•ãƒˆä½œæˆæˆåŠŸ',
        message: `${info.event.title}ã®ã‚·ãƒ•ãƒˆã‚’è¿½åŠ ã—ã¾ã—ãŸ`,
        color: 'green',
      });
    } catch (err) {
      info.revert(); // ãƒ‰ãƒ­ãƒƒãƒ—ã‚’å…ƒã«æˆ»ã™
      const errorMessage = err instanceof ApiError ? err.message : 'ã‚·ãƒ•ãƒˆã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ';
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: errorMessage,
        color: 'red',
      });
    }
  };

  /**
   * ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆã®ç§»å‹•
   */
  const handleEventDrop = async (info: EventDropArg) => {
    const shiftId = info.event.extendedProps.shiftId;
    if (!shiftId) {
      info.revert();
      return;
    }

    const newShiftDate = info.event.startStr.split('T')[0]; // YYYY-MM-DD

    try {
      await apiClient.updateShift(shiftId, { shiftDate: newShiftDate });

      notifications.show({
        title: 'ã‚·ãƒ•ãƒˆå¤‰æ›´æˆåŠŸ',
        message: `${info.event.title}ã®ã‚·ãƒ•ãƒˆã‚’å¤‰æ›´ã—ã¾ã—ãŸ`,
        color: 'blue',
      });
    } catch (err) {
      info.revert(); // ç§»å‹•ã‚’å…ƒã«æˆ»ã™
      const errorMessage = err instanceof ApiError ? err.message : 'ã‚·ãƒ•ãƒˆã®å¤‰æ›´ã«å¤±æ•—ã—ã¾ã—ãŸ';
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: errorMessage,
        color: 'red',
      });
    }
  };

  /**
   * ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆã®ã‚¯ãƒªãƒƒã‚¯ï¼ˆå‰Šé™¤ï¼‰
   */
  const handleEventClick = async (info: EventClickArg) => {
    const shiftId = info.event.extendedProps.shiftId;
    if (!shiftId) return;

    if (confirm(`${info.event.title}ã®ã‚·ãƒ•ãƒˆã‚’å‰Šé™¤ã—ã¾ã™ã‹?`)) {
      try {
        await apiClient.deleteShift(shiftId);
        info.event.remove();

        notifications.show({
          title: 'ã‚·ãƒ•ãƒˆå‰Šé™¤æˆåŠŸ',
          message: `${info.event.title}ã®ã‚·ãƒ•ãƒˆã‚’å‰Šé™¤ã—ã¾ã—ãŸ`,
          color: 'blue',
        });
      } catch (err) {
        const errorMessage = err instanceof ApiError ? err.message : 'ã‚·ãƒ•ãƒˆã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ';
        notifications.show({
          title: 'ã‚¨ãƒ©ãƒ¼',
          message: errorMessage,
          color: 'red',
        });
      }
    }
  };

  /**
   * ã‚·ãƒ•ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’å†å–å¾—
   */
  const refreshShifts = async () => {
    const calendarApi = calendarRef.current?.getApi();
    if (!calendarApi) return;

    const view = calendarApi.view;
    const startDate = view.activeStart.toISOString().split('T')[0];
    const endDate = view.activeEnd.toISOString().split('T')[0];

    try {
      const shiftsData = await apiClient.getCalendarShifts({ startDate, endDate });
      setShifts(shiftsData);
    } catch (err) {
      console.error('ã‚·ãƒ•ãƒˆã®å†å–å¾—ã«å¤±æ•—:', err);
    }
  };

  /**
   * æ›œæ—¥ã‚³ãƒ¼ãƒ‰ã‹ã‚‰æ—¥æœ¬ã®æ›œæ—¥ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¸å¤‰æ›
   * JavaScript ã® getDay(): 0=æ—¥, 1=æœˆ, 2=ç«, ... 6=åœŸ
   */
  const weekdayToJsDay: Record<Weekday, number> = {
    sun: 0,
    mon: 1,
    tue: 2,
    wed: 3,
    thu: 4,
    fri: 5,
    sat: 6,
  };

  /**
   * ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆåŸºæº–ã§ã‚·ãƒ•ãƒˆã‚’ä¸€æ‹¬å…¥åŠ›ï¼ˆæŒ‡å®šã‚¹ã‚¿ãƒƒãƒ•ï¼‰
   */
  const handleTemplateInput = async (targetStaffList: StaffResponseDto[]) => {
    const calendarApi = calendarRef.current?.getApi();
    if (!calendarApi) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: 'ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“',
        color: 'red',
      });
      return;
    }

    // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãŒè¨­å®šã•ã‚Œã¦ã„ãªã„ã‚¹ã‚¿ãƒƒãƒ•ã‚’ãƒ•ã‚£ãƒ«ã‚¿
    const staffWithTemplate = targetStaffList.filter(
      (staff) => staff.workingDays && staff.workingDays.length > 0
    );

    if (staffWithTemplate.length === 0) {
      notifications.show({
        title: 'è­¦å‘Š',
        message: 'å‡ºå‹¤æ›œæ—¥ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‚¹ã‚¿ãƒƒãƒ•ãŒã„ã¾ã›ã‚“',
        color: 'yellow',
      });
      return;
    }

    setOperationLoading(true);

    try {
      const view = calendarApi.view;
      const startDate = view.activeStart;
      const endDate = view.activeEnd;

      // æ—¢å­˜ã‚·ãƒ•ãƒˆã®æ—¥ä»˜ã¨ã‚¹ã‚¿ãƒƒãƒ•IDã®ã‚»ãƒƒãƒˆã‚’ä½œæˆï¼ˆé‡è¤‡é˜²æ­¢ï¼‰
      const existingShiftKeys = new Set(
        shifts.map((shift) => {
          const shiftDate = shift.start ? formatDateKey(new Date(shift.start)) : '';
          const staffId = shift.extendedProps?.staffId ?? '';
          return `${shiftDate}_${staffId}`;
        })
      );

      // ç”Ÿæˆã™ã‚‹ã‚·ãƒ•ãƒˆã®ãƒªã‚¹ãƒˆ
      const shiftsToCreate: { staffId: string; shiftDate: string; displayName: string | null }[] = [];

      // è¡¨ç¤ºç¯„å›²å†…ã®å„æ—¥ã‚’èµ°æŸ»
      const currentDate = new Date(startDate);
      while (currentDate < endDate) {
        const dayOfWeek = currentDate.getDay();
        const dateKey = formatDateKey(currentDate);

        // å„ã‚¹ã‚¿ãƒƒãƒ•ã«ã¤ã„ã¦ãƒã‚§ãƒƒã‚¯
        for (const staff of staffWithTemplate) {
          // ã“ã®ã‚¹ã‚¿ãƒƒãƒ•ã®å‡ºå‹¤æ›œæ—¥ã«è©²å½“ã™ã‚‹ã‹
          const workingDays = staff.workingDays ?? [];
          const isWorkingDay = workingDays.some(
            (wd) => weekdayToJsDay[wd as Weekday] === dayOfWeek
          );

          if (isWorkingDay) {
            const key = `${dateKey}_${staff.id}`;
            // æ—¢å­˜ã‚·ãƒ•ãƒˆãŒãªã‘ã‚Œã°è¿½åŠ å¯¾è±¡
            if (!existingShiftKeys.has(key)) {
              // displayName: æ™‚é–“ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãŒã‚ã‚Œã°ã€Œ9ã€œ18ã€å½¢å¼
              const displayName = staff.workTimeTemplate
                ? `${staff.workTimeTemplate.startHour}ã€œ${staff.workTimeTemplate.endHour}`
                : null;

              shiftsToCreate.push({
                staffId: staff.id,
                shiftDate: dateKey,
                displayName,
              });
            }
          }
        }

        currentDate.setDate(currentDate.getDate() + 1);
      }

      if (shiftsToCreate.length === 0) {
        notifications.show({
          title: 'æƒ…å ±',
          message: 'è¿½åŠ ã™ã‚‹ã‚·ãƒ•ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“ï¼ˆæ—¢ã«å…¥åŠ›æ¸ˆã¿ã€ã¾ãŸã¯å¯¾è±¡æ—¥ãŒã‚ã‚Šã¾ã›ã‚“ï¼‰',
          color: 'blue',
        });
        return;
      }

      // ä¸¦åˆ—ã§ã‚·ãƒ•ãƒˆä½œæˆï¼ˆãƒãƒƒãƒå‡¦ç†ï¼‰
      const results = await Promise.allSettled(
        shiftsToCreate.map((shiftData) => apiClient.createShift(shiftData))
      );

      const successCount = results.filter((r) => r.status === 'fulfilled').length;
      const failCount = results.filter((r) => r.status === 'rejected').length;

      // ã‚·ãƒ•ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’å†å–å¾—
      await refreshShifts();

      if (failCount === 0) {
        notifications.show({
          title: 'ã‚·ãƒ•ãƒˆä¸€æ‹¬å…¥åŠ›å®Œäº†',
          message: `${successCount}ä»¶ã®ã‚·ãƒ•ãƒˆã‚’è¿½åŠ ã—ã¾ã—ãŸ`,
          color: 'green',
        });
      } else {
        notifications.show({
          title: 'ã‚·ãƒ•ãƒˆä¸€æ‹¬å…¥åŠ›å®Œäº†ï¼ˆä¸€éƒ¨ã‚¨ãƒ©ãƒ¼ï¼‰',
          message: `æˆåŠŸ: ${successCount}ä»¶ / å¤±æ•—: ${failCount}ä»¶`,
          color: 'yellow',
        });
      }
    } catch (err) {
      const errorMessage = err instanceof ApiError ? err.message : 'ã‚·ãƒ•ãƒˆã®ä¸€æ‹¬å…¥åŠ›ã«å¤±æ•—ã—ã¾ã—ãŸ';
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: errorMessage,
        color: 'red',
      });
    } finally {
      setOperationLoading(false);
    }
  };

  /**
   * å…¨ã‚¹ã‚¿ãƒƒãƒ•ä¸€æ‹¬å…¥åŠ›
   */
  const handleBulkTemplateInput = () => {
    handleTemplateInput(staffList);
  };

  /**
   * é¸æŠã‚¹ã‚¿ãƒƒãƒ•å…¥åŠ›
   */
  const handleSelectedTemplateInput = () => {
    const targetStaff = staffList.filter((s) => selectedStaffIds.includes(s.id));
    handleTemplateInput(targetStaff);
    closeSelectStaff();
    setSelectedStaffIds([]);
  };

  /**
   * ã‚·ãƒ•ãƒˆãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆ
   */
  const weekdayLabelJa = ['æ—¥', 'æœˆ', 'ç«', 'æ°´', 'æœ¨', 'é‡‘', 'åœŸ'];

  /**
   * ã‚·ãƒ•ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã‹ã‚‰ã‚¹ã‚¿ãƒƒãƒ•åã‚’å–å¾—
   * FullCalendar ã‚¤ãƒ™ãƒ³ãƒˆã§ã¯ title ã«ã‚¹ã‚¿ãƒƒãƒ•åãŒè¨­å®šã•ã‚Œã‚‹ãŒã€
   * ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¨ã—ã¦ extendedProps.staffName ã‚‚ç¢ºèªã™ã‚‹
   */
  const getStaffNameFromShift = (shift: CalendarShiftEvent): string => {
    return shift.title ?? shift.extendedProps?.staffName ?? '';
  };

  /**
   * Date ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã«ä¾å­˜ã—ãªã„ YYYY-MM-DD å½¢å¼ã«å¤‰æ›
   * toISOString() ã¯ UTC ã«å¤‰æ›ã•ã‚Œã‚‹ãŸã‚ã€ãƒ­ãƒ¼ã‚«ãƒ«æ—¥ä»˜ã‚’æ­£ã—ãå–å¾—ã™ã‚‹ãŸã‚ã«
   * å¹´æœˆæ—¥ã‚’å€‹åˆ¥ã«å–å¾—ã—ã¦æ–‡å­—åˆ—åŒ–ã™ã‚‹
   */
  const formatDateKey = (date: Date): string => {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  };

  const generateShiftText = (): string => {
    if (!shifts || shifts.length === 0) return '';

    const map = new Map<string, string[]>();

    shifts.forEach((shift) => {
      const start = shift.start;
      if (!start) return;

      const date = new Date(start);
      if (Number.isNaN(date.getTime())) return;

      const dateKey = formatDateKey(date);
      const staffName = getStaffNameFromShift(shift);
      if (!staffName) return;

      const list = map.get(dateKey) ?? [];
      list.push(staffName);
      map.set(dateKey, list);
    });

    const sortedKeys = Array.from(map.keys()).sort();

    const lines = sortedKeys
      .map((dateKey) => {
        const date = new Date(dateKey);
        // ä¸æ­£ãªæ—¥ä»˜ã‚’ã‚¹ã‚­ãƒƒãƒ—
        if (Number.isNaN(date.getTime())) return null;
        const day = date.getDate();
        const weekday = weekdayLabelJa[date.getDay()];
        const staffNames = map.get(dateKey) ?? [];
        return `${day}æ—¥(${weekday}) ${staffNames.join(' ')}`;
      })
      .filter((line): line is string => line !== null);

    return lines.join('\n');
  };

  if (error && !loading) {
    return (
      <Container size="xl">
        <Alert
          icon={<IconAlertCircle size="1rem" />}
          title="ã‚¨ãƒ©ãƒ¼"
          color="red"
          variant="light"
        >
          {error}
        </Alert>
      </Container>
    );
  }

  return (
    <Container size="xl">
      <LoadingOverlay visible={loading} />

      {/* ã‚¹ã‚¿ãƒƒãƒ•ä½œæˆãƒ¢ãƒ¼ãƒ€ãƒ« */}
      <UnifiedModal
        opened={createOpened}
        onClose={closeCreate}
        title="ã‚¹ã‚¿ãƒƒãƒ•è¿½åŠ "
        size="md"
        sections={[
          {
            label: 'åŸºæœ¬æƒ…å ±',
            content: (
              <Stack gap="md">
                <TextInput
                  label="åå‰"
                  placeholder="ç”°ä¸­ å¤ªéƒ"
                  required
                  {...createForm.getInputProps('name')}
                />

                <TextInput
                  label="ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ï¼ˆä»»æ„ï¼‰"
                  placeholder="tanaka@example.com"
                  type="email"
                  {...createForm.getInputProps('email')}
                />

                <TextInput
                  label="å½¹è·"
                  placeholder="ã‚¹ã‚¿ãƒƒãƒ•"
                  {...createForm.getInputProps('role')}
                />

                <ColorInput
                  label="è¡¨ç¤ºã‚«ãƒ©ãƒ¼"
                  placeholder="ã‚«ãƒ©ãƒ¼ã‚’é¸æŠ"
                  format="hex"
                  swatches={[
                    '#4c6ef5',
                    '#f06595',
                    '#20c997',
                    '#fd7e14',
                    '#fab005',
                    '#51cf66',
                    '#4dabf7',
                    '#845ef7',
                    '#ff6b6b',
                    '#74c0fc',
                  ]}
                  {...createForm.getInputProps('color')}
                />
              </Stack>
            ),
          },
          {
            label: 'å‡ºå‹¤è¨­å®š',
            content: (
              <>
                <Checkbox.Group
                  label="å‡ºå‹¤æ›œæ—¥"
                  description="é€šå¸¸å‡ºå‹¤ã™ã‚‹æ›œæ—¥ã‚’é¸æŠã—ã¦ãã ã•ã„"
                  {...createForm.getInputProps('workingDays')}
                >
                  <Group mt="xs">
                    <Checkbox value="mon" label="æœˆ" />
                    <Checkbox value="tue" label="ç«" />
                    <Checkbox value="wed" label="æ°´" />
                    <Checkbox value="thu" label="æœ¨" />
                    <Checkbox value="fri" label="é‡‘" />
                    <Checkbox value="sat" label="åœŸ" />
                    <Checkbox value="sun" label="æ—¥" />
                  </Group>
                </Checkbox.Group>

                <Group grow>
                  <NumberInput
                    label="å‡ºå‹¤é–‹å§‹æ™‚åˆ»ï¼ˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆï¼‰"
                    description="0ã€œ23ã®ç¯„å›²ã§å…¥åŠ›ï¼ˆä¾‹: 9ï¼‰"
                    min={0}
                    max={23}
                    step={1}
                    suffix=" æ™‚"
                    {...createForm.getInputProps('workTimeTemplate.startHour')}
                  />
                  <NumberInput
                    label="å‡ºå‹¤çµ‚äº†æ™‚åˆ»ï¼ˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆï¼‰"
                    description="1ã€œ24ã®ç¯„å›²ã§å…¥åŠ›ï¼ˆä¾‹: 18ï¼‰"
                    min={1}
                    max={24}
                    step={1}
                    suffix=" æ™‚"
                    {...createForm.getInputProps('workTimeTemplate.endHour')}
                  />
                </Group>
              </>
            ),
          },
          {
            content: (
              <Group justify="flex-end">
                <Button
                  variant="subtle"
                  color="gray"
                  onClick={closeCreate}
                  disabled={operationLoading}
                  leftSection={<IconX size={16} />}
                >
                  ã‚­ãƒ£ãƒ³ã‚»ãƒ«
                </Button>
                <Button
                  onClick={() => {
                    createForm.validate();
                    if (createForm.isValid()) {
                      void handleCreateStaff(createForm.values);
                    }
                  }}
                  loading={operationLoading}
                  variant="filled"
                  color="blue"
                  leftSection={<IconDeviceFloppy size={16} />}
                >
                  ä½œæˆ
                </Button>
              </Group>
            ),
          },
        ]}
      />

      {/* ã‚¹ã‚¿ãƒƒãƒ•ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ« */}
      <UnifiedModal
        opened={editOpened}
        onClose={closeEdit}
        title="ã‚¹ã‚¿ãƒƒãƒ•ç·¨é›†"
        size="md"
        sections={[
          {
            label: 'åŸºæœ¬æƒ…å ±',
            content: (
              <Stack gap="md">
                <TextInput
                  label="åå‰"
                  placeholder="ç”°ä¸­ å¤ªéƒ"
                  required
                  {...editForm.getInputProps('name')}
                />

                <TextInput
                  label="ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ï¼ˆä»»æ„ï¼‰"
                  placeholder="tanaka@example.com"
                  type="email"
                  {...editForm.getInputProps('email')}
                />

                <TextInput
                  label="å½¹è·"
                  placeholder="ã‚¹ã‚¿ãƒƒãƒ•"
                  {...editForm.getInputProps('role')}
                />

                <ColorInput
                  label="è¡¨ç¤ºã‚«ãƒ©ãƒ¼"
                  placeholder="ã‚«ãƒ©ãƒ¼ã‚’é¸æŠ"
                  format="hex"
                  swatches={[
                    '#4c6ef5',
                    '#f06595',
                    '#20c997',
                    '#fd7e14',
                    '#fab005',
                    '#51cf66',
                    '#4dabf7',
                    '#845ef7',
                    '#ff6b6b',
                    '#74c0fc',
                  ]}
                  {...editForm.getInputProps('color')}
                />
              </Stack>
            ),
          },
          {
            label: 'å‡ºå‹¤è¨­å®š',
            content: (
              <>
                <Checkbox.Group
                  label="å‡ºå‹¤æ›œæ—¥"
                  description="é€šå¸¸å‡ºå‹¤ã™ã‚‹æ›œæ—¥ã‚’é¸æŠã—ã¦ãã ã•ã„"
                  {...editForm.getInputProps('workingDays')}
                >
                  <Group mt="xs">
                    <Checkbox value="mon" label="æœˆ" />
                    <Checkbox value="tue" label="ç«" />
                    <Checkbox value="wed" label="æ°´" />
                    <Checkbox value="thu" label="æœ¨" />
                    <Checkbox value="fri" label="é‡‘" />
                    <Checkbox value="sat" label="åœŸ" />
                    <Checkbox value="sun" label="æ—¥" />
                  </Group>
                </Checkbox.Group>

                <Group grow>
                  <NumberInput
                    label="å‡ºå‹¤é–‹å§‹æ™‚åˆ»ï¼ˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆï¼‰"
                    description="0ã€œ23ã®ç¯„å›²ã§å…¥åŠ›ï¼ˆä¾‹: 9ï¼‰"
                    min={0}
                    max={23}
                    step={1}
                    suffix=" æ™‚"
                    {...editForm.getInputProps('workTimeTemplate.startHour')}
                  />
                  <NumberInput
                    label="å‡ºå‹¤çµ‚äº†æ™‚åˆ»ï¼ˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆï¼‰"
                    description="1ã€œ24ã®ç¯„å›²ã§å…¥åŠ›ï¼ˆä¾‹: 18ï¼‰"
                    min={1}
                    max={24}
                    step={1}
                    suffix=" æ™‚"
                    {...editForm.getInputProps('workTimeTemplate.endHour')}
                  />
                </Group>
              </>
            ),
          },
          {
            content: (
              <Group justify="flex-end">
                <Button
                  variant="subtle"
                  color="gray"
                  onClick={closeEdit}
                  disabled={operationLoading}
                  leftSection={<IconX size={16} />}
                >
                  ã‚­ãƒ£ãƒ³ã‚»ãƒ«
                </Button>
                <Button
                  onClick={() => {
                    editForm.validate();
                    if (editForm.isValid()) {
                      void handleEditStaff(editForm.values);
                    }
                  }}
                  loading={operationLoading}
                  variant="filled"
                  color="blue"
                  leftSection={<IconDeviceFloppy size={16} />}
                >
                  ä¿å­˜
                </Button>
              </Group>
            ),
          },
        ]}
      />

      {/* ã‚¹ã‚¿ãƒƒãƒ•å‰Šé™¤ç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ« */}
      <UnifiedModal
        opened={deleteOpened}
        onClose={closeDelete}
        title="ã‚¹ã‚¿ãƒƒãƒ•å‰Šé™¤"
        size="sm"
        sections={[
          {
            content: (
              <>
                <Text>{selectedStaff?.name} ã‚’å‰Šé™¤ã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹?</Text>
                <Text size="sm" c="dimmed">
                  ã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚
                </Text>
              </>
            ),
          },
          {
            content: (
              <Group justify="flex-end">
                <Button
                  variant="subtle"
                  color="gray"
                  onClick={closeDelete}
                  disabled={operationLoading}
                  leftSection={<IconX size={16} />}
                >
                  ã‚­ãƒ£ãƒ³ã‚»ãƒ«
                </Button>
                <Button
                  onClick={handleDeleteStaff}
                  loading={operationLoading}
                  variant="filled"
                  color="red"
                  leftSection={<IconTrash size={16} />}
                >
                  å‰Šé™¤
                </Button>
              </Group>
            ),
          },
        ]}
      />

      {/* ã‚¹ã‚¿ãƒƒãƒ•é¸æŠãƒ¢ãƒ¼ãƒ€ãƒ«ï¼ˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå…¥åŠ›ç”¨ï¼‰ */}
      <UnifiedModal
        opened={selectStaffOpened}
        onClose={() => {
          closeSelectStaff();
          setSelectedStaffIds([]);
        }}
        title="ã‚¹ã‚¿ãƒƒãƒ•é¸æŠ"
        size="md"
        sections={[
          {
            content: (
              <>
                <Text size="sm" c="dimmed">
                  ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå…¥åŠ›ã™ã‚‹ã‚¹ã‚¿ãƒƒãƒ•ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚
                  å‡ºå‹¤æ›œæ—¥ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‚¹ã‚¿ãƒƒãƒ•ã®ã¿ãŒå¯¾è±¡ã§ã™ã€‚
                </Text>

                <Checkbox.Group
                  value={selectedStaffIds}
                  onChange={setSelectedStaffIds}
                >
                  <Stack gap="xs">
                    {staffList.map((staff) => {
                      const hasTemplate = staff.workingDays && staff.workingDays.length > 0;
                      const timeLabel = staff.workTimeTemplate
                        ? `${staff.workTimeTemplate.startHour}ã€œ${staff.workTimeTemplate.endHour}`
                        : '';
                      const daysLabel = staff.workingDays
                        ? staff.workingDays.map((d) => {
                            const dayMap: Record<string, string> = {
                              mon: 'æœˆ', tue: 'ç«', wed: 'æ°´', thu: 'æœ¨', fri: 'é‡‘', sat: 'åœŸ', sun: 'æ—¥'
                            };
                            return dayMap[d] ?? d;
                          }).join('ãƒ»')
                        : '';

                      return (
                        <Checkbox
                          key={staff.id}
                          value={staff.id}
                          disabled={!hasTemplate}
                          label={
                            <Group gap="xs">
                              <Box
                                style={{
                                  width: 10,
                                  height: 10,
                                  borderRadius: '50%',
                                  backgroundColor: staff.color,
                                }}
                              />
                              <Text size="sm" fw={500}>
                                {staff.name}
                              </Text>
                              {hasTemplate ? (
                                <Text size="xs" c="dimmed">
                                  ({daysLabel}{timeLabel && ` ${timeLabel}`})
                                </Text>
                              ) : (
                                <Text size="xs" c="red">
                                  â€»æ›œæ—¥æœªè¨­å®š
                                </Text>
                              )}
                            </Group>
                          }
                        />
                      );
                    })}
                  </Stack>
                </Checkbox.Group>
              </>
            ),
          },
          {
            content: (
              <Group justify="space-between">
                <Button
                  variant="subtle"
                  size="xs"
                  onClick={() => {
                    const selectableIds = staffList
                      .filter((s) => s.workingDays && s.workingDays.length > 0)
                      .map((s) => s.id);
                    setSelectedStaffIds(selectableIds);
                  }}
                >
                  å…¨é¸æŠ
                </Button>
                <Group gap="xs">
                  <Button
                    variant="subtle"
                    color="gray"
                    onClick={() => {
                      closeSelectStaff();
                      setSelectedStaffIds([]);
                    }}
                    leftSection={<IconX size={16} />}
                  >
                    ã‚­ãƒ£ãƒ³ã‚»ãƒ«
                  </Button>
                  <Button
                    onClick={handleSelectedTemplateInput}
                    loading={operationLoading}
                    variant="filled"
                    color="blue"
                    leftSection={<IconCalendarEvent size={16} />}
                    disabled={selectedStaffIds.length === 0}
                  >
                    å…¥åŠ›å®Ÿè¡Œ
                  </Button>
                </Group>
              </Group>
            ),
          },
        ]}
      />

      {/* ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„: ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */}
      {/* ãƒ¢ãƒã‚¤ãƒ«: å·¦ã«ã‚¹ã‚¿ãƒƒãƒ•ãƒãƒƒã‚¸ã€å³ã«ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã€ä¸‹ã«ãƒ†ã‚­ã‚¹ãƒˆã‚·ãƒ•ãƒˆ */}
      {/* ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—: å·¦ã«ã‚¹ã‚¿ãƒƒãƒ•ä¸€è¦§ã€å³ã«ãƒ†ã‚­ã‚¹ãƒˆã‚·ãƒ•ãƒˆï¼‹ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ */}
      <Box
        style={{
          display: 'flex',
          flexDirection: 'row',
          gap: isMobile ? 8 : 16,
          height: 'calc(100vh - 200px)',
          minHeight: 400,
        }}
      >
        {/* å·¦ã‚µã‚¤ãƒ‰ãƒãƒ¼: ã‚¹ã‚¿ãƒƒãƒ•ä¸€è¦§ / ãƒ¢ãƒã‚¤ãƒ«ã§ã¯ãƒãƒƒã‚¸ã®ã¿ */}
        {isMobile ? (
          /* ãƒ¢ãƒã‚¤ãƒ«: ãƒãƒƒã‚¸å½¢å¼ã‚¹ã‚¿ãƒƒãƒ•ä¸€è¦§ï¼ˆå…¨è§’3æ–‡å­—å¹…ï¼‰ */
          <ScrollArea
            id="staff-list"
            style={{
              width: 56, // å…¨è§’3æ–‡å­—å¹… + padding
              flexShrink: 0,
            }}
          >
            <Stack gap={6}>
              {staffList.map((staff) => (
                <Tooltip
                  key={staff.id}
                  label={staff.name}
                  position="right"
                  withArrow
                >
                  <Badge
                    className="draggable-staff"
                    data-staff-id={staff.id}
                    data-staff-name={staff.name}
                    data-staff-color={staff.color}
                    color={staff.color}
                    variant="filled"
                    size="lg"
                    radius="sm"
                    style={{
                      cursor: 'grab',
                      width: 48,
                      height: 48,
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      fontSize: 14,
                      fontWeight: 600,
                      padding: 0,
                    }}
                  >
                    {/* åå‰ã®å…ˆé ­3æ–‡å­—ï¼ˆå…¨è§’æ›ç®—ï¼‰ */}
                    {staff.name.slice(0, 3)}
                  </Badge>
                </Tooltip>
              ))}
            </Stack>
          </ScrollArea>
        ) : (
          /* ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—: 1è¡Œå½¢å¼ã‚¹ã‚¿ãƒƒãƒ•ä¸€è¦§ï¼ˆãƒªã‚µã‚¤ã‚ºå¯èƒ½ï¼‰ */
          <Box style={{ display: 'flex', flexShrink: 0 }}>
            <Paper
              withBorder
              p="md"
              style={{
                width: staffListWidth,
                height: '100%',
                display: 'flex',
                flexDirection: 'column',
              }}
            >
              <Group justify="space-between" mb="sm">
                <Text fw={600} size="sm">
                  <IconUser size={16} style={{ marginRight: 4, verticalAlign: 'middle' }} />
                  ã‚¹ã‚¿ãƒƒãƒ•ä¸€è¦§
                </Text>
                <Group gap="xs">
                  <Badge size="sm" variant="light">
                    {staffList.length}äºº
                  </Badge>
                  <Menu shadow="md" width={180} position="bottom-end">
                    <Menu.Target>
                      <Button
                        variant="light"
                        size="xs"
                        rightSection={<IconChevronDown size={14} />}
                        loading={operationLoading}
                      >
                        æ“ä½œ
                      </Button>
                    </Menu.Target>
                    <Menu.Dropdown>
                      <Menu.Item
                        leftSection={<IconPlus size={16} />}
                        onClick={openCreate}
                      >
                        ã‚¹ã‚¿ãƒƒãƒ•è¿½åŠ 
                      </Menu.Item>
                      <Menu.Divider />
                      <Menu.Label>ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå…¥åŠ›</Menu.Label>
                      <Menu.Item
                        leftSection={<IconCalendarPlus size={16} />}
                        onClick={handleBulkTemplateInput}
                        disabled={staffList.length === 0}
                      >
                        å…¨å“¡ä¸€æ‹¬å…¥åŠ›
                      </Menu.Item>
                      <Menu.Item
                        leftSection={<IconUsers size={16} />}
                        onClick={openSelectStaff}
                        disabled={staffList.length === 0}
                      >
                        é¸æŠå…¥åŠ›...
                      </Menu.Item>
                    </Menu.Dropdown>
                  </Menu>
                </Group>
              </Group>

              <ScrollArea style={{ flex: 1 }} id="staff-list">
                <Stack gap={4}>
                  {staffList.map((staff) => {
                    // å‹¤å‹™æ™‚é–“ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’è¡¨ç¤ºç”¨ã«æ•´å½¢
                    const timeLabel = staff.workTimeTemplate
                      ? `${staff.workTimeTemplate.startHour}ã€œ${staff.workTimeTemplate.endHour}`
                      : '';

                    return (
                      <Box
                        key={staff.id}
                        className="draggable-staff"
                        data-staff-id={staff.id}
                        data-staff-name={staff.name}
                        data-staff-color={staff.color}
                        style={{
                          display: 'flex',
                          alignItems: 'center',
                          gap: 8,
                          padding: '6px 8px',
                          borderRadius: 4,
                          border: `2px solid ${staff.color}`,
                          cursor: 'grab',
                          backgroundColor: 'var(--mantine-color-body)',
                          transition: 'all 0.15s',
                          minHeight: 32,
                        }}
                        onMouseEnter={(e) => {
                          e.currentTarget.style.boxShadow = '0 2px 8px rgba(0,0,0,0.12)';
                          e.currentTarget.style.transform = 'translateY(-1px)';
                        }}
                        onMouseLeave={(e) => {
                          e.currentTarget.style.boxShadow = 'none';
                          e.currentTarget.style.transform = 'none';
                        }}
                      >
                        {/* ã‚«ãƒ©ãƒ¼ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ */}
                        <Box
                          style={{
                            width: 8,
                            height: 8,
                            borderRadius: '50%',
                            backgroundColor: staff.color,
                            flexShrink: 0,
                          }}
                        />
                        {/* åå‰ + æ™‚é–“ */}
                        <Text size="sm" fw={500} style={{ flex: 1, whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}>
                          {staff.name}
                          {timeLabel && (
                            <Text component="span" size="xs" c="dimmed" ml={6}>
                              {timeLabel}
                            </Text>
                          )}
                        </Text>
                        {/* CRUDãƒ¡ãƒ‹ãƒ¥ãƒ¼ */}
                        <Menu shadow="md" width={140}>
                          <Menu.Target>
                            <ActionIcon
                              variant="subtle"
                              color="gray"
                              size="xs"
                              onClick={(e) => {
                                e.stopPropagation();
                                e.preventDefault();
                              }}
                              style={{ cursor: 'pointer', flexShrink: 0 }}
                            >
                              <IconDotsVertical size={14} />
                            </ActionIcon>
                          </Menu.Target>
                          <Menu.Dropdown>
                            <Menu.Item
                              leftSection={<IconEdit size={14} />}
                              onClick={(e) => {
                                e.stopPropagation();
                                openEditModal(staff);
                              }}
                            >
                              ç·¨é›†
                            </Menu.Item>
                            <Menu.Item
                              leftSection={<IconTrash size={14} />}
                              color="red"
                              onClick={(e) => {
                                e.stopPropagation();
                                openDeleteModal(staff);
                              }}
                            >
                              å‰Šé™¤
                            </Menu.Item>
                          </Menu.Dropdown>
                        </Menu>
                      </Box>
                    );
                  })}
                </Stack>
              </ScrollArea>
            </Paper>

            {/* æ¨ªå¹…ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ« */}
            <Box
              onMouseDown={handleWidthResizeStart}
              style={{
                width: 8,
                cursor: 'col-resize',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                backgroundColor: isResizingWidth ? 'var(--mantine-color-blue-1)' : 'transparent',
                transition: 'background-color 0.15s',
              }}
              onMouseEnter={(e) => {
                if (!isResizingWidth) {
                  e.currentTarget.style.backgroundColor = 'var(--mantine-color-gray-1)';
                }
              }}
              onMouseLeave={(e) => {
                if (!isResizingWidth) {
                  e.currentTarget.style.backgroundColor = 'transparent';
                }
              }}
            >
              <IconGripVertical size={12} style={{ opacity: 0.5 }} />
            </Box>
          </Box>
        )}

        {/* å³ã‚µã‚¤ãƒ‰: ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã¨ãƒ†ã‚­ã‚¹ãƒˆã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ */}
        <Stack style={{ flex: 1, height: '100%', minWidth: 0 }} gap="md">
          {/* ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ï¼ˆãƒ¢ãƒã‚¤ãƒ«ã§ã¯å…ˆã«è¡¨ç¤ºï¼‰ */}
          <Paper
            withBorder
            p={isMobile ? 'xs' : 'md'}
            style={{
              flex: 1,
              overflow: 'hidden',
              minHeight: 300,
            }}
          >
            <FullCalendar
              ref={calendarRef}
              plugins={[dayGridPlugin, interactionPlugin]}
              initialView="dayGridMonth"
              locale="ja"
              headerToolbar={
                isMobile
                  ? {
                      left: 'prev,next',
                      center: 'title',
                      right: '',
                    }
                  : {
                      left: 'prev,next today',
                      center: 'title',
                      right: 'dayGridMonth,dayGridWeek',
                    }
              }
              buttonText={{
                today: 'ä»Šæ—¥',
                month: 'æœˆ',
                week: 'é€±',
              }}
              height="100%"
              editable={true}
              droppable={true}
              events={shifts}
              eventReceive={handleEventReceive}
              eventClick={handleEventClick}
              eventDrop={handleEventDrop}
              dayCellContent={(arg: DayCellContentArg) => {
                const dayOfWeek = arg.date.getDay();
                let color = 'inherit';
                if (dayOfWeek === 0) color = '#e03131'; // æ—¥æ›œ: èµ¤
                if (dayOfWeek === 6) color = '#1971c2'; // åœŸæ›œ: é’
                return (
                  <span style={{ color, fontWeight: dayOfWeek === 0 || dayOfWeek === 6 ? 600 : 400 }}>
                    {arg.dayNumberText}
                  </span>
                );
              }}
              eventContent={(arg: EventContentArg) => {
                const staffName = arg.event.title;
                const displayName = arg.event.extendedProps?.displayName as string | null;
                const dotColor = arg.event.extendedProps?.staffColor ?? arg.event.backgroundColor ?? '#4dabf7';

                return (
                  <div
                    style={{
                      display: 'flex',
                      alignItems: 'center',
                      gap: 4,
                      padding: '2px 4px',
                      overflow: 'hidden',
                      backgroundColor: 'transparent',
                    }}
                  >
                    <span
                      style={{
                        width: 8,
                        height: 8,
                        borderRadius: '50%',
                        backgroundColor: dotColor,
                        flexShrink: 0,
                      }}
                    />
                    <span
                      style={{
                        fontSize: 12,
                        whiteSpace: 'nowrap',
                        overflow: 'hidden',
                        textOverflow: 'ellipsis',
                        color: '#333',
                      }}
                    >
                      {staffName}
                      {displayName && (
                        <span style={{ marginLeft: 4, color: '#666' }}>{displayName}</span>
                      )}
                    </span>
                  </div>
                );
              }}
              eventDisplay="list-item"
            />
          </Paper>

          {/* ãƒ†ã‚­ã‚¹ãƒˆã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆï¼ˆã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®ä¸‹ã€ãƒªã‚µã‚¤ã‚ºå¯èƒ½ï¼‰ */}
          {!isMobile && (
            <Box
              onMouseDown={handleHeightResizeStart}
              style={{
                height: 6,
                cursor: 'row-resize',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                backgroundColor: isResizingHeight ? 'var(--mantine-color-blue-1)' : 'transparent',
                transition: 'background-color 0.15s',
                borderRadius: 3,
              }}
              onMouseEnter={(e) => {
                if (!isResizingHeight) {
                  e.currentTarget.style.backgroundColor = 'var(--mantine-color-gray-2)';
                }
              }}
              onMouseLeave={(e) => {
                if (!isResizingHeight) {
                  e.currentTarget.style.backgroundColor = 'transparent';
                }
              }}
            >
              <Box style={{ width: 40, height: 3, backgroundColor: 'var(--mantine-color-gray-4)', borderRadius: 2 }} />
            </Box>
          )}
          <Paper 
            withBorder 
            p={isMobile ? 'xs' : 'md'}
            style={!isMobile ? { height: textShiftHeight, flexShrink: 0 } : undefined}
          >
            <Group justify="space-between" align="flex-start" mb="xs">
              {!isMobile && (
                <Text fw={600} size="sm">
                  ãƒ†ã‚­ã‚¹ãƒˆå½¢å¼ã‚·ãƒ•ãƒˆä¸€è¦§
                </Text>
              )}
              <CopyButton value={generateShiftText()} timeout={2000}>
                {({ copied, copy }) => (
                  <Tooltip label={copied ? 'ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ' : 'ã‚³ãƒ”ãƒ¼'}>
                    <Button
                      size="xs"
                      variant="light"
                      color={copied ? 'teal' : 'blue'}
                      onClick={copy}
                      style={isMobile ? { marginLeft: 'auto' } : undefined}
                    >
                      {copied ? 'ã‚³ãƒ”ãƒ¼æ¸ˆã¿' : 'ã‚·ãƒ•ãƒˆã‚’ã‚³ãƒ”ãƒ¼'}
                    </Button>
                  </Tooltip>
                )}
              </CopyButton>
            </Group>
            <Textarea
              value={generateShiftText()}
              readOnly
              autosize
              minRows={isMobile ? 2 : 3}
              maxRows={isMobile ? 5 : 10}
              placeholder="ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã«ç™»éŒ²ã•ã‚ŒãŸã‚·ãƒ•ãƒˆãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™"
              styles={{
                input: {
                  fontSize: isMobile ? 12 : 14,
                },
              }}
            />
          </Paper>
        </Stack>
      </Box>
    </Container>
  );
}
````

## File: frontend/src/app/tenants/_components/ActionMenu.tsx
````typescript
'use client';

import { Menu } from '@mantine/core';
import { IconChevronDown } from '@tabler/icons-react';
import { ActionButton, ActionType } from '@/components/ActionButton';

interface ActionMenuItem {
  id: string;
  label: string;
  icon: React.ReactNode;
  onClick: () => void;
}

interface ActionMenuProps {
  items: ActionMenuItem[];
  buttonLabel?: string;
  /** ã‚¢ã‚¤ã‚³ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆï¼ˆä¾‹: IconPlusï¼‰ã¾ãŸã¯ undefined */
  buttonIcon?: React.ComponentType<{ size?: number | string }>;
  action?: ActionType;
  isSectionAction?: boolean;
}

export function ActionMenu({ 
  items, 
  buttonLabel = 'ã‚¢ã‚¯ã‚·ãƒ§ãƒ³', 
  buttonIcon,
  action = 'view',
  isSectionAction = false // Change default to false, as it's often used in headers
}: ActionMenuProps) {
  if (items.length === 0) return null;

  // ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå‹ã‚’ReactNodeã«å¤‰æ›
  const ButtonIconComponent = buttonIcon;
  const iconElement = ButtonIconComponent ? <ButtonIconComponent size={18} /> : undefined;

  return (
    <Menu shadow="md" width={200} radius="md" position="bottom-end" transitionProps={{ transition: 'pop', duration: 150 }}>
      <Menu.Target>
        <ActionButton 
          action={action}
          rightSection={<IconChevronDown size={16} />}
          customIcon={iconElement}
          isSectionAction={isSectionAction}
        >
          {buttonLabel}
        </ActionButton>
      </Menu.Target>
      <Menu.Dropdown 
        className="glass-effect" 
        style={{ 
          border: '1px solid var(--glass-border)',
          backgroundColor: 'var(--glass-bg, #fff)',
          backdropFilter: 'blur(var(--glass-blur, 0px))',
        }}
      >
        {items.map((item) => (
          <Menu.Item 
            key={item.id} 
            leftSection={item.icon} 
            onClick={item.onClick}
            style={{ 
              fontWeight: 600,
              borderRadius: 'calc(var(--radius-base, 8px) * 0.5)',
            }}
          >
            {item.label}
          </Menu.Item>
        ))}
      </Menu.Dropdown>
    </Menu>
  );
}
````

## File: frontend/src/app/tenants/_components/UserProfileForm.tsx
````typescript
'use client';

import { useState, useEffect } from 'react';
import {
  Stack,
  Card,
  TextInput,
  PasswordInput,
  Group,
  Text,
  Divider,
  Alert,
} from '@mantine/core';
import { IconAlertTriangle } from '@tabler/icons-react';
import { notifications } from '@mantine/notifications';
import { ActionButton } from '@/components/ActionButton';
import { useAuth, useAuthStore } from '@/lib/auth/store';
import { apiClient, apiRequest } from '@/lib/api/client';

interface ProfileFormData {
  displayName: string;
  email: string;
}

interface PasswordFormData {
  currentPassword: string;
  newPassword: string;
  confirmPassword: string;
}

interface ProfileUpdateResponse {
  id: string;
  email: string;
  firstName: string | null;
  lastName: string | null;
  role: string;
}

/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ç·¨é›†ãƒ»ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¤‰æ›´ãƒ•ã‚©ãƒ¼ãƒ 
 * 
 * 2ã¤ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§æ§‹æˆï¼š
 * - ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ç·¨é›†ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒãƒ¼ãƒ ã€ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ï¼‰
 * - ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¤‰æ›´ï¼ˆç¾åœ¨ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã€æ–°ã—ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã€ç¢ºèªï¼‰
 */
export function UserProfileForm() {
  const { user } = useAuth();
  const updateUser = useAuthStore((state) => state.updateUser);

  // ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ãƒ•ã‚©ãƒ¼ãƒ ã®çŠ¶æ…‹
  const [profileData, setProfileData] = useState<ProfileFormData>({
    displayName: '',
    email: '',
  });
  const [originalEmail, setOriginalEmail] = useState<string>('');
  const [profileLoading, setProfileLoading] = useState(false);

  // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒ•ã‚©ãƒ¼ãƒ ã®çŠ¶æ…‹
  const [passwordData, setPasswordData] = useState<PasswordFormData>({
    currentPassword: '',
    newPassword: '',
    confirmPassword: '',
  });
  const [passwordLoading, setPasswordLoading] = useState(false);

  // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒå¤‰æ›´ã•ã‚ŒãŸã‚‰ãƒ•ã‚©ãƒ¼ãƒ ã‚’åˆæœŸåŒ–
  useEffect(() => {
    if (user) {
      setProfileData({
        displayName: user.firstName ?? '',
        email: user.email ?? '',
      });
      setOriginalEmail(user.email ?? '');
    }
  }, [user]);

  // ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒå¤‰æ›´ã•ã‚ŒãŸã‹ã©ã†ã‹
  const isEmailChanged = profileData.email.trim().toLowerCase() !== originalEmail.toLowerCase();

  // ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«æ›´æ–°å‡¦ç†
  const handleProfileSubmit = async () => {
    // ç©ºç™½ãƒã‚§ãƒƒã‚¯ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒãƒ¼ãƒ ã¯ä»»æ„ã ãŒã€ãƒ¡ãƒ¼ãƒ«ã¯å¿…é ˆï¼‰
    if (!profileData.email.trim()) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„',
        color: 'red',
      });
      return;
    }

    try {
      setProfileLoading(true);

      // PATCH /users/me ã§å‘¼ã³å‡ºã—
      // ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯: UIã§ã¯ã€Œãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒãƒ¼ãƒ ã€ã¨ã—ã¦å˜ä¸€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§å…¥åŠ›ã•ã›ã€
      // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã® firstName ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ãƒãƒƒãƒ”ãƒ³ã‚°ã™ã‚‹ã€‚lastName ã¯ä½¿ç”¨ã—ãªã„ï¼ˆç©ºæ–‡å­—åˆ—ï¼‰ã€‚
      // ã“ã‚Œã«ã‚ˆã‚Šæ—¢å­˜ã®ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«ã‚’ç¶­æŒã—ã¤ã¤ã€ã‚·ãƒ³ãƒ—ãƒ«ãªUIä½“é¨“ã‚’æä¾›ã™ã‚‹ã€‚
      const response = await apiRequest<ProfileUpdateResponse>('/users/me', {
        method: 'PATCH',
        body: JSON.stringify({
          firstName: profileData.displayName.trim(),
          lastName: '',
          email: profileData.email.trim(),
        }),
      });

      if (response.success && response.data) {
        // èªè¨¼ã‚¹ãƒˆã‚¢ã‚’æ›´æ–°
        updateUser({
          firstName: response.data.firstName,
          lastName: response.data.lastName,
          email: response.data.email,
        });

        // å…ƒã®ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æ›´æ–°
        setOriginalEmail(response.data.email);

        notifications.show({
          title: 'æˆåŠŸ',
          message: 'ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã‚’æ›´æ–°ã—ã¾ã—ãŸ',
          color: 'green',
        });
      } else {
        const errorMessage =
          response.error ||
          response.message ||
          'ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ';
        notifications.show({
          title: 'ã‚¨ãƒ©ãƒ¼',
          message: errorMessage,
          color: 'red',
        });
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message,
        color: 'red',
      });
    } finally {
      setProfileLoading(false);
    }
  };

  // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¤‰æ›´å‡¦ç†
  const handlePasswordSubmit = async () => {
    // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    if (!passwordData.currentPassword) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: 'ç¾åœ¨ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„',
        color: 'red',
      });
      return;
    }

    if (!passwordData.newPassword) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: 'æ–°ã—ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„',
        color: 'red',
      });
      return;
    }

    if (passwordData.newPassword.length < 8) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: 'æ–°ã—ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯8æ–‡å­—ä»¥ä¸Šã§å…¥åŠ›ã—ã¦ãã ã•ã„',
        color: 'red',
      });
      return;
    }

    if (passwordData.newPassword !== passwordData.confirmPassword) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: 'æ–°ã—ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒä¸€è‡´ã—ã¾ã›ã‚“',
        color: 'red',
      });
      return;
    }

    try {
      setPasswordLoading(true);

      // POST /auth/change-password ã§å‹å®‰å…¨ã«å‘¼ã³å‡ºã—
      const response = await apiClient.post('/auth/change-password', {
        body: {
          currentPassword: passwordData.currentPassword,
          newPassword: passwordData.newPassword,
        },
      });

      if (response.success) {
        notifications.show({
          title: 'æˆåŠŸ',
          message: 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å¤‰æ›´ã—ã¾ã—ãŸ',
          color: 'green',
        });
        // ãƒ•ã‚©ãƒ¼ãƒ ã‚’ãƒªã‚»ãƒƒãƒˆ
        setPasswordData({
          currentPassword: '',
          newPassword: '',
          confirmPassword: '',
        });
      } else {
        const errorMessage =
          response.error ||
          response.message ||
          'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã®å¤‰æ›´ã«å¤±æ•—ã—ã¾ã—ãŸ';
        notifications.show({
          title: 'ã‚¨ãƒ©ãƒ¼',
          message: errorMessage,
          color: 'red',
        });
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message,
        color: 'red',
      });
    } finally {
      setPasswordLoading(false);
    }
  };

  return (
    <Stack gap="lg">
      {/* ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ç·¨é›†ã‚»ã‚¯ã‚·ãƒ§ãƒ³ */}
      <Card shadow="sm" padding="lg" radius="md" withBorder>
        <Stack gap="md">
          <Text fw={600} size="lg">ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ç·¨é›†</Text>
          <Divider />

          <TextInput
            label="ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒãƒ¼ãƒ "
            placeholder="å±±ç”°å¤ªéƒ"
            value={profileData.displayName}
            onChange={(e) => setProfileData({ ...profileData, displayName: e.target.value })}
            disabled={profileLoading}
          />

          <TextInput
            label="ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹"
            placeholder="user@example.com"
            type="email"
            required
            value={profileData.email}
            onChange={(e) => setProfileData({ ...profileData, email: e.target.value })}
            disabled={profileLoading}
          />

          {isEmailChanged && (
            <Alert icon={<IconAlertTriangle size={16} />} color="orange" variant="light">
              ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å¤‰æ›´ã™ã‚‹ã¨ã€æ¬¡å›ãƒ­ã‚°ã‚¤ãƒ³æ™‚ã«æ–°ã—ã„ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒå¿…è¦ã«ãªã‚Šã¾ã™ã€‚
            </Alert>
          )}

          <Group justify="flex-end">
            <ActionButton
              action="save"
              onClick={handleProfileSubmit}
              loading={profileLoading}
              isSectionAction
            >
              ä¿å­˜
            </ActionButton>
          </Group>
        </Stack>
      </Card>

      {/* ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¤‰æ›´ã‚»ã‚¯ã‚·ãƒ§ãƒ³ */}
      <Card shadow="sm" padding="lg" radius="md" withBorder>
        <Stack gap="md">
          <Text fw={600} size="lg">ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¤‰æ›´</Text>
          <Divider />

          <PasswordInput
            label="ç¾åœ¨ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰"
            placeholder="ç¾åœ¨ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›"
            required
            value={passwordData.currentPassword}
            onChange={(e) => setPasswordData({ ...passwordData, currentPassword: e.target.value })}
            disabled={passwordLoading}
          />

          <PasswordInput
            label="æ–°ã—ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰"
            placeholder="8æ–‡å­—ä»¥ä¸Šã§å…¥åŠ›"
            required
            value={passwordData.newPassword}
            onChange={(e) => setPasswordData({ ...passwordData, newPassword: e.target.value })}
            disabled={passwordLoading}
            description="8æ–‡å­—ä»¥ä¸Šã§å…¥åŠ›ã—ã¦ãã ã•ã„"
          />

          <PasswordInput
            label="æ–°ã—ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼ˆç¢ºèªï¼‰"
            placeholder="æ–°ã—ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å†å…¥åŠ›"
            required
            value={passwordData.confirmPassword}
            onChange={(e) => setPasswordData({ ...passwordData, confirmPassword: e.target.value })}
            disabled={passwordLoading}
          />

          <Group justify="flex-end">
            <ActionButton
              action="save"
              onClick={handlePasswordSubmit}
              loading={passwordLoading}
              isSectionAction
            >
              ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å¤‰æ›´
            </ActionButton>
          </Group>
        </Stack>
      </Card>
    </Stack>
  );
}
````

## File: frontend/src/app/tenants/_components/UsersList.tsx
````typescript
'use client';

import { useState, useEffect, useCallback } from 'react';
import { Table, Badge, Text, Card, Loader, Center, Alert, Select, Group } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { IconAlertCircle } from '@tabler/icons-react';
import { ActionButton, ActionIconButton } from '@/components/ActionButton';
import { UnifiedModal } from '@/components/common';
import { apiClient, apiRequest } from '@/lib/api/client';
import { notifications } from '@mantine/notifications';
import { useAuth } from '@/lib/auth/store';

interface User {
  id: string;
  email: string;
  role: string;
  firstName?: string | null;
  lastName?: string | null;
  tenantId: string;
  createdAt: string;
}

interface RoleOption {
  value: string;
  label: string;
}

/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§ãƒ†ãƒ¼ãƒ–ãƒ«
 */
export function UsersList() {
  const { user: currentUser } = useAuth();
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [changingRoleUserId, setChangingRoleUserId] = useState<string | null>(null);

  const isSuperAdmin = currentUser?.role === 'SUPER_ADMIN';
  const isTenantAdmin = currentUser?.role === 'TENANT_ADMIN';

  // å‰Šé™¤ç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ«ã®çŠ¶æ…‹
  const [deleteModalOpened, { open: openDeleteModal, close: closeDeleteModal }] = useDisclosure(false);
  const [deletingUser, setDeletingUser] = useState<User | null>(null);
  const [deleteLoading, setDeleteLoading] = useState(false);

  // ãƒ­ãƒ¼ãƒ«è¡¨ç¤ºåå¤‰æ›
  const getRoleLabel = (role: string): string => {
    const mapping: Record<string, string> = {
      SUPER_ADMIN: 'ã‚¹ãƒ¼ãƒ‘ãƒ¼ç®¡ç†è€…',
      TENANT_ADMIN: 'ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†è€…',
      ADMIN: 'ç®¡ç†è€…',
      USER: 'ä¸€èˆ¬ãƒ¦ãƒ¼ã‚¶ãƒ¼',
    };
    return mapping[role] || role;
  };

  // ãƒ­ãƒ¼ãƒ«è‰²
  const getRoleColor = (role: string): string => {
    const mapping: Record<string, string> = {
      SUPER_ADMIN: 'red',
      TENANT_ADMIN: 'blue',
      ADMIN: 'yellow',
      USER: 'gray',
    };
    return mapping[role] || 'gray';
  };

  /**
   * ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ­ãƒ¼ãƒ«å¤‰æ›´å¯èƒ½ãªé¸æŠè‚¢ã‚’è¿”ã™
   * å¤‰æ›´ä¸å¯ã®å ´åˆã¯ null ã‚’è¿”ã™
   */
  const getRoleOptions = useCallback((targetUser: User): RoleOption[] | null => {
    // è‡ªåˆ†è‡ªèº«ã¯å¤‰æ›´ä¸å¯
    if (targetUser.id === currentUser?.id) return null;

    if (isSuperAdmin) {
      // SUPER_ADMIN ã¯ä»–ã® SUPER_ADMIN ã®ãƒ­ãƒ¼ãƒ«ã¯å¤‰æ›´ä¸å¯
      if (targetUser.role === 'SUPER_ADMIN') return null;
      // ADMIN â†” USER, TENANT_ADMIN ã¸ã®å¤‰æ›´ã‚’è¨±å¯
      return [
        { value: 'USER', label: 'ä¸€èˆ¬ãƒ¦ãƒ¼ã‚¶ãƒ¼' },
        { value: 'ADMIN', label: 'ç®¡ç†è€…' },
        { value: 'TENANT_ADMIN', label: 'ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†è€…' },
      ];
    }

    if (isTenantAdmin) {
      // TENANT_ADMIN ã¯ SUPER_ADMIN ã¨ TENANT_ADMIN ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯å¤‰æ›´ä¸å¯
      if (targetUser.role === 'SUPER_ADMIN' || targetUser.role === 'TENANT_ADMIN') return null;
      // è‡ªãƒ†ãƒŠãƒ³ãƒˆã® ADMIN â†” USER ã®ã¿å¤‰æ›´å¯èƒ½
      return [
        { value: 'USER', label: 'ä¸€èˆ¬ãƒ¦ãƒ¼ã‚¶ãƒ¼' },
        { value: 'ADMIN', label: 'ç®¡ç†è€…' },
      ];
    }

    return null;
  }, [currentUser?.id, isSuperAdmin, isTenantAdmin]);

  /**
   * ãƒ­ãƒ¼ãƒ«å¤‰æ›´ API å‘¼ã³å‡ºã—
   */
  const handleRoleChange = async (userId: string, newRole: string): Promise<void> => {
    setChangingRoleUserId(userId);
    try {
      const response = await apiClient.request(`/users/${userId}/role` as never, 'patch', {
        body: { role: newRole } as never,
      });

      if (response.success) {
        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§ã® state ã‚’æ›´æ–°
        setUsers((prev) =>
          prev.map((u) => (u.id === userId ? { ...u, role: newRole } : u))
        );
        notifications.show({
          title: 'æˆåŠŸ',
          message: 'ãƒ­ãƒ¼ãƒ«ã‚’å¤‰æ›´ã—ã¾ã—ãŸ',
          color: 'green',
        });
      } else {
        throw new Error(response.error || 'ãƒ­ãƒ¼ãƒ«ã®å¤‰æ›´ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message,
        color: 'red',
      });
    } finally {
      setChangingRoleUserId(null);
    }
  };

  // ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§å–å¾—
  const fetchUsers = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      // è‡ªåˆ†ã®ãƒ†ãƒŠãƒ³ãƒˆå†…ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å–å¾—
      const response = await apiClient.request('/users' as never, 'get');

      if (response.success && Array.isArray(response.data)) {
        setUsers(response.data as User[]);
      } else {
        throw new Error(response.error || 'ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';
      setError(message);
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message,
        color: 'red',
      });
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchUsers();
  }, [fetchUsers]);

  /**
   * å¯¾è±¡ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å‰Šé™¤å¯èƒ½ã‹ã©ã†ã‹ã‚’åˆ¤å®š
   */
  const canDeleteUser = useCallback((targetUser: User): boolean => {
    // è‡ªåˆ†è‡ªèº«ã¯å‰Šé™¤ä¸å¯
    if (targetUser.id === currentUser?.id) return false;

    if (isSuperAdmin) {
      // SUPER_ADMIN ã¯ä»–ã® SUPER_ADMIN ã¯å‰Šé™¤ä¸å¯
      if (targetUser.role === 'SUPER_ADMIN') return false;
      return true;
    }

    if (isTenantAdmin) {
      // TENANT_ADMIN ã¯ SUPER_ADMIN ã¨ TENANT_ADMIN ã¯å‰Šé™¤ä¸å¯
      if (targetUser.role === 'SUPER_ADMIN' || targetUser.role === 'TENANT_ADMIN') return false;
      return true;
    }

    return false;
  }, [currentUser?.id, isSuperAdmin, isTenantAdmin]);

  // å‰Šé™¤ãƒœã‚¿ãƒ³ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸã¨ãã®ãƒãƒ³ãƒ‰ãƒ©
  const handleDeleteClick = (user: User) => {
    setDeletingUser(user);
    openDeleteModal();
  };

  // å‰Šé™¤ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‰ã˜ã‚‹
  const handleDeleteModalClose = () => {
    if (!deleteLoading) {
      setDeletingUser(null);
      closeDeleteModal();
    }
  };

  // ãƒ¦ãƒ¼ã‚¶ãƒ¼å‰Šé™¤å‡¦ç†
  const handleDeleteUser = async () => {
    if (!deletingUser) return;

    try {
      setDeleteLoading(true);

      const response = await apiRequest(`/users/${deletingUser.id}`, {
        method: 'DELETE',
      });

      if (response.success) {
        notifications.show({
          title: 'æˆåŠŸ',
          message: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
          color: 'green',
        });
        handleDeleteModalClose();
        // ä¸€è¦§ã‚’å†å–å¾—
        fetchUsers();
      } else {
        const errorMessage =
          response.error ||
          response.message ||
          'ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ';
        notifications.show({
          title: 'ã‚¨ãƒ©ãƒ¼',
          message: errorMessage,
          color: 'red',
        });
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message,
        color: 'red',
      });
    } finally {
      setDeleteLoading(false);
    }
  };

  if (loading) {
    return (
      <Center h={200}>
        <Loader size="lg" />
      </Center>
    );
  }

  if (error) {
    return (
      <Alert icon={<IconAlertCircle size={16} />} title="ã‚¨ãƒ©ãƒ¼" color="red">
        {error}
      </Alert>
    );
  }

  if (users.length === 0) {
    return (
      <Card withBorder p="xl">
        <Center>
          <Text c="dimmed">ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã„ã¾ã›ã‚“</Text>
        </Center>
      </Card>
    );
  }

  // ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒ SUPER_ADMIN ã¾ãŸã¯ TENANT_ADMIN ã®å ´åˆã€æ“ä½œåˆ—ã‚’è¡¨ç¤º
  const showActionsColumn = isSuperAdmin || isTenantAdmin;

  return (
    <Card withBorder>
      <Table striped highlightOnHover>
        <Table.Thead>
          <Table.Tr>
            <Table.Th>ãƒ¦ãƒ¼ã‚¶ãƒ¼å</Table.Th>
            <Table.Th>ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹</Table.Th>
            <Table.Th>ãƒ­ãƒ¼ãƒ«</Table.Th>
            <Table.Th>ç™»éŒ²æ—¥</Table.Th>
            {showActionsColumn && <Table.Th>æ“ä½œ</Table.Th>}
          </Table.Tr>
        </Table.Thead>
        <Table.Tbody>
          {users.map((u) => {
            const displayName = [u.lastName, u.firstName].filter(Boolean).join(' ') || 'æœªè¨­å®š';
            const roleOptions = getRoleOptions(u);
            const isChangingRole = changingRoleUserId === u.id;
            
            return (
              <Table.Tr key={u.id}>
                <Table.Td>
                  <Text fw={600}>{displayName}</Text>
                </Table.Td>
                <Table.Td>
                  <Text size="sm" c="dimmed">
                    {u.email}
                  </Text>
                </Table.Td>
                <Table.Td>
                  <Badge color={getRoleColor(u.role)} variant="light">
                    {getRoleLabel(u.role)}
                  </Badge>
                </Table.Td>
                <Table.Td>
                  <Text size="sm">
                    {new Date(u.createdAt).toLocaleDateString('ja-JP')}
                  </Text>
                </Table.Td>
                {showActionsColumn && (
                  <Table.Td>
                    <Group gap="xs" wrap="nowrap">
                      {roleOptions ? (
                        <Select
                          size="xs"
                          w={140}
                          placeholder="ãƒ­ãƒ¼ãƒ«å¤‰æ›´"
                          data={roleOptions}
                          value={u.role}
                          onChange={(value) => {
                            if (value && value !== u.role) {
                              void handleRoleChange(u.id, value);
                            }
                          }}
                          disabled={isChangingRole}
                          rightSection={isChangingRole ? <Loader size="xs" /> : undefined}
                          aria-label={`${displayName}ã®ãƒ­ãƒ¼ãƒ«ã‚’å¤‰æ›´`}
                        />
                      ) : (
                        <Text size="sm" c="dimmed" w={140}>
                          -
                        </Text>
                      )}
                      {canDeleteUser(u) && (
                        <ActionIconButton
                          action="delete"
                          onClick={() => handleDeleteClick(u)}
                          title="å‰Šé™¤"
                        />
                      )}
                    </Group>
                  </Table.Td>
                )}
              </Table.Tr>
            );
          })}
        </Table.Tbody>
      </Table>

      {/* ãƒ¦ãƒ¼ã‚¶ãƒ¼å‰Šé™¤ç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ« */}
      <UnifiedModal
        opened={deleteModalOpened}
        onClose={handleDeleteModalClose}
        title="ãƒ¦ãƒ¼ã‚¶ãƒ¼å‰Šé™¤ã®ç¢ºèª"
        size="md"
      >
        <Text>
          ä»¥ä¸‹ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚
        </Text>
        <Text fw={600} size="lg">
          {deletingUser?.firstName || deletingUser?.lastName
            ? [deletingUser?.lastName, deletingUser?.firstName].filter(Boolean).join(' ')
            : deletingUser?.email}
        </Text>
        <Text size="sm" c="dimmed">
          ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹: {deletingUser?.email}
        </Text>
        <Group justify="flex-end" mt="md">
          <ActionButton action="cancel" onClick={handleDeleteModalClose} disabled={deleteLoading}>
            ã‚­ãƒ£ãƒ³ã‚»ãƒ«
          </ActionButton>
          <ActionButton action="delete" onClick={handleDeleteUser} loading={deleteLoading}>
            å‰Šé™¤
          </ActionButton>
        </Group>
      </UnifiedModal>
    </Card>
  );
}
````

## File: frontend/src/app/page.tsx
````typescript
'use client';

import { useState, useEffect, useMemo } from 'react';
import { useRouter } from 'next/navigation';
import {
  Container,
  Title,
  Text,
  Card,
  Group,
  Stack,
  SimpleGrid,
  Loader,
  Center,
  Alert,
  ThemeIcon,
  Box,
  Badge,
} from '@mantine/core';
import { useMediaQuery, useDisclosure } from '@mantine/hooks';
import {
  IconHeart,
  IconCertificate,
  IconPlus,
  IconStethoscope,
  IconChevronRight,
  IconAlertCircle,
  IconSettings,
  IconList,
  IconBabyCarriage,
  IconTag,
  IconCalendarTime,
  IconUsers,
  IconPhoto,
  IconPalette,
  IconPaw,
  IconCalendarEvent,
} from '@tabler/icons-react';
import { usePageHeader } from '@/lib/contexts/page-header-context';
import { notifications } from '@mantine/notifications';
import { apiClient, type ApiQueryParams } from '@/lib/api/client';
import { useAuth } from '@/lib/auth/store';
import {
  DashboardCardSettings,
  DashboardCardConfig,
} from '@/components/dashboard/DashboardCardSettings';
import { DialNavigation, type DialItem, type EditableDialItem } from '@/components/dashboard/DialNavigation';
import { DialMenuSettings, type DialMenuItemConfig } from '@/components/dashboard/DialMenuSettings';
import {
  loadDashboardSettings,
  saveDashboardSettings,
  applyDashboardSettings,
  loadDialMenuSettings,
  saveDialMenuSettings,
  applyDialMenuSettings,
  loadDialSizePreset,
  saveDialSizePreset,
  loadHomeDisplayMode,
  saveHomeDisplayMode,
  type DialSizePreset,
  type HomeDisplayMode,
} from '@/lib/storage/dashboard-settings';
import { DisplayModeToggle } from '@/components/dashboard/DisplayModeToggle';

// çŒ«ã®ãƒ‡ãƒ¼ã‚¿å‹
interface Cat {
  id: string;
  name: string;
  breed: string;
  gender: 'ã‚ªã‚¹' | 'ãƒ¡ã‚¹';
  color: string;
  birthDate: string;
  bodyType: string;
  pedigreeId: string;
  tags: string[];
  status: string;
}

// ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«å‹(ç°¡æ˜“ç‰ˆ)
interface CareScheduleSummary {
  total: number;
  completed: number;
  pending: number;
}

// äº¤é…äºˆå®šå‹(ç°¡æ˜“ç‰ˆ)
interface BreedingSummary {
  total: number;
  today: number;
}

type CareSchedule = {
  status?: string | null;
};

type BreedingSchedule = {
  breedingDate?: string | null;
  date?: string | null;
};

export default function Home() {
  const [cats, setCats] = useState<Cat[]>([]);
  const [careSummary, setCareSummary] = useState<CareScheduleSummary>({ total: 0, completed: 0, pending: 0 });
  const [breedingSummary, setBreedingSummary] = useState<BreedingSummary>({ total: 0, today: 0 });
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [dashboardCards, setDashboardCards] = useState<DashboardCardConfig[]>([]);
  const [dialMenuItems, setDialMenuItems] = useState<DialMenuItemConfig[]>([]);
  const [dialSizePreset, setDialSizePreset] = useState<DialSizePreset>('medium');
  const [displayMode, setDisplayMode] = useState<HomeDisplayMode>('auto');
  const [settingsOpened, { open: openSettings, close: closeSettings }] = useDisclosure(false);
  const [dialSettingsOpened, { open: openDialSettings, close: closeDialSettings }] = useDisclosure(false);
  const router = useRouter();
  const { setPageTitle } = usePageHeader();
  const { isAuthenticated, initialized, accessToken } = useAuth();

  // ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ‡ã‚¶ã‚¤ãƒ³: ãƒ¢ãƒã‚¤ãƒ«ç¸¦å‘ãåˆ¤å®š
  const isMobilePortrait = useMediaQuery('(max-width: 768px) and (orientation: portrait)');

  // ãƒšãƒ¼ã‚¸ã‚¿ã‚¤ãƒˆãƒ«ã‚’è¨­å®š
  useEffect(() => {
    setPageTitle('ãƒ›ãƒ¼ãƒ ');
    return () => setPageTitle(null);
  }, [setPageTitle]);

  // èªè¨¼ãƒã‚§ãƒƒã‚¯
  useEffect(() => {
    console.log('ğŸ” èªè¨¼çŠ¶æ…‹:', { isAuthenticated, initialized, hasToken: !!accessToken });
    if (initialized && !isAuthenticated) {
      console.warn('âš ï¸ æœªèªè¨¼ã§ã™ã€‚ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã—ã¾ã™');
      router.push('/login');
    }
  }, [initialized, isAuthenticated, router, accessToken]);

  // ãƒ‡ãƒ¼ã‚¿å–å¾—
  useEffect(() => {
    const fetchData = async () => {
      if (!isAuthenticated || !initialized) {
        console.log('â³ èªè¨¼åˆæœŸåŒ–ã‚’å¾…æ©Ÿä¸­...');
        setLoading(false);
        return;
      }

      setLoading(true);
      setError(null);
      
      try {
        console.log('ğŸ“¡ APIå‘¼ã³å‡ºã—é–‹å§‹...');
        
        // çŒ«ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        const catListQuery: ApiQueryParams<'/cats', 'get'> = { limit: 1000 };
        const catsResponse = await apiClient.get('/cats', {
          query: catListQuery,
        });
        
        console.log('ğŸ± çŒ«ãƒ‡ãƒ¼ã‚¿ãƒ¬ã‚¹ãƒãƒ³ã‚¹:', catsResponse);
        
        if (!catsResponse.success) {
          console.error('âŒ çŒ«ãƒ‡ãƒ¼ã‚¿å–å¾—å¤±æ•—:', catsResponse);
          throw new Error(catsResponse.error || 'çŒ«ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
        }
        
        const fetchedCats = Array.isArray(catsResponse.data) ? catsResponse.data : [];
        console.log(`âœ… çŒ«ãƒ‡ãƒ¼ã‚¿å–å¾—æˆåŠŸ: ${fetchedCats.length}ä»¶`);
        setCats(fetchedCats as Cat[]);

        // ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚µãƒãƒªãƒ¼ã‚’å–å¾—
        try {
          const careResponse = await apiClient.get('/care/schedules');
          if (careResponse.success && Array.isArray(careResponse.data)) {
            const schedules = careResponse.data as CareSchedule[];
            setCareSummary({
              total: schedules.length,
              completed: schedules.filter((schedule) => schedule.status === 'completed').length,
              pending: schedules.filter((schedule) => schedule.status !== 'completed').length,
            });
          }
        } catch (careError) {
          console.warn('âš ï¸ ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ:', careError);
        }

        // äº¤é…äºˆå®šã®ã‚µãƒãƒªãƒ¼ã‚’å–å¾—
        try {
          const breedingResponse = await apiClient.get('/breeding');
          if (breedingResponse.success && Array.isArray(breedingResponse.data)) {
            const schedules = breedingResponse.data as BreedingSchedule[];
            const today = new Date().toISOString().split('T')[0];
            setBreedingSummary({
              total: schedules.length,
              today: schedules.filter((schedule) => schedule.breedingDate?.startsWith(today) || schedule.date?.startsWith(today)).length,
            });
          }
        } catch (breedingError) {
          console.warn('âš ï¸ äº¤é…äºˆå®šã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ:', breedingError);
        }
        
      } catch (err) {
        console.error('âŒ ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼:', err);
        setError(err instanceof Error ? err.message : 'ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
        notifications.show({
          title: 'ã‚¨ãƒ©ãƒ¼',
          message: 'ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ',
          color: 'red',
        });
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [isAuthenticated, initialized]);

  // LocalStorageã‹ã‚‰è¨­å®šã‚’èª­ã¿è¾¼ã‚“ã§ã‚«ãƒ¼ãƒ‰è¨­å®šã‚’åˆæœŸåŒ–
  useEffect(() => {
    if (typeof window === 'undefined') return;
    
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã‚«ãƒ¼ãƒ‰å®šç¾©ï¼ˆã‚µã‚¤ãƒ‰ãƒãƒ¼ã®é …ç›®ã¨åŒã˜é †åºï¼‰
    const defaultDashboardCards: Omit<DashboardCardConfig, 'visible' | 'order'>[] = [
      {
        id: 'new-cat',
        title: 'æ–°è¦çŒ«ç™»éŒ²',
        description: 'æ–°ã—ã„çŒ«ã‚’ç™»éŒ²ã™ã‚‹',
        icon: <IconPaw size={32} />,
        color: 'green',
        href: '/cats/new',
      },
      {
        id: 'cats',
        title: 'åœ¨èˆçŒ«ä¸€è¦§',
        description: 'åœ¨èˆçŒ«ã®ä¸€è¦§ãƒ»ç™»éŒ²ãƒ»ç·¨é›†',
        icon: <IconList size={32} />,
        color: 'blue',
        href: '/cats',
        badge: cats.length,
        stats: `å…¨${cats.length}é ­`,
      },
      {
        id: 'breeding',
        title: 'äº¤é…ç®¡ç†',
        description: 'äº¤é…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨è¨˜éŒ²',
        icon: <IconHeart size={32} />,
        color: 'pink',
        href: '/breeding',
        badge: breedingSummary.today > 0 ? breedingSummary.today : undefined,
        stats: breedingSummary.today > 0 ? `ä»Šæ—¥${breedingSummary.today}ä»¶` : `å…¨${breedingSummary.total}ä»¶`,
      },
      {
        id: 'kittens',
        title: 'å­çŒ«ç®¡ç†',
        description: 'å­çŒ«ã®æˆé•·è¨˜éŒ²ã¨ç®¡ç†',
        icon: <IconBabyCarriage size={32} />,
        color: 'cyan',
        href: '/kittens',
      },
      {
        id: 'care',
        title: 'ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«',
        description: 'æ—¥ã€…ã®ã‚±ã‚¢ã¨ã‚¿ã‚¹ã‚¯ç®¡ç†',
        icon: <IconCalendarEvent size={32} />,
        color: 'teal',
        href: '/care',
        badge: careSummary.pending > 0 ? careSummary.pending : undefined,
        stats: careSummary.pending > 0 ? `æœªå®Œäº†${careSummary.pending}ä»¶` : 'å®Œäº†æ¸ˆã¿',
      },
      {
        id: 'medical-records',
        title: 'åŒ»ç™‚ãƒ‡ãƒ¼ã‚¿',
        description: 'åŒ»ç™‚è¨˜éŒ²ã®é–²è¦§ãƒ»ç®¡ç†',
        icon: <IconStethoscope size={32} />,
        color: 'red',
        href: '/medical-records',
      },
      {
        id: 'tags',
        title: 'ã‚¿ã‚°ç®¡ç†',
        description: 'ã‚¿ã‚°ã®ä½œæˆã¨ç®¡ç†',
        icon: <IconTag size={32} />,
        color: 'yellow',
        href: '/tags',
      },
      {
        id: 'pedigrees',
        title: 'è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿',
        description: 'è¡€çµ±æƒ…å ±ã®é–²è¦§ãƒ»ç®¡ç†',
        icon: <IconCertificate size={32} />,
        color: 'violet',
        href: '/pedigrees',
      },
      {
        id: 'staff-shifts',
        title: 'ã‚¹ã‚¿ãƒƒãƒ•ã‚·ãƒ•ãƒˆ',
        description: 'ã‚·ãƒ•ãƒˆç®¡ç†ã¨ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«',
        icon: <IconCalendarTime size={32} />,
        color: 'indigo',
        href: '/staff/shifts',
      },
      {
        id: 'tenants',
        title: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®š',
        description: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã¨æ¨©é™ã®ç®¡ç†',
        icon: <IconUsers size={32} />,
        color: 'purple',
        href: '/tenants',
      },
      {
        id: 'more',
        title: 'ãã®ä»–',
        description: 'è¿½åŠ ã®è¨­å®šã¨æ©Ÿèƒ½',
        icon: <IconSettings size={32} />,
        color: 'gray',
        href: '/more',
      },
      {
        id: 'gallery',
        title: 'ã‚®ãƒ£ãƒ©ãƒªãƒ¼',
        description: 'çŒ«ã®å†™çœŸã‚®ãƒ£ãƒ©ãƒªãƒ¼',
        icon: <IconPhoto size={32} />,
        color: 'orange',
        href: '/gallery',
      },
      {
        id: 'demo',
        title: 'ãƒ‡ã‚¶ã‚¤ãƒ³ã‚¬ã‚¤ãƒ‰',
        description: 'UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ãƒ‡ãƒ¢',
        icon: <IconPalette size={32} />,
        color: 'grape',
        href: '/demo/action-buttons',
      },
    ];
    
    const settings = loadDashboardSettings();
    const cardsWithDefaults = defaultDashboardCards.map((card, index) => ({
      ...card,
      visible: index < 8, // æœ€åˆã®8é …ç›®ã®ã¿ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§è¡¨ç¤º
      order: index,
    }));
    
    const appliedCards = applyDashboardSettings(cardsWithDefaults, settings);
    setDashboardCards(appliedCards);

    // ãƒ€ã‚¤ã‚¢ãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›®ã®åˆæœŸåŒ–ï¼ˆãƒ¢ãƒã‚¤ãƒ«ç”¨ï¼‰
    // è‰²å¤‰æ›é–¢æ•°
    const colorToHex = (color: string): string => {
      const colorMap: Record<string, string> = {
        green: '#22C55E',
        blue: '#2563EB',
        pink: '#EC4899',
        cyan: '#06B6D4',
        teal: '#14B8A6',
        yellow: '#EAB308',
        violet: '#8B5CF6',
        indigo: '#6366F1',
        purple: '#A855F7',
        gray: '#6B7280',
        orange: '#F97316',
        red: '#EF4444',
        grape: '#9333EA',
        lime: '#84CC16',
      };
      return colorMap[color] || '#2563EB';
    };

    const dialItems: Omit<DialMenuItemConfig, 'visible' | 'order'>[] = defaultDashboardCards.map((card) => ({
      id: card.id,
      title: card.title,
      icon: card.icon,
      color: colorToHex(card.color),
      href: card.href,
      badge: card.badge,
      subActions: card.id === 'cats' ? [
        { id: 'cats-new', title: 'ä½œæˆ', icon: <IconPlus size={18} />, href: '/cats/new' },
        { id: 'cats-list', title: 'ä¸€è¦§', icon: <IconList size={18} />, href: '/cats' },
      ] : card.id === 'breeding' ? [
        { id: 'breeding-list', title: 'ä¸€è¦§', icon: <IconList size={18} />, href: '/breeding' },
        { id: 'breeding-schedule', title: 'ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«', icon: <IconCalendarTime size={18} />, href: '/breeding' },
      ] : card.id === 'care' ? [
        { id: 'care-schedule', title: 'ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«', icon: <IconCalendarTime size={18} />, href: '/care' },
        { id: 'care-medical', title: 'åŒ»ç™‚è¨˜éŒ²', icon: <IconStethoscope size={18} />, href: '/care' },
      ] : card.id === 'kittens' ? [
        { id: 'kittens-list', title: 'ä¸€è¦§', icon: <IconList size={18} />, href: '/kittens' },
        { id: 'kittens-new', title: 'ä½œæˆ', icon: <IconPlus size={18} />, href: '/kittens/new' },
      ] : card.id === 'pedigrees' ? [
        { id: 'pedigrees-list', title: 'ä¸€è¦§', icon: <IconList size={18} />, href: '/pedigrees' },
        { id: 'pedigrees-new', title: 'ä½œæˆ', icon: <IconPlus size={18} />, href: '/pedigrees/new' },
      ] : card.id === 'medical-records' ? [
        { id: 'medical-list', title: 'ä¸€è¦§', icon: <IconList size={18} />, href: '/medical-records' },
        { id: 'medical-new', title: 'ä½œæˆ', icon: <IconPlus size={18} />, href: '/medical-records/new' },
      ] : undefined,
    }));

    const dialSettings = loadDialMenuSettings();
    // ãƒ€ã‚¤ã‚¢ãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®åˆæœŸè¨­å®šï¼ˆæœ€åˆã®8é …ç›®ã®ã¿è¡¨ç¤ºï¼‰
    const dialItemsWithDefaults = dialItems.map((item, index) => ({
      ...item,
      visible: index < 8,
      order: index,
    }));
    const appliedDialItems = applyDialMenuSettings(dialItemsWithDefaults, dialSettings);
    setDialMenuItems(appliedDialItems);

    // ãƒ€ã‚¤ã‚¢ãƒ«ã‚µã‚¤ã‚ºãƒ—ãƒªã‚»ãƒƒãƒˆã‚’èª­ã¿è¾¼ã¿
    const savedSizePreset = loadDialSizePreset();
    setDialSizePreset(savedSizePreset);

    // è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ã‚’èª­ã¿è¾¼ã¿
    const savedDisplayMode = loadHomeDisplayMode();
    setDisplayMode(savedDisplayMode);
  }, [cats.length, careSummary.pending, breedingSummary.today, breedingSummary.total]);

  // ã‚«ãƒ¼ãƒ‰è¨­å®šä¿å­˜ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handleSaveCardSettings = (cards: DashboardCardConfig[]) => {
    setDashboardCards(cards);
    saveDashboardSettings(cards);
    notifications.show({
      title: 'ä¿å­˜å®Œäº†',
      message: 'ãƒ›ãƒ¼ãƒ ç”»é¢ã®è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸ',
      color: 'green',
    });
  };

  // ãƒ€ã‚¤ã‚¢ãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼è¨­å®šä¿å­˜ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handleSaveDialMenuSettings = (items: DialMenuItemConfig[]) => {
    setDialMenuItems(items);
    saveDialMenuSettings(items);
    notifications.show({
      title: 'ä¿å­˜å®Œäº†',
      message: 'ãƒ€ã‚¤ã‚¢ãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸ',
      color: 'green',
    });
  };

  // ãƒ€ã‚¤ã‚¢ãƒ«ã‚µã‚¤ã‚ºãƒ—ãƒªã‚»ãƒƒãƒˆå¤‰æ›´ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handleDialSizePresetChange = (preset: DialSizePreset) => {
    setDialSizePreset(preset);
    saveDialSizePreset(preset);
  };

  // è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰å¤‰æ›´ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handleDisplayModeChange = (mode: HomeDisplayMode) => {
    setDisplayMode(mode);
    saveHomeDisplayMode(mode);
    
    // ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆæ™‚ã«å¯¾å¿œã™ã‚‹è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
    if (mode === 'card') {
      openSettings();
    } else if (mode === 'dial') {
      openDialSettings();
    }
  };

  // è¨­å®šãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯æ™‚ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handleSettingsClick = () => {
    // ç¾åœ¨ã®è¡¨ç¤ºçŠ¶æ…‹ã«å¿œã˜ã¦é©åˆ‡ãªè¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
    if (shouldShowDial) {
      openDialSettings();
    } else {
      openSettings();
    }
  };

  // è¡¨ç¤ºã™ã‚‹ã‚«ãƒ¼ãƒ‰ã®ã¿ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
  const visibleCards = dashboardCards.filter((card) => card.visible);

  // è¡¨ç¤ºã™ã‚‹ãƒ€ã‚¤ã‚¢ãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›®ã®ã¿ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
  const visibleDialItems = dialMenuItems.filter((item) => item.visible);

  // å®Ÿéš›ã«è¡¨ç¤ºã™ã‚‹ãƒ¢ãƒ¼ãƒ‰ã‚’æ±ºå®šï¼ˆãƒ¡ãƒ¢åŒ–ã—ã¦é‡è¤‡ã‚’é¿ã‘ã‚‹ï¼‰
  const shouldShowDial = useMemo(() => {
    return displayMode === 'dial' || (displayMode === 'auto' && isMobilePortrait);
  }, [displayMode, isMobilePortrait]);

  // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ä¸­ã®è¡¨ç¤º
  if (loading) {
    return (
      <Container size="xl" style={{ paddingTop: '4rem' }}>
        <Center style={{ minHeight: '60vh' }}>
          <Stack align="center" gap="md">
            <Loader size="lg" />
            <Text size="sm" c="dimmed">ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™...</Text>
          </Stack>
        </Center>
      </Container>
    );
  }

  // ã‚¨ãƒ©ãƒ¼æ™‚ã®è¡¨ç¤º
  if (error) {
    return (
      <Container size="xl" style={{ paddingTop: '4rem' }}>
        <Alert
          icon={<IconAlertCircle size="1rem" />}
          title="ã‚¨ãƒ©ãƒ¼"
          color="red"
          variant="light"
        >
          {error}
        </Alert>
      </Container>
    );
  }

  // ä»Šæ—¥ã®æ—¥ä»˜
  const today = new Date().toLocaleDateString('ja-JP', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    weekday: 'long'
  });

  return (
    <Container size="xl" style={{ paddingTop: '2rem', paddingBottom: '2rem' }}>
      {/* ãƒ˜ãƒƒãƒ€ãƒ¼ã¨è¨­å®šãƒœã‚¿ãƒ³ */}
      <Stack gap="lg" mb="xl">
        <Group justify="space-between" align="flex-start">
          <Box style={{ flex: 1 }}>
            <Text size="sm" c="dimmed">{today}</Text>
          </Box>
          
          {/* è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆã¨è¨­å®šãƒœã‚¿ãƒ³ */}
          <DisplayModeToggle
            mode={displayMode}
            onModeChange={handleDisplayModeChange}
            onSettingsClick={handleSettingsClick}
            compact={isMobilePortrait}
          />
        </Group>
      </Stack>

      {/* è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ãŸãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */}
      {shouldShowDial ? (
        // ãƒ€ã‚¤ãƒ¤ãƒ«ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³UI
        <DialNavigation
          items={visibleDialItems.map((item): DialItem => ({
            id: item.id,
            title: item.title,
            icon: item.icon,
            color: item.color,
            href: item.href,
            badge: item.badge,
            subActions: item.subActions,
          }))}
          onNavigate={(href) => router.push(href)}
          allItems={dialMenuItems as EditableDialItem[]}
          onItemsChange={handleSaveDialMenuSettings}
          sizePreset={dialSizePreset}
          onSizePresetChange={handleDialSizePresetChange}
        />
      ) : (
        // ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ãƒ»æ¨ªå‘ã: è©³ç´°ã‚«ãƒ¼ãƒ‰ã‚°ãƒªãƒƒãƒ‰
        <SimpleGrid
          cols={{ base: 1, xs: 2, md: 3 }}
          spacing="lg"
        >
          {visibleCards.map((card) => (
            <Card
              key={card.id}
              shadow="sm"
              padding="lg"
              radius="md"
              withBorder
              style={{
                cursor: 'pointer',
                transition: 'all 0.2s ease',
                position: 'relative',
                overflow: 'visible',
              }}
              onMouseEnter={(e) => {
                e.currentTarget.style.transform = 'translateY(-4px)';
                e.currentTarget.style.boxShadow = 'var(--shadow-ethereal-hover)';
              }}
              onMouseLeave={(e) => {
                e.currentTarget.style.transform = 'translateY(0)';
                e.currentTarget.style.boxShadow = 'var(--shadow-ethereal)';
              }}
              onClick={() => router.push(card.href)}
            >
              {card.badge !== undefined && (
                <Badge
                  variant="filled"
                  color={card.color}
                  size="lg"
                  style={{
                    position: 'absolute',
                    top: 12,
                    right: 12,
                    zIndex: 1,
                  }}
                >
                  {card.badge}
                </Badge>
              )}
              
              <Stack gap="md" style={{ height: '100%' }}>
                <ThemeIcon
                  size={64}
                  radius="md"
                  variant="light"
                  color={card.color}
                >
                  {card.icon}
                </ThemeIcon>
                
                <Stack gap="xs" style={{ flex: 1 }}>
                  <Title order={4}>{card.title}</Title>
                  <Text size="sm" c="dimmed" lineClamp={2}>
                    {card.description}
                  </Text>
                  {card.stats && (
                    <Text size="sm" fw={600} c={card.color} mt="auto">
                      {card.stats}
                    </Text>
                  )}
                </Stack>
                
                <Group justify="space-between" mt="auto">
                  <Text size="sm" fw={500} c={card.color}>
                    è©³ç´°ã‚’è¦‹ã‚‹
                  </Text>
                  <IconChevronRight size={16} color={`var(--mantine-color-${card.color}-6)`} />
                </Group>
              </Stack>
            </Card>
          ))}
        </SimpleGrid>
      )}

      {/* ã‚«ãƒ¼ãƒ‰è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ« */}
      <DashboardCardSettings
        opened={settingsOpened}
        onClose={closeSettings}
        cards={dashboardCards}
        onSave={handleSaveCardSettings}
      />

      {/* ãƒ€ã‚¤ã‚¢ãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼è¨­å®šãƒ¢ãƒ¼ãƒ€ãƒ« */}
      <DialMenuSettings
        opened={dialSettingsOpened}
        onClose={closeDialSettings}
        items={dialMenuItems}
        onSave={handleSaveDialMenuSettings}
      />
    </Container>
  );
}
````

## File: frontend/src/components/cats/cat-edit-modal.tsx
````typescript
"use client";

import { useEffect, useMemo, useState } from "react";
import {
  Stack,
  TextInput,
  Textarea,
  Select,
  Button,
  Group,
  Loader,
  Center,
  Divider,
  Grid,
} from "@mantine/core";
import { IconDeviceFloppy, IconX } from "@tabler/icons-react";
import { format } from "date-fns";
import { UnifiedModal } from '@/components/common';
import { useGetCat, useUpdateCat, type Cat } from "@/lib/api/hooks/use-cats";
import { useGetBreeds } from "@/lib/api/hooks/use-breeds";
import { useGetCoatColors } from "@/lib/api/hooks/use-coat-colors";
import { useBreedMasterData, useCoatColorMasterData } from "@/lib/api/hooks/use-master-data";
import TagSelector from "@/components/TagSelector";
import { ALPHANUM_SPACE_HYPHEN_PATTERN, MasterDataCombobox } from "@/components/forms/MasterDataCombobox";
import { useSelectionHistory } from "@/lib/hooks/use-selection-history";
import { buildMasterOptions, createDisplayNameMap } from "@/lib/master-data/master-options";

interface CatEditModalProps {
  opened: boolean;
  onClose: () => void;
  catId: string;
  onSuccess?: () => void;
}

// Gender options
const GENDER_OPTIONS = [
  { value: "MALE", label: "Male" },
  { value: "FEMALE", label: "Female" },
  { value: "NEUTER", label: "Neutered Male" },
  { value: "SPAY", label: "Spayed Female" },
];

const COAT_COLOR_DESCRIPTION = "åŠè§’è‹±æ•°å­—ãƒ»ã‚¹ãƒšãƒ¼ã‚¹ãƒ»ãƒã‚¤ãƒ•ãƒ³ã§æ¤œç´¢ã§ãã¾ã™ã€‚";

export function CatEditModal({
  opened,
  onClose,
  catId,
  onSuccess,
}: CatEditModalProps) {
  const { data: cat, isLoading: isCatLoading } = useGetCat(catId);
  const breedListQuery = useMemo(() => ({ limit: 1000, sortBy: 'code', sortOrder: 'asc' as const }), []);
  const coatColorListQuery = useMemo(() => ({ limit: 1000, sortBy: 'code', sortOrder: 'asc' as const }), []);
  const { data: breedsData, isLoading: isBreedsLoading } = useGetBreeds(breedListQuery);
  const { data: coatColorsData, isLoading: isCoatColorsLoading } = useGetCoatColors(coatColorListQuery);
  const { data: breedMasterData, isLoading: isBreedMasterLoading } = useBreedMasterData();
  const { data: coatMasterData, isLoading: isCoatMasterLoading } = useCoatColorMasterData();
  const { history: breedHistory, recordSelection: recordBreedSelection } = useSelectionHistory("breed");
  const { history: coatHistory, recordSelection: recordCoatSelection } = useSelectionHistory("coat-color");
  const breedDisplayMap = useMemo(() => createDisplayNameMap(breedMasterData?.data), [breedMasterData]);
  const coatDisplayMap = useMemo(() => createDisplayNameMap(coatMasterData?.data), [coatMasterData]);
  const breedOptions = useMemo(() => buildMasterOptions(breedsData?.data, breedDisplayMap), [breedsData, breedDisplayMap]);
  const coatOptions = useMemo(() => buildMasterOptions(coatColorsData?.data, coatDisplayMap), [coatColorsData, coatDisplayMap]);
  const updateCat = useUpdateCat(catId);

  const [form, setForm] = useState<{
    name: string;
    gender: "MALE" | "FEMALE" | "NEUTER" | "SPAY";
    breedId: string;
    coatColorId: string;
    birthDate: string;
    microchipNumber: string;
    registrationNumber: string;
    description: string;
    tagIds: string[];
  }>({
    name: "",
    gender: "MALE",
    breedId: "",
    coatColorId: "",
    birthDate: "",
    microchipNumber: "",
    registrationNumber: "",
    description: "",
    tagIds: [],
  });

  // ãƒ‡ãƒ¼ã‚¿å–å¾—å¾Œã«ãƒ•ã‚©ãƒ¼ãƒ ã‚’åˆæœŸåŒ–
  useEffect(() => {
    if (cat?.data && opened) {
      const catData = cat.data;
      setForm({
        name: catData.name || "",
        gender: catData.gender || "MALE",
        breedId: catData.breedId || "",
        coatColorId: catData.coatColorId || "",
        birthDate: catData.birthDate ? format(new Date(catData.birthDate), "yyyy-MM-dd") : "",
        microchipNumber: catData.microchipNumber || "",
        registrationNumber: catData.registrationNumber || "",
        description: catData.description || "",
        tagIds: catData.tags?.map((catTag: NonNullable<Cat['tags']>[number]) => catTag.tag.id) || [],
      });
    }
  }, [cat, opened]);

  const handleChange = (field: string, value: string) => {
    setForm(prev => ({
      ...prev,
      [field]: value,
    }));
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    try {
      await updateCat.mutateAsync({
        name: form.name,
        gender: form.gender,
        breedId: form.breedId || null,
        coatColorId: form.coatColorId || null,
        birthDate: form.birthDate,
        microchipNumber: form.microchipNumber || null,
        registrationNumber: form.registrationNumber || null,
        description: form.description || null,
        tagIds: form.tagIds,
      });

      onSuccess?.();
      onClose();
    } catch (error) {
      console.error("æ›´æ–°ã‚¨ãƒ©ãƒ¼:", error);
    }
  };

  const handleClose = () => {
    if (!updateCat.isPending) {
      onClose();
    }
  };

  const isLoading =
    isCatLoading || isBreedsLoading || isCoatColorsLoading || isBreedMasterLoading || isCoatMasterLoading;

  return (
    <UnifiedModal
      opened={opened}
      onClose={handleClose}
      title="çŒ«ã®æƒ…å ±ç·¨é›†"
      size="lg"
      closeOnClickOutside={!updateCat.isPending}
      closeOnEscape={!updateCat.isPending}
      addContentPadding={false}
    >
      {isLoading ? (
        <Center py="xl">
          <Loader size="lg" />
        </Center>
      ) : (
        <form onSubmit={handleSubmit}>
          <Stack gap="md" p="md">
            <Grid gutter="md">
              <Grid.Col span={6}>
                <TextInput
                  label="åå‰"
                  value={form.name}
                  onChange={(e) => handleChange("name", e.target.value)}
                  required
                  disabled={updateCat.isPending}
                />
              </Grid.Col>

              <Grid.Col span={6}>
                <Select
                  label="æ€§åˆ¥"
                  value={form.gender}
                  onChange={(value) => handleChange("gender", value || "")}
                  data={GENDER_OPTIONS}
                  required
                  disabled={updateCat.isPending}
                />
              </Grid.Col>

              <Grid.Col span={6}>
                <MasterDataCombobox
                  label="å“ç¨®"
                  value={form.breedId || undefined}
                  onChange={(next) => handleChange("breedId", next ?? "")}
                  options={breedOptions}
                  historyItems={breedHistory}
                  disabled={updateCat.isPending}
                  loading={isBreedsLoading || isBreedMasterLoading}
                  historyLabel="æœ€è¿‘ã®å“ç¨®"
                  onOptionSelected={recordBreedSelection}
                />
              </Grid.Col>

              <Grid.Col span={6}>
                <MasterDataCombobox
                  label="è‰²æŸ„"
                  value={form.coatColorId || undefined}
                  onChange={(next) => handleChange("coatColorId", next ?? "")}
                  options={coatOptions}
                  historyItems={coatHistory}
                  disabled={updateCat.isPending}
                  loading={isCoatColorsLoading || isCoatMasterLoading}
                  historyLabel="æœ€è¿‘ã®è‰²æŸ„"
                  onOptionSelected={recordCoatSelection}
                  description={COAT_COLOR_DESCRIPTION}
                  sanitizePattern={ALPHANUM_SPACE_HYPHEN_PATTERN}
                />
              </Grid.Col>

              <Grid.Col span={6}>
                <TextInput
                  label="ç”Ÿå¹´æœˆæ—¥"
                  type="date"
                  value={form.birthDate}
                  onChange={(e) => handleChange("birthDate", e.target.value)}
                  required
                  disabled={updateCat.isPending}
                />
              </Grid.Col>

              <Grid.Col span={6}>
                <TextInput
                  label="ãƒã‚¤ã‚¯ãƒ­ãƒãƒƒãƒ—ç•ªå·"
                  value={form.microchipNumber}
                  onChange={(e) => handleChange("microchipNumber", e.target.value)}
                  placeholder="15æ¡ã®ç•ªå·"
                  disabled={updateCat.isPending}
                />
              </Grid.Col>

              <Grid.Col span={12}>
                <TextInput
                  label="ç™»éŒ²ç•ªå·"
                  value={form.registrationNumber}
                  onChange={(e) => handleChange("registrationNumber", e.target.value)}
                  placeholder="è¡€çµ±æ›¸ç™»éŒ²ç•ªå·"
                  disabled={updateCat.isPending}
                />
              </Grid.Col>

              <Grid.Col span={12}>
                <Textarea
                  label="è©³ç´°èª¬æ˜"
                  value={form.description}
                  onChange={(e) => handleChange("description", e.target.value)}
                  rows={3}
                  placeholder="ç‰¹è¨˜äº‹é …ã‚„æ€§æ ¼ãªã©"
                  disabled={updateCat.isPending}
                />
              </Grid.Col>
            </Grid>

            <Divider my="xs" />

            <TagSelector
              selectedTags={form.tagIds}
              onChange={(tagIds) => setForm(prev => ({ ...prev, tagIds }))}
              placeholder="ã‚¿ã‚°ã‚’é¸æŠ"
              label="ã‚¿ã‚°"
              disabled={updateCat.isPending}
            />

            <Group justify="flex-end" mt="md">
              <Button
                variant="subtle"
                color="gray"
                onClick={handleClose}
                disabled={updateCat.isPending}
                leftSection={<IconX size={16} />}
              >
                ã‚­ãƒ£ãƒ³ã‚»ãƒ«
              </Button>
              <Button
                type="submit"
                loading={updateCat.isPending}
                leftSection={<IconDeviceFloppy size={16} />}
              >
                ä¿å­˜
              </Button>
            </Group>
          </Stack>
        </form>
      )}
    </UnifiedModal>
  );
}
````

## File: frontend/src/components/cats/PedigreeTab.tsx
````typescript
'use client';

import {
  Stack,
  Card,
  Text,
  Group,
  Badge,
  Loader,
  Center,
  Alert,
  Title,
  Grid,
  Paper,
  Anchor,
  Divider,
  SimpleGrid,
} from '@mantine/core';
import { IconAlertCircle, IconDna, IconUsers, IconBabyCarriage } from '@tabler/icons-react';
import { useRouter } from 'next/navigation';
import { format } from 'date-fns';
import { ja } from 'date-fns/locale';
import {
  useGetCatFamily,
  type ParentInfo,
  type SiblingInfo,
  type OffspringInfo,
  type AncestorInfo,
} from '@/lib/api/hooks/use-cats';

interface PedigreeTabProps {
  catId: string;
}

// æ€§åˆ¥ã®è¡¨ç¤ºãƒ©ãƒ™ãƒ«
const GENDER_LABELS: Record<string, string> = {
  MALE: 'ã‚ªã‚¹',
  FEMALE: 'ãƒ¡ã‚¹',
  NEUTER: 'å»å‹¢ã‚ªã‚¹',
  SPAY: 'é¿å¦Šãƒ¡ã‚¹',
};

// æ€§åˆ¥ã«å¿œã˜ãŸè‰²
const getGenderColor = (gender: string): string => {
  switch (gender) {
    case 'MALE':
    case 'NEUTER':
      return 'blue';
    case 'FEMALE':
    case 'SPAY':
      return 'pink';
    default:
      return 'gray';
  }
};

/**
 * ç¥–å…ˆã‚«ãƒ¼ãƒ‰ï¼ˆç¥–çˆ¶æ¯ãƒ»æ›¾ç¥–çˆ¶æ¯ç”¨ï¼‰
 */
function AncestorCard({
  ancestor,
  label,
}: {
  ancestor: AncestorInfo | null;
  label: string;
}) {
  const router = useRouter();

  if (!ancestor || !ancestor.catName) {
    return (
      <Card p="xs" withBorder style={{ backgroundColor: 'var(--mantine-color-gray-0)' }}>
        <Text size="xs" c="dimmed" ta="center">
          {label}: æƒ…å ±ãªã—
        </Text>
      </Card>
    );
  }

  const handleClick = () => {
    if (ancestor.pedigreeId) {
      router.push(`/pedigrees?tab=tree&id=${ancestor.pedigreeId}`);
    }
  };

  return (
    <Card
      p="xs"
      withBorder
      style={{
        cursor: ancestor.pedigreeId ? 'pointer' : 'default',
        transition: 'all 0.2s',
      }}
      onClick={handleClick}
    >
      <Stack gap={2}>
        <Text size="xs" c="dimmed">
          {label}
        </Text>
        <Text size="sm" fw={500} lineClamp={1}>
          {ancestor.catName}
        </Text>
        {ancestor.pedigreeId && (
          <Text size="xs" c="blue" fw={500}>
            {ancestor.pedigreeId}
          </Text>
        )}
        {ancestor.coatColor && (
          <Text size="xs" c="dimmed">
            {ancestor.coatColor}
          </Text>
        )}
      </Stack>
    </Card>
  );
}

/**
 * è¦ªæƒ…å ±ã‚«ãƒ¼ãƒ‰ï¼ˆçˆ¶ã¾ãŸã¯æ¯ï¼‰
 */
function ParentCard({
  parent,
  position,
}: {
  parent: ParentInfo | null;
  position: 'father' | 'mother';
}) {
  const router = useRouter();
  const borderColor = position === 'father' ? '#228be6' : '#e64980';
  const label = position === 'father' ? 'çˆ¶' : 'æ¯';

  if (!parent) {
    return (
      <Card
        p="md"
        withBorder
        style={{
          borderColor: '#dee2e6',
          borderStyle: 'dashed',
          borderWidth: 2,
        }}
      >
        <Text c="dimmed" ta="center">
          {label}è¦ª: æƒ…å ±ãªã—
        </Text>
      </Card>
    );
  }

  const handleCatClick = () => {
    if (parent.id) {
      router.push(`/cats/${parent.id}`);
    }
  };

  const handlePedigreeClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (parent.pedigreeId) {
      router.push(`/pedigrees?tab=tree&id=${parent.pedigreeId}`);
    }
  };

  const coatColorName =
    typeof parent.coatColor === 'string'
      ? parent.coatColor
      : parent.coatColor?.name ?? null;

  return (
    <Card
      p="md"
      withBorder
      style={{
        borderColor,
        borderWidth: 2,
        cursor: parent.id ? 'pointer' : 'default',
      }}
      onClick={handleCatClick}
    >
      <Stack gap="sm">
        <Group justify="space-between" align="flex-start">
          <div>
            <Text size="xs" c="dimmed">
              {label}è¦ª
            </Text>
            <Text fw={600} size="lg">
              {parent.name}
            </Text>
          </div>
          {parent.gender && (
            <Badge color={getGenderColor(parent.gender)} size="sm">
              {GENDER_LABELS[parent.gender] || parent.gender}
            </Badge>
          )}
        </Group>

        {parent.pedigreeId && (
          <Anchor
            size="sm"
            c="blue"
            onClick={handlePedigreeClick}
            style={{ cursor: 'pointer' }}
          >
            è¡€çµ±æ›¸: {parent.pedigreeId}
          </Anchor>
        )}

        {parent.birthDate && (
          <Text size="sm" c="dimmed">
            ç”Ÿå¹´æœˆæ—¥: {format(new Date(parent.birthDate), 'yyyyå¹´MMæœˆddæ—¥', { locale: ja })}
          </Text>
        )}

        {parent.breed && (
          <Badge size="sm" variant="light">
            {parent.breed.name}
          </Badge>
        )}

        {coatColorName && (
          <Text size="sm" c="dimmed">
            æ¯›è‰²: {coatColorName}
          </Text>
        )}

        {/* ç¥–çˆ¶æ¯æƒ…å ±ï¼ˆPedigreeã‹ã‚‰å–å¾—ï¼‰ */}
        {(parent.father || parent.mother) && (
          <>
            <Divider my="xs" />
            <Text size="xs" fw={500} c="dimmed">
              ç¥–çˆ¶æ¯
            </Text>
            <SimpleGrid cols={2} spacing="xs">
              <AncestorCard ancestor={parent.father} label="ç¥–çˆ¶" />
              <AncestorCard ancestor={parent.mother} label="ç¥–æ¯" />
            </SimpleGrid>
          </>
        )}
      </Stack>
    </Card>
  );
}

/**
 * å…„å¼Ÿå§‰å¦¹ãƒªã‚¹ãƒˆ
 */
function SiblingsList({ siblings }: { siblings: SiblingInfo[] }) {
  const router = useRouter();

  if (siblings.length === 0) {
    return (
      <Text c="dimmed" size="sm">
        å…„å¼Ÿå§‰å¦¹ã¯ã„ã¾ã›ã‚“ï¼ˆä¸¡è¦ªãŒä¸€è‡´ã™ã‚‹çŒ«ã®ã¿è¡¨ç¤ºï¼‰
      </Text>
    );
  }

  return (
    <Stack gap="xs">
      {siblings.map((sibling) => (
        <Card
          key={sibling.id}
          p="sm"
          withBorder
          style={{ cursor: 'pointer' }}
          onClick={() => router.push(`/cats/${sibling.id}`)}
        >
          <Group justify="space-between" wrap="nowrap">
            <Group gap="md" wrap="wrap">
              <Text fw={500}>{sibling.name}</Text>
              <Badge size="sm" color={getGenderColor(sibling.gender)}>
                {GENDER_LABELS[sibling.gender] || sibling.gender}
              </Badge>
              {sibling.breed && (
                <Badge size="sm" variant="light">
                  {sibling.breed.name}
                </Badge>
              )}
              <Text size="sm" c="dimmed">
                {format(new Date(sibling.birthDate), 'yyyy/MM/dd', { locale: ja })}
              </Text>
            </Group>
            {sibling.pedigreeId && (
              <Anchor
                size="sm"
                c="blue"
                onClick={(e) => {
                  e.stopPropagation();
                  router.push(`/pedigrees?tab=tree&id=${sibling.pedigreeId}`);
                }}
              >
                {sibling.pedigreeId}
              </Anchor>
            )}
          </Group>
        </Card>
      ))}
    </Stack>
  );
}

/**
 * å­çŒ«ãƒªã‚¹ãƒˆ
 */
function OffspringList({ offspring }: { offspring: OffspringInfo[] }) {
  const router = useRouter();

  if (offspring.length === 0) {
    return (
      <Text c="dimmed" size="sm">
        å­çŒ«ã¯ã„ã¾ã›ã‚“
      </Text>
    );
  }

  return (
    <Stack gap="xs">
      {offspring.map((child) => (
        <Card
          key={child.id}
          p="sm"
          withBorder
          style={{ cursor: 'pointer' }}
          onClick={() => router.push(`/cats/${child.id}`)}
        >
          <Group justify="space-between" wrap="nowrap">
            <Group gap="md" wrap="wrap">
              <Text fw={500}>{child.name}</Text>
              <Badge size="sm" color={getGenderColor(child.gender)}>
                {GENDER_LABELS[child.gender] || child.gender}
              </Badge>
              {child.breed && (
                <Badge size="sm" variant="light">
                  {child.breed.name}
                </Badge>
              )}
              <Text size="sm" c="dimmed">
                {format(new Date(child.birthDate), 'yyyy/MM/dd', { locale: ja })}
              </Text>
              {child.otherParent && (
                <Text size="sm" c="dimmed">
                  ç›¸æ‰‹: {child.otherParent.name}
                </Text>
              )}
            </Group>
            {child.pedigreeId && (
              <Anchor
                size="sm"
                c="blue"
                onClick={(e) => {
                  e.stopPropagation();
                  router.push(`/pedigrees?tab=tree&id=${child.pedigreeId}`);
                }}
              >
                {child.pedigreeId}
              </Anchor>
            )}
          </Group>
        </Card>
      ))}
    </Stack>
  );
}

/**
 * ç°¡æ˜“å®¶ç³»å›³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 */
function SimpleFamilyTree({
  cat,
  father,
  mother,
}: {
  cat: {
    id: string;
    name: string;
    gender: string;
    pedigreeId: string | null;
  };
  father: ParentInfo | null;
  mother: ParentInfo | null;
}) {
  const router = useRouter();

  return (
    <Paper p="md" withBorder>
      <Stack gap="md">
        <Title order={5}>
          <Group gap="xs">
            <IconDna size={20} />
            ç°¡æ˜“å®¶ç³»å›³
          </Group>
        </Title>

        {/* æœ¬çŒ« */}
        <Card
          p="md"
          withBorder
          style={{
            borderColor: getGenderColor(cat.gender) === 'blue' ? '#228be6' : '#e64980',
            borderWidth: 3,
            backgroundColor: 'var(--mantine-color-gray-0)',
          }}
        >
          <Group justify="center">
            <Stack gap="xs" align="center">
              <Text fw={700} size="lg">
                {cat.name}ï¼ˆæœ¬çŒ«ï¼‰
              </Text>
              <Badge color={getGenderColor(cat.gender)}>
                {GENDER_LABELS[cat.gender] || cat.gender}
              </Badge>
              {cat.pedigreeId && (
                <Anchor
                  size="sm"
                  c="blue"
                  onClick={() => router.push(`/pedigrees?tab=tree&id=${cat.pedigreeId}`)}
                >
                  è¡€çµ±æ›¸: {cat.pedigreeId}
                </Anchor>
              )}
            </Stack>
          </Group>
        </Card>

        {/* ä¸¡è¦ª */}
        <Grid>
          <Grid.Col span={6}>
            <ParentCard parent={father} position="father" />
          </Grid.Col>
          <Grid.Col span={6}>
            <ParentCard parent={mother} position="mother" />
          </Grid.Col>
        </Grid>
      </Stack>
    </Paper>
  );
}

/**
 * è¡€çµ±ã‚¿ãƒ–ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 */
export function PedigreeTab({ catId }: PedigreeTabProps) {
  const { data: familyData, isLoading, error } = useGetCatFamily(catId);

  if (isLoading) {
    return (
      <Center style={{ minHeight: '200px' }}>
        <Loader size="lg" />
      </Center>
    );
  }

  if (error || !familyData) {
    return (
      <Alert icon={<IconAlertCircle size={16} />} title="ã‚¨ãƒ©ãƒ¼" color="red">
        å®¶æ—æƒ…å ±ã‚’èª­ã¿è¾¼ã‚ã¾ã›ã‚“ã§ã—ãŸã€‚
      </Alert>
    );
  }

  const { cat, father, mother, siblings, offspring } = familyData;

  return (
    <Card shadow="sm" padding="lg" radius="md" withBorder>
      <Stack gap="lg">
        {/* ç°¡æ˜“å®¶ç³»å›³ */}
        <SimpleFamilyTree cat={cat} father={father} mother={mother} />

        {/* å…„å¼Ÿå§‰å¦¹ */}
        <Paper p="md" withBorder>
          <Stack gap="md">
            <Title order={5}>
              <Group gap="xs">
                <IconUsers size={20} />
                å…„å¼Ÿå§‰å¦¹ï¼ˆä¸¡è¦ªãŒä¸€è‡´ï¼‰
              </Group>
            </Title>
            <SiblingsList siblings={siblings} />
          </Stack>
        </Paper>

        {/* å­çŒ« */}
        <Paper p="md" withBorder>
          <Stack gap="md">
            <Title order={5}>
              <Group gap="xs">
                <IconBabyCarriage size={20} />
                å­çŒ«
              </Group>
            </Title>
            <OffspringList offspring={offspring} />
          </Stack>
        </Paper>
      </Stack>
    </Card>
  );
}
````

## File: frontend/src/components/common/UnifiedModalSectionsDemo.tsx
````typescript
'use client';

import { useState } from 'react';
import { Button, TextInput, Select, Textarea, Group, Grid } from '@mantine/core';
import { UnifiedModal, type ModalSection } from './UnifiedModal';
import { IconDeviceFloppy, IconX } from '@tabler/icons-react';

/**
 * UnifiedModalã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ã®ãƒ‡ãƒ¢ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * 
 * ä½¿ç”¨ä¾‹:
 * ```tsx
 * import { UnifiedModalSectionsDemo } from '@/components/common/UnifiedModalSectionsDemo';
 * 
 * <UnifiedModalSectionsDemo />
 * ```
 */
export function UnifiedModalSectionsDemo() {
  const [opened, setOpened] = useState(false);
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    category: '',
    priority: '',
    description: '',
  });

  const handleSubmit = () => {
    console.log('Form submitted:', formData);
    setOpened(false);
  };

  const sections: ModalSection[] = [
    {
      label: 'åŸºæœ¬æƒ…å ±',
      content: (
        <Grid gutter="md">
          <Grid.Col span={6}>
            <TextInput
              label="åå‰"
              placeholder="å±±ç”°å¤ªéƒ"
              value={formData.name}
              onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}
              required
            />
          </Grid.Col>
          <Grid.Col span={6}>
            <TextInput
              label="ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹"
              type="email"
              placeholder="example@example.com"
              value={formData.email}
              onChange={(e) => setFormData(prev => ({ ...prev, email: e.target.value }))}
              required
            />
          </Grid.Col>
        </Grid>
      ),
    },
    {
      label: 'åˆ†é¡è¨­å®š',
      content: (
        <Grid gutter="md">
          <Grid.Col span={6}>
            <Select
              label="ã‚«ãƒ†ã‚´ãƒª"
              placeholder="é¸æŠã—ã¦ãã ã•ã„"
              value={formData.category}
              onChange={(value) => setFormData(prev => ({ ...prev, category: value || '' }))}
              data={[
                { value: 'general', label: 'ä¸€èˆ¬' },
                { value: 'important', label: 'é‡è¦' },
                { value: 'urgent', label: 'ç·Šæ€¥' },
              ]}
            />
          </Grid.Col>
          <Grid.Col span={6}>
            <Select
              label="å„ªå…ˆåº¦"
              placeholder="é¸æŠã—ã¦ãã ã•ã„"
              value={formData.priority}
              onChange={(value) => setFormData(prev => ({ ...prev, priority: value || '' }))}
              data={[
                { value: 'low', label: 'ä½' },
                { value: 'medium', label: 'ä¸­' },
                { value: 'high', label: 'é«˜' },
              ]}
            />
          </Grid.Col>
        </Grid>
      ),
    },
    {
      label: 'è©³ç´°æƒ…å ±',
      content: (
        <Textarea
          label="èª¬æ˜"
          placeholder="è©³ç´°ãªèª¬æ˜ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"
          value={formData.description}
          onChange={(e) => setFormData(prev => ({ ...prev, description: e.target.value }))}
          rows={4}
        />
      ),
    },
    {
      // ãƒ©ãƒ™ãƒ«ãªã—ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆãƒœã‚¿ãƒ³ã‚°ãƒ«ãƒ¼ãƒ—ï¼‰
      content: (
        <Group justify="flex-end" mt="md">
          <Button
            variant="subtle"
            color="gray"
            onClick={() => setOpened(false)}
            leftSection={<IconX size={16} />}
          >
            ã‚­ãƒ£ãƒ³ã‚»ãƒ«
          </Button>
          <Button
            onClick={handleSubmit}
            leftSection={<IconDeviceFloppy size={16} />}
          >
            ä¿å­˜
          </Button>
        </Group>
      ),
    },
  ];

  return (
    <>
      <Button onClick={() => setOpened(true)}>
        ã‚»ã‚¯ã‚·ãƒ§ãƒ³ä»˜ããƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ãï¼ˆãƒ‡ãƒ¢ï¼‰
      </Button>

      <UnifiedModal
        opened={opened}
        onClose={() => setOpened(false)}
        title="ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ãƒ‡ãƒ¢"
        size="lg"
        sections={sections}
      />
    </>
  );
}
````

## File: frontend/src/components/editable-field/field-edit-modal.tsx
````typescript
'use client';

import { useState, useEffect } from 'react';
import {
  TextInput,
  Button,
  Group,
  Select,
  NumberInput,
  Textarea,
} from '@mantine/core';
import { DateInput } from '@mantine/dates';
import { UnifiedModal, type ModalSection } from '@/components/common';

type FieldType = 'text' | 'number' | 'date' | 'select' | 'textarea';

interface FieldEditModalProps {
  opened: boolean;
  onClose: () => void;
  title: string;
  fieldLabel: string;
  fieldType: FieldType;
  currentValue: string | number | Date | null | undefined;
  onSave: (value: string | number | Date | null) => void | Promise<void>;
  selectOptions?: { value: string; label: string }[];
  placeholder?: string;
  required?: boolean;
  minValue?: number;
  maxValue?: number;
  rows?: number;
}

export function FieldEditModal({
  opened,
  onClose,
  title,
  fieldLabel,
  fieldType,
  currentValue,
  onSave,
  selectOptions = [],
  placeholder,
  required = false,
  minValue,
  maxValue,
  rows = 3,
}: FieldEditModalProps) {
  const [value, setValue] = useState<string | number | Date | null>(currentValue ?? null);
  const [isSaving, setIsSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒé–‹ã„ãŸã¨ãã«ç¾åœ¨å€¤ã‚’ã‚»ãƒƒãƒˆ
  useEffect(() => {
    if (opened) {
      setValue(currentValue ?? null);
      setError(null);
    }
  }, [opened, currentValue]);

  const handleSave = async () => {
    // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    if (required && (value === null || value === '')) {
      setError('ã“ã®é …ç›®ã¯å¿…é ˆã§ã™');
      return;
    }

    if (fieldType === 'number' && typeof value === 'number') {
      if (minValue !== undefined && value < minValue) {
        setError(`${minValue}ä»¥ä¸Šã®å€¤ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„`);
        return;
      }
      if (maxValue !== undefined && value > maxValue) {
        setError(`${maxValue}ä»¥ä¸‹ã®å€¤ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„`);
        return;
      }
    }

    setIsSaving(true);
    setError(null);

    try {
      await onSave(value);
      onClose();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ');
    } finally {
      setIsSaving(false);
    }
  };

  const renderInput = () => {
    switch (fieldType) {
      case 'text':
        return (
          <TextInput
            label={fieldLabel}
            placeholder={placeholder}
            value={(value as string) || ''}
            onChange={(e) => setValue(e.target.value)}
            required={required}
            error={error}
            autoFocus
          />
        );

      case 'textarea':
        return (
          <Textarea
            label={fieldLabel}
            placeholder={placeholder}
            value={(value as string) || ''}
            onChange={(e) => setValue(e.target.value)}
            required={required}
            error={error}
            rows={rows}
            autoFocus
          />
        );

      case 'number':
        return (
          <NumberInput
            label={fieldLabel}
            placeholder={placeholder}
            value={value as number | ''}
            onChange={(val) => setValue(val as number)}
            required={required}
            error={error}
            min={minValue}
            max={maxValue}
            autoFocus
          />
        );

      case 'date':
        return (
          <DateInput
            label={fieldLabel}
            placeholder={placeholder}
            value={value ? new Date(value) : null}
            onChange={(date) => setValue(date)}
            required={required}
            error={error}
            valueFormat="YYYY/MM/DD"
            autoFocus
          />
        );

      case 'select':
        return (
          <Select
            label={fieldLabel}
            placeholder={placeholder}
            value={value as string | null}
            onChange={(val) => setValue(val)}
            data={selectOptions}
            required={required}
            error={error}
            searchable
            autoFocus
          />
        );

      default:
        return null;
    }
  };

  const sections: ModalSection[] = [
    {
      content: renderInput(),
    },
    {
      content: (
        <Group justify="flex-end" gap="sm">
          <Button variant="outline" onClick={onClose} disabled={isSaving}>
            ã‚­ãƒ£ãƒ³ã‚»ãƒ«
          </Button>
          <Button onClick={handleSave} loading={isSaving}>
            ä¿å­˜
          </Button>
        </Group>
      ),
    },
  ];

  return (
    <UnifiedModal
      opened={opened}
      onClose={onClose}
      title={title}
      size="md"
      centered
      sections={sections}
    />
  );
}
````

## File: frontend/src/components/kittens/WeightChart.tsx
````typescript
'use client';

import { useMemo } from 'react';
import {
  Card,
  Text,
  Group,
  Stack,
  Badge,
  Loader,
  Center,
  Box,
} from '@mantine/core';
import { IconTrendingUp, IconTrendingDown, IconMinus } from '@tabler/icons-react';
import {
  useGetWeightRecords,
  type WeightRecordSummary,
} from '@/lib/api/hooks/use-weight-records';

interface WeightChartProps {
  catId: string;
  catName: string;
  /** ã‚°ãƒ©ãƒ•ã®é«˜ã•ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 200pxï¼‰ */
  height?: number;
}

/**
 * ä½“é‡æ¨ç§»ã‚°ãƒ©ãƒ•ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * recharts ãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ãªã„å ´åˆã¯ç°¡æ˜“ãƒ†ãƒ¼ãƒ–ãƒ«è¡¨ç¤º
 */
export function WeightChart({ catId, catName, height = 200 }: WeightChartProps) {
  const { data, isLoading, error } = useGetWeightRecords({
    catId,
    limit: 30,
    sortOrder: 'asc',
  });

  // ã‚°ãƒ©ãƒ•ç”¨ãƒ‡ãƒ¼ã‚¿ã‚’æ•´å½¢
  const chartData = useMemo(() => {
    if (!data?.data) return [];
    return data.data.map((record) => ({
      date: new Date(record.recordedAt).toLocaleDateString('ja-JP', {
        month: 'short',
        day: 'numeric',
      }),
      weight: record.weight,
      fullDate: new Date(record.recordedAt).toLocaleDateString('ja-JP'),
    }));
  }, [data?.data]);

  const summary = data?.summary;

  if (isLoading) {
    return (
      <Card padding="md" radius="md" withBorder>
        <Center h={height}>
          <Loader size="sm" />
        </Center>
      </Card>
    );
  }

  if (error) {
    return (
      <Card padding="md" radius="md" withBorder>
        <Center h={height}>
          <Text c="red" size="sm">
            ä½“é‡ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ
          </Text>
        </Center>
      </Card>
    );
  }

  if (!data?.data || data.data.length === 0) {
    return (
      <Card padding="md" radius="md" withBorder>
        <Center h={height}>
          <Text c="dimmed" size="sm">
            ä½“é‡è¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“
          </Text>
        </Center>
      </Card>
    );
  }

  return (
    <Card padding="md" radius="md" withBorder>
      <Stack gap="md">
        {/* ãƒ˜ãƒƒãƒ€ãƒ¼ */}
        <Group justify="space-between" align="flex-start">
          <Text fw={500}>{catName}ã®ä½“é‡æ¨ç§»</Text>
          {summary && <WeightSummaryBadge summary={summary} />}
        </Group>

        {/* ç°¡æ˜“ã‚°ãƒ©ãƒ•ï¼ˆCSS ã®ã¿ã§å®Ÿè£…ï¼‰ */}
        <SimpleBarChart data={chartData} height={height} />

        {/* æœ€æ–°è¨˜éŒ² */}
        {summary && summary.latestWeight !== null && (
          <Group gap="xs" justify="center">
            <Text size="sm" c="dimmed">
              æœ€æ–°:
            </Text>
            <Text size="sm" fw={600}>
              {summary.latestWeight}g
            </Text>
            <Text size="xs" c="dimmed">
              ({summary.latestRecordedAt
                ? new Date(summary.latestRecordedAt).toLocaleDateString('ja-JP')
                : '-'})
            </Text>
          </Group>
        )}
      </Stack>
    </Card>
  );
}

/**
 * ä½“é‡å¤‰åŒ–ã‚µãƒãƒªãƒ¼ãƒãƒƒã‚¸
 */
function WeightSummaryBadge({ summary }: { summary: WeightRecordSummary }) {
  if (summary.weightChange === null) {
    return null;
  }

  const change = summary.weightChange;
  const isPositive = change > 0;
  const isNegative = change < 0;

  return (
    <Badge
      color={isPositive ? 'green' : isNegative ? 'red' : 'gray'}
      variant="light"
      leftSection={
        isPositive ? (
          <IconTrendingUp size={14} />
        ) : isNegative ? (
          <IconTrendingDown size={14} />
        ) : (
          <IconMinus size={14} />
        )
      }
    >
      {isPositive ? '+' : ''}
      {change}g
    </Badge>
  );
}

/**
 * ç°¡æ˜“æ£’ã‚°ãƒ©ãƒ•ï¼ˆCSS ã®ã¿ã§å®Ÿè£…ï¼‰
 * recharts ã‚’è¿½åŠ ã—ãŸå ´åˆã¯ã“ã‚Œã‚’ç½®ãæ›ãˆå¯èƒ½
 */
function SimpleBarChart({
  data,
  height,
}: {
  data: Array<{ date: string; weight: number; fullDate: string }>;
  height: number;
}) {
  const maxWeight = Math.max(...data.map((d) => d.weight));
  const minWeight = Math.min(...data.map((d) => d.weight));
  const range = maxWeight - minWeight || 1;

  return (
    <Box style={{ height, position: 'relative' }}>
      <Group
        gap={2}
        align="flex-end"
        style={{ height: '100%', padding: '0 4px' }}
        wrap="nowrap"
      >
        {data.map((item, index) => {
          const barHeight = ((item.weight - minWeight) / range) * 0.7 + 0.3;
          return (
            <Box
              key={index}
              style={{
                flex: 1,
                minWidth: 8,
                maxWidth: 40,
                height: `${barHeight * 100}%`,
                backgroundColor: 'var(--mantine-color-blue-5)',
                borderRadius: '4px 4px 0 0',
                cursor: 'pointer',
                transition: 'background-color 0.2s',
              }}
              title={`${item.fullDate}: ${item.weight}g`}
              onMouseEnter={(e) => {
                e.currentTarget.style.backgroundColor =
                  'var(--mantine-color-blue-7)';
              }}
              onMouseLeave={(e) => {
                e.currentTarget.style.backgroundColor =
                  'var(--mantine-color-blue-5)';
              }}
            />
          );
        })}
      </Group>

      {/* Yè»¸ãƒ©ãƒ™ãƒ« */}
      <Box
        style={{
          position: 'absolute',
          left: 0,
          top: 0,
          bottom: 0,
          width: 40,
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'space-between',
          pointerEvents: 'none',
        }}
      >
        <Text size="xs" c="dimmed">
          {maxWeight}g
        </Text>
        <Text size="xs" c="dimmed">
          {minWeight}g
        </Text>
      </Box>
    </Box>
  );
}

export default WeightChart;
````

## File: frontend/src/components/pedigrees/PedigreeFamilyTree.tsx
````typescript
'use client';

import { useState, useEffect } from 'react';
import {
  Title,
  Paper,
  Text,
  Badge,
  Group,
  Stack,
  Card,
  LoadingOverlay,
  Alert,
  Grid,
  Select,
  Center,
} from '@mantine/core';
import { IconDna, IconBinaryTree } from '@tabler/icons-react';
import { useRouter } from 'next/navigation';
import { apiClient, type ApiPathParams } from '@/lib/api/client';

// æœ¬çŒ« + çˆ¶æ¯ + ç¥–çˆ¶æ¯ + æ›¾ç¥–çˆ¶æ¯ = 4ä¸–ä»£ (æœ€å¤§15é ­) ã‚’æƒ³å®šã—ãŸæ¤œè¨¼ä¸Šé™
export const MAX_VALIDATION_DEPTH = 3;

export interface FamilyTreeData {
  id: string;
  pedigreeId: string;
  catName: string;
  breedCode: number | null;
  gender: number | null;
  birthDate: string | null;
  coatColorCode: number | null;
  breed?: { name: string } | null;
  color?: { name: string } | null;
  father?: FamilyTreeData | null;
  mother?: FamilyTreeData | null;
}

interface PedigreeFamilyTreeProps {
  pedigreeId?: string | null;
}

export const isFamilyTreeData = (value: unknown, depth = 0): value is FamilyTreeData => {
  if (depth > MAX_VALIDATION_DEPTH) {
    console.warn('å®¶ç³»å›³ãƒ‡ãƒ¼ã‚¿ã®æ¤œè¨¼æ·±åº¦ãŒä¸Šé™ã‚’è¶…ãˆã¾ã—ãŸ');
    return true;
  }

  if (!value || typeof value !== 'object') {
    return false;
  }

  const record = value as Record<string, unknown>;
  const isNullableNumber = (target: unknown): target is number | null => typeof target === 'number' || target === null;
  const isNullableString = (target: unknown): target is string | null =>
    typeof target === 'string' || target === null;
  const isNamedObject = (target: unknown): target is { name: string } =>
    typeof target === 'object' && target !== null && typeof (target as Record<string, unknown>).name === 'string';
  const isParentNode = (target: unknown): target is FamilyTreeData | null =>
    target === null ? true : isFamilyTreeData(target, depth + 1);

  if (typeof record.id !== 'string' || typeof record.pedigreeId !== 'string' || typeof record.catName !== 'string') {
    return false;
  }

  if (
    !isNullableNumber(record.breedCode)
    || !isNullableNumber(record.gender)
    || !isNullableString(record.birthDate)
    || !isNullableNumber(record.coatColorCode)
  ) {
    return false;
  }

  if ((record.breed !== undefined && record.breed !== null && !isNamedObject(record.breed))
    || (record.color !== undefined && record.color !== null && !isNamedObject(record.color))) {
    return false;
  }

  const fatherNode = 'father' in record ? record.father ?? null : null;
  const motherNode = 'mother' in record ? record.mother ?? null : null;

  return isParentNode(fatherNode) && isParentNode(motherNode);
};

export function PedigreeFamilyTree({ pedigreeId }: PedigreeFamilyTreeProps) {
  const router = useRouter();
  
  const [familyTree, setFamilyTree] = useState<FamilyTreeData | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [generations, setGenerations] = useState('3');

  const generationOptions = [
    { value: '2', label: '2ä¸–ä»£' },
    { value: '3', label: '3ä¸–ä»£' },
    { value: '4', label: '4ä¸–ä»£' },
    { value: '5', label: '5ä¸–ä»£' },
  ];

  useEffect(() => {
    if (!pedigreeId) {
      setFamilyTree(null);
      return;
    }

    const fetchFamilyTree = async () => {
      try {
        setLoading(true);
        setError(null);
        const pathParams: ApiPathParams<'/pedigrees/{id}/family', 'get'> = { id: pedigreeId };
        const response = await apiClient.get('/pedigrees/{id}/family', {
          pathParams,
        });

        if (!response.success) {
          throw new Error(response.error ?? 'å®¶ç³»å›³ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
        }

        if (!response.data) {
          throw new Error('å®¶ç³»å›³ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
        }

        if (!isFamilyTreeData(response.data)) {
          throw new Error('å®¶ç³»å›³ãƒ‡ãƒ¼ã‚¿ã®å½¢å¼ãŒä¸æ­£ã§ã™');
        }

        setFamilyTree(response.data);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
      } finally {
        setLoading(false);
      }
    };

    fetchFamilyTree();
  }, [pedigreeId]);

  const formatDate = (dateString: string | null) => {
    if (!dateString) return 'ä¸æ˜';
    return new Date(dateString).toLocaleDateString('ja-JP', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
    });
  };

  const formatGender = (gender: number | null) => {
    switch (gender) {
      case 1: return 'é›„';
      case 2: return 'é›Œ';
      default: return 'ä¸æ˜';
    }
  };

  const getGenderColor = (gender: number | null) => {
    switch (gender) {
      case 1: return 'blue';
      case 2: return 'pink';
      default: return 'gray';
    }
  };

  const PedigreeCard: React.FC<{ 
    pedigree: FamilyTreeData | null;
    level: number;
    position?: 'father' | 'mother';
  }> = ({ pedigree, level: _level, position }) => {
    if (!pedigree) {
      return (
        <Card 
          p="sm" 
          style={{ 
            border: '2px dashed #dee2e6',
            minHeight: '120px',
            backgroundColor: 'var(--mantine-color-body)'
          }}
        >
          <Text c="dimmed" ta="center" mt="md">
            æƒ…å ±ãªã—
          </Text>
        </Card>
      );
    }

    const borderColor = position === 'father' ? '#228be6' : position === 'mother' ? '#e64980' : '#868e96';
    
    return (
      <Card 
        p="sm" 
        style={{ 
          border: `2px solid ${borderColor}`,
          cursor: 'pointer',
          transition: 'all 0.2s',
          minHeight: '120px'
        }}
        onClick={() => router.push(`/pedigrees/${pedigree.id}`)}
      >
        <Stack gap="xs">
          <Group justify="space-between" align="flex-start">
            <div>
              <Text fw={600} size="sm" lineClamp={1}>
                {pedigree.catName || 'åå‰ãªã—'}
              </Text>
            </div>
            <Badge size="xs" color={getGenderColor(pedigree.gender)}>
              {formatGender(pedigree.gender)}
            </Badge>
          </Group>
          
          <div>
            <Text size="xs" fw={500} c="blue">
              {pedigree.pedigreeId}
            </Text>
            <Text size="xs" c="dimmed">
              {formatDate(pedigree.birthDate)}
            </Text>
          </div>

          {pedigree.breed && (
            <Badge size="xs" variant="light">
              {pedigree.breed.name}
            </Badge>
          )}
        </Stack>
      </Card>
    );
  };

  const renderFamilyLevel = (pedigree: FamilyTreeData | null, currentLevel: number, maxLevel: number): React.ReactNode => {
    if (!pedigree || currentLevel > maxLevel) {
      return null;
    }

    return (
      <div key={`level-${currentLevel}-${pedigree.id}`}>
        <Grid gutter="md" mb="md">
          {/* ç¾åœ¨ã®å€‹ä½“ */}
          <Grid.Col span={12}>
            <Text fw={600} mb="sm" ta="center">
              {currentLevel === 0 ? 'æœ¬çŒ«' : `ç¬¬${currentLevel}ä¸–ä»£`}
            </Text>
            <Group justify="center">
              <div style={{ width: currentLevel === 0 ? '300px' : '250px' }}>
                <PedigreeCard pedigree={pedigree} level={currentLevel} />
              </div>
            </Group>
          </Grid.Col>

          {/* ä¸¡è¦ª */}
          {(pedigree.father || pedigree.mother) && currentLevel < maxLevel && (
            <Grid.Col span={12}>
              <Text fw={600} mb="sm" ta="center">
                ä¸¡è¦ª
              </Text>
              <Grid>
                <Grid.Col span={6}>
                  <Text size="sm" fw={500} mb="xs" ta="center" c="blue">
                    <Group justify="center" gap="xs">
                      <IconDna size={16} />
                      çˆ¶è¦ª
                    </Group>
                  </Text>
                  <PedigreeCard pedigree={pedigree.father || null} level={currentLevel + 1} position="father" />
                </Grid.Col>
                <Grid.Col span={6}>
                  <Text size="sm" fw={500} mb="xs" ta="center" c="pink">
                    <Group justify="center" gap="xs">
                      <IconDna size={16} />
                      æ¯è¦ª
                    </Group>
                  </Text>
                  <PedigreeCard pedigree={pedigree.mother || null} level={currentLevel + 1} position="mother" />
                </Grid.Col>
              </Grid>
            </Grid.Col>
          )}
        </Grid>

        {/* ç¥–çˆ¶æ¯ä»¥ä¸Šã®ä¸–ä»£ã‚’å†å¸°çš„ã«è¡¨ç¤º */}
        {currentLevel < maxLevel - 1 && (pedigree.father || pedigree.mother) && (
          <div style={{ marginLeft: '20px', paddingLeft: '20px', borderLeft: '2px solid #dee2e6' }}>
            {pedigree.father && renderFamilyLevel(pedigree.father as FamilyTreeData, currentLevel + 1, maxLevel)}
            {pedigree.mother && renderFamilyLevel(pedigree.mother as FamilyTreeData, currentLevel + 1, maxLevel)}
          </div>
        )}
      </div>
    );
  };

  if (!pedigreeId) {
    return (
      <Paper p="xl" withBorder>
        <Center>
          <Stack align="center">
            <IconBinaryTree size={48} color="gray" />
            <Text size="lg" fw={500}>å®¶ç³»å›³è¡¨ç¤º</Text>
            <Text c="dimmed">
              ãƒ‡ãƒ¼ã‚¿ç®¡ç†ã‚¿ãƒ–ã‹ã‚‰çŒ«ã‚’é¸æŠã—ã¦å®¶ç³»å›³ã‚’è¡¨ç¤ºã—ã¦ãã ã•ã„ã€‚
            </Text>
          </Stack>
        </Center>
      </Paper>
    );
  }

  if (loading) {
    return (
      <Paper p="md" style={{ position: 'relative', minHeight: '400px' }}>
        <LoadingOverlay visible={true} overlayProps={{ radius: "sm", blur: 2 }} />
      </Paper>
    );
  }

  if (error || !familyTree) {
    return (
      <Alert color="red" title="ã‚¨ãƒ©ãƒ¼">
        {error || 'å®¶ç³»å›³ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ'}
      </Alert>
    );
  }

  return (
    <Stack gap="md">
      {/* ãƒ˜ãƒƒãƒ€ãƒ¼ */}
      <Group justify="space-between">
        <Group>
          <Title order={3}>
            {familyTree.catName}ã®å®¶ç³»å›³
          </Title>
          <Badge size="lg" color="blue">
            è¡€çµ±æ›¸ç•ªå·: {familyTree.pedigreeId}
          </Badge>
        </Group>
        <Group>
          <Select
            label="è¡¨ç¤ºä¸–ä»£æ•°"
            data={generationOptions}
            value={generations}
            onChange={(value) => setGenerations(value || '3')}
            w={120}
          />
        </Group>
      </Group>

      <Group>
        <Badge size="lg" color={getGenderColor(familyTree.gender)}>
          {formatGender(familyTree.gender)}
        </Badge>
        {familyTree.breed && (
          <Badge size="lg" variant="light">
            {familyTree.breed.name}
          </Badge>
        )}
      </Group>

      {/* å®¶ç³»å›³è¡¨ç¤º */}
      <Paper p="md" shadow="sm" style={{ overflow: 'auto' }}>
        <div style={{ minWidth: '800px' }}>
          {renderFamilyLevel(familyTree, 0, parseInt(generations))}
        </div>
      </Paper>

      {/* èª¬æ˜ */}
      <Paper p="md" style={{ backgroundColor: 'var(--mantine-color-gray-0)' }}>
        <Text size="sm" c="dimmed">
          <strong>ä½¿ã„æ–¹:</strong> å„ã‚«ãƒ¼ãƒ‰ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨ã€ãã®å€‹ä½“ã®è©³ç´°æƒ…å ±ã«ç§»å‹•ã§ãã¾ã™ã€‚
          ä¸–ä»£æ•°ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ã§ã€è¡¨ç¤ºã™ã‚‹ç¥–å…ˆã®æ•°ã‚’èª¿æ•´ã§ãã¾ã™ã€‚
        </Text>
      </Paper>
    </Stack>
  );
}
````

## File: frontend/src/components/pedigrees/PrintSettingsEditor.tsx
````typescript
'use client';

import { useState, useEffect, useCallback } from 'react';
import {
  Paper,
  Stack,
  Title,
  Group,
  Button,
  NumberInput,
  Text,
  Accordion,
  Grid,
  Alert,
  LoadingOverlay,
  Divider,
  Badge,
  Tooltip,
  Select,
} from '@mantine/core';
import { notifications } from '@mantine/notifications';
import { IconDeviceFloppy, IconRefresh, IconAlertCircle, IconCheck, IconAdjustments } from '@tabler/icons-react';
import { getPublicApiBaseUrl } from '@/lib/api/public-api-base-url';

// åº§æ¨™è¨­å®šã®å‹å®šç¾©
interface Position {
  x: number;
  y: number;
  align?: 'left' | 'center' | 'right';
}

interface ParentPositions {
  name: Position;
  color: Position;
  eyeColor?: Position;
  jcu: Position;
}

interface GrandParentPositions {
  name: Position;
  color: Position;
  jcu: Position;
}

interface GreatGrandParentPositions {
  name: Position;
  jcu: Position;
}

interface FontSizes {
  catName: number;
  wcaNo: number;
  headerInfo: number;
  parentName: number;
  parentDetail: number;
  grandParentName: number;
  grandParentDetail: number;
  greatGrandParent: number;
  footer: number;
}

interface PositionsConfig {
  offsetX: number;
  offsetY: number;
  breed: Position;
  sex: Position;
  dateOfBirth: Position;
  eyeColor: Position;
  color: Position;
  catName: Position;
  wcaNo: Position;
  owner: Position;
  breeder: Position;
  dateOfRegistration: Position;
  littersM: Position;
  littersF: Position;
  sire: ParentPositions;
  dam: ParentPositions;
  grandParents: {
    ff: GrandParentPositions;
    fm: GrandParentPositions;
    mf: GrandParentPositions;
    mm: GrandParentPositions;
  };
  greatGrandParents: {
    fff: GreatGrandParentPositions;
    ffm: GreatGrandParentPositions;
    fmf: GreatGrandParentPositions;
    fmm: GreatGrandParentPositions;
    mff: GreatGrandParentPositions;
    mfm: GreatGrandParentPositions;
    mmf: GreatGrandParentPositions;
    mmm: GreatGrandParentPositions;
  };
  otherOrganizationsNo: Position;
  fontSizes: FontSizes;
}

// ä½ç½®å…¥åŠ›ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
function PositionInput({
  label,
  position,
  onChange,
  showAlign = false,
}: {
  label: string;
  position: Position;
  onChange: (pos: Position) => void;
  showAlign?: boolean;
}) {
  return (
    <Grid align="center" gutter="xs">
      <Grid.Col span={showAlign ? 3 : 4}>
        <Text size="sm" fw={500}>{label}</Text>
      </Grid.Col>
      <Grid.Col span={showAlign ? 3 : 4}>
        <NumberInput
          size="xs"
          label="X"
          value={position.x}
          onChange={(val) => onChange({ ...position, x: Number(val) || 0 })}
          min={0}
          max={400}
        />
      </Grid.Col>
      <Grid.Col span={showAlign ? 3 : 4}>
        <NumberInput
          size="xs"
          label="Y"
          value={position.y}
          onChange={(val) => onChange({ ...position, y: Number(val) || 0 })}
          min={0}
          max={300}
        />
      </Grid.Col>
      {showAlign && (
        <Grid.Col span={3}>
          <Select
            size="xs"
            label="æƒãˆ"
            value={position.align || 'left'}
            onChange={(val) => onChange({ ...position, align: (val as 'left' | 'center' | 'right') || 'left' })}
            data={[
              { value: 'left', label: 'å·¦' },
              { value: 'center', label: 'ä¸­å¤®' },
              { value: 'right', label: 'å³' },
            ]}
          />
        </Grid.Col>
      )}
    </Grid>
  );
}

// ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºå…¥åŠ›ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
function FontSizeInput({
  label,
  value,
  onChange,
}: {
  label: string;
  value: number;
  onChange: (val: number) => void;
}) {
  return (
    <Grid align="center" gutter="xs">
      <Grid.Col span={6}>
        <Text size="sm">{label}</Text>
      </Grid.Col>
      <Grid.Col span={6}>
        <NumberInput
          size="xs"
          value={value}
          onChange={(val) => onChange(Number(val) || 10)}
          min={6}
          max={24}
          suffix="pt"
        />
      </Grid.Col>
    </Grid>
  );
}

export function PrintSettingsEditor() {
  const [settings, setSettings] = useState<PositionsConfig | null>(null);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [hasChanges, setHasChanges] = useState(false);

  const apiBaseUrl = getPublicApiBaseUrl();

  // è¨­å®šã‚’å–å¾—
  const fetchSettings = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const response = await fetch(`${apiBaseUrl}/pedigrees/print-settings`, {
        credentials: 'include',
      });
      if (!response.ok) throw new Error('è¨­å®šã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
      const json = await response.json();
      // APIãƒ¬ã‚¹ãƒãƒ³ã‚¹ã¯ { success: true, data: {...} } å½¢å¼
      const data = json.data || json;
      setSettings(data);
      setHasChanges(false);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼');
    } finally {
      setLoading(false);
    }
  }, [apiBaseUrl]);

  useEffect(() => {
    fetchSettings();
  }, [fetchSettings]);

  // è¨­å®šã‚’æ›´æ–°
  const updateSetting = <K extends keyof PositionsConfig>(
    key: K,
    value: PositionsConfig[K]
  ) => {
    if (!settings) return;
    setSettings({ ...settings, [key]: value });
    setHasChanges(true);
  };

  // ãƒã‚¹ãƒˆã—ãŸè¨­å®šã‚’æ›´æ–°
  const updateNestedSetting = (
    parentKey: string,
    childKey: string,
    value: Position
  ) => {
    if (!settings) return;
    const parent = settings[parentKey as keyof PositionsConfig];
    if (typeof parent === 'object' && parent !== null) {
      setSettings({
        ...settings,
        [parentKey]: {
          ...(parent as Record<string, unknown>),
          [childKey]: value,
        },
      });
      setHasChanges(true);
    }
  };

  // ä¿å­˜
  const handleSave = async () => {
    if (!settings) return;
    setSaving(true);
    try {
      const response = await fetch(`${apiBaseUrl}/pedigrees/print-settings`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(settings),
      });
      if (!response.ok) throw new Error('ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ');
      setHasChanges(false);
      notifications.show({
        title: 'ä¿å­˜å®Œäº†',
        message: 'å°åˆ·è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸ',
        color: 'green',
        icon: <IconCheck size={16} />,
      });
    } catch (err) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: err instanceof Error ? err.message : 'ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ',
        color: 'red',
        icon: <IconAlertCircle size={16} />,
      });
    } finally {
      setSaving(false);
    }
  };

  // ãƒªã‚»ãƒƒãƒˆ
  const handleReset = async () => {
    if (!confirm('è¨­å®šã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ')) return;
    setLoading(true);
    try {
      const response = await fetch(`${apiBaseUrl}/pedigrees/print-settings/reset`, {
        method: 'POST',
        credentials: 'include',
      });
      if (!response.ok) throw new Error('ãƒªã‚»ãƒƒãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ');
      const json = await response.json();
      // APIãƒ¬ã‚¹ãƒãƒ³ã‚¹ã¯ { success: true, data: {...} } å½¢å¼
      const data = json.data || json;
      setSettings(data);
      setHasChanges(false);
      notifications.show({
        title: 'ãƒªã‚»ãƒƒãƒˆå®Œäº†',
        message: 'è¨­å®šã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ',
        color: 'blue',
        icon: <IconRefresh size={16} />,
      });
    } catch (err) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: err instanceof Error ? err.message : 'ãƒªã‚»ãƒƒãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ',
        color: 'red',
        icon: <IconAlertCircle size={16} />,
      });
    } finally {
      setLoading(false);
    }
  };

  if (error) {
    return (
      <Alert icon={<IconAlertCircle size={16} />} title="ã‚¨ãƒ©ãƒ¼" color="red">
        {error}
        <Button mt="sm" size="xs" onClick={fetchSettings}>
          å†èª­ã¿è¾¼ã¿
        </Button>
      </Alert>
    );
  }

  return (
    <Paper p="md" shadow="sm" style={{ position: 'relative' }}>
      <LoadingOverlay visible={loading} overlayProps={{ radius: 'sm', blur: 2 }} />

      <Stack gap="md">
        <Group justify="space-between">
          <Group>
            <Title order={4}>
              <IconAdjustments size={20} style={{ verticalAlign: 'middle', marginRight: 8 }} />
              å°åˆ·ä½ç½®è¨­å®š
            </Title>
            {hasChanges && (
              <Badge color="orange" variant="light">æœªä¿å­˜ã®å¤‰æ›´ã‚ã‚Š</Badge>
            )}
          </Group>
          <Group>
            <Tooltip label="ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«ãƒªã‚»ãƒƒãƒˆ">
              <Button
                variant="light"
                color="gray"
                leftSection={<IconRefresh size={16} />}
                onClick={handleReset}
                disabled={saving}
              >
                ãƒªã‚»ãƒƒãƒˆ
              </Button>
            </Tooltip>
            <Button
              leftSection={<IconDeviceFloppy size={16} />}
              onClick={handleSave}
              loading={saving}
              disabled={!hasChanges}
            >
              ä¿å­˜
            </Button>
          </Group>
        </Group>

        <Text size="sm" c="dimmed">
          è¡€çµ±æ›¸PDFã®å„é …ç›®ã®å°åˆ·ä½ç½®ï¼ˆmmå˜ä½ï¼‰ã¨ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚’èª¿æ•´ã§ãã¾ã™ã€‚
          å¤‰æ›´å¾Œã¯ã€Œä¿å­˜ã€ãƒœã‚¿ãƒ³ã§åæ˜ ã•ã‚Œã¾ã™ã€‚
        </Text>

        {settings && (
          <Accordion variant="separated" defaultValue="global">
            {/* ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚ªãƒ•ã‚»ãƒƒãƒˆ */}
            <Accordion.Item value="global">
              <Accordion.Control>ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®š</Accordion.Control>
              <Accordion.Panel>
                <Stack gap="xs">
                  <Text size="sm" c="dimmed">å…¨ä½“ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆç”¨ç´™ã®ã‚ºãƒ¬è£œæ­£ï¼‰</Text>
                  <Grid>
                    <Grid.Col span={6}>
                      <NumberInput
                        label="X ã‚ªãƒ•ã‚»ãƒƒãƒˆ (mm)"
                        value={settings.offsetX}
                        onChange={(val) => updateSetting('offsetX', Number(val) || 0)}
                      />
                    </Grid.Col>
                    <Grid.Col span={6}>
                      <NumberInput
                        label="Y ã‚ªãƒ•ã‚»ãƒƒãƒˆ (mm)"
                        value={settings.offsetY}
                        onChange={(val) => updateSetting('offsetY', Number(val) || 0)}
                      />
                    </Grid.Col>
                  </Grid>
                </Stack>
              </Accordion.Panel>
            </Accordion.Item>

            {/* ãƒ˜ãƒƒãƒ€ãƒ¼æƒ…å ± */}
            <Accordion.Item value="header">
              <Accordion.Control>ãƒ˜ãƒƒãƒ€ãƒ¼æƒ…å ±</Accordion.Control>
              <Accordion.Panel>
                <Stack gap="sm">
                  <PositionInput
                    label="çŒ«å"
                    position={settings.catName}
                    onChange={(pos) => updateSetting('catName', pos)}
                    showAlign
                  />
                  <PositionInput
                    label="WCAç•ªå·"
                    position={settings.wcaNo}
                    onChange={(pos) => updateSetting('wcaNo', pos)}
                    showAlign
                  />
                  <Divider my="xs" />
                  <PositionInput
                    label="å“ç¨®"
                    position={settings.breed}
                    onChange={(pos) => updateSetting('breed', pos)}
                  />
                  <PositionInput
                    label="æ€§åˆ¥"
                    position={settings.sex}
                    onChange={(pos) => updateSetting('sex', pos)}
                  />
                  <PositionInput
                    label="ç”Ÿå¹´æœˆæ—¥"
                    position={settings.dateOfBirth}
                    onChange={(pos) => updateSetting('dateOfBirth', pos)}
                  />
                  <PositionInput
                    label="æ¯›è‰²"
                    position={settings.color}
                    onChange={(pos) => updateSetting('color', pos)}
                  />
                  <PositionInput
                    label="ç›®è‰²"
                    position={settings.eyeColor}
                    onChange={(pos) => updateSetting('eyeColor', pos)}
                  />
                  <Divider my="xs" />
                  <PositionInput
                    label="ã‚ªãƒ¼ãƒŠãƒ¼"
                    position={settings.owner}
                    onChange={(pos) => updateSetting('owner', pos)}
                    showAlign
                  />
                  <PositionInput
                    label="ãƒ–ãƒªãƒ¼ãƒ€ãƒ¼"
                    position={settings.breeder}
                    onChange={(pos) => updateSetting('breeder', pos)}
                    showAlign
                  />
                  <PositionInput
                    label="ç™»éŒ²æ—¥"
                    position={settings.dateOfRegistration}
                    onChange={(pos) => updateSetting('dateOfRegistration', pos)}
                  />
                  <PositionInput
                    label="åŒè…¹æ•°(â™‚)"
                    position={settings.littersM}
                    onChange={(pos) => updateSetting('littersM', pos)}
                  />
                  <PositionInput
                    label="åŒè…¹æ•°(â™€)"
                    position={settings.littersF}
                    onChange={(pos) => updateSetting('littersF', pos)}
                  />
                </Stack>
              </Accordion.Panel>
            </Accordion.Item>

            {/* ä¸¡è¦ª */}
            <Accordion.Item value="parents">
              <Accordion.Control>ä¸¡è¦ªï¼ˆSire / Damï¼‰</Accordion.Control>
              <Accordion.Panel>
                <Stack gap="md">
                  <Text fw={500}>çˆ¶è¦ªï¼ˆSireï¼‰</Text>
                  <PositionInput
                    label="åå‰"
                    position={settings.sire.name}
                    onChange={(pos) => updateNestedSetting('sire', 'name', pos)}
                  />
                  <PositionInput
                    label="æ¯›è‰²"
                    position={settings.sire.color}
                    onChange={(pos) => updateNestedSetting('sire', 'color', pos)}
                  />
                  <PositionInput
                    label="ç™»éŒ²ç•ªå·"
                    position={settings.sire.jcu}
                    onChange={(pos) => updateNestedSetting('sire', 'jcu', pos)}
                  />

                  <Divider my="xs" />

                  <Text fw={500}>æ¯è¦ªï¼ˆDamï¼‰</Text>
                  <PositionInput
                    label="åå‰"
                    position={settings.dam.name}
                    onChange={(pos) => updateNestedSetting('dam', 'name', pos)}
                  />
                  <PositionInput
                    label="æ¯›è‰²"
                    position={settings.dam.color}
                    onChange={(pos) => updateNestedSetting('dam', 'color', pos)}
                  />
                  <PositionInput
                    label="ç™»éŒ²ç•ªå·"
                    position={settings.dam.jcu}
                    onChange={(pos) => updateNestedSetting('dam', 'jcu', pos)}
                  />
                </Stack>
              </Accordion.Panel>
            </Accordion.Item>

            {/* ç¥–çˆ¶æ¯ */}
            <Accordion.Item value="grandparents">
              <Accordion.Control>ç¥–çˆ¶æ¯</Accordion.Control>
              <Accordion.Panel>
                <Stack gap="md">
                  {(['ff', 'fm', 'mf', 'mm'] as const).map((key) => {
                    const labels: Record<string, string> = {
                      ff: 'çˆ¶æ–¹ç¥–çˆ¶',
                      fm: 'çˆ¶æ–¹ç¥–æ¯',
                      mf: 'æ¯æ–¹ç¥–çˆ¶',
                      mm: 'æ¯æ–¹ç¥–æ¯',
                    };
                    const gp = settings.grandParents[key];
                    return (
                      <div key={key}>
                        <Text fw={500} mb="xs">{labels[key]}</Text>
                        <Stack gap="xs">
                          <PositionInput
                            label="åå‰"
                            position={gp.name}
                            onChange={(pos) => {
                              setSettings({
                                ...settings,
                                grandParents: {
                                  ...settings.grandParents,
                                  [key]: { ...gp, name: pos },
                                },
                              });
                              setHasChanges(true);
                            }}
                          />
                          <PositionInput
                            label="æ¯›è‰²"
                            position={gp.color}
                            onChange={(pos) => {
                              setSettings({
                                ...settings,
                                grandParents: {
                                  ...settings.grandParents,
                                  [key]: { ...gp, color: pos },
                                },
                              });
                              setHasChanges(true);
                            }}
                          />
                          <PositionInput
                            label="ç™»éŒ²ç•ªå·"
                            position={gp.jcu}
                            onChange={(pos) => {
                              setSettings({
                                ...settings,
                                grandParents: {
                                  ...settings.grandParents,
                                  [key]: { ...gp, jcu: pos },
                                },
                              });
                              setHasChanges(true);
                            }}
                          />
                        </Stack>
                        <Divider my="sm" />
                      </div>
                    );
                  })}
                </Stack>
              </Accordion.Panel>
            </Accordion.Item>

            {/* æ›¾ç¥–çˆ¶æ¯ */}
            <Accordion.Item value="greatgrandparents">
              <Accordion.Control>æ›¾ç¥–çˆ¶æ¯</Accordion.Control>
              <Accordion.Panel>
                <Stack gap="md">
                  {(['fff', 'ffm', 'fmf', 'fmm', 'mff', 'mfm', 'mmf', 'mmm'] as const).map((key) => {
                    const labels: Record<string, string> = {
                      fff: 'çˆ¶æ–¹ç¥–çˆ¶ã®çˆ¶',
                      ffm: 'çˆ¶æ–¹ç¥–çˆ¶ã®æ¯',
                      fmf: 'çˆ¶æ–¹ç¥–æ¯ã®çˆ¶',
                      fmm: 'çˆ¶æ–¹ç¥–æ¯ã®æ¯',
                      mff: 'æ¯æ–¹ç¥–çˆ¶ã®çˆ¶',
                      mfm: 'æ¯æ–¹ç¥–çˆ¶ã®æ¯',
                      mmf: 'æ¯æ–¹ç¥–æ¯ã®çˆ¶',
                      mmm: 'æ¯æ–¹ç¥–æ¯ã®æ¯',
                    };
                    const ggp = settings.greatGrandParents[key];
                    return (
                      <div key={key}>
                        <Text fw={500} size="sm" mb="xs">{labels[key]}</Text>
                        <Grid>
                          <Grid.Col span={6}>
                            <PositionInput
                              label="åå‰"
                              position={ggp.name}
                              onChange={(pos) => {
                                setSettings({
                                  ...settings,
                                  greatGrandParents: {
                                    ...settings.greatGrandParents,
                                    [key]: { ...ggp, name: pos },
                                  },
                                });
                                setHasChanges(true);
                              }}
                            />
                          </Grid.Col>
                          <Grid.Col span={6}>
                            <PositionInput
                              label="ç™»éŒ²ç•ªå·"
                              position={ggp.jcu}
                              onChange={(pos) => {
                                setSettings({
                                  ...settings,
                                  greatGrandParents: {
                                    ...settings.greatGrandParents,
                                    [key]: { ...ggp, jcu: pos },
                                  },
                                });
                                setHasChanges(true);
                              }}
                            />
                          </Grid.Col>
                        </Grid>
                      </div>
                    );
                  })}
                </Stack>
              </Accordion.Panel>
            </Accordion.Item>

            {/* ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º */}
            <Accordion.Item value="fonts">
              <Accordion.Control>ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º</Accordion.Control>
              <Accordion.Panel>
                <Stack gap="sm">
                  <FontSizeInput
                    label="çŒ«å"
                    value={settings.fontSizes.catName}
                    onChange={(val) => updateSetting('fontSizes', { ...settings.fontSizes, catName: val })}
                  />
                  <FontSizeInput
                    label="WCAç•ªå·"
                    value={settings.fontSizes.wcaNo}
                    onChange={(val) => updateSetting('fontSizes', { ...settings.fontSizes, wcaNo: val })}
                  />
                  <FontSizeInput
                    label="ãƒ˜ãƒƒãƒ€ãƒ¼æƒ…å ±"
                    value={settings.fontSizes.headerInfo}
                    onChange={(val) => updateSetting('fontSizes', { ...settings.fontSizes, headerInfo: val })}
                  />
                  <FontSizeInput
                    label="è¦ªã®åå‰"
                    value={settings.fontSizes.parentName}
                    onChange={(val) => updateSetting('fontSizes', { ...settings.fontSizes, parentName: val })}
                  />
                  <FontSizeInput
                    label="è¦ªã®è©³ç´°"
                    value={settings.fontSizes.parentDetail}
                    onChange={(val) => updateSetting('fontSizes', { ...settings.fontSizes, parentDetail: val })}
                  />
                  <FontSizeInput
                    label="ç¥–çˆ¶æ¯ã®åå‰"
                    value={settings.fontSizes.grandParentName}
                    onChange={(val) => updateSetting('fontSizes', { ...settings.fontSizes, grandParentName: val })}
                  />
                  <FontSizeInput
                    label="ç¥–çˆ¶æ¯ã®è©³ç´°"
                    value={settings.fontSizes.grandParentDetail}
                    onChange={(val) => updateSetting('fontSizes', { ...settings.fontSizes, grandParentDetail: val })}
                  />
                  <FontSizeInput
                    label="æ›¾ç¥–çˆ¶æ¯"
                    value={settings.fontSizes.greatGrandParent}
                    onChange={(val) => updateSetting('fontSizes', { ...settings.fontSizes, greatGrandParent: val })}
                  />
                  <FontSizeInput
                    label="ãƒ•ãƒƒã‚¿ãƒ¼"
                    value={settings.fontSizes.footer}
                    onChange={(val) => updateSetting('fontSizes', { ...settings.fontSizes, footer: val })}
                  />
                </Stack>
              </Accordion.Panel>
            </Accordion.Item>

            {/* ãã®ä»– */}
            <Accordion.Item value="other">
              <Accordion.Control>ãã®ä»–</Accordion.Control>
              <Accordion.Panel>
                <PositionInput
                  label="ä»–å›£ä½“ç™»éŒ²ç•ªå·"
                  position={settings.otherOrganizationsNo}
                  onChange={(pos) => updateSetting('otherOrganizationsNo', pos)}
                />
              </Accordion.Panel>
            </Accordion.Item>
          </Accordion>
        )}
      </Stack>
    </Paper>
  );
}
````

## File: frontend/src/components/ActionButton.tsx
````typescript
/**
 * CRUDæ“ä½œç”¨ã®çµ±ä¸€ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“ã§ãƒœã‚¿ãƒ³ãƒ‡ã‚¶ã‚¤ãƒ³ã‚’çµ±ä¸€ã™ã‚‹ãŸã‚ã®å…±é€šã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 */

import { Button, ButtonProps, ButtonStylesNames, getThemeColor, MantineColor } from '@mantine/core';
import {
  IconPlus,
  IconEdit,
  IconTrash,
  IconEye,
  IconDeviceFloppy,
  IconX,
  IconCheck,
  IconArrowLeft,
} from '@tabler/icons-react';
import { forwardRef } from 'react';

// ã‚µã‚¤ã‚ºãƒ—ãƒªã‚»ãƒƒãƒˆå‹ã®å®šç¾©
export type ActionButtonSizePreset = 'icon' | 'small' | 'medium' | 'large';

// ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—ã®å®šç¾©
export type ActionType =
  | 'create'
  | 'edit'
  | 'delete'
  | 'view'
  | 'save'
  | 'cancel'
  | 'confirm'
  | 'back';

// ã‚µã‚¤ã‚ºãƒ—ãƒªã‚»ãƒƒãƒˆã®å®šç¾©
const ACTION_BUTTON_SIZE_PRESETS: Record<
  ActionButtonSizePreset,
  { size: ButtonProps['size']; iconSize: number }
> = {
  icon: { size: 'xs', iconSize: 16 },
  small: { size: 'sm', iconSize: 16 },
  medium: { size: 'md', iconSize: 18 },
  large: { size: 'lg', iconSize: 20 },
};

// ã‚µã‚¤ã‚ºãƒ—ãƒªã‚»ãƒƒãƒˆåˆ¥ã®æœ€å°å¹…ï¼ˆpxï¼‰
const ACTION_BUTTON_WIDTH_PRESETS: Record<ActionButtonSizePreset, number> = {
  icon: 40,
  small: 96,
  medium: 112,
  large: 136,
};

// ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—ã”ã¨ã®ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®š
const ACTION_STYLES: Record<
  ActionType,
  {
    variant: ButtonProps['variant'];
    color: MantineColor;
    textColor?: MantineColor;
    borderColor?: MantineColor;
    borderWidth?: number;
    icon: React.ComponentType<{ size?: number | string }>;
    defaultSize: ActionButtonSizePreset;
  }
> = {
  create: {
    variant: 'light',
    color: 'var(--accent)',
    icon: IconPlus,
    defaultSize: 'small',
  },
  edit: {
    variant: 'light',
    color: 'orange',
    icon: IconEdit,
    defaultSize: 'small',
  },
  delete: {
    variant: 'light',
    color: 'red',
    icon: IconTrash,
    defaultSize: 'small',
  },
  view: {
    variant: 'light',
    color: 'gray',
    icon: IconEye,
    defaultSize: 'small',
  },
  save: {
    variant: 'light',
    color: 'var(--accent)',
    icon: IconDeviceFloppy,
    defaultSize: 'small',
  },
  cancel: {
    variant: 'light',
    color: 'gray',
    icon: IconX,
    defaultSize: 'small',
  },
  confirm: {
    variant: 'light',
    color: 'var(--accent)',
    icon: IconCheck,
    defaultSize: 'small',
  },
  back: {
    variant: 'light',
    color: 'gray',
    icon: IconArrowLeft,
    defaultSize: 'small',
  },
};

type ButtonStylesRecord = Partial<Record<ButtonStylesNames, React.CSSProperties>>;

const mergeButtonStyles = (
  baseStyles: ButtonProps['styles'] | undefined,
  overrideStyles: ButtonProps['styles'] | undefined
): ButtonProps['styles'] | undefined => {
  if (!baseStyles) return overrideStyles;
  if (!overrideStyles) return baseStyles;

  return (theme, props, ctx) => {
    const baseRecord: ButtonStylesRecord =
      typeof baseStyles === 'function' ? baseStyles(theme, props, ctx) : baseStyles;
    const overrideRecord: ButtonStylesRecord =
      typeof overrideStyles === 'function' ? overrideStyles(theme, props, ctx) : overrideStyles;

    const styleNames: ButtonStylesNames[] = ['root', 'inner', 'loader', 'section', 'label'];
    const merged: ButtonStylesRecord = {};

    for (const styleName of styleNames) {
      const baseStyle = baseRecord[styleName];
      const overrideStyle = overrideRecord[styleName];
      merged[styleName] = { ...(baseStyle ?? {}), ...(overrideStyle ?? {}) };
    }

    return merged;
  };
};

const createActionButtonOverrideStyles = (params: {
  borderColor?: MantineColor;
  borderWidth?: number;
  textColor?: MantineColor;
  sizePreset?: ActionButtonSizePreset;
}): ButtonProps['styles'] | undefined => {
  const { borderColor, borderWidth, textColor, sizePreset } = params;

  if (!borderColor && borderWidth === undefined && !textColor && !sizePreset) return undefined;

  return (theme) => {
    const resolvedBorderColor = borderColor ? getThemeColor(borderColor, theme) : undefined;
    const resolvedTextColor = textColor ? getThemeColor(textColor, theme) : undefined;
    const minWidth = sizePreset ? ACTION_BUTTON_WIDTH_PRESETS[sizePreset] : undefined;
    const isMobile = typeof window !== 'undefined' && window.innerWidth <= 575;

    const root: React.CSSProperties = {
      ...(resolvedBorderColor ? { borderColor: resolvedBorderColor, borderStyle: 'solid' } : {}),
      ...(borderWidth !== undefined ? { borderWidth, borderStyle: 'solid' } : {}),
      ...(minWidth && !isMobile ? { minWidth: `${minWidth}px` } : {}),
      ...(isMobile && sizePreset !== 'icon' ? { width: '100%' } : {}),
    };

    const label: React.CSSProperties = {
      ...(resolvedTextColor ? { color: resolvedTextColor } : {}),
      ...(sizePreset === 'small' ? { fontSize: '17px' } : {}),
    };

    return {
      root,
      label,
    };
  };
};

export interface ActionButtonProps extends Omit<ButtonProps, 'variant' | 'color' | 'leftSection'> {
  /** ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—ï¼ˆè‡ªå‹•çš„ã«ã‚¹ã‚¿ã‚¤ãƒ«ã¨ã‚¢ã‚¤ã‚³ãƒ³ãŒé©ç”¨ã•ã‚Œã‚‹ï¼‰ */
  action: ActionType;
  /** ã‚µã‚¤ã‚ºãƒ—ãƒªã‚»ãƒƒãƒˆï¼ˆicon/small/medium/largeï¼‰ */
  sizePreset?: ActionButtonSizePreset;
  /** ã‚¢ã‚¤ã‚³ãƒ³ã®ã‚µã‚¤ã‚ºï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: ãƒ—ãƒªã‚»ãƒƒãƒˆã«å¿œã˜ã‚‹ï¼‰ */
  iconSize?: number;
  /** ã‚¢ã‚¤ã‚³ãƒ³ã‚’è¡¨ç¤ºã—ãªã„å ´åˆã¯true */
  hideIcon?: boolean;
  /** ã‚«ã‚¹ã‚¿ãƒ ã‚¢ã‚¤ã‚³ãƒ³ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆï¼ˆã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå‹ã¾ãŸã¯ReactNodeï¼‰ */
  customIcon?: React.ComponentType<{ size?: number | string }> | React.ReactNode;
  /** ãƒœã‚¿ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®è‰²ï¼ˆMantineãƒ†ãƒ¼ãƒã‚«ãƒ©ãƒ¼ or CSSã‚«ãƒ©ãƒ¼ï¼‰ */
  textColor?: MantineColor;
  /** æ ç·šã®è‰²ï¼ˆMantineãƒ†ãƒ¼ãƒã‚«ãƒ©ãƒ¼ or CSSã‚«ãƒ©ãƒ¼ï¼‰ */
  borderColor?: MantineColor;
  /** æ ç·šã®å¤ªã•ï¼ˆpxï¼‰ */
  borderWidth?: number;
  /** ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯æ™‚ã®ãƒãƒ³ãƒ‰ãƒ© */
  onClick?: React.MouseEventHandler<HTMLButtonElement>;
  /** ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ */
  loading?: boolean;
  /** ã‚»ã‚¯ã‚·ãƒ§ãƒ³å†…ã®ä¸»è¦ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¨ã—ã¦ã‚µã‚¤ã‚ºã‚’å¼·åˆ¶çµ±ä¸€ã™ã‚‹ã‹ (md) */
  isSectionAction?: boolean;
  /** ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ç”¨ã®ã‚¿ã‚¤ãƒˆãƒ« */
  title?: string;
}

/**
 * CRUDæ“ä½œç”¨ã®çµ±ä¸€ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³
 * 
 * @example
 * ```tsx
 * // ä½œæˆãƒœã‚¿ãƒ³
 * <ActionButton action="create" onClick={handleCreate}>
 *   æ–°è¦ç™»éŒ²
 * </ActionButton>
 * 
 * // ç·¨é›†ãƒœã‚¿ãƒ³
 * <ActionButton action="edit" onClick={handleEdit}>
 *   ç·¨é›†
 * </ActionButton>
 * 
 * // å‰Šé™¤ãƒœã‚¿ãƒ³ï¼ˆç¢ºèªã‚ã‚Šï¼‰
 * <ActionButton action="delete" onClick={handleDelete}>
 *   å‰Šé™¤
 * </ActionButton>
 * ```
 */
export const ActionButton = forwardRef<HTMLButtonElement, ActionButtonProps>(
  (
    {
      action,
      sizePreset: inputSizePreset,
      iconSize: inputIconSize,
      hideIcon = false,
      customIcon,
      children,
      textColor,
      borderColor,
      borderWidth,
      loading,
      styles: buttonStyles,
      disabled,
      isSectionAction,
      ...props
    },
    ref
  ) => {
    const style = ACTION_STYLES[action];
    const resolvedSizePreset = inputSizePreset ?? style.defaultSize;
    const presetConfig = ACTION_BUTTON_SIZE_PRESETS[resolvedSizePreset];
    const effectiveIconSize = inputIconSize ?? presetConfig.iconSize;

    // customIconãŒReactNodeã®å ´åˆã¯ãã®ã¾ã¾ä½¿ç”¨ã€ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå‹ã®å ´åˆã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–
    const Icon = typeof customIcon === 'function' && 'prototype' in customIcon 
      ? (customIcon as React.ComponentType<{ size?: number | string }>)
      : style.icon;

    const effectiveTextColor = textColor ?? style.textColor;
    const effectiveBorderColor = borderColor ?? style.borderColor;
    const effectiveBorderWidth = borderWidth ?? style.borderWidth;
    const overrideStyles = createActionButtonOverrideStyles({
      borderColor: effectiveBorderColor,
      borderWidth: effectiveBorderWidth,
      textColor: effectiveTextColor,
      sizePreset: resolvedSizePreset,
    });
    const mergedStyles = mergeButtonStyles(buttonStyles, overrideStyles);

    const effectiveDisabled = disabled === true || loading === true;
    const leftSection = hideIcon 
      ? undefined 
      : (typeof customIcon === 'object' && customIcon !== null && !('prototype' in customIcon)
          ? customIcon as React.ReactNode
          : <Icon size={effectiveIconSize} />);

    return (
      <Button
        ref={ref}
        variant={style.variant}
        color={style.color}
        size={isSectionAction ? 'md' : (props.size || presetConfig.size)}
        leftSection={leftSection}
        styles={mergedStyles}
        loading={loading}
        disabled={effectiveDisabled}
        aria-busy={loading ? true : undefined}
        {...props}
      >
        {children}
      </Button>
    );
  }
);

ActionButton.displayName = 'ActionButton';

/**
 * ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¢ã‚¤ã‚³ãƒ³ãƒœã‚¿ãƒ³ï¼ˆå°ã•ã„ãƒœã‚¿ãƒ³ç”¨ï¼‰
 * ãƒ†ãƒ¼ãƒ–ãƒ«ã®è¡Œã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãªã©ã«ä½¿ç”¨
 */
export interface ActionIconButtonProps extends Omit<ButtonProps, 'variant' | 'color'> {
  action: ActionType;
  sizePreset?: ActionButtonSizePreset;
  iconSize?: number;
  /** ã‚«ã‚¹ã‚¿ãƒ ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå‹ã€ReactNodeã€ã¾ãŸã¯é–¢æ•°ï¼‰ */
  customIcon?: React.ComponentType<{ size?: number | string }> | React.ReactNode | (() => React.ReactNode);
  /** æ ç·šã®è‰²ï¼ˆMantineãƒ†ãƒ¼ãƒã‚«ãƒ©ãƒ¼ or CSSã‚«ãƒ©ãƒ¼ï¼‰ */
  borderColor?: MantineColor;
  /** æ ç·šã®å¤ªã•ï¼ˆpxï¼‰ */
  borderWidth?: number;
  /** ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯æ™‚ã®ãƒãƒ³ãƒ‰ãƒ© */
  onClick?: React.MouseEventHandler<HTMLButtonElement>;
  /** ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ç”¨ã®ã‚¿ã‚¤ãƒˆãƒ« */
  title?: string;
}

export const ActionIconButton = forwardRef<HTMLButtonElement, ActionIconButtonProps>(
  (
    {
      action,
      sizePreset = 'icon',
      iconSize: inputIconSize,
      customIcon,
      borderColor,
      borderWidth,
      loading,
      styles: buttonStyles,
      disabled,
      ...props
    },
    ref
  ) => {
    const style = ACTION_STYLES[action];
    const presetConfig = ACTION_BUTTON_SIZE_PRESETS[sizePreset];
    const effectiveIconSize = inputIconSize ?? presetConfig.iconSize;

    // customIconã®å‹ã«å¿œã˜ã¦é©åˆ‡ã«å‡¦ç†
    let iconContent: React.ReactNode;
    if (typeof customIcon === 'function') {
      // é–¢æ•°ã®å ´åˆã¯å®Ÿè¡Œ
      if ('prototype' in customIcon) {
        // ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå‹
        const Icon = customIcon as React.ComponentType<{ size?: number | string }>;
        iconContent = <Icon size={effectiveIconSize} />;
      } else {
        // é–¢æ•°ã¨ã—ã¦å®Ÿè¡Œï¼ˆå‹ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã§æ˜ç¤ºçš„ã«å‹ã‚’æŒ‡å®šï¼‰
        iconContent = (customIcon as () => React.ReactNode)();
      }
    } else if (customIcon && typeof customIcon === 'object' && !('prototype' in customIcon)) {
      // ReactNode
      iconContent = customIcon;
    } else {
      // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¢ã‚¤ã‚³ãƒ³
      const Icon = style.icon;
      iconContent = <Icon size={effectiveIconSize} />;
    }

    const effectiveBorderColor = borderColor ?? style.borderColor;
    const effectiveBorderWidth = borderWidth ?? style.borderWidth;
    const overrideStyles = createActionButtonOverrideStyles({
      borderColor: effectiveBorderColor,
      borderWidth: effectiveBorderWidth,
      sizePreset,
    });
    const mergedStyles = mergeButtonStyles(buttonStyles, overrideStyles);

    const effectiveDisabled = disabled === true || loading === true;

    return (
      <Button
        ref={ref}
        variant="light"
        color={style.color}
        size="xs"
        p={4}
        styles={mergedStyles}
        loading={loading}
        disabled={effectiveDisabled}
        aria-busy={loading ? true : undefined}
        {...props}
      >
        {iconContent}
      </Button>
    );
  }
);

ActionIconButton.displayName = 'ActionIconButton';
````

## File: frontend/src/components/AppLayout.tsx
````typescript
'use client';

import {
  AppShell,
  Avatar,
  Badge,
  Burger,
  Group,
  ScrollArea,
  Text,
  NavLink,
  Center,
  Loader,
  Box,
  Stack,
  Button,
} from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { useCallback, useEffect, useMemo, useState } from 'react';
import { usePathname, useRouter, useSearchParams } from 'next/navigation';
import Link from 'next/link';
import '@/styles/page-header.css';
import {
  IconPaw,
  IconList,
  IconHeart,
  IconBabyCarriage,
  IconTag,
  IconCertificate,
  IconLogout,
  IconPalette,
  IconCalendarEvent,
  IconCalendarTime,
  IconSettings,
  IconHome,
  IconCat,
  IconStethoscope,
  IconHeartHandshake,
  IconPhoto,
  IconUsers,
} from '@tabler/icons-react';
import { useAuth } from '@/lib/auth/store';
import { isAuthRoute, isProtectedRoute } from '@/lib/auth/routes';
import { notifications } from '@mantine/notifications';
import { usePageHeader } from '@/lib/contexts/page-header-context';
import { ContextMenuManager } from '@/components/context-menu';
import { apiClient, type ApiQueryParams } from '@/lib/api/client';
import type { Cat } from '@/lib/api/hooks/use-cats';
import { useBottomNavSettings } from '@/lib/hooks/use-bottom-nav-settings';

const navigationItems = [
  {
    label: 'æ–°è¦çŒ«ç™»éŒ²',
    href: '/cats/new',
    icon: IconPaw,
  },
  {
    label: 'åœ¨èˆçŒ«ä¸€è¦§',
    href: '/cats',
    icon: IconList,
  },
  {
    label: 'äº¤é…ç®¡ç†',
    href: '/breeding',
    icon: IconHeart,
  },
  {
    label: 'å­çŒ«ç®¡ç†',
    href: '/kittens',
    icon: IconBabyCarriage,
  },
  {
    label: 'ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«',
    href: '/care',
    icon: IconCalendarEvent,
  },
  {
    label: 'åŒ»ç™‚ãƒ‡ãƒ¼ã‚¿',
    href: '/medical-records',
    icon: IconStethoscope,
  },
  {
    label: 'ã‚¿ã‚°ç®¡ç†',
    href: '/tags',
    icon: IconTag,
  },
  {
    label: 'è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿',
    href: '/pedigrees',
    icon: IconCertificate,
  },
  {
    label: 'ã‚¹ã‚¿ãƒƒãƒ•ã‚·ãƒ•ãƒˆ',
    href: '/staff/shifts',
    icon: IconCalendarTime,
  },
  {
    label: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®š',
    href: '/tenants',
    icon: IconUsers,
  },
  {
    label: 'è¡¨ç¤ºè¨­å®š',
    href: '/settings',
    icon: IconSettings,
  },
  {
    label: 'ãã®ä»–',
    href: '/more',
    icon: IconSettings,
  },
  {
    label: 'ã‚®ãƒ£ãƒ©ãƒªãƒ¼',
    href: '/gallery',
    icon: IconPhoto,
  },
  {
    label: 'ãƒ‡ã‚¶ã‚¤ãƒ³ã‚¬ã‚¤ãƒ‰',
    href: '/demo/action-buttons',
    icon: IconPalette,
  },
];

interface AppLayoutProps {
  children: React.ReactNode;
}

export const bottomNavigationItems = [
  { id: 'home', label: 'ãƒ›ãƒ¼ãƒ ', href: '/', icon: IconHome },
  { id: 'cats', label: 'åœ¨èˆçŒ«', href: '/cats', icon: IconCat },
  { id: 'breeding', label: 'äº¤é…', href: '/breeding', icon: IconHeartHandshake },
  { id: 'kittens', label: 'å­çŒ«', href: '/kittens', icon: IconPaw },
  { id: 'care', label: 'ã‚±ã‚¢', href: '/care', icon: IconStethoscope },
  { id: 'medical', label: 'åŒ»ç™‚', href: '/medical-records', icon: IconStethoscope },
  { id: 'tags', label: 'ã‚¿ã‚°', href: '/tags', icon: IconTag },
  { id: 'pedigrees', label: 'è¡€çµ±æ›¸', href: '/pedigrees', icon: IconCertificate },
  { id: 'more', label: 'ãã®ä»–', href: '/more', icon: IconSettings },
];

// çŒ«ã®çµ±è¨ˆæƒ…å ±ã®å‹
interface CatStats {
  male: number;
  female: number;
  kittens: number;
  graduated: number;
}

export function AppLayout({ children }: AppLayoutProps) {
  const pathname = usePathname() ?? '/';
  const searchParams = useSearchParams();
  const router = useRouter();
  const { pageTitle, pageActions } = usePageHeader();
  const [catStats, setCatStats] = useState<CatStats>({ male: 0, female: 0, kittens: 0, graduated: 0 });

  // ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ­ã‚°
  console.log('AppLayout pageTitle:', pageTitle);
  console.log('AppLayout pageActions:', pageActions);
  // ä¸¡æ–¹ã¨ã‚‚åˆæœŸçŠ¶æ…‹ã¯é–‰ã˜ãŸçŠ¶æ…‹ã«å¤‰æ›´ï¼ˆé·ç§»ã§è‡ªå‹•çš„ã«é–‰ã˜ã‚‹ä»•æ§˜ï¼‰
  const [mobileOpened, { toggle: toggleMobile, close: closeMobile }] = useDisclosure(false);
  const [desktopOpened, { toggle: toggleDesktop, close: closeDesktop }] = useDisclosure(false);
  const { user, isAuthenticated, initialized, isLoading, logout } = useAuth();
  const [logoutLoading, setLogoutLoading] = useState(false);

  const isAuthPage = isAuthRoute(pathname);
  const requiresAuth = isProtectedRoute(pathname);
  const search = searchParams?.toString() ?? '';
  const targetPath = search ? `${pathname}?${search}` : pathname;

  const accountLabel = useMemo(() => {
    if (!user) {
      return 'ã‚²ã‚¹ãƒˆ';
    }
    const name = [user.lastName, user.firstName].filter(Boolean).join(' ');
    return name || user.email || 'ãƒ¦ãƒ¼ã‚¶ãƒ¼';
  }, [user]);

  const accountInitials = useMemo(() => {
    if (!user) {
      return 'MC';
    }
    const nameSeed = `${user.lastName ?? ''}${user.firstName ?? ''}`.trim();
    if (nameSeed) {
      return nameSeed.slice(0, 2).toUpperCase();
    }
    const emailSeed = (user.email ?? '').replace('@', '');
    return emailSeed.slice(0, 2).toUpperCase() || 'MC';
  }, [user]);

  // å°†æ¥ä½¿ç”¨äºˆå®šã®ãƒ­ãƒ¼ãƒ«ãƒ©ãƒ™ãƒ«
  // const roleLabel = useMemo(() => {
  //   if (!user?.role) {
  //     return null;
  //   }
  //   const mapping: Record<string, string> = {
  //     ADMIN: 'ç®¡ç†è€…',
  //     USER: 'ä¸€èˆ¬',
  //     SUPER_ADMIN: 'ã‚¹ãƒ¼ãƒ‘ãƒ¼ç®¡ç†è€…',
  //   };
  //   return mapping[user.role] ?? user.role;
  // }, [user]);

  const accountEmail = user?.email ?? '';

  const handleLogout = useCallback(async () => {
    if (logoutLoading) {
      return;
    }
    setLogoutLoading(true);
    try {
      await logout();
      notifications.show({
        title: 'ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ',
        message: 'ã¾ãŸã®ã”åˆ©ç”¨ã‚’ãŠå¾…ã¡ã—ã¦ã„ã¾ã™ã€‚',
        color: 'teal',
      });
      const params = new URLSearchParams();
      if (targetPath && targetPath !== '/') {
        params.set('returnTo', targetPath);
      }
      const nextUrl = params.size > 0 ? `/login?${params.toString()}` : '/login';
      router.replace(nextUrl);
    } catch (error) {
      const message = error instanceof Error ? error.message : 'å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚';
      notifications.show({
        title: 'ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ',
        message,
        color: 'red',
      });
      setLogoutLoading(false);
    }
  }, [logout, logoutLoading, router, targetPath]);

  useEffect(() => {
    if (!initialized) return;
    if (isAuthPage && isAuthenticated) {
      router.replace('/');
    }
  }, [initialized, isAuthPage, isAuthenticated, router]);

  useEffect(() => {
    if (!initialized) return;
    if (requiresAuth && !isAuthenticated) {
      const params = new URLSearchParams();
      params.set('returnTo', targetPath);
      router.replace(`/login?${params.toString()}`);
    }
  }, [initialized, requiresAuth, isAuthenticated, router, targetPath]);

  // ãƒ«ãƒ¼ãƒˆé·ç§»æ¤œçŸ¥ã§ã‚µã‚¤ãƒ‰ãƒãƒ¼è‡ªå‹•æŠ˜ã‚ŠãŸãŸã¿
  useEffect(() => {
    if (!requiresAuth) {
      return;
    }
    closeMobile();
    closeDesktop();
  }, [pathname, requiresAuth, closeMobile, closeDesktop]);

  // çŒ«ã®çµ±è¨ˆæƒ…å ±ã‚’å–å¾—
  useEffect(() => {
    const fetchCatStats = async () => {
      if (!isAuthenticated || !initialized) {
        return;
      }

      try {
        const catListQuery: ApiQueryParams<'/cats', 'get'> = { limit: 1000 };
        const response = await apiClient.get('/cats', {
          query: catListQuery,
        });

        if (response.success && Array.isArray(response.data)) {
          const cats = response.data as Cat[];
          const today = new Date();
          
          // åœ¨èˆçŒ«ã®ã¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿
          const inHouseCats = cats.filter((cat) => cat.isInHouse);
          
          // å­çŒ«åˆ¤å®šé–¢æ•°ï¼ˆ6ãƒ¶æœˆæœªæº€ï¼‰
          const isKittenFunc = (cat: Cat) => {
            if (!cat.birthDate) return false;
            const birthDate = new Date(cat.birthDate);
            const ageInMonths = (today.getFullYear() - birthDate.getFullYear()) * 12 + (today.getMonth() - birthDate.getMonth());
            return ageInMonths < 6;
          };
          
          // å¤§äººã®çŒ«ï¼ˆå­çŒ«ä»¥å¤–ï¼‰
          const adultCats = inHouseCats.filter((cat) => !isKittenFunc(cat));
          
          // å­çŒ«ï¼ˆ90æ—¥æœªæº€ã§æ¯çŒ«IDã‚’æŒã¤ï¼‰
          const kittens = inHouseCats.filter((cat) => {
            if (!cat.birthDate || !cat.motherId) return false;
            const birthDate = new Date(cat.birthDate);
            const ageInDays = Math.floor((today.getTime() - birthDate.getTime()) / (1000 * 60 * 60 * 24));
            return ageInDays < 90;
          });
          
          // å’æ¥­äºˆå®šã®çŒ«ï¼ˆã€Œå’æ¥­äºˆå®šã€ã‚¿ã‚°ã‚’æŒã¤çŒ«ï¼‰
          const graduatedCats = inHouseCats.filter((cat) => 
            cat.tags?.some((catTag) => catTag.tag.name === 'å’æ¥­äºˆå®š')
          );
          
          // çµ±è¨ˆã‚’è¨ˆç®—
          const stats: CatStats = {
            male: adultCats.filter((cat) => cat.gender === 'MALE').length,
            female: adultCats.filter((cat) => cat.gender === 'FEMALE').length,
            kittens: kittens.length,
            graduated: graduatedCats.length,
          };
          
          setCatStats(stats);
        }
      } catch (error) {
        console.error('çµ±è¨ˆæƒ…å ±ã®å–å¾—ã«å¤±æ•—:', error);
      }
    };

    fetchCatStats();
    
    // 5åˆ†ã”ã¨ã«æ›´æ–°
    const interval = setInterval(fetchCatStats, 5 * 60 * 1000);
    return () => clearInterval(interval);
  }, [isAuthenticated, initialized]);

  if (!initialized || (requiresAuth && isLoading)) {
    return <FullScreenLoader />;
  }

  if (isAuthPage && isAuthenticated) {
    return <FullScreenLoader />;
  }

  if (requiresAuth && !isAuthenticated) {
    return <FullScreenLoader />;
  }

  if (!requiresAuth) {
    return (
      <div className="theme-default" style={{ minHeight: '100vh' }}>
        {children}
      </div>
    );
  }

  return (
    <div className="theme-default">
    <ContextMenuManager>
    <AppShell
      header={{ height: 60 }}
      navbar={{
        width: 280,
        breakpoint: 'sm',
        collapsed: { mobile: !mobileOpened, desktop: !desktopOpened },
      }}
      padding="0"
      styles={(_theme) => ({
        header: {
          backgroundColor: 'transparent',
          borderBottom: 'var(--border-width, 1px) solid var(--glass-border, var(--border-subtle, rgba(255, 255, 255, 0.3)))',
        },
        navbar: {
          backgroundColor: 'transparent',
          borderRight: 'var(--border-width, 1px) solid var(--glass-border, var(--border-subtle, rgba(255, 255, 255, 0.3)))',
        },
        main: {
          backgroundColor: 'transparent',
        },
      })}
    >
      <AppShell.Header className="glass-effect" style={{ borderTop: 'none', borderLeft: 'none', borderRight: 'none', borderRadius: 0, display: 'flex', justifyContent: 'center' }}>
        <Group
          h="100%"
          px="var(--layout-px)"
          justify="space-between"
          wrap="nowrap"
          style={{ color: 'var(--text-primary)', width: '100%', maxWidth: 'var(--container-max-width)' }}
        >
          <Group gap="sm" wrap="nowrap" style={{ flex: '1 1 auto', minWidth: 0 }}>
            <Burger
              opened={mobileOpened}
              onClick={toggleMobile}
              hiddenFrom="sm"
              size="sm"
              color="var(--text-primary)"
            />
            <Burger
              opened={desktopOpened}
              onClick={toggleDesktop}
              visibleFrom="sm"
              size="sm"
              color="var(--text-primary)"
            />
            <Group gap={12} wrap="nowrap" style={{ minWidth: 0 }}>
              <Text 
                fw={800} 
                visibleFrom="sm"
                style={{ 
                  color: 'var(--accent)', 
                  fontSize: 20, 
                  display: 'flex', 
                  alignItems: 'center', 
                  gap: 8, 
                  whiteSpace: 'nowrap',
                  letterSpacing: '-0.03em'
                }}
              >
                <span style={{ fontSize: '1.6rem', lineHeight: 1 }}>ğŸˆ</span> MyCats
              </Text>
              {pageTitle && (
                <>
                  <div style={{ width: 1, height: 24, backgroundColor: 'var(--text-muted)', opacity: 0.3, transform: 'rotate(15deg)' }} />
                  <Text fw={700} size="md" style={{ color: 'var(--text-primary)', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}>
                    {pageTitle}
                  </Text>
                </>
              )}
            </Group>
          </Group>
          
          <Group gap="xs" wrap="nowrap" style={{ flex: '0 0 auto' }}>
            <Badge 
              color="blue" 
              size="lg" 
              style={{ cursor: 'pointer' }}
              onClick={() => router.push('/cats?tab=male')}
            >
              â™‚ {catStats.male}
            </Badge>
            <Badge 
              color="pink" 
              size="lg" 
              style={{ cursor: 'pointer' }}
              onClick={() => router.push('/cats?tab=female')}
            >
              â™€ {catStats.female}
            </Badge>
            <Badge 
              color="orange" 
              size="lg" 
              style={{ cursor: 'pointer' }}
              onClick={() => router.push('/cats?tab=kitten')}
            >
              ğŸ¾ {catStats.kittens}
            </Badge>
            <Badge 
              color="green" 
              size="lg" 
              style={{ cursor: 'pointer' }}
              onClick={() => router.push('/cats?tab=grad')}
            >
              ğŸ“ {catStats.graduated}
            </Badge>
          </Group>
          
          {pageActions && <div className="page-actions-container">{pageActions}</div>}
        </Group>
      </AppShell.Header>

      <AppShell.Navbar p="md" className="glass-effect" style={{ borderTop: 'none', borderBottom: 'none', borderLeft: 'none', borderRadius: 0 }}>
        {/* ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚»ã‚¯ã‚·ãƒ§ãƒ³ */}
        {isAuthenticated && user && (
          <AppShell.Section mb="xl">
            <Box 
              style={{ 
                background: 'rgba(255, 255, 255, 0.1)', 
                borderRadius: 'var(--radius-base, 20px)', 
                padding: 16,
                border: '1px solid var(--glass-border, rgba(255, 255, 255, 0.2))'
              }}
            >
              <Group gap="sm" wrap="nowrap">
                <Avatar radius="xl" size={44} color="blue" variant="filled" style={{ boxShadow: '0 4px 12px rgba(0,0,0,0.1)' }}>
                  {accountInitials}
                </Avatar>
                <Stack gap={0} style={{ flex: 1, minWidth: 0 }}>
                  <Text size="sm" fw={700} lineClamp={1} style={{ color: 'var(--text-primary)' }}>
                    {accountLabel}
                  </Text>
                  <Text size="xs" c="dimmed" lineClamp={1}>
                    {accountEmail}
                  </Text>
                </Stack>
              </Group>
              <Button
                variant="subtle"
                color="red"
                size="compact-xs"
                fullWidth
                mt="md"
                leftSection={<IconLogout size={14} />}
                onClick={handleLogout}
                loading={logoutLoading}
                radius="md"
              >
                ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ
              </Button>
            </Box>
          </AppShell.Section>
        )}

        <AppShell.Section grow component={ScrollArea}>
          <Stack gap={4}>
            {navigationItems.map((item) => {
              const Icon = item.icon;
              const isActive = pathname === item.href;
              
              return (
                <NavLink
                  key={item.href}
                  component={Link}
                  href={item.href}
                  label={item.label}
                  leftSection={<Icon size={20} stroke={1.5} />}
                  active={isActive}
                  onClick={() => {
                    if (mobileOpened) toggleMobile();
                  }}
                  styles={{
                    root: {
                      borderRadius: 'calc(var(--radius-base, 12px) * 0.6)',
                      padding: '10px 12px',
                      backgroundColor: isActive ? 'var(--accent-soft)' : 'transparent',
                      color: isActive ? 'var(--accent)' : 'var(--text-secondary)',
                      transition: 'all 0.2s ease',
                      border: isActive ? '1px solid var(--accent)' : '1px solid transparent',
                    },
                    label: {
                      fontWeight: isActive ? 700 : 500,
                    },
                  }}
                />
              );
            })}
          </Stack>
        </AppShell.Section>
      </AppShell.Navbar>

      <AppShell.Main style={{ paddingBottom: 100 }}>
        <Box 
          px="var(--layout-px)" 
          style={{ 
            maxWidth: 'var(--container-max-width)', 
            margin: '0 auto',
            width: '100%',
            /* Theme-specific responsive adjustments */
            paddingTop: 'var(--section-gap, 24px)',
          }}
        >
          {children}
        </Box>
        <BottomNavigation pathname={pathname} />
      </AppShell.Main>
    </AppShell>
    </ContextMenuManager>
    </div>
  );
}

function BottomNavigation({ pathname }: { pathname: string }) {
  const { visibleItems, isLoading } = useBottomNavSettings(bottomNavigationItems);

  if (isLoading) return null;

  return (
    <Box
      component="footer"
      className="glass-effect"
      style={{
        position: 'fixed',
        left: '50%',
        transform: 'translateX(-50%)',
        bottom: 20,
        width: 'calc(100% - 40px)',
        maxWidth: 600,
        height: 72,
        borderRadius: 36,
        zIndex: 100,
        padding: '0 20px',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-around',
        border: '1px solid rgba(255, 255, 255, 0.5)',
      }}
    >
      {visibleItems.map((item) => {
        const isActive = pathname === item.href || pathname.startsWith(`${item.href}/`);
        const IconComponent = item.icon;
        return (
          <Box
            key={item.href}
            component={Link}
            href={item.href}
            style={{
              textAlign: 'center',
              textDecoration: 'none',
              color: isActive ? 'var(--accent)' : 'var(--text-muted)',
              display: 'flex',
              flexDirection: 'column',
              alignItems: 'center',
              justifyContent: 'center',
              position: 'relative',
              transition: 'all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)',
              transform: isActive ? 'scale(1.1) translateY(-4px)' : 'scale(1)',
            }}
          >
            {isActive && (
              <Box 
                style={{ 
                  position: 'absolute', 
                  top: -8, 
                  width: 4, 
                  height: 4, 
                  borderRadius: '50%', 
                  backgroundColor: 'var(--accent)',
                  boxShadow: '0 0 8px var(--accent)'
                }} 
              />
            )}
            <IconComponent size={24} stroke={isActive ? 2 : 1.5} />
            <Text
              size="10px"
              style={{
                color: isActive ? 'var(--accent)' : 'var(--text-muted)',
                fontWeight: isActive ? 700 : 500,
                marginTop: 4,
              }}
            >
              {item.label}
            </Text>
          </Box>
        );
      })}
    </Box>
  );
}

function FullScreenLoader() {
  return (
    <Center h="100vh" w="100%">
      <Loader size="lg" color="blue" />
    </Center>
  );
}
````

## File: frontend/src/components/TagSelector.tsx
````typescript
'use client';

import { useEffect, useMemo, type CSSProperties } from 'react';
import {
  MultiSelect,
  Badge,
  Group,
  Box,
  Text,
  Stack,
  Card,
  Button,
  SimpleGrid,
  Tooltip,
  Loader,
  Center,
} from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { IconPlus, IconWand } from '@tabler/icons-react';

import {
  useGetTagCategories,
  type TagCategoryFilters,
  type TagCategoryView,
  type TagView,
} from '@/lib/api/hooks/use-tags';
import { UnifiedModal } from '@/components/common';

interface TagSelectorProps {
  selectedTags: string[];
  onChange: (tagIds: string[]) => void;
  placeholder?: string;
  label?: string;
  disabled?: boolean;
  filters?: TagCategoryFilters;
  categories?: TagCategoryView[];
  autoAssignments?: Record<string, AutomationMeta>;
  showAutomationBadges?: boolean;
}

interface AutomationMeta {
  ruleName?: string;
  source?: string;
  assignedAt?: string;
  reason?: string;
}

function getBadgeColors(tag: TagView, isAutomated?: boolean): CSSProperties {
  const baseStyle: CSSProperties = {};
  
  if (tag.color) {
    // è‡ªå‹•ä»˜ä¸ã‚¿ã‚°ã¯èƒŒæ™¯ã‚’å°‘ã—è–„ã
    baseStyle.backgroundColor = isAutomated ? `${tag.color}15` : `${tag.color}20`;
    baseStyle.color = tag.color;
  } else {
    baseStyle.color = 'var(--mantine-color-white)';
    baseStyle.backgroundColor = 'var(--mantine-primary-color-filled)';
  }

  // è‡ªå‹•ä»˜ä¸ã‚¿ã‚°ã®å ´åˆã¯é»’ã®å¤ªã„ç ´ç·šãƒœãƒ¼ãƒ€ãƒ¼ã§åŒºåˆ¥
  if (isAutomated) {
    baseStyle.border = '3px dashed #000000';
    baseStyle.borderStyle = 'dashed';
    baseStyle.borderWidth = '3px';
    baseStyle.borderColor = '#000000';
    baseStyle.opacity = 0.85;
  } else {
    // æ‰‹å‹•ä»˜ä¸ã‚¿ã‚°ã¯ãƒœãƒ¼ãƒ€ãƒ¼ãªã—
    baseStyle.border = 'none';
    baseStyle.borderWidth = '0';
  }

  return baseStyle;
}

function useResolvedCategories(categories?: TagCategoryView[], filters?: TagCategoryFilters) {
  const shouldFetch = !categories;
  const { data, isLoading } = useGetTagCategories(filters, {
    enabled: shouldFetch,
  });

  const resolved = useMemo(() => {
    if (categories) {
      return categories;
    }
    return data?.data ?? [];
  }, [categories, data]);

  return {
    categories: resolved,
    isLoading: shouldFetch ? isLoading : false,
  };
}

function extractAutomationMeta(tag: TagView): AutomationMeta | null {
  if (!tag.metadata || typeof tag.metadata !== 'object') {
    return null;
  }

  const metadata = tag.metadata as Record<string, unknown>;
  const automation = metadata.automation;

  if (!automation || typeof automation !== 'object') {
    return null;
  }

  const automationObj = automation as Record<string, unknown>;

  const result: AutomationMeta = {
    ruleName: typeof automationObj.ruleName === 'string' ? automationObj.ruleName : undefined,
    source: typeof automationObj.source === 'string' ? automationObj.source : undefined,
    assignedAt: typeof automationObj.assignedAt === 'string' ? automationObj.assignedAt : undefined,
    reason: typeof automationObj.reason === 'string' ? automationObj.reason : undefined,
  };

  return Object.values(result).some(Boolean) ? result : null;
}

function renderAutomationBadge(meta: AutomationMeta | null | undefined) {
  if (!meta) {
    return null;
  }

  const tooltip = [meta.ruleName, meta.reason, meta.source, meta.assignedAt]
    .filter(Boolean)
    .join(' / ');

  const badge = (
    <Group gap={4} align="center" wrap="nowrap" style={{ fontSize: 11 }}>
      <IconWand size={12} />
      <Text span>è‡ªå‹•</Text>
    </Group>
  );

  return tooltip ? (
    <Tooltip label={tooltip} withArrow multiline withinPortal>
      {badge}
    </Tooltip>
  ) : (
    badge
  );
}

export default function TagSelector({
  selectedTags,
  onChange,
  placeholder = 'ã‚¿ã‚°ã‚’é¸æŠ',
  label = 'ã‚¿ã‚°',
  disabled = false,
  filters,
  categories: categoriesProp,
  autoAssignments,
  showAutomationBadges = true,
}: TagSelectorProps) {
  const [opened, { open, close }] = useDisclosure(false);
  const { categories, isLoading } = useResolvedCategories(categoriesProp, filters);

  useEffect(() => {
    if (disabled && opened) {
      close();
    }
  }, [disabled, opened, close]);

  const allTags = useMemo(() => categories.flatMap((category) => category.tags || []), [categories]);
  const tagMap = useMemo(() => new Map(allTags.map((tag) => [tag.id, tag])), [allTags]);

  const tagOptions = useMemo(
    () =>
      allTags.map((tag) => ({
        value: tag.id,
        label: tag.name,
        color: tag.color,
        automation: autoAssignments?.[tag.id] ?? extractAutomationMeta(tag),
      })),
    [allTags, autoAssignments],
  );

  const selectedTagDetails = useMemo(
    () => selectedTags.map((tagId) => tagMap.get(tagId)).filter(Boolean) as TagView[],
    [selectedTags, tagMap],
  );

  const automationMap = useMemo(() => {
    if (!showAutomationBadges) {
      return new Map<string, AutomationMeta>();
    }

    const map = new Map<string, AutomationMeta>();

    selectedTagDetails.forEach((tag) => {
      const meta = autoAssignments?.[tag.id] ?? extractAutomationMeta(tag);
      if (meta) {
        map.set(tag.id, meta);
      }
    });

    return map;
  }, [autoAssignments, selectedTagDetails, showAutomationBadges]);

  const handleToggleTag = (tagId: string) => {
    if (selectedTags.includes(tagId)) {
      onChange(selectedTags.filter((id) => id !== tagId));
      return;
    }

    onChange([...selectedTags, tagId]);
  };

  const isDisabled = disabled || (isLoading && !categoriesProp);

  return (
    <Box>
      <Group justify="space-between" mb="xs">
        <Text size="sm" fw={500}>
          {label}
        </Text>
        <Button
          size="xs"
          variant="light"
          leftSection={<IconPlus size={12} />}
          onClick={open}
          disabled={isDisabled}
        >
          ã‚«ãƒ†ã‚´ãƒªåˆ¥é¸æŠ
        </Button>
      </Group>

      <MultiSelect
        placeholder={placeholder}
        data={tagOptions}
        value={selectedTags}
        onChange={onChange}
        searchable
        clearable
        disabled={isDisabled}
        nothingFoundMessage={isLoading ? 'èª­ã¿è¾¼ã¿ä¸­...' : 'åˆ©ç”¨å¯èƒ½ãªã‚¿ã‚°ãŒã‚ã‚Šã¾ã›ã‚“'}
        renderOption={({ option }) => {
          const tag = tagMap.get(option.value);
          const automationMeta = showAutomationBadges
            ? (option as typeof option & { automation?: AutomationMeta }).automation
            : undefined;

          return (
            <Group gap="xs">
              <Box w={8} h={8} bg={tag?.color || 'var(--mantine-primary-color-filled)'} style={{ borderRadius: '50%' }} />
              <Text>{option.label}</Text>
              {automationMeta && renderAutomationBadge(automationMeta)}
            </Group>
          );
        }}
      />

      {isLoading && (
        <Center mt="xs">
          <Loader size="sm" />
        </Center>
      )}

      {selectedTagDetails.length > 0 && (
        <Group gap="xs" mt="xs">
          {selectedTagDetails.map((tag) => {
            const automationMeta = automationMap.get(tag.id);
            const badgeStyles = getBadgeColors(tag, !!automationMeta);
            return (
              <Badge 
                key={tag.id} 
                size="sm" 
                variant="light" 
                radius="md" 
                style={badgeStyles}
                styles={{
                  root: {
                    ...badgeStyles,
                  }
                }}
              >
                {tag.name}
              </Badge>
            );
          })}
        </Group>
      )}

      <UnifiedModal
        opened={opened}
        onClose={close}
        title="ã‚¿ã‚°é¸æŠ"
        size="lg"
        sections={[
          {
            content: (
              <>
                {isLoading && (
                  <Center py="xl">
                    <Loader />
                  </Center>
                )}

                {!isLoading && categories.length === 0 && (
                  <Center py="xl">
                    <Text c="dimmed">åˆ©ç”¨å¯èƒ½ãªã‚«ãƒ†ã‚´ãƒªãŒã‚ã‚Šã¾ã›ã‚“ã€‚</Text>
                  </Center>
                )}

                {!isLoading && categories.length > 0 && (
                  <Stack gap="md">
                    {categories.map((category) => (
                      <Card key={category.id} padding="md" withBorder>
                        <Stack gap="sm">
                          <Group gap="xs">
                            <Box w={12} h={12} bg={category.color || 'var(--mantine-primary-color-filled)'} style={{ borderRadius: 2 }} />
                            <Text fw={500} c={category.color}>
                              {category.name}
                            </Text>
                          </Group>

                          {category.description && (
                            <Text size="xs" c="dimmed">
                              {category.description}
                            </Text>
                          )}

                          <SimpleGrid cols={{ base: 2, sm: 3, md: 4 }} spacing="xs">
                            {(category.tags ?? []).map((tag) => {
                              const isSelected = selectedTags.includes(tag.id);
                              const automationMeta = showAutomationBadges
                                ? autoAssignments?.[tag.id] ?? extractAutomationMeta(tag)
                                : undefined;

                              return (
                                <Tooltip
                                  key={tag.id}
                                  label={
                                    tag.description
                                      ? tag.description
                                      : `ä½¿ç”¨å›æ•°: ${tag.usageCount.toLocaleString()}å›`
                                  }
                                  withArrow
                                  withinPortal
                                >
                                  <Badge
                                    size="md"
                                    radius="md"
                                    variant="light"
                                    style={{
                                      cursor: 'pointer',
                                      backgroundColor: isSelected
                                        ? tag.color ?? 'var(--mantine-primary-color-filled)'
                                        : tag.color
                                          ? `${tag.color}15`
                                          : 'var(--mantine-color-gray-1)',
                                      color: isSelected
                                        ? tag.color
                                          ? 'var(--mantine-color-white)'
                                          : 'var(--mantine-color-dark-6)'
                                        : tag.color ?? 'var(--mantine-color-dark-6)',
                                      border: isSelected && tag.color
                                        ? `1px solid ${tag.color}`
                                        : undefined,
                                    }}
                                    onClick={() => handleToggleTag(tag.id)}
                                  >
                                    {tag.name}
                                    {showAutomationBadges && automationMeta && (
                                      <Box component="span" ml={6}>
                                        {renderAutomationBadge(automationMeta)}
                                      </Box>
                                    )}
                                  </Badge>
                                </Tooltip>
                              );
                            })}
                          </SimpleGrid>
                        </Stack>
                      </Card>
                    ))}
                  </Stack>
                )}
              </>
            ),
          },
          {
            content: (
              <Group justify="flex-end">
                <Button onClick={close}>å®Œäº†</Button>
              </Group>
            ),
          },
        ]}
      />
    </Box>
  );
}

interface TagDisplayProps {
  tagIds: string[];
  categories?: TagCategoryView[];
  filters?: TagCategoryFilters;
  size?: 'xs' | 'sm' | 'md' | 'lg';
  tagMetadata?: Record<string, Record<string, unknown>>;
}

export function TagDisplay({ tagIds, categories: categoriesProp, filters, size = 'sm', tagMetadata }: TagDisplayProps) {
  const { categories, isLoading } = useResolvedCategories(categoriesProp, filters);

  const tagMap = useMemo(() => {
    const map = new Map<string, TagView>();
    categories.forEach((category) => {
      (category.tags ?? []).forEach((tag) => {
        // tagMetadataãŒæä¾›ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ãã‚Œã‚’ä½¿ç”¨
        if (tagMetadata && tagMetadata[tag.id]) {
          map.set(tag.id, { ...tag, metadata: tagMetadata[tag.id] });
        } else {
          map.set(tag.id, tag);
        }
      });
    });
    return map;
  }, [categories, tagMetadata]);

  const tags = useMemo(() => tagIds.map((tagId) => tagMap.get(tagId)).filter(Boolean) as TagView[], [tagIds, tagMap]);

  if (isLoading) {
    return (
      <Center>
        <Loader size="sm" />
      </Center>
    );
  }

  if (tags.length === 0) {
    return null;
  }

  return (
    <Group gap="xs">
      {tags.map((tag) => {
        const automationMeta = extractAutomationMeta(tag);
        const badgeStyles = getBadgeColors(tag, !!automationMeta);
        return (
          <Badge 
            key={tag.id} 
            size={size} 
            variant="light" 
            radius="md" 
            style={badgeStyles}
            styles={{
              root: {
                ...badgeStyles,
              }
            }}
          >
            {tag.name}
          </Badge>
        );
      })}
    </Group>
  );
}
````

## File: frontend/src/lib/auth/password-reset-store.ts
````typescript
import { create } from 'zustand';
import { useShallow } from 'zustand/react/shallow';
import { apiClient, type ApiRequestBody, type ApiSuccessData } from '../api/client';

export type PasswordResetStatus = 'idle' | 'loading' | 'success' | 'error';

type RequestResetBody = ApiRequestBody<'/auth/request-password-reset', 'post'>;
type ResetPasswordBody = ApiRequestBody<'/auth/reset-password', 'post'>;
type RequestResetResponse = ApiSuccessData<'/auth/request-password-reset', 'post'>;

interface PasswordResetState {
  requestStatus: PasswordResetStatus;
  requestError: string | null;
  resetStatus: PasswordResetStatus;
  resetError: string | null;
  lastRequestedEmail: string | null;
  devToken: string | null;
  requestPasswordReset: (email: string) => Promise<void>;
  resetPassword: (payload: { token: string; newPassword: string }) => Promise<void>;
  resetRequestState: () => void;
  resetResetState: () => void;
  clearDevToken: () => void;
}

function isRecord(value: unknown): value is Record<string, unknown> {
  return typeof value === 'object' && value !== null;
}

function extractDevToken(response: RequestResetResponse): string | null {
  if (!response || typeof response !== 'object') {
    return null;
  }

  if (isRecord(response) && typeof response.token === 'string') {
    return response.token;
  }

  return null;
}

function extractMessage(value: unknown): string | null {
  if (typeof value === 'string') {
    return value;
  }

  if (isRecord(value) && typeof value.message === 'string') {
    return value.message;
  }

  return null;
}

export const usePasswordResetStore = create<PasswordResetState>((set) => ({
  requestStatus: 'idle',
  requestError: null,
  resetStatus: 'idle',
  resetError: null,
  lastRequestedEmail: null,
  devToken: null,
  requestPasswordReset: async (email) => {
    const payload: RequestResetBody = { email };

    set({ requestStatus: 'loading', requestError: null });

    try {
      const response = await apiClient.post('/auth/request-password-reset', {
        body: payload,
        retryOnUnauthorized: false,
      });

      if (!response.success) {
        throw new Error(response.error || response.message || 'ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ');
      }

      const devToken = extractDevToken(response.data as RequestResetResponse);

      if (devToken && process.env.NODE_ENV !== 'production' && typeof window !== 'undefined') {
        console.info('ğŸ”‘ Password reset token:', devToken);
        console.info('ğŸ”— Reset URL:', `${window.location.origin}/reset-password?token=${devToken}`);
      }

      set({
        requestStatus: 'success',
        requestError: null,
        lastRequestedEmail: email,
        devToken: devToken ?? null,
      });
    } catch (error) {
      const message = error instanceof Error ? error.message : extractMessage(error) || 'ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ';
      set({
        requestStatus: 'error',
        requestError: message,
      });
      throw error;
    }
  },
  resetPassword: async ({ token, newPassword }) => {
    const payload: ResetPasswordBody = {
      token,
      newPassword,
    };

    set({ resetStatus: 'loading', resetError: null });

    try {
      const response = await apiClient.post('/auth/reset-password', {
        body: payload,
        retryOnUnauthorized: false,
      });

      if (!response.success) {
        throw new Error(response.error || response.message || 'ãƒªã‚»ãƒƒãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ');
      }

      set({
        resetStatus: 'success',
        resetError: null,
      });
    } catch (error) {
      const message = error instanceof Error ? error.message : extractMessage(error) || 'ãƒªã‚»ãƒƒãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ';
      set({
        resetStatus: 'error',
        resetError: message,
      });
      throw error;
    }
  },
  resetRequestState: () => set({ requestStatus: 'idle', requestError: null }),
  resetResetState: () => set({ resetStatus: 'idle', resetError: null }),
  clearDevToken: () => set({ devToken: null }),
}));

// useShallowã‚’ä½¿ç”¨ã—ã¦å®‰å®šã—ãŸã‚»ãƒ¬ã‚¯ã‚¿ã‚’æä¾›
export function usePasswordResetSelectors() {
  return usePasswordResetStore(
    useShallow((state) => ({
      requestStatus: state.requestStatus,
      requestError: state.requestError,
      resetStatus: state.resetStatus,
      resetError: state.resetError,
      lastRequestedEmail: state.lastRequestedEmail,
      devToken: state.devToken,
    }))
  );
}

// ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¯å®‰å®šã—ãŸå‚ç…§ã‚’æŒã¤ãŸã‚ã€å€‹åˆ¥ã«å–å¾—
export function usePasswordResetActions() {
  const requestPasswordReset = usePasswordResetStore((state) => state.requestPasswordReset);
  const resetPassword = usePasswordResetStore((state) => state.resetPassword);
  const resetRequestState = usePasswordResetStore((state) => state.resetRequestState);
  const resetResetState = usePasswordResetStore((state) => state.resetResetState);
  const clearDevToken = usePasswordResetStore((state) => state.clearDevToken);

  return {
    requestPasswordReset,
    resetPassword,
    resetRequestState,
    resetResetState,
    clearDevToken,
  };
}
````

## File: frontend/eslint.config.mjs
````javascript
/**
 * ESLintè¨­å®šãƒ•ã‚¡ã‚¤ãƒ« (ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰)
 * Next.js + React + TypeScript ç”¨ãƒ•ãƒ©ãƒƒãƒˆè¨­å®š
 * 
 * è¨­å®šæ–¹é‡:
 * - é–‹ç™ºåŠ¹ç‡ã‚’é‡è¦–ã—ã€è­¦å‘Šãƒ¬ãƒ™ãƒ«ã§ã®é‹ç”¨
 * - TypeScriptå‹å®‰å…¨æ€§ã¯æ®µéšçš„æ”¹å–„
 * - Next.js/React ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã«æº–æ‹ 
 * - Importé †åºã¯ç°¡ç´ åŒ–ã—ã¦ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹æ€§é‡è¦–
 */

import js from '@eslint/js';
import tseslint from 'typescript-eslint';
import reactHooks from 'eslint-plugin-react-hooks';
import nextPlugin from '@next/eslint-plugin-next';
import importX from 'eslint-plugin-import-x';
import prettier from 'eslint-config-prettier';

const eslintConfig = [
  // === åŸºæœ¬è¨­å®š ===
  js.configs.recommended,
  ...tseslint.configs.recommended,
  prettier,
  
  // === TypeScriptè¨­å®š ===
  {
    name: 'frontend-typescript-config',
    files: ["**/*.ts", "**/*.tsx"],
    plugins: {
      'react-hooks': reactHooks,
      '@next/next': nextPlugin,
      'import-x': importX,
    },
    languageOptions: {
      parserOptions: {
        project: './tsconfig.json',
        ecmaVersion: 2020,
        sourceType: 'module',
      }
    },
    rules: {
      // === TypeScript Rules ===
      // é–‹ç™ºæ®µéšã§ã¯è­¦å‘Šãƒ¬ãƒ™ãƒ«ã§é‹ç”¨ã€æ®µéšçš„ã«errorã«ç§»è¡Œ
      '@typescript-eslint/no-unused-vars': ['warn', { 
        argsIgnorePattern: '^_',
        varsIgnorePattern: '^_'
      }],
      '@typescript-eslint/no-explicit-any': 'error',
      '@typescript-eslint/no-non-null-assertion': 'error',
      '@typescript-eslint/return-await': ['error', 'in-try-catch'],
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-return': 'warn',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/triple-slash-reference': 'off', // Next.js generated files
      
      // === Import/Export Rules ===
      // è­¦å‘Šå‰Šæ¸›ã®ãŸã‚é †åºãƒã‚§ãƒƒã‚¯ã¯ä¸€æ—¦ç„¡åŠ¹åŒ–ï¼ˆå°†æ¥Re-enableæ¤œè¨ï¼‰
      'import-x/order': 'off',
      'import-x/no-duplicates': 'error',
      'import-x/no-unresolved': 'off', // TypeScriptã§è§£æ±ºã™ã‚‹ãŸã‚ç„¡åŠ¹åŒ–
      'import-x/no-unused-modules': 'off', // é–‹ç™ºæ®µéšã§ã¯ç„¡åŠ¹åŒ–
      
      // === React/Next.js Rules ===
      'react-hooks/rules-of-hooks': 'error',
      'react-hooks/exhaustive-deps': 'warn',
      '@next/next/no-img-element': 'off', // Next.js Image componentæ¨å¥¨ã ãŒå¼·åˆ¶ã—ãªã„
      '@next/next/no-html-link-for-pages': 'error',
      '@next/next/no-page-custom-font': 'warn',
      '@next/next/no-unwanted-polyfillio': 'warn',
      
      // === ä¸€èˆ¬çš„ãªJavaScript Rules ===
      // é–‹ç™ºåŠ¹ç‡å„ªå…ˆã§consoleã¯è¨±å¯ï¼ˆæœ¬ç•ªãƒ“ãƒ«ãƒ‰æ™‚ã«è¦‹ç›´ã—ï¼‰
      'no-console': 'off',
      'no-debugger': 'warn',
    },
    settings: {
      next: {
        rootDir: '.'
      },
      'import-x/resolver': {
        typescript: {
          alwaysTryTypes: true,
          project: './tsconfig.json'
        },
        node: true
      }
    }
  },

  // === JavaScriptè¨­å®š (TypeScriptãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒã‚§ãƒƒã‚¯ãªã—) ===
  {
    name: 'frontend-javascript-config',
    files: ["**/*.js", "**/*.jsx"],
    plugins: {
      'react-hooks': reactHooks,
      '@next/next': nextPlugin,
      'import-x': importX,
    },
    rules: {
      // === React/Next.js Rules ===
      'react-hooks/rules-of-hooks': 'error',
      'react-hooks/exhaustive-deps': 'warn',
      '@next/next/no-img-element': 'off',
      '@next/next/no-html-link-for-pages': 'error',
      '@next/next/no-page-custom-font': 'warn',
      '@next/next/no-unwanted-polyfillio': 'warn',
      
      // === ä¸€èˆ¬çš„ãªJavaScript Rules ===
      'no-console': 'off',
      'no-debugger': 'warn',
    },
    settings: {
      next: {
        rootDir: '.'
      }
    }
  },
  
  // === ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«å°‚ç”¨è¨­å®š ===
  {
    name: 'frontend-test-config',
    files: ['**/*.test.ts', '**/*.test.tsx', '**/*.spec.ts', '**/*.spec.tsx'],
    rules: {
      // ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã§ã¯anyå‹ä½¿ç”¨ã‚’è¨±å¯
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'off',
      '@typescript-eslint/no-unsafe-member-access': 'off',
      '@typescript-eslint/no-unsafe-call': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-argument': 'off',
      'no-console': 'off', // ãƒ†ã‚¹ãƒˆæ™‚ã®ãƒ‡ãƒãƒƒã‚°ç”¨
    }
  },

  // === UIãƒ•ã‚¡ã‚¤ãƒ«ã®æ®µéšçš„ç·©å’Œï¼ˆapp/componentsï¼‰===
  {
    name: 'frontend-ui-relax-rules',
    files: ['src/app/**/*.tsx', 'src/components/**/*.tsx'],
    rules: {
      '@typescript-eslint/no-unsafe-assignment': 'off',
      '@typescript-eslint/no-unsafe-member-access': 'off',
      '@typescript-eslint/no-unsafe-call': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-argument': 'off',
    }
  },
  
  // === é™¤å¤–è¨­å®š ===
  {
    name: 'frontend-ignores',
    ignores: [
      ".next/**",
      "out/**", 
      "dist/**",
      "node_modules/**",
      "coverage/**",
      "next-env.d.ts",
      "**/*_old.tsx",
      "**/*page_old.tsx", 
      "**/*page_new.tsx",
      "**/*_old.ts",
      "*.config.js",
      "*.config.mjs",
      "check-syntax.js",
      "src/lib/api/generated/**",
      "**/*.bak",
      "**/*.backup.ts",
      "**/*.backup.tsx"
    ]
  }
];

export default eslintConfig;
````

## File: frontend/next.config.ts
````typescript
import type { NextConfig } from "next";
import path from "path";
// Bundle Analyzer (ANALYZE=true ã§ãƒ“ãƒ«ãƒ‰æ™‚ã«æœ‰åŠ¹åŒ–)
import withBundleAnalyzer from '@next/bundle-analyzer';

const bundleAnalyzer = withBundleAnalyzer({
  enabled: process.env.ANALYZE === 'true',
});

const nextConfig: NextConfig = {
  /* config options here */
  serverExternalPackages: [],
  typescript: {
    // æœ¬ç•ªãƒ“ãƒ«ãƒ‰æ™‚ã«TypeScriptã‚¨ãƒ©ãƒ¼ã‚’ç„¡è¦–ï¼ˆé–‹ç™ºæ™‚ã¯å‹ãƒã‚§ãƒƒã‚¯ãŒæœ‰åŠ¹ï¼‰
    ignoreBuildErrors: false,
  },
  // Production optimizations
  compiler: {
    removeConsole: process.env.NODE_ENV === 'production',
  },
  // Build configuration
  generateEtags: false,
  poweredByHeader: false,
  // Standalone output for production deployment
  output: 'standalone',
  // Bundle size optimization
  // swcMinify: true, // Removed in Next.js 15 as it's default
  // Experimental features for better performance
  experimental: {
    optimizePackageImports: [
      '@mantine/core',
      '@mantine/hooks',
      '@tabler/icons-react',
    ],
  },
  // Turbopack è¨­å®š
  // Next.js 15.6.0-canary ç³»ã§ç™ºç”Ÿã™ã‚‹ Turbopack é–¢é€£ã®è­¦å‘Šã‚’æŠ‘åˆ¶ã™ã‚‹ãŸã‚ã®ç©ºè¨­å®š
  // å°†æ¥çš„ã«è©²å½“ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ãƒ¯ãƒ¼ã‚¯ã‚¢ãƒ©ã‚¦ãƒ³ãƒ‰ãŒä¸è¦ã«ãªã£ãŸã‚‰å‰Šé™¤ã‚’æ¤œè¨ã™ã‚‹
  turbopack: {},
  // ãƒ¢ãƒãƒ¬ãƒå¯¾å¿œã®ãŸã‚ã®ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ãƒ«ãƒ¼ãƒˆè¨­å®š
  outputFileTracingRoot: path.join(__dirname, "../"),
  // Memory optimization for CI/CD and development
  webpack: (config, { dev, isServer }) => {
    // é–‹ç™ºç’°å¢ƒã§ã®ãƒ¡ãƒ¢ãƒªæœ€é©åŒ–
    if (dev) {
      // é–‹ç™ºç’°å¢ƒã§ã¯ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã‚’æŠ‘åˆ¶ã™ã‚‹ãŸã‚ã€ä¸€éƒ¨ã®æœ€é©åŒ–ã‚’ç„¡åŠ¹åŒ–
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      if (config.optimization) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        config.optimization.removeAvailableModules = false;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        config.optimization.removeEmptyChunks = false;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        config.optimization.splitChunks = false;
      }
    }
    
    // æœ¬ç•ªãƒ“ãƒ«ãƒ‰æ™‚ã®æœ€é©åŒ–
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    if (!dev && !isServer && config.optimization?.splitChunks?.cacheGroups) {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
      const cg = config.optimization.splitChunks.cacheGroups;
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
      config.optimization.splitChunks.cacheGroups = {
        ...cg,
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
          priority: 10,
        },
      };
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return config;
  },
  // Remove rewrites and headers as they don't work with static export
};

export default bundleAnalyzer(nextConfig);
````

## File: gcp_verification_results.md
````markdown
# MyCats ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ æœ€çµ‚å‹•ä½œæ¤œè¨¼ãƒ¬ãƒãƒ¼ãƒˆ

**æ¤œè¨¼æ—¥**: 2026å¹´1æœˆ30æ—¥  
**æ¤œè¨¼ç’°å¢ƒ**: GCP Cloud Run  
**ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰URL**: https://mycats-pro-frontend-518939509282.asia-northeast1.run.app  
**ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰URL**: https://mycats-pro-backend-518939509282.asia-northeast1.run.app  
**æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯**: Next.js 15 + Mantine UI + NestJS + Prisma + PostgreSQL

---

## æ¤œè¨¼ã‚µãƒãƒªãƒ¼

| ã‚«ãƒ†ã‚´ãƒª | æ¤œè¨¼é …ç›®æ•° | PASS | FAIL | WARNING |
|---------|-----------|------|------|---------|
| èªè¨¼æ©Ÿèƒ½ | 6 | 4 | 2 | 0 |
| çŒ«ç®¡ç† | 8 | 8 | 0 | 0 |
| äº¤é…ç®¡ç† | 3 | 3 | 0 | 0 |
| å­çŒ«ç®¡ç† | 2 | 2 | 0 | 0 |
| ã‚±ã‚¢ç®¡ç† | 2 | 2 | 0 | 0 |
| åŒ»ç™‚ãƒ‡ãƒ¼ã‚¿ | 2 | 2 | 0 | 0 |
| ã‚¿ã‚°ç®¡ç† | 2 | 2 | 0 | 0 |
| è¡€çµ±æ›¸ | 3 | 3 | 0 | 0 |
| ãã®ä»–æ©Ÿèƒ½ | 6 | 6 | 0 | 0 |
| UI/UX | 5 | 5 | 0 | 0 |
| **åˆè¨ˆ** | **39** | **37** | **2** | **0** |

---

## è©³ç´°æ¤œè¨¼çµæœ

### 1. èªè¨¼æ©Ÿèƒ½

| é …ç›® | çµæœ | å‚™è€ƒ |
|------|------|------|
| ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸è¡¨ç¤º | PASS | æ­£å¸¸ã«è¡¨ç¤ºã€ãƒ•ã‚©ãƒ¼ãƒ ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å‹•ä½œ |
| ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ | PASS | admin@example.com / Passw0rd! ã§ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ |
| ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ | PASS | æ­£å¸¸ã«ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã€ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ |
| æ–°è¦ç™»éŒ²ãƒšãƒ¼ã‚¸ | PASS | ãƒ•ã‚©ãƒ¼ãƒ è¡¨ç¤ºã€ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰è¦ä»¶è¡¨ç¤ºã‚ã‚Š |
| ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆè¦æ±‚ (/forgot-password) | **FAIL** | ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ |
| ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆå®Ÿè¡Œ (/reset-password) | **FAIL** | ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ |

### 2. çŒ«ç®¡ç†æ©Ÿèƒ½

| é …ç›® | çµæœ | å‚™è€ƒ |
|------|------|------|
| åœ¨èˆçŒ«ä¸€è¦§è¡¨ç¤º | PASS | 52é ­ã®ãƒ‡ãƒ¼ã‚¿æ­£å¸¸è¡¨ç¤º |
| çŒ«è©³ç´°ãƒšãƒ¼ã‚¸ | PASS | å€‹ä½“æƒ…å ±ã€å†™çœŸã€ã‚¿ã‚°è¡¨ç¤º |
| çŒ«ç·¨é›†ãƒšãƒ¼ã‚¸ | PASS | ãƒ•ã‚©ãƒ¼ãƒ æ­£å¸¸å‹•ä½œ |
| æ–°è¦çŒ«ç™»éŒ²ãƒšãƒ¼ã‚¸ | PASS | å…¨ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å…¥åŠ›å¯èƒ½ |
| è¡€çµ±ã‚¿ãƒ– | PASS | è¡€çµ±æƒ…å ±è¡¨ç¤º |
| è¡€çµ±è¡¨è¡¨ç¤º | PASS | å®¶ç³»å›³å½¢å¼ã§è¡¨ç¤º |
| çŒ«ç¨®ãƒ»è‰²æŸ„é¸æŠ | PASS | ã‚ªãƒ¼ãƒˆã‚³ãƒ³ãƒ—ãƒªãƒ¼ãƒˆå‹•ä½œ |
| ã‚¿ã‚°é¸æŠ | PASS | ã‚«ãƒ†ã‚´ãƒªåˆ¥é¸æŠå¯èƒ½ |

### 3. äº¤é…ç®¡ç†æ©Ÿèƒ½

| é …ç›® | çµæœ | å‚™è€ƒ |
|------|------|------|
| äº¤é…ç®¡ç†ãƒšãƒ¼ã‚¸è¡¨ç¤º | PASS | ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆå¯èƒ½ |
| å¦Šå¨ ç¢ºèªã‚¿ãƒ– | PASS | æ­£å¸¸è¡¨ç¤º |
| äº¤é…è¨˜éŒ²ä¸€è¦§ | PASS | 0ä»¶è¡¨ç¤ºï¼ˆãƒ‡ãƒ¼ã‚¿ãªã—ï¼‰ |

### 4. å­çŒ«ç®¡ç†æ©Ÿèƒ½

| é …ç›® | çµæœ | å‚™è€ƒ |
|------|------|------|
| å­çŒ«ç®¡ç†ãƒšãƒ¼ã‚¸è¡¨ç¤º | PASS | æ­£å¸¸è¡¨ç¤º |
| å­çŒ«ä¸€è¦§ | PASS | æ­£å¸¸è¡¨ç¤º |

### 5. ã‚±ã‚¢ç®¡ç†æ©Ÿèƒ½

| é …ç›® | çµæœ | å‚™è€ƒ |
|------|------|------|
| ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒšãƒ¼ã‚¸ | PASS | æœªå®Œäº†2ä»¶è¡¨ç¤º |
| ã‚±ã‚¢ã‚¿ã‚¹ã‚¯ä¸€è¦§ | PASS | æ­£å¸¸è¡¨ç¤º |

### 6. åŒ»ç™‚ãƒ‡ãƒ¼ã‚¿æ©Ÿèƒ½

| é …ç›® | çµæœ | å‚™è€ƒ |
|------|------|------|
| åŒ»ç™‚ãƒ‡ãƒ¼ã‚¿ãƒšãƒ¼ã‚¸è¡¨ç¤º | PASS | æ­£å¸¸è¡¨ç¤º |
| åŒ»ç™‚è¨˜éŒ²ä¸€è¦§ | PASS | æ­£å¸¸è¡¨ç¤º |

### 7. ã‚¿ã‚°ç®¡ç†æ©Ÿèƒ½

| é …ç›® | çµæœ | å‚™è€ƒ |
|------|------|------|
| ã‚¿ã‚°ç®¡ç†ãƒšãƒ¼ã‚¸è¡¨ç¤º | PASS | æ­£å¸¸è¡¨ç¤º |
| ã‚¿ã‚°ä¸€è¦§ | PASS | ã‚«ãƒ†ã‚´ãƒªåˆ¥è¡¨ç¤º |

### 8. è¡€çµ±æ›¸æ©Ÿèƒ½

| é …ç›® | çµæœ | å‚™è€ƒ |
|------|------|------|
| è¡€çµ±æ›¸ä¸€è¦§ãƒšãƒ¼ã‚¸ | PASS | æ­£å¸¸è¡¨ç¤º |
| è¡€çµ±æ›¸æ–°è¦ä½œæˆãƒšãƒ¼ã‚¸ | PASS | ãƒ•ã‚©ãƒ¼ãƒ è¡¨ç¤º |
| è¡€çµ±æ›¸è©³ç´° | PASS | æ­£å¸¸è¡¨ç¤º |

### 9. ãã®ä»–æ©Ÿèƒ½

| é …ç›® | çµæœ | å‚™è€ƒ |
|------|------|------|
| ã‚®ãƒ£ãƒ©ãƒªãƒ¼ãƒšãƒ¼ã‚¸ | PASS | ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆå¯èƒ½ï¼ˆå­çŒ«/çˆ¶çŒ«/æ¯çŒ«/å’æ¥­çŒ«ï¼‰ |
| å°åˆ·ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç®¡ç† | PASS | ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä¸€è¦§è¡¨ç¤ºã€ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼æ©Ÿèƒ½ |
| ã‚¹ã‚¿ãƒƒãƒ•ã‚·ãƒ•ãƒˆãƒšãƒ¼ã‚¸ | PASS | æ­£å¸¸è¡¨ç¤º |
| ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šãƒšãƒ¼ã‚¸ | PASS | ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ç·¨é›†ã€ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¤‰æ›´ã€ãƒ‡ã‚¶ã‚¤ãƒ³è¨­å®š |
| ãƒ‡ã‚¶ã‚¤ãƒ³ã‚¬ã‚¤ãƒ‰ãƒšãƒ¼ã‚¸ | PASS | UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆä¸€è¦§è¡¨ç¤º |
| åˆå›ã‚¹ãƒ¼ãƒ‘ãƒ¼ã‚¢ãƒ‰ãƒŸãƒ³è¨­å®š | PASS | æ­£å¸¸è¡¨ç¤ºï¼ˆæ—¢å­˜ãƒ¦ãƒ¼ã‚¶ãƒ¼å‘ã‘ï¼‰ |

### 10. UI/UX

| é …ç›® | çµæœ | å‚™è€ƒ |
|------|------|------|
| ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ‡ã‚¶ã‚¤ãƒ³ | PASS | ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œ |
| ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ | PASS | ã‚µã‚¤ãƒ‰ãƒãƒ¼ã€ãƒœãƒˆãƒ ãƒŠãƒ“æ­£å¸¸å‹•ä½œ |
| ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰è¡¨ç¤ºåˆ‡æ›¿ | PASS | è‡ªå‹•/ã‚«ãƒ¼ãƒ‰/ãƒ€ã‚¤ã‚¢ãƒ«åˆ‡æ›¿å¯èƒ½ |
| çµ±è¨ˆæƒ…å ±è¡¨ç¤º | PASS | â™‚6 â™€6 ğŸ¾40 ğŸ“0 æ­£å¸¸è¡¨ç¤º |
| ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ç¶­æŒ | PASS | ã‚»ãƒƒã‚·ãƒ§ãƒ³ç¶­æŒæ­£å¸¸ |

---

## æ¤œå‡ºã—ãŸå•é¡Œ

| ç®‡æ‰€ | å•é¡Œå†…å®¹ | é‡è¦åº¦ | æ¨å¥¨å¯¾å¿œ |
|------|---------|--------|---------|
| /forgot-password | ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã‚¨ãƒ©ãƒ¼ã€ŒApplication error: a client-side exception has occurredã€ | é«˜ | ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ç¢ºèªã€useSearchParamsã®Suspenseå¯¾å¿œç¢ºèª |
| /reset-password | ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã‚¨ãƒ©ãƒ¼ã€ŒApplication error: a client-side exception has occurredã€ | é«˜ | ãƒˆãƒ¼ã‚¯ãƒ³ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä¸åœ¨æ™‚ã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°æ”¹å–„ |

---

## æ¨å¥¨äº‹é …ãƒ»æ‰€è¦‹

### å³æ™‚å¯¾å¿œãŒå¿…è¦ãªé …ç›®

1. **ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆæ©Ÿèƒ½ã®ä¿®æ­£**: forgot-password ã¨ reset-password ãƒšãƒ¼ã‚¸ã§ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã„ã¾ã™ã€‚Next.js 15ã®useSearchParamsã¯Suspenseã§ãƒ©ãƒƒãƒ—ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ãŒã€ã‚³ãƒ¼ãƒ‰ã‚’ç¢ºèªã—ãŸã¨ã“ã‚Suspenseã¯å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚æœ¬ç•ªç’°å¢ƒã§ã®ã¿ç™ºç”Ÿã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€ãƒ“ãƒ«ãƒ‰è¨­å®šã‚„SSR/CSRå¢ƒç•Œã®ç¢ºèªãŒå¿…è¦ã§ã™ã€‚

### å°†æ¥çš„ã«å¯¾å¿œã™ã¹ãæŠ€è¡“çš„è² å‚µ

1. **æ‹›å¾…å—è«¾ãƒšãƒ¼ã‚¸**: ãƒˆãƒ¼ã‚¯ãƒ³ãªã—ã§ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸéš›ã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯é©åˆ‡ã§ã™ãŒã€ã‚ˆã‚Šè¦ªåˆ‡ãªã‚¬ã‚¤ãƒ€ãƒ³ã‚¹ãŒã‚ã‚‹ã¨è‰¯ã„ã§ã—ã‚‡ã†ã€‚

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã«é–¢ã™ã‚‹æ‰€è¦‹

1. ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿ã¯å…¨èˆ¬çš„ã«é«˜é€Ÿã§ã€GCP Cloud Runã§ã®é‹ç”¨ã«å•é¡Œã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
2. ç”»åƒã®é…å»¶èª­ã¿è¾¼ã¿ãŒé©åˆ‡ã«å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚

### UX/UIã«é–¢ã™ã‚‹ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯

1. Mantine UIã‚’æ´»ç”¨ã—ãŸçµ±ä¸€æ„Ÿã®ã‚ã‚‹ãƒ‡ã‚¶ã‚¤ãƒ³ãŒå®Ÿç¾ã•ã‚Œã¦ã„ã¾ã™ã€‚
2. ãƒ‡ã‚¶ã‚¤ãƒ³ã‚¬ã‚¤ãƒ‰ãƒšãƒ¼ã‚¸ã«ã‚ˆã‚Šã€é–‹ç™ºè€…ãŒUIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’ä¸€è²«ã—ã¦ä½¿ç”¨ã§ãã‚‹ç’°å¢ƒãŒæ•´ã£ã¦ã„ã¾ã™ã€‚
3. ãƒœãƒˆãƒ ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºæ©Ÿèƒ½ã¯å„ªã‚ŒãŸUXæ”¹å–„ã§ã™ã€‚

---

## çµè«–

**æœ€çµ‚åˆ¤å®š: æ¡ä»¶ä»˜ããƒªãƒªãƒ¼ã‚¹å¯**

å…¨39é …ç›®ä¸­37é …ç›®ãŒPASSï¼ˆ94.9%ï¼‰ã¨ãªã‚Šã€ä¸»è¦æ©Ÿèƒ½ã¯æ­£å¸¸ã«å‹•ä½œã—ã¦ã„ã¾ã™ã€‚ãŸã ã—ã€ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆæ©Ÿèƒ½ï¼ˆforgot-password, reset-passwordï¼‰ã«é‡å¤§ãªã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã„ã‚‹ãŸã‚ã€ä»¥ä¸‹ã®å¯¾å¿œã‚’æ¨å¥¨ã—ã¾ã™ã€‚

1. **ãƒªãƒªãƒ¼ã‚¹å‰ã«ä¿®æ­£ã™ã¹ãé …ç›®**: ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆæ©Ÿèƒ½ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã‚¨ãƒ©ãƒ¼
2. **å›é¿ç­–**: ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆãŒå¿…è¦ãªãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã¯ç®¡ç†è€…ãŒæ‰‹å‹•ã§ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹é‹ç”¨ã§å¯¾å¿œå¯èƒ½

ä¸Šè¨˜ã®å•é¡ŒãŒä¿®æ­£ã•ã‚Œã‚Œã°ã€æœ¬ç•ªãƒªãƒªãƒ¼ã‚¹ã«å•é¡Œã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
````

## File: GEMINI.md
````markdown
# GEMINI.md

ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€Google GeminiãŒ`my-cats-pro`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆï¼ˆNekoya Management Systemï¼‰ã®ã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã‚’ç†è§£ã—ã€é–‹ç™ºã‚’æ”¯æ´ã™ã‚‹ãŸã‚ã®**Project Context & System Instructions**ã§ã™ã€‚

Geminiã¯ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã€Œå”¯ä¸€ã®çœŸå®Ÿã€ã¨ã—ã¦å‚ç…§ã—ã€ä»¥ä¸‹ã®ãƒšãƒ«ã‚½ãƒŠã€æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯ã€ãƒ«ãƒ¼ãƒ«ã«å¾“ã£ã¦æŒ¯ã‚‹èˆã£ã¦ãã ã•ã„ã€‚

---

## 1. Role & Persona (å½¹å‰²ã¨æŒ¯ã‚‹èˆã„)

ã‚ãªãŸã¯**Nekoya co.ltdã®å°‚å±ã‚·ãƒ‹ã‚¢ãƒ»ãƒ•ãƒ«ã‚¹ã‚¿ãƒƒã‚¯ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢**ã§ã‚ã‚Šã€åŒæ™‚ã«ãƒ¦ãƒ¼ã‚¶ãƒ¼ï¼ˆCEOï¼‰ã®ã€ŒVibe Codingã€ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼ã§ã™ã€‚

* **Vibe Coding Partner**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã‚³ãƒ¼ãƒ‰ã‚’èª­ã¿æ›¸ãã—ã¾ã›ã‚“ã€‚ã‚ãªãŸã®ä»•äº‹ã¯ã€æŠ€è¡“çš„ãªè©³ç´°ã‚’é•·ã€…ã¨èª¬æ˜ã™ã‚‹ã“ã¨ã§ã¯ãªãã€ã€Œãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå®Ÿç¾ã—ãŸã„ã“ã¨ã€ã‚’**å‹•ãã‚³ãƒ¼ãƒ‰**ã¨ã—ã¦æä¾›ã™ã‚‹ã“ã¨ã§ã™ã€‚
* **Expert Architect**: ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰(Next.js)ã‹ã‚‰ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰(NestJS)ã€ã‚¤ãƒ³ãƒ•ãƒ©(GCP)ã¾ã§ã‚’å®Œç’§ã«æŠŠæ¡ã—ã€éƒ¨åˆ†æœ€é©ã§ã¯ãªãå…¨ä½“æœ€é©ã‚’è€ƒæ…®ã—ãŸææ¡ˆã‚’è¡Œã„ã¾ã™ã€‚
* **Domain Expert**: çŒ«ã®ç¹æ®–ã€è¡€çµ±æ›¸ã€å¥åº·ç®¡ç†ã«é–¢ã™ã‚‹æ¥­å‹™çŸ¥è­˜ã‚’æ·±ãç†è§£ã—ã€å˜ãªã‚‹ãƒ‡ãƒ¼ã‚¿ç®¡ç†ã§ã¯ãªãã€ŒçŒ«ã®ãŸã‚ã®(All Four Cats)ã€ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚

## 2. User & Interaction Rules (å¯¾è©±ãƒ«ãƒ¼ãƒ«)

1.  **NO Placeholders (çœç•¥ç¦æ­¢)**
    * ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã‚³ãƒ¼ãƒ‰ã‚’ç·¨é›†ã§ãã¾ã›ã‚“ã€‚`// ... existing code` ã‚„ `// ... (çœç•¥)` ã¨ã„ã£ãŸçœç•¥ã¯**å³ç¦**ã§ã™ã€‚
    * ä¿®æ­£ã‚’å«ã‚€ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€å¿…ãš**ãƒ•ã‚¡ã‚¤ãƒ«ã®å…ˆé ­ã‹ã‚‰æœ«å°¾ã¾ã§ã®å®Œå…¨ãªã‚³ãƒ¼ãƒ‰**ã‚’å‡ºåŠ›ã—ã¦ãã ã•ã„ã€‚

2.  **No Regression (æ—¢å­˜æ©Ÿèƒ½ã®ç ´å£Šç¦æ­¢)**
    * æ–°ã—ã„æ©Ÿèƒ½ã‚’è¿½åŠ ã™ã‚‹éš›ã€æ—¢å­˜ã®æ©Ÿèƒ½ï¼ˆç‰¹ã«ã‚¿ã‚°è‡ªå‹•åŒ–ã‚„è¡€çµ±æ›¸ç”Ÿæˆï¼‰ã‚’å£Šã•ãªã„ã“ã¨ã‚’æœ€å„ªå…ˆã—ã¦ãã ã•ã„ã€‚
    * å¤‰æ›´ãŒä»–ã®éƒ¨åˆ†ã«å½±éŸ¿ã‚’ä¸ãˆã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹å ´åˆã¯ã€äº‹å‰ã«ãƒªã‚¹ã‚¯ã‚’è­¦å‘Šã—ã¦ãã ã•ã„ã€‚

3.  **Communication Style**
    * **è¨€èª**: æ—¥æœ¬èª (Japanese)
    * **ãƒˆãƒ¼ãƒ³**: ãƒ—ãƒ­ãƒ•ã‚§ãƒƒã‚·ãƒ§ãƒŠãƒ«ã ãŒè¦ªã—ã¿ã‚„ã™ãã€‚éåº¦ãªè¬ç½ªï¼ˆã€Œç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ã€ï¼‰ã¯ä¸è¦ã§ã™ã€‚å³åº§ã«ä¿®æ­£æ¡ˆã‚’æç¤ºã—ã¦ãã ã•ã„ã€‚
    * **èª¬æ˜**: æŠ€è¡“ç”¨èªã‚’ä¸¦ã¹ã‚‹ã®ã§ã¯ãªãã€ã€Œä½•ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã‹ã€ã€Œã©ã†å¤‰ã‚ã‚‹ã‹ã€ã‚’ãƒ“ã‚¸ãƒã‚¹è¦–ç‚¹ã§èª¬æ˜ã—ã¦ãã ã•ã„ã€‚
    - æœ¬ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯ **æ—¥æœ¬èª UI / ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ** ã‚’å‰æã¨ã—ã€ã‚„ã‚Šå–ã‚Šã‚‚æ—¥æœ¬èªã§çµ±ä¸€ã€‚
    - ãƒãƒ£ãƒƒãƒˆã€ãƒ¬ãƒ“ãƒ¥ãƒ¼ã€PR èª¬æ˜: ã™ã¹ã¦æ—¥æœ¬èªã§å›ç­”ã€‚
    - ã‚³ãƒ¼ãƒ‰ã‚³ãƒ¡ãƒ³ãƒˆ / README / è¨­è¨ˆè³‡æ–™: æ—¥æœ¬èªã§è¨˜è¿°ã€‚
    - ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: å¯èƒ½ãªé™ã‚Šæ—¥æœ¬èªã§è¡¨ç¤ºã—ã€é–‹ç™ºè€…å‘ã‘ãƒ­ã‚°ã‚‚æ—¥æœ¬èªã‚³ãƒ¡ãƒ³ãƒˆã‚’æ·»ä»˜ã€‚
    - å¤‰æ•°å / é–¢æ•°å / å‹åã¯å›½éš›æ…£ç¿’ã«å¾“ã„è‹±èªã§çµ±ä¸€ã€‚
    - æ©Ÿæ¢°ç¿»è¨³æ„Ÿã‚’é¿ã‘ã€ç°¡æ½”ã§å®Ÿå‹™çš„ãªæ—¥æœ¬èªã‚’å¿ƒæ›ã‘ã‚‹ã€‚

## 3. Tech Stack (æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯)

ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æŠ€è¡“çš„ãªã€ŒçœŸå®Ÿã€ã§ã™ã€‚ã“ã‚Œä»¥å¤–ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ææ¡ˆã™ã‚‹éš›ã¯æ…é‡ã«è¡Œã£ã¦ãã ã•ã„ã€‚

### Frontend
* **Framework**: Next.js 15+ (App Router)
* **Language**: TypeScript
* **Styling**: Tailwind CSS (Mobile First)
* **UI Components**: Headless UI, Heroicons, Custom "Mochi-UI" (Rounded, Soft, Pink/White theme)
* **State Management**: React Query (Server State), Zustand (Client State)
* **Key Patterns**:
    * `UnifiedModal` (å…¨ã¦ã®ãƒ¢ãƒ¼ãƒ€ãƒ«ã¯ `src/components/common/UnifiedModal.tsx` ã‚’ä½¿ç”¨)
    * Server Actions (APIé€šä¿¡ã®ãƒ©ãƒƒãƒ—)

### Backend
* **Framework**: NestJS (Monorepo structure)
* **Language**: TypeScript
* **Database**: PostgreSQL
* **ORM**: Prisma (Schema located at `backend/prisma/schema.prisma`)
* **API**: RESTful API (Standard Controllers)
* **Auth**: JWT based (SuperAdmin, TenantAdmin, Staff)

### Infrastructure
* **Container**: Docker (Development & Production)
* **Cloud**: Google Cloud Platform (Cloud Run, Cloud Build, Cloud SQL)

## 4. Coding Standards & Guidelines

### A. "Unified Modal" Protocol
ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ã€ãƒ¢ãƒ¼ãƒ€ãƒ«å®Ÿè£…ã«å³æ ¼ãªãƒ«ãƒ¼ãƒ«ãŒã‚ã‚Šã¾ã™ã€‚
* **ç¦æ­¢**: æ–°ã—ã„ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’ã‚¼ãƒ­ã‹ã‚‰ä½œã‚‹ã“ã¨ã€‚
* **å¼·åˆ¶**: å¿…ãš `UnifiedModal` ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’ä½¿ç”¨ã—ã€`UNIFIED_MODAL_SECTIONS` å®šç¾©ã«å¾“ã£ã¦ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’æ§‹æˆã™ã‚‹ã“ã¨ã€‚
* **ç›®çš„**: ãƒ¢ãƒã‚¤ãƒ«ç«¯æœ«ã§ã®æ“ä½œæ€§çµ±ä¸€ã¨ã€ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹æ€§ã®å‘ä¸Šã€‚

### B. Prisma & Database
* **Schema First**: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®å¤‰æ›´ã¯å¿…ãš `schema.prisma` ã®å¤‰æ›´ã‹ã‚‰å§‹ã‚ã€ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚¡ã‚¤ãƒ« (`migration.sql`) ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚
* **Multi-tenancy**: ã»ã¼å…¨ã¦ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã¯ `tenantId` ã‚’æŒã¡ã€ãƒ†ãƒŠãƒ³ãƒˆé–“ã®ãƒ‡ãƒ¼ã‚¿åˆ†é›¢ã‚’å³å®ˆã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

### C. å‹å®‰å…¨ãƒãƒªã‚·ãƒ¼ï¼ˆå³æ ¼ç‰ˆï¼‰

- `any` / `unknown` ã®ä½¿ç”¨ã¯ç¦æ­¢ã€‚ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®åˆ¶ç´„ã§ä¸å¯é¿ãªå ´åˆã®ã¿ã€**è©²å½“è¡Œã«ç†ç”±ã‚³ãƒ¡ãƒ³ãƒˆã‚’è¨˜è¼‰**ã—ã€å‹ã‚¬ãƒ¼ãƒ‰ã‚„ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã§éœ²å‡ºã‚’å±€æ‰€åŒ–ã™ã‚‹ã€‚

### C-1. any / unknown ä¾‹å¤–æ¡ä»¶ï¼ˆã™ã¹ã¦å¿…é ˆï¼‰

1. å¤–éƒ¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å‹å®šç¾©ãŒå®Ÿæ…‹ã¨ç•°ãªã‚Šä¿®æ­£ä¸èƒ½
2. ä»¥ä¸‹ã®ä»£æ›¿æ¡ˆã‚’ã™ã¹ã¦è©¦è¡Œã—å¤±æ•—:
   - å‹ã‚¬ãƒ¼ãƒ‰
   - Partial / Pick / Omit
   - ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹
   - å‹ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³
   - ãƒ©ã‚¤ãƒ–ãƒ©ãƒªæ›´æ–°ãƒ»ä»£æ›¿æ¤œè¨
3. è©²å½“è¡Œã«ä»¥ä¸‹ã‚’å¿…ãšè¨˜è¼‰:
   - è©¦è¡Œã—ãŸä»£æ›¿æ¡ˆã¨çµæœ
   - any ä½¿ç”¨ç†ç”±
   - å½±éŸ¿ç¯„å›²æœ€å°åŒ–æ–¹æ³•

- é null ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆ`!`ï¼‰ã¯ç¦æ­¢ã€‚nullable ã‚’æ‰±ã†éš›ã¯ã‚¬ãƒ¼ãƒ‰ã‚„ `if (!value) return` ã§å®‰å…¨ã«æ‰±ã†ã€‚
- ä¹±æš´ãªäºŒæ®µã‚­ãƒ£ã‚¹ãƒˆï¼ˆ`value as unknown as X`, `as any`ï¼‰ã¯ç¦æ­¢ã€‚å¿…è¦ãªå ´åˆã¯å‹ã‚¬ãƒ¼ãƒ‰ãƒ»åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…ã€‚
- `// eslint-disable` / `@ts-ignore` ã¯åŸå‰‡ç¦æ­¢ã€‚ã‚„ã‚€ã‚’å¾—ãªã„å ´åˆã¯ 1 è¡Œé™å®š + ç†ç”±ã‚³ãƒ¡ãƒ³ãƒˆã€‚
- ESLint / tsconfig ã®è¨­å®šã§å‹ã‚¨ãƒ©ãƒ¼ã‚’é»™æ®ºã™ã‚‹ã“ã¨ã¯ç¦æ­¢ã€‚ã‚¨ãƒ©ãƒ¼åŸå› ã‚’ã‚³ãƒ¼ãƒ‰ã§è§£æ±ºã™ã‚‹ã€‚
- ã™ã¹ã¦ã®å…¬é–‹é–¢æ•°ãƒ»ã‚¯ãƒ©ã‚¹ã¯å¼•æ•°ãƒ»æˆ»ã‚Šå€¤ã‚’å®Œå…¨ã«å‹å®šç¾©ã€‚`Promise` é–¢æ•°ã¯ `Promise<ResultType>` ã‚’æ˜ç¤ºã€‚
- åˆ†å²ã¯å¯èƒ½ãªé™ã‚Š **exhaustiveness check** ã‚’å®Ÿæ–½ï¼ˆ`switch` + `never`ï¼‰ã€‚
- API å…¥å‡ºåŠ›ã¯æ—¢å­˜ DTO / Prisma å‹ / å…±é€š `types/` ã‚’å†åˆ©ç”¨ã€‚é‡è¤‡å®šç¾©ã‚’é¿ã‘ã€å‹ãŒè¶³ã‚Šãªã„å ´åˆã¯å…±é€šå ´æ‰€ã«è¿½åŠ ã—ã¦ã‹ã‚‰ä½¿ç”¨ã™ã‚‹  

### D. "Vibe" Aesthetics (UI/UX)
* ãƒ‡ã‚¶ã‚¤ãƒ³ã¯ã€Œæ©Ÿèƒ½çš„ã€ã‹ã¤ã€Œã‚·ãƒ³ãƒ—ãƒ«ã€ã ã‘ã©ã€ã¡ã‚‡ã£ã¨ã ã‘ã€Œã‹ã‚ã„ã„ã€ã‚’ç›®æŒ‡ã—ã¾ã™ã€‚

## 5. Directory Structure Map

é‡è¦ãªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å½¹å‰²ã§ã™ã€‚æ¢ç´¢ã®å‚è€ƒã«ã—ã¦ãã ã•ã„ã€‚

* `frontend/src/app`: Next.js App Router Pages
* `frontend/src/components/common`: UnifiedModalãªã©ã®å…±é€šã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
* `frontend/src/lib/api`: APIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨React Query Hooks
* `backend/src/breeding`: ç¹æ®–ã€äº¤é…è¨ˆç”»ã€å‡ºç”£ç®¡ç†ãƒ­ã‚¸ãƒƒã‚¯
* `backend/src/pedigree`: è¡€çµ±æ›¸ç”Ÿæˆã€PDFå‡ºåŠ›ãƒ­ã‚¸ãƒƒã‚¯
* `backend/src/tags`: ã‚¿ã‚°è‡ªå‹•åŒ–ã‚·ã‚¹ãƒ†ãƒ ï¼ˆéå¸¸ã«é‡è¦ï¼‰
* `docs/`: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®è©³ç´°ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆï¼ˆå›°ã£ãŸã‚‰ã“ã“ã‚’æ¢ã™ï¼‰

## 6. Project Specific Knowledge (ãƒ‰ãƒ¡ã‚¤ãƒ³çŸ¥è­˜)

* **Tag Automation**: çŒ«ã®æœˆé½¢ã‚„çŠ¶æ…‹ï¼ˆå¦Šå¨ ä¸­ãªã©ï¼‰ã«å¿œã˜ã¦ã€ã‚¿ã‚°ã‚’è‡ªå‹•çš„ã«ä»˜ä¸ãƒ»å‰Šé™¤ã™ã‚‹ãƒãƒƒãƒå‡¦ç†ãŒã‚ã‚Šã¾ã™ã€‚æ‰‹å‹•ã§ã®ã‚¿ã‚°æ“ä½œã¨ç«¶åˆã—ãªã„ã‚ˆã†æ³¨æ„ãŒå¿…è¦ã§ã™ã€‚
* **Pedigree Logic**: æœ¬çŒ«ã‹ã‚‰3ä»£å‰ã¾ã§é¡ã‚‹è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã¯è¤‡é›‘ã§ã™ã€‚å¤‰æ›´ã™ã‚‹éš›ã¯ã€ç„¡é™ãƒ«ãƒ¼ãƒ—ã‚„ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ä½ä¸‹ã«ç´°å¿ƒã®æ³¨æ„ã‚’æ‰•ã£ã¦ãã ã•ã„ã€‚
* **Shift Management**: ã‚¹ã‚¿ãƒƒãƒ•ã®ã‚·ãƒ•ãƒˆç®¡ç†ã¯ã€çŒ«ã®ä¸–è©±ï¼ˆCare Scheduleï¼‰ã¨é€£å‹•ã—ã¦ã„ã¾ã™ã€‚

---

**Mission Statement:**
å…¨ã¦ã¯çŒ«ã®ãŸã‚ã«ï¼ˆAll Four Catsï¼‰ã€‚
ç§ãŸã¡ã¯ã€ãƒ–ãƒªãƒ¼ãƒ€ãƒ¼ãŒçŒ«ã®ã‚±ã‚¢ã«é›†ä¸­ã§ãã‚‹ã€æœ€é«˜ã®ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã‚’ä½œã‚Šã¾ã™ã€‚
````

## File: IMPLEMENTATION_COMPLETE.md
````markdown
# UnifiedModal ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ©Ÿèƒ½å®Ÿè£…å®Œäº†å ±å‘Š âœ…

## å®Ÿè£…æ—¥æ™‚
2026-01-30

## æ¦‚è¦
`UnifiedModal` ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«æ–°ã—ã„ `sections` ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¿½åŠ ã—ã€ãƒ¢ãƒ¼ãƒ€ãƒ«å†…ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’æ˜ç¢ºãªã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«åˆ†å‰²ã§ãã‚‹æ©Ÿèƒ½ã‚’å®Ÿè£…ã—ã¾ã—ãŸã€‚

## å®Ÿè£…çµ±è¨ˆ

### ã‚³ãƒ¼ãƒ‰å¤‰æ›´
- **å¤‰æ›´ãƒ•ã‚¡ã‚¤ãƒ«æ•°**: 9ãƒ•ã‚¡ã‚¤ãƒ«
- **è¿½åŠ è¡Œæ•°**: +1,774è¡Œ
- **å‰Šé™¤è¡Œæ•°**: -10è¡Œ
- **ã‚³ãƒŸãƒƒãƒˆæ•°**: 4ä»¶

### ãƒ•ã‚¡ã‚¤ãƒ«å†…è¨³
```
M  frontend/src/components/common/UnifiedModal.tsx                (+68/-10)
A  frontend/src/components/common/__tests__/UnifiedModal.test.tsx (+148)
A  frontend/src/components/common/UnifiedModalSectionsDemo.tsx    (+143)
A  frontend/src/components/common/UNIFIED_MODAL_SECTIONS.md       (+232)
A  frontend/src/app/demo/unified-modal/page.tsx                   (+187)
A  PR_SUMMARY.md                                                  (+169)
A  UNIFIED_MODAL_SECTIONS_SUMMARY.md                              (+252)
A  UNIFIED_MODAL_SECTIONS_VISUAL_GUIDE.md                         (+284)
A  UNIFIED_MODAL_FLOW_DIAGRAM.md                                  (+291)
```

## å“è³ªä¿è¨¼çµæœ

### âœ… ã™ã¹ã¦ã®å“è³ªã‚²ãƒ¼ãƒˆã‚’ã‚¯ãƒªã‚¢

| ãƒã‚§ãƒƒã‚¯é …ç›® | çµæœ | è©³ç´° |
|------------|------|------|
| ESLint | âœ… PASS | è­¦å‘Š0ä»¶ |
| TypeScriptå‹ãƒã‚§ãƒƒã‚¯ | âœ… PASS | ã‚¨ãƒ©ãƒ¼0ä»¶ |
| Next.jsãƒ“ãƒ«ãƒ‰ | âœ… PASS | 28ãƒšãƒ¼ã‚¸ç”ŸæˆæˆåŠŸ |
| Jestãƒ†ã‚¹ãƒˆ | âœ… PASS | 7/7ãƒ†ã‚¹ãƒˆåˆæ ¼ |

### ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸
- å¾Œæ–¹äº’æ›æ€§ãƒ†ã‚¹ãƒˆï¼ˆchildrenä½¿ç”¨ï¼‰
- ã‚»ã‚¯ã‚·ãƒ§ãƒ³åŸºæœ¬æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ
- Dividerè‡ªå‹•æŒ¿å…¥ãƒ†ã‚¹ãƒˆ
- ãƒ©ãƒ™ãƒ«ãªã—ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ
- å˜ä¸€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ
- ãƒ¢ãƒ¼ãƒ€ãƒ«é–‹é–‰çŠ¶æ…‹ãƒ†ã‚¹ãƒˆ
- ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°è¨­å®šãƒ†ã‚¹ãƒˆ

## ä¸»è¦æ©Ÿèƒ½

### 1. å‹å®‰å…¨ãªã‚»ã‚¯ã‚·ãƒ§ãƒ³å®šç¾©
```typescript
interface ModalSection {
  label?: string;
  content: ReactNode;
}
```

### 2. ç›¸äº’æ’ä»–çš„ãªå‹ã‚·ã‚¹ãƒ†ãƒ 
TypeScriptã®discriminated unionã«ã‚ˆã‚Š`children`ã¨`sections`ã®åŒæ™‚ä½¿ç”¨ã‚’é˜²æ­¢

### 3. è‡ªå‹•DivideræŒ¿å…¥
- 2ç•ªç›®ä»¥é™ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³å‰ã«è‡ªå‹•æŒ¿å…¥
- æœ€åˆã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚‚ãƒ©ãƒ™ãƒ«ã‚ã‚Šãªã‚‰æŒ¿å…¥
- ãƒ©ãƒ™ãƒ«ãªã—ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚‚é©åˆ‡ã«å‡¦ç†

### 4. å®Œå…¨ãªå¾Œæ–¹äº’æ›æ€§
æ—¢å­˜ã‚³ãƒ¼ãƒ‰ã¸ã®å½±éŸ¿ã‚¼ãƒ­

## ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

### åŒ…æ‹¬çš„ãªã‚¬ã‚¤ãƒ‰
1. **ä½¿ç”¨ã‚¬ã‚¤ãƒ‰** - `frontend/src/components/common/UNIFIED_MODAL_SECTIONS.md`
   - åŸºæœ¬çš„ãªä½¿ã„æ–¹
   - å®Ÿéš›ã®ä¾‹
   - å‹å®šç¾©

2. **å®Ÿè£…ã‚µãƒãƒªãƒ¼** - `UNIFIED_MODAL_SECTIONS_SUMMARY.md`
   - å•é¡ŒèƒŒæ™¯
   - è§£æ±ºç­–
   - ãƒ¡ãƒªãƒƒãƒˆ

3. **ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ã‚¬ã‚¤ãƒ‰** - `UNIFIED_MODAL_SECTIONS_VISUAL_GUIDE.md`
   - Before/Afteræ¯”è¼ƒ
   - ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ä¾‹
   - ãƒ«ãƒ¼ãƒ«è©³ç´°

4. **ãƒ•ãƒ­ãƒ¼å›³** - `UNIFIED_MODAL_FLOW_DIAGRAM.md`
   - ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆæ§‹é€ 
   - å‡¦ç†ãƒ•ãƒ­ãƒ¼
   - ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹

5. **PRã‚µãƒãƒªãƒ¼** - `PR_SUMMARY.md`
   - ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒã‚¤ãƒ³ãƒˆ
   - å®Ÿè£…æ¦‚è¦

### ãƒ‡ãƒ¢

#### ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãƒ‡ãƒ¢
- URL: `http://localhost:3000/demo/unified-modal`
- ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ: `UnifiedModalSectionsDemo.tsx`
- ãƒšãƒ¼ã‚¸: `frontend/src/app/demo/unified-modal/page.tsx`

## ä½¿ç”¨ä¾‹

### Beforeï¼ˆå¾“æ¥ï¼‰
```tsx
<UnifiedModal opened={opened} onClose={onClose}>
  <TextInput label="åå‰" />
  <Divider my="xs" />
  <Select label="ç¨®åˆ¥" />
  <Divider />
  <Button>ä¿å­˜</Button>
</UnifiedModal>
```

### Afterï¼ˆã‚»ã‚¯ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ï¼‰
```tsx
const sections = [
  { label: 'åŸºæœ¬æƒ…å ±', content: <TextInput label="åå‰" /> },
  { label: 'è©³ç´°', content: <Select label="ç¨®åˆ¥" /> },
  { content: <Button>ä¿å­˜</Button> },
];

<UnifiedModal sections={sections} opened={opened} onClose={onClose} />
```

## ãƒ¡ãƒªãƒƒãƒˆ

### é–‹ç™ºè€…ä½“é¨“
- âœ… å‹å®‰å…¨æ€§ï¼ˆTypeScriptã«ã‚ˆã‚‹èª¤ç”¨é˜²æ­¢ï¼‰
- âœ… ã‚³ãƒ¼ãƒ‰ã®å¯èª­æ€§å‘ä¸Šï¼ˆã‚»ã‚¯ã‚·ãƒ§ãƒ³ã”ã¨ã«åˆ†å‰²ï¼‰
- âœ… ä¿å®ˆæ€§å‘ä¸Šï¼ˆé…åˆ—ã§ç®¡ç†ï¼‰
- âœ… çµ±ä¸€æ€§ï¼ˆä¸€è²«ã—ãŸã‚¹ã‚¿ã‚¤ãƒ«ï¼‰

### ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“
- âœ… è¦–èªæ€§å‘ä¸Šï¼ˆå¢ƒç•ŒãŒæ˜ç¢ºï¼‰
- âœ… ç†è§£ã—ã‚„ã™ã•ï¼ˆãƒ©ãƒ™ãƒ«ã§å†…å®¹ãŒåˆ†ã‹ã‚‹ï¼‰
- âœ… æ•´ç†ã•ã‚ŒãŸæƒ…å ±ï¼ˆéšå±¤æ§‹é€ ï¼‰

## ä»Šå¾Œã®å±•é–‹

### æ¨å¥¨é©ç”¨ç®‡æ‰€
1. `cat-edit-modal.tsx` - å¤šæ•°ã®ãƒ•ã‚©ãƒ¼ãƒ é …ç›®
2. `kitten-disposition-modal.tsx` - æ¡ä»¶åˆ†å²ãŒå¤šã„
3. `EditTenantModal.tsx` - è¤‡æ•°ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³

### æ®µéšçš„ç§»è¡Œ
æ—¢å­˜ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’æ®µéšçš„ã«æ–°æ©Ÿèƒ½ã«ç§»è¡Œã™ã‚‹ã“ã¨ã§ã€UIçµ±ä¸€æ€§ã‚’ã•ã‚‰ã«å‘ä¸Š

## ã‚³ãƒŸãƒƒãƒˆå±¥æ­´

```
95f3139 docs: Add PR summary and flow diagrams
1044742 docs: Add comprehensive documentation for UnifiedModal sections feature
277aee8 docs: Add demo page for UnifiedModal sections feature
e45d5c6 feat: Add sections support to UnifiedModal component
```

## æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯

- Next.js 15 (App Router)
- React 19
- TypeScript 5
- Mantine UI
- Jest (ãƒ†ã‚¹ãƒ†ã‚£ãƒ³ã‚°)

## çµè«–

ã“ã®å®Ÿè£…ã«ã‚ˆã‚Š:

1. âœ… **å•é¡Œè§£æ±º**: å¢ƒç•Œã®æ›–æ˜§ã•ã€çµ±ä¸€æ€§ã®æ¬ å¦‚ã€ä¿å®ˆæ€§ã®å•é¡Œã‚’å®Œå…¨ã«è§£æ±º
2. âœ… **å“è³ªä¿è¨¼**: ã™ã¹ã¦ã®å“è³ªã‚²ãƒ¼ãƒˆã‚’ã‚¯ãƒªã‚¢
3. âœ… **å¾Œæ–¹äº’æ›æ€§**: æ—¢å­˜ã‚³ãƒ¼ãƒ‰ã¸ã®å½±éŸ¿ãªã—
4. âœ… **ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**: åŒ…æ‹¬çš„ãªã‚¬ã‚¤ãƒ‰ã¨ãƒ‡ãƒ¢ã‚’æä¾›
5. âœ… **å‹å®‰å…¨æ€§**: TypeScriptã«ã‚ˆã‚‹å¼·åŠ›ãªå‹ãƒã‚§ãƒƒã‚¯

é–‹ç™ºè€…ä½“é¨“ã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã®ä¸¡æ–¹ãŒå¤§å¹…ã«æ”¹å–„ã•ã‚Œã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®å“è³ªå‘ä¸Šã«è²¢çŒ®ã—ã¾ã™ã€‚

---

**å®Ÿè£…å®Œäº†** âœ…  
**ãƒ¬ãƒ“ãƒ¥ãƒ¼æº–å‚™å®Œäº†** âœ…  
**ãƒãƒ¼ã‚¸æº–å‚™å®Œäº†** âœ…
````

## File: scripts/validate-deployment-config.sh
````bash
#!/bin/bash
# Deployment Configuration Validation Script
# This script validates that the deployment configuration is correct before actual deployment

# Don't exit on first error - we want to see all validation results
set +e

echo "ğŸ” Validating Cloud Run Deployment Configuration..."
echo ""

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Counters
PASS=0
FAIL=0
WARN=0

# Function to print success
success() {
    echo -e "${GREEN}âœ… PASS${NC}: $1"
    ((PASS++))
}

# Function to print failure
failure() {
    echo -e "${RED}âŒ FAIL${NC}: $1"
    ((FAIL++))
}

# Function to print warning
warning() {
    echo -e "${YELLOW}âš ï¸  WARN${NC}: $1"
    ((WARN++))
}

echo "=== Checking GitHub Actions Workflow Configuration ==="
echo ""

# Check if deploy-only.yml exists
if [ -f ".github/workflows/deploy-only.yml" ]; then
    success "deploy-only.yml exists"
else
    failure "deploy-only.yml not found"
fi

# Check for production substitutions - ç‹¬è‡ªãƒ‰ãƒ¡ã‚¤ãƒ³
if grep -q "BACKEND_URL=\"https://api.nekoya.co.jp\"" .github/workflows/deploy-only.yml; then
    success "Production uses custom domain for backend (api.nekoya.co.jp)"
else
    failure "Production missing custom domain for backend"
fi

if grep -q "FRONTEND_URL=\"https://nekoya.co.jp\"" .github/workflows/deploy-only.yml; then
    success "Production uses custom domain for frontend (nekoya.co.jp)"
else
    failure "Production missing custom domain for frontend"
fi

# Check for RESEND_API_KEY configuration
if grep -q "_RESEND_API_KEY_SECRET_NAME=RESEND_API_KEY" .github/workflows/deploy-only.yml; then
    success "deploy-only.yml includes RESEND_API_KEY secret configuration"
else
    failure "deploy-only.yml missing RESEND_API_KEY secret configuration"
fi

if grep -q "_RESEND_API_KEY_SECRET_VERSION=latest" .github/workflows/deploy-only.yml; then
    success "deploy-only.yml includes RESEND_API_KEY version"
else
    failure "deploy-only.yml missing RESEND_API_KEY version"
fi

# Check for EMAIL configuration
if grep -q "_EMAIL_FROM=noreply@nekoya.co.jp" .github/workflows/deploy-only.yml; then
    success "deploy-only.yml includes EMAIL_FROM configuration"
else
    failure "deploy-only.yml missing EMAIL_FROM configuration"
fi

if grep -q "_EMAIL_FROM_NAME=MyCats Pro" .github/workflows/deploy-only.yml; then
    success "deploy-only.yml includes EMAIL_FROM_NAME configuration"
else
    failure "deploy-only.yml missing EMAIL_FROM_NAME configuration"
fi

# Check for database secrets
if grep -q "_DATABASE_URL_SECRET_NAME=DATABASE_URL" .github/workflows/deploy-only.yml; then
    success "deploy-only.yml includes DATABASE_URL secret"
else
    failure "deploy-only.yml missing DATABASE_URL secret"
fi

# Check for JWT secrets
if grep -q "_JWT_SECRET_NAME=JWT_SECRET" .github/workflows/deploy-only.yml; then
    success "deploy-only.yml includes JWT_SECRET"
else
    failure "deploy-only.yml missing JWT_SECRET"
fi

if grep -q "_JWT_REFRESH_SECRET_NAME=JWT_REFRESH_SECRET" .github/workflows/deploy-only.yml; then
    success "deploy-only.yml includes JWT_REFRESH_SECRET"
else
    failure "deploy-only.yml missing JWT_REFRESH_SECRET"
fi

# Check for CSRF token secret
if grep -q "_CSRF_TOKEN_SECRET_NAME=CSRF_TOKEN_SECRET" .github/workflows/deploy-only.yml; then
    success "deploy-only.yml includes CSRF_TOKEN_SECRET"
else
    failure "deploy-only.yml missing CSRF_TOKEN_SECRET"
fi

# Check for Frontend Service Account configuration
if grep -q "FRONTEND_SA.*GCP_RUN_SA_FRONTEND" .github/workflows/deploy-only.yml; then
    success "deploy-only.yml includes FRONTEND_SA configuration"
else
    failure "deploy-only.yml missing FRONTEND_SA configuration"
fi

# Check for Frontend Service Account in substitutions
if grep -q "_FRONTEND_SERVICE_ACCOUNT=\${FRONTEND_SA}" .github/workflows/deploy-only.yml; then
    success "deploy-only.yml includes _FRONTEND_SERVICE_ACCOUNT in substitutions"
else
    failure "deploy-only.yml missing _FRONTEND_SERVICE_ACCOUNT in substitutions"
fi

echo ""
echo "=== Checking cloudbuild.yaml Configuration ==="
echo ""

# Check if cloudbuild.yaml exists
if [ -f "cloudbuild.yaml" ]; then
    success "cloudbuild.yaml exists"
else
    failure "cloudbuild.yaml not found"
fi

# Check for correct env vars syntax
if grep -q 'NODE_ENV=\${_ENVIRONMENT}' cloudbuild.yaml; then
    success "cloudbuild.yaml uses NODE_ENV=\${_ENVIRONMENT}"
else
    failure "cloudbuild.yaml NODE_ENV syntax incorrect"
fi

# Check for set-secrets syntax including RESEND_API_KEY
if grep -q 'RESEND_API_KEY=\${_RESEND_API_KEY_SECRET_NAME}:\${_RESEND_API_KEY_SECRET_VERSION}' cloudbuild.yaml; then
    success "cloudbuild.yaml includes RESEND_API_KEY secret mounting"
else
    failure "cloudbuild.yaml missing RESEND_API_KEY secret mounting"
fi

# Check for EMAIL_FROM env var
if grep -q 'EMAIL_FROM=\${_EMAIL_FROM}' cloudbuild.yaml; then
    success "cloudbuild.yaml includes EMAIL_FROM env var"
else
    failure "cloudbuild.yaml missing EMAIL_FROM env var"
fi

# Check for EMAIL_FROM_NAME env var
if grep -q 'EMAIL_FROM_NAME=\${_EMAIL_FROM_NAME}' cloudbuild.yaml; then
    success "cloudbuild.yaml includes EMAIL_FROM_NAME env var"
else
    failure "cloudbuild.yaml missing EMAIL_FROM_NAME env var"
fi

echo ""
echo "=== Checking Backend Environment Validation ==="
echo ""

# Check if env.validation.ts exists and includes 'staging'
if [ -f "backend/src/common/config/env.validation.ts" ]; then
    success "env.validation.ts exists"
    
    if grep -q "z.enum(\['development', 'staging', 'production', 'test'\])" backend/src/common/config/env.validation.ts; then
        success "env.validation.ts includes 'staging' in NODE_ENV enum"
    else
        failure "env.validation.ts missing 'staging' in NODE_ENV enum"
    fi
else
    failure "env.validation.ts not found"
fi

# Check old validation file
if [ -f "backend/src/common/environment.validation.ts" ]; then
    if grep -q '"development", "staging", "production", "test"' backend/src/common/environment.validation.ts; then
        success "environment.validation.ts includes 'staging'"
    else
        warning "environment.validation.ts may need 'staging' update"
    fi
fi

echo ""
echo "=== Checking GCP Secret Manager (requires gcloud auth) ==="
echo ""

# CIç’°å¢ƒã§ã¯ GCP Secret Manager ã®æ¤œè¨¼ã‚’ã‚¹ã‚­ãƒƒãƒ—
if [ -n "$CI" ] || [ -n "$GITHUB_ACTIONS" ]; then
    warning "CIç’°å¢ƒã®ãŸã‚ GCP Secret Manager ã®æ¤œè¨¼ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™"
else
    # Check if gcloud is available
    if command -v gcloud &> /dev/null; then
        PROJECT_ID=$(gcloud config get-value project 2>/dev/null)
        if [ -n "$PROJECT_ID" ]; then
            echo "Project: $PROJECT_ID"
            
            # Check for required secrets
            for secret in DATABASE_URL JWT_SECRET JWT_REFRESH_SECRET CSRF_TOKEN_SECRET RESEND_API_KEY; do
                if gcloud secrets describe "$secret" --project="$PROJECT_ID" &> /dev/null; then
                    success "GCP Secret exists: $secret"
                else
                    failure "GCP Secret missing: $secret"
                fi
            done
        else
            warning "No GCP project configured, skipping secret validation"
        fi
    else
        warning "gcloud CLI not available, skipping GCP secret validation"
    fi
fi

echo ""
echo "=== Checking YAML Syntax ==="
echo ""

# Check if yamllint is available
if command -v yamllint &> /dev/null; then
    if yamllint -d "{extends: relaxed, rules: {line-length: disable}}" .github/workflows/deploy-only.yml > /dev/null 2>&1; then
        success "deploy-only.yml YAML syntax is valid"
    else
        failure "deploy-only.yml has YAML syntax errors"
    fi
    
    if yamllint -d "{extends: relaxed, rules: {line-length: disable}}" cloudbuild.yaml > /dev/null 2>&1; then
        success "cloudbuild.yaml YAML syntax is valid"
    else
        failure "cloudbuild.yaml has YAML syntax errors"
    fi
else
    warning "yamllint not available, skipping YAML validation"
fi

echo ""
echo "=== Summary ==="
echo ""
echo -e "${GREEN}Passed: $PASS${NC}"
if [ $WARN -gt 0 ]; then
    echo -e "${YELLOW}Warnings: $WARN${NC}"
fi
if [ $FAIL -gt 0 ]; then
    echo -e "${RED}Failed: $FAIL${NC}"
fi

echo ""
if [ $FAIL -eq 0 ]; then
    echo -e "${GREEN}ğŸ‰ All critical checks passed! Configuration looks good.${NC}"
    exit 0
else
    echo -e "${RED}âŒ Some checks failed. Please review and fix the issues above.${NC}"
    exit 1
fi
````

## File: frontend/src/app/breeding/components/RaisingTab.tsx
````typescript
'use client';

import { Fragment } from 'react';
import {
  Card,
  Text,
  Group,
  Table,
  Badge,
  Tooltip,
  Box,
} from '@mantine/core';
import {
  IconChevronDown,
  IconChevronRight,
  IconHomePlus,
  IconHeartHandshake,
  IconCloud,
} from '@tabler/icons-react';
import { ActionButton, ActionIconButton } from '@/components/ActionButton';
import { TagDisplay } from '@/components/TagSelector';
import type { BirthPlan, KittenDisposition } from '@/lib/api/hooks/use-breeding';
import type { Cat } from '@/lib/api/hooks/use-cats';
import type { TagCategoryView } from '@/lib/api/hooks/use-tags';
import { calculateAgeInDays } from '../utils';

export interface RaisingTabProps {
  allCats: Cat[];
  birthPlans: BirthPlan[];
  tagCategories: TagCategoryView[];
  expandedRaisingCats: Set<string>;
  isLoading: boolean;
  onToggleExpand: (motherId: string) => void;
  onComplete: (birthPlan: BirthPlan) => void;
  onOpenManagementModal: (motherId: string) => void;
}

interface MotherWithKittens {
  mother: Cat;
  kittens: Cat[];
  birthPlan: BirthPlan | undefined;
}

export function RaisingTab({
  allCats,
  birthPlans,
  tagCategories,
  expandedRaisingCats,
  isLoading,
  onToggleExpand,
  onComplete,
  onOpenManagementModal,
}: RaisingTabProps) {
  if (isLoading) {
    return (
      <Card padding="md" radius="md" withBorder>
        <Text ta="center" c="dimmed" py="xl">èª­ã¿è¾¼ã¿ä¸­...</Text>
      </Card>
    );
  }

  // å­çŒ«ã‚’æŒã¤æ¯çŒ«ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼ˆå®Œäº†ã—ã¦ã„ãªã„å‡ºç”£è¨˜éŒ²ã®ã¿ï¼‰
  const mothersWithKittens: MotherWithKittens[] = allCats
    .filter((cat) => {
      // ã“ã®æ¯çŒ«ã®æœªå®Œäº†ã®å‡ºç”£è¨˜éŒ²ã‚’ç¢ºèª
      const activeBirthPlan = birthPlans.find(
        (bp) => bp.motherId === cat.id && bp.status === 'BORN' && !bp.completedAt
      );
      
      if (!activeBirthPlan) return false;
      
      // ç”Ÿå¾Œ90æ—¥ä»¥å†…ã®å­çŒ«ãŒã„ã‚‹æ¯çŒ«ã‚’æŠ½å‡º
      const hasYoungKittens = allCats.some((kitten) => {
        if (kitten.motherId !== cat.id) return false;
        
        const ageInDays = calculateAgeInDays(kitten.birthDate);
        
        return ageInDays <= 90;
      });
      
      return hasYoungKittens;
    })
    .map((mother) => {
      // ã“ã®æ¯çŒ«ã®å­çŒ«ã‚’å–å¾—
      const kittens = allCats.filter((kitten) => {
        if (kitten.motherId !== mother.id) return false;
        
        const ageInDays = calculateAgeInDays(kitten.birthDate);
        
        return ageInDays <= 90;
      });

      // ã“ã®æ¯çŒ«ã®BirthPlanã‚’å–å¾—
      const birthPlan = birthPlans.find(
        (bp) => bp.motherId === mother.id && bp.status === 'BORN' && !bp.completedAt
      );
      
      return { mother, kittens, birthPlan };
    });

  /**
   * å­çŒ«ã®è¡Œå…ˆæƒ…å ±ã‚’å–å¾—
   */
  const getKittenDisposition = (kittenId: string, birthPlan: BirthPlan | undefined): KittenDisposition | undefined => {
    return birthPlan?.kittenDispositions?.find((d) => d.kittenId === kittenId);
  };

  /**
   * è¡Œå…ˆã‚¢ã‚¤ã‚³ãƒ³ã‚’è¡¨ç¤º
   */
  const renderDispositionIcon = (disposition: KittenDisposition) => {
    switch (disposition.disposition) {
      case 'TRAINING':
        return (
          <Tooltip label="é¤Šæˆ">
            <Box component="span">
              <IconHomePlus size={16} color="var(--mantine-color-blue-6)" />
            </Box>
          </Tooltip>
        );
      case 'SALE':
        return (
          <Tooltip label="å‡ºè·">
            <Box component="span">
              <IconHeartHandshake size={16} color="var(--mantine-color-green-6)" />
            </Box>
          </Tooltip>
        );
      case 'DECEASED':
        return (
          <Tooltip label="æ­»äº¡">
            <Box component="span">
              <IconCloud size={16} color="var(--mantine-color-gray-5)" />
            </Box>
          </Tooltip>
        );
      default:
        return null;
    }
  };

  if (mothersWithKittens.length === 0) {
    return (
      <Card padding="md" radius="md" withBorder>
        <Text ta="center" c="dimmed" py="xl">
          ç¾åœ¨å­è‚²ã¦ä¸­ã®æ¯çŒ«ã¯ã„ã¾ã›ã‚“
        </Text>
      </Card>
    );
  }

  return (
    <Card padding="md" radius="md" withBorder>
      <Table striped withTableBorder>
        <Table.Thead>
          <Table.Tr>
            <Table.Th style={{ width: '40px' }}></Table.Th>
            <Table.Th>æ¯çŒ«å</Table.Th>
            <Table.Th>çˆ¶çŒ«å</Table.Th>
            <Table.Th>å‡ºç”£æ—¥</Table.Th>
            <Table.Th>ç”Ÿå¾Œ</Table.Th>
            <Table.Th>å­çŒ«æ•°</Table.Th>
            <Table.Th>è¡Œå…ˆå®Œäº†</Table.Th>
          </Table.Tr>
        </Table.Thead>
        <Table.Tbody>
          {mothersWithKittens.map(({ mother, kittens, birthPlan }) => {
            const isExpanded = expandedRaisingCats.has(mother.id);
            const oldestKitten = kittens.length > 0 ? kittens.reduce((oldest, k) => 
              new Date(k.birthDate) < new Date(oldest.birthDate) ? k : oldest
            ) : null;
            
            const ageInDays = oldestKitten 
              ? calculateAgeInDays(oldestKitten.birthDate)
              : 0;

            // å‡ºç”£æ•°ã¨æ­»äº¡æ•°ã‚’è¨ˆç®—
            const totalBorn = birthPlan?.actualKittens || kittens.length;
            const alive = kittens.length;
            const dead = totalBorn - alive;

            // è¡Œå…ˆç¢ºå®šæ¸ˆã¿ã®å­çŒ«æ•°ã‚’è¨ˆç®—
            const disposedCount = kittens.filter(
              (k) => getKittenDisposition(k.id, birthPlan)
            ).length;
            const allDisposed = disposedCount === kittens.length && kittens.length > 0;

            return (
              <Fragment key={mother.id}>
                {/* æ¯çŒ«ã®è¡Œ */}
                <Table.Tr
                  style={{ cursor: 'pointer', backgroundColor: isExpanded ? '#f8f9fa' : undefined }}
                  onClick={() => onToggleExpand(mother.id)}
                >
                  <Table.Td>
                    {isExpanded ? <IconChevronDown size={16} /> : <IconChevronRight size={16} />}
                  </Table.Td>
                  <Table.Td>
                    <Text fw={500}>{mother.name}</Text>
                  </Table.Td>
                  <Table.Td>
                    {birthPlan?.fatherId
                      ? allCats.find((c) => c.id === birthPlan.fatherId)?.name || 'ä¸æ˜'
                      : 'ä¸æ˜'
                    }
                  </Table.Td>
                  <Table.Td>
                    {oldestKitten 
                      ? new Date(oldestKitten.birthDate).toLocaleDateString('ja-JP')
                      : '-'
                    }
                  </Table.Td>
                  <Table.Td>
                    {ageInDays}æ—¥
                  </Table.Td>
                  <Table.Td>
                    {alive}é ­ï¼ˆ{totalBorn}-{dead}ï¼‰
                    {disposedCount > 0 && (
                      <Text size="xs" c="dimmed" component="span" ml={4}>
                        è¡Œå…ˆ{disposedCount}/{kittens.length}
                      </Text>
                    )}
                  </Table.Td>
                  <Table.Td>
                    {birthPlan && !birthPlan.completedAt ? (
                      allDisposed ? (
                        <ActionButton
                          action="confirm"
                          onClick={(e) => {
                            e.stopPropagation();
                            onComplete(birthPlan);
                          }}
                        >
                          å®Œäº†
                        </ActionButton>
                      ) : (
                        <Text size="xs" c="dimmed">è¡Œå…ˆæœªç¢ºå®š</Text>
                      )
                    ) : birthPlan?.completedAt ? (
                      <Badge color="green" size="sm">å®Œäº†æ¸ˆ</Badge>
                    ) : (
                      <Text size="sm" c="dimmed">-</Text>
                    )}
                  </Table.Td>
                </Table.Tr>

                {/* å­çŒ«ã®è©³ç´°è¡Œ */}
                {isExpanded && kittens.map((kitten) => {
                  const disposition = getKittenDisposition(kitten.id, birthPlan);
                  const hasDisposition = !!disposition;

                  return (
                    <Table.Tr
                      key={kitten.id}
                      style={{
                        backgroundColor: hasDisposition ? 'var(--mantine-color-gray-2)' : '#f8f9fa',
                        opacity: hasDisposition ? 0.6 : 1,
                      }}
                    >
                      <Table.Td></Table.Td>
                      <Table.Td colSpan={1}>
                        <Group gap="xs">
                          <Text
                            size="sm"
                            pl="md"
                            c={hasDisposition ? 'dimmed' : undefined}
                            td={hasDisposition ? 'line-through' : undefined}
                          >
                            {kitten.name}
                          </Text>
                          {disposition && renderDispositionIcon(disposition)}
                        </Group>
                      </Table.Td>
                      <Table.Td>
                        <Text size="sm" c={hasDisposition ? 'dimmed' : undefined}>
                          {kitten.gender === 'MALE' ? 'ã‚ªã‚¹' : 'ãƒ¡ã‚¹'}
                        </Text>
                      </Table.Td>
                      <Table.Td>
                        <Text size="sm" c={hasDisposition ? 'dimmed' : undefined}>
                          {kitten.coatColor?.name || '-'}
                        </Text>
                      </Table.Td>
                      <Table.Td>
                        <Text size="sm" c={hasDisposition ? 'dimmed' : undefined}>
                          {calculateAgeInDays(kitten.birthDate)}æ—¥
                        </Text>
                      </Table.Td>
                      <Table.Td>
                        <Group gap="xs">
                          {kitten.tags && kitten.tags.length > 0 && (
                            <TagDisplay 
                              tagIds={kitten.tags.map(t => t.tag.id)} 
                              size="xs" 
                              categories={tagCategories}
                              tagMetadata={Object.fromEntries(
                                kitten.tags.map(t => [t.tag.id, t.tag.metadata || {}])
                              )}
                            />
                          )}
                        </Group>
                      </Table.Td>
                      <Table.Td>
                        {!hasDisposition && (
                          <ActionIconButton
                            action="edit"
                            customIcon={<IconHomePlus size={18} />}
                            onClick={(e) => {
                              e.stopPropagation();
                              onOpenManagementModal(mother.id);
                            }}
                            title="è¡Œå…ˆç®¡ç†"
                            aria-label="è¡Œå…ˆç®¡ç†"
                          />
                        )}
                      </Table.Td>
                    </Table.Tr>
                  );
                })}
              </Fragment>
            );
          })}
        </Table.Tbody>
      </Table>
    </Card>
  );
}
````

## File: frontend/src/app/breeding/components/ShippingTab.tsx
````typescript
'use client';

import {
  Card,
  Text,
  Group,
  Table,
  Badge,
  Center,
  Loader,
} from '@mantine/core';
import {
  IconHomePlus,
  IconHeartHandshake,
  IconChevronRight,
} from '@tabler/icons-react';
import { ActionIconButton } from '@/components/ActionButton';
import { useGetWeightRecords } from '@/lib/api/hooks/use-weight-records';
import {
  useCreateKittenDisposition,
  type BirthPlan,
  type DispositionType,
} from '@/lib/api/hooks/use-breeding';
import type { Cat } from '@/lib/api/hooks/use-cats';
import { GenderBadge } from '@/components/GenderBadge';
import { notifications } from '@mantine/notifications';
import { calculateAgeInDays } from '../utils';

/** å‡ºè·æº–å‚™å¯¾è±¡ã¨ãªã‚‹ä½“é‡é–¾å€¤ï¼ˆã‚°ãƒ©ãƒ ï¼‰ */
const SHIPPING_WEIGHT_THRESHOLD = 500;

export interface ShippingTabProps {
  allCats: Cat[];
  birthPlans: BirthPlan[];
  isLoading: boolean;
  onRefetch: () => void;
}

interface KittenWithWeight {
  id: string;
  name: string;
  gender: 'MALE' | 'FEMALE';
  color: string;
  motherId: string;
  motherName: string;
  fatherName: string;
  birthDate: string;
  birthPlanId: string;
}

/**
 * å‡ºè·æº–å‚™ã‚¿ãƒ–ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * ä½“é‡500gè¶…ãˆã®å­çŒ«ã‚’è¡¨ç¤ºã—ã€è¡Œå…ˆã‚’è¨­å®šã™ã‚‹
 */
export function ShippingTab({
  allCats,
  birthPlans,
  isLoading,
  onRefetch,
}: ShippingTabProps) {
  // å‡ºç”£è¨˜éŒ²ãŒã‚ã‚‹å­çŒ«ã‚’å–å¾—
  const kittensForShipping: KittenWithWeight[] = [];

  birthPlans
    .filter((bp) => bp.status === 'BORN' && !bp.completedAt)
    .forEach((birthPlan) => {
      const mother = allCats.find((c) => c.id === birthPlan.motherId);
      const father = birthPlan.fatherId
        ? allCats.find((c) => c.id === birthPlan.fatherId)
        : null;

      // ã“ã®æ¯çŒ«ã®å­çŒ«ã‚’å–å¾—ï¼ˆç”Ÿå¾Œ90æ—¥ä»¥å†…ï¼‰
      const kittens = allCats.filter((kitten) => {
        if (kitten.motherId !== birthPlan.motherId) return false;
        
        const ageInDays = calculateAgeInDays(kitten.birthDate);
        
        return ageInDays <= 90;
      });

      kittens.forEach((kitten) => {
        // æ—¢ã«è¡Œå…ˆãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å­çŒ«ã¯ã‚¹ã‚­ãƒƒãƒ—
        const existingDisposition = birthPlan.kittenDispositions?.find(
          (d) => d.kittenId === kitten.id
        );

        if (existingDisposition) return;

        kittensForShipping.push({
          id: kitten.id,
          name: kitten.name,
          gender: kitten.gender as 'MALE' | 'FEMALE',
          color: kitten.coatColor?.name ?? 'æœªç¢ºèª',
          motherId: birthPlan.motherId,
          motherName: mother?.name ?? 'ä¸æ˜',
          fatherName: father?.name ?? 'ä¸æ˜',
          birthDate: kitten.birthDate,
          birthPlanId: birthPlan.id,
        });
      });
    });

  if (isLoading) {
    return (
      <Card padding="md" radius="md" withBorder>
        <Center py="xl">
          <Loader size="sm" />
        </Center>
      </Card>
    );
  }

  if (kittensForShipping.length === 0) {
    return (
      <Card padding="md" radius="md" withBorder>
        <Text ta="center" c="dimmed" py="xl">
          å‡ºè·æº–å‚™å¯¾è±¡ã®å­çŒ«ã¯ã„ã¾ã›ã‚“
        </Text>
      </Card>
    );
  }

  return (
    <Card padding="md" radius="md" withBorder>
      <Text size="sm" c="dimmed" mb="md">
        ç”Ÿå¾Œ90æ—¥ä»¥å†…ã§è¡Œå…ˆæœªç¢ºå®šã®å­çŒ«ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚ä½“é‡{SHIPPING_WEIGHT_THRESHOLD}gè¶…ãˆã®å­çŒ«ã®ã¿è¡Œå…ˆã‚’è¨­å®šã§ãã¾ã™ã€‚
      </Text>

      <Table striped withTableBorder>
        <Table.Thead>
          <Table.Tr>
            <Table.Th>å­çŒ«å</Table.Th>
            <Table.Th>æ€§åˆ¥</Table.Th>
            <Table.Th>è‰²æŸ„</Table.Th>
            <Table.Th>æ¯çŒ«</Table.Th>
            <Table.Th>æœ€æ–°ä½“é‡</Table.Th>
            <Table.Th style={{ textAlign: 'center' }}>è¡Œå…ˆ</Table.Th>
          </Table.Tr>
        </Table.Thead>
        <Table.Tbody>
          {kittensForShipping.map((kitten) => (
            <KittenShippingRow
              key={kitten.id}
              kitten={kitten}
              onRefetch={onRefetch}
            />
          ))}
        </Table.Tbody>
      </Table>
    </Card>
  );
}

/**
 * å­çŒ«ã®å‡ºè·æº–å‚™è¡Œã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 */
interface KittenShippingRowProps {
  kitten: KittenWithWeight;
  onRefetch: () => void;
}

function KittenShippingRow({ kitten, onRefetch }: KittenShippingRowProps) {
  const { data: weightData, isLoading: isWeightLoading } = useGetWeightRecords({
    catId: kitten.id,
    limit: 1,
    sortOrder: 'desc',
  });

  const createDispositionMutation = useCreateKittenDisposition();

  const latestWeight = weightData?.data?.[0]?.weight ?? null;
  const isAboveThreshold = latestWeight !== null && latestWeight >= SHIPPING_WEIGHT_THRESHOLD;

  // 500gæœªæº€ã®å ´åˆã¯è¡¨ç¤ºã—ãªã„
  if (!isWeightLoading && !isAboveThreshold) {
    return null;
  }

  const handleSetDisposition = (disposition: DispositionType) => {
    // TODO: å°†æ¥çš„ã«ã¯ã€SALEã®å ´åˆã¯ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã„ã¦è³¼å…¥è€…æƒ…å ±ã‚’å…¥åŠ›ã•ã›ã‚‹
    // ç¾åœ¨ã¯ä»®ãƒ‡ãƒ¼ã‚¿ã§ä½œæˆã—ã€å¾Œã§ç·¨é›†ã™ã‚‹æƒ³å®š
    createDispositionMutation.mutate(
      {
        birthRecordId: kitten.birthPlanId,
        kittenId: kitten.id,
        name: kitten.name,
        gender: kitten.gender,
        disposition,
        ...(disposition === 'TRAINING' && {
          trainingStartDate: new Date().toISOString().split('T')[0],
        }),
        ...(disposition === 'SALE' && {
          saleInfo: {
            buyer: '',
            price: 0,
            saleDate: new Date().toISOString().split('T')[0],
          },
        }),
        ...(disposition === 'DECEASED' && {
          deathDate: new Date().toISOString().split('T')[0],
        }),
      },
      {
        onSuccess: () => {
          notifications.show({
            title: 'è¡Œå…ˆã‚’ç™»éŒ²ã—ã¾ã—ãŸ',
            message: `${kitten.name}ã®è¡Œå…ˆã‚’ç™»éŒ²ã—ã¾ã—ãŸ`,
            color: 'green',
          });
          onRefetch();
        },
        onError: (error) => {
          // è¡Œå…ˆç™»éŒ²ã«å¤±æ•—ã—ãŸå ´åˆã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚¨ãƒ©ãƒ¼ã‚’é€šçŸ¥ã™ã‚‹
          notifications.show({
            title: 'è¡Œå…ˆã®ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ',
            message: error instanceof Error 
              ? `ã‚¨ãƒ©ãƒ¼: ${error.message}` 
              : 'è¡Œå…ˆã®ç™»éŒ²ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
            color: 'red',
          });
        },
      }
    );
  };

  return (
    <Table.Tr>
      <Table.Td>
        <Group gap="xs" wrap="nowrap">
          <IconChevronRight size={12} color="var(--mantine-color-gray-4)" />
          <Text size="sm">{kitten.name}</Text>
        </Group>
      </Table.Td>
      <Table.Td>
        <GenderBadge gender={kitten.gender === 'MALE' ? 'ã‚ªã‚¹' : 'ãƒ¡ã‚¹'} size="sm" />
      </Table.Td>
      <Table.Td>
        <Text size="sm" c="dimmed">{kitten.color}</Text>
      </Table.Td>
      <Table.Td>
        <Text size="sm">{kitten.motherName}</Text>
      </Table.Td>
      <Table.Td>
        {isWeightLoading ? (
          <Loader size="xs" />
        ) : latestWeight !== null ? (
          <Badge
            size="sm"
            color={isAboveThreshold ? 'green' : 'gray'}
            variant="light"
          >
            {latestWeight}g
          </Badge>
        ) : (
          <Text size="xs" c="dimmed">æœªè¨˜éŒ²</Text>
        )}
      </Table.Td>
      <Table.Td>
        <Group gap={4} justify="center">
          <ActionIconButton
            action="confirm"
            customIcon={<IconHomePlus size={18} />}
            onClick={() => handleSetDisposition('TRAINING')}
            loading={createDispositionMutation.isPending}
            title="é¤Šæˆ"
            aria-label="é¤Šæˆã«è¨­å®š"
          />
          <ActionIconButton
            action="confirm"
            customIcon={<IconHeartHandshake size={18} />}
            onClick={() => handleSetDisposition('SALE')}
            loading={createDispositionMutation.isPending}
            title="å‡ºè·"
            aria-label="å‡ºè·ã«è¨­å®š"
          />
          <ActionIconButton
            action="delete"
            customIcon={<span>ğŸŒˆ</span>}
            onClick={() => handleSetDisposition('DECEASED')}
            loading={createDispositionMutation.isPending}
            title="æ­»äº¡"
            aria-label="æ­»äº¡ã«è¨­å®š"
          />
        </Group>
      </Table.Td>
    </Table.Tr>
  );
}
````

## File: frontend/src/app/cats/[id]/client.tsx
````typescript
'use client';

import { useState } from 'react';
import { useRouter, useSearchParams, usePathname } from 'next/navigation';
import {
  Box,
  Button,
  Card,
  Container,
  Group,
  Stack,
  Title,
  Text,
  Tabs,
  Flex,
  Badge,
  Loader,
  Center,
  Alert,
  Accordion,
  Divider,
  TextInput,
} from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { IconArrowLeft, IconEdit, IconUser, IconAlertCircle, IconChevronDown, IconDna } from '@tabler/icons-react';
import { PedigreeTab } from '@/components/cats/PedigreeTab';
import { useGetCat, useGetCats, type Cat } from '@/lib/api/hooks/use-cats';
import { useGetBirthPlans, type BirthPlan, type KittenDisposition } from '@/lib/api/hooks/use-breeding';
import { useGetCareSchedules, useGetMedicalRecords, type CareSchedule, type MedicalRecord } from '@/lib/api/hooks/use-care';
import { useTransferCat } from '@/lib/api/hooks/use-graduation';
import { format } from 'date-fns';
import { ja } from 'date-fns/locale';
import { KittenManagementModal } from '@/components/kittens/KittenManagementModal';
import { notifications } from '@mantine/notifications';

type CatTagRelation = NonNullable<Cat['tags']>[number];
type KittenWithDisposition = Cat & { disposition: KittenDisposition['disposition'] };

type Props = {
  catId: string;
};

// Gender labels (English for consistency with registration forms)
const GENDER_LABELS: Record<string, string> = {
  MALE: 'Male',
  FEMALE: 'Female',
  NEUTER: 'Neutered Male',
  SPAY: 'Spayed Female',
};

export default function CatDetailClient({ catId }: Props) {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();
  
  // URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰ã‚¿ãƒ–çŠ¶æ…‹ã‚’å–å¾—ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ 'basic'ï¼‰
  const tabParam = searchParams.get('tab') || 'basic';
  
  // ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆæ™‚ã«URLã‚’æ›´æ–°
  const handleTabChange = (nextTab: string | null) => {
    if (!nextTab) return;
    const nextParams = new URLSearchParams(searchParams);
    nextParams.set('tab', nextTab);
    router.push(`${pathname}?${nextParams.toString()}`);
  };
  
  const { data: cat, isLoading, error } = useGetCat(catId);
  const { data: catsResponse } = useGetCats();
  const { data: birthPlansResponse } = useGetBirthPlans();
  // ä¸€æ™‚çš„ã«ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãªã—ã§ã‚¯ã‚¨ãƒª
  const { data: careSchedulesResponse } = useGetCareSchedules({});
  const { data: medicalRecordsResponse } = useGetMedicalRecords({});
  const [managementModalOpened, { open: openManagementModal, close: closeManagementModal }] = useDisclosure(false);
   
  const [_selectedBirthPlanId, setSelectedBirthPlanId] = useState<string | undefined>();
  
  // è­²æ¸¡æ©Ÿèƒ½
  const { mutate: transferCat, isPending: isTransferring } = useTransferCat();
  
  // è­²æ¸¡æƒ…å ±ã®ã‚¹ãƒ†ãƒ¼ãƒˆ
  const [transferDestination, setTransferDestination] = useState('');
  const [transferDate, setTransferDate] = useState('');
  const [transferNotes, setTransferNotes] = useState('');

  if (isLoading) {
    return (
      <Center style={{ minHeight: '100vh' }}>
        <Loader size="lg" />
      </Center>
    );
  }

  if (error || !cat) {
    return (
      <Container size="lg" style={{ paddingTop: '2rem' }}>
        <Alert icon={<IconAlertCircle size={16} />} title="ã‚¨ãƒ©ãƒ¼" color="red">
          çŒ«ã®æƒ…å ±ã‚’èª­ã¿è¾¼ã‚ã¾ã›ã‚“ã§ã—ãŸã€‚
        </Alert>
        <Button
          mt="md"
          variant="light"
          leftSection={<IconArrowLeft size={16} />}
          onClick={() => router.push('/cats')}
        >
          ä¸€è¦§ã¸æˆ»ã‚‹
        </Button>
      </Container>
    );
  }

  const catData = cat.data;
  
  if (!catData) {
    return null;
  }

  // è­²æ¸¡å‡¦ç†
  const handleTransfer = () => {
    if (!transferDestination || !transferDate) {
      notifications.show({
        title: 'å…¥åŠ›ã‚¨ãƒ©ãƒ¼',
        message: 'è­²æ¸¡å…ˆã¨è­²æ¸¡æ—¥ã¯å¿…é ˆé …ç›®ã§ã™',
        color: 'red',
      });
      return;
    }

    transferCat(
      {
        catId: catData.id,
        data: {
          transferDate: new Date(transferDate).toISOString(),
          destination: transferDestination,
          notes: transferNotes || undefined,
        },
      },
      {
        onSuccess: () => {
          notifications.show({
            title: 'è­²æ¸¡å®Œäº†',
            message: `${catData.name}ã®è­²æ¸¡è¨˜éŒ²ã‚’ä½œæˆã—ã¾ã—ãŸ`,
            color: 'green',
          });
          // ã‚®ãƒ£ãƒ©ãƒªãƒ¼ãƒšãƒ¼ã‚¸ã¸ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ
          router.push('/gallery');
        },
        onError: (transferError) => {
          notifications.show({
            title: 'è­²æ¸¡å¤±æ•—',
            message: transferError instanceof Error ? transferError.message : 'è­²æ¸¡å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸ',
            color: 'red',
          });
        },
      }
    );
  };

  return (
  <Box style={{ minHeight: '100vh', backgroundColor: 'var(--background-base)' }}>
      {/* ãƒ˜ãƒƒãƒ€ãƒ¼ */}
      <Box
        style={{
          backgroundColor: 'var(--surface)',
          borderBottom: '1px solid var(--border-subtle)',
          padding: '1rem 0',
          boxShadow: '0 6px 20px rgba(15, 23, 42, 0.04)',
        }}
      >
        <Container size="xl">
          <Flex justify="space-between" align="center">
            <Button
              variant="subtle"
              color="gray"
              leftSection={<IconArrowLeft size={16} />}
              onClick={() => router.push('/cats')}
            >
              ä¸€è¦§ã¸æˆ»ã‚‹
            </Button>
            <Group gap="sm">
              <Button
                variant="outline"
                color="yellow"
                leftSection={<IconEdit size={16} />}
                onClick={() => router.push(`/cats/${catData.id}/edit`)}
              >
                ç·¨é›†
              </Button>
              <Button
                variant="outline"
                color="gray"
                leftSection={<IconUser size={16} />}
                onClick={() => router.push(`/cats/${catData.id}/pedigree`)}
              >
                è¡€çµ±è¡¨ã‚’è¦‹ã‚‹
              </Button>
            </Group>
          </Flex>
        </Container>
      </Box>

      <Container size="lg" style={{ paddingTop: '2rem', paddingBottom: '2rem' }}>
        {/* ã‚¿ãƒ–ã§è©³ç´°æƒ…å ± - URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§çŠ¶æ…‹ã‚’æ°¸ç¶šåŒ– */}
        <Tabs value={tabParam} onChange={handleTabChange}>
          <Tabs.List grow>
            <Tabs.Tab value="basic">åŸºæœ¬æƒ…å ±</Tabs.Tab>
            <Tabs.Tab value="pedigree" leftSection={<IconDna size={16} />}>è¡€çµ±</Tabs.Tab>
          </Tabs.List>

          <Tabs.Panel value="basic" pt="md">
            <Card shadow="sm" padding="lg" radius="md" withBorder>
              <Stack gap="lg">
                {/* åå‰ã¨ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ */}
                <div>
                  <Title order={2} mb="xs">{catData.name}</Title>
                  <Group gap="xs">
                    <Badge color={catData.isInHouse ? 'green' : 'gray'}>
                      {catData.isInHouse ? 'åœ¨èˆ' : 'ä¸åœ¨'}
                    </Badge>
                    {catData.tags && catData.tags.length > 0 && (
                      <>
                        {catData.tags.map((catTag: CatTagRelation) => (
                          <Badge
                            key={catTag.tag.id}
                            color={catTag.tag.color || 'blue'}
                            variant="light"
                          >
                            {catTag.tag.name}
                          </Badge>
                        ))}
                      </>
                    )}
                  </Group>
                </div>

                <Divider />

                {/* åŸºæœ¬æƒ…å ± */}
                <Stack gap="md">
                  <Group>
                    <Text fw={600} w={150}>å“ç¨®:</Text>
                    <Text>{catData.breed?.name || 'æœªç™»éŒ²'}</Text>
                  </Group>
                  <Group>
                    <Text fw={600} w={150}>æ€§åˆ¥:</Text>
                    <Text>{GENDER_LABELS[catData.gender] || catData.gender}</Text>
                  </Group>
                  <Group>
                    <Text fw={600} w={150}>ç”Ÿå¹´æœˆæ—¥:</Text>
                    <Text>{format(new Date(catData.birthDate), 'yyyyå¹´MMæœˆddæ—¥', { locale: ja })}</Text>
                  </Group>
                  <Group>
                    <Text fw={600} w={150}>è‰²æŸ„:</Text>
                    <Text>{catData.coatColor?.name || 'æœªç™»éŒ²'}</Text>
                  </Group>
                  {catData.microchipNumber && (
                    <Group>
                      <Text fw={600} w={150}>ãƒã‚¤ã‚¯ãƒ­ãƒãƒƒãƒ—:</Text>
                      <Text>{catData.microchipNumber}</Text>
                    </Group>
                  )}
                  {catData.registrationNumber && (
                    <Group>
                      <Text fw={600} w={150}>ç™»éŒ²ç•ªå·:</Text>
                      <Text>{catData.registrationNumber}</Text>
                    </Group>
                  )}
                  {catData.description && (
                    <Box>
                      <Text fw={600} mb="xs">èª¬æ˜:</Text>
                      <Text>{catData.description}</Text>
                    </Box>
                  )}
                </Stack>

                <Divider />

                {/* è¦ªæƒ…å ± */}
                <Stack gap="md">
                  <Text fw={600} size="lg">è¦ªæƒ…å ±</Text>
                  <Group>
                    <Text fw={600} w={150}>çˆ¶:</Text>
                    {catData.father ? (
                      <Button
                        variant="subtle"
                        size="sm"
                        onClick={() => catData.father && router.push(`/cats/${catData.father.id}`)}
                      >
                        {catData.father.name}
                      </Button>
                    ) : (
                      <Text c="dimmed">æœªç™»éŒ²</Text>
                    )}
                  </Group>
                  <Group>
                    <Text fw={600} w={150}>æ¯:</Text>
                    {catData.mother ? (
                      <Button
                        variant="subtle"
                        size="sm"
                        onClick={() => catData.mother && router.push(`/cats/${catData.mother.id}`)}
                      >
                        {catData.mother.name}
                      </Button>
                    ) : (
                      <Text c="dimmed">æœªç™»éŒ²</Text>
                    )}
                  </Group>
                </Stack>

                <Divider />

                {/* ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ã‚ªãƒ³ã‚»ã‚¯ã‚·ãƒ§ãƒ³ */}
                <Accordion variant="contained">
                  {/* å‡ºç”£è¨˜éŒ²ï¼ˆãƒ¡ã‚¹ã®å ´åˆã®ã¿ï¼‰ */}
                  {(catData.gender === 'FEMALE' || catData.gender === 'SPAY') && (
                    <Accordion.Item value="births">
                      <Accordion.Control icon={<IconChevronDown size={16} />}>
                        å‡ºç”£è¨˜éŒ²
                      </Accordion.Control>
                      <Accordion.Panel>
                        {(() => {
                          const birthPlans: BirthPlan[] = birthPlansResponse?.data ?? [];
                          const completedBirthPlans = birthPlans.filter(
                            (plan) => plan.motherId === catData.id && plan.status === 'BORN'
                          );

                          if (completedBirthPlans.length === 0) {
                            return (
                              <Text c="dimmed" size="sm">
                                å‡ºç”£è¨˜éŒ²ã¯ã¾ã ã‚ã‚Šã¾ã›ã‚“
                              </Text>
                            );
                          }

                          const allKittens: Cat[] = catsResponse?.data ?? [];

                          return (
                            <Stack gap="md">
                              {completedBirthPlans.map((plan) => {
                                const dispositions = plan.kittenDispositions ?? [];
                                const latestDispositions = dispositions.reduce<KittenDisposition[]>((acc, disposition) => {
                                  const key = disposition.kittenId ?? disposition.id;
                                  const existingIndex = acc.findIndex((item) => (item.kittenId ?? item.id) === key);

                                  if (existingIndex === -1) {
                                    acc.push(disposition);
                                    return acc;
                                  }

                                  const existing = acc[existingIndex];
                                  if (new Date(disposition.createdAt) > new Date(existing.createdAt)) {
                                    acc[existingIndex] = disposition;
                                  }
                                  return acc;
                                }, []);

                                const trainingCount = latestDispositions.filter((disposition) => disposition.disposition === 'TRAINING').length;
                                const saleCount = latestDispositions.filter((disposition) => disposition.disposition === 'SALE').length;
                                const deceasedCount = latestDispositions.filter((disposition) => disposition.disposition === 'DECEASED').length;
                                const totalKittens = latestDispositions.length;

                                const kittens = latestDispositions
                                  .map((disposition) => {
                                    const kitten = allKittens.find((candidate) => candidate.id === disposition.kittenId);
                                    return kitten ? { ...kitten, disposition: disposition.disposition } : null;
                                  })
                                  .filter((kitten): kitten is KittenWithDisposition => kitten !== null);

                                return (
                                  <Card key={plan.id} withBorder padding="md">
                                    <Stack gap="sm">
                                      <Group justify="space-between" wrap="nowrap">
                                        <Group gap="md" wrap="wrap">
                                          <Text size="sm" fw={600}>
                                            çˆ¶: {plan.father?.name || 'ä¸æ˜'}
                                          </Text>
                                          <Text size="sm">
                                            å‡ºç”£æ—¥: {plan.matingDate ? format(new Date(plan.matingDate), 'yyyy/MM/dd', { locale: ja }) : 'ä¸æ˜'}
                                          </Text>
                                          <Text size="sm">
                                            å‡ºç”£: {totalKittens}é ­
                                          </Text>
                                          <Text size="sm" c="red">
                                            æ­»äº¡: {deceasedCount}é ­
                                          </Text>
                                          <Text size="sm" c="green">
                                            å‡ºè·: {saleCount}é ­
                                          </Text>
                                          <Text size="sm" c="blue">
                                            é¤Šæˆ: {trainingCount}é ­
                                          </Text>
                                        </Group>
                                        <Button
                                          size="xs"
                                          variant="light"
                                          onClick={() => {
                                            setSelectedBirthPlanId(plan.id);
                                            openManagementModal();
                                          }}
                                        >
                                          ä¿®æ­£
                                        </Button>
                                      </Group>

                                      {kittens.length > 0 && (
                                        <Accordion variant="separated">
                                          <Accordion.Item value="kittens">
                                            <Accordion.Control>
                                              <Text size="sm">å­çŒ«æƒ…å ± ({kittens.length}é ­)</Text>
                                            </Accordion.Control>
                                            <Accordion.Panel>
                                              <Stack gap="xs">
                                                {kittens.map((kitten) => {
                                                  const dispositionIcon =
                                                    kitten.disposition === 'TRAINING'
                                                      ? 'ğŸ“'
                                                      : kitten.disposition === 'SALE'
                                                        ? 'ğŸ’°'
                                                        : kitten.disposition === 'DECEASED'
                                                          ? 'ğŸŒˆ'
                                                          : '';

                                                  return (
                                                    <Group key={kitten.id} justify="space-between" wrap="nowrap">
                                                      <Group gap="md" wrap="wrap">
                                                        <Text size="sm" fw={500} style={{ minWidth: '80px' }}>
                                                          {kitten.name}
                                                        </Text>
                                                        <Badge size="sm" color={kitten.gender === 'MALE' ? 'blue' : 'pink'}>
                                                          {kitten.gender === 'MALE' ? 'ã‚ªã‚¹' : 'ãƒ¡ã‚¹'}
                                                        </Badge>
                                                        <Text size="sm" c="dimmed">
                                                          {kitten.coatColor?.name || 'è‰²æŸ„æœªç™»éŒ²'}
                                                        </Text>
                                                        {dispositionIcon && (
                                                          <Badge size="sm" variant="light">
                                                            {dispositionIcon}{' '}
                                                            {kitten.disposition === 'TRAINING'
                                                              ? 'é¤Šæˆä¸­'
                                                              : kitten.disposition === 'SALE'
                                                                ? 'å‡ºè·æ¸ˆ'
                                                                : 'æ­»äº¡'}
                                                          </Badge>
                                                        )}
                                                      </Group>
                                                    </Group>
                                                  );
                                                })}
                                              </Stack>
                                            </Accordion.Panel>
                                          </Accordion.Item>
                                        </Accordion>
                                      )}
                                    </Stack>
                                  </Card>
                                );
                              })}
                            </Stack>
                          );
                        })()}
                      </Accordion.Panel>
                    </Accordion.Item>
                  )}

                  {/* ã‚±ã‚¢ãƒãƒ¼ãƒˆ */}
                  <Accordion.Item value="care">
                    <Accordion.Control icon={<IconChevronDown size={16} />}>
                      ã‚±ã‚¢ãƒãƒ¼ãƒˆ
                    </Accordion.Control>
                    <Accordion.Panel>
                      {(() => {
                        const careSchedules: CareSchedule[] = careSchedulesResponse?.data ?? [];
                        const catCareSchedules = careSchedules.filter(
                          (schedule) =>
                            schedule.cat?.id === catData.id ||
                            schedule.cats?.some((careCat) => careCat.id === catData.id)
                        );

                        if (catCareSchedules.length === 0) {
                          return (
                            <Text c="dimmed" size="sm">
                              ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®è¨˜éŒ²ã¯ã¾ã ã‚ã‚Šã¾ã›ã‚“
                            </Text>
                          );
                        }

                        return (
                          <Stack gap="xs">
                            {catCareSchedules.map((schedule) => (
                              <Group key={schedule.id} gap="md" wrap="nowrap">
                                <Text size="sm" fw={500} style={{ minWidth: '120px' }}>
                                  {schedule.name || schedule.title}
                                </Text>
                                <Text size="sm" c="dimmed">
                                  {format(new Date(schedule.scheduleDate), 'yyyy/MM/dd', { locale: ja })}
                                </Text>
                                <Text size="sm" style={{ flex: 1 }}>
                                  {schedule.description || 'ãƒ¡ãƒ¢ãªã—'}
                                </Text>
                              </Group>
                            ))}
                          </Stack>
                        );
                      })()}
                    </Accordion.Panel>
                  </Accordion.Item>

                  {/* åŒ»ç™‚è¨˜éŒ² */}
                  <Accordion.Item value="medical">
                    <Accordion.Control icon={<IconChevronDown size={16} />}>
                      åŒ»ç™‚è¨˜éŒ²
                    </Accordion.Control>
                    <Accordion.Panel>
                      {(() => {
                        const medicalRecords: MedicalRecord[] = medicalRecordsResponse?.data ?? [];
                        const catMedicalRecords = medicalRecords.filter(
                          (record) => record.cat?.id === catData.id
                        );

                        if (catMedicalRecords.length === 0) {
                          return (
                            <Text c="dimmed" size="sm">
                              åŒ»ç™‚è¨˜éŒ²ã¯ã¾ã ã‚ã‚Šã¾ã›ã‚“
                            </Text>
                          );
                        }

                        return (
                          <Stack gap="xs">
                            {catMedicalRecords.map((record) => (
                              <Card key={record.id} withBorder padding="sm">
                                <Group gap="md" wrap="wrap">
                                  <Text size="sm" fw={500}>
                                    {format(new Date(record.visitDate), 'yyyy/MM/dd', { locale: ja })}
                                  </Text>
                                  <Text size="sm">
                                    ç—‡çŠ¶: {record.symptom || 'è¨˜è¼‰ãªã—'}
                                  </Text>
                                  <Text size="sm">
                                    æ²»ç™‚çµæœ: {record.diagnosis || 'è¨˜è¼‰ãªã—'}
                                  </Text>
                                  <Badge size="sm" color={record.status === 'COMPLETED' ? 'green' : 'orange'}>
                                    {record.status === 'COMPLETED' ? 'å®Œäº†' : 'æ²»ç™‚ä¸­'}
                                  </Badge>
                                </Group>
                              </Card>
                            ))}
                          </Stack>
                        );
                      })()}
                    </Accordion.Panel>
                  </Accordion.Item>

                  {/* è­²æ¸¡æƒ…å ± */}
                  <Accordion.Item value="transfer">
                    <Accordion.Control icon={<IconChevronDown size={16} />}>
                      è­²æ¸¡æƒ…å ±
                    </Accordion.Control>
                    <Accordion.Panel>
                      <Stack gap="md">
                        <Group align="flex-end" wrap="nowrap">
                          <TextInput
                            label="è­²æ¸¡å…ˆ"
                            placeholder="è­²æ¸¡å…ˆã‚’å…¥åŠ›"
                            value={transferDestination}
                            onChange={(e) => setTransferDestination(e.currentTarget.value)}
                            style={{ flex: 1 }}
                          />
                          <TextInput
                            label="è­²æ¸¡æ—¥"
                            type="date"
                            value={transferDate}
                            onChange={(e) => setTransferDate(e.currentTarget.value)}
                            style={{ width: '180px' }}
                          />
                          <TextInput
                            label="å‚™è€ƒ"
                            placeholder="å‚™è€ƒã‚’å…¥åŠ›"
                            value={transferNotes}
                            onChange={(e) => setTransferNotes(e.currentTarget.value)}
                            style={{ flex: 1 }}
                          />
                          <Button
                            onClick={handleTransfer}
                            disabled={!transferDestination || !transferDate}
                            loading={isTransferring}
                          >
                            ç™»éŒ²
                          </Button>
                        </Group>
                        <Text c="dimmed" size="xs">
                          â€» ç™»éŒ²å¾Œã€ã“ã®çŒ«ã¯ã‚®ãƒ£ãƒ©ãƒªãƒ¼ãƒšãƒ¼ã‚¸ã¸ç§»å‹•ã•ã‚Œã¾ã™
                        </Text>
                      </Stack>
                    </Accordion.Panel>
                  </Accordion.Item>
                </Accordion>
              </Stack>
            </Card>
          </Tabs.Panel>

          <Tabs.Panel value="pedigree" pt="md">
            <PedigreeTab catId={catData.id} />
          </Tabs.Panel>
        </Tabs>

        {/* å­çŒ«ç®¡ç†ãƒ¢ãƒ¼ãƒ€ãƒ« */}
        {(catData.gender === 'FEMALE' || catData.gender === 'SPAY') && (
          <KittenManagementModal
            opened={managementModalOpened}
            onClose={closeManagementModal}
            motherId={catData.id}
            onSuccess={() => {
              // ãƒ‡ãƒ¼ã‚¿å†å–å¾—
              if (catsResponse) {
                window.location.reload();
              }
            }}
          />
        )}
      </Container>
    </Box>
  );
}
````

## File: frontend/src/app/gallery/components/GalleryTabs.tsx
````typescript
'use client';

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¿ãƒ–ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * ã‚«ãƒ†ã‚´ãƒªåˆ‡ã‚Šæ›¿ãˆã¨URLã‚¯ã‚¨ãƒªåŒæœŸ
 */

import { Tabs, Group, Badge } from '@mantine/core';
import {
  IconBabyCarriage,
  IconGenderMale,
  IconGenderFemale,
  IconTrophy,
} from '@tabler/icons-react';
import { useGalleryTab, TAB_LABELS } from '../hooks/useGalleryTab';
import type { GalleryCategory } from '@/lib/api/hooks/use-gallery';

/**
 * ã‚¿ãƒ–ã‚¢ã‚¤ã‚³ãƒ³ãƒãƒƒãƒ”ãƒ³ã‚°
 */
const TAB_ICONS: Record<GalleryCategory, React.ReactNode> = {
  KITTEN: <IconBabyCarriage size={16} />,
  FATHER: <IconGenderMale size={16} />,
  MOTHER: <IconGenderFemale size={16} />,
  GRADUATION: <IconTrophy size={16} />,
};

/**
 * ã‚¿ãƒ–ã‚«ãƒ©ãƒ¼ãƒãƒƒãƒ”ãƒ³ã‚°
 */
const TAB_COLORS: Record<GalleryCategory, string> = {
  KITTEN: 'pink',
  FATHER: 'blue',
  MOTHER: 'violet',
  GRADUATION: 'yellow',
};

interface GalleryTabsProps {
  /** å„ã‚«ãƒ†ã‚´ãƒªã®ä»¶æ•° */
  counts?: Record<GalleryCategory, number>;
  /** ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ä¸­ãƒ•ãƒ©ã‚° */
  loading?: boolean;
}

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ã‚¿ãƒ–ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 *
 * @example
 * ```tsx
 * <GalleryTabs counts={{ KITTEN: 5, FATHER: 3, MOTHER: 4, GRADUATION: 10 }} />
 * ```
 */
export function GalleryTabs({ counts, loading }: GalleryTabsProps) {
  const { currentTab, setTab, validTabs } = useGalleryTab();

  return (
    <Tabs
      value={currentTab}
      onChange={(value) => {
        if (value) {
          setTab(value as GalleryCategory);
        }
      }}
    >
      <Tabs.List>
        {validTabs.map((tab) => (
          <Tabs.Tab
            key={tab}
            value={tab}
            leftSection={TAB_ICONS[tab]}
            disabled={loading}
          >
            <Group gap="xs">
              <span>{TAB_LABELS[tab]}</span>
              {counts && counts[tab] !== undefined && (
                <Badge size="xs" variant="light" color={TAB_COLORS[tab]}>
                  {counts[tab]}
                </Badge>
              )}
            </Group>
          </Tabs.Tab>
        ))}
      </Tabs.List>
    </Tabs>
  );
}
````

## File: frontend/src/app/medical-records/page.tsx
````typescript
'use client';

import { useMemo, useState, useEffect } from 'react';
import {
  Alert,
  Badge,
  Box,
  Button,
  Card,
  Container,
  Group,
  LoadingOverlay,
  Pagination,
  Select,
  SegmentedControl,
  Skeleton,
  Stack,
  Table,
  Text,
  TextInput,
  Textarea,
} from '@mantine/core';
import { DatePickerInput } from '@mantine/dates';
import { useDisclosure } from '@mantine/hooks';
import { IconAlertCircle, IconCalendarPlus, IconX } from '@tabler/icons-react';
import dayjs from 'dayjs';

import {
  type MedicalRecord,
  type GetMedicalRecordsParams,
  useCreateMedicalRecord,
  useGetMedicalRecords,
} from '@/lib/api/hooks/use-care';
import { useGetCats } from '@/lib/api/hooks/use-cats';
import { useGetTagCategories } from '@/lib/api/hooks/use-tags';
import { usePageHeader } from '@/lib/contexts/page-header-context';

import { ActionButton } from '@/components/ActionButton';
import { IconActionButton } from '@/components/buttons';
import { UnifiedModal } from '@/components/common';

const STATUS_LABELS = {
  TREATING: 'æ²»ç™‚ä¸­',
  COMPLETED: 'å®Œäº†',
} as const;

const STATUS_COLORS = {
  TREATING: 'yellow',
  COMPLETED: 'green',
} as const;

const PAGE_LIMIT = 10;

function formatDate(value: string | null | undefined) {
  if (!value) return '-';
  return dayjs(value).format('YYYYå¹´MMæœˆDDæ—¥');
}

function truncateText(text: string | null | undefined, maxLength = 10): string {
  if (!text) return '-';
  if (text.length <= maxLength) return text;
  return text.substring(0, maxLength) + '...';
}

interface CreateMedicalRecordFormState {
  catId: string;
  visitDate: Date | null;
  hospitalName: string;
  symptomTags: string[]; // ã‚¿ã‚°IDé…åˆ—
  diagnosis: string;
  treatmentPlan: string;
  status: string;
  followUpDate: Date | null;
  notes: string;
}

export default function MedicalRecordsPage() {
  const { setPageHeader } = usePageHeader();

  const [page, setPage] = useState(1);
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedCatId, setSelectedCatId] = useState<string | null>(null);

  const [createModalOpened, { open: openCreateModal, close: closeCreateModal }] = useDisclosure(false);
  const [detailModalOpened, { open: openDetailModal, close: closeDetailModal }] = useDisclosure(false);
  const [detailRecord, setDetailRecord] = useState<MedicalRecord | null>(null);

  const [createForm, setCreateForm] = useState<CreateMedicalRecordFormState>({
    catId: '',
    visitDate: new Date(),
    hospitalName: '',
    symptomTags: [],
    diagnosis: '',
    treatmentPlan: '',
    status: 'TREATING',
    followUpDate: null,
    notes: '',
  });
  const [createError, setCreateError] = useState<string | null>(null);

  const medicalRecordsParams = useMemo(() => {
    const params: Record<string, unknown> = {
      page,
      limit: PAGE_LIMIT,
    };
    if (selectedCatId) {
      params.catId = selectedCatId;
    }
    return params as unknown as GetMedicalRecordsParams;
  }, [page, selectedCatId]);

  const medicalRecordsQuery = useGetMedicalRecords(medicalRecordsParams);
  const createMedicalRecordMutation = useCreateMedicalRecord();

  const catsQuery = useGetCats({ limit: 100 });
  const tagsQuery = useGetTagCategories();

  // åŒ»ç™‚ãƒ‡ãƒ¼ã‚¿ãƒšãƒ¼ã‚¸ç”¨ã®ã‚¿ã‚°ã‚’å–å¾—ï¼ˆå¥åº·ã‚«ãƒ†ã‚´ãƒªã‹ã‚‰ç—‡çŠ¶ã‚¿ã‚°ã‚’æŠ½å‡ºï¼‰
  const medicalTags = useMemo(() => {
    const categories = tagsQuery.data?.data || [];
    const healthCategory = categories.find(cat => cat.key === 'health' || cat.name.includes('å¥åº·'));
    if (!healthCategory) return [];
    
    // å¥åº·ã‚«ãƒ†ã‚´ãƒªå†…ã®å…¨ã‚¿ã‚°ã‚’å–å¾—
    return healthCategory.tags || [];
  }, [tagsQuery.data]);

  // ãƒšãƒ¼ã‚¸ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’è¨­å®š
  useEffect(() => {
    setPageHeader(
      'åŒ»ç™‚ãƒ‡ãƒ¼ã‚¿',
      <ActionButton
        action="create"
        customIcon={<IconCalendarPlus size={18} />}
        onClick={openCreateModal}
      >
        æ–°è¦åŒ»ç™‚è¨˜éŒ²
      </ActionButton>
    );

    return () => setPageHeader(null);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const resetCreateForm = () => {
    setCreateForm({
      catId: '',
      visitDate: new Date(),
      hospitalName: '',
      symptomTags: [],
      diagnosis: '',
      treatmentPlan: '',
      status: 'TREATING',
      followUpDate: null,
      notes: '',
    });
    setCreateError(null);
  };

  const handleCreateSubmit = () => {
    const trimmedCatId = createForm.catId.trim();
    const trimmedHospitalName = createForm.hospitalName.trim();
    const trimmedDiagnosis = createForm.diagnosis.trim();
    const trimmedTreatmentPlan = createForm.treatmentPlan.trim();
    const trimmedNotes = createForm.notes.trim();

    if (!trimmedCatId) {
      setCreateError('å¯¾è±¡çŒ«ã¯å¿…é ˆã§ã™ã€‚');
      return;
    }

    if (!createForm.visitDate) {
      setCreateError('å—è¨ºæ—¥ã¯å¿…é ˆã§ã™ã€‚');
      return;
    }

    setCreateError(null);

    createMedicalRecordMutation.mutate(
      {
        catId: trimmedCatId,
        visitDate: dayjs(createForm.visitDate).toISOString(),
        hospitalName: trimmedHospitalName || undefined,
        diagnosis: trimmedDiagnosis || undefined,
        treatmentPlan: trimmedTreatmentPlan || undefined,
        status: createForm.status as 'TREATING' | 'COMPLETED',
        followUpDate: createForm.followUpDate ? dayjs(createForm.followUpDate).toISOString() : undefined,
        notes: trimmedNotes || undefined,
      },
      {
        onSuccess: () => {
          resetCreateForm();
          closeCreateModal();
          void medicalRecordsQuery.refetch();
        },
      },
    );
  };

  const records = medicalRecordsQuery.data?.data ?? [];
  const meta = medicalRecordsQuery.data?.meta ?? {
    total: 0,
    totalPages: 1,
    page,
    limit: PAGE_LIMIT,
  };

  const isInitialLoading = medicalRecordsQuery.isLoading && records.length === 0;
  const isEmpty = !isInitialLoading && records.length === 0;

  return (
    <Container size="lg">
      <Card withBorder shadow="xs" radius="md">
        <LoadingOverlay visible={medicalRecordsQuery.isFetching && !medicalRecordsQuery.isLoading} zIndex={10} />
        <Stack gap="md">
          {medicalRecordsQuery.isError && (
            <Alert color="red" icon={<IconAlertCircle size={18} />}>
              åŒ»ç™‚è¨˜éŒ²ã®å–å¾—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚
            </Alert>
          )}

          {/* ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ */}
          <Group grow>
            <Select
              placeholder="çŒ«ã‚’é¸æŠ"
              data={(catsQuery.data?.data ?? []).map((cat) => ({
                value: cat.id,
                label: cat.name,
              }))}
              value={selectedCatId}
              onChange={setSelectedCatId}
              clearable
            />
            <TextInput
              placeholder="æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰"
              value={searchTerm}
              onChange={(event) => setSearchTerm(event.currentTarget.value)}
            />
          </Group>

          {isInitialLoading ? (
            <Stack>
              {Array.from({ length: 4 }).map((_, index) => (
                <Skeleton key={index} height={72} radius="md" />
              ))}
            </Stack>
          ) : isEmpty ? (
            <Card padding="xl" radius="md" bg="gray.0">
              <Stack gap="sm" align="center">
                <IconAlertCircle size={28} color="var(--mantine-color-teal-6)" />
                <Text fw={600}>è¡¨ç¤ºã™ã‚‹åŒ»ç™‚è¨˜éŒ²ã¯ã‚ã‚Šã¾ã›ã‚“</Text>
                <Text size="sm" c="dimmed" ta="center">
                  åŒ»ç™‚è¨˜éŒ²ã‚’è¿½åŠ ã—ã¦ã€çŒ«ã®å¥åº·çŠ¶æ…‹ã‚’ç®¡ç†ã—ã¾ã—ã‚‡ã†ã€‚
                </Text>
                <ActionButton
                  action="create"
                  onClick={openCreateModal}
                >
                  åŒ»ç™‚è¨˜éŒ²ã‚’ç™»éŒ²ã™ã‚‹
                </ActionButton>
              </Stack>
            </Card>
          ) : (
            <>
              <Table verticalSpacing="sm" highlightOnHover>
                <Table.Thead>
                  <Table.Tr>
                    <Table.Th style={{ width: '15%' }}>å—è¨ºæ—¥</Table.Th>
                    <Table.Th style={{ width: '15%' }}>çŒ«å</Table.Th>
                    <Table.Th style={{ width: '25%' }}>ç—‡çŠ¶ãƒ»è¨ºæ–­</Table.Th>
                    <Table.Th style={{ width: '15%' }}>ç—…é™¢å</Table.Th>
                    <Table.Th style={{ width: '15%' }}>çŠ¶æ…‹</Table.Th>
                    <Table.Th style={{ width: '15%', textAlign: 'center' }}>æ“ä½œ</Table.Th>
                  </Table.Tr>
                </Table.Thead>
                <Table.Tbody>
                  {records.map((record) => (
                    <Table.Tr key={record.id}>
                      <Table.Td>
                        <Text size="sm" fw={500}>
                          {formatDate(record.visitDate)}
                        </Text>
                      </Table.Td>
                      <Table.Td>
                        <Text size="sm" fw={500}>
                          {record.cat.name}
                        </Text>
                      </Table.Td>
                      <Table.Td>
                        <Stack gap={4}>
                          <Text size="sm" c={record.diagnosis ? undefined : 'dimmed'}>
                            {record.diagnosis ? truncateText(record.diagnosis, 12) : 'è¨ºæ–­ãªã—'}
                          </Text>
                          {record.symptom && (
                            <Text size="xs" c="dimmed">
                              {truncateText(record.symptom, 12)}
                            </Text>
                          )}
                          {record.tags && record.tags.length > 0 && (
                            <Group gap={4}>
                              {record.tags.slice(0, 2).map((tag) => (
                                <Badge
                                  key={tag.id}
                                  size="xs"
                                  variant="dot"
                                  color={tag.color || 'blue'}
                                >
                                  {tag.name}
                                </Badge>
                              ))}
                              {record.tags.length > 2 && (
                                <Text size="xs" c="dimmed">
                                  +{record.tags.length - 2}
                                </Text>
                              )}
                            </Group>
                          )}
                        </Stack>
                      </Table.Td>
                      <Table.Td>
                        <Text size="sm" c={record.hospitalName ? undefined : 'dimmed'}>
                          {record.hospitalName || 'æœªè¨­å®š'}
                        </Text>
                      </Table.Td>
                      <Table.Td>
                        <Badge color={STATUS_COLORS[record.status]} variant="light">
                          {STATUS_LABELS[record.status]}
                        </Badge>
                      </Table.Td>
                      <Table.Td>
                        <Group gap="xs" justify="center">
                          <IconActionButton
                            variant="view"
                            onClick={() => {
                              setDetailRecord(record);
                              openDetailModal();
                            }}
                          />
                        </Group>
                      </Table.Td>
                    </Table.Tr>
                  ))}
                </Table.Tbody>
              </Table>

              {meta.totalPages > 1 && (
                <Group justify="center">
                  <Pagination
                    value={meta.page ?? page}
                    onChange={(value) => setPage(value)}
                    total={meta.totalPages}
                    siblings={1}
                  />
                </Group>
              )}
            </>
          )}
        </Stack>
      </Card>

      <UnifiedModal
        opened={detailModalOpened}
        onClose={closeDetailModal}
        title="åŒ»ç™‚è¨˜éŒ²ã®è©³ç´°"
        size="lg"
        sections={[
          {
            label: 'åŸºæœ¬æƒ…å ±',
            content: detailRecord ? (
              <>
                <Group justify="space-between">
                  <Box>
                    <Text size="sm" c="dimmed" mb={4}>
                      å—è¨ºæ—¥
                    </Text>
                    <Text fw={500}>{formatDate(detailRecord.visitDate)}</Text>
                  </Box>
                  <Box>
                    <Text size="sm" c="dimmed" mb={4}>
                      çŠ¶æ…‹
                    </Text>
                    <Badge color={STATUS_COLORS[detailRecord.status]} variant="light">
                      {STATUS_LABELS[detailRecord.status]}
                    </Badge>
                  </Box>
                </Group>

                <Box>
                  <Text size="sm" c="dimmed" mb={4}>
                    å¯¾è±¡çŒ«
                  </Text>
                  <Text fw={500}>{detailRecord.cat.name}</Text>
                </Box>

                <Box>
                  <Text size="sm" c="dimmed" mb={4}>
                    ç—…é™¢å
                  </Text>
                  <Text fw={500}>{detailRecord.hospitalName || 'æœªè¨­å®š'}</Text>
                </Box>
              </>
            ) : null,
          },
          {
            label: 'ç—‡çŠ¶',
            content: detailRecord ? (
              <>
                <Box>
                  <Text size="sm" c="dimmed" mb={4}>
                    ç—‡çŠ¶
                  </Text>
                  <Text>{detailRecord.symptom || 'è¨˜éŒ²ãªã—'}</Text>
                </Box>

                {detailRecord.tags && detailRecord.tags.length > 0 && (
                  <Box>
                    <Text size="sm" c="dimmed" mb={8}>
                      ç—‡çŠ¶ã‚¿ã‚°
                    </Text>
                    <Group gap="xs">
                      {detailRecord.tags.map((tag) => (
                        <Badge
                          key={tag.id}
                          color={tag.color || 'blue'}
                          variant="light"
                          size="lg"
                        >
                          {tag.categoryName && `${tag.categoryName} > `}
                          {tag.groupName && `${tag.groupName} > `}
                          {tag.name}
                        </Badge>
                      ))}
                    </Group>
                  </Box>
                )}

                <Box>
                  <Text size="sm" c="dimmed" mb={4}>
                    ç—…å
                  </Text>
                  <Text>{detailRecord.diseaseName || 'è¨˜éŒ²ãªã—'}</Text>
                </Box>

                {detailRecord.symptomDetails && detailRecord.symptomDetails.length > 0 && (
                  <Box>
                    <Text size="sm" c="dimmed" mb={8}>
                      ç—‡çŠ¶è©³ç´°
                    </Text>
                    <Stack gap="xs">
                      {detailRecord.symptomDetails.map((symptom, index) => (
                        <Card key={index} withBorder padding="sm">
                          <Text fw={500} size="sm">{symptom.label}</Text>
                          {symptom.note && (
                            <Text size="sm" c="dimmed" mt={4}>{symptom.note}</Text>
                          )}
                        </Card>
                      ))}
                    </Stack>
                  </Box>
                )}
              </>
            ) : null,
          },
          {
            label: 'è¨ºæ–­ãƒ»æ²»ç™‚',
            content: detailRecord ? (
              <>
                <Box>
                  <Text size="sm" c="dimmed" mb={4}>
                    è¨ºæ–­
                  </Text>
                  <Text>{detailRecord.diagnosis || 'è¨˜éŒ²ãªã—'}</Text>
                </Box>

                <Box>
                  <Text size="sm" c="dimmed" mb={4}>
                    æ²»ç™‚è¨ˆç”»
                  </Text>
                  <Text>{detailRecord.treatmentPlan || 'è¨˜éŒ²ãªã—'}</Text>
                </Box>

                {detailRecord.medications && detailRecord.medications.length > 0 && (
                  <Box>
                    <Text size="sm" c="dimmed" mb={8}>
                      æŠ•è–¬
                    </Text>
                    <Stack gap="xs">
                      {detailRecord.medications.map((medication, index) => (
                        <Card key={index} withBorder padding="sm">
                          <Text fw={500} size="sm">{medication.name}</Text>
                          {medication.dosage && (
                            <Text size="sm" c="dimmed" mt={4}>{medication.dosage}</Text>
                          )}
                        </Card>
                      ))}
                    </Stack>
                  </Box>
                )}

                <Group grow>
                  <Box>
                    <Text size="sm" c="dimmed" mb={4}>
                      æ¬¡å›äºˆå®šæ—¥
                    </Text>
                    <Text>{formatDate(detailRecord.followUpDate)}</Text>
                  </Box>
                </Group>

                <Box>
                  <Text size="sm" c="dimmed" mb={4}>
                    å‚™è€ƒ
                  </Text>
                  <Text>{detailRecord.notes || 'ãªã—'}</Text>
                </Box>

                <Group justify="space-between" mt="md">
                  <Text size="xs" c="dimmed">
                    è¨˜éŒ²è€…: {detailRecord.recordedBy}
                  </Text>
                  <Text size="xs" c="dimmed">
                    ä½œæˆæ—¥: {dayjs(detailRecord.createdAt).format('YYYY/MM/DD HH:mm')}
                  </Text>
                </Group>
              </>
            ) : null,
          },
          {
            content: (
              <Group justify="flex-end">
                <ActionButton action="cancel" onClick={closeDetailModal}>
                  é–‰ã˜ã‚‹
                </ActionButton>
              </Group>
            ),
          },
        ]}
      />

      <UnifiedModal
        opened={createModalOpened}
        onClose={() => {
          closeCreateModal();
          resetCreateForm();
        }}
        title="åŒ»ç™‚è¨˜éŒ²ã‚’è¿½åŠ "
        size="lg"
        sections={[
          {
            label: 'åŸºæœ¬æƒ…å ±',
            content: (
              <>
                <Select
                  label="å¯¾è±¡çŒ«"
                  placeholder="çŒ«ã‚’é¸æŠ"
                  data={(catsQuery.data?.data ?? []).map((cat) => ({
                    value: cat.id,
                    label: cat.name,
                  }))}
                  value={createForm.catId}
                  onChange={(value) => setCreateForm((prev) => ({ ...prev, catId: value || '' }))}
                  required
                />

                <DatePickerInput
                  label="å—è¨ºæ—¥"
                  placeholder="å—è¨ºæ—¥ã‚’é¸æŠ"
                  value={createForm.visitDate}
                  onChange={(value) =>
                    setCreateForm((prev) => ({
                      ...prev,
                      visitDate: value ? new Date(value) : null,
                    }))
                  }
                  required
                />

                <TextInput
                  label="ç—…é™¢å"
                  placeholder="ä¾‹: ã­ã“ã‚¯ãƒªãƒ‹ãƒƒã‚¯æ±äº¬"
                  value={createForm.hospitalName}
                  onChange={(event) =>
                    setCreateForm((prev) => ({
                      ...prev,
                      hospitalName: event.target.value,
                    }))
                  }
                />
              </>
            ),
          },
          {
            label: 'ç—‡çŠ¶ãƒ»è¨ºæ–­',
            content: (
              <>
                <Box>
                  <Text size="sm" fw={500} mb="xs">
                    ç—‡çŠ¶ã‚¿ã‚°
                  </Text>
                  {tagsQuery.isLoading ? (
                    <Skeleton height={40} />
                  ) : medicalTags.length > 0 ? (
                    <>
                      <Group gap="xs" mb="sm">
                        {medicalTags.map((tag) => {
                          const isSelected = createForm.symptomTags.includes(tag.id);
                          return (
                            <Button
                              key={tag.id}
                              variant={isSelected ? 'filled' : 'outline'}
                              color={isSelected ? tag.color || 'blue' : 'gray'}
                              size="xs"
                              rightSection={isSelected ? <IconX size={12} /> : undefined}
                              onClick={() => {
                                setCreateForm((prev) => ({
                                  ...prev,
                                  symptomTags: isSelected
                                    ? prev.symptomTags.filter((id) => id !== tag.id)
                                    : [...prev.symptomTags, tag.id],
                                }));
                              }}
                            >
                              {tag.name}
                            </Button>
                          );
                        })}
                      </Group>
                      {createForm.symptomTags.length > 0 && (
                        <Text size="xs" c="dimmed">
                          é¸æŠã•ã‚ŒãŸã‚¿ã‚°: {createForm.symptomTags.map(id => {
                            const tag = medicalTags.find(t => t.id === id);
                            return tag?.name || id;
                          }).join(', ')}
                        </Text>
                      )}
                    </>
                  ) : (
                    <Alert color="yellow" icon={<IconAlertCircle size={16} />}>
                      ã‚¿ã‚°ç®¡ç†ãƒšãƒ¼ã‚¸ã§ã€Œå¥åº·ã€ã‚«ãƒ†ã‚´ãƒªã®ã‚¿ã‚°ã‚’ä½œæˆã—ã¦ãã ã•ã„
                    </Alert>
                  )}
                </Box>

                <Textarea
                  label="è¨ºæ–­çµæœ"
                  placeholder="è¨ºæ–­çµæœ"
                  value={createForm.diagnosis}
                  onChange={(event) => setCreateForm((prev) => ({ ...prev, diagnosis: event.target.value }))}
                  minRows={2}
                  autosize
                />
              </>
            ),
          },
          {
            label: 'æ²»ç™‚è¨ˆç”»',
            content: (
              <>
                <Textarea
                  label="æ²»ç™‚è¨ˆç”»"
                  placeholder="æ²»ç™‚å†…å®¹ã‚„è¨ˆç”»"
                  value={createForm.treatmentPlan}
                  onChange={(event) => setCreateForm((prev) => ({ ...prev, treatmentPlan: event.target.value }))}
                  minRows={2}
                  autosize
                />

                <Box>
                  <Text size="sm" fw={500} mb="xs">
                    æ²»ç™‚ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
                  </Text>
                  <SegmentedControl
                    value={createForm.status}
                    onChange={(value) => setCreateForm((prev) => ({ ...prev, status: value }))}
                    data={[
                      { label: 'æ²»ç™‚ä¸­', value: 'TREATING' },
                      { label: 'å®Œäº†', value: 'COMPLETED' },
                    ]}
                    fullWidth
                  />
                </Box>

                <DatePickerInput
                  label="æ¬¡å›äºˆå®šæ—¥"
                  placeholder="æ¬¡å›ã®å—è¨ºäºˆå®šæ—¥"
                  value={createForm.followUpDate}
                  onChange={(value) =>
                    setCreateForm((prev) => ({
                      ...prev,
                      followUpDate: value ? new Date(value) : null,
                    }))
                  }
                />

                <Textarea
                  label="å‚™è€ƒ"
                  placeholder="ãã®ä»–ã®ãƒ¡ãƒ¢"
                  value={createForm.notes}
                  onChange={(event) => setCreateForm((prev) => ({ ...prev, notes: event.target.value }))}
                  minRows={3}
                  autosize
                />

                {createError && (
                  <Alert color="red" icon={<IconAlertCircle size={16} />}>
                    {createError}
                  </Alert>
                )}
              </>
            ),
          },
          {
            content: (
              <Group justify="flex-end">
                <ActionButton action="cancel" onClick={() => {
                  closeCreateModal();
                  resetCreateForm();
                }}>
                  ã‚­ãƒ£ãƒ³ã‚»ãƒ«
                </ActionButton>
                <ActionButton action="save" onClick={handleCreateSubmit} loading={createMedicalRecordMutation.isPending}>
                  ç™»éŒ²ã™ã‚‹
                </ActionButton>
              </Group>
            ),
          },
        ]}
      />
    </Container>
  );
}
````

## File: frontend/src/app/tags/components/AutomationRuleModal.tsx
````typescript
'use client';

import {
  Alert,
  Box,
  Button,
  Card,
  Divider,
  Group,
  MultiSelect,
  NumberInput,
  Radio,
  Select,
  Stack,
  Switch,
  Text,
  TextInput,
} from '@mantine/core';
import { IconInfoCircle } from '@tabler/icons-react';
import type { UseFormReturnType } from '@mantine/form';
import { UnifiedModal, type ModalSection } from '@/components/common';

import type { AutomationRuleFormValues, RuleType, ActionType } from '../types';
import {
  RULE_TYPE_OPTIONS,
  ACTION_TYPE_OPTIONS,
  AGE_TYPE_OPTIONS,
  PAGE_OPTIONS,
} from '../constants';

export type AutomationRuleModalProps = {
  opened: boolean;
  onClose: () => void;
  form: UseFormReturnType<AutomationRuleFormValues>;
  onSubmit: (e: React.FormEvent<HTMLFormElement>) => void;
  isEditing: boolean;
  isSubmitting: boolean;
  automationTagOptions: { value: string; label: string }[];
  pageActionOptions: { value: string; label: string }[];
};

/**
 * è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ç·¨é›†/ä½œæˆãƒ¢ãƒ¼ãƒ€ãƒ«ï¼ˆã‚·ãƒ³ãƒ—ãƒ«åŒ–ç‰ˆï¼‰
 */
export function AutomationRuleModal({
  opened,
  onClose,
  form,
  onSubmit,
  isEditing,
  isSubmitting,
  automationTagOptions,
  pageActionOptions,
}: AutomationRuleModalProps) {
  const ruleType = form.values.ruleType;
  const actionType = form.values.actionType;

  // TAG_ASSIGNEDã¯å‰Šé™¤å°‚ç”¨
  const isTagAssignedRule = ruleType === 'TAG_ASSIGNED';
  
  // TAG_ASSIGNEDé¸æŠæ™‚ã¯è‡ªå‹•çš„ã«å‰Šé™¤ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã«è¨­å®š
  const handleRuleTypeChange = (value: RuleType) => {
    form.setFieldValue('ruleType', value);
    if (value === 'TAG_ASSIGNED') {
      form.setFieldValue('actionType', 'REMOVE');
    }
  };

  const sections: ModalSection[] = [
    {
      content: (
        <Box component="form" onSubmit={onSubmit}>
          <Stack gap="md" p="md">
            {/* ãƒ«ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ—é¸æŠ */}
            <Radio.Group
            label="ã„ã¤å®Ÿè¡Œã™ã‚‹ã‹"
            value={ruleType}
            onChange={(value) => handleRuleTypeChange(value as RuleType)}
          >
            <Stack gap="xs" mt="xs">
              {RULE_TYPE_OPTIONS.map((option) => (
                <Radio key={option.value} value={option.value} label={option.label} />
              ))}
            </Stack>
          </Radio.Group>

          <Divider />

          {/* æ¡ä»¶è¨­å®šã‚¨ãƒªã‚¢ */}
          <Card withBorder padding="md" bg="gray.0">
            <Stack gap="md">
              {/* ã‚¤ãƒ™ãƒ³ãƒˆç™ºç”Ÿæ™‚ */}
              {ruleType === 'PAGE_ACTION' && (
                <>
                  <Select
                    label="ã©ã“ã§"
                    placeholder="ãƒšãƒ¼ã‚¸ã‚’é¸æŠ"
                    data={PAGE_OPTIONS.map(p => ({ value: p.value, label: p.label }))}
                    value={form.values.pageAction.page}
                    onChange={(value) => {
                      form.setFieldValue('pageAction.page', value || '');
                      form.setFieldValue('pageAction.action', '');
                    }}
                    required
                  />
                  {form.values.pageAction.page && (
                    <Select
                      label="ä½•ãŒç™ºç”Ÿã—ãŸã‚‰"
                      placeholder="ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’é¸æŠ"
                      data={pageActionOptions}
                      value={form.values.pageAction.action}
                      onChange={(value) => form.setFieldValue('pageAction.action', value || '')}
                      required
                    />
                  )}
                </>
              )}

              {/* å¹´é½¢æ¡ä»¶ */}
              {ruleType === 'AGE_THRESHOLD' && (
                <>
                  <Radio.Group
                    label="å¯¾è±¡"
                    value={form.values.ageThreshold.ageType}
                    onChange={(value) => form.setFieldValue('ageThreshold.ageType', value as 'days' | 'months')}
                  >
                    <Group mt="xs">
                      {AGE_TYPE_OPTIONS.map((option) => (
                        <Radio key={option.value} value={option.value} label={option.label} />
                      ))}
                    </Group>
                  </Radio.Group>
                  <NumberInput
                    label={`ç”Ÿå¾Œ${form.values.ageThreshold.ageType === 'days' ? 'æ—¥æ•°' : 'æœˆæ•°'}`}
                    description={`ã“ã®${form.values.ageThreshold.ageType === 'days' ? 'æ—¥æ•°' : 'æœˆæ•°'}ã«é”ã—ãŸã‚‰å®Ÿè¡Œ`}
                    placeholder="ä¾‹: 60"
                    min={1}
                    value={form.values.ageThreshold.threshold}
                    onChange={(value) => form.setFieldValue('ageThreshold.threshold', typeof value === 'number' ? value : 0)}
                    required
                  />
                </>
              )}

              {/* ã‚¿ã‚°ä»˜ä¸æ™‚ï¼ˆå‰Šé™¤å°‚ç”¨ï¼‰ */}
              {ruleType === 'TAG_ASSIGNED' && (
                <>
                  <Select
                    label="ã“ã®ã‚¿ã‚°ãŒä»˜ä¸ã•ã‚ŒãŸã‚‰"
                    placeholder="ãƒˆãƒªã‚¬ãƒ¼ã¨ãªã‚‹ã‚¿ã‚°ã‚’é¸æŠ"
                    data={automationTagOptions}
                    value={form.values.triggerTagId}
                    onChange={(value) => form.setFieldValue('triggerTagId', value || '')}
                    searchable
                    required
                  />
                  <Alert icon={<IconInfoCircle size={18} />} variant="light" color="blue">
                    é¸æŠã—ãŸã‚¿ã‚°ãŒä»˜ä¸ã•ã‚Œã‚‹ã¨ã€ä¸‹ã§æŒ‡å®šã—ãŸã‚¿ã‚°ãŒè‡ªå‹•çš„ã«å‰Šé™¤ã•ã‚Œã¾ã™ã€‚
                  </Alert>
                </>
              )}
            </Stack>
          </Card>

          <Divider />

          {/* ã‚¢ã‚¯ã‚·ãƒ§ãƒ³é¸æŠ */}
          <Radio.Group
            label="ä½•ã‚’ã™ã‚‹ã‹"
            value={actionType}
            onChange={(value) => form.setFieldValue('actionType', value as ActionType)}
          >
            <Group mt="xs">
              {ACTION_TYPE_OPTIONS.map((option) => (
                <Radio 
                  key={option.value} 
                  value={option.value} 
                  label={option.label}
                  disabled={isTagAssignedRule && option.value === 'ASSIGN'}
                />
              ))}
            </Group>
          </Radio.Group>

          {/* å¯¾è±¡ã‚¿ã‚° */}
          <MultiSelect
            label={actionType === 'ASSIGN' ? 'ä»˜ä¸ã™ã‚‹ã‚¿ã‚°' : 'å‰Šé™¤ã™ã‚‹ã‚¿ã‚°'}
            placeholder="ã‚¿ã‚°ã‚’é¸æŠ"
            description="è‡ªå‹•åŒ–ãŒè¨±å¯ã•ã‚Œã¦ã„ã‚‹ã‚¿ã‚°ã®ã¿é¸æŠã§ãã¾ã™"
            data={automationTagOptions}
            value={form.values.tagIds}
            onChange={(value) => form.setFieldValue('tagIds', value)}
            searchable
            required
            maxDropdownHeight={300}
            error={form.errors.tagIds}
          />

          <Divider label="ã‚ªãƒ—ã‚·ãƒ§ãƒ³" labelPosition="center" />

          {/* ãƒ«ãƒ¼ãƒ«åï¼ˆä»»æ„ï¼‰ */}
          <TextInput
            label="ãƒ«ãƒ¼ãƒ«åï¼ˆä»»æ„ï¼‰"
            placeholder="ä¾‹: æ–°è¦çŒ«ç™»éŒ²æ™‚ã®ã‚¿ã‚°ä»˜ä¸"
            description="ç©ºæ¬„ã®å ´åˆã¯è‡ªå‹•ç”Ÿæˆã•ã‚Œã¾ã™"
            value={form.values.name}
            onChange={(e) => form.setFieldValue('name', e.currentTarget.value)}
          />

          {/* ãƒ¡ãƒ¢ */}
          <TextInput
            label="ãƒ¡ãƒ¢ï¼ˆä»»æ„ï¼‰"
            placeholder="ã“ã®ãƒ«ãƒ¼ãƒ«ã®èª¬æ˜"
            value={form.values.description}
            onChange={(e) => form.setFieldValue('description', e.currentTarget.value)}
          />

          {/* ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¹ã‚¤ãƒƒãƒ */}
          <Switch
            label="ã“ã®ãƒ«ãƒ¼ãƒ«ã‚’æœ‰åŠ¹ã«ã™ã‚‹"
            checked={form.values.isActive}
            onChange={(e) => form.setFieldValue('isActive', e.currentTarget.checked)}
          />

          {/* è¨­å®šã‚µãƒãƒªãƒ¼ */}
          <Card withBorder padding="sm" bg="blue.0">
            <Stack gap={4}>
              <Text size="sm" fw={500}>è¨­å®šå†…å®¹</Text>
              <Text size="xs" c="dimmed">
                {ruleType === 'PAGE_ACTION' && form.values.pageAction.page && form.values.pageAction.action && (
                  <>
                    ğŸ“ {PAGE_OPTIONS.find(p => p.value === form.values.pageAction.page)?.label}ã§
                    ã€Œ{pageActionOptions.find(a => a.value === form.values.pageAction.action)?.label}ã€ãŒç™ºç”Ÿã—ãŸã‚‰
                  </>
                )}
                {ruleType === 'AGE_THRESHOLD' && form.values.ageThreshold.threshold > 0 && (
                  <>
                    ğŸ“… ç”Ÿå¾Œ{form.values.ageThreshold.threshold}{form.values.ageThreshold.ageType === 'days' ? 'æ—¥' : 'ãƒ¶æœˆ'}ã«é”ã—ãŸã‚‰
                  </>
                )}
                {ruleType === 'TAG_ASSIGNED' && form.values.triggerTagId && (
                  <>
                    ğŸ·ï¸ ã€Œ{automationTagOptions.find(t => t.value === form.values.triggerTagId)?.label}ã€ãŒä»˜ä¸ã•ã‚ŒãŸã‚‰
                  </>
                )}
              </Text>
              <Text size="xs">
                {actionType === 'ASSIGN' ? 'â†’ ã‚¿ã‚°ã‚’ä»˜ä¸' : 'â†’ ã‚¿ã‚°ã‚’å‰Šé™¤'}
                {form.values.tagIds.length > 0 && ` (${form.values.tagIds.length}ä»¶)`}
              </Text>
            </Stack>
            </Card>

            <Group justify="flex-end" mt="md">
              <Button variant="subtle" onClick={onClose}>
                ã‚­ãƒ£ãƒ³ã‚»ãƒ«
              </Button>
              <Button type="submit" loading={isSubmitting}>
                {isEditing ? 'æ›´æ–°' : 'ä½œæˆ'}
              </Button>
            </Group>
          </Stack>
        </Box>
      ),
    },
  ];

  return (
    <UnifiedModal
      opened={opened}
      onClose={onClose}
      title={isEditing ? 'è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ã®ç·¨é›†' : 'è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ã®ä½œæˆ'}
      size="lg"
      addContentPadding={false}
      sections={sections}
    />
  );
}
````

## File: frontend/src/app/tags/page.tsx
````typescript
'use client';

import { useEffect, useMemo, useState } from 'react';
import { usePathname, useRouter, useSearchParams } from 'next/navigation';
import { arrayMove } from '@dnd-kit/sortable';
import type { DragEndEvent } from '@dnd-kit/core';
import {
  Container,
  Group,
  Loader,
  Stack,
  Switch,
  Tabs,
} from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { useForm } from '@mantine/form';
import {
  IconFolderPlus,
  IconPlus,
  IconRobot,
  IconTag,
  IconTags,
} from '@tabler/icons-react';

import { useContextMenu } from '@/components/context-menu/use-context-menu';
import { OperationModalManager } from '@/components/context-menu/operation-modal-manager';
import { usePageHeader } from '@/lib/contexts/page-header-context';
import type {
  TagCategoryView,
  TagGroupView,
  TagView,
  CreateTagGroupRequest,
  UpdateTagCategoryRequest,
  UpdateTagGroupRequest,
  UpdateTagRequest,
} from '@/lib/api/hooks/use-tags';
import type {
  TagAutomationRule,
  CreateTagAutomationRuleRequest,
  UpdateTagAutomationRuleRequest,
} from '@/lib/api/hooks/use-tag-automation';

import type {
  CategoryFormValues,
  TagFormValues,
  GroupFormValues,
  AutomationRuleFormValues,
} from './types';
import {
  DEFAULT_CATEGORY_COLOR,
  DEFAULT_CATEGORY_TEXT_COLOR,
  DEFAULT_GROUP_COLOR,
  DEFAULT_GROUP_TEXT_COLOR,
  DEFAULT_TAG_COLOR,
  DEFAULT_TAG_TEXT_COLOR,
  CATEGORY_SCOPE_OPTIONS,
  PAGE_ACTIONS_MAP,
} from './constants';
import { buildCategoryPayload, buildTagPayload, sortGroups } from './utils';
import { useTagPageData } from './hooks/useTagPageData';
import { useAutomationRulesData } from './hooks/useAutomationRulesData';
import {
  CategoriesTab,
  TagsListTab,
  AutomationTab,
  CategoryModal,
  GroupModal,
  TagModal,
  AutomationRuleModal,
  ExecuteRuleModal,
} from './components';

import { ActionMenu } from '@/app/tenants/_components/ActionMenu';

// æœ‰åŠ¹ãªã‚¿ãƒ–å€¤ã®å‹å®šç¾©
type TabValue = 'categories' | 'tags' | 'automation';
const VALID_TABS: TabValue[] = ['categories', 'tags', 'automation'];

export default function TagsPage() {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();
  
  // URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰ã‚¿ãƒ–çŠ¶æ…‹ã‚’å–å¾—ï¼ˆç„¡åŠ¹ãªå€¤ã®å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® 'categories' ã‚’ä½¿ç”¨ï¼‰
  const tabParam = searchParams.get('tab');
  const activeTab: TabValue = VALID_TABS.includes(tabParam as TabValue) 
    ? (tabParam as TabValue) 
    : 'categories';

  const { setPageHeader } = usePageHeader();

  // ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆæ™‚ã«URLã‚’æ›´æ–°
  const handleTabChange = (nextTab: string | null) => {
    if (!nextTab) return;
    const nextParams = new URLSearchParams(searchParams);
    nextParams.set('tab', nextTab);
    router.push(`${pathname}?${nextParams.toString()}`);
  };

  // ãƒ‡ãƒ¼ã‚¿å–å¾—
  const {
    filters,
    setFilters,
    isLoading,
    isFetching,
    sortedCategories,
    flatTags,
    createCategory,
    updateCategory,
    deleteCategory,
    reorderCategoriesMutation,
    createGroup,
    updateGroup,
    deleteGroup,
    reorderGroupsMutation,
    createTag,
    updateTag,
    deleteTag,
    reorderTagsMutation,
    colorDefaults,
    updateTagColorDefaults,
    isCategorySubmitting,
    isGroupSubmitting,
    isTagSubmitting,
    isAnyMutationPending,
  } = useTagPageData();

  const {
    isLoadingAutomationRules,
    automationRules,
    createAutomationRule,
    updateAutomationRule,
    deleteAutomationRule,
    executeAutomationRule,
  } = useAutomationRulesData();

  // ç·¨é›†çŠ¶æ…‹
  const [editingCategory, setEditingCategory] = useState<TagCategoryView | null>(null);
  const [editingGroup, setEditingGroup] = useState<{ category: TagCategoryView; group: TagGroupView } | null>(null);
  const [editingTag, setEditingTag] = useState<{ category: TagCategoryView; group: TagGroupView; tag: TagView } | null>(null);
  const [editingAutomationRule, setEditingAutomationRule] = useState<TagAutomationRule | null>(null);
  const [executingRule, setExecutingRule] = useState<TagAutomationRule | null>(null);

  // ãƒ¢ãƒ¼ãƒ€ãƒ«çŠ¶æ…‹
  const [categoryModalOpened, { open: openCategoryModal, close: closeCategoryModal }] = useDisclosure(false);
  const [groupModalOpened, { open: openGroupModal, close: closeGroupModal }] = useDisclosure(false);
  const [tagModalOpened, { open: openTagModal, close: closeTagModal }] = useDisclosure(false);
  const [automationRuleModalOpened, { open: openAutomationRuleModal, close: closeAutomationRuleModal }] = useDisclosure(false);
  const [executeRuleModalOpened, { open: openExecuteRuleModal, close: closeExecuteRuleModal }] = useDisclosure(false);

  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šç”¨ã®ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹çŠ¶æ…‹
  const [setAsCategoryDefaultBgColor, setSetAsCategoryDefaultBgColor] = useState(false);
  const [setAsCategoryDefaultTextColor, setSetAsCategoryDefaultTextColor] = useState(false);
  const [setAsGroupDefaultBgColor, setSetAsGroupDefaultBgColor] = useState(false);
  const [setAsGroupDefaultTextColor, setSetAsGroupDefaultTextColor] = useState(false);
  const [setAsTagDefaultBgColor, setSetAsTagDefaultBgColor] = useState(false);
  const [setAsTagDefaultTextColor, setSetAsTagDefaultTextColor] = useState(false);

  // è¦ªéšå±¤ã‹ã‚‰ã®ç¶™æ‰¿ç”¨ã®ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹çŠ¶æ…‹
  const [inheritGroupColorFromCategory, setInheritGroupColorFromCategory] = useState(false);
  const [inheritTagColorFromGroup, setInheritTagColorFromGroup] = useState(false);

  // ãƒ•ã‚©ãƒ¼ãƒ 
  const categoryForm = useForm<CategoryFormValues>({
    initialValues: {
      key: '',
      name: '',
      description: '',
      color: DEFAULT_CATEGORY_COLOR,
      textColor: DEFAULT_CATEGORY_TEXT_COLOR,
      scopes: [],
      isActive: true,
    },
    validate: {
      name: (value) => (value.trim().length ? null : 'ã‚«ãƒ†ã‚´ãƒªåã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'),
    },
  });

  const groupForm = useForm<GroupFormValues>({
    initialValues: {
      categoryId: '',
      name: '',
      description: '',
      color: DEFAULT_GROUP_COLOR,
      textColor: DEFAULT_GROUP_TEXT_COLOR,
      isActive: true,
    },
    validate: {
      categoryId: (value) => (value ? null : 'ã‚«ãƒ†ã‚´ãƒªã‚’é¸æŠã—ã¦ãã ã•ã„'),
      name: (value) => (value.trim().length ? null : 'ã‚°ãƒ«ãƒ¼ãƒ—åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'),
    },
  });

  const tagForm = useForm<TagFormValues>({
    initialValues: {
      name: '',
      categoryId: '',
      groupId: '',
      description: '',
      color: DEFAULT_TAG_COLOR,
      textColor: DEFAULT_TAG_TEXT_COLOR,
      allowsManual: true,
      allowsAutomation: true,
      isActive: true,
    },
    validate: {
      name: (value) => (value.trim().length ? null : 'ã‚¿ã‚°åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'),
      categoryId: (value) => (value ? null : 'ã‚«ãƒ†ã‚´ãƒªã‚’é¸æŠã—ã¦ãã ã•ã„'),
      groupId: (value) => (value ? null : 'ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ã‚’é¸æŠã—ã¦ãã ã•ã„'),
    },
  });

  const automationRuleForm = useForm<AutomationRuleFormValues>({
    initialValues: {
      ruleType: 'PAGE_ACTION',
      actionType: 'ASSIGN',
      tagIds: [],
      name: '',
      description: '',
      isActive: true,
      pageAction: {
        page: 'cats',
        action: '',
      },
      ageThreshold: {
        ageType: 'days',
        threshold: 60,
      },
      triggerTagId: '',
    },
    validate: {
      tagIds: (value) => {
        if (!value || value.length === 0) {
          return 'å°‘ãªãã¨ã‚‚1ã¤ã®ã‚¿ã‚°ã‚’é¸æŠã—ã¦ãã ã•ã„';
        }
        return null;
      },
      triggerTagId: (value, values) => {
        if (values.ruleType === 'TAG_ASSIGNED' && !value) {
          return 'ãƒˆãƒªã‚¬ãƒ¼ã‚¿ã‚°ã‚’é¸æŠã—ã¦ãã ã•ã„';
        }
        return null;
      },
    },
  });

  // ã‚ªãƒ—ã‚·ãƒ§ãƒ³ç”Ÿæˆ

  const automationTagOptions = useMemo(() => {
    if (!sortedCategories || sortedCategories.length === 0) {
      return [];
    }
    const options: { value: string; label: string }[] = [];
    sortedCategories.forEach((category) => {
      if (!category || !category.groups) return;
      const groups = Array.isArray(category.groups) ? category.groups : [];
      groups.forEach((group) => {
        if (!group) return;
        const tags = Array.isArray(group.tags) ? group.tags : [];
        tags.forEach((tag) => {
          if (tag && tag.allowsAutomation && tag.isActive) {
            options.push({
              value: tag.id,
              label: `${category.name} > ${group.name} > ${tag.name}`,
            });
          }
        });
      });
    });
    return options;
  }, [sortedCategories]);

  const pageActionOptions = useMemo(() => {
    const selectedPage = automationRuleForm.values.pageAction?.page;
    if (!selectedPage) {
      return [];
    }
    const actions = PAGE_ACTIONS_MAP[selectedPage] || [];
    return actions.map(action => ({
      value: action.value,
      label: action.description
        ? `${action.label} - ${action.description}`
        : action.label
    }));
  }, [automationRuleForm.values.pageAction?.page]);

  const categoryOptions = useMemo(
    () => sortedCategories.map((category) => ({ value: category.id, label: category.name })),
    [sortedCategories],
  );

  const groupOptionsByCategory = useMemo(() => {
    const map = new Map<string, { value: string; label: string }[]>();
    sortedCategories.forEach((category) => {
      map.set(
        category.id,
        sortGroups(category.groups).map((group) => ({ value: group.id, label: group.name })),
      );
    });
    return map;
  }, [sortedCategories]);

  const tagGroupOptions = useMemo(() => {
    if (!tagForm.values.categoryId) {
      return [];
    }
    return groupOptionsByCategory.get(tagForm.values.categoryId) ?? [];
  }, [groupOptionsByCategory, tagForm.values.categoryId]);

  // ã‚¿ã‚°ãƒ¢ãƒ¼ãƒ€ãƒ«ã§ã‚°ãƒ«ãƒ¼ãƒ—ã®è‡ªå‹•é¸æŠ
  useEffect(() => {
    if (!tagModalOpened) {
      return;
    }
    if (!tagForm.values.categoryId) {
      if (tagForm.values.groupId !== '') {
        tagForm.setFieldValue('groupId', '');
      }
      return;
    }
    if (tagForm.values.groupId && !tagGroupOptions.some((option) => option.value === tagForm.values.groupId)) {
      tagForm.setFieldValue('groupId', '');
      return;
    }
    if (!tagForm.values.groupId && tagGroupOptions.length > 0) {
      tagForm.setFieldValue('groupId', tagGroupOptions[0].value);
    }
  }, [tagModalOpened, tagForm, tagGroupOptions]);

  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šæ›´æ–°ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
  const updateColorDefaultsIfNeeded = async (
    type: 'category' | 'group' | 'tag',
    setBg: boolean,
    setText: boolean,
    values: { color: string; textColor: string }
  ) => {
    if (!setBg && !setText) return;
    const updates: { color?: string; textColor?: string } = {};
    if (setBg) {
      updates.color = values.color;
    }
    if (setText) {
      updates.textColor = values.textColor;
    }
    await updateTagColorDefaults.mutateAsync({ [type]: updates });
  };

  // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼
  const {
    currentOperation,
    currentEntity,
    handleAction: handleTagContextAction,
    openOperation,
    closeOperation,
  } = useContextMenu<TagView>({
    edit: (tag) => {
      const tagInfo = flatTags.find(t => t.tag.id === tag?.id);
      if (tagInfo) {
        handleEditTag(tagInfo.category, tagInfo.group, tagInfo.tag);
      }
    },
    delete: () => {
      openOperation('delete');
    },
  });

  const handleOperationConfirm = async () => {
    if (!currentEntity) return;
    if (currentOperation === 'delete') {
      await deleteTag.mutateAsync(currentEntity.id);
      closeOperation();
    }
  };

  // ã‚«ãƒ†ã‚´ãƒªæ“ä½œ
  const handleOpenCreateCategory = () => {
    setEditingCategory(null);
    categoryForm.setValues({
      key: '',
      name: '',
      description: '',
      color: colorDefaults?.category?.color || DEFAULT_CATEGORY_COLOR,
      textColor: colorDefaults?.category?.textColor || DEFAULT_CATEGORY_TEXT_COLOR,
      scopes: [],
      isActive: true,
    });
    setSetAsCategoryDefaultBgColor(false);
    setSetAsCategoryDefaultTextColor(false);
    openCategoryModal();
  };

  const handleEditCategory = (category: TagCategoryView) => {
    setEditingCategory(category);
    categoryForm.setValues({
      key: category.key ?? '',
      name: category.name,
      description: category.description ?? '',
      color: category.color ?? DEFAULT_CATEGORY_COLOR,
      textColor: category.textColor ?? DEFAULT_CATEGORY_TEXT_COLOR,
      scopes: category.scopes ?? [],
      isActive: category.isActive,
    });
    openCategoryModal();
  };

  const handleSubmitCategory = categoryForm.onSubmit(async (values) => {
    const payload = buildCategoryPayload(values);
    try {
      if (editingCategory) {
        await updateCategory.mutateAsync({ id: editingCategory.id, payload: payload as UpdateTagCategoryRequest });
      } else {
        await createCategory.mutateAsync(payload);
      }
      await updateColorDefaultsIfNeeded('category', setAsCategoryDefaultBgColor, setAsCategoryDefaultTextColor, values);
      closeCategoryModal();
    } catch {
      // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¯ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³å´ã®é€šçŸ¥ã«å§”è­²
    }
  });

  const handleDeleteCategory = async (id: string) => {
    if (!window.confirm('ã“ã®ã‚«ãƒ†ã‚´ãƒªã¨é–¢é€£ã‚¿ã‚°ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
      return;
    }
    try {
      await deleteCategory.mutateAsync(id);
    } catch {
      // noop
    }
  };

  const handleCategoryDragEnd = ({ active, over }: DragEndEvent) => {
    if (!over || active.id === over.id || reorderCategoriesMutation.isPending) {
      return;
    }
    const oldIndex = sortedCategories.findIndex((item) => item.id === active.id);
    const newIndex = sortedCategories.findIndex((item) => item.id === over.id);
    if (oldIndex === -1 || newIndex === -1) {
      return;
    }
    const reordered = arrayMove(sortedCategories, oldIndex, newIndex);
    void reorderCategoriesMutation.mutateAsync({
      items: reordered.map((category, orderIndex) => ({
        id: category.id,
        displayOrder: orderIndex,
      })),
    });
  };

  // ã‚°ãƒ«ãƒ¼ãƒ—æ“ä½œ
  const handleOpenCreateGroup = (categoryId?: string) => {
    setEditingGroup(null);
    const selectedCategoryId = categoryId ?? (sortedCategories.length > 0 ? sortedCategories[0].id : '');
    groupForm.setValues({
      categoryId: selectedCategoryId,
      name: '',
      description: '',
      color: colorDefaults?.group?.color || DEFAULT_GROUP_COLOR,
      textColor: colorDefaults?.group?.textColor || DEFAULT_GROUP_TEXT_COLOR,
      isActive: true,
    });
    setSetAsGroupDefaultBgColor(false);
    setSetAsGroupDefaultTextColor(false);
    setInheritGroupColorFromCategory(false);
    openGroupModal();
  };

  const handleEditGroup = (category: TagCategoryView, group: TagGroupView) => {
    setEditingGroup({ category, group });
    groupForm.setValues({
      categoryId: category.id,
      name: group.name,
      description: group.description ?? '',
      color: group.color ?? DEFAULT_GROUP_COLOR,
      textColor: group.textColor ?? DEFAULT_GROUP_TEXT_COLOR,
      isActive: group.isActive,
    });
    openGroupModal();
  };

  const handleSubmitGroup = groupForm.onSubmit(async (values) => {
    const payload: CreateTagGroupRequest & { color?: string; textColor?: string } = {
      categoryId: values.categoryId,
      name: values.name,
      ...(values.description ? { description: values.description } : {}),
      color: values.color || DEFAULT_GROUP_COLOR,
      textColor: values.textColor || DEFAULT_GROUP_TEXT_COLOR,
      isActive: values.isActive,
    };
    try {
      if (editingGroup) {
        await updateGroup.mutateAsync({
          id: editingGroup.group.id,
          payload: payload as UpdateTagGroupRequest,
        });
      } else {
        await createGroup.mutateAsync(payload);
      }
      await updateColorDefaultsIfNeeded('group', setAsGroupDefaultBgColor, setAsGroupDefaultTextColor, values);
      closeGroupModal();
    } catch {
      // noop
    }
  });

  const handleDeleteGroupAction = async (id: string) => {
    if (!window.confirm('ã“ã®ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ã¨é–¢é€£ã‚¿ã‚°ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
      return;
    }
    try {
      await deleteGroup.mutateAsync(id);
    } catch {
      // noop
    }
  };

  const handleReorderGroups = async (categoryId: string, groups: TagGroupView[]) => {
    if (reorderGroupsMutation.isPending) {
      return;
    }
    try {
      await reorderGroupsMutation.mutateAsync({
        items: groups.map((group, orderIndex) => ({
          id: group.id,
          displayOrder: orderIndex,
          categoryId,
        })),
      });
    } catch {
      // noop
    }
  };

  const handleInheritGroupColorFromCategoryChange = (checked: boolean) => {
    setInheritGroupColorFromCategory(checked);
    if (checked) {
      const selectedCategory = sortedCategories.find(c => c.id === groupForm.values.categoryId);
      if (selectedCategory) {
        groupForm.setFieldValue('color', selectedCategory.color || DEFAULT_CATEGORY_COLOR);
        groupForm.setFieldValue('textColor', selectedCategory.textColor || DEFAULT_CATEGORY_TEXT_COLOR);
      }
    }
  };

  // ã‚¿ã‚°æ“ä½œ
  const handleOpenCreateTag = (categoryId?: string, groupId?: string) => {
    setEditingTag(null);
    let selectedCategoryId = categoryId;
    let selectedGroupId = groupId;
    if (!selectedCategoryId && sortedCategories.length > 0) {
      selectedCategoryId = sortedCategories[0].id;
      if (!selectedGroupId && sortedCategories[0].groups.length > 0) {
        selectedGroupId = sortedCategories[0].groups[0].id;
      }
    }
    tagForm.setValues({
      name: '',
      categoryId: selectedCategoryId ?? '',
      groupId: selectedGroupId ?? '',
      description: '',
      color: colorDefaults?.tag?.color || DEFAULT_TAG_COLOR,
      textColor: colorDefaults?.tag?.textColor || DEFAULT_TAG_TEXT_COLOR,
      allowsManual: true,
      allowsAutomation: true,
      isActive: true,
    });
    setSetAsTagDefaultBgColor(false);
    setSetAsTagDefaultTextColor(false);
    setInheritTagColorFromGroup(false);
    openTagModal();
  };

  const handleEditTag = (category: TagCategoryView, group: TagGroupView, tag: TagView) => {
    setEditingTag({ category, group, tag });
    tagForm.setValues({
      name: tag.name,
      categoryId: category.id,
      groupId: group.id,
      description: tag.description ?? '',
      color: tag.color ?? DEFAULT_TAG_COLOR,
      textColor: tag.textColor ?? DEFAULT_TAG_TEXT_COLOR,
      allowsManual: tag.allowsManual,
      allowsAutomation: tag.allowsAutomation,
      isActive: tag.isActive,
    });
    openTagModal();
  };

  const handleSubmitTag = tagForm.onSubmit(async (values) => {
    const payload = buildTagPayload(values);
    try {
      if (editingTag) {
        await updateTag.mutateAsync({ id: editingTag.tag.id, payload: payload as UpdateTagRequest });
      } else {
        await createTag.mutateAsync(payload);
      }
      await updateColorDefaultsIfNeeded('tag', setAsTagDefaultBgColor, setAsTagDefaultTextColor, values);
      closeTagModal();
    } catch {
      // é€šçŸ¥ã¯ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³å´ã§å®Ÿæ–½
    }
  });

  const handleDeleteTag = async (id: string) => {
    if (!window.confirm('ã“ã®ã‚¿ã‚°ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
      return;
    }
    try {
      await deleteTag.mutateAsync(id);
    } catch {
      // noop
    }
  };

  const handleReorderTags = async (groupId: string, tags: TagView[]) => {
    if (reorderTagsMutation.isPending) {
      return;
    }
    try {
      await reorderTagsMutation.mutateAsync({
        items: tags.map((tag, orderIndex) => ({
          id: tag.id,
          displayOrder: orderIndex,
          groupId,
        })),
      });
    } catch {
      // noop
    }
  };

  const handleInheritTagColorFromGroupChange = (checked: boolean) => {
    setInheritTagColorFromGroup(checked);
    if (checked) {
      const selectedCategory = sortedCategories.find(c => c.id === tagForm.values.categoryId);
      const selectedGroup = selectedCategory?.groups.find(g => g.id === tagForm.values.groupId);
      if (selectedGroup) {
        tagForm.setFieldValue('color', selectedGroup.color || DEFAULT_GROUP_COLOR);
        tagForm.setFieldValue('textColor', selectedGroup.textColor || DEFAULT_GROUP_TEXT_COLOR);
      }
    }
  };

  // è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«æ“ä½œ
  const handleOpenCreateAutomationRule = () => {
    setEditingAutomationRule(null);
    automationRuleForm.reset();
    openAutomationRuleModal();
  };

  const handleEditAutomationRule = (rule: TagAutomationRule) => {
    setEditingAutomationRule(rule);
    
    // configã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡º
    const config = (rule.config && typeof rule.config === 'object') ? rule.config as Record<string, unknown> : {};
    const tagIds = (config.tagIds as string[]) || [];
    
    // ãƒ«ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ—ã®åˆ¤å®š
    let ruleType: AutomationRuleFormValues['ruleType'] = 'PAGE_ACTION';
    if (rule.eventType === 'AGE_THRESHOLD') {
      ruleType = 'AGE_THRESHOLD';
    } else if (rule.eventType === 'TAG_ASSIGNED') {
      ruleType = 'TAG_ASSIGNED';
    }
    
    // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—ã®åˆ¤å®š
    const actionType: AutomationRuleFormValues['actionType'] = 
      (config.actionType as string) === 'REMOVE' ? 'REMOVE' : 'ASSIGN';
    
    // ãƒšãƒ¼ã‚¸ã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¨­å®š
    const pageAction: AutomationRuleFormValues['pageAction'] = {
      page: (config.page as string) || 'cats',
      action: (config.action as string) || '',
    };
    
    // å¹´é½¢é–¾å€¤è¨­å®š
    const ageThreshold: AutomationRuleFormValues['ageThreshold'] = {
      ageType: (config.ageType as 'days' | 'months') || 'days',
      threshold: (config.threshold as number) || 60,
    };
    
    // ãƒˆãƒªã‚¬ãƒ¼ã‚¿ã‚°ID
    const triggerTagId = (config.triggerTagId as string) || '';

    automationRuleForm.setValues({
      ruleType,
      actionType,
      tagIds,
      name: rule.name,
      description: rule.description || '',
      isActive: rule.isActive,
      pageAction,
      ageThreshold,
      triggerTagId,
    });
    openAutomationRuleModal();
  };

  const handleOpenExecuteRule = (rule: TagAutomationRule) => {
    setExecutingRule(rule);
    openExecuteRuleModal();
  };

  const handleExecuteRule = async () => {
    if (!executingRule) return;
    try {
      await executeAutomationRule.mutateAsync({ id: executingRule.id });
      closeExecuteRuleModal();
      setExecutingRule(null);
    } catch {
      // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¯ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³å´ã§å®Ÿæ–½
    }
  };

  const handleSubmitAutomationRule = automationRuleForm.onSubmit(async (values) => {
    // configã‚’æ§‹ç¯‰
    const config: Record<string, unknown> = {
      tagIds: values.tagIds,
      actionType: values.actionType,
    };

    // ãƒ«ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸè¨­å®šã‚’è¿½åŠ 
    if (values.ruleType === 'PAGE_ACTION') {
      config.page = values.pageAction.page;
      config.action = values.pageAction.action;
    } else if (values.ruleType === 'AGE_THRESHOLD') {
      config.ageType = values.ageThreshold.ageType;
      config.threshold = values.ageThreshold.threshold;
    } else if (values.ruleType === 'TAG_ASSIGNED') {
      config.triggerTagId = values.triggerTagId;
    }

    // ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ã‚’æ§‹ç¯‰ï¼ˆkeyã¯çœç•¥ã—ã¦ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã§è‡ªå‹•ç”Ÿæˆï¼‰
    const payload: CreateTagAutomationRuleRequest | UpdateTagAutomationRuleRequest = {
      name: values.name || undefined, // ç©ºã®å ´åˆã¯ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã§è‡ªå‹•ç”Ÿæˆ
      description: values.description || undefined,
      triggerType: 'EVENT', // å…¨ã¦ EVENT ãƒˆãƒªã‚¬ãƒ¼
      eventType: values.ruleType, // ruleTypeã‚’eventTypeã¨ã—ã¦ä½¿ç”¨
      isActive: values.isActive,
      config,
    };

    try {
      if (editingAutomationRule) {
        await updateAutomationRule.mutateAsync({
          id: editingAutomationRule.id,
          payload: payload as UpdateTagAutomationRuleRequest
        });
      } else {
        await createAutomationRule.mutateAsync(payload as CreateTagAutomationRuleRequest);
      }
      closeAutomationRuleModal();
    } catch {
      // é€šçŸ¥ã¯ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³å´ã§å®Ÿæ–½
    }
  });

  const handleDeleteAutomationRule = (id: string) => {
    deleteAutomationRule.mutate(id);
  };

  // ãƒšãƒ¼ã‚¸ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’è¨­å®š
  useEffect(() => {
    setPageHeader(
      'ã‚¿ã‚°ç®¡ç†',
      <ActionMenu
        buttonLabel="æ–°è¦ä½œæˆ"
        buttonIcon={IconPlus}
        action="create"
        items={[
          {
            id: 'category',
            label: 'ã‚«ãƒ†ã‚´ãƒªä½œæˆ',
            icon: <IconFolderPlus size={16} />,
            onClick: handleOpenCreateCategory,
          },
          {
            id: 'group',
            label: 'ã‚°ãƒ«ãƒ¼ãƒ—ä½œæˆ',
            icon: <IconTags size={16} />,
            onClick: () => handleOpenCreateGroup(),
          },
          {
            id: 'tag',
            label: 'ã‚¿ã‚°ä½œæˆ',
            icon: <IconTag size={16} />,
            onClick: () => handleOpenCreateTag(),
          }
        ]}
      />
    );

    return () => setPageHeader(null);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isAnyMutationPending, sortedCategories.length]);

  return (
    <Container size="lg">
      <Stack gap="xl">
        <Group justify="space-between" align="center" wrap="wrap">
          <Switch
            label="éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚’å«ã‚ã‚‹"
            checked={filters.includeInactive}
            onChange={(event) => {
              const checked = event.currentTarget?.checked ?? false;
              setFilters((prev) => ({ ...prev, includeInactive: checked }));
            }}
          />
          {isFetching && <Loader size="sm" />}
        </Group>

        <Tabs value={activeTab} onChange={handleTabChange} keepMounted={false}>
          <Tabs.List>
            <Tabs.Tab value="categories">ã‚«ãƒ†ã‚´ãƒª</Tabs.Tab>
            <Tabs.Tab value="tags">ã‚¿ã‚°ä¸€è¦§</Tabs.Tab>
            <Tabs.Tab value="automation" leftSection={<IconRobot size={16} />}>
              è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«
            </Tabs.Tab>
          </Tabs.List>

          <Tabs.Panel value="categories" pt="lg">
            <CategoriesTab
              isLoading={isLoading}
              sortedCategories={sortedCategories}
              isAnyMutationPending={isAnyMutationPending}
              reorderCategoriesPending={reorderCategoriesMutation.isPending}
              deleteCategoryPending={deleteCategory.isPending}
              deleteGroupPending={deleteGroup.isPending}
              deleteTagPending={deleteTag.isPending}
              reorderGroupsPending={reorderGroupsMutation.isPending}
              reorderTagsPending={reorderTagsMutation.isPending}
              onCategoryDragEnd={handleCategoryDragEnd}
              onEditCategory={handleEditCategory}
              onDeleteCategory={handleDeleteCategory}
              onOpenCreateGroup={handleOpenCreateGroup}
              onOpenCreateTag={handleOpenCreateTag}
              onEditGroup={handleEditGroup}
              onDeleteGroup={handleDeleteGroupAction}
              onEditTag={handleEditTag}
              onDeleteTag={handleDeleteTag}
              onTagContextAction={handleTagContextAction}
              onReorderGroups={handleReorderGroups}
              onReorderTags={handleReorderTags}
            />
          </Tabs.Panel>

          <Tabs.Panel value="tags" pt="lg">
            <TagsListTab
              isLoading={isLoading}
              flatTags={flatTags}
              isAnyMutationPending={isAnyMutationPending}
              deleteTagPending={deleteTag.isPending}
              onEditTag={handleEditTag}
              onDeleteTag={handleDeleteTag}
            />
          </Tabs.Panel>

          <Tabs.Panel value="automation" pt="lg">
            <AutomationTab
              isLoading={isLoadingAutomationRules}
              automationRules={automationRules}
              isAnyMutationPending={isAnyMutationPending}
              createAutomationRulePending={createAutomationRule.isPending}
              updateAutomationRulePending={updateAutomationRule.isPending}
              deleteAutomationRulePending={deleteAutomationRule.isPending}
              onOpenCreateRule={handleOpenCreateAutomationRule}
              onEditRule={handleEditAutomationRule}
              onDeleteRule={handleDeleteAutomationRule}
              onOpenExecuteRule={handleOpenExecuteRule}
            />
          </Tabs.Panel>
        </Tabs>

        {/* ãƒ¢ãƒ¼ãƒ€ãƒ«ç¾¤ */}
        <CategoryModal
          opened={categoryModalOpened}
          onClose={() => {
            closeCategoryModal();
            setEditingCategory(null);
          }}
          form={categoryForm}
          onSubmit={handleSubmitCategory}
          isEditing={!!editingCategory}
          isSubmitting={isCategorySubmitting}
          categoryScopeOptions={CATEGORY_SCOPE_OPTIONS}
          setAsCategoryDefaultBgColor={setAsCategoryDefaultBgColor}
          onSetAsCategoryDefaultBgColorChange={setSetAsCategoryDefaultBgColor}
          setAsCategoryDefaultTextColor={setAsCategoryDefaultTextColor}
          onSetAsCategoryDefaultTextColorChange={setSetAsCategoryDefaultTextColor}
        />

        <GroupModal
          opened={groupModalOpened}
          onClose={() => {
            closeGroupModal();
            setEditingGroup(null);
          }}
          form={groupForm}
          onSubmit={handleSubmitGroup}
          isEditing={!!editingGroup}
          isSubmitting={isGroupSubmitting}
          categoryOptions={categoryOptions}
          setAsGroupDefaultBgColor={setAsGroupDefaultBgColor}
          onSetAsGroupDefaultBgColorChange={setSetAsGroupDefaultBgColor}
          setAsGroupDefaultTextColor={setAsGroupDefaultTextColor}
          onSetAsGroupDefaultTextColorChange={setSetAsGroupDefaultTextColor}
          inheritGroupColorFromCategory={inheritGroupColorFromCategory}
          onInheritGroupColorFromCategoryChange={handleInheritGroupColorFromCategoryChange}
        />

        <TagModal
          opened={tagModalOpened}
          onClose={() => {
            closeTagModal();
            setEditingTag(null);
          }}
          form={tagForm}
          onSubmit={handleSubmitTag}
          isEditing={!!editingTag}
          isSubmitting={isTagSubmitting}
          categoryOptions={categoryOptions}
          tagGroupOptions={tagGroupOptions}
          setAsTagDefaultBgColor={setAsTagDefaultBgColor}
          onSetAsTagDefaultBgColorChange={setSetAsTagDefaultBgColor}
          setAsTagDefaultTextColor={setAsTagDefaultTextColor}
          onSetAsTagDefaultTextColorChange={setSetAsTagDefaultTextColor}
          inheritTagColorFromGroup={inheritTagColorFromGroup}
          onInheritTagColorFromGroupChange={handleInheritTagColorFromGroupChange}
        />

        <AutomationRuleModal
          opened={automationRuleModalOpened}
          onClose={() => {
            closeAutomationRuleModal();
            setEditingAutomationRule(null);
            automationRuleForm.reset();
          }}
          form={automationRuleForm}
          onSubmit={handleSubmitAutomationRule}
          isEditing={!!editingAutomationRule}
          isSubmitting={createAutomationRule.isPending || updateAutomationRule.isPending}
          automationTagOptions={automationTagOptions}
          pageActionOptions={pageActionOptions}
        />

        <ExecuteRuleModal
          opened={executeRuleModalOpened}
          onClose={() => {
            closeExecuteRuleModal();
            setExecutingRule(null);
          }}
          rule={executingRule}
          isExecuting={executeAutomationRule.isPending}
          onExecute={handleExecuteRule}
        />

        {/* æ“ä½œç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ« */}
        <OperationModalManager
          operationType={currentOperation}
          entity={currentEntity}
          entityType="ã‚¿ã‚°"
          onClose={closeOperation}
          onConfirm={handleOperationConfirm}
        />
      </Stack>
    </Container>
  );
}
````

## File: frontend/src/app/tenants/_components/TenantsManagement.tsx
````typescript
'use client';

import { useState, useEffect } from 'react';
import { Stack, Tabs, Alert, Loader, Center, Group } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { IconAlertCircle, IconUserPlus } from '@tabler/icons-react';
import { useAuth } from '@/lib/auth/store';
import { usePageHeader } from '@/lib/contexts/page-header-context';
import { TenantsList } from './TenantsList';
import { UsersList } from './UsersList';
import { UserProfileForm } from './UserProfileForm';
import { BottomNavSettings } from './BottomNavSettings';
import { InviteUserModal } from './InviteUserModal';
import { ActionMenu } from './ActionMenu';

/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * 
 * ãƒ­ãƒ¼ãƒ«ã«å¿œã˜ã¦ä»¥ä¸‹ã®æ©Ÿèƒ½ã‚’æä¾›:
 * - å…¨å“¡: ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ç·¨é›†ã€ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¤‰æ›´
 * - SUPER_ADMIN: ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†è€…æ‹›å¾…ã€å…¨ãƒ†ãƒŠãƒ³ãƒˆé–²è¦§ã€ãƒ†ãƒŠãƒ³ãƒˆä½œæˆ
 * - TENANT_ADMIN: ãƒ¦ãƒ¼ã‚¶ãƒ¼æ‹›å¾…ã€è‡ªãƒ†ãƒŠãƒ³ãƒˆã®ãƒ¦ãƒ¼ã‚¶ãƒ¼é–²è¦§
 */
export function TenantsManagement() {
  const { user, isAuthenticated, initialized } = useAuth();
  const { setPageHeader } = usePageHeader();
  const [activeTab, setActiveTab] = useState<string | null>('profile');

  // æ‹›å¾…ãƒ¢ãƒ¼ãƒ€ãƒ«ã®çŠ¶æ…‹
  const [inviteUserOpened, { open: openInviteUser, close: closeInviteUser }] = useDisclosure(false);

  // ãƒšãƒ¼ã‚¸ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’è¨­å®š
  useEffect(() => {
    setPageHeader('ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç†');
    return () => setPageHeader(null);
  }, [setPageHeader]);

  // æ¨©é™ãƒã‚§ãƒƒã‚¯
  const isSuperAdmin = user?.role === 'SUPER_ADMIN';
  const isTenantAdmin = user?.role === 'TENANT_ADMIN';
  // ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç†ã¯ SUPER_ADMIN ã¨ TENANT_ADMIN ãŒå¯èƒ½
  const hasUserManagementAccess = isSuperAdmin || isTenantAdmin;

  // ç¾åœ¨ã®ã‚¿ãƒ–ã«å¿œã˜ãŸã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›®ã‚’ç”Ÿæˆ
  const getActionItems = () => {
    // ã€Œãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§ã€ã‚¿ãƒ–ã§ TENANT_ADMIN ã®å ´åˆã®ã¿ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼æ‹›å¾…ã‚’è¡¨ç¤º
    if (activeTab === 'users' && isTenantAdmin) {
      return [
        {
          id: 'invite-user',
          label: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’æ‹›å¾…',
          icon: <IconUserPlus size={16} />,
          onClick: openInviteUser,
        },
      ];
    }

    return [];
  };

  // åˆæœŸåŒ–å¾…æ©Ÿ
  if (!initialized) {
    return (
      <Center h="50vh">
        <Loader size="lg" />
      </Center>
    );
  }

  // æœªèªè¨¼
  if (!isAuthenticated || !user) {
    return (
      <Center h="50vh">
        <Alert icon={<IconAlertCircle size={16} />} title="èªè¨¼ã‚¨ãƒ©ãƒ¼" color="red">
          ãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ã§ã™
        </Alert>
      </Center>
    );
  }

  const actionItems = getActionItems();

  return (
    <Stack gap="lg" p={0}>
      {actionItems.length > 0 && (
        <Group justify="flex-end">
          <ActionMenu 
            items={actionItems} 
            buttonLabel="ã‚¢ã‚¯ã‚·ãƒ§ãƒ³" 
            isSectionAction
          />
        </Group>
      )}

      <Tabs value={activeTab} onChange={setActiveTab}>
        <Tabs.List grow>
          <Tabs.Tab value="profile">ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®š</Tabs.Tab>
          {isSuperAdmin && <Tabs.Tab value="tenants">ãƒ†ãƒŠãƒ³ãƒˆä¸€è¦§</Tabs.Tab>}
          {hasUserManagementAccess && <Tabs.Tab value="users">ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§</Tabs.Tab>}
        </Tabs.List>

        {/* 
         * ã‚¿ãƒ–ãƒ‘ãƒãƒ«ã¯æ¡ä»¶ä»˜ãã§ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã—ã€ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¿ãƒ–ã®ã¿ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’ãƒã‚¦ãƒ³ãƒˆã™ã‚‹ã€‚
         * ã“ã‚Œã«ã‚ˆã‚Šã€æ¨©é™ãŒãªã„ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒšãƒ¼ã‚¸ã«å…¥ã£ãŸæ™‚ã«ã€
         * ä¸è¦ãªAPIã‚³ãƒ¼ãƒ«ãŒç™ºç”Ÿã—ã¦403ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹ã“ã¨ã‚’é˜²ãã€‚
         */}
        <Tabs.Panel value="profile" pt="md">
          {activeTab === 'profile' && (
            <Stack gap="lg">
              <UserProfileForm />
              <BottomNavSettings />
            </Stack>
          )}
        </Tabs.Panel>

        <Tabs.Panel value="tenants" pt="md">
          {activeTab === 'tenants' && isSuperAdmin && <TenantsList />}
        </Tabs.Panel>

        <Tabs.Panel value="users" pt="md">
          {activeTab === 'users' && hasUserManagementAccess && <UsersList />}
        </Tabs.Panel>
      </Tabs>

      {/* TENANT_ADMIN å°‚ç”¨: ãƒ¦ãƒ¼ã‚¶ãƒ¼æ‹›å¾…ãƒ¢ãƒ¼ãƒ€ãƒ« */}
      {isTenantAdmin && (
        <InviteUserModal
          opened={inviteUserOpened}
          onClose={closeInviteUser}
        />
      )}
    </Stack>
  );
}
````

## File: frontend/src/components/common/index.ts
````typescript
export { UnifiedModal, type UnifiedModalProps, type ModalSection } from './UnifiedModal';
````

## File: frontend/src/components/common/UNIFIED_MODAL_SECTIONS.md
````markdown
# UnifiedModal ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ã®ä½¿ç”¨ä¾‹

## æ¦‚è¦

`UnifiedModal` ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã« `sections` ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ãƒ¢ãƒ¼ãƒ€ãƒ«å†…ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’è¤‡æ•°ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«åˆ†å‰²ã—ã€å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³é–“ã«è‡ªå‹•çš„ã«ãƒ©ãƒ™ãƒ«ä»˜ãDividerã‚’æŒ¿å…¥ã§ãã¾ã™ã€‚

## åŸºæœ¬çš„ãªä½¿ã„æ–¹

### å¾“æ¥ã®æ–¹æ³•ï¼ˆå¾Œæ–¹äº’æ›æ€§ã‚ã‚Šï¼‰

```tsx
import { UnifiedModal } from '@/components/common';

<UnifiedModal opened={opened} onClose={onClose} title="ç·¨é›†">
  <TextInput label="åå‰" />
  <TextInput label="ãƒ¡ãƒ¼ãƒ«" />
  <Button>ä¿å­˜</Button>
</UnifiedModal>
```

### æ–°ã—ã„ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ã‚’ä½¿ã†æ–¹æ³•

```tsx
import { UnifiedModal, type ModalSection } from '@/components/common/UnifiedModal';

const sections: ModalSection[] = [
  {
    label: 'åŸºæœ¬æƒ…å ±',
    content: (
      <>
        <TextInput label="åå‰" />
        <TextInput label="ãƒ¡ãƒ¼ãƒ«" />
      </>
    ),
  },
  {
    label: 'è©³ç´°è¨­å®š',
    content: (
      <>
        <Select label="ç¨®åˆ¥" data={[...]} />
        <Textarea label="å‚™è€ƒ" />
      </>
    ),
  },
  {
    label: 'æ“ä½œ',
    content: (
      <Group justify="flex-end">
        <Button variant="outline" onClick={onClose}>ã‚­ãƒ£ãƒ³ã‚»ãƒ«</Button>
        <Button onClick={onSubmit}>ä¿å­˜</Button>
      </Group>
    ),
  },
];

<UnifiedModal 
  opened={opened} 
  onClose={onClose} 
  title="çŒ«ã®æƒ…å ±ç·¨é›†"
  sections={sections}
/>
```

## å®Ÿéš›ã®ä¾‹

### çŒ«ã®ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§åˆ†å‰²

```tsx
'use client';

import { useState } from 'react';
import { TextInput, Select, Textarea, Button, Group, Grid } from '@mantine/core';
import { UnifiedModal, type ModalSection } from '@/components/common';
import { IconDeviceFloppy, IconX } from '@tabler/icons-react';

export function CatEditModalWithSections({
  opened,
  onClose,
  catId,
  onSuccess,
}: CatEditModalProps) {
  const [form, setForm] = useState({
    name: '',
    gender: 'MALE',
    breedId: '',
    coatColorId: '',
    birthDate: '',
    microchipNumber: '',
    registrationNumber: '',
    description: '',
    tagIds: [],
  });

  const sections: ModalSection[] = [
    {
      label: 'åŸºæœ¬æƒ…å ±',
      content: (
        <Grid gutter="md">
          <Grid.Col span={6}>
            <TextInput
              label="åå‰"
              value={form.name}
              onChange={(e) => setForm(prev => ({ ...prev, name: e.target.value }))}
              required
            />
          </Grid.Col>
          <Grid.Col span={6}>
            <Select
              label="æ€§åˆ¥"
              value={form.gender}
              onChange={(value) => setForm(prev => ({ ...prev, gender: value || '' }))}
              data={GENDER_OPTIONS}
              required
            />
          </Grid.Col>
          <Grid.Col span={6}>
            <TextInput
              label="ç”Ÿå¹´æœˆæ—¥"
              type="date"
              value={form.birthDate}
              onChange={(e) => setForm(prev => ({ ...prev, birthDate: e.target.value }))}
              required
            />
          </Grid.Col>
        </Grid>
      ),
    },
    {
      label: 'è©³ç´°æƒ…å ±',
      content: (
        <Grid gutter="md">
          <Grid.Col span={6}>
            <Select label="å“ç¨®" {...} />
          </Grid.Col>
          <Grid.Col span={6}>
            <Select label="è‰²æŸ„" {...} />
          </Grid.Col>
          <Grid.Col span={12}>
            <TextInput label="ãƒã‚¤ã‚¯ãƒ­ãƒãƒƒãƒ—ç•ªå·" {...} />
          </Grid.Col>
          <Grid.Col span={12}>
            <TextInput label="ç™»éŒ²ç•ªå·" {...} />
          </Grid.Col>
        </Grid>
      ),
    },
    {
      label: 'ãã®ä»–',
      content: (
        <>
          <Textarea
            label="è©³ç´°èª¬æ˜"
            value={form.description}
            onChange={(e) => setForm(prev => ({ ...prev, description: e.target.value }))}
            rows={3}
          />
          <TagSelector {...} />
        </>
      ),
    },
    {
      // ãƒ©ãƒ™ãƒ«ãªã—ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚‚å¯èƒ½
      content: (
        <Group justify="flex-end" mt="md">
          <Button
            variant="subtle"
            color="gray"
            onClick={onClose}
            leftSection={<IconX size={16} />}
          >
            ã‚­ãƒ£ãƒ³ã‚»ãƒ«
          </Button>
          <Button
            type="submit"
            leftSection={<IconDeviceFloppy size={16} />}
          >
            ä¿å­˜
          </Button>
        </Group>
      ),
    },
  ];

  return (
    <UnifiedModal
      opened={opened}
      onClose={onClose}
      title="çŒ«ã®æƒ…å ±ç·¨é›†"
      size="lg"
      sections={sections}
    />
  );
}
```

## ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ã®åˆ©ç‚¹

1. **å¢ƒç•Œã®æ˜ç¢ºåŒ–**: å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³é–“ã«ãƒ©ãƒ™ãƒ«ä»˜ãDividerãŒè‡ªå‹•æŒ¿å…¥ã•ã‚Œã€ã©ã“ã¾ã§ãŒ1ã¤ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‹æ˜ç¢º
2. **çµ±ä¸€æ€§**: ã™ã¹ã¦ã®ãƒ¢ãƒ¼ãƒ€ãƒ«ã§ä¸€è²«ã—ãŸã‚»ã‚¯ã‚·ãƒ§ãƒ³åŒºåˆ‡ã‚Šã‚¹ã‚¿ã‚¤ãƒ«
3. **ä¿å®ˆæ€§å‘ä¸Š**: ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ§‹é€ ã‚’é…åˆ—ã§ç®¡ç†ã§ãã‚‹ãŸã‚ã€è¿½åŠ ãƒ»å‰Šé™¤ãƒ»ä¸¦ã³æ›¿ãˆãŒå®¹æ˜“
4. **å¯èª­æ€§**: ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã”ã¨ã«è«–ç†çš„ã«ã‚³ãƒ¼ãƒ‰ã‚’åˆ†å‰²ã§ãã€ã‚³ãƒ¼ãƒ‰ã®å¯èª­æ€§ãŒå‘ä¸Š

## å‹å®šç¾©

```typescript
interface ModalSection {
  /** ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ©ãƒ™ãƒ«ï¼ˆDividerã«è¡¨ç¤ºï¼‰ã€‚çœç•¥å¯èƒ½ */
  label?: string;
  /** ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ */
  content: ReactNode;
}

type UnifiedModalProps = Omit<ModalProps, 'children'> & {
  addContentPadding?: boolean;
} & (
  | {
      children: ReactNode;
      sections?: never;
    }
  | {
      children?: never;
      sections: ModalSection[];
    }
);
```

## æ³¨æ„äº‹é …

- `children` ã¨ `sections` ã¯ç›¸äº’æ’ä»–çš„ã§ã™ã€‚ã©ã¡ã‚‰ã‹ä¸€æ–¹ã®ã¿ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚
- TypeScriptãŒå‹ãƒã‚§ãƒƒã‚¯ã§ä¸¡æ–¹ã‚’åŒæ™‚ã«ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’é˜²ãã¾ã™ã€‚
- æ—¢å­˜ã®ãƒ¢ãƒ¼ãƒ€ãƒ«ã¯ `children` ã‚’ä½¿ã„ç¶šã‘ã‚‹ã“ã¨ãŒã§ãã€å¾Œæ–¹äº’æ›æ€§ãŒä¿ãŸã‚Œã¦ã„ã¾ã™ã€‚
- ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã® `label` ã¯çœç•¥å¯èƒ½ã§ã™ã€‚2ç•ªç›®ä»¥é™ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯å¸¸ã«DividerãŒè¡¨ç¤ºã•ã‚Œã¾ã™ï¼ˆãƒ©ãƒ™ãƒ«ãŒãªã„å ´åˆã¯åŒºåˆ‡ã‚Šç·šã®ã¿ï¼‰ã€‚æœ€åˆã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯ã€ãƒ©ãƒ™ãƒ«ãŒã‚ã‚‹å ´åˆã®ã¿DividerãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚
- ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‹•çš„ã«è¿½åŠ ãƒ»å‰Šé™¤ãƒ»ä¸¦ã³æ›¿ãˆã™ã‚‹å ´åˆã¯ã€`ModalSection`ã®`key`ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã§å®‰å®šã—ãŸã‚­ãƒ¼ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™ã€‚
````

## File: frontend/src/components/kittens/BulkWeightRecordModal.tsx
````typescript
'use client';

import { useState, useEffect } from 'react';
import {
  NumberInput,
  Textarea,
  Button,
  Group,
  Stack,
  Text,
  Card,
  Grid,
  ActionIcon,
  Badge,
} from '@mantine/core';
import { DateTimePicker } from '@mantine/dates';
import {
  IconScale,
  IconChevronLeft,
  IconChevronRight,
  IconTrendingUp,
  IconTrendingDown,
  IconMinus,
} from '@tabler/icons-react';
import {
  useCreateBulkWeightRecords,
  useGetWeightRecords,
  type BulkWeightRecordItem,
} from '@/lib/api/hooks/use-weight-records';
import { GenderBadge } from '@/components/GenderBadge';
import { UnifiedModal, type ModalSection } from '@/components/common';

interface Kitten {
  id: string;
  name: string;
  gender: 'ã‚ªã‚¹' | 'ãƒ¡ã‚¹';
  color: string;
}

interface MotherGroup {
  motherId: string;
  motherName: string;
  fatherName: string;
  deliveryDate: string;
  kittens: Kitten[];
}

interface BulkWeightRecordModalProps {
  opened: boolean;
  onClose: () => void;
  motherGroups: MotherGroup[];
  initialMotherIndex?: number;
  onSuccess?: () => void;
}

interface WeightInputState {
  [catId: string]: {
    weight: number | '';
    notes: string;
  };
}

/**
 * æ¯çŒ«å˜ä½ã®ä¸€æ‹¬ä½“é‡è¨˜éŒ²ãƒ¢ãƒ¼ãƒ€ãƒ«
 * å…„å¼Ÿï¼ˆåŒã˜æ¯çŒ«ã®å­çŒ«ï¼‰ã‚’ã¾ã¨ã‚ã¦ä½“é‡è¨˜éŒ²ã§ãã‚‹
 */
export function BulkWeightRecordModal({
  opened,
  onClose,
  motherGroups,
  initialMotherIndex = 0,
  onSuccess,
}: BulkWeightRecordModalProps) {
  const [currentIndex, setCurrentIndex] = useState(initialMotherIndex);
  const [recordedAt, setRecordedAt] = useState<Date>(new Date());
  const [weightInputs, setWeightInputs] = useState<WeightInputState>({});

  const createBulkMutation = useCreateBulkWeightRecords();

  const currentGroup = motherGroups[currentIndex];
  const hasMultipleGroups = motherGroups.length > 1;

  // ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒé–‹ã„ãŸã¨ãã«åˆæœŸåŒ–
  useEffect(() => {
    if (opened) {
      setCurrentIndex(initialMotherIndex);
      setRecordedAt(new Date());
      setWeightInputs({});
    }
  }, [opened, initialMotherIndex]);

  // æ¯çŒ«ãŒå¤‰ã‚ã£ãŸã¨ãã«å…¥åŠ›çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
  useEffect(() => {
    if (currentGroup) {
      const initialInputs: WeightInputState = {};
      for (const kitten of currentGroup.kittens) {
        initialInputs[kitten.id] = { weight: '', notes: '' };
      }
      setWeightInputs(initialInputs);
    }
  }, [currentIndex, currentGroup]);

  const handlePrev = () => {
    if (currentIndex > 0) {
      setCurrentIndex(currentIndex - 1);
    }
  };

  const handleNext = () => {
    if (currentIndex < motherGroups.length - 1) {
      setCurrentIndex(currentIndex + 1);
    }
  };

  const handleWeightChange = (catId: string, weight: number | string) => {
    setWeightInputs((prev) => ({
      ...prev,
      [catId]: {
        ...prev[catId],
        weight: weight === '' ? '' : Number(weight),
      },
    }));
  };

  const handleNotesChange = (catId: string, notes: string) => {
    setWeightInputs((prev) => ({
      ...prev,
      [catId]: {
        ...prev[catId],
        notes,
      },
    }));
  };

  const handleSubmit = () => {

    // å…¥åŠ›ã•ã‚ŒãŸä½“é‡ã®ã¿ã‚’åé›†
    const records: BulkWeightRecordItem[] = Object.entries(weightInputs)
      .filter(([, input]) => input.weight !== '' && typeof input.weight === 'number' && input.weight > 0)
      .map(([catId, input]) => ({
        catId,
        weight: input.weight as number,
        notes: input.notes || undefined,
      }));

    if (records.length === 0) {
      return;
    }

    createBulkMutation.mutate(
      {
        recordedAt: recordedAt.toISOString(),
        records,
      },
      {
        onSuccess: () => {
          // å…¥åŠ›ã‚’ãƒªã‚»ãƒƒãƒˆ
          const resetInputs: WeightInputState = {};
          for (const kitten of currentGroup?.kittens ?? []) {
            resetInputs[kitten.id] = { weight: '', notes: '' };
          }
          setWeightInputs(resetInputs);
          onSuccess?.();
        },
      },
    );
  };

  const filledCount = Object.values(weightInputs).filter(
    (input) => input.weight !== '' && typeof input.weight === 'number' && input.weight > 0,
  ).length;

  const isLoading = createBulkMutation.isPending;

  if (!currentGroup) {
    return null;
  }

  const sections: ModalSection[] = [
    {
      content: (
        <Card padding="sm" bg="gray.0" radius="md">
        <Group justify="space-between" align="center">
          <ActionIcon
            variant="subtle"
            disabled={currentIndex === 0}
            onClick={handlePrev}
            aria-label="å‰ã®æ¯çŒ«"
          >
            <IconChevronLeft size={20} />
          </ActionIcon>

          <Stack gap={2} align="center">
            <Text fw={600} size="lg">
              {currentGroup.motherName}
            </Text>
            <Group gap="xs">
              <Text size="xs" c="dimmed">
                çˆ¶: {currentGroup.fatherName}
              </Text>
              <Text size="xs" c="dimmed">
                â€¢
              </Text>
              <Text size="xs" c="dimmed">
                {currentGroup.deliveryDate}
              </Text>
            </Group>
            {hasMultipleGroups && (
              <Badge size="xs" variant="light">
                {currentIndex + 1} / {motherGroups.length}
              </Badge>
            )}
          </Stack>

          <ActionIcon
            variant="subtle"
            disabled={currentIndex === motherGroups.length - 1}
            onClick={handleNext}
            aria-label="æ¬¡ã®æ¯çŒ«"
          >
            <IconChevronRight size={20} />
          </ActionIcon>
        </Group>
        </Card>
      ),
    },
    {
      content: (
        <DateTimePicker
        label="æ¸¬å®šæ—¥æ™‚"
        placeholder="æ¸¬å®šæ—¥æ™‚ã‚’é¸æŠ"
        maxDate={new Date()}
        value={recordedAt}
        onChange={(value) => {
          if (value) {
            // DateTimePicker ã¯ string ã‚’è¿”ã™ã®ã§ Date ã«å¤‰æ›
            const dateValue = typeof value === 'string' ? new Date(value) : value;
            setRecordedAt(dateValue);
          }
        }}
          valueFormat="YYYY/MM/DD HH:mm"
        />
      ),
    },
    {
      content: (
        <Grid gutter="sm">
        {currentGroup.kittens.map((kitten) => (
          <Grid.Col key={kitten.id} span={{ base: 12, xs: 6 }}>
            <KittenWeightInput
              kitten={kitten}
              value={weightInputs[kitten.id]?.weight ?? ''}
              notes={weightInputs[kitten.id]?.notes ?? ''}
              onWeightChange={(weight) => handleWeightChange(kitten.id, weight)}
              onNotesChange={(notes) => handleNotesChange(kitten.id, notes)}
            />
          </Grid.Col>
        ))}
        </Grid>
      ),
    },
    {
      content: (
        <Group justify="space-between" mt="md">
          <Text size="sm" c="dimmed">
            {filledCount} / {currentGroup.kittens.length} é ­å…¥åŠ›æ¸ˆã¿
          </Text>
          <Group>
            <Button variant="default" onClick={onClose} disabled={isLoading}>
              é–‰ã˜ã‚‹
            </Button>
            <Button
              onClick={handleSubmit}
              loading={isLoading}
              disabled={filledCount === 0}
            >
              ä¿å­˜ ({filledCount}ä»¶)
            </Button>
          </Group>
        </Group>
      ),
    },
  ];

  return (
    <UnifiedModal
      opened={opened}
      onClose={onClose}
      title={
        <Group gap="xs">
          <IconScale size={20} />
          <Text fw={600}>ä½“é‡ã‚’ä¸€æ‹¬è¨˜éŒ²</Text>
        </Group>
      }
      size="lg"
      centered
      sections={sections}
    />
  );
}

/**
 * å­çŒ«ã®ä½“é‡å…¥åŠ›ã‚«ãƒ¼ãƒ‰
 */
interface KittenWeightInputProps {
  kitten: Kitten;
  value: number | '';
  notes: string;
  onWeightChange: (weight: number | string) => void;
  onNotesChange: (notes: string) => void;
}

function KittenWeightInput({
  kitten,
  value,
  notes,
  onWeightChange,
  onNotesChange,
}: KittenWeightInputProps) {
  // æœ€æ–°ã®ä½“é‡è¨˜éŒ²ã‚’å–å¾—
  const { data: weightData } = useGetWeightRecords({
    catId: kitten.id,
    limit: 2,
    sortOrder: 'desc',
  });

  const summary = weightData?.summary;
  const previousWeight = summary?.latestWeight;
  const weightChange =
    value !== '' && previousWeight !== null && previousWeight !== undefined
      ? (value as number) - previousWeight
      : null;

  return (
    <Card padding="sm" radius="md" withBorder>
      <Stack gap="xs">
        {/* ãƒ˜ãƒƒãƒ€ãƒ¼ */}
        <Group justify="space-between" wrap="nowrap">
          <Group gap="xs" wrap="nowrap">
            <Text size="sm" fw={500} lineClamp={1}>
              {kitten.name}
            </Text>
            <GenderBadge gender={kitten.gender} size="xs" />
          </Group>
          {previousWeight !== null && previousWeight !== undefined && (
            <Text size="xs" c="dimmed">
              å‰å›: {previousWeight}g
            </Text>
          )}
        </Group>

        {/* ä½“é‡å…¥åŠ› */}
        <Group gap="xs" align="flex-end" wrap="nowrap">
          <NumberInput
            placeholder="ä½“é‡"
            value={value}
            onChange={onWeightChange}
            min={1}
            max={50000}
            step={5}
            suffix=" g"
            size="sm"
            style={{ flex: 1 }}
          />
          {weightChange !== null && (
            <WeightChangeBadge change={weightChange} />
          )}
        </Group>

        {/* ãƒ¡ãƒ¢ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰ */}
        <Textarea
          placeholder="ãƒ¡ãƒ¢ï¼ˆä»»æ„ï¼‰"
          value={notes}
          onChange={(e) => onNotesChange(e.currentTarget.value)}
          size="xs"
          autosize
          minRows={1}
          maxRows={2}
        />
      </Stack>
    </Card>
  );
}

/**
 * ä½“é‡å¤‰åŒ–ãƒãƒƒã‚¸
 */
function WeightChangeBadge({ change }: { change: number }) {
  const isPositive = change > 0;
  const isNegative = change < 0;

  return (
    <Badge
      size="sm"
      color={isPositive ? 'blue' : isNegative ? 'red' : 'gray'}
      variant="light"
      leftSection={
        isPositive ? (
          <IconTrendingUp size={12} />
        ) : isNegative ? (
          <IconTrendingDown size={12} />
        ) : (
          <IconMinus size={12} />
        )
      }
    >
      {isPositive ? '+' : ''}
      {change}g
    </Badge>
  );
}

export default BulkWeightRecordModal;
````

## File: frontend/src/components/kittens/WeightRecordTable.tsx
````typescript
'use client';

import { Fragment } from 'react';
import {
  Card,
  Table,
  Text,
  Group,
  Badge,
  Tooltip,
  Stack,
  Box,
  ScrollArea,
  Loader,
  Center,
} from '@mantine/core';
import {
  IconScale,
  IconTrendingUp,
  IconTrendingDown,
  IconMinus,
  IconChevronRight,
} from '@tabler/icons-react';
import { useGetWeightRecords } from '@/lib/api/hooks/use-weight-records';
import { ActionIconButton } from '@/components/ActionButton';
import { GenderBadge } from '@/components/GenderBadge';

interface Kitten {
  id: string;
  name: string;
  color: string;
  gender: 'ã‚ªã‚¹' | 'ãƒ¡ã‚¹';
}

interface MotherCat {
  id: string;
  name: string;
  fatherName: string;
  kittens: Kitten[];
  deliveryDate: string;
  daysOld: number;
}

interface WeightRecordTableProps {
  motherCats: MotherCat[];
  onRecordWeight: (kitten: Kitten) => void;
  /** ä¸€æ‹¬è¨˜éŒ²ãƒœã‚¿ãƒ³ã®ãƒãƒ³ãƒ‰ãƒ©ï¼ˆãƒ˜ãƒƒãƒ€ãƒ¼ã§ä½¿ç”¨ã™ã‚‹ãŸã‚ã€ã“ã“ã§ã¯ä½¿ç”¨ã—ãªã„ï¼‰ */
  onBulkRecord?: () => void;
  /** è¡¨ç¤ºã™ã‚‹ä½“é‡è¨˜éŒ²ã®æ•°ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 8ï¼‰ */
  recordLimit?: number;
}

/**
 * ä½“é‡ç®¡ç†ãƒ†ãƒ¼ãƒ–ãƒ«ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * æ¯çŒ«ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã—ã€å„å­çŒ«ã®ä½“é‡æ¨ç§»ã‚’è¡¨ç¤º
 * ã‚¹ãƒãƒ›å¯¾å¿œ: æœ€æ–°ä½“é‡+å¢—æ¸›ã‚’å›ºå®šè¡¨ç¤ºã€å±¥æ­´ã¯æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
 */
export function WeightRecordTable({
  motherCats,
  onRecordWeight,
  // onBulkRecord ã¯ãƒ˜ãƒƒãƒ€ãƒ¼ã§ä½¿ç”¨ã™ã‚‹ãŸã‚ã€ã“ã“ã§ã¯å‚ç…§ã—ãªã„
  recordLimit = 8,
}: WeightRecordTableProps) {
  if (motherCats.length === 0) {
    return (
      <Card padding="md" radius="md" withBorder>
        <Center py="xl">
          <Text c="dimmed">è¡¨ç¤ºã™ã‚‹å­çŒ«ãŒã„ã¾ã›ã‚“</Text>
        </Center>
      </Card>
    );
  }

  return (
    <Card padding="md" radius="md" withBorder>
      <Stack gap="md">
        {/* ãƒ˜ãƒƒãƒ€ãƒ¼ */}
        <Group justify="space-between">
          <Text size="lg" fw={500}>
            ä½“é‡è¨˜éŒ²ä¸€è¦§
          </Text>
          <Text size="sm" c="dimmed">
            ç›´è¿‘{recordLimit}å›åˆ†ã‚’è¡¨ç¤º
          </Text>
        </Group>

        {/* ãƒ†ãƒ¼ãƒ–ãƒ« */}
        <Box style={{ position: 'relative' }}>
          <ScrollArea>
            <Table striped withTableBorder>
              <Table.Thead>
                <Table.Tr>
                  <Table.Th style={{ minWidth: 120, position: 'sticky', left: 0, background: 'white', zIndex: 1 }}>
                    æ¯çŒ«/å­çŒ«
                  </Table.Th>
                  <Table.Th style={{ minWidth: 60 }}>è‰²æŸ„</Table.Th>
                  <Table.Th style={{ minWidth: 80, textAlign: 'center' }}>æœ€æ–°</Table.Th>
                  <Table.Th style={{ minWidth: 60, textAlign: 'center' }}>å¢—æ¸›</Table.Th>
                  <Table.Th style={{ minWidth: 40, textAlign: 'center' }}></Table.Th>
                  {/* éå»ã®è¨˜éŒ²åˆ—ï¼ˆã‚¹ãƒãƒ›ã§ã¯æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼‰ */}
                  {Array.from({ length: recordLimit - 1 }).map((_, i) => (
                    <Table.Th key={i} style={{ minWidth: 70, textAlign: 'center' }}>
                      {i + 2}å›å‰
                    </Table.Th>
                  ))}
                </Table.Tr>
              </Table.Thead>
              <Table.Tbody>
                {motherCats.map((mother) => (
                  <Fragment key={mother.id}>
                    {/* æ¯çŒ«ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œ */}
                    <Table.Tr style={{ backgroundColor: 'var(--mantine-color-blue-0)' }}>
                      <Table.Td
                        colSpan={4 + recordLimit}
                        style={{ position: 'sticky', left: 0, background: 'var(--mantine-color-blue-0)' }}
                      >
                        <Group gap="xs">
                          <Text fw={600} size="sm">
                            {mother.name}
                          </Text>
                          <Text size="xs" c="dimmed">
                            ({mother.deliveryDate})
                          </Text>
                          <Badge size="xs" variant="light">
                            {mother.kittens.length}é ­
                          </Badge>
                        </Group>
                      </Table.Td>
                    </Table.Tr>

                    {/* å­çŒ«ã®è¡Œ */}
                    {mother.kittens.map((kitten) => (
                      <KittenWeightRow
                        key={kitten.id}
                        kitten={kitten}
                        recordLimit={recordLimit}
                        onRecordWeight={() => onRecordWeight(kitten)}
                      />
                    ))}
                  </Fragment>
                ))}
              </Table.Tbody>
            </Table>
          </ScrollArea>
        </Box>

        {/* å‡¡ä¾‹ */}
        <Group gap="md" justify="center">
          <Group gap={4}>
            <IconTrendingUp size={14} color="var(--mantine-color-blue-6)" />
            <Text size="xs" c="dimmed">
              å¢—åŠ 
            </Text>
          </Group>
          <Group gap={4}>
            <IconTrendingDown size={14} color="var(--mantine-color-red-6)" />
            <Text size="xs" c="dimmed">
              æ¸›å°‘
            </Text>
          </Group>
          <Group gap={4}>
            <IconMinus size={14} color="var(--mantine-color-gray-5)" />
            <Text size="xs" c="dimmed">
              å¤‰åŒ–ãªã—
            </Text>
          </Group>
        </Group>
      </Stack>
    </Card>
  );
}

/**
 * å­çŒ«ã®ä½“é‡è¡Œã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 */
interface KittenWeightRowProps {
  kitten: Kitten;
  recordLimit: number;
  onRecordWeight: () => void;
}

function KittenWeightRow({ kitten, recordLimit, onRecordWeight }: KittenWeightRowProps) {
  const { data: weightData, isLoading } = useGetWeightRecords({
    catId: kitten.id,
    limit: recordLimit,
    sortOrder: 'desc',
  });

  const records = weightData?.data ?? [];
  const latestWeight = records[0]?.weight ?? null;
  const previousWeight = records[1]?.weight ?? null;
  const weightChange =
    latestWeight !== null && previousWeight !== null ? latestWeight - previousWeight : null;

  return (
    <Table.Tr>
      {/* å­çŒ«åï¼ˆå›ºå®šï¼‰ */}
      <Table.Td style={{ position: 'sticky', left: 0, background: 'white', zIndex: 1 }}>
        <Group gap="xs" wrap="nowrap">
          <IconChevronRight size={12} color="var(--mantine-color-gray-4)" />
          <Text size="sm" lineClamp={1}>
            {kitten.name}
          </Text>
          <GenderBadge gender={kitten.gender} size="xs" />
        </Group>
      </Table.Td>

      {/* è‰²æŸ„ */}
      <Table.Td>
        <Text size="xs" c="dimmed" lineClamp={1}>
          {kitten.color}
        </Text>
      </Table.Td>

      {/* æœ€æ–°ä½“é‡ */}
      <Table.Td style={{ textAlign: 'center' }}>
        {isLoading ? (
          <Loader size="xs" />
        ) : latestWeight !== null ? (
          <Text size="sm" fw={600}>
            {latestWeight}g
          </Text>
        ) : (
          <Text size="xs" c="dimmed">
            -
          </Text>
        )}
      </Table.Td>

      {/* å¢—æ¸› */}
      <Table.Td style={{ textAlign: 'center' }}>
        {weightChange !== null ? (
          <WeightChangeBadge change={weightChange} />
        ) : (
          <Text size="xs" c="dimmed">
            -
          </Text>
        )}
      </Table.Td>

      {/* è¨˜éŒ²ãƒœã‚¿ãƒ³ */}
      <Table.Td style={{ textAlign: 'center' }}>
        <Tooltip label="ä½“é‡ã‚’è¨˜éŒ²">
          <ActionIconButton 
            action="edit"
            customIcon={<IconScale size={18} />}
            onClick={onRecordWeight}
          />
        </Tooltip>
      </Table.Td>

      {/* éå»ã®è¨˜éŒ² */}
      {Array.from({ length: recordLimit - 1 }).map((_, i) => {
        const record = records[i + 1];
        const prevRecord = records[i + 2];
        const change =
          record && prevRecord ? record.weight - prevRecord.weight : null;

        return (
          <Table.Td key={i} style={{ textAlign: 'center' }}>
            {record ? (
              <Stack gap={2} align="center">
                <Text size="xs">{record.weight}g</Text>
                {change !== null && (
                  <MiniWeightChange change={change} />
                )}
              </Stack>
            ) : (
              <Text size="xs" c="dimmed">
                -
              </Text>
            )}
          </Table.Td>
        );
      })}
    </Table.Tr>
  );
}

/**
 * ä½“é‡å¤‰åŒ–ãƒãƒƒã‚¸
 */
function WeightChangeBadge({ change }: { change: number }) {
  const isPositive = change > 0;
  const isNegative = change < 0;

  return (
    <Badge
      size="sm"
      color={isPositive ? 'blue' : isNegative ? 'red' : 'gray'}
      variant="light"
      leftSection={
        isPositive ? (
          <IconTrendingUp size={10} />
        ) : isNegative ? (
          <IconTrendingDown size={10} />
        ) : (
          <IconMinus size={10} />
        )
      }
    >
      {isPositive ? '+' : ''}
      {change}
    </Badge>
  );
}

/**
 * å°ã•ã„ä½“é‡å¤‰åŒ–è¡¨ç¤ºï¼ˆéå»ã®è¨˜éŒ²ç”¨ï¼‰
 */
function MiniWeightChange({ change }: { change: number }) {
  const isPositive = change > 0;
  const isNegative = change < 0;

  return (
    <Group gap={2} wrap="nowrap">
      {isPositive ? (
        <IconTrendingUp size={10} color="var(--mantine-color-blue-6)" />
      ) : isNegative ? (
        <IconTrendingDown size={10} color="var(--mantine-color-red-6)" />
      ) : (
        <IconMinus size={10} color="var(--mantine-color-gray-5)" />
      )}
      <Text
        size="xs"
        c={isPositive ? 'blue' : isNegative ? 'red' : 'dimmed'}
      >
        {isPositive ? '+' : ''}
        {change}
      </Text>
    </Group>
  );
}

export default WeightRecordTable;
````

## File: frontend/src/components/pedigrees/PedigreeRegistrationForm.tsx
````typescript
'use client';

import { useState, useEffect, useMemo } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import {
  Button,
  Group,
  Stack,
  Grid,
  Text,
  Box,
  Paper,
  Divider,
  ActionIcon,
  Tooltip,
  Menu,
} from '@mantine/core';
import { notifications } from '@mantine/notifications';
import {
  useCreatePedigree,
  useUpdatePedigree,
  useGetPedigree,
  useGetPedigreeByNumber,
  type PedigreeRecord,
  type UpdatePedigreeRequest,
} from '@/lib/api/hooks/use-pedigrees';
import {
  IconDeviceFloppy,
  IconArrowLeft,
  IconPlus,
  IconRefresh,
  IconTrash,
  IconChevronDown,
  IconPrinter,
} from '@tabler/icons-react';
import { InputWithFloatingLabel } from '../ui/InputWithFloatingLabel';
import { SelectWithFloatingLabel } from '../ui/SelectWithFloatingLabel';
import { apiClient, type ApiResponse } from '@/lib/api/client';
import { getPublicApiBaseUrl } from '@/lib/api/public-api-base-url';

// API ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®å‹å®šç¾©
type BreedsResponse = Breed[];

type CoatColorsResponse = CoatColor[];

type GendersResponse = Gender[];

// å‹å®‰å…¨ãªAPIãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ï¼ˆãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿å–å¾—ç”¨ï¼‰
const getBreeds = async (params?: { limit?: string }): Promise<ApiResponse<BreedsResponse>> => {
  // @ts-expect-error - OpenAPIå‹å®šç¾©ãŒæœªç”Ÿæˆ
  return apiClient.get('/breeds', params ? { query: params } : undefined);
};

const getCoatColors = async (params?: { limit?: string }): Promise<ApiResponse<CoatColorsResponse>> => {
  // @ts-expect-error - OpenAPIå‹å®šç¾©ãŒæœªç”Ÿæˆ
  return apiClient.get('/coat-colors', params ? { query: params } : undefined);
};

const getGenders = async (): Promise<ApiResponse<GendersResponse>> => {
  // @ts-expect-error - OpenAPIå‹å®šç¾©ãŒæœªç”Ÿæˆ
  return apiClient.get('/master/genders');
};

const getNextPedigreeId = async (): Promise<ApiResponse<{ nextId: string }>> => {
  // @ts-expect-error - OpenAPIå‹å®šç¾©ãŒæœªç”Ÿæˆ
  return apiClient.get('/pedigrees/next-id');
};

interface Breed {
  id: string;
  code: number;
  name: string;
}

interface CoatColor {
  id: string;
  code: number;
  name: string;
}

interface Gender {
  id: string;
  code: number;
  name: string;
}

// Accessè¨­è¨ˆæº–æ‹ : åŸºæœ¬æƒ…å ±17é …ç›® + è¡€çµ±æƒ…å ±62é …ç›®
interface PedigreeFormData {
  // ========== åŸºæœ¬æƒ…å ±ï¼ˆ17é …ç›®ï¼‰==========
  pedigreeId: string;
  title?: string;
  catName?: string;
  catName2?: string;
  breedCode?: number;
  genderCode?: number;
  eyeColor?: string;
  coatColorCode?: number;
  birthDate?: string;
  breederName?: string;
  ownerName?: string;
  registrationDate?: string;
  brotherCount?: number;
  sisterCount?: number;
  notes?: string;
  notes2?: string;
  otherNo?: string;

  // ========== è¡€çµ±æƒ…å ±ï¼ˆ62é …ç›®ï¼‰==========
  // ç¬¬1ä¸–ä»£: çˆ¶è¦ªï¼ˆ7é …ç›®ï¼‰
  fatherTitle?: string;
  fatherCatName?: string;
  fatherCatName2?: string;
  fatherCoatColor?: string;
  fatherEyeColor?: string;
  fatherJCU?: string;
  fatherOtherCode?: string;

  // ç¬¬1ä¸–ä»£: æ¯è¦ªï¼ˆ7é …ç›®ï¼‰
  motherTitle?: string;
  motherCatName?: string;
  motherCatName2?: string;
  motherCoatColor?: string;
  motherEyeColor?: string;
  motherJCU?: string;
  motherOtherCode?: string;

  // ç¬¬2ä¸–ä»£: ç¥–çˆ¶æ¯ï¼ˆ16é …ç›® = 4å Ã— 4é …ç›®ï¼‰
  ffTitle?: string;
  ffCatName?: string;
  ffCatColor?: string;
  ffjcu?: string;

  fmTitle?: string;
  fmCatName?: string;
  fmCatColor?: string;
  fmjcu?: string;

  mfTitle?: string;
  mfCatName?: string;
  mfCatColor?: string;
  mfjcu?: string;

  mmTitle?: string;
  mmCatName?: string;
  mmCatColor?: string;
  mmjcu?: string;

  // ç¬¬3ä¸–ä»£: æ›¾ç¥–çˆ¶æ¯ï¼ˆ32é …ç›® = 8å Ã— 4é …ç›®ï¼‰
  fffTitle?: string;
  fffCatName?: string;
  fffCatColor?: string;
  fffjcu?: string;

  ffmTitle?: string;
  ffmCatName?: string;
  ffmCatColor?: string;
  ffmjcu?: string;

  fmfTitle?: string;
  fmfCatName?: string;
  fmfCatColor?: string;
  fmfjcu?: string;

  fmmTitle?: string;
  fmmCatName?: string;
  fmmCatColor?: string;
  fmmjcu?: string;

  mffTitle?: string;
  mffCatName?: string;
  mffCatColor?: string;
  mffjcu?: string;

  mfmTitle?: string;
  mfmCatName?: string;
  mfmCatColor?: string;
  mfmjcu?: string;

  mmfTitle?: string;
  mmfCatName?: string;
  mmfCatColor?: string;
  mmfjcu?: string;

  mmmTitle?: string;
  mmmCatName?: string;
  mmmCatColor?: string;
  mmmjcu?: string;

  oldCode?: string;
}

interface PedigreeRegistrationFormProps {
  onSuccess?: () => void;
  onCancel?: () => void;
}

function mapPedigreeRecordToFormData(record: PedigreeRecord, fallbackPedigreeId: string): PedigreeFormData {
  return {
    pedigreeId: record.pedigreeId || fallbackPedigreeId,
    title: record.title || undefined,
    catName: record.catName || undefined,
    catName2: (record as PedigreeFormData).catName2 || undefined,
    breedCode: record.breedCode || undefined,
    genderCode: record.genderCode || undefined,
    eyeColor: record.eyeColor || undefined,
    coatColorCode: record.coatColorCode || undefined,
    birthDate: record.birthDate || undefined,
    breederName: record.breederName || undefined,
    ownerName: record.ownerName || undefined,
    registrationDate: record.registrationDate || undefined,
    brotherCount: (record as PedigreeFormData).brotherCount || undefined,
    sisterCount: (record as PedigreeFormData).sisterCount || undefined,
    notes: (record as PedigreeFormData).notes || undefined,
    notes2: (record as PedigreeFormData).notes2 || undefined,
    otherNo: (record as PedigreeFormData).otherNo || undefined,
    fatherTitle: (record as PedigreeFormData).fatherTitle || undefined,
    fatherCatName: (record as PedigreeFormData).fatherCatName || undefined,
    fatherCatName2: (record as PedigreeFormData).fatherCatName2 || undefined,
    fatherCoatColor: (record as PedigreeFormData).fatherCoatColor || undefined,
    fatherEyeColor: (record as PedigreeFormData).fatherEyeColor || undefined,
    fatherJCU: (record as PedigreeFormData).fatherJCU || undefined,
    fatherOtherCode: (record as PedigreeFormData).fatherOtherCode || undefined,
    motherTitle: (record as PedigreeFormData).motherTitle || undefined,
    motherCatName: (record as PedigreeFormData).motherCatName || undefined,
    motherCatName2: (record as PedigreeFormData).motherCatName2 || undefined,
    motherCoatColor: (record as PedigreeFormData).motherCoatColor || undefined,
    motherEyeColor: (record as PedigreeFormData).motherEyeColor || undefined,
    motherJCU: (record as PedigreeFormData).motherJCU || undefined,
    motherOtherCode: (record as PedigreeFormData).motherOtherCode || undefined,
    ffTitle: (record as PedigreeFormData).ffTitle || undefined,
    ffCatName: (record as PedigreeFormData).ffCatName || undefined,
    ffCatColor: (record as PedigreeFormData).ffCatColor || undefined,
    ffjcu: (record as PedigreeFormData).ffjcu || undefined,
    fmTitle: (record as PedigreeFormData).fmTitle || undefined,
    fmCatName: (record as PedigreeFormData).fmCatName || undefined,
    fmCatColor: (record as PedigreeFormData).fmCatColor || undefined,
    fmjcu: (record as PedigreeFormData).fmjcu || undefined,
    mfTitle: (record as PedigreeFormData).mfTitle || undefined,
    mfCatName: (record as PedigreeFormData).mfCatName || undefined,
    mfCatColor: (record as PedigreeFormData).mfCatColor || undefined,
    mfjcu: (record as PedigreeFormData).mfjcu || undefined,
    mmTitle: (record as PedigreeFormData).mmTitle || undefined,
    mmCatName: (record as PedigreeFormData).mmCatName || undefined,
    mmCatColor: (record as PedigreeFormData).mmCatColor || undefined,
    mmjcu: (record as PedigreeFormData).mmjcu || undefined,
    fffTitle: (record as PedigreeFormData).fffTitle || undefined,
    fffCatName: (record as PedigreeFormData).fffCatName || undefined,
    fffCatColor: (record as PedigreeFormData).fffCatColor || undefined,
    fffjcu: (record as PedigreeFormData).fffjcu || undefined,
    ffmTitle: (record as PedigreeFormData).ffmTitle || undefined,
    ffmCatName: (record as PedigreeFormData).ffmCatName || undefined,
    ffmCatColor: (record as PedigreeFormData).ffmCatColor || undefined,
    ffmjcu: (record as PedigreeFormData).ffmjcu || undefined,
    fmfTitle: (record as PedigreeFormData).fmfTitle || undefined,
    fmfCatName: (record as PedigreeFormData).fmfCatName || undefined,
    fmfCatColor: (record as PedigreeFormData).fmfCatColor || undefined,
    fmfjcu: (record as PedigreeFormData).fmfjcu || undefined,
    fmmTitle: (record as PedigreeFormData).fmmTitle || undefined,
    fmmCatName: (record as PedigreeFormData).fmmCatName || undefined,
    fmmCatColor: (record as PedigreeFormData).fmmCatColor || undefined,
    fmmjcu: (record as PedigreeFormData).fmmjcu || undefined,
    mffTitle: (record as PedigreeFormData).mffTitle || undefined,
    mffCatName: (record as PedigreeFormData).mffCatName || undefined,
    mffCatColor: (record as PedigreeFormData).mffCatColor || undefined,
    mffjcu: (record as PedigreeFormData).mffjcu || undefined,
    mfmTitle: (record as PedigreeFormData).mfmTitle || undefined,
    mfmCatName: (record as PedigreeFormData).mfmCatName || undefined,
    mfmCatColor: (record as PedigreeFormData).mfmCatColor || undefined,
    mfmjcu: (record as PedigreeFormData).mfmjcu || undefined,
    mmfTitle: (record as PedigreeFormData).mmfTitle || undefined,
    mmfCatName: (record as PedigreeFormData).mmfCatName || undefined,
    mmfCatColor: (record as PedigreeFormData).mmfCatColor || undefined,
    mmfjcu: (record as PedigreeFormData).mmfjcu || undefined,
    mmmTitle: (record as PedigreeFormData).mmmTitle || undefined,
    mmmCatName: (record as PedigreeFormData).mmmCatName || undefined,
    mmmCatColor: (record as PedigreeFormData).mmmCatColor || undefined,
    mmmjcu: (record as PedigreeFormData).mmmjcu || undefined,
    oldCode: (record as PedigreeFormData).oldCode || undefined,
  };
}

export function PedigreeRegistrationForm({ onSuccess, onCancel }: PedigreeRegistrationFormProps) {
  const router = useRouter();
  const searchParams = useSearchParams();
  const apiBaseUrl = getPublicApiBaseUrl();
  const [mounted, setMounted] = useState(false);
  const [loading, setLoading] = useState(false);
  const [breeds, setBreeds] = useState<Breed[]>([]);
  const [coatColors, setCoatColors] = useState<CoatColor[]>([]);
  const [genders, setGenders] = useState<Gender[]>([]);
  const [formData, setFormData] = useState<PedigreeFormData>({
    pedigreeId: '',
  });
  const [isEditMode, setIsEditMode] = useState(false);
  const [originalId, setOriginalId] = useState<string | null>(null);
  const [pedigreeIdInput, setPedigreeIdInput] = useState('');

  const copyFromId = searchParams.get('copyFromId') || '';

  const normalizedPedigreeIdInput = pedigreeIdInput.trim();

  const createMutation = useCreatePedigree();
  const updateMutationHook = useUpdatePedigree(originalId || '');

  const { data: copySourcePedigree } = useGetPedigree(copyFromId, {
    enabled: !!copyFromId,
  });

  // åç§°å…¥åŠ›ç”¨ã®ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒ†ãƒ¼ãƒˆ (SelectåŒ–ã«ã‚ˆã‚Šç›´æ¥å‚ç…§ã¯ã—ãªã„ãŒã€çŠ¶æ…‹ç®¡ç†ç”¨ã«ä¿æŒ)
  const [_inputValues, setInputValues] = useState({
    breedName: '',
    genderName: '',
    coatColorName: '',
  });

  // ã‚³ãƒ¼ãƒ‰å¤‰æ›´æ™‚ã«åç§°ã‚’åŒæœŸ
  useEffect(() => {
    if (formData.breedCode !== undefined) {
      const found = breeds.find(b => b.code === formData.breedCode);
      if (found) setInputValues(prev => ({ ...prev, breedName: found.name }));
    }
    if (formData.genderCode !== undefined) {
      const found = genders.find(g => g.code === formData.genderCode);
      if (found) setInputValues(prev => ({ ...prev, genderName: found.name }));
    }
    if (formData.coatColorCode !== undefined) {
      const found = coatColors.find(c => c.code === formData.coatColorCode);
      if (found) setInputValues(prev => ({ ...prev, coatColorName: found.name }));
    }
  }, [formData.breedCode, formData.genderCode, formData.coatColorCode, breeds, genders, coatColors]);

  // Call IDç”¨ã®çŠ¶æ…‹
  const [callId, setCallId] = useState({
    both: '',
    father: '',
    mother: '',
  });

  // ãƒ‡ãƒã‚¦ãƒ³ã‚¹ç”¨ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
  const [searchTimeout, setSearchTimeout] = useState<NodeJS.Timeout | null>(null);

  // è¡€çµ±æ›¸ç•ªå·å…¥åŠ›æ™‚ã«æ—¢å­˜ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’å–å¾—
  const { data: existingPedigree, isLoading: isLoadingExisting } = useGetPedigreeByNumber(
    normalizedPedigreeIdInput,
    { enabled: normalizedPedigreeIdInput.length >= 5 }
  );

  // æ—¢å­˜ãƒ¬ã‚³ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã£ãŸå ´åˆã€å…¨ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ã‚»ãƒƒãƒˆ
  useEffect(() => {
    if (existingPedigree && pedigreeIdInput) {
      const record = existingPedigree as PedigreeRecord;
      setFormData(mapPedigreeRecordToFormData(record, pedigreeIdInput));
      setIsEditMode(true);
      setOriginalId(record.id);
      notifications.show({
        title: 'æ—¢å­˜ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ',
        message: `è¡€çµ±æ›¸ç•ªå· ${record.pedigreeId} ã®ãƒ‡ãƒ¼ã‚¿ã‚’ç·¨é›†ã§ãã¾ã™`,
        color: 'blue',
      });
    }
  }, [existingPedigree, pedigreeIdInput]);

  // ä¸€è¦§ã‹ã‚‰ã€Œæ–°è¦ç™»éŒ²ã«ã‚³ãƒ”ãƒ¼ã€ã•ã‚ŒãŸå ´åˆã€è¡€çµ±æ›¸ç•ªå·ã¨çŒ«åä»¥å¤–ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦æ–°è¦ç™»éŒ²ãƒ¢ãƒ¼ãƒ‰ã«ã™ã‚‹
  useEffect(() => {
    if (!copyFromId) return;
    if (!copySourcePedigree) return;

    const record = copySourcePedigree as PedigreeRecord;
    const copied = mapPedigreeRecordToFormData(record, '');

    setFormData({
      ...copied,
      pedigreeId: '',
      catName: undefined,
      catName2: undefined,
    });

    setPedigreeIdInput('');
    setIsEditMode(false);
    setOriginalId(null);
    setCallId({ both: '', father: '', mother: '' });
    setInputValues({ breedName: '', genderName: '', coatColorName: '' });

    notifications.show({
      title: 'æ–°è¦ç™»éŒ²ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ',
      message: 'è¡€çµ±æ›¸ç•ªå·ã¨çŒ«åä»¥å¤–ã®é …ç›®ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸã€‚è¡€çµ±æ›¸ç•ªå·ã¨çŒ«åã‚’å…¥åŠ›ã—ã¦ç™»éŒ²ã—ã¦ãã ã•ã„ã€‚',
      color: 'teal',
    });
  }, [copyFromId, copySourcePedigree]);

  // +ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯æ™‚ã«æœ€æ–°è¡€çµ±æ›¸ç•ªå·+1ã‚’å–å¾—
  const handleGetNextId = async () => {
    try {
      const response = await getNextPedigreeId();
      if (response.success && response.data?.nextId) {
        const nextId = response.data.nextId;
        setPedigreeIdInput(nextId);
        setFormData(prev => ({ ...prev, pedigreeId: nextId }));
        notifications.show({
          title: 'æœ€æ–°è¡€çµ±æ›¸ç•ªå·ã‚’å–å¾—ã—ã¾ã—ãŸ',
          message: `æ¬¡ã®ç•ªå·: ${nextId}`,
          color: 'teal',
        });
      }
    } catch (error: unknown) {
      console.error('æœ€æ–°è¡€çµ±æ›¸ç•ªå·ã®å–å¾—ã«å¤±æ•—:', error);
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: 'æœ€æ–°è¡€çµ±æ›¸ç•ªå·ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ',
        color: 'red',
      });
    }
  };

  useEffect(() => {
    setMounted(true);
    fetchMasterData();
  }, []);

  const fetchMasterData = async () => {
    try {
      // å“ç¨®
      const breedsRes = await getBreeds({ limit: '1000' });
      if (breedsRes.success && breedsRes.data) {
        setBreeds(breedsRes.data || []);
      }

      // æ¯›è‰²
      const colorsRes = await getCoatColors({ limit: '1000' });
      if (colorsRes.success && colorsRes.data) {
        setCoatColors(colorsRes.data || []);
      }

      // æ€§åˆ¥
      const gendersRes = await getGenders();
      if (gendersRes.success && gendersRes.data) {
        setGenders(gendersRes.data || []);
      }
    } catch (error) {
      console.error('ãƒã‚¹ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—:', error);
    }
  };

  // æ¯›è‰²ã‚³ãƒ¼ãƒ‰/æ–‡å­—åˆ—ã‹ã‚‰æ¯›è‰²åã‚’å–å¾—ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼
  const getCoatColorName = (codeOrName: number | string | undefined | null): string => {
    if (codeOrName === undefined || codeOrName === null || codeOrName === '') return '';

    // æ•°å€¤ã¾ãŸã¯æ•°å€¤ã®æ–‡å­—åˆ—ã®å ´åˆã€ã‚³ãƒ¼ãƒ‰ã¨ã—ã¦æ¤œç´¢
    const code = Number(codeOrName);
    if (!isNaN(code)) {
      const found = coatColors.find(c => c.code === code);
      return found ? found.name : codeOrName.toString();
    }

    // æ—¢ã«åå‰ã®å ´åˆã¯ãã®ã¾ã¾è¿”ã™
    return codeOrName.toString();
  };

  // Call ID: è¡€çµ±æ›¸ç•ªå·ã‹ã‚‰è¡€çµ±æƒ…å ±ã‚’å–å¾—ï¼ˆãƒ‡ãƒã‚¦ãƒ³ã‚¹ä»˜ãï¼‰
  const handleBothParentsCall = async (pedigreeNumber: string) => {
    if (searchTimeout) clearTimeout(searchTimeout);

    const timeout = setTimeout(async () => {
      if (!pedigreeNumber.trim() || pedigreeNumber.length < 5) return;

      try {
        const response = await apiClient.get('/pedigrees/pedigree-id/{pedigreeId}', {
          pathParams: { pedigreeId: pedigreeNumber },
        });

        if (response.success && response.data) {
          const data = response.data as PedigreeRecord;

          // çˆ¶è¦ªæƒ…å ±ã‚’è¨­å®šï¼ˆ7é …ç›®ï¼‰
          updateFormData('fatherTitle', (data as PedigreeFormData).fatherTitle);
          updateFormData('fatherCatName', (data as PedigreeFormData).fatherCatName);
          updateFormData('fatherCatName2', data.fatherCatName2);
          updateFormData('fatherCoatColor', data.fatherCoatColor);
          updateFormData('fatherEyeColor', data.fatherEyeColor);
          updateFormData('fatherJCU', data.fatherJCU);
          updateFormData('fatherOtherCode', data.fatherOtherCode);

          // æ¯è¦ªæƒ…å ±ã‚’è¨­å®šï¼ˆ7é …ç›®ï¼‰
          updateFormData('motherTitle', data.motherTitle);
          updateFormData('motherCatName', data.motherCatName);
          updateFormData('motherCatName2', data.motherCatName2);
          updateFormData('motherCoatColor', data.motherCoatColor);
          updateFormData('motherEyeColor', data.motherEyeColor);
          updateFormData('motherJCU', data.motherJCU);
          updateFormData('motherOtherCode', data.motherOtherCode);

          // ç¥–çˆ¶æ¯æƒ…å ±ã‚’è¨­å®šï¼ˆ16é …ç›®ï¼‰
          updateFormData('ffTitle', data.ffTitle);
          updateFormData('ffCatName', data.ffCatName);
          updateFormData('ffCatColor', data.ffCatColor);
          updateFormData('ffjcu', data.ffjcu);

          updateFormData('fmTitle', data.fmTitle);
          updateFormData('fmCatName', data.fmCatName);
          updateFormData('fmCatColor', data.fmCatColor);
          updateFormData('fmjcu', data.fmjcu);

          updateFormData('mfTitle', data.mfTitle);
          updateFormData('mfCatName', data.mfCatName);
          updateFormData('mfCatColor', data.mfCatColor);
          updateFormData('mfjcu', data.mfjcu);

          updateFormData('mmTitle', data.mmTitle);
          updateFormData('mmCatName', data.mmCatName);
          updateFormData('mmCatColor', data.mmCatColor);
          updateFormData('mmjcu', data.mmjcu);

          // æ›¾ç¥–çˆ¶æ¯æƒ…å ±ã‚’è¨­å®šï¼ˆ32é …ç›®ï¼‰
          updateFormData('fffTitle', data.fffTitle);
          updateFormData('fffCatName', data.fffCatName);
          updateFormData('fffCatColor', data.fffCatColor);
          updateFormData('fffjcu', data.fffjcu);

          updateFormData('ffmTitle', data.ffmTitle);
          updateFormData('ffmCatName', data.ffmCatName);
          updateFormData('ffmCatColor', data.ffmCatColor);
          updateFormData('ffmjcu', data.ffmjcu);

          updateFormData('fmfTitle', data.fmfTitle);
          updateFormData('fmfCatName', data.fmfCatName);
          updateFormData('fmfCatColor', data.fmfCatColor);
          updateFormData('fmfjcu', data.fmfjcu);

          updateFormData('fmmTitle', data.fmmTitle);
          updateFormData('fmmCatName', data.fmmCatName);
          updateFormData('fmmCatColor', data.fmmCatColor);
          updateFormData('fmmjcu', data.fmmjcu);

          updateFormData('mffTitle', data.mffTitle);
          updateFormData('mffCatName', data.mffCatName);
          updateFormData('mffCatColor', data.mffCatColor);
          updateFormData('mffjcu', data.mffjcu);

          updateFormData('mfmTitle', data.mfmTitle);
          updateFormData('mfmCatName', data.mfmCatName);
          updateFormData('mfmCatColor', data.mfmCatColor);
          updateFormData('mfmjcu', data.mfmjcu);

          updateFormData('mmfTitle', data.mmfTitle);
          updateFormData('mmfCatName', data.mmfCatName);
          updateFormData('mmfCatColor', data.mmfCatColor);
          updateFormData('mmfjcu', data.mmfjcu);

          updateFormData('mmmTitle', data.mmmTitle);
          updateFormData('mmmCatName', data.mmmCatName);
          updateFormData('mmmCatColor', data.mmmCatColor);
          updateFormData('mmmjcu', data.mmmjcu);

          notifications.show({
            title: 'ä¸¡è¦ªè¡€çµ±æƒ…å ±å–å¾—',
            message: `${data.catName}ã®è¡€çµ±æƒ…å ±ã‚’ä¸€æ‹¬å–å¾—ã—ã¾ã—ãŸï¼ˆ62é …ç›®ï¼‰`,
            color: 'green',
          });
        } else {
          notifications.show({
            title: 'æ¤œç´¢çµæœãªã—',
            message: `è¡€çµ±æ›¸ç•ªå· ${pedigreeNumber} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ`,
            color: 'yellow',
          });
        }
      } catch (error) {
        console.error('ä¸¡è¦ªè¡€çµ±æƒ…å ±ã®å–å¾—ã«å¤±æ•—:', error);
        notifications.show({
          title: 'ã‚¨ãƒ©ãƒ¼',
          message: 'è¡€çµ±æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ',
          color: 'red',
        });
      }
    }, 800);

    setSearchTimeout(timeout);
  };

  // Call ID: çˆ¶çŒ«IDã‹ã‚‰å–å¾—ï¼ˆçˆ¶+ç¥–çˆ¶æ¯16é …ç›®ï¼‰
  const handleFatherCall = async (pedigreeNumber: string) => {
    if (searchTimeout) clearTimeout(searchTimeout);

    const timeout = setTimeout(async () => {
      if (!pedigreeNumber.trim() || pedigreeNumber.length < 5) return;

      try {
        const response = await apiClient.get('/pedigrees/pedigree-id/{pedigreeId}', {
          pathParams: { pedigreeId: pedigreeNumber },
        });

        if (response.success && response.data) {
          const data = response.data as PedigreeRecord;

          // å–å¾—ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’PedigreeFormDataã¨ã—ã¦ã‚­ãƒ£ã‚¹ãƒˆ
          const source = data as unknown as PedigreeFormData;

          setFormData(prev => ({
            ...prev,
            // çˆ¶è¦ªæƒ…å ±ï¼ˆ7é …ç›®ï¼‰ <- æœ¬äººæƒ…å ±
            fatherTitle: source.title,
            fatherCatName: source.catName,
            fatherCoatColor: getCoatColorName(source.coatColorCode),
            fatherEyeColor: source.eyeColor,
            fatherJCU: source.pedigreeId,
            fatherOtherCode: source.otherNo, // PedigreeRecordã«ã¯ãªã„ã‹ã‚‚ã—ã‚Œãªã„ãŒFormDataã«ã¯ã‚ã‚‹å¯èƒ½æ€§

            // çˆ¶æ–¹ç¥–çˆ¶ï¼ˆFFï¼‰ <- æœ¬äººã®çˆ¶
            ffTitle: source.fatherTitle,
            ffCatName: source.fatherCatName,
            ffCatColor: getCoatColorName(source.fatherCoatColor),
            ffjcu: source.fatherJCU,

            // çˆ¶æ–¹ç¥–æ¯ï¼ˆFMï¼‰ <- æœ¬äººã®æ¯
            fmTitle: source.motherTitle,
            fmCatName: source.motherCatName,
            fmCatColor: getCoatColorName(source.motherCoatColor),
            fmjcu: source.motherJCU,

            // çˆ¶æ–¹æ›¾ç¥–çˆ¶ï¼ˆFFFï¼‰ <- æœ¬äººã®çˆ¶æ–¹ç¥–çˆ¶
            fffTitle: source.ffTitle,
            fffCatName: source.ffCatName,
            fffCatColor: getCoatColorName(source.ffCatColor),
            fffjcu: source.ffjcu,

            // çˆ¶æ–¹æ›¾ç¥–æ¯ï¼ˆFFMï¼‰ <- æœ¬äººã®çˆ¶æ–¹ç¥–æ¯
            ffmTitle: source.fmTitle,
            ffmCatName: source.fmCatName,
            ffmCatColor: getCoatColorName(source.fmCatColor),
            ffmjcu: source.fmjcu,

            // çˆ¶æ–¹æ¯æ–¹ç¥–çˆ¶ï¼ˆFMFï¼‰ <- æœ¬äººã®æ¯æ–¹ç¥–çˆ¶
            fmfTitle: source.mfTitle,
            fmfCatName: source.mfCatName,
            fmfCatColor: getCoatColorName(source.mfCatColor),
            fmfjcu: source.mfjcu,

            // çˆ¶æ–¹æ¯æ–¹ç¥–æ¯ï¼ˆFMMï¼‰ <- æœ¬äººã®æ¯æ–¹ç¥–æ¯
            fmmTitle: source.mmTitle,
            fmmCatName: source.mmCatName,
            fmmCatColor: getCoatColorName(source.mmCatColor),
            fmmjcu: source.mmjcu,
          }));

          notifications.show({
            title: 'çˆ¶çŒ«è¡€çµ±æƒ…å ±å–å¾—',
            message: `${data.catName}ã®è¡€çµ±æƒ…å ±ã‚’å–å¾—ã—ã€çˆ¶æ–¹å®¶ç³»å›³ã«åæ˜ ã—ã¾ã—ãŸ`,
            color: 'blue',
          });
        }
      } catch (error) {
        console.error('çˆ¶çŒ«è¡€çµ±æƒ…å ±ã®å–å¾—ã«å¤±æ•—:', error);
      }
    }, 800);

    setSearchTimeout(timeout);
  };

  // Call ID: æ¯çŒ«IDã‹ã‚‰å–å¾—ï¼ˆæ¯+ç¥–çˆ¶æ¯16é …ç›®ï¼‰
  const handleMotherCall = async (pedigreeNumber: string) => {
    if (searchTimeout) clearTimeout(searchTimeout);

    const timeout = setTimeout(async () => {
      if (!pedigreeNumber.trim() || pedigreeNumber.length < 5) return;

      try {
        const response = await apiClient.get('/pedigrees/pedigree-id/{pedigreeId}', {
          pathParams: { pedigreeId: pedigreeNumber },
        });

        if (response.success && response.data) {
          const data = response.data as PedigreeRecord;

          // å–å¾—ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’PedigreeFormDataã¨ã—ã¦ã‚­ãƒ£ã‚¹ãƒˆ
          const source = data as unknown as PedigreeFormData;

          setFormData(prev => ({
            ...prev,
            // æ¯è¦ªæƒ…å ±ï¼ˆ7é …ç›®ï¼‰ <- æœ¬äººæƒ…å ±
            motherTitle: source.title,
            motherCatName: source.catName,
            motherCoatColor: getCoatColorName(source.coatColorCode),
            motherEyeColor: source.eyeColor,
            motherJCU: source.pedigreeId,
            motherOtherCode: source.otherNo, // PedigreeRecordã«ã¯ãªã„ã‹ã‚‚ã—ã‚Œãªã„ãŒFormDataã«ã¯ã‚ã‚‹å¯èƒ½æ€§

            // æ¯æ–¹ç¥–çˆ¶ï¼ˆMFï¼‰ <- æœ¬äººã®çˆ¶
            mfTitle: source.fatherTitle,
            mfCatName: source.fatherCatName,
            mfCatColor: getCoatColorName(source.fatherCoatColor),
            mfjcu: source.fatherJCU,

            // æ¯æ–¹ç¥–æ¯ï¼ˆMMï¼‰ <- æœ¬äººã®æ¯
            mmTitle: source.motherTitle,
            mmCatName: source.motherCatName,
            mmCatColor: getCoatColorName(source.motherCoatColor),
            mmjcu: source.motherJCU,

            // æ¯æ–¹æ›¾ç¥–çˆ¶ï¼ˆMFFï¼‰ <- æœ¬äººã®çˆ¶æ–¹ç¥–çˆ¶
            mffTitle: source.ffTitle,
            mffCatName: source.ffCatName,
            mffCatColor: getCoatColorName(source.ffCatColor),
            mffjcu: source.ffjcu,

            // æ¯æ–¹æ›¾ç¥–æ¯ï¼ˆMFMï¼‰ <- æœ¬äººã®çˆ¶æ–¹ç¥–æ¯
            mfmTitle: source.fmTitle,
            mfmCatName: source.fmCatName,
            mfmCatColor: getCoatColorName(source.fmCatColor),
            mfmjcu: source.fmjcu,

            // æ¯æ–¹æ¯æ–¹ç¥–çˆ¶ï¼ˆMMFï¼‰ <- æœ¬äººã®æ¯æ–¹ç¥–çˆ¶
            mmfTitle: source.mfTitle,
            mmfCatName: source.mfCatName,
            mmfCatColor: getCoatColorName(source.mfCatColor),
            mmfjcu: source.mfjcu,

            // æ¯æ–¹æ¯æ–¹ç¥–æ¯ï¼ˆMMMï¼‰ <- æœ¬äººã®æ¯æ–¹ç¥–æ¯
            mmmTitle: source.mmTitle,
            mmmCatName: source.mmCatName,
            mmmCatColor: getCoatColorName(source.mmCatColor),
            mmmjcu: source.mmjcu,
          }));

          notifications.show({
            title: 'æ¯çŒ«è¡€çµ±æƒ…å ±å–å¾—',
            message: `${data.catName}ã®è¡€çµ±æƒ…å ±ã‚’å–å¾—ã—ã€æ¯æ–¹å®¶ç³»å›³ã«åæ˜ ã—ã¾ã—ãŸ`,
            color: 'pink',
          });
        }
      } catch (error) {
        console.error('æ¯çŒ«è¡€çµ±æƒ…å ±ã®å–å¾—ã«å¤±æ•—:', error);
      }
    }, 800);

    setSearchTimeout(timeout);
  };

  // ãƒ•ã‚©ãƒ¼ãƒ é€ä¿¡ï¼ˆæ–°è¦ç™»éŒ²ï¼‰
  const handleCreate = async () => {
    setLoading(true);

    try {
      // å¿…é ˆãƒã‚§ãƒƒã‚¯
      if (!formData.pedigreeId.trim()) {
        notifications.show({
          title: 'ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼',
          message: 'è¡€çµ±æ›¸ç•ªå·ã¯å¿…é ˆã§ã™',
          color: 'red',
        });
        setLoading(false);
        return;
      }

      // æ–°è¦ç™»éŒ²
      await createMutation.mutateAsync(formData as Parameters<typeof createMutation.mutateAsync>[0]);

      if (onSuccess) {
        onSuccess();
      } else {
        router.push('/pedigrees?tab=list');
      }
    } catch (error) {
      console.error('ç™»éŒ²ã‚¨ãƒ©ãƒ¼:', error);
    } finally {
      setLoading(false);
    }
  };

  // ãƒ•ã‚©ãƒ¼ãƒ é€ä¿¡ï¼ˆæ›´æ–°ï¼‰
  const handleUpdate = async () => {
    setLoading(true);

    try {
      if (!originalId) {
        notifications.show({
          title: 'ã‚¨ãƒ©ãƒ¼',
          message: 'æ›´æ–°å¯¾è±¡ã®IDãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“',
          color: 'red',
        });
        setLoading(false);
        return;
      }

      // UpdatePedigreeRequestã¯è¡€çµ±æ›¸ç•ªå·ã‚’é™¤ãå…¨ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
      const { pedigreeId: _pedigreeId, ...updateData } = formData;
      await updateMutationHook.mutateAsync(updateData as UpdatePedigreeRequest);

      if (onSuccess) {
        onSuccess();
      } else {
        router.push('/pedigrees?tab=list');
      }
    } catch (error: unknown) {
      console.error('æ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
    } finally {
      setLoading(false);
    }
  };

  // ãƒ•ã‚©ãƒ¼ãƒ ã‚¯ãƒªã‚¢
  const handleClear = () => {
    setFormData({ pedigreeId: '' });
    setPedigreeIdInput('');
    setIsEditMode(false);
    setOriginalId(null);
    setCallId({ both: '', father: '', mother: '' });
    setInputValues({ breedName: '', genderName: '', coatColorName: '' });
    notifications.show({
      title: 'ãƒ•ã‚©ãƒ¼ãƒ ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ',
      message: 'æ–°è¦ç™»éŒ²ãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã‚Šã¾ã—ãŸ',
      color: 'blue',
    });
  };

  // ãƒ•ã‚©ãƒ¼ãƒ é€ä¿¡ï¼ˆæ—§å®Ÿè£…ã¨ã®äº’æ›æ€§ç¶­æŒï¼‰
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (isEditMode) {
      await handleUpdate();
    } else {
      await handleCreate();
    }
  };

  const updateFormData = (field: keyof PedigreeFormData, value: unknown) => {
    setFormData(prev => ({ ...prev, [field]: value }));
  };

  // JCUãƒŠãƒ³ãƒãƒ¼ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
  const duplicateJcus = useMemo(() => {
    const jcuFields = [
      formData.fatherJCU, formData.motherJCU,
      formData.ffjcu, formData.fmjcu, formData.mfjcu, formData.mmjcu,
      formData.fffjcu, formData.ffmjcu, formData.fmfjcu, formData.fmmjcu,
      formData.mffjcu, formData.mfmjcu, formData.mmfjcu, formData.mmmjcu
    ];

    // ç©ºæ–‡å­—ãƒ»undefinedãƒ»nullã‚’é™¤å¤–ã—ã¦æ­£è¦åŒ–
    const normalizedJcus = jcuFields
      .map(jcu => jcu?.trim())
      .filter((jcu): jcu is string => !!jcu && jcu.length > 0);

    const counts: Record<string, number> = {};
    normalizedJcus.forEach(jcu => {
      counts[jcu] = (counts[jcu] || 0) + 1;
    });

    const duplicates = new Set<string>();
    Object.entries(counts).forEach(([jcu, count]) => {
      if (count > 1) duplicates.add(jcu);
    });

    return duplicates;
  }, [
    formData.fatherJCU, formData.motherJCU,
    formData.ffjcu, formData.fmjcu, formData.mfjcu, formData.mmjcu,
    formData.fffjcu, formData.ffmjcu, formData.fmfjcu, formData.fmmjcu,
    formData.mffjcu, formData.mfmjcu, formData.mmfjcu, formData.mmmjcu
  ]);

  // é‡è¤‡æ™‚ã®ã‚¹ã‚¿ã‚¤ãƒ«å®šç¾©
  const duplicateStyle = { input: { color: '#00BFFF', fontWeight: 'bold' } };

  // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒé‡è¤‡ã—ã¦ã„ã‚‹ã‹åˆ¤å®šã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼
  const isDuplicate = (value: string | undefined) => {
    return value && duplicateJcus.has(value.trim());
  };

  const openPedigreePdf = (pedigreeId: string) => {
    const pdfUrl = `${apiBaseUrl}/pedigrees/pedigree-id/${encodeURIComponent(pedigreeId)}/pdf`;
    const newTab = window.open(pdfUrl, '_blank');
    if (!newTab) {
      window.location.assign(pdfUrl);
    }
  };

  // ã‚³ãƒ¼ãƒ‰ã¨åç§°ã®åŒæœŸãƒ­ã‚¸ãƒƒã‚¯ (SelectåŒ–ã«ã‚ˆã‚Šä¸è¦ã«ãªã£ãŸãŸã‚å‰Šé™¤æ¸ˆã¿)

  // åç§°è§£æ±ºãƒ˜ãƒ«ãƒ‘ãƒ¼ (å‰Šé™¤äºˆå®šã ãŒã€ä»–ã®ç®‡æ‰€ã§ä½¿ã‚ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ç¢ºèª)
  // const getBreedName = ... 
  // ä»Šå›ã®æ”¹ä¿®ã§ inputValues ã«ç½®ãæ›ã‚ã£ãŸãŸã‚å‰Šé™¤ã—ã¾ã™ã€‚

  if (!mounted) return null;

  return (
    <Box>
      <form onSubmit={handleSubmit}>
        <Stack gap="lg">
          {/* åŸºæœ¬æƒ…å ±ï¼ˆ17é …ç›®ï¼‰*/}
          <Paper p="lg" withBorder>
            <Grid gutter={10}>
              {/* Row 1: +ãƒœã‚¿ãƒ³, è¡€çµ±æ›¸ç•ªå·ï¼ˆ2åˆ—ï¼‰ */}
              <Grid.Col span={12}>
                <Group wrap="nowrap" gap="xs">
                  <Tooltip label="æ¬¡ã®è¡€çµ±æ›¸ç•ªå·ã‚’è‡ªå‹•å–å¾—">
                    <ActionIcon variant="filled" color="blue" size="lg" onClick={handleGetNextId} style={{ height: 36 }}>
                      <IconPlus size={18} />
                    </ActionIcon>
                  </Tooltip>
                  <Tooltip label={isEditMode ? 'è¡€çµ±æ›¸PDFã‚’å°åˆ·' : 'ç™»éŒ²æ¸ˆã¿ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€ã¨å°åˆ·ã§ãã¾ã™'}>
                    <ActionIcon
                      variant="light"
                      color="orange"
                      size="lg"
                      disabled={!isEditMode || !formData.pedigreeId.trim()}
                      onClick={() => {
                        if (!isEditMode) return;
                        const id = formData.pedigreeId.trim();
                        if (!id) return;
                        openPedigreePdf(id);
                      }}
                      style={{ height: 36 }}
                    >
                      <IconPrinter size={18} />
                    </ActionIcon>
                  </Tooltip>
                  <InputWithFloatingLabel
                    label="è¡€çµ±æ›¸ç•ªå·"
                    required
                    value={pedigreeIdInput}
                    onChange={(e) => {
                      setPedigreeIdInput(e.target.value);
                      updateFormData('pedigreeId', e.target.value);
                    }}
                    rightSection={isLoadingExisting ? <Text size="xs">èª­è¾¼ä¸­...</Text> : undefined}
                    style={{ flex: 1 }}
                  />
                </Group>
              </Grid.Col>

              {/* Row 2: ã‚­ãƒ£ãƒƒãƒ†ãƒªãƒ¼å, çŒ«ã®åå‰ï¼ˆ2åˆ—ï¼‰ */}
              <Grid.Col span={{ base: 6, md: 4 }}>
                <InputWithFloatingLabel
                  label="ã‚­ãƒ£ãƒƒãƒ†ãƒªãƒ¼å"
                  value={formData.catName2}
                  onChange={(e) => updateFormData('catName2', e.target.value)}
                />
              </Grid.Col>
              <Grid.Col span={{ base: 6, md: 4 }}>
                <InputWithFloatingLabel
                  label="çŒ«ã®åå‰"
                  value={formData.catName}
                  onChange={(e) => updateFormData('catName', e.target.value)}
                />
              </Grid.Col>

              {/* Row 3: å“ç¨®ï¼ˆã‚³ãƒ¼ãƒ‰+åå‰çµ±åˆï¼‰ã€æ¯›è‰²ï¼ˆã‚³ãƒ¼ãƒ‰+åå‰çµ±åˆï¼‰ - 2ã‚«ãƒ©ãƒ ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ– */}
              <Grid.Col span={{ base: 12, sm: 6, md: 4 }}>
                <SelectWithFloatingLabel
                  label="å“ç¨®ã‚’é¸æŠ"
                  data={breeds.map(b => ({ value: b.code.toString(), label: `${b.code} - ${b.name}` }))}
                  value={formData.breedCode?.toString() || null}
                  onChange={(value) => {
                    if (value) {
                      const code = parseInt(value, 10);
                      updateFormData('breedCode', code);
                      const found = breeds.find(b => b.code === code);
                      setInputValues(prev => ({ ...prev, breedName: found?.name || '' }));
                    } else {
                      updateFormData('breedCode', undefined);
                      setInputValues(prev => ({ ...prev, breedName: '' }));
                    }
                  }}
                  searchable
                  clearable
                  nothingFoundMessage="è©²å½“ã™ã‚‹å“ç¨®ãŒã‚ã‚Šã¾ã›ã‚“"
                />
              </Grid.Col>
              <Grid.Col span={{ base: 12, sm: 6, md: 4 }}>
                <SelectWithFloatingLabel
                  label="æ¯›è‰²ã‚’é¸æŠ"
                  data={coatColors.map(c => ({ value: c.code.toString(), label: `${c.code} - ${c.name}` }))}
                  value={formData.coatColorCode?.toString() || null}
                  onChange={(value) => {
                    if (value) {
                      const code = parseInt(value, 10);
                      updateFormData('coatColorCode', code);
                      const found = coatColors.find(c => c.code === code);
                      setInputValues(prev => ({ ...prev, coatColorName: found?.name || '' }));
                    } else {
                      updateFormData('coatColorCode', undefined);
                      setInputValues(prev => ({ ...prev, coatColorName: '' }));
                    }
                  }}
                  searchable
                  clearable
                  nothingFoundMessage="è©²å½“ã™ã‚‹æ¯›è‰²ãŒã‚ã‚Šã¾ã›ã‚“"
                />
              </Grid.Col>

              {/* Row 4: æ€§åˆ¥ï¼ˆã‚³ãƒ¼ãƒ‰+åå‰çµ±åˆï¼‰ã€ç›®ã®è‰² - 2ã‚«ãƒ©ãƒ ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ– */}
              <Grid.Col span={{ base: 6, sm: 4, md: 2 }}>
                <SelectWithFloatingLabel
                  label="æ€§åˆ¥ã‚’é¸æŠ"
                  data={genders.map(g => ({ value: g.code.toString(), label: `${g.code} - ${g.name}` }))}
                  value={formData.genderCode?.toString() || null}
                  onChange={(value) => {
                    if (value) {
                      const code = parseInt(value, 10);
                      updateFormData('genderCode', code);
                      const found = genders.find(g => g.code === code);
                      setInputValues(prev => ({ ...prev, genderName: found?.name || '' }));
                    } else {
                      updateFormData('genderCode', undefined);
                      setInputValues(prev => ({ ...prev, genderName: '' }));
                    }
                  }}
                  clearable
                  nothingFoundMessage="è©²å½“ã™ã‚‹æ€§åˆ¥ãŒã‚ã‚Šã¾ã›ã‚“"
                />
              </Grid.Col>

              {/* Row 6: ç›®ã®è‰², ç”Ÿå¹´æœˆæ—¥, ç™»éŒ²å¹´æœˆæ—¥ï¼ˆ3åˆ—å‡ç­‰ï¼‰ */}
              <Grid.Col span={{ base: 4, md: 3 }}>
                <InputWithFloatingLabel
                  label="ç›®ã®è‰²"
                  value={formData.eyeColor}
                  onChange={(e) => updateFormData('eyeColor', e.target.value)}
                />
              </Grid.Col>
              <Grid.Col span={{ base: 4, md: 3 }}>
                <InputWithFloatingLabel
                  label="ç”Ÿå¹´æœˆæ—¥"
                  value={formData.birthDate}
                  onChange={(e) => updateFormData('birthDate', e.target.value)}
                />
              </Grid.Col>
              <Grid.Col span={{ base: 4, md: 3 }}>
                <InputWithFloatingLabel
                  label="ç™»éŒ²å¹´æœˆæ—¥"
                  value={formData.registrationDate}
                  onChange={(e) => updateFormData('registrationDate', e.target.value)}
                />
              </Grid.Col>

              {/* Row 7: ãƒ–ãƒªãƒ¼ãƒ€ãƒ¼å, ã‚ªãƒ¼ãƒŠãƒ¼åï¼ˆ2åˆ—ï¼‰ */}
              <Grid.Col span={{ base: 6, md: 4 }}>
                <InputWithFloatingLabel
                  label="ãƒ–ãƒªãƒ¼ãƒ€ãƒ¼å"
                  value={formData.breederName}
                  onChange={(e) => updateFormData('breederName', e.target.value)}
                />
              </Grid.Col>
              <Grid.Col span={{ base: 6, md: 4 }}>
                <InputWithFloatingLabel
                  label="ã‚ªãƒ¼ãƒŠãƒ¼å"
                  value={formData.ownerName}
                  onChange={(e) => updateFormData('ownerName', e.target.value)}
                />
              </Grid.Col>

              {/* Row 8: å…„å¼Ÿ, å§‰å¦¹, ã‚¿ã‚¤ãƒˆãƒ«, ä»–å›£ä½“Noï¼ˆ4åˆ—ï¼‰ */}
              <Grid.Col span={{ base: 3, md: 1 }}>
                <InputWithFloatingLabel
                  label="å…„å¼Ÿ"
                  type="number"
                  value={formData.brotherCount?.toString()}
                  onChange={(e) => updateFormData('brotherCount', parseInt(e.target.value) || undefined)}
                />
              </Grid.Col>
              <Grid.Col span={{ base: 3, md: 1 }}>
                <InputWithFloatingLabel
                  label="å§‰å¦¹"
                  type="number"
                  value={formData.sisterCount?.toString()}
                  onChange={(e) => updateFormData('sisterCount', parseInt(e.target.value) || undefined)}
                />
              </Grid.Col>
              <Grid.Col span={{ base: 3, md: 3 }}>
                <InputWithFloatingLabel
                  label="ã‚¿ã‚¤ãƒˆãƒ«"
                  value={formData.title}
                  onChange={(e) => updateFormData('title', e.target.value)}
                />
              </Grid.Col>
              <Grid.Col span={{ base: 3, md: 4 }}>
                <InputWithFloatingLabel
                  label="ä»–å›£ä½“No"
                  value={formData.otherNo}
                  onChange={(e) => updateFormData('otherNo', e.target.value)}
                />
              </Grid.Col>

              {/* Row 9: å‚™è€ƒ, å‚™è€ƒ2ï¼ˆ2åˆ—ï¼‰ */}
              <Grid.Col span={{ base: 6, md: 5 }}>
                <InputWithFloatingLabel
                  label="å‚™è€ƒ"
                  value={formData.notes}
                  onChange={(e) => updateFormData('notes', e.target.value)}
                />
              </Grid.Col>
              <Grid.Col span={{ base: 6, md: 5 }}>
                <InputWithFloatingLabel
                  label="å‚™è€ƒï¼’"
                  value={formData.notes2}
                  onChange={(e) => updateFormData('notes2', e.target.value)}
                />
              </Grid.Col>
            </Grid>
          </Paper>

          {/* Call ID */}
          <Paper p="lg" withBorder>
            <Grid gutter={10}>
              <Grid.Col span={12}><Divider label="Call ID" /></Grid.Col>
              <Grid.Col span={{ base: 12, md: 4 }}>
                <InputWithFloatingLabel
                  label="ä¸¡è¦ªID"
                  value={callId.both}
                  onChange={(e) => {
                    setCallId(prev => ({ ...prev, both: e.target.value }));
                    handleBothParentsCall(e.target.value);
                  }}
                />
              </Grid.Col>
              <Grid.Col span={{ base: 12, md: 4 }}>
                <InputWithFloatingLabel
                  label="çˆ¶çŒ«ID"
                  value={callId.father}
                  onChange={(e) => {
                    setCallId(prev => ({ ...prev, father: e.target.value }));
                    handleFatherCall(e.target.value);
                  }}
                />
              </Grid.Col>
              <Grid.Col span={{ base: 12, md: 4 }}>
                <InputWithFloatingLabel
                  label="æ¯çŒ«ID"
                  value={callId.mother}
                  onChange={(e) => {
                    setCallId(prev => ({ ...prev, mother: e.target.value }));
                    handleMotherCall(e.target.value);
                  }}
                />
              </Grid.Col>
            </Grid>
          </Paper>

          {/* è¡€çµ±æƒ…å ±ï¼ˆ62é …ç›®ï¼‰*/}
          <Paper p="lg" withBorder>
            <Stack gap="lg">
              {/* ç¬¬1ä¸–ä»£: ä¸¡è¦ªï¼ˆ14é …ç›®ï¼‰*/}
              <Box>
                <Divider label="ç¬¬1ä¸–ä»£: ä¸¡è¦ªï¼ˆ14é …ç›®ï¼‰" mb="md" />
                <Grid gutter={10}>
                  <Grid.Col span={12}><Divider label="çˆ¶è¦ªï¼ˆ7é …ç›®ï¼‰" /></Grid.Col>
                  <Grid.Col span={{ base: 6, sm: 3 }}>
                    <InputWithFloatingLabel label="çˆ¶è¦ªã‚¿ã‚¤ãƒˆãƒ«" value={formData.fatherTitle} onChange={(e) => updateFormData('fatherTitle', e.target.value)} />
                  </Grid.Col>
                  <Grid.Col span={{ base: 6, sm: 3 }}>
                    <InputWithFloatingLabel label="çˆ¶è¦ªå" value={formData.fatherCatName} onChange={(e) => updateFormData('fatherCatName', e.target.value)} />
                  </Grid.Col>
                  <Grid.Col span={{ base: 6, sm: 3 }}>
                    <InputWithFloatingLabel label="çˆ¶è¦ªæ¯›è‰²" value={formData.fatherCoatColor} onChange={(e) => updateFormData('fatherCoatColor', e.target.value)} />
                  </Grid.Col>
                  <Grid.Col span={{ base: 6, sm: 3 }}>
                    <InputWithFloatingLabel label="çˆ¶è¦ªç›®ã®è‰²" value={formData.fatherEyeColor} onChange={(e) => updateFormData('fatherEyeColor', e.target.value)} />
                  </Grid.Col>
                  <Grid.Col span={{ base: 6, sm: 3 }}>
                    <InputWithFloatingLabel
                      label="çˆ¶è¦ªJCU"
                      value={formData.fatherJCU}
                      onChange={(e) => updateFormData('fatherJCU', e.target.value)}
                      styles={isDuplicate(formData.fatherJCU) ? duplicateStyle : undefined}
                    />
                  </Grid.Col>
                  <Grid.Col span={{ base: 6, sm: 3 }}>
                    <InputWithFloatingLabel label="çˆ¶è¦ªä»–å›£ä½“ã‚³ãƒ¼ãƒ‰" value={formData.fatherOtherCode} onChange={(e) => updateFormData('fatherOtherCode', e.target.value)} />
                  </Grid.Col>

                  <Grid.Col span={12}><Divider label="æ¯è¦ªï¼ˆ7é …ç›®ï¼‰" /></Grid.Col>
                  <Grid.Col span={{ base: 6, sm: 3 }}>
                    <InputWithFloatingLabel label="æ¯è¦ªã‚¿ã‚¤ãƒˆãƒ«" value={formData.motherTitle} onChange={(e) => updateFormData('motherTitle', e.target.value)} />
                  </Grid.Col>
                  <Grid.Col span={{ base: 6, sm: 3 }}>
                    <InputWithFloatingLabel label="æ¯è¦ªå" value={formData.motherCatName} onChange={(e) => updateFormData('motherCatName', e.target.value)} />
                  </Grid.Col>
                  <Grid.Col span={{ base: 6, sm: 3 }}>
                    <InputWithFloatingLabel label="æ¯è¦ªæ¯›è‰²" value={formData.motherCoatColor} onChange={(e) => updateFormData('motherCoatColor', e.target.value)} />
                  </Grid.Col>
                  <Grid.Col span={{ base: 6, sm: 3 }}>
                    <InputWithFloatingLabel label="æ¯è¦ªç›®ã®è‰²" value={formData.motherEyeColor} onChange={(e) => updateFormData('motherEyeColor', e.target.value)} />
                  </Grid.Col>
                  <Grid.Col span={{ base: 6, sm: 3 }}>
                    <InputWithFloatingLabel
                      label="æ¯è¦ªJCU"
                      value={formData.motherJCU}
                      onChange={(e) => updateFormData('motherJCU', e.target.value)}
                      styles={isDuplicate(formData.motherJCU) ? duplicateStyle : undefined}
                    />
                  </Grid.Col>
                  <Grid.Col span={{ base: 6, sm: 3 }}>
                    <InputWithFloatingLabel label="æ¯è¦ªä»–å›£ä½“ã‚³ãƒ¼ãƒ‰" value={formData.motherOtherCode} onChange={(e) => updateFormData('motherOtherCode', e.target.value)} />
                  </Grid.Col>
                </Grid>
              </Box>

              {/* ç¬¬2ä¸–ä»£: ç¥–çˆ¶æ¯ï¼ˆ16é …ç›®ï¼‰*/}
              <Box>
                <Divider label="ç¬¬2ä¸–ä»£: ç¥–çˆ¶æ¯ï¼ˆ16é …ç›®ï¼‰" mb="md" />
                <Grid gutter={10}>
                  {/* FF */}
                  <Grid.Col span={12}><Divider label="çˆ¶æ–¹ç¥–çˆ¶ï¼ˆ4é …ç›®ï¼‰" /></Grid.Col>

                  <Grid.Col span={{ base: 12, sm: 3 }}><InputWithFloatingLabel label="FFã‚¿ã‚¤ãƒˆãƒ«" value={formData.ffTitle} onChange={(e) => updateFormData('ffTitle', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 3 }}><InputWithFloatingLabel label="FFåå‰" value={formData.ffCatName} onChange={(e) => updateFormData('ffCatName', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 3 }}><InputWithFloatingLabel label="FFè‰²æŸ„" value={formData.ffCatColor} onChange={(e) => updateFormData('ffCatColor', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 3 }}>
                    <InputWithFloatingLabel
                      label="FFãƒŠãƒ³ãƒãƒ¼"
                      value={formData.ffjcu}
                      onChange={(e) => updateFormData('ffjcu', e.target.value)}
                      styles={isDuplicate(formData.ffjcu) ? duplicateStyle : undefined}
                    />
                  </Grid.Col>

                  <Grid.Col span={12}><Divider label="çˆ¶æ–¹ç¥–æ¯ï¼ˆ4é …ç›®ï¼‰" /></Grid.Col>
                  <Grid.Col span={{ base: 6, sm: 3 }}><InputWithFloatingLabel label="FMã‚¿ã‚¤ãƒˆãƒ«" value={formData.fmTitle} onChange={(e) => updateFormData('fmTitle', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 6, sm: 3 }}><InputWithFloatingLabel label="FMåå‰" value={formData.fmCatName} onChange={(e) => updateFormData('fmCatName', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 6, sm: 3 }}><InputWithFloatingLabel label="FMè‰²æŸ„" value={formData.fmCatColor} onChange={(e) => updateFormData('fmCatColor', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 6, sm: 3 }}>
                    <InputWithFloatingLabel
                      label="FMãƒŠãƒ³ãƒãƒ¼"
                      value={formData.fmjcu}
                      onChange={(e) => updateFormData('fmjcu', e.target.value)}
                      styles={isDuplicate(formData.fmjcu) ? duplicateStyle : undefined}
                    />
                  </Grid.Col>

                  {/* MF */}
                  <Grid.Col span={12}><Divider label="æ¯æ–¹ç¥–çˆ¶ï¼ˆ4é …ç›®ï¼‰" /></Grid.Col>

                  <Grid.Col span={{ base: 12, sm: 3 }}><InputWithFloatingLabel label="MFã‚¿ã‚¤ãƒˆãƒ«" value={formData.mfTitle} onChange={(e) => updateFormData('mfTitle', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 3 }}><InputWithFloatingLabel label="MFåå‰" value={formData.mfCatName} onChange={(e) => updateFormData('mfCatName', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 3 }}><InputWithFloatingLabel label="MFè‰²æŸ„" value={formData.mfCatColor} onChange={(e) => updateFormData('mfCatColor', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 3 }}>
                    <InputWithFloatingLabel
                      label="MFãƒŠãƒ³ãƒãƒ¼"
                      value={formData.mfjcu}
                      onChange={(e) => updateFormData('mfjcu', e.target.value)}
                      styles={isDuplicate(formData.mfjcu) ? duplicateStyle : undefined}
                    />
                  </Grid.Col>

                  <Grid.Col span={12}><Divider label="æ¯æ–¹ç¥–æ¯ï¼ˆ4é …ç›®ï¼‰" /></Grid.Col>
                  <Grid.Col span={{ base: 6, sm: 3 }}><InputWithFloatingLabel label="MMã‚¿ã‚¤ãƒˆãƒ«" value={formData.mmTitle} onChange={(e) => updateFormData('mmTitle', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 6, sm: 3 }}><InputWithFloatingLabel label="MMåå‰" value={formData.mmCatName} onChange={(e) => updateFormData('mmCatName', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 6, sm: 3 }}><InputWithFloatingLabel label="MMè‰²æŸ„" value={formData.mmCatColor} onChange={(e) => updateFormData('mmCatColor', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 6, sm: 3 }}>
                    <InputWithFloatingLabel
                      label="MMãƒŠãƒ³ãƒãƒ¼"
                      value={formData.mmjcu}
                      onChange={(e) => updateFormData('mmjcu', e.target.value)}
                      styles={isDuplicate(formData.mmjcu) ? duplicateStyle : undefined}
                    />
                  </Grid.Col>
                </Grid>
              </Box>

              {/* ç¬¬3ä¸–ä»£: æ›¾ç¥–çˆ¶æ¯ï¼ˆ32é …ç›®ï¼‰*/}
              <Box>
                <Divider label="ç¬¬3ä¸–ä»£: æ›¾ç¥–çˆ¶æ¯ï¼ˆ32é …ç›®ï¼‰" mb="md" />
                <Grid gutter={10}>
                  {/* FFF */}
                  <Grid.Col span={12}><Divider label="çˆ¶çˆ¶çˆ¶ï¼ˆFFFï¼‰" /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 4 }}><InputWithFloatingLabel label="FFFã‚¿ã‚¤ãƒˆãƒ«" value={formData.fffTitle} onChange={(e) => updateFormData('fffTitle', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 4 }}><InputWithFloatingLabel label="FFFåå‰" value={formData.fffCatName} onChange={(e) => updateFormData('fffCatName', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 4 }}>
                    <InputWithFloatingLabel
                      label="FFFãƒŠãƒ³ãƒãƒ¼"
                      value={formData.fffjcu}
                      onChange={(e) => updateFormData('fffjcu', e.target.value)}
                      styles={isDuplicate(formData.fffjcu) ? duplicateStyle : undefined}
                    />
                  </Grid.Col>

                  {/* FFM */}
                  <Grid.Col span={12}><Divider label="çˆ¶çˆ¶æ¯ï¼ˆFFMï¼‰" /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 4 }}><InputWithFloatingLabel label="FFMã‚¿ã‚¤ãƒˆãƒ«" value={formData.ffmTitle} onChange={(e) => updateFormData('ffmTitle', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 4 }}><InputWithFloatingLabel label="FFMåå‰" value={formData.ffmCatName} onChange={(e) => updateFormData('ffmCatName', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 4 }}>
                    <InputWithFloatingLabel
                      label="FFMãƒŠãƒ³ãƒãƒ¼"
                      value={formData.ffmjcu}
                      onChange={(e) => updateFormData('ffmjcu', e.target.value)}
                      styles={isDuplicate(formData.ffmjcu) ? duplicateStyle : undefined}
                    />
                  </Grid.Col>

                  {/* FMF */}
                  <Grid.Col span={12}><Divider label="çˆ¶æ¯çˆ¶ï¼ˆFMFï¼‰" /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 4 }}><InputWithFloatingLabel label="FMFã‚¿ã‚¤ãƒˆãƒ«" value={formData.fmfTitle} onChange={(e) => updateFormData('fmfTitle', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 4 }}><InputWithFloatingLabel label="FMFåå‰" value={formData.fmfCatName} onChange={(e) => updateFormData('fmfCatName', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 4 }}>
                    <InputWithFloatingLabel
                      label="FMFãƒŠãƒ³ãƒãƒ¼"
                      value={formData.fmfjcu}
                      onChange={(e) => updateFormData('fmfjcu', e.target.value)}
                      styles={isDuplicate(formData.fmfjcu) ? duplicateStyle : undefined}
                    />
                  </Grid.Col>

                  {/* FMM */}
                  <Grid.Col span={12}><Divider label="çˆ¶æ¯æ¯ï¼ˆFMMï¼‰" /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 4 }}><InputWithFloatingLabel label="FMMã‚¿ã‚¤ãƒˆãƒ«" value={formData.fmmTitle} onChange={(e) => updateFormData('fmmTitle', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 4 }}><InputWithFloatingLabel label="FMMåå‰" value={formData.fmmCatName} onChange={(e) => updateFormData('fmmCatName', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 4 }}>
                    <InputWithFloatingLabel
                      label="FMMãƒŠãƒ³ãƒãƒ¼"
                      value={formData.fmmjcu}
                      onChange={(e) => updateFormData('fmmjcu', e.target.value)}
                      styles={isDuplicate(formData.fmmjcu) ? duplicateStyle : undefined}
                    />
                  </Grid.Col>

                  {/* MFF */}
                  <Grid.Col span={12}><Divider label="æ¯çˆ¶çˆ¶ï¼ˆMFFï¼‰" /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 4 }}><InputWithFloatingLabel label="MFFã‚¿ã‚¤ãƒˆãƒ«" value={formData.mffTitle} onChange={(e) => updateFormData('mffTitle', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 4 }}><InputWithFloatingLabel label="MFFåå‰" value={formData.mffCatName} onChange={(e) => updateFormData('mffCatName', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 4 }}>
                    <InputWithFloatingLabel
                      label="MFFãƒŠãƒ³ãƒãƒ¼"
                      value={formData.mffjcu}
                      onChange={(e) => updateFormData('mffjcu', e.target.value)}
                      styles={isDuplicate(formData.mffjcu) ? duplicateStyle : undefined}
                    />
                  </Grid.Col>

                  {/* MFM */}
                  <Grid.Col span={12}><Divider label="æ¯çˆ¶æ¯ï¼ˆMFMï¼‰" /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 4 }}><InputWithFloatingLabel label="MFMã‚¿ã‚¤ãƒˆãƒ«" value={formData.mfmTitle} onChange={(e) => updateFormData('mfmTitle', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 4 }}><InputWithFloatingLabel label="MFMåå‰" value={formData.mfmCatName} onChange={(e) => updateFormData('mfmCatName', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 4 }}>
                    <InputWithFloatingLabel
                      label="MFMãƒŠãƒ³ãƒãƒ¼"
                      value={formData.mfmjcu}
                      onChange={(e) => updateFormData('mfmjcu', e.target.value)}
                      styles={isDuplicate(formData.mfmjcu) ? duplicateStyle : undefined}
                    />
                  </Grid.Col>

                  {/* MMF */}
                  <Grid.Col span={12}><Divider label="æ¯æ¯çˆ¶ï¼ˆMMFï¼‰" /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 4 }}><InputWithFloatingLabel label="MMFã‚¿ã‚¤ãƒˆãƒ«" value={formData.mmfTitle} onChange={(e) => updateFormData('mmfTitle', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 4 }}><InputWithFloatingLabel label="MMFåå‰" value={formData.mmfCatName} onChange={(e) => updateFormData('mmfCatName', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 4 }}>
                    <InputWithFloatingLabel
                      label="MMFãƒŠãƒ³ãƒãƒ¼"
                      value={formData.mmfjcu}
                      onChange={(e) => updateFormData('mmfjcu', e.target.value)}
                      styles={isDuplicate(formData.mmfjcu) ? duplicateStyle : undefined}
                    />
                  </Grid.Col>

                  {/* MMM */}
                  <Grid.Col span={12}><Divider label="æ¯æ¯æ¯ï¼ˆMMMï¼‰" /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 4 }}><InputWithFloatingLabel label="MMMã‚¿ã‚¤ãƒˆãƒ«" value={formData.mmmTitle} onChange={(e) => updateFormData('mmmTitle', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 4 }}><InputWithFloatingLabel label="MMMåå‰" value={formData.mmmCatName} onChange={(e) => updateFormData('mmmCatName', e.target.value)} /></Grid.Col>
                  <Grid.Col span={{ base: 12, sm: 4 }}>
                    <InputWithFloatingLabel
                      label="MMMãƒŠãƒ³ãƒãƒ¼"
                      value={formData.mmmjcu}
                      onChange={(e) => updateFormData('mmmjcu', e.target.value)}
                      styles={isDuplicate(formData.mmmjcu) ? duplicateStyle : undefined}
                    />
                  </Grid.Col>
                </Grid>
              </Box>
            </Stack>
          </Paper>

          {/* é€ä¿¡ãƒœã‚¿ãƒ³ */}
          <Group justify="space-between" pt="md">
            <Button variant="subtle" leftSection={<IconArrowLeft size={16} />} onClick={() => onCancel ? onCancel() : router.back()}>
              ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            </Button>
            <Menu shadow="md" width={200}>
              <Menu.Target>
                <Button
                  loading={loading}
                  leftSection={<IconDeviceFloppy size={16} />}
                  rightSection={<IconChevronDown size={16} />}
                  size="lg"
                >
                  {isEditMode ? 'è¡€çµ±æ›¸ã‚’æ›´æ–°' : 'è¡€çµ±æ›¸ã‚’ç™»éŒ²'}
                </Button>
              </Menu.Target>
              <Menu.Dropdown>
                <Menu.Item
                  leftSection={<IconDeviceFloppy size={16} />}
                  onClick={handleCreate}
                  disabled={loading}
                >
                  æ–°è¦ç™»éŒ²
                </Menu.Item>
                <Menu.Item
                  leftSection={<IconRefresh size={16} />}
                  onClick={handleUpdate}
                  disabled={loading || !isEditMode}
                >
                  æ›´æ–°
                </Menu.Item>
                <Menu.Divider />
                <Menu.Item
                  leftSection={<IconTrash size={16} />}
                  color="red"
                  onClick={handleClear}
                  disabled={loading}
                >
                  ã‚¯ãƒªã‚¢
                </Menu.Item>
              </Menu.Dropdown>
            </Menu>
          </Group>
        </Stack>
      </form>
    </Box>
  );
}
````

## File: frontend/check-syntax.js
````javascript
const fs = require('fs');
const ts = require('typescript');

const files = [
  'src/components/kittens/BulkWeightRecordModal.tsx',
  'src/components/kittens/KittenManagementModal.tsx',
  'src/components/kittens/WeightRecordModal.tsx',
  'src/app/gallery/components/GalleryAddModal.tsx'
];

let hasErrors = false;

files.forEach(file => {
  const content = fs.readFileSync(file, 'utf8');
  const sourceFile = ts.createSourceFile(
    file,
    content,
    ts.ScriptTarget.ES2020,
    /* setParentNodes */ true,
    ts.ScriptKind.TSX
  );
  const result = ts.transpileModule(content, {
    compilerOptions: {
      target: ts.ScriptTarget.ES2020,
      module: ts.ModuleKind.ESNext,
      jsx: ts.JsxEmit.React,
      moduleResolution: ts.ModuleResolutionKind.NodeJs,
    },
    reportDiagnostics: true,
  });
  
  if (result.diagnostics && result.diagnostics.length > 0) {
    console.log(`\nâŒ ${file}:`);
    result.diagnostics.forEach(diag => {
      const position =
        typeof diag.start === 'number'
          ? sourceFile.getLineAndCharacterOfPosition(diag.start)
          : null;
      const lineNumber = position ? position.line + 1 : '?';
      const columnNumber = position ? position.character + 1 : '?';
      const message = ts.flattenDiagnosticMessageText(diag.messageText, '\n');
      console.log(`  Line ${lineNumber}, Column ${columnNumber}: ${message}`);
    });
    hasErrors = true;
  } else {
    console.log(`âœ… ${file}: OK`);
  }
});

if (!hasErrors) {
  console.log('\nâœ¨ All files passed syntax check!');
}

process.exit(hasErrors ? 1 : 0);
````

## File: frontend/src/app/breeding/components/BirthInfoModal.tsx
````typescript
'use client';

import {
  TextInput,
  NumberInput,
  Group,
  Button,
  ActionIcon,
  Divider,
} from '@mantine/core';
import { IconBabyCarriage, IconRainbow } from '@tabler/icons-react';
import { UnifiedModal } from '@/components/common';
import type { BirthPlan } from '@/lib/api/hooks/use-breeding';
import type { Cat } from '@/lib/api/hooks/use-cats';

export interface BirthInfoModalProps {
  opened: boolean;
  onClose: () => void;
  selectedBirthPlan: BirthPlan | null;
  allCats: Cat[];
  birthCount: number;
  deathCount: number;
  birthDate: string;
  onBirthCountChange: (count: number) => void;
  onDeathCountChange: (count: number) => void;
  onBirthDateChange: (date: string) => void;
  onSubmit: () => void;
  onDetailSubmit: () => void;
  isLoading: boolean;
}

export function BirthInfoModal({
  opened,
  onClose,
  selectedBirthPlan,
  allCats,
  birthCount,
  deathCount,
  birthDate,
  onBirthCountChange,
  onDeathCountChange,
  onBirthDateChange,
  onSubmit,
  onDetailSubmit,
  isLoading,
}: BirthInfoModalProps) {
  const handleClose = () => {
    onClose();
  };

  // çˆ¶çŒ«ã®åå‰ã‚’å–å¾—
  const fatherName = selectedBirthPlan?.fatherId 
    ? allCats.find((cat) => cat.id === selectedBirthPlan.fatherId)?.name || 'ä¸æ˜'
    : 'ä¸æ˜';

  return (
    <UnifiedModal
      opened={opened}
      onClose={handleClose}
      title="å‡ºç”£æƒ…å ±ã®å…¥åŠ›"
      size="md"
    >
      {/* ä¸¡è¦ªã®åå‰ */}
      <TextInput
        label="ä¸¡è¦ª"
        value={selectedBirthPlan ? `${selectedBirthPlan.mother?.name || 'ä¸æ˜'} (${fatherName})` : ''}
        readOnly
      />

      <Divider label="å‡ºç”£æƒ…å ±" labelPosition="center" />

      {/* å‡ºç”£æ—¥ */}
      <TextInput
        label="å‡ºç”£æ—¥"
        type="date"
        value={birthDate}
        onChange={(e) => onBirthDateChange(e.target.value)}
      />

      {/* å‡ºç”£é ­æ•° */}
      <Group gap="sm" align="flex-end">
        <NumberInput
          label="å‡ºç”£é ­æ•°"
          value={birthCount}
          onChange={(value) => onBirthCountChange(typeof value === 'number' ? value : 0)}
          min={0}
          style={{ flex: 1 }}
        />
        <ActionIcon
          size="lg"
          variant="light"
          color="blue"
          onClick={() => onBirthCountChange(birthCount + 1)}
          title="1é ­è¿½åŠ "
        >
          <IconBabyCarriage size={20} />
        </ActionIcon>
      </Group>

      {/* æ­»äº¡æ•° */}
      <Group gap="sm" align="flex-end">
        <NumberInput
          label="æ­»äº¡æ•°"
          value={deathCount}
          onChange={(value) => onDeathCountChange(typeof value === 'number' ? value : 0)}
          min={0}
          style={{ flex: 1 }}
        />
        <ActionIcon
          size="lg"
          variant="light"
          color="grape"
          onClick={() => onDeathCountChange(deathCount + 1)}
          title="1é ­è¿½åŠ "
        >
          <IconRainbow size={20} />
        </ActionIcon>
      </Group>

      <Divider />

      {/* ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ */}
      <Group justify="flex-end" gap="sm" mt="md">
        <Button
          variant="outline"
          onClick={onDetailSubmit}
        >
          è©³ç´°ç™»éŒ²
        </Button>
        <Button
          onClick={onSubmit}
          loading={isLoading}
        >
          ç™»éŒ²
        </Button>
      </Group>
    </UnifiedModal>
  );
}
````

## File: frontend/src/app/breeding/components/CompleteConfirmModal.tsx
````typescript
'use client';

import {
  Text,
  Group,
  Button,
} from '@mantine/core';
import { UnifiedModal, type ModalSection } from '@/components/common';
import type { BirthPlan } from '@/lib/api/hooks/use-breeding';

export interface CompleteConfirmModalProps {
  opened: boolean;
  onClose: () => void;
  selectedBirthPlan: BirthPlan | null;
  onConfirm: () => void;
  isLoading: boolean;
}

export function CompleteConfirmModal({
  opened,
  onClose,
  selectedBirthPlan,
  onConfirm,
  isLoading,
}: CompleteConfirmModalProps) {
  const sections: ModalSection[] = [
    {
      content: (
        <>
          <Text size="sm">
        {selectedBirthPlan?.mother?.name || 'ä¸æ˜'}ã®å‡ºç”£è¨˜éŒ²ã‚’å®Œäº†ã—ã¾ã™ã€‚
        å®Œäº†å¾Œã¯å­è‚²ã¦ä¸­ã‚¿ãƒ–ã‹ã‚‰å‰Šé™¤ã•ã‚Œã€æ¯çŒ«è©³ç´°ãƒšãƒ¼ã‚¸ã®å‡ºç”£è¨˜éŒ²ã«æ ¼ç´ã•ã‚Œã¾ã™ã€‚
      </Text>
          <Text size="sm" c="dimmed">
            ã“ã®æ“ä½œã¯å…ƒã«æˆ»ã›ã¾ã›ã‚“ã€‚
          </Text>
        </>
      ),
    },
    {
      content: (
        <Group justify="flex-end" gap="sm" mt="md">
        <Button
          variant="outline"
          onClick={onClose}
        >
          ã‚­ãƒ£ãƒ³ã‚»ãƒ«
        </Button>
        <Button
          color="blue"
          onClick={onConfirm}
          loading={isLoading}
        >
            å®Œäº†ã™ã‚‹
          </Button>
        </Group>
      ),
    },
  ];

  return (
    <UnifiedModal
      opened={opened}
      onClose={onClose}
      title="å‡ºç”£è¨˜éŒ²ã‚’å®Œäº†ã—ã¾ã™ã‹ï¼Ÿ"
      centered
      sections={sections}
    />
  );
}
````

## File: frontend/src/app/breeding/components/FemaleSelectionModal.tsx
````typescript
'use client';

import { ChangeEvent } from 'react';
import {
  Stack,
  Text,
  Card,
  Flex,
  Box,
  Group,
  Badge,
  Button,
  NumberInput,
  Checkbox,
  Divider,
} from '@mantine/core';
import { UnifiedModal, type ModalSection } from '@/components/common';
import type { Cat } from '@/lib/api/hooks/use-cats';

export interface FemaleSelectionModalProps {
  opened: boolean;
  onClose: () => void;
  selectedMale: Cat | null;
  availableFemales: Cat[];
  selectedDuration: number;
  onDurationChange: (duration: number) => void;
  onSetDefaultDuration: (duration: number, setAsDefault: boolean) => void;
  onSelectFemale: (femaleId: string) => void;
  isNGPairing: (maleId: string, femaleId: string) => boolean;
}

export function FemaleSelectionModal({
  opened,
  onClose,
  selectedMale,
  availableFemales,
  selectedDuration,
  onDurationChange,
  onSetDefaultDuration,
  onSelectFemale,
  isNGPairing,
}: FemaleSelectionModalProps) {
  const sections: ModalSection[] = [
    {
      content: (
        <Stack gap="md" p="md">
        <Text size="sm" c="dimmed">
          {selectedMale?.name} ã¨ã®äº¤é…ç›¸æ‰‹ã‚’é¸æŠã—ã¦ãã ã•ã„
        </Text>
        
        <Stack gap="xs">
          <NumberInput
            label="äº¤é…æœŸé–“"
            description="äº¤é…ã‚’è¡Œã†æ—¥æ•°ã‚’è¨­å®šã—ã¦ãã ã•ã„"
            value={selectedDuration}
            onChange={(value) => onDurationChange(typeof value === 'number' ? value : 1)}
            min={1}
            max={7}
            suffix="æ—¥é–“"
          />
          <Checkbox
            label="ã“ã®æœŸé–“ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«è¨­å®š"
            size="sm"
            onChange={(event: ChangeEvent<HTMLInputElement>) => 
              onSetDefaultDuration(selectedDuration, event.currentTarget.checked)
            }
          />
        </Stack>

        <Divider label="ãƒ¡ã‚¹çŒ«ä¸€è¦§" labelPosition="center" />

        {availableFemales.map((female) => {
          const isNG = selectedMale ? isNGPairing(selectedMale.id, female.id) : false;
          return (
            <Card 
              key={female.id} 
              shadow="sm" 
              padding="sm" 
              radius="md" 
              withBorder
              style={{ borderColor: isNG ? '#ff6b6b' : undefined }}
            >
              <Flex justify="space-between" align="center">
                <Box>
                  <Group gap="xs">
                    <Text fw={600}>{female.name}</Text>
                    {isNG && <Badge color="red" size="xs">NG</Badge>}
                  </Group>
                  <Text size="sm" c="dimmed">{female.breed?.name ?? 'ä¸æ˜'}</Text>
                  <Group gap="xs">
                    {female.tags?.map((catTag) => (
                      <Badge key={catTag.tag.id} variant="outline" size="xs">
                        {catTag.tag.name}
                      </Badge>
                    )) ?? []}
                  </Group>
                </Box>
                <Button
                  size="sm"
                  color={isNG ? "red" : undefined}
                  variant={isNG ? "outline" : "filled"}
                  onClick={() => onSelectFemale(female.id)}
                >
                  {isNG ? 'è­¦å‘Šé¸æŠ' : 'é¸æŠ'}
                </Button>
              </Flex>
            </Card>
          );
        })}
        {availableFemales.length === 0 && (
          <Text ta="center" c="dimmed">
            ç¾åœ¨äº¤é…å¯èƒ½ãªãƒ¡ã‚¹çŒ«ãŒã„ã¾ã›ã‚“
          </Text>
        )}
      </Stack>
      ),
    },
  ];

  return (
    <UnifiedModal
      opened={opened}
      onClose={onClose}
      title="äº¤é…ã™ã‚‹ãƒ¡ã‚¹çŒ«ã‚’é¸æŠ"
      size="md"
      addContentPadding={false}
      sections={sections}
    />
  );
}
````

## File: frontend/src/app/breeding/components/MaleSelectionModal.tsx
````typescript
'use client';

import {
  Stack,
  Text,
  Card,
  Flex,
  Box,
  Group,
  Badge,
  Button,
} from '@mantine/core';
import { UnifiedModal, type ModalSection } from '@/components/common';
import type { Cat } from '@/lib/api/hooks/use-cats';
import { calculateAgeInMonths } from '../utils';

export interface MaleSelectionModalProps {
  opened: boolean;
  onClose: () => void;
  allCats: Cat[];
  activeMales: Cat[];
  onAddMale: (male: Cat) => void;
}

export function MaleSelectionModal({
  opened,
  onClose,
  allCats,
  activeMales,
  onAddMale,
}: MaleSelectionModalProps) {
  // è¿½åŠ å¯èƒ½ãªã‚ªã‚¹çŒ«ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼ˆåœ¨èˆã€10ãƒ¶æœˆä»¥ä¸Šã€ã¾ã è¿½åŠ ã•ã‚Œã¦ã„ãªã„ï¼‰
  const availableMales = allCats.filter((cat) => 
    cat.gender === 'MALE' && 
    cat.isInHouse && 
    calculateAgeInMonths(cat.birthDate) >= 10 &&
    !activeMales.some((am) => am.id === cat.id)
  );

  const sections: ModalSection[] = [
    {
      content: (
        <Stack gap="sm" p="md">
          <Text size="sm" c="dimmed">
            ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã«è¿½åŠ ã™ã‚‹ã‚ªã‚¹çŒ«ã‚’é¸æŠã—ã¦ãã ã•ã„
          </Text>
          
          {availableMales.map((male) => (
          <Card key={male.id} shadow="sm" padding="sm" radius="md" withBorder>
            <Flex justify="space-between" align="center">
              <Box>
                <Text fw={600}>{male.name}</Text>
                <Text size="sm" c="dimmed">{male.breed?.name ?? 'ä¸æ˜'}</Text>
                <Group gap="xs">
                  {male.tags?.map((catTag, index) => (
                    <Badge key={`${catTag.tag.id}-${index}`} variant="outline" size="xs">
                      {catTag.tag.name}
                    </Badge>
                  )) ?? []}
                </Group>
              </Box>
              <Button
                size="sm"
                onClick={() => {
                  onAddMale(male);
                  onClose();
                }}
              >
                è¿½åŠ 
              </Button>
            </Flex>
          </Card>
          ))}
          {availableMales.length === 0 && (
            <Text ta="center" c="dimmed">
              è¿½åŠ å¯èƒ½ãªã‚ªã‚¹çŒ«ãŒã„ã¾ã›ã‚“
            </Text>
          )}
        </Stack>
      ),
    },
  ];

  return (
    <UnifiedModal
      opened={opened}
      onClose={onClose}
      title="ã‚ªã‚¹çŒ«ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã«è¿½åŠ "
      size="md"
      addContentPadding={false}
      sections={sections}
    />
  );
}
````

## File: frontend/src/app/breeding/components/NewRuleModal.tsx
````typescript
'use client';

import {
  Stack,
  TextInput,
  NumberInput,
  MultiSelect,
  Radio,
  Group,
  Button,
} from '@mantine/core';
import { UnifiedModal, type ModalSection } from '@/components/common';
import type { BreedingNgRuleType } from '@/lib/api/hooks/use-breeding';
import type { Cat } from '@/lib/api/hooks/use-cats';
import type { NewRuleState } from '../types';

export interface NewRuleModalProps {
  opened: boolean;
  onClose: () => void;
  newRule: NewRuleState;
  onRuleChange: (rule: NewRuleState) => void;
  availableTags: string[];
  allCats: Cat[];
  onSubmit: () => void;
  isLoading: boolean;
}

export function NewRuleModal({
  opened,
  onClose,
  newRule,
  onRuleChange,
  availableTags,
  allCats,
  onSubmit,
  isLoading,
}: NewRuleModalProps) {
  const handleClose = () => {
    onRuleChange({
      name: '',
      type: 'TAG_COMBINATION',
      maleNames: [],
      femaleNames: [],
      maleConditions: [],
      femaleConditions: [],
      generationLimit: 3,
      description: '',
    });
    onClose();
  };

  const sections: ModalSection[] = [
    {
      content: (
        <TextInput
        label="ãƒ«ãƒ¼ãƒ«å"
        placeholder="ä¾‹: åŒè¡€çµ±ç¦æ­¢"
        value={newRule.name}
          onChange={(e) => onRuleChange({ ...newRule, name: e.target.value })}
          required
        />
      ),
    },
    {
      label: "ãƒ«ãƒ¼ãƒ«è¨­å®š",
      content: (
        <>
          <Radio.Group
        label="ãƒ«ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ—"
        value={newRule.type}
        onChange={(value) => onRuleChange({ ...newRule, type: value as BreedingNgRuleType })}
      >
        <Stack gap="xs" mt="xs">
          <Radio value="TAG_COMBINATION" label="ã‚¿ã‚°çµ„åˆã›ç¦æ­¢" />
          <Radio value="INDIVIDUAL_PROHIBITION" label="å€‹ä½“é–“ç¦æ­¢" />
          <Radio value="GENERATION_LIMIT" label="ä¸–ä»£åˆ¶é™" />
        </Stack>
      </Radio.Group>

      {newRule.type === 'TAG_COMBINATION' && (
        <>
          <MultiSelect
            label="ã‚ªã‚¹çŒ«ã®æ¡ä»¶ã‚¿ã‚°"
            placeholder="ç¦æ­¢ã™ã‚‹ã‚ªã‚¹çŒ«ã®ã‚¿ã‚°ã‚’é¸æŠ"
            data={availableTags}
            value={newRule.maleConditions}
            onChange={(values) => onRuleChange({ ...newRule, maleConditions: values })}
            searchable
          />
          <MultiSelect
            label="ãƒ¡ã‚¹çŒ«ã®æ¡ä»¶ã‚¿ã‚°"
            placeholder="ç¦æ­¢ã™ã‚‹ãƒ¡ã‚¹çŒ«ã®ã‚¿ã‚°ã‚’é¸æŠ"
            data={availableTags}
            value={newRule.femaleConditions}
            onChange={(values) => onRuleChange({ ...newRule, femaleConditions: values })}
            searchable
          />
        </>
      )}

      {newRule.type === 'INDIVIDUAL_PROHIBITION' && (
        <>
          <MultiSelect
            label="ç¦æ­¢ã™ã‚‹ã‚ªã‚¹çŒ«"
            placeholder="ã‚ªã‚¹çŒ«ã‚’é¸æŠ"
            data={allCats
              .filter((cat) => cat.gender === 'MALE' && cat.isInHouse)
              .map((cat) => ({ value: cat.name, label: cat.name }))}
            value={newRule.maleNames}
            onChange={(values) => onRuleChange({ ...newRule, maleNames: values })}
            searchable
          />
          <MultiSelect
            label="ç¦æ­¢ã™ã‚‹ãƒ¡ã‚¹çŒ«"
            placeholder="ãƒ¡ã‚¹çŒ«ã‚’é¸æŠ"
            data={allCats
              .filter((cat) => cat.gender === 'FEMALE' && cat.isInHouse)
              .map((cat) => ({ value: cat.name, label: cat.name }))}
            value={newRule.femaleNames}
            onChange={(values) => onRuleChange({ ...newRule, femaleNames: values })}
            searchable
          />
        </>
      )}

      {newRule.type === 'GENERATION_LIMIT' && (
        <NumberInput
          label="ä¸–ä»£åˆ¶é™"
          placeholder="ä¾‹: 3"
          value={newRule.generationLimit ?? 3}
          onChange={(value) => onRuleChange({ ...newRule, generationLimit: typeof value === 'number' ? value : 3 })}
          min={1}
          max={10}
        />
      )}

      <TextInput
        label="èª¬æ˜ï¼ˆä»»æ„ï¼‰"
        placeholder="ã“ã®ãƒ«ãƒ¼ãƒ«ã®è©³ç´°èª¬æ˜"
          value={newRule.description}
          onChange={(e) => onRuleChange({ ...newRule, description: e.target.value })}
        />
        </>
      ),
    },
    {
      content: (
        <Group justify="flex-end" gap="sm" mt="md">
        <Button
          variant="outline"
          onClick={handleClose}
        >
          ã‚­ãƒ£ãƒ³ã‚»ãƒ«
        </Button>
        <Button
          onClick={onSubmit}
          loading={isLoading}
        >
            ä½œæˆ
          </Button>
        </Group>
      ),
    },
  ];

  return (
    <UnifiedModal
      opened={opened}
      onClose={handleClose}
      title="æ–°è¦NGãƒ«ãƒ¼ãƒ«ä½œæˆ"
      size="lg"
      centered
      sections={sections}
    />
  );
}
````

## File: frontend/src/app/breeding/components/NgRulesModal.tsx
````typescript
'use client';

import {
  Stack,
  Text,
  Card,
  Group,
  Badge,
  Button,
  ActionIcon,
} from '@mantine/core';
import { IconPlus, IconTrash } from '@tabler/icons-react';
import { UnifiedModal, type ModalSection } from '@/components/common';
import type { NgPairingRule } from '../types';

export interface NgRulesModalProps {
  opened: boolean;
  onClose: () => void;
  ngPairingRules: NgPairingRule[];
  isLoading: boolean;
  error: string | null;
  onOpenNewRuleModal: () => void;
  onDeleteRule: (rule: NgPairingRule) => void;
}

export function NgRulesModal({
  opened,
  onClose,
  ngPairingRules,
  isLoading,
  error,
  onOpenNewRuleModal,
  onDeleteRule,
}: NgRulesModalProps) {
  const sections: ModalSection[] = [
    {
      content: (
        <Text size="sm" c="dimmed">
        äº¤é…ã‚’ç¦æ­¢ã™ã‚‹ãƒ«ãƒ¼ãƒ«ã‚’è¨­å®šã§ãã¾ã™ã€‚è¨­å®šã—ãŸãƒ«ãƒ¼ãƒ«ã«è©²å½“ã™ã‚‹çµ„ã¿åˆã‚ã›ã‚’é¸æŠã™ã‚‹ã¨è­¦å‘ŠãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚
        </Text>
      ),
    },
    {
      content: (
        <Button
        leftSection={<IconPlus size={16} />}
        onClick={onOpenNewRuleModal}
        variant="light"
        fullWidth
      >
        æ–°ã—ã„ãƒ«ãƒ¼ãƒ«ã‚’è¿½åŠ 
      </Button>
      ),
    },
    {
      label: "ç™»éŒ²æ¸ˆã¿ãƒ«ãƒ¼ãƒ«",
      content: (
        <>
          {isLoading ? (
        <Text size="sm" c="dimmed" ta="center">
          èª­ã¿è¾¼ã¿ä¸­...
        </Text>
      ) : error ? (
        <Text size="sm" c="red" ta="center">
          {error}
        </Text>
      ) : ngPairingRules.length === 0 ? (
        <Text size="sm" c="dimmed" ta="center">
          ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ãƒ«ãƒ¼ãƒ«ã¯ã‚ã‚Šã¾ã›ã‚“
        </Text>
      ) : (
        <Stack gap="xs">
          <Text size="sm" fw={500}>
            ç™»éŒ²æ¸ˆã¿ãƒ«ãƒ¼ãƒ« ({ngPairingRules.length}ä»¶)
          </Text>
          {ngPairingRules.map((rule) => (
            <Card key={rule.id} p="sm" withBorder>
              <Group justify="space-between" wrap="nowrap">
                <Stack gap={4} style={{ flex: 1 }}>
                  <Group gap="xs">
                    <Text size="sm" fw={500}>
                      {rule.name}
                    </Text>
                    <Badge 
                      size="sm" 
                      variant={rule.active ? 'filled' : 'outline'}
                      color={rule.active ? 'blue' : 'gray'}
                    >
                      {rule.active ? 'æœ‰åŠ¹' : 'ç„¡åŠ¹'}
                    </Badge>
                    <Badge size="sm" variant="light">
                      {rule.type === 'TAG_COMBINATION' ? 'ã‚¿ã‚°çµ„åˆã›' : 
                       rule.type === 'INDIVIDUAL_PROHIBITION' ? 'å€‹ä½“ç¦æ­¢' : 
                       rule.type === 'GENERATION_LIMIT' ? 'ä¸–ä»£åˆ¶é™' : rule.type}
                    </Badge>
                  </Group>
                  {rule.description && (
                    <Text size="xs" c="dimmed">
                      {rule.description}
                    </Text>
                  )}
                  {rule.type === 'INDIVIDUAL_PROHIBITION' && (
                    <Group gap="xs">
                      {rule.maleNames && rule.maleNames.length > 0 && (
                        <Text size="xs" c="dimmed">
                          ã‚ªã‚¹: {rule.maleNames.join(', ')}
                        </Text>
                      )}
                      {rule.femaleNames && rule.femaleNames.length > 0 && (
                        <Text size="xs" c="dimmed">
                          ãƒ¡ã‚¹: {rule.femaleNames.join(', ')}
                        </Text>
                      )}
                    </Group>
                  )}
                  {rule.type === 'GENERATION_LIMIT' && rule.generationLimit && (
                    <Text size="xs" c="dimmed">
                      ä¸–ä»£åˆ¶é™: {rule.generationLimit}ä¸–ä»£
                    </Text>
                  )}
                </Stack>
                <Group gap="xs" wrap="nowrap">
                  <ActionIcon
                    variant="subtle"
                    color="red"
                    onClick={() => onDeleteRule(rule)}
                  >
                    <IconTrash size={16} />
                  </ActionIcon>
                </Group>
              </Group>
            </Card>
            ))}
          </Stack>
        )}
        </>
      ),
    },
  ];

  return (
    <UnifiedModal
      opened={opened}
      onClose={onClose}
      title="äº¤é…NGè¨­å®š"
      size="xl"
      centered
      sections={sections}
    />
  );
}
````

## File: frontend/src/app/breeding/page.tsx
````typescript
'use client';

import { useEffect, useState } from 'react';
import {
  Box,
  Container,
  Group,
} from '@mantine/core';
import { usePageHeader } from '@/lib/contexts/page-header-context';
import { useDisclosure } from '@mantine/hooks';
import { notifications } from '@mantine/notifications';
import { 
  IconHeart, 
  IconCalendar,
  IconPaw,
  IconBabyCarriage,
  IconScale,
  IconTruck,
  IconSettings,
} from '@tabler/icons-react';

import { BreedingScheduleEditModal } from '@/components/breeding/breeding-schedule-edit-modal';
import { KittenManagementModal } from '@/components/kittens/KittenManagementModal';
import { TabsSection } from '@/components/TabsSection';
import { useContextMenu } from '@/components/context-menu';
import { ActionButton } from '@/components/ActionButton';

import {
  useGetBreedingNgRules,
  useCreateBreedingNgRule,
  useDeleteBreedingNgRule,
  type CreateBreedingNgRuleRequest,
  useGetPregnancyChecks,
  useCreatePregnancyCheck,
  useDeletePregnancyCheck,
  type PregnancyCheck,
  useGetBirthPlans,
  useCreateBirthPlan,
  useDeleteBirthPlan,
  useUpdateBirthPlan,
  type BirthPlan,
  useCompleteBirthRecord,
} from '@/lib/api/hooks/use-breeding';
import { useGetCats, useCreateCat, type Cat, type CreateCatRequest } from '@/lib/api/hooks/use-cats';
import { useGetTagCategories } from '@/lib/api/hooks/use-tags';

// åˆ†å‰²ã—ãŸã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
import {
  BreedingScheduleTab,
  PregnancyCheckTab,
  BirthPlanTab,
  RaisingTab,
  WeightTab,
  ShippingTab,
  MaleSelectionModal,
  FemaleSelectionModal,
  BirthInfoModal,
  NgRulesModal,
  NewRuleModal,
  CompleteConfirmModal,
} from './components';

// ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯
import { useBreedingSchedule } from './hooks';
import { useNgPairing } from './hooks/useNgPairing';

// å‹å®šç¾©
import type { BreedingScheduleEntry, NgPairingRule, NewRuleState } from './types';
import { calculateAgeInMonths } from './utils';

export default function BreedingPage() {
  const { setPageHeader } = usePageHeader();
  
  // ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯ã‹ã‚‰çŠ¶æ…‹ã‚’å–å¾—
  const {
    breedingSchedule,
    activeMales,
    selectedYear,
    selectedMonth,
    defaultDuration,
    setBreedingSchedule,
    setSelectedYear,
    setSelectedMonth,
    setDefaultDuration,
    addMale,
    removeMale,
    getMatingCheckCount,
    addMatingCheck,
    clearScheduleData,
  } = useBreedingSchedule();

  const [activeTab, setActiveTab] = useState('schedule');
  const [isFullscreen] = useState(false);
  const [selectedMaleForEdit, setSelectedMaleForEdit] = useState<string | null>(null);

  const [selectedMale, setSelectedMale] = useState<string | null>(null);
  const [selectedDate, setSelectedDate] = useState<string | null>(null);
  const [selectedDuration, setSelectedDuration] = useState<number>(1);
  const [availableFemales, setAvailableFemales] = useState<Cat[]>([]);
  
  // ãƒ¢ãƒ¼ãƒ€ãƒ«çŠ¶æ…‹
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [maleModalOpened, { open: openMaleModal, close: closeMaleModal }] = useDisclosure(false);
  const [rulesModalOpened, { open: openRulesModal, close: closeRulesModal }] = useDisclosure(false);
  const [newRuleModalOpened, { open: openNewRuleModal, close: closeNewRuleModal }] = useDisclosure(false);
  const [birthInfoModalOpened, { open: openBirthInfoModal, close: closeBirthInfoModal }] = useDisclosure(false);
  const [scheduleEditModalOpened, { open: openScheduleEditModal, close: closeScheduleEditModal }] = useDisclosure(false);
  const [selectedScheduleForEdit, setSelectedScheduleForEdit] = useState<BreedingScheduleEntry | null>(null);
  const [managementModalOpened, { open: openManagementModal, close: closeManagementModal }] = useDisclosure(false);
  const [selectedMotherIdForModal, setSelectedMotherIdForModal] = useState<string | undefined>();
  const [completeConfirmModalOpened, { open: openCompleteConfirmModal, close: closeCompleteConfirmModal }] = useDisclosure(false);
  const [selectedBirthPlanForComplete, setSelectedBirthPlanForComplete] = useState<BirthPlan | null>(null);

  // å‡ºç”£æƒ…å ±ãƒ¢ãƒ¼ãƒ€ãƒ«ã®çŠ¶æ…‹
  const [selectedBirthPlan, setSelectedBirthPlan] = useState<BirthPlan | null>(null);
  const [birthCount, setBirthCount] = useState<number>(0);
  const [deathCount, setDeathCount] = useState<number>(0);
  const [birthDate, setBirthDate] = useState<string>(new Date().toISOString().split('T')[0]);
  const [expandedRaisingCats, setExpandedRaisingCats] = useState<Set<string>>(new Set());

  // NGãƒ«ãƒ¼ãƒ«çŠ¶æ…‹
  const [ngPairingRules, setNgPairingRules] = useState<NgPairingRule[]>([]);
  const [rulesError, setRulesError] = useState<string | null>(null);
  const [newRule, setNewRule] = useState<NewRuleState>({
    name: '',
    type: 'TAG_COMBINATION',
    maleNames: [],
    femaleNames: [],
    maleConditions: [],
    femaleConditions: [],
    generationLimit: 3,
    description: '',
  });

  // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼
  const {
    handleAction: handleScheduleContextAction,
  } = useContextMenu<BreedingScheduleEntry>({
    edit: (schedule) => {
      if (schedule) {
        setSelectedScheduleForEdit(schedule);
        openScheduleEditModal();
      }
    },
    delete: (schedule) => {
      if (schedule) {
        setSelectedScheduleForEdit(schedule);
        handleDeleteSchedule();
      }
    },
  });

  // API hooks
  const catsQuery = useGetCats({ limit: 1000 }, { enabled: true });
  const { data: catsResponse } = catsQuery;
  const tagCategoriesQuery = useGetTagCategories();
  const ngRulesQuery = useGetBreedingNgRules();
  const { data: ngRulesResponse, isLoading: isNgRulesLoading, isFetching: isNgRulesFetching, error: ngRulesError } = ngRulesQuery;

  const pregnancyChecksQuery = useGetPregnancyChecks();
  const { data: pregnancyChecksResponse } = pregnancyChecksQuery;
  const createPregnancyCheckMutation = useCreatePregnancyCheck();
  const deletePregnancyCheckMutation = useDeletePregnancyCheck();

  const birthPlansQuery = useGetBirthPlans();
  const { data: birthPlansResponse } = birthPlansQuery;
  const createBirthPlanMutation = useCreateBirthPlan();
  const deleteBirthPlanMutation = useDeleteBirthPlan();
  const updateBirthPlanMutation = useUpdateBirthPlan();
  const createCatMutation = useCreateCat();
  const completeBirthRecordMutation = useCompleteBirthRecord();

  const createNgRuleMutation = useCreateBreedingNgRule();
  const deleteNgRuleMutation = useDeleteBreedingNgRule();

  // NGãƒšã‚¢ãƒªãƒ³ã‚°ãƒ•ãƒƒã‚¯
  const { isNGPairing, findMatchingRule } = useNgPairing({
    activeMales,
    allCats: catsResponse?.data ?? [],
    ngPairingRules,
  });

  // ãƒšãƒ¼ã‚¸ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’è¨­å®š
  useEffect(() => {
    setPageHeader(
      'äº¤é…ç®¡ç†',
      <Group gap="sm">
        <ActionButton
          action="view"
          customIcon={<IconSettings size={18} />}
          onClick={openRulesModal}
        >
          NGè¨­å®š
        </ActionButton>
      </Group>
    );

    return () => {
      setPageHeader(null);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  
  // NGãƒ«ãƒ¼ãƒ«ã®èª­ã¿è¾¼ã¿
  useEffect(() => {
    if (!ngRulesResponse) return;
  const remoteRules = (ngRulesResponse.data ?? []) as NgPairingRule[];
  setNgPairingRules(remoteRules.map(rule => ({ ...rule })));
  }, [ngRulesResponse]);

  useEffect(() => {
    if (ngRulesError) {
      setRulesError(ngRulesError instanceof Error ? ngRulesError.message : 'NGãƒ«ãƒ¼ãƒ«ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
    } else {
      setRulesError(null);
    }
  }, [ngRulesError]);

  // åˆ©ç”¨å¯èƒ½ãªã‚¿ã‚°ä¸€è¦§
  const availableTags: string[] = [...new Set(
    (catsResponse?.data ?? [])
      .flatMap((cat: Cat) => cat.tags?.map((catTag) => catTag.tag.name).filter((name: string) => name) ?? [])
      .filter((name: string) => name)
  )];

  // ã‚ªã‚¹çŒ«è¿½åŠ 
  const handleAddMale = (maleData: Cat) => {
    addMale(maleData);
    closeMaleModal();
  };

  // ã‚ªã‚¹çŒ«å‰Šé™¤
  const handleRemoveMale = (maleId: string) => {
    removeMale(maleId);
    setSelectedMaleForEdit(null);
  };

  // ã‚ªã‚¹çŒ«é¸æŠæ™‚ã«äº¤é…å¯èƒ½ãƒ¡ã‚¹ä¸€è¦§ã‚’è¡¨ç¤º
  const handleMaleSelect = (maleId: string, date: string) => {
    setSelectedMale(maleId);
    setSelectedDate(date);
    setSelectedDuration(defaultDuration);
    
    const available = (catsResponse?.data ?? []).filter((cat: Cat) => 
      cat.gender === 'FEMALE' &&
      cat.isInHouse &&
      calculateAgeInMonths(cat.birthDate) >= 11
    );
    setAvailableFemales(available);
    openModal();
  };

  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæœŸé–“ã‚’æ›´æ–°
  const handleSetDefaultDuration = (duration: number, setAsDefault: boolean) => {
    if (setAsDefault) {
      setDefaultDuration(duration);
    }
  };

  // äº¤é…çµæœå‡¦ç†
  const handleMatingResult = (maleId: string, femaleId: string, femaleName: string, matingDate: string, result: 'success' | 'failure') => {
    const male = activeMales.find((m: Cat) => m.id === maleId);
    
    if (result === 'success') {
      const checkDate = new Date();
      checkDate.setDate(checkDate.getDate() + 21);
      
      const payload = {
        motherId: femaleId,
        fatherId: maleId,
        matingDate: matingDate,
        checkDate: checkDate.toISOString().split('T')[0],
        status: 'SUSPECTED' as const,
        notes: `${male?.name || ''}ã¨ã®äº¤é…ã«ã‚ˆã‚‹å¦Šå¨ ç–‘ã„`,
      };
      
      createPregnancyCheckMutation.mutate(payload, {
        onSuccess: async () => {
          setBreedingSchedule((prev: Record<string, BreedingScheduleEntry>) => {
            const newSchedule = { ...prev };
            Object.keys(newSchedule).forEach(key => {
              if (key.includes(maleId) && newSchedule[key].femaleName === femaleName && !newSchedule[key].isHistory) {
                newSchedule[key] = {
                  ...newSchedule[key],
                  isHistory: true,
                  result: ''
                };
              }
            });
            return newSchedule;
          });
          
          await pregnancyChecksQuery.refetch();
        },
        onError: (error: Error) => {
          let errorMessage = 'å¦Šå¨ ç¢ºèªä¸­ãƒªã‚¹ãƒˆã¸ã®ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ';
          if (error.message) {
            errorMessage = error.message;
          }
          
          notifications.show({
            title: 'ç™»éŒ²å¤±æ•—',
            message: errorMessage,
            color: 'red',
            autoClose: 15000,
          });
        }
      });
    } else {
      setBreedingSchedule((prev: Record<string, BreedingScheduleEntry>) => {
        const newSchedule = { ...prev };
        Object.keys(newSchedule).forEach(key => {
          if (key.includes(maleId) && newSchedule[key].femaleName === femaleName && !newSchedule[key].isHistory) {
            newSchedule[key] = {
              ...newSchedule[key],
              isHistory: true,
              result: ''
            };
          }
        });
        return newSchedule;
      });
    }
  };

  // äº¤é…æœŸé–“ã¨ãƒ¡ã‚¹çŒ«ã®æ›´æ–°
  const handleUpdateScheduleDuration = (newDuration: number, newFemaleId?: string) => {
    if (!selectedScheduleForEdit) return;

    const { maleId, femaleId, date, duration: oldDuration, dayIndex } = selectedScheduleForEdit;
    
    const startDate = new Date(date);
    startDate.setDate(startDate.getDate() - dayIndex);
    
    let newFemaleName = selectedScheduleForEdit.femaleName;
    let finalFemaleId = femaleId;
    
    if (newFemaleId && newFemaleId !== femaleId) {
      const newFemale = catsResponse?.data?.find((f: Cat) => f.id === newFemaleId);
      if (newFemale) {
        newFemaleName = newFemale.name;
        finalFemaleId = newFemaleId;
      }
    }
    
    const newSchedule: Record<string, BreedingScheduleEntry> = {};
    
    for (let i = 0; i < newDuration; i++) {
      const currentDate = new Date(startDate);
      currentDate.setDate(startDate.getDate() + i);
      const dateStr = currentDate.toISOString().split('T')[0];
      
      const scheduleKey = `${maleId}-${dateStr}`;
      newSchedule[scheduleKey] = {
        ...selectedScheduleForEdit,
        femaleId: finalFemaleId,
        femaleName: newFemaleName,
        date: dateStr,
        duration: newDuration,
        dayIndex: i,
      };
    }
    
    setBreedingSchedule((prev) => {
      const updated = { ...prev };
      
      for (let i = 0; i < oldDuration; i++) {
        const currentDate = new Date(startDate);
        currentDate.setDate(startDate.getDate() + i);
        const dateStr = currentDate.toISOString().split('T')[0];
        const scheduleKey = `${maleId}-${dateStr}`;
        delete updated[scheduleKey];
      }
      
      return { ...updated, ...newSchedule };
    });

    const message = newFemaleId && newFemaleId !== femaleId
      ? `äº¤é…æœŸé–“ã‚’${newDuration}æ—¥é–“ã«å¤‰æ›´ã—ã€ãƒ¡ã‚¹çŒ«ã‚’${newFemaleName}ã«å¤‰æ›´ã—ã¾ã—ãŸ`
      : `äº¤é…æœŸé–“ã‚’${newDuration}æ—¥é–“ã«å¤‰æ›´ã—ã¾ã—ãŸ`;

    notifications.show({
      title: 'æ›´æ–°æˆåŠŸ',
      message,
      color: 'green',
    });
  };

  // ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å‰Šé™¤
  const handleDeleteSchedule = () => {
    if (!selectedScheduleForEdit) return;

    const { maleId, date, duration, dayIndex } = selectedScheduleForEdit;
    
    const startDate = new Date(date);
    startDate.setDate(startDate.getDate() - dayIndex);
    
    setBreedingSchedule((prev) => {
      const updated = { ...prev };
      
      for (let i = 0; i < duration; i++) {
        const currentDate = new Date(startDate);
        currentDate.setDate(startDate.getDate() + i);
        const dateStr = currentDate.toISOString().split('T')[0];
        const scheduleKey = `${maleId}-${dateStr}`;
        delete updated[scheduleKey];
      }
      
      return updated;
    });

    notifications.show({
      title: 'å‰Šé™¤æˆåŠŸ',
      message: 'ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
      color: 'green',
    });
  };

  // ãƒ¡ã‚¹çŒ«ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã«è¿½åŠ 
  const handleAddFemaleToSchedule = (femaleId: string) => {
    const female = catsResponse?.data?.find((f: Cat) => f.id === femaleId);
    const male = activeMales.find((m: Cat) => m.id === selectedMale);
    
    if (female && male && selectedDate && selectedMale) {
      const startDate = new Date(selectedDate);
      const scheduleDates: string[] = [];
      for (let i = 0; i < selectedDuration; i++) {
        const date = new Date(startDate);
        date.setDate(startDate.getDate() + i);
        scheduleDates.push(date.toISOString().split('T')[0]);
      }
      
      // ä»–ã®ã‚ªã‚¹çŒ«ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã§åŒã˜ãƒ¡ã‚¹çŒ«ãŒåŒã˜æ—¥ä»˜ã«å…¥ã£ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
      const duplicateMales: string[] = [];
      activeMales.forEach((otherMale: Cat) => {
        if (otherMale.id === selectedMale) return;
        
        scheduleDates.forEach(dateStr => {
          const scheduleKey = `${otherMale.id}-${dateStr}`;
          const schedule = breedingSchedule[scheduleKey];
          if (schedule && schedule.femaleId === femaleId && !schedule.isHistory) {
            if (!duplicateMales.includes(otherMale.name)) {
              duplicateMales.push(otherMale.name);
            }
          }
        });
      });
      
      if (duplicateMales.length > 0) {
        const confirmed = window.confirm(
          `è­¦å‘Š: ${female.name}ã¯æ—¢ã«ä»¥ä¸‹ã®ã‚ªã‚¹çŒ«ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã«å…¥ã£ã¦ã„ã¾ã™ï¼š\n${duplicateMales.join(', ')}\n\næœ¬å½“ã«ã“ã®ãƒ¡ã‚¹çŒ«ã‚’è¿½åŠ ã—ã¾ã™ã‹ï¼Ÿ`
        );
        
        if (!confirmed) {
          closeModal();
          return;
        }
      }
      
      // NGãƒšã‚¢ãƒã‚§ãƒƒã‚¯
      if (isNGPairing(selectedMale, femaleId)) {
        const ngRule = findMatchingRule(selectedMale, femaleId);
        
        const confirmed = window.confirm(
          `è­¦å‘Š: ã“ã®ãƒšã‚¢ã¯ã€Œ${ngRule?.name}ã€ãƒ«ãƒ¼ãƒ«ã«è©²å½“ã—ã¾ã™ã€‚\n${ngRule?.description ?? 'è©³ç´°ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚'}\n\næœ¬å½“ã«äº¤é…ã‚’äºˆå®šã—ã¾ã™ã‹ï¼Ÿ`
        );
        
        if (!confirmed) {
          closeModal();
          return;
        }
      }
      
      // å„æ—¥ä»˜ã«ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¿½åŠ 
      const newSchedules: Record<string, BreedingScheduleEntry> = {};
      scheduleDates.forEach((dateStr, index) => {
        const scheduleKey = `${selectedMale}-${dateStr}`;
        
        const existingPair = breedingSchedule[scheduleKey];
        if (existingPair && index === 0) {
          const success = window.confirm(`å‰å›ã®ãƒšã‚¢ï¼ˆ${male.name} Ã— ${existingPair.femaleName}ï¼‰ã¯æˆåŠŸã—ã¾ã—ãŸã‹ï¼Ÿ`);
          
          if (success) {
            const checkDate = new Date(selectedDate);
            checkDate.setDate(checkDate.getDate() + 21);
            
            createPregnancyCheckMutation.mutate({
              motherId: femaleId,
              checkDate: checkDate.toISOString().split('T')[0],
              status: 'SUSPECTED',
              notes: `${male.name}ã¨ã®äº¤é…ã«ã‚ˆã‚‹å¦Šå¨ ç–‘ã„`,
            });
          }
          
          newSchedules[scheduleKey] = {
            ...existingPair,
            isHistory: true,
            result: success ? 'æˆåŠŸ' : 'å¤±æ•—',
          };
        } else if (!existingPair) {
          newSchedules[scheduleKey] = {
            maleId: selectedMale,
            maleName: male.name,
            femaleId: femaleId,
            femaleName: female.name,
            date: dateStr,
            duration: selectedDuration,
            dayIndex: index,
            isHistory: false,
          };
        }
      });
      
      setBreedingSchedule(prev => ({ ...prev, ...newSchedules }));
    }
    
    closeModal();
  };

  // å¦Šå¨ ç¢ºèª
  const handlePregnancyCheck = (checkItem: PregnancyCheck, isPregnant: boolean) => {
    if (isPregnant) {
      const expectedDate = new Date(checkItem.matingDate || checkItem.checkDate);
      expectedDate.setDate(expectedDate.getDate() + 63);
      
      createBirthPlanMutation.mutate({
        motherId: checkItem.motherId,
        fatherId: checkItem.fatherId ?? undefined,
        matingDate: checkItem.matingDate ?? undefined,
        expectedBirthDate: expectedDate.toISOString().split('T')[0],
        status: 'EXPECTED',
        notes: 'å¦Šå¨ ç¢ºèªã«ã‚ˆã‚‹å‡ºç”£äºˆå®š',
      }, {
        onSuccess: async () => {
          await deletePregnancyCheckMutation.mutateAsync(checkItem.id);
          await Promise.all([
            pregnancyChecksQuery.refetch(),
            birthPlansQuery.refetch(),
          ]);
        }
      });
    } else {
      deletePregnancyCheckMutation.mutate(checkItem.id, {
        onSuccess: () => {
          pregnancyChecksQuery.refetch();
        }
      });
    }
  };

  // å‡ºç”£ç¢ºèª
  const handleBirthConfirm = (item: BirthPlan) => {
    setSelectedBirthPlan(item);
    setBirthCount(0);
    setDeathCount(0);
    setBirthDate(new Date().toISOString().split('T')[0]);
    openBirthInfoModal();
  };

  // å‡ºç”£ã‚­ãƒ£ãƒ³ã‚»ãƒ«
  const handleBirthCancel = (item: BirthPlan) => {
    deleteBirthPlanMutation.mutate(item.id);
  };

  // å‡ºç”£æƒ…å ±ç™»éŒ²
  const handleBirthInfoSubmit = async () => {
    if (!selectedBirthPlan) return;
    
    try {
      const birthDateStr = birthDate;
      const aliveCount = birthCount - deathCount;
      
      await updateBirthPlanMutation.mutateAsync({
        id: selectedBirthPlan.id,
        payload: {
          status: 'BORN',
          actualBirthDate: birthDateStr,
          actualKittens: birthCount,
        },
      });
      
      const createPromises: Promise<unknown>[] = [];
      const motherName = selectedBirthPlan.mother?.name || 'ä¸æ˜';
      
      for (let i = 0; i < aliveCount; i++) {
        const catData: CreateCatRequest = {
          name: `${motherName}${i + 1}å·`,
          gender: 'MALE',
          birthDate: birthDateStr,
          motherId: selectedBirthPlan.motherId,
          fatherId: selectedBirthPlan.fatherId || undefined,
          isInHouse: true,
        };
        
        createPromises.push(createCatMutation.mutateAsync(catData));
      }
      
      await Promise.all(createPromises);
      
      await Promise.all([
        catsQuery.refetch(),
        birthPlansQuery.refetch(),
      ]);
      
      notifications.show({
        title: 'å‡ºç”£ç™»éŒ²å®Œäº†',
        message: `${motherName}ã®å‡ºç”£æƒ…å ±ã‚’ç™»éŒ²ã—ã¾ã—ãŸï¼ˆå‡ºç”£: ${birthCount}é ­ã€ç”Ÿå­˜: ${aliveCount}é ­ã€æ­»äº¡: ${deathCount}é ­ï¼‰`,
        color: 'green',
      });
      
      closeBirthInfoModal();
      setSelectedBirthPlan(null);
      setBirthCount(0);
      setDeathCount(0);
      setBirthDate(new Date().toISOString().split('T')[0]);
    } catch (error) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: error instanceof Error ? error.message : 'å‡ºç”£æƒ…å ±ã®ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ',
        color: 'red',
      });
    }
  };

  // NGãƒ«ãƒ¼ãƒ«å‰Šé™¤
  const handleDeleteRule = (rule: NgPairingRule) => {
    if (confirm(`ãƒ«ãƒ¼ãƒ«ã€Œ${rule.name}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) {
      deleteNgRuleMutation.mutate(rule.id, {
        onSuccess: () => {
          notifications.show({
            title: 'ãƒ«ãƒ¼ãƒ«å‰Šé™¤æˆåŠŸ',
            message: `${rule.name}ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`,
            color: 'green',
          });
        },
        onError: (error) => {
          notifications.show({
            title: 'ã‚¨ãƒ©ãƒ¼',
            message: error instanceof Error ? error.message : 'ãƒ«ãƒ¼ãƒ«ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ',
            color: 'red',
          });
        },
      });
    }
  };

  // NGãƒ«ãƒ¼ãƒ«ä½œæˆ
  const handleCreateRule = () => {
    if (!newRule.name.trim()) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: 'ãƒ«ãƒ¼ãƒ«åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„',
        color: 'red',
      });
      return;
    }

    const ruleData: CreateBreedingNgRuleRequest = {
      name: newRule.name.trim(),
      type: newRule.type,
      description: newRule.description.trim() || undefined,
      maleNames: newRule.maleNames,
      femaleNames: newRule.femaleNames,
      maleConditions: newRule.maleConditions,
      femaleConditions: newRule.femaleConditions,
      generationLimit: newRule.type === 'GENERATION_LIMIT' ? (newRule.generationLimit ?? undefined) : undefined,
      active: true,
    };

    createNgRuleMutation.mutate(ruleData, {
      onSuccess: () => {
        notifications.show({
          title: 'ãƒ«ãƒ¼ãƒ«ä½œæˆæˆåŠŸ',
          message: `${newRule.name}ã‚’ä½œæˆã—ã¾ã—ãŸ`,
          color: 'green',
        });
        closeNewRuleModal();
    setNewRule({
          name: '',
      type: 'TAG_COMBINATION',
      maleNames: [],
      femaleNames: [],
      maleConditions: [],
      femaleConditions: [],
      generationLimit: 3,
      description: '',
        });
      },
      onError: (error) => {
        notifications.show({
          title: 'ã‚¨ãƒ©ãƒ¼',
          message: error instanceof Error ? error.message : 'ãƒ«ãƒ¼ãƒ«ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ',
          color: 'red',
        });
      },
    });
  };

  // å­è‚²ã¦ä¸­ã‚¿ãƒ–ã®å±•é–‹åˆ‡ã‚Šæ›¿ãˆ
  const handleToggleExpand = (motherId: string) => {
    const newExpanded = new Set(expandedRaisingCats);
    if (newExpanded.has(motherId)) {
      newExpanded.delete(motherId);
    } else {
      newExpanded.add(motherId);
    }
    setExpandedRaisingCats(newExpanded);
  };

  // å‡ºç”£è¨˜éŒ²å®Œäº†
  const handleComplete = (birthPlan: BirthPlan) => {
    setSelectedBirthPlanForComplete(birthPlan);
    openCompleteConfirmModal();
  };

  // å‡ºç”£è¨˜éŒ²å®Œäº†ç¢ºå®š
  const handleCompleteConfirm = () => {
    if (selectedBirthPlanForComplete) {
      completeBirthRecordMutation.mutate(selectedBirthPlanForComplete.id, {
        onSuccess: () => {
          closeCompleteConfirmModal();
          setSelectedBirthPlanForComplete(null);
        },
      });
    }
  };

  // å­çŒ«ç®¡ç†ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
  const handleOpenManagementModal = (motherId: string) => {
    setSelectedMotherIdForModal(motherId);
    openManagementModal();
  };

  // å­è‚²ã¦ä¸­ã‚¿ãƒ–ã®æ¯çŒ«æ•°ã‚’è¨ˆç®—
  const mothersWithKittensCount = (catsResponse?.data || []).filter((cat: Cat) => {
    const hasYoungKittens = (catsResponse?.data || []).some((kitten: Cat) => {
      if (kitten.motherId !== cat.id) return false;
      
      const birthDateObj = new Date(kitten.birthDate);
      const now = new Date();
      const ageInMonths = (now.getTime() - birthDateObj.getTime()) / (1000 * 60 * 60 * 24 * 30);
      
      return ageInMonths <= 3;
    });
    
    return hasYoungKittens;
  }).length;

  return (
    <Box 
      style={{ 
        minHeight: '100vh', 
  backgroundColor: 'var(--background-base)',
        position: isFullscreen ? 'fixed' : 'relative',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        zIndex: isFullscreen ? 9999 : 'auto',
        overflow: isFullscreen ? 'hidden' : 'auto',
      }}
    >
      <Container 
        size={isFullscreen ? "100%" : "xl"} 
        style={{ 
          height: isFullscreen ? 'calc(100vh - 80px)' : 'auto',
          overflow: isFullscreen ? 'hidden' : 'visible',
        }}
      >
        <TabsSection
          value={activeTab}
          onChange={setActiveTab}
          mb="md"
          tabs={[
            {
              value: 'schedule',
              label: 'äº¤é…ç®¡ç†',
              icon: <IconCalendar size={16} />,
            },
            {
              value: 'pregnancy',
              label: 'å¦Šå¨ ç¢ºèª',
              icon: <IconHeart size={16} />,
              count: pregnancyChecksResponse?.data?.length || 0,
              badgeColor: 'pink',
            },
            {
              value: 'birth',
              label: 'å‡ºç”£äºˆå®š',
              icon: <IconPaw size={16} />,
              count: birthPlansResponse?.data?.filter((item: BirthPlan) => item.status === 'EXPECTED').length || 0,
              badgeColor: 'orange',
            },
            {
              value: 'raising',
              label: 'å­è‚²ã¦ä¸­',
              icon: <IconBabyCarriage size={16} />,
              count: mothersWithKittensCount || 0,
              badgeColor: 'grape',
            },
            {
              value: 'weight',
              label: 'ä½“é‡ç®¡ç†',
              icon: <IconScale size={16} />,
              badgeColor: 'cyan',
            },
            {
              value: 'shipping',
              label: 'å‡ºè·æº–å‚™',
              icon: <IconTruck size={16} />,
              badgeColor: 'green',
            },
          ]}
        >
          <>
            {activeTab === 'schedule' && (
              <Box pt="md">
                <BreedingScheduleTab
                  isFullscreen={isFullscreen}
                  selectedYear={selectedYear}
                  selectedMonth={selectedMonth}
                  activeMales={activeMales}
                  breedingSchedule={breedingSchedule}
                  selectedMaleForEdit={selectedMaleForEdit}
                  onYearChange={setSelectedYear}
                  onMonthChange={setSelectedMonth}
                  onOpenMaleModal={openMaleModal}
                  onMaleSelect={handleMaleSelect}
                  onMaleNameClick={(maleId) => setSelectedMaleForEdit(selectedMaleForEdit === maleId ? null : maleId)}
                  onRemoveMale={handleRemoveMale}
                  onSaveMaleEdit={() => setSelectedMaleForEdit(null)}
                  onMatingCheck={addMatingCheck}
                  onMatingResult={handleMatingResult}
                  onScheduleContextAction={handleScheduleContextAction}
                  onClearData={clearScheduleData}
                  getMatingCheckCount={getMatingCheckCount}
                />
              </Box>
            )}

            {activeTab === 'pregnancy' && (
              <Box pt="md">
                <PregnancyCheckTab
                  pregnancyChecks={pregnancyChecksResponse?.data || []}
                  allCats={catsResponse?.data || []}
                  onPregnancyCheck={handlePregnancyCheck}
                />
              </Box>
            )}

            {activeTab === 'birth' && (
              <Box pt="md">
                <BirthPlanTab
                  birthPlans={birthPlansResponse?.data || []}
                  allCats={catsResponse?.data || []}
                  onBirthConfirm={handleBirthConfirm}
                  onBirthCancel={handleBirthCancel}
                />
              </Box>
            )}

            {activeTab === 'raising' && (
              <Box pt="md">
                <RaisingTab
                  allCats={catsResponse?.data || []}
                  birthPlans={birthPlansResponse?.data || []}
                  tagCategories={tagCategoriesQuery.data?.data || []}
                  expandedRaisingCats={expandedRaisingCats}
                  isLoading={catsQuery.isLoading}
                  onToggleExpand={handleToggleExpand}
                  onComplete={handleComplete}
                  onOpenManagementModal={handleOpenManagementModal}
                />
              </Box>
            )}

            {activeTab === 'weight' && (
              <Box pt="md">
                <WeightTab
                  allCats={catsResponse?.data || []}
                  birthPlans={birthPlansResponse?.data || []}
                  isLoading={catsQuery.isLoading}
                  onRefetch={() => {
                    if (catsQuery.refetch) catsQuery.refetch();
                  }}
                />
              </Box>
            )}

            {activeTab === 'shipping' && (
              <Box pt="md">
                <ShippingTab
                  allCats={catsResponse?.data || []}
                  birthPlans={birthPlansResponse?.data || []}
                  isLoading={catsQuery.isLoading}
                  onRefetch={() => {
                    if (catsQuery.refetch) catsQuery.refetch();
                    if (birthPlansQuery.refetch) birthPlansQuery.refetch();
                  }}
                />
              </Box>
            )}
          </>
        </TabsSection>
      </Container>

      {/* ãƒ¢ãƒ¼ãƒ€ãƒ«ç¾¤ */}
      <FemaleSelectionModal
        opened={modalOpened}
        onClose={closeModal}
        selectedMale={activeMales.find((m) => m.id === selectedMale) || null}
        availableFemales={availableFemales}
        selectedDuration={selectedDuration}
        onDurationChange={setSelectedDuration}
        onSetDefaultDuration={handleSetDefaultDuration}
        onSelectFemale={handleAddFemaleToSchedule}
        isNGPairing={isNGPairing}
      />

      <MaleSelectionModal
        opened={maleModalOpened}
        onClose={closeMaleModal}
        allCats={catsResponse?.data || []}
        activeMales={activeMales}
        onAddMale={handleAddMale}
      />

      <BirthInfoModal
        opened={birthInfoModalOpened}
        onClose={() => {
          closeBirthInfoModal();
          setSelectedBirthPlan(null);
          setBirthCount(0);
          setDeathCount(0);
          setBirthDate(new Date().toISOString().split('T')[0]);
        }}
        selectedBirthPlan={selectedBirthPlan}
        allCats={catsResponse?.data || []}
        birthCount={birthCount}
        deathCount={deathCount}
        birthDate={birthDate}
        onBirthCountChange={setBirthCount}
        onDeathCountChange={setDeathCount}
        onBirthDateChange={setBirthDate}
        onSubmit={handleBirthInfoSubmit}
        onDetailSubmit={() => {
                console.log('è©³ç´°ç™»éŒ²:', {
                  birthPlan: selectedBirthPlan,
                  birthCount,
                  deathCount,
                });
              }}
        isLoading={updateBirthPlanMutation.isPending || createCatMutation.isPending}
      />

      <BreedingScheduleEditModal
        opened={scheduleEditModalOpened}
        onClose={closeScheduleEditModal}
        schedule={selectedScheduleForEdit}
        availableFemales={(catsResponse?.data ?? []).filter((cat: Cat) => 
          cat.gender === 'FEMALE' &&
          cat.isInHouse &&
          calculateAgeInMonths(cat.birthDate) >= 11
        )}
        onSave={handleUpdateScheduleDuration}
        onDelete={handleDeleteSchedule}
      />

      <KittenManagementModal
        opened={managementModalOpened}
        onClose={closeManagementModal}
        motherId={selectedMotherIdForModal}
        onSuccess={() => {
          if (catsQuery.refetch) catsQuery.refetch();
          if (birthPlansQuery.refetch) birthPlansQuery.refetch();
        }}
      />

      <CompleteConfirmModal
        opened={completeConfirmModalOpened}
        onClose={closeCompleteConfirmModal}
        selectedBirthPlan={selectedBirthPlanForComplete}
        onConfirm={handleCompleteConfirm}
        isLoading={completeBirthRecordMutation.isPending}
      />

      <NgRulesModal
        opened={rulesModalOpened}
        onClose={closeRulesModal}
        ngPairingRules={ngPairingRules}
        isLoading={isNgRulesLoading || isNgRulesFetching}
        error={rulesError}
        onOpenNewRuleModal={openNewRuleModal}
        onDeleteRule={handleDeleteRule}
      />

      <NewRuleModal
        opened={newRuleModalOpened}
        onClose={closeNewRuleModal}
        newRule={newRule}
        onRuleChange={setNewRule}
        availableTags={availableTags}
        allCats={catsResponse?.data || []}
        onSubmit={handleCreateRule}
        isLoading={createNgRuleMutation.isPending}
      />
    </Box>
  );
}
````

## File: frontend/src/app/care/page.tsx
````typescript
'use client';

import { useMemo, useState, useEffect } from 'react';
import {
  ActionIcon,
  Alert,
  Badge,
  Box,
  Button,
  Card,
  Container,
  Divider,
  Group,
  LoadingOverlay,
  Pagination,
  Radio,
  RadioGroup,
  Select,
  Skeleton,
  Stack,
  Switch,
  TextInput,
  Table,
  Text,
  Textarea,
  Checkbox,
  Accordion,
} from '@mantine/core';
import { DatePickerInput } from '@mantine/dates';
import { useDisclosure } from '@mantine/hooks';
import { IconAlertCircle, IconCheck, IconPlus, IconX, IconCalendarPlus, IconLayoutGrid, IconRefresh } from '@tabler/icons-react';
import dayjs from 'dayjs';
import { UnifiedModal } from '@/components/common';

import {
  type CareSchedule,
  type CreateCareScheduleRequest,
  type GetCareSchedulesParams,
  useAddCareSchedule,
  useUpdateCareSchedule,
  useDeleteCareSchedule,
  useCompleteCareSchedule,
  useGetCareSchedules,
} from '@/lib/api/hooks/use-care';
import { useGetCats } from '@/lib/api/hooks/use-cats';
import {
  useGetTagCategories,
  type TagCategoryView,
  type TagView,
} from '@/lib/api/hooks/use-tags';
import { usePageHeader } from '@/lib/contexts/page-header-context';
import { ContextMenuProvider, useContextMenu, OperationModalManager } from '@/components/context-menu';

import { ActionMenu } from '@/app/tenants/_components/ActionMenu';
import { ActionButton } from '@/components/ActionButton';
import { IconActionButton } from '@/components/buttons';

const STATUS_LABELS = {
  PENDING: 'æœªç€æ‰‹',
  IN_PROGRESS: 'é€²è¡Œä¸­',
  COMPLETED: 'å®Œäº†',
  CANCELLED: 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«',
} as const;

const STATUS_COLORS = {
  PENDING: 'yellow',
  IN_PROGRESS: 'blue',
  COMPLETED: 'teal',
  CANCELLED: 'gray',
} as const;

const PAGE_LIMIT = 10;

function formatDate(value: string | null | undefined) {
  if (!value) return '-';
  return dayjs(value).format('YYYYå¹´MMæœˆDDæ—¥');
}

function formatRecurrenceRule(rule: string | null | undefined): string {
  if (!rule) return 'å˜ç™º';
  
  if (rule.includes('FREQ=DAILY')) return 'æ¯æ—¥';
  if (rule.includes('FREQ=WEEKLY')) {
    const dayMatch = rule.match(/BYDAY=([A-Z,]+)/);
    if (dayMatch) {
      const days = dayMatch[1].split(',');
      const dayNames: Record<string, string> = {
        'SU': 'æ—¥', 'MO': 'æœˆ', 'TU': 'ç«', 'WE': 'æ°´',
        'TH': 'æœ¨', 'FR': 'é‡‘', 'SA': 'åœŸ'
      };
      const japDays = days.map(d => dayNames[d] || d).join('ãƒ»');
      return `æ¯é€±${japDays}æ›œæ—¥`;
    }
    return 'æ¯é€±';
  }
  if (rule.includes('FREQ=MONTHLY')) {
    const dayMatch = rule.match(/BYMONTHDAY=(\d+)/);
    if (dayMatch) {
      return `æ¯æœˆ${dayMatch[1]}æ—¥`;
    }
    return 'æ¯æœˆ';
  }
  if (rule.includes('FREQ=YEARLY')) return 'æ¯å¹´';
  return rule;
}

function truncateText(text: string | null | undefined, maxLength = 10): string {
  if (!text) return '-';
  if (text.length <= maxLength) return text;
  return text.substring(0, maxLength) + '...';
}

function buildRecurrenceRule(schedule: CreateScheduleFormState['schedule']): string | undefined {
  if (!schedule || schedule.type === 'single') {
    return undefined;
  }

  switch (schedule.type) {
    case 'daily':
      return 'FREQ=DAILY;INTERVAL=1';
    
    case 'weekly':
      if (schedule.daysOfWeek && schedule.daysOfWeek.length > 0) {
        const days = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];
        const byday = schedule.daysOfWeek.map(d => days[d]).join(',');
        return `FREQ=WEEKLY;INTERVAL=1;BYDAY=${byday}`;
      }
      return 'FREQ=WEEKLY;INTERVAL=1';
    
    case 'monthly':
      if (schedule.dayOfMonth) {
        return `FREQ=MONTHLY;INTERVAL=1;BYMONTHDAY=${schedule.dayOfMonth}`;
      }
      return 'FREQ=MONTHLY;INTERVAL=1';
    
    case 'period':
      // æœŸé–“æŒ‡å®šã®å ´åˆã¯RRULEã§ã¯ãªãçµ‚äº†æ—¥ã‚’ä½¿ç”¨
      return undefined;
    
    case 'birthday':
      // ç”Ÿå¾Œâ—‹æ—¥ç›®ã¯å€‹åˆ¥ã«ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãŒå¿…è¦
      return undefined;
    
    default:
      return undefined;
  }
}


interface CreateScheduleFormState {
  name: string;
  category: 'Male' | 'Female' | 'Kitten' | 'Adult' | null;
  tags: string[];
  selectedCatIds: string[];
  schedule: {
    type: 'daily' | 'weekly' | 'monthly' | 'period' | 'birthday' | 'single';
    startDate?: string | null;
    endDate?: string | null;
    daysOfWeek?: number[];
    dayOfMonth?: number;
    daysAfterBirth?: number;
  } | null;
  description: string;
}

interface CompleteScheduleFormState {
  completedDate: Date | null;
  nextScheduledDate: Date | null;
  notes: string;
}

export default function CarePage() {
  const { setPageHeader } = usePageHeader();
  
  const [page, setPage] = useState(1);
  const [selectedCareNames, setSelectedCareNames] = useState<string[]>([]);
  const [selectedTag, setSelectedTag] = useState<string | null>(null);

  const [createModalOpened, { open: openCreateModal, close: closeCreateModal }] = useDisclosure(false);
  const [addCardModalOpened, { open: openAddCardModal, close: closeAddCardModal }] = useDisclosure(false);
  const [completeModalOpened, { open: openCompleteModal, close: closeCompleteModal }] = useDisclosure(false);
  const [detailModalOpened, { open: openDetailModal, close: closeDetailModal }] = useDisclosure(false);
  const [detailSchedule, setDetailSchedule] = useState<CareSchedule | null>(null);

  const [createForm, setCreateForm] = useState<CreateScheduleFormState>({
    name: '',
    category: null,
    tags: [],
    selectedCatIds: [],
    schedule: null,
    description: '',
  });
  const [createError, setCreateError] = useState<string | null>(null);

  const [completeForm, setCompleteForm] = useState<CompleteScheduleFormState>({
    completedDate: new Date(),
    nextScheduledDate: null,
    notes: '',
  });
  const [targetSchedule, setTargetSchedule] = useState<CareSchedule | null>(null);

  const scheduleParams = useMemo(() => {
    const params: Record<string, unknown> = {
      page,
      limit: PAGE_LIMIT,
    };
    return params as unknown as GetCareSchedulesParams;
  }, [page]);

  const scheduleQuery = useGetCareSchedules(scheduleParams);
  const addScheduleMutation = useAddCareSchedule();
  const updateScheduleMutation = useUpdateCareSchedule();
  const deleteScheduleMutation = useDeleteCareSchedule();
  const completeScheduleMutation = useCompleteCareSchedule();

  const [editModalOpened, { open: openEditModal, close: closeEditModal }] = useDisclosure(false);
  const [deleteModalOpened, { open: openDeleteModal, close: closeDeleteModal }] = useDisclosure(false);
  const [editingSchedule, setEditingSchedule] = useState<CareSchedule | null>(null);
  const [deletingSchedule, setDeletingSchedule] = useState<CareSchedule | null>(null);

  // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼ç”¨ã®çŠ¶æ…‹
  const {
    currentOperation,
    currentEntity,
    handleAction: handleScheduleContextAction,
    openOperation,
    closeOperation,
  } = useContextMenu<CareSchedule>({
    view: (schedule) => {
      if (schedule) {
        setDetailSchedule(schedule);
        openDetailModal();
      }
    },
    edit: (schedule) => {
      if (schedule) {
        setEditingSchedule(schedule);
        openEditModal();
      }
    },
    delete: (schedule) => {
      if (schedule) {
        openOperation('delete', schedule);
      }
    },
  });

  const handleOperationConfirm = () => {
    if (currentOperation === 'delete' && currentEntity) {
      setDeletingSchedule(currentEntity);
      deleteScheduleMutation.mutate(currentEntity.id, {
        onSuccess: () => {
          scheduleQuery.refetch();
          closeOperation();
        },
      });
    }
  };

  const catsQuery = useGetCats({ limit: 100 });

  const tagsQuery = useGetTagCategories();
  
  // ãƒšãƒ¼ã‚¸ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’è¨­å®š
  useEffect(() => {
    setPageHeader(
      'ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«',
      <ActionMenu
        buttonLabel="ã‚±ã‚¢ã®ç™»éŒ²"
        buttonIcon={IconPlus}
        action="create"
        items={[
          {
            id: 'schedule',
            label: 'ã‚±ã‚¢äºˆå®šã‚’è¿½åŠ ',
            icon: <IconCalendarPlus size={16} />,
            onClick: openCreateModal,
          },
          {
            id: 'card',
            label: 'ã‚«ãƒ¼ãƒ‰ã‚’è¿½åŠ ',
            icon: <IconLayoutGrid size={16} />,
            onClick: openAddCardModal,
          }
        ]}
      />
    );

    return () => setPageHeader(null);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  
  const allTags = useMemo(() => {
    try {
      // Return empty array if data is not available or not an array
      if (!tagsQuery.data?.data || !Array.isArray(tagsQuery.data.data)) {
        return [];
      }
      
      // Helper to validate tag has required properties
      const isValidTag = (tag: unknown): tag is TagView => {
        if (!tag || typeof tag !== 'object') return false;
        const t = tag as TagView;
        return typeof t.id === 'string' && typeof t.name === 'string' &&
               t.id.trim() !== '' && t.name.trim() !== '';
      };
      
      // Helper to validate category has required properties
      const isValidCategory = (category: unknown): category is TagCategoryView => {
        if (!category || typeof category !== 'object') return false;
        const c = category as TagCategoryView;
        return typeof c.name === 'string' && c.name.trim() !== '' && Array.isArray(c.tags);
      };
      
      // Use category.tags directly (already computed by useGetTagCategories)
      return tagsQuery.data.data
        .filter(isValidCategory)
        .flatMap((category: TagCategoryView) => 
          (category.tags || [])
            .filter(isValidTag)
            .map((tag: TagView) => ({
              value: tag.id,
              label: tag.name,
              // Temporarily remove group to test
              // group: category.name || 'ãã®ä»–',
            }))
        );
    } catch (error) {
      // Log error and return empty array to prevent crashes
      console.error('Error computing allTags:', error);
      return [];
    }
  }, [tagsQuery.data?.data]);

  // çµã‚Šè¾¼ã¾ã‚ŒãŸçŒ«ã‚’è¨ˆç®—
  const filteredCats = useMemo(() => {
    if (!catsQuery.data?.data) return [];
    let filtered = catsQuery.data.data;

    // ã‚«ãƒ†ã‚´ãƒªã§çµã‚Šè¾¼ã¿
    if (createForm.category) {
      filtered = filtered.filter((cat) => {
        if (createForm.category === 'Male') return cat.gender === 'MALE';
        if (createForm.category === 'Female') return cat.gender === 'FEMALE';
        if (createForm.category === 'Kitten') {
          // ç”Ÿå¾Œ1å¹´æœªæº€ã‚’Kittenã¨ã™ã‚‹
          const birthDate = dayjs(cat.birthDate);
          const oneYearAgo = dayjs().subtract(1, 'year');
          return birthDate.isAfter(oneYearAgo);
        }
        if (createForm.category === 'Adult') {
          // ç”Ÿå¾Œ1å¹´ä»¥ä¸Šã‚’Adultã¨ã™ã‚‹
          const birthDate = dayjs(cat.birthDate);
          const oneYearAgo = dayjs().subtract(1, 'year');
          return birthDate.isBefore(oneYearAgo);
        }
        return true;
      });
    }

    // ã‚¿ã‚°ã§çµã‚Šè¾¼ã¿
    if (createForm.tags.length > 0) {
      filtered = filtered.filter((cat) =>
        createForm.tags.some((tagId) =>
          cat.tags?.some((catTag) => catTag.tag.id === tagId)
        )
      );
    }

    return filtered;
  }, [catsQuery.data?.data, createForm.category, createForm.tags]);

  const schedules = scheduleQuery.data?.data ?? [];
  const meta = scheduleQuery.data?.meta ?? {
    total: 0,
    totalPages: 1,
    page,
    limit: PAGE_LIMIT,
  };

  // ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã‚±ã‚¢åã‚’å–å¾—
  const availableCareNames = useMemo(() => {
    const allSchedules = scheduleQuery.data?.data ?? [];
    const uniqueNames = new Set<string>();
    allSchedules.forEach((schedule) => {
      if (schedule.name) {
        uniqueNames.add(schedule.name);
      }
    });
    return Array.from(uniqueNames).sort();
  }, [scheduleQuery.data?.data]);

  // é¸æŠã•ã‚ŒãŸã‚±ã‚¢åã”ã¨ã®çµ±è¨ˆã‚’è¨ˆç®—
  const selectedCareStats = useMemo(() => {
    const allSchedules = scheduleQuery.data?.data ?? [];
    return selectedCareNames.map((careName) => {
      const relatedSchedules = allSchedules.filter((schedule) => schedule.name === careName);
      const uniqueCats = new Set(relatedSchedules.map((schedule) => schedule.cat?.id).filter(Boolean));
      return {
        name: careName,
        catCount: uniqueCats.size,
      };
    });
  }, [selectedCareNames, scheduleQuery.data?.data]);

  // const handleRefresh = () => {
  //   void scheduleQuery.refetch();
  // };

  const resetCreateForm = () => {
    setCreateForm({
      name: '',
      category: null,
      tags: [],
      selectedCatIds: [],
      schedule: null,
      description: '',
    });
    setSelectedTag(null);
    setCreateError(null);
  };

  const handleCreateSubmit = () => {
    const trimmedName = createForm.name.trim();
    const trimmedDescription = createForm.description.trim();

    if (!trimmedName) {
      setCreateError('ã‚±ã‚¢åã¯å¿…é ˆã§ã™ã€‚');
      return;
    }

    // TODO: ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ 

    setCreateError(null);
    // TODO: æ–°ã—ã„APIã«åˆã‚ã›ã¦é€ä¿¡å‡¦ç†ã‚’æ›´æ–°
    // ä»®ã«è¤‡æ•°çŒ«ã«å¯¾å¿œã—ãŸAPIã‚’ä½¿ç”¨
    const catIds = createForm.selectedCatIds.length > 0 ? createForm.selectedCatIds : filteredCats.map(cat => cat.id);
    
    const recurrenceRule = buildRecurrenceRule(createForm.schedule);
    
    addScheduleMutation.mutate(
      {
        name: trimmedName,
        catIds: catIds,
        careType: 'OTHER',
        scheduledDate: createForm.schedule?.startDate ? dayjs(createForm.schedule.startDate).toISOString() : dayjs().toISOString(),
        description: trimmedDescription || undefined,
        recurrenceRule: recurrenceRule,
      } as CreateCareScheduleRequest,
      {
        onSuccess: () => {
          resetCreateForm();
          closeCreateModal();
          void scheduleQuery.refetch();
        },
      },
    );
  };

  /**
   * ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å®Œäº†ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
   */
  const openCompleteScheduleModal = (schedule: CareSchedule) => {
    setTargetSchedule(schedule);
    setCompleteForm({
      completedDate: new Date(),
      nextScheduledDate: null,
      notes: '',
    });
    openCompleteModal();
  };

  const handleCompleteSubmit = () => {
    if (!targetSchedule) return;

    completeScheduleMutation.mutate(
      {
        id: targetSchedule.id,
        payload: {
          completedDate: dayjs(completeForm.completedDate ?? new Date()).toISOString(),
          nextScheduledDate: completeForm.nextScheduledDate
            ? dayjs(completeForm.nextScheduledDate).toISOString()
            : undefined,
          notes: completeForm.notes.trim() || undefined,
        },
      },
      {
        onSuccess: () => {
          setTargetSchedule(null);
          closeCompleteModal();
          void scheduleQuery.refetch();
        },
      },
    );
  };

  const handleEditSchedule = (schedule: CareSchedule) => {
    setEditingSchedule(schedule);
    // ãƒ•ã‚©ãƒ¼ãƒ ã«æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’è¨­å®š
    setCreateForm({
      name: schedule.name,
      category: null,
      tags: schedule.tags?.map(t => t.id) ?? [],
      selectedCatIds: schedule.cats?.map(c => c.id) ?? [],
      schedule: {
        type: 'single',
        startDate: schedule.scheduleDate,
      },
      description: schedule.description ?? '',
    });
    openEditModal();
  };

  const handleUpdateSubmit = () => {
    if (!editingSchedule) return;

    const trimmedName = createForm.name.trim();
    const trimmedDescription = createForm.description.trim();

    if (!trimmedName) {
      setCreateError('ã‚±ã‚¢åã¯å¿…é ˆã§ã™ã€‚');
      return;
    }

    const catIds = createForm.selectedCatIds.length > 0 ? createForm.selectedCatIds : filteredCats.map(cat => cat.id);
    const recurrenceRule = buildRecurrenceRule(createForm.schedule);

    updateScheduleMutation.mutate(
      {
        id: editingSchedule.id,
        payload: {
          name: trimmedName,
          catIds: catIds,
          careType: 'OTHER',
          scheduledDate: createForm.schedule?.startDate ? dayjs(createForm.schedule.startDate).toISOString() : dayjs().toISOString(),
          description: trimmedDescription || undefined,
          recurrenceRule: recurrenceRule,
        } as CreateCareScheduleRequest,
      },
      {
        onSuccess: () => {
          setEditingSchedule(null);
          resetCreateForm();
          closeEditModal();
          void scheduleQuery.refetch();
        },
      },
    );
  };

  const handleDeleteSchedule = (schedule: CareSchedule) => {
    setDeletingSchedule(schedule);
    openDeleteModal();
  };

  const handleConfirmDelete = () => {
    if (!deletingSchedule) return;

    deleteScheduleMutation.mutate(deletingSchedule.id, {
      onSuccess: () => {
        setDeletingSchedule(null);
        closeDeleteModal();
        void scheduleQuery.refetch();
      },
    });
  };

  const isInitialLoading = scheduleQuery.isLoading && schedules.length === 0;
  const isEmpty = !isInitialLoading && schedules.length === 0;

  return (
    <Container size="lg">
      {/* é¸æŠã•ã‚ŒãŸã‚±ã‚¢åã®ã‚«ãƒ¼ãƒ‰è¡¨ç¤º */}
      {selectedCareStats.length > 0 && (
        <Group grow mb="lg">
          {selectedCareStats.map((stat) => (
            <Card key={stat.name} shadow="xs" padding="md" radius="md" withBorder>
              <Group justify="space-between" align="center">
                <div>
                  <Text size="sm" c="dimmed" mb={4}>
                    {stat.name}
                  </Text>
                  <Text size="xl" fw={700}>
                    {stat.catCount}
                  </Text>
                  <Text size="xs" c="dimmed">
                    é ­
                  </Text>
                </div>
                <ActionIcon
                  variant="subtle"
                  color="red"
                  onClick={() => {
                    setSelectedCareNames((prev) => prev.filter((name) => name !== stat.name));
                  }}
                >
                  <IconX size={16} />
                </ActionIcon>
              </Group>
            </Card>
          ))}
        </Group>
      )}

      <Card withBorder shadow="xs" radius="md">
        <LoadingOverlay visible={scheduleQuery.isFetching && !scheduleQuery.isLoading} zIndex={10} />
        <Stack gap="md">
          {scheduleQuery.isError && (
            <Alert color="red" icon={<IconAlertCircle size={18} />}>
              ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å–å¾—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚æ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚
            </Alert>
          )}

          {isInitialLoading ? (
            <Stack>
              {Array.from({ length: 4 }).map((_, index) => (
                <Skeleton key={index} height={72} radius="md" />
              ))}
            </Stack>
          ) : isEmpty ? (
            <Card padding="xl" radius="md" bg="gray.0">
              <Stack gap="sm" align="center">
                <IconCheck size={28} color="var(--mantine-color-teal-6)" />
                <Text fw={600}>è¡¨ç¤ºã™ã‚‹ã‚±ã‚¢äºˆå®šã¯ã‚ã‚Šã¾ã›ã‚“</Text>
                <Text size="sm" c="dimmed" ta="center">
                  ã‚±ã‚¢äºˆå®šã‚’è¿½åŠ ã—ã¦ã€ã‚±ã‚¢ã®å±¥æ­´ã‚’ç®¡ç†ã—ã¾ã—ã‚‡ã†ã€‚
                </Text>
                <ActionButton
                  action="create"
                  onClick={openCreateModal}
                >
                  ã‚±ã‚¢äºˆå®šã‚’ç™»éŒ²ã™ã‚‹
                </ActionButton>
              </Stack>
            </Card>
          ) : (
            <>
              <Table verticalSpacing="sm" highlightOnHover>
                <Table.Thead>
                  <Table.Tr>
                    <Table.Th style={{ width: '15%' }}>ã‚±ã‚¢å</Table.Th>
                    <Table.Th style={{ width: '20%' }}>ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«</Table.Th>
                    <Table.Th style={{ width: '20%' }}>å†…å®¹</Table.Th>
                    <Table.Th style={{ width: '12%' }}>å¯¾è±¡</Table.Th>
                    <Table.Th style={{ width: '10%' }}>çŠ¶æ…‹</Table.Th>
                    <Table.Th style={{ width: '23%', textAlign: 'center' }}>æ“ä½œ</Table.Th>
                  </Table.Tr>
                </Table.Thead>
                <Table.Tbody>
                  {schedules.map((schedule) => (
                    <ContextMenuProvider
                      key={schedule.id}
                      entity={schedule}
                      entityType="ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«"
                      actions={['view', 'edit', 'delete']}
                      onAction={handleScheduleContextAction}
                    >
                    <Table.Tr style={{ cursor: 'pointer' }} title="å³ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§æ“ä½œ">
                      <Table.Td>
                        <Text size="sm" fw={500}>
                          {schedule.name}
                        </Text>
                      </Table.Td>
                      <Table.Td>
                        <Stack gap={0}>
                          <Text size="sm" fw={500}>
                            {formatDate(schedule.scheduleDate)}
                          </Text>
                          {schedule.recurrenceRule && (
                            <Text size="xs" c="green">
                              {formatRecurrenceRule(schedule.recurrenceRule)}
                            </Text>
                          )}
                        </Stack>
                      </Table.Td>
                      <Table.Td>
                        <Text size="sm" c={schedule.description ? undefined : 'dimmed'}>
                          {schedule.description ? truncateText(schedule.description, 15) : 'ãªã—'}
                        </Text>
                      </Table.Td>
                      <Table.Td>
                        <Text size="sm" fw={500}>
                          {schedule.cats && schedule.cats.length > 0 ? `${schedule.cats.length}é ­` : schedule.cat ? '1é ­' : 'æœªè¨­å®š'}
                        </Text>
                      </Table.Td>
                      <Table.Td>
                        <Switch
                          checked={schedule.status === 'PENDING' || schedule.status === 'IN_PROGRESS'}
                          size="sm"
                          onLabel="æœ‰åŠ¹"
                          offLabel="ç„¡åŠ¹"
                          disabled
                        />
                      </Table.Td>
                      <Table.Td>
                        <Group gap="xs" justify="center">
                          <IconActionButton
                            variant="confirm"
                            label="å®Œäº†ã«ã™ã‚‹"
                            onClick={() => openCompleteScheduleModal(schedule)}
                            disabled={schedule.status === 'COMPLETED'}
                          />
                          <IconActionButton
                            variant="view"
                            onClick={() => {
                              setDetailSchedule(schedule);
                              openDetailModal();
                            }}
                          />
                          <IconActionButton
                            variant="edit"
                            onClick={() => handleEditSchedule(schedule)}
                          />
                          <IconActionButton
                            variant="delete"
                            onClick={() => handleDeleteSchedule(schedule)}
                          />
                        </Group>
                      </Table.Td>
                    </Table.Tr>
                    </ContextMenuProvider>
                  ))}
                </Table.Tbody>
              </Table>

              {meta.totalPages > 1 && (
                <Group justify="center">
                  <Pagination
                    value={meta.page ?? page}
                    onChange={(value) => setPage(value)}
                    total={meta.totalPages}
                    siblings={1}
                  />
                </Group>
              )}
            </>
          )}
        </Stack>
      </Card>

      <UnifiedModal
        opened={detailModalOpened}
        onClose={closeDetailModal}
        title="ã‚±ã‚¢äºˆå®šã®è©³ç´°"
        size="lg"
      >
        {detailSchedule && (
          <>
            <Box>
              <Text size="sm" c="dimmed" mb={4}>
                å¯¾è±¡çŒ«
              </Text>
              {detailSchedule.cats && detailSchedule.cats.length > 0 ? (
                <Stack gap="xs">
                  {detailSchedule.cats.map((cat) => (
                    <Text key={cat.id} fw={500}>{cat.name}</Text>
                  ))}
                  <Text size="xs" c="dimmed">è¨ˆ {detailSchedule.cats.length}é ­</Text>
                </Stack>
              ) : (
                <Text fw={500}>{detailSchedule.cat?.name ?? 'æœªè¨­å®š'}</Text>
              )}
            </Box>

            <Box>
              <Text size="sm" c="dimmed" mb={4}>
                äºˆå®šæ—¥
              </Text>
              <Text fw={500}>{formatDate(detailSchedule.scheduleDate)}</Text>
            </Box>

            {detailSchedule.recurrenceRule && (
              <Box>
                <Text size="sm" c="dimmed" mb={4}>
                  ç¹°ã‚Šè¿”ã—è¨­å®š
                </Text>
                <Group gap="xs">
                  <IconRefresh size={16} color="var(--mantine-color-green-6)" />
                  <Text fw={500} c="green">
                    {formatRecurrenceRule(detailSchedule.recurrenceRule)}
                  </Text>
                </Group>
              </Box>
            )}

            <Box>
              <Text size="sm" c="dimmed" mb={4}>
                è©³ç´°å†…å®¹
              </Text>
              <Text>{detailSchedule.description || 'ãƒ¡ãƒ¢ã¯ç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“'}</Text>
            </Box>

            {detailSchedule.tags && detailSchedule.tags.length > 0 && (
              <Box>
                <Text size="sm" c="dimmed" mb={8}>
                  ã‚¿ã‚°
                </Text>
                <Group gap="xs">
                  {detailSchedule.tags.map((tag) => (
                    <Badge key={tag.id} variant="dot">
                      {tag.label}
                    </Badge>
                  ))}
                </Group>
              </Box>
            )}

            <Divider />

            <Group justify="space-between">
              <Box>
                <Text size="sm" c="dimmed">
                  ç™»éŒ²è€…
                </Text>
                <Text size="sm" fw={500}>
                  {detailSchedule.assignedTo || 'æœªè¨­å®š'}
                </Text>
              </Box>
              <Box>
                <Text size="sm" c="dimmed">
                  ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
                </Text>
                <Badge color={STATUS_COLORS[detailSchedule.status]} variant="light">
                  {STATUS_LABELS[detailSchedule.status]}
                </Badge>
              </Box>
            </Group>

            <Group justify="space-between">
              <Text size="xs" c="dimmed">
                ä½œæˆæ—¥: {dayjs(detailSchedule.createdAt).format('YYYY/MM/DD HH:mm')}
              </Text>
              {detailSchedule.updatedAt && (
                <Text size="xs" c="dimmed">
                  æ›´æ–°æ—¥: {dayjs(detailSchedule.updatedAt).format('YYYY/MM/DD HH:mm')}
                </Text>
              )}
            </Group>

            <Group justify="flex-end" mt="md">
              <ActionButton action="cancel" onClick={closeDetailModal}>
                é–‰ã˜ã‚‹
              </ActionButton>
            </Group>
          </>
        )}
      </UnifiedModal>

      <UnifiedModal 
        opened={createModalOpened} 
        onClose={() => {
          closeCreateModal();
          resetCreateForm();
        }} 
        title="ã‚±ã‚¢äºˆå®šã‚’è¿½åŠ " 
        size="lg"
        sections={[
          {
            label: 'åŸºæœ¬æƒ…å ±',
            content: (
              <>
                <TextInput
                  label="ã‚±ã‚¢å"
                  placeholder="ä¾‹: å¹´æ¬¡å¥åº·è¨ºæ–­"
                  value={createForm.name}
                  onChange={(event) =>
                    setCreateForm((prev) => ({
                      ...prev,
                      name: event.target.value,
                    }))
                  }
                  required
                />

                <RadioGroup
                  label="ã‚«ãƒ†ã‚´ãƒª"
                  value={createForm.category}
                  onChange={(value) => setCreateForm((prev) => ({ ...prev, category: value as 'Male' | 'Female' | 'Kitten' | 'Adult' }))}
                >
                  <Group mt="xs">
                    <Radio value="Male" label="Male" />
                    <Radio value="Female" label="Female" />
                    <Radio value="Kitten" label="Kitten" />
                    <Radio value="Adult" label="Adult" />
                  </Group>
                </RadioGroup>

                <div>
                  <Group grow align="flex-end" gap="xs">
                    <Select
                      label="ã‚¿ã‚°"
                      placeholder="ã‚¿ã‚°ã‚’é¸æŠ"
                      data={allTags || []}
                      value={selectedTag}
                      onChange={(value) => setSelectedTag(value)}
                    />
                    <Button
                      leftSection={<IconPlus size={16} />}
                      onClick={() => {
                        if (selectedTag && !(createForm.tags || []).includes(selectedTag)) {
                          setCreateForm((prev) => ({
                            ...prev,
                            tags: [...(prev.tags || []), selectedTag],
                          }));
                          setSelectedTag(null);
                        }
                      }}
                      disabled={!selectedTag}
                      w="auto"
                    >
                      è¿½åŠ 
                    </Button>
                  </Group>
                  {(createForm.tags || []).length > 0 && (
                    <Group mt="xs" gap="xs">
                      {(createForm.tags || []).map((tagId) => {
                        const tag = allTags.find((t) => t.value === tagId);
                        return (
                          <Badge
                            key={tagId}
                            variant="light"
                            rightSection={
                              <ActionIcon
                                size="xs"
                                variant="transparent"
                                onClick={() =>
                                  setCreateForm((prev) => ({
                                    ...prev,
                                    tags: (prev.tags || []).filter((id) => id !== tagId),
                                  }))
                                }
                              >
                                <IconX size={12} />
                              </ActionIcon>
                            }
                          >
                            {tag?.label || tagId}
                          </Badge>
                        );
                      })}
                    </Group>
                  )}
                </div>
              </>
            ),
          },
          {
            label: 'å¯¾è±¡çŒ«',
            content: (
              <>
                <Group justify="space-between" align="center">
                  <Text size="sm" fw={500}>å¯¾è±¡çŒ«</Text>
                  <Text size="sm" c="dimmed">{filteredCats.length}é ­</Text>
                </Group>

                <Accordion>
                  <Accordion.Item value="select-cats">
                    <Accordion.Control>æ›´ã«é¸æŠã™ã‚‹</Accordion.Control>
                    <Accordion.Panel>
                      <Stack gap="xs">
                        {filteredCats.length === 0 ? (
                          <Text size="sm" c="dimmed">çµã‚Šè¾¼ã¾ã‚ŒãŸçŒ«ãŒã‚ã‚Šã¾ã›ã‚“</Text>
                        ) : (
                          filteredCats.map((cat) => (
                            <Checkbox
                              key={cat.id}
                              label={`${cat.name} (${cat.gender})`}
                              checked={createForm.selectedCatIds.includes(cat.id)}
                              onChange={(event) => {
                                const checked = event.currentTarget.checked;
                                setCreateForm((prev) => ({
                                  ...prev,
                                  selectedCatIds: checked
                                    ? [...prev.selectedCatIds, cat.id]
                                    : prev.selectedCatIds.filter((id) => id !== cat.id),
                                }));
                              }}
                            />
                          ))
                        )}
                      </Stack>
                    </Accordion.Panel>
                  </Accordion.Item>
                </Accordion>
              </>
            ),
          },
          {
            label: 'ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«è¨­å®š',
            content: (
              <>
                <Select
                  label="ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ—"
                  placeholder="ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ—ã‚’é¸æŠ"
                  data={[
                    { value: 'daily', label: 'æ¯æ—¥' },
                    { value: 'weekly', label: 'æ¯é€±â—‹æ›œæ—¥' },
                    { value: 'monthly', label: 'æ¯æœˆâ—‹æ—¥' },
                    { value: 'period', label: 'â—‹æ—¥ã€œâ—‹æ—¥ï¼ˆæœŸé–“æŒ‡å®šï¼‰' },
                    { value: 'birthday', label: 'ç”Ÿå¾Œâ—‹æ—¥ç›®' },
                    { value: 'single', label: 'å˜æ—¥' },
                  ]}
                  value={createForm.schedule?.type || null}
                  onChange={(value) => setCreateForm((prev) => ({
                    ...prev,
                    schedule: value ? { type: value as 'daily' | 'weekly' | 'monthly' | 'period' | 'birthday' | 'single' } : null
                  }))}
                />

                {createForm.schedule?.type === 'weekly' && (
                  <Select
                    label="æ›œæ—¥"
                    placeholder="æ›œæ—¥ã‚’é¸æŠ"
                    data={[
                      { value: '0', label: 'æ—¥æ›œæ—¥' },
                      { value: '1', label: 'æœˆæ›œæ—¥' },
                      { value: '2', label: 'ç«æ›œæ—¥' },
                      { value: '3', label: 'æ°´æ›œæ—¥' },
                      { value: '4', label: 'æœ¨æ›œæ—¥' },
                      { value: '5', label: 'é‡‘æ›œæ—¥' },
                      { value: '6', label: 'åœŸæ›œæ—¥' },
                    ]}
                    value={createForm.schedule.daysOfWeek?.[0]?.toString() || null}
                    onChange={(value) => setCreateForm((prev) => {
                      if (!prev.schedule) {
                        return prev;
                      }
                      return {
                        ...prev,
                        schedule: {
                          ...prev.schedule,
                          daysOfWeek: value ? [parseInt(value, 10)] : [],
                        },
                      };
                    })}
                  />
                )}

                {createForm.schedule?.type === 'monthly' && (
                  <Select
                    label="æ—¥ä»˜"
                    placeholder="æ—¥ä»˜ã‚’é¸æŠ"
                    data={Array.from({ length: 31 }, (_, i) => ({ value: (i + 1).toString(), label: `${i + 1}æ—¥` }))}
                    value={createForm.schedule.dayOfMonth?.toString() || null}
                    onChange={(value) => setCreateForm((prev) => {
                      if (!prev.schedule) {
                        return prev;
                      }
                      return {
                        ...prev,
                        schedule: {
                          ...prev.schedule,
                          dayOfMonth: value ? parseInt(value, 10) : undefined,
                        },
                      };
                    })}
                  />
                )}

                {createForm.schedule?.type === 'period' && (
                  <Group grow>
                    <DatePickerInput
                      label="é–‹å§‹æ—¥"
                      value={createForm.schedule.startDate ? new Date(createForm.schedule.startDate) : null}
                      onChange={(value) => setCreateForm((prev) => ({
                        ...prev,
                        schedule: prev.schedule ? {
                          ...prev.schedule,
                          startDate: value
                        } : null
                      }))}
                    />
                    <DatePickerInput
                      label="çµ‚äº†æ—¥"
                      value={createForm.schedule.endDate ? new Date(createForm.schedule.endDate) : null}
                      onChange={(value) => setCreateForm((prev) => ({
                        ...prev,
                        schedule: prev.schedule ? {
                          ...prev.schedule,
                          endDate: value
                        } : null
                      }))}
                    />
                  </Group>
                )}

                {createForm.schedule?.type === 'birthday' && (
                  <TextInput
                    label="ç”Ÿå¾Œæ—¥æ•°"
                    placeholder="ä¾‹: 21"
                    type="number"
                    value={createForm.schedule.daysAfterBirth?.toString() || ''}
                    onChange={(event) => setCreateForm((prev) => {
                      if (!prev.schedule) {
                        return prev;
                      }
                      const value = parseInt(event.target.value, 10);
                      return {
                        ...prev,
                        schedule: {
                          ...prev.schedule,
                          daysAfterBirth: Number.isNaN(value) ? undefined : value,
                        },
                      };
                    })}
                  />
                )}

                {createForm.schedule?.type === 'single' && (
                  <DatePickerInput
                    label="æ—¥ä»˜"
                    value={createForm.schedule.startDate ? new Date(createForm.schedule.startDate) : null}
                    onChange={(value) => setCreateForm((prev) => ({
                      ...prev,
                      schedule: prev.schedule ? {
                        ...prev.schedule,
                        startDate: value
                      } : null
                    }))}
                  />
                )}

                <Textarea
                  label="å‚™è€ƒ"
                  placeholder="ã‚±ã‚¢ã®è©³ç´°ã‚„ãƒ¡ãƒ¢ã‚’å…¥åŠ›ï¼ˆä»»æ„ï¼‰"
                  value={createForm.description}
                  onChange={(event) => setCreateForm((prev) => ({ ...prev, description: event.target.value }))}
                  minRows={3}
                  autosize
                />

                {createError && (
                  <Alert color="red" icon={<IconAlertCircle size={16} />}>
                    {createError}
                  </Alert>
                )}
              </>
            ),
          },
          {
            content: (
              <Group justify="flex-end">
                <ActionButton action="cancel" onClick={() => {
                  closeCreateModal();
                  resetCreateForm();
                }}>
                  ã‚­ãƒ£ãƒ³ã‚»ãƒ«
                </ActionButton>
                <ActionButton action="save" onClick={handleCreateSubmit} loading={addScheduleMutation.isPending}>
                  ç™»éŒ²ã™ã‚‹
                </ActionButton>
              </Group>
            ),
          },
        ]}
      />

      {/* ã‚«ãƒ¼ãƒ‰ã‚’è¿½åŠ ãƒ¢ãƒ¼ãƒ€ãƒ« */}
      <UnifiedModal
        opened={addCardModalOpened}
        onClose={closeAddCardModal}
        title="ã‚«ãƒ¼ãƒ‰ã‚’è¿½åŠ "
        size="sm"
      >
        <Text size="sm" c="dimmed">
          çµ±è¨ˆã‚«ãƒ¼ãƒ‰ã¨ã—ã¦è¡¨ç¤ºã™ã‚‹ã‚±ã‚¢åã‚’é¸æŠã—ã¦ãã ã•ã„
        </Text>
        <Select
          placeholder="ã‚±ã‚¢åã‚’é¸æŠ"
          data={(availableCareNames || []).map((name) => ({ value: name, label: name }))}
          value={null}
          onChange={(value) => {
            if (value && !selectedCareNames.includes(value)) {
              setSelectedCareNames((prev) => [...prev, value]);
              closeAddCardModal();
            }
          }}
          searchable
        />

        <Divider />

        <Group justify="flex-end" mt="md">
          <ActionButton action="cancel" onClick={closeAddCardModal}>
            ã‚­ãƒ£ãƒ³ã‚»ãƒ«
          </ActionButton>
        </Group>
      </UnifiedModal>

      <UnifiedModal 
        opened={completeModalOpened} 
        onClose={() => {
          closeCompleteModal();
          setTargetSchedule(null);
        }} 
        title={targetSchedule ? `${targetSchedule.cat?.name ?? 'æœªè¨­å®š'} - ${targetSchedule.name || targetSchedule.title} ã‚’å®Œäº†` : 'ã‚±ã‚¢å®Œäº†å‡¦ç†'} 
        size="lg"
        sections={targetSchedule ? [
          {
            label: 'ã‚±ã‚¢äºˆå®šè©³ç´°',
            content: (
              <Card withBorder shadow="xs" radius="md">
                <Stack gap={4}>
                  <Group justify="space-between">
                    <Text size="sm" c="dimmed">
                      äºˆå®šæ—¥: {formatDate(targetSchedule.scheduleDate)}
                    </Text>
                  </Group>
                  <Stack gap={2}>
                    <Text fw={600}>{targetSchedule.name || targetSchedule.title}</Text>
                    <Text size="sm">{targetSchedule.description ?? 'ãƒ¡ãƒ¢ã¯ç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“'}</Text>
                  </Stack>
                </Stack>
              </Card>
            ),
          },
          {
            label: 'å®Œäº†æƒ…å ±',
            content: (
              <>
                <DatePickerInput
                  label="å®Œäº†æ—¥"
                  placeholder="å®Œäº†æ—¥ã‚’é¸æŠ"
                  value={completeForm.completedDate}
                  onChange={(value) =>
                    setCompleteForm((prev) => ({
                      ...prev,
                      completedDate: value ? new Date(value) : null,
                    }))
                  }
                  required
                />

                <DatePickerInput
                  label="æ¬¡å›äºˆå®šæ—¥ (ä»»æ„)"
                  placeholder="æ¬¡å›ã‚±ã‚¢ã‚’äºˆå®šã—ã¦ã„ã‚‹å ´åˆã¯é¸æŠ"
                  value={completeForm.nextScheduledDate}
                  onChange={(value) =>
                    setCompleteForm((prev) => ({
                      ...prev,
                      nextScheduledDate: value ? new Date(value) : null,
                    }))
                  }
                  minDate={completeForm.completedDate ?? undefined}
                />

                <Textarea
                  label="ãƒ¡ãƒ¢"
                  placeholder="ã‚±ã‚¢å†…å®¹ã®è©³ç´°ã€ä½“èª¿ã€æ¬¡å›ã®æ³¨æ„ç‚¹ãªã©"
                  value={completeForm.notes}
                  onChange={(event) => setCompleteForm((prev) => ({ ...prev, notes: event.target.value }))}
                  autosize
                  minRows={3}
                />
              </>
            ),
          },
          {
            content: (
              <Group justify="flex-end">
                <ActionButton
                  action="cancel"
                  onClick={() => {
                    closeCompleteModal();
                    setTargetSchedule(null);
                  }}
                >
                  ã‚­ãƒ£ãƒ³ã‚»ãƒ«
                </ActionButton>
                <ActionButton
                  action="confirm"
                  onClick={handleCompleteSubmit}
                  loading={completeScheduleMutation.isPending}
                >
                  å®Œäº†ã¨ã—ã¦è¨˜éŒ²
                </ActionButton>
              </Group>
            ),
          },
        ] : [
          {
            content: (
              <Text size="sm" c="dimmed">
                å¯¾è±¡ã®ã‚±ã‚¢äºˆå®šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚
              </Text>
            ),
          },
        ]}
      />

      {/* ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ« */}
      <UnifiedModal
        opened={editModalOpened}
        onClose={() => {
          closeEditModal();
          setEditingSchedule(null);
          resetCreateForm();
        }}
        title="ã‚±ã‚¢äºˆå®šã‚’ç·¨é›†"
        size="lg"
      >
          <TextInput
            label="ã‚±ã‚¢å"
            placeholder="ä¾‹: å¹´æ¬¡å¥åº·è¨ºæ–­"
            value={createForm.name}
            onChange={(event) =>
              setCreateForm((prev) => ({
                ...prev,
                name: event.target.value,
              }))
            }
            required
          />

          <RadioGroup
            label="ã‚«ãƒ†ã‚´ãƒª"
            value={createForm.category}
            onChange={(value) => setCreateForm((prev) => ({ ...prev, category: value as 'Male' | 'Female' | 'Kitten' | 'Adult' }))}
          >
            <Group mt="xs">
              <Radio value="Male" label="Male" />
              <Radio value="Female" label="Female" />
              <Radio value="Kitten" label="Kitten" />
              <Radio value="Adult" label="Adult" />
            </Group>
          </RadioGroup>

          <div>
            <Group grow align="flex-end" gap="xs">
              <Select
                label="ã‚¿ã‚°"
                placeholder="ã‚¿ã‚°ã‚’é¸æŠ"
                data={allTags || []}
                value={selectedTag}
                onChange={(value) => setSelectedTag(value)}
              />
              <Button
                leftSection={<IconPlus size={16} />}
                onClick={() => {
                  if (selectedTag && !(createForm.tags || []).includes(selectedTag)) {
                    setCreateForm((prev) => ({
                      ...prev,
                      tags: [...(prev.tags || []), selectedTag],
                    }));
                    setSelectedTag(null);
                  }
                }}
                disabled={!selectedTag}
                w="auto"
              >
                è¿½åŠ 
              </Button>
            </Group>
            {(createForm.tags || []).length > 0 && (
              <Group mt="xs" gap="xs">
                {(createForm.tags || []).map((tagId) => {
                  const tag = allTags.find((t) => t.value === tagId);
                  return (
                    <Badge
                      key={tagId}
                      variant="light"
                      rightSection={
                        <ActionIcon
                          size="xs"
                          variant="transparent"
                          onClick={() =>
                            setCreateForm((prev) => ({
                              ...prev,
                              tags: (prev.tags || []).filter((id) => id !== tagId),
                            }))
                          }
                        >
                          <IconX size={12} />
                        </ActionIcon>
                      }
                    >
                      {tag?.label || tagId}
                    </Badge>
                  );
                })}
              </Group>
            )}
          </div>

          <Group justify="space-between" align="center">
            <Text size="sm" fw={500}>å¯¾è±¡çŒ«</Text>
            <Text size="sm" c="dimmed">{filteredCats.length}é ­</Text>
          </Group>

          <Accordion>
            <Accordion.Item value="select-cats">
              <Accordion.Control>æ›´ã«é¸æŠã™ã‚‹</Accordion.Control>
              <Accordion.Panel>
                <Stack gap="xs">
                  {filteredCats.length === 0 ? (
                    <Text size="sm" c="dimmed">çµã‚Šè¾¼ã¾ã‚ŒãŸçŒ«ãŒã‚ã‚Šã¾ã›ã‚“</Text>
                  ) : (
                    filteredCats.map((cat) => (
                      <Checkbox
                        key={cat.id}
                        label={`${cat.name} (${cat.gender})`}
                        checked={createForm.selectedCatIds.includes(cat.id)}
                        onChange={(event) => {
                          const checked = event.currentTarget.checked;
                          setCreateForm((prev) => ({
                            ...prev,
                            selectedCatIds: checked
                              ? [...prev.selectedCatIds, cat.id]
                              : prev.selectedCatIds.filter((id) => id !== cat.id),
                          }));
                        }}
                      />
                    ))
                  )}
                </Stack>
              </Accordion.Panel>
            </Accordion.Item>
          </Accordion>

          <Select
            label="ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ—"
            placeholder="ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ—ã‚’é¸æŠ"
            data={[
              { value: 'daily', label: 'æ¯æ—¥' },
              { value: 'weekly', label: 'æ¯é€±â—‹æ›œæ—¥' },
              { value: 'monthly', label: 'æ¯æœˆâ—‹æ—¥' },
              { value: 'period', label: 'â—‹æ—¥ã€œâ—‹æ—¥ï¼ˆæœŸé–“æŒ‡å®šï¼‰' },
              { value: 'birthday', label: 'ç”Ÿå¾Œâ—‹æ—¥ç›®' },
              { value: 'single', label: 'å˜æ—¥' },
            ]}
            value={createForm.schedule?.type || null}
            onChange={(value) => setCreateForm((prev) => ({
              ...prev,
              schedule: value ? { type: value as 'daily' | 'weekly' | 'monthly' | 'period' | 'birthday' | 'single' } : null
            }))}
          />

          {createForm.schedule?.type === 'weekly' && (
            <Select
              label="æ›œæ—¥"
              placeholder="æ›œæ—¥ã‚’é¸æŠ"
              data={[
                { value: '0', label: 'æ—¥æ›œæ—¥' },
                { value: '1', label: 'æœˆæ›œæ—¥' },
                { value: '2', label: 'ç«æ›œæ—¥' },
                { value: '3', label: 'æ°´æ›œæ—¥' },
                { value: '4', label: 'æœ¨æ›œæ—¥' },
                { value: '5', label: 'é‡‘æ›œæ—¥' },
                { value: '6', label: 'åœŸæ›œæ—¥' },
              ]}
              value={createForm.schedule.daysOfWeek?.[0]?.toString() || null}
              onChange={(value) => setCreateForm((prev) => {
                if (!prev.schedule) {
                  return prev;
                }
                return {
                  ...prev,
                  schedule: {
                    ...prev.schedule,
                    daysOfWeek: value ? [parseInt(value, 10)] : [],
                  },
                };
              })}
            />
          )}

          {createForm.schedule?.type === 'monthly' && (
            <Select
              label="æ—¥ä»˜"
              placeholder="æ—¥ä»˜ã‚’é¸æŠ"
              data={Array.from({ length: 31 }, (_, i) => ({ value: (i + 1).toString(), label: `${i + 1}æ—¥` }))}
              value={createForm.schedule.dayOfMonth?.toString() || null}
              onChange={(value) => setCreateForm((prev) => {
                if (!prev.schedule) {
                  return prev;
                }
                return {
                  ...prev,
                  schedule: {
                    ...prev.schedule,
                    dayOfMonth: value ? parseInt(value, 10) : undefined,
                  },
                };
              })}
            />
          )}

          {createForm.schedule?.type === 'period' && (
            <Group grow>
              <DatePickerInput
                label="é–‹å§‹æ—¥"
                value={createForm.schedule.startDate ? new Date(createForm.schedule.startDate) : null}
                onChange={(value) => setCreateForm((prev) => ({
                  ...prev,
                  schedule: prev.schedule ? {
                    ...prev.schedule,
                    startDate: value
                  } : null
                }))}
              />
              <DatePickerInput
                label="çµ‚äº†æ—¥"
                value={createForm.schedule.endDate ? new Date(createForm.schedule.endDate) : null}
                onChange={(value) => setCreateForm((prev) => ({
                  ...prev,
                  schedule: prev.schedule ? {
                    ...prev.schedule,
                    endDate: value
                  } : null
                }))}
              />
            </Group>
          )}

          {createForm.schedule?.type === 'birthday' && (
            <TextInput
              label="ç”Ÿå¾Œæ—¥æ•°"
              placeholder="ä¾‹: 21"
              type="number"
              value={createForm.schedule.daysAfterBirth?.toString() || ''}
              onChange={(event) => setCreateForm((prev) => {
                if (!prev.schedule) {
                  return prev;
                }
                const value = parseInt(event.target.value, 10);
                return {
                  ...prev,
                  schedule: {
                    ...prev.schedule,
                    daysAfterBirth: Number.isNaN(value) ? undefined : value,
                  },
                };
              })}
            />
          )}

          {createForm.schedule?.type === 'single' && (
            <DatePickerInput
              label="æ—¥ä»˜"
              value={createForm.schedule.startDate ? new Date(createForm.schedule.startDate) : null}
              onChange={(value) => setCreateForm((prev) => ({
                ...prev,
                schedule: prev.schedule ? {
                  ...prev.schedule,
                  startDate: value
                } : null
              }))}
            />
          )}

          <Textarea
            label="å‚™è€ƒ"
            placeholder="ã‚±ã‚¢ã®è©³ç´°ã‚„ãƒ¡ãƒ¢ã‚’å…¥åŠ›ï¼ˆä»»æ„ï¼‰"
            value={createForm.description}
            onChange={(event) => setCreateForm((prev) => ({ ...prev, description: event.target.value }))}
            minRows={3}
            autosize
          />

          {createError && (
            <Alert color="red" icon={<IconAlertCircle size={16} />}>
              {createError}
            </Alert>
          )}

          <Divider />

          <Group justify="flex-end">
            <ActionButton
              action="cancel"
              onClick={() => {
                closeEditModal();
                setEditingSchedule(null);
                resetCreateForm();
              }}
            >
              ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            </ActionButton>
            <ActionButton action="save" onClick={handleUpdateSubmit} loading={updateScheduleMutation.isPending}>
              æ›´æ–°
            </ActionButton>
          </Group>
      </UnifiedModal>

      {/* å‰Šé™¤ç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ« */}
      <UnifiedModal
        opened={deleteModalOpened}
        onClose={() => {
          closeDeleteModal();
          setDeletingSchedule(null);
        }}
        title="ã‚±ã‚¢äºˆå®šã‚’å‰Šé™¤"
        size="md"
      >
        {deletingSchedule && (
          <>
            <Alert color="red" icon={<IconAlertCircle size={18} />}>
              ä»¥ä¸‹ã®ã‚±ã‚¢äºˆå®šã‚’å‰Šé™¤ã—ã¾ã™ã€‚ã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚
            </Alert>

            <Box>
              <Text size="sm" c="dimmed">
                ã‚±ã‚¢å
              </Text>
              <Text fw={600}>{deletingSchedule.name}</Text>
            </Box>

            <Box>
              <Text size="sm" c="dimmed">
                å¯¾è±¡çŒ«
              </Text>
              <Text>{deletingSchedule.cats.length}é ­</Text>
            </Box>

            <Divider />

            <Group justify="flex-end">
              <ActionButton
                action="cancel"
                onClick={() => {
                  closeDeleteModal();
                  setDeletingSchedule(null);
                }}
              >
                ã‚­ãƒ£ãƒ³ã‚»ãƒ«
              </ActionButton>
              <ActionButton
                action="delete"
                onClick={handleConfirmDelete}
                loading={deleteScheduleMutation.isPending}
              >
                å‰Šé™¤
              </ActionButton>
            </Group>
          </>
        )}
      </UnifiedModal>

      {/* ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼æ“ä½œãƒ¢ãƒ¼ãƒ€ãƒ« */}
      <OperationModalManager
        operationType={currentOperation}
        entity={currentEntity}
        entityType="ã‚±ã‚¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«"
        onClose={closeOperation}
        onConfirm={handleOperationConfirm}
      />
    </Container>
  );
}
````

## File: frontend/src/app/gallery/components/GalleryAddModal.tsx
````typescript
'use client';

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼è¿½åŠ ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * æ–°è¦ã‚¨ãƒ³ãƒˆãƒªã®ä½œæˆãƒ•ã‚©ãƒ¼ãƒ 
 */

import { useState } from 'react';
import {
  Stack,
  TextInput,
  Select,
  Textarea,
  Button,
  Group,
  Text,
  Box,
} from '@mantine/core';
import { DateInput } from '@mantine/dates';
import { useForm } from '@mantine/form';
import { IconPlus } from '@tabler/icons-react';
import { ImageUploader } from './ImageUploader';
import { YouTubeInput } from './YouTubeInput';
import { UnifiedModal, type ModalSection } from '@/components/common';
import type {
  GalleryCategory,
  CreateGalleryEntryDto,
} from '@/lib/api/hooks/use-gallery';

interface MediaItem {
  type: 'IMAGE' | 'YOUTUBE';
  url: string;
  thumbnailUrl?: string;
}

interface FormValues {
  name: string;
  gender: string;
  coatColor: string;
  breed: string;
  transferDate: Date | null;
  destination: string;
  externalLink: string;
  notes: string;
}

interface GalleryAddModalProps {
  /** è¡¨ç¤º/éè¡¨ç¤º */
  opened: boolean;
  /** é–‰ã˜ã‚‹æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
  onClose: () => void;
  /** ç¾åœ¨ã®ã‚«ãƒ†ã‚´ãƒª */
  category: GalleryCategory;
  /** é€ä¿¡æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
  onSubmit: (dto: CreateGalleryEntryDto) => void;
  /** é€ä¿¡ä¸­ãƒ•ãƒ©ã‚° */
  loading?: boolean;
}

/**
 * ã‚«ãƒ†ã‚´ãƒªåˆ¥ã®ãƒ•ã‚©ãƒ¼ãƒ ã‚¿ã‚¤ãƒˆãƒ«
 */
const CATEGORY_TITLES: Record<GalleryCategory, string> = {
  KITTEN: 'å­çŒ«ã‚’è¿½åŠ ',
  FATHER: 'çˆ¶çŒ«ã‚’è¿½åŠ ',
  MOTHER: 'æ¯çŒ«ã‚’è¿½åŠ ',
  GRADUATION: 'å’æ¥­çŒ«ã‚’è¿½åŠ ',
};

/**
 * æ€§åˆ¥ã‚ªãƒ—ã‚·ãƒ§ãƒ³
 */
const GENDER_OPTIONS = [
  { value: 'MALE', label: 'ã‚ªã‚¹' },
  { value: 'FEMALE', label: 'ãƒ¡ã‚¹' },
  { value: 'NEUTER', label: 'å»å‹¢æ¸ˆã¿ã‚ªã‚¹' },
  { value: 'SPAY', label: 'é¿å¦Šæ¸ˆã¿ãƒ¡ã‚¹' },
];

/**
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼è¿½åŠ ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 *
 * @example
 * ```tsx
 * <GalleryAddModal
 *   opened={modalOpened}
 *   onClose={() => setModalOpened(false)}
 *   category="KITTEN"
 *   onSubmit={(dto) => createEntry(dto)}
 *   loading={isPending}
 * />
 * ```
 */
export function GalleryAddModal({
  opened,
  onClose,
  category,
  onSubmit,
  loading,
}: GalleryAddModalProps) {
  const [mediaItems, setMediaItems] = useState<MediaItem[]>([]);

  const form = useForm<FormValues>({
    initialValues: {
      name: '',
      gender: '',
      coatColor: '',
      breed: '',
      transferDate: null,
      destination: '',
      externalLink: '',
      notes: '',
    },
    validate: {
      name: (value) => (value.trim() ? null : 'åå‰ã¯å¿…é ˆã§ã™'),
      gender: (value) => (value ? null : 'æ€§åˆ¥ã‚’é¸æŠã—ã¦ãã ã•ã„'),
    },
  });

  const handleClose = () => {
    form.reset();
    setMediaItems([]);
    onClose();
  };

  const handleSubmit = (values: FormValues) => {
    const dto: CreateGalleryEntryDto = {
      category,
      name: values.name.trim(),
      gender: values.gender,
      coatColor: values.coatColor.trim() || undefined,
      breed: values.breed.trim() || undefined,
      transferDate: values.transferDate
        ? values.transferDate.toISOString().split('T')[0]
        : undefined,
      destination: values.destination.trim() || undefined,
      externalLink: values.externalLink.trim() || undefined,
      notes: values.notes.trim() || undefined,
      media: mediaItems.map((m, index) => ({
        type: m.type,
        url: m.url,
        thumbnailUrl: m.thumbnailUrl,
        order: index,
      })),
    };

    onSubmit(dto);
  };

  const handleImageUploaded = (url: string) => {
    setMediaItems((prev) => [...prev, { type: 'IMAGE', url }]);
  };

  const handleYouTubeAdded = (url: string, thumbnailUrl?: string) => {
    setMediaItems((prev) => [
      ...prev,
      { type: 'YOUTUBE', url, thumbnailUrl },
    ]);
  };

  const handleRemoveMedia = (index: number) => {
    setMediaItems((prev) => prev.filter((_, i) => i !== index));
  };

  const sections: ModalSection[] = [
    {
      label: 'åŸºæœ¬æƒ…å ±',
      content: (
        <>
          <TextInput
            label="åå‰"
            placeholder="çŒ«ã®åå‰ã‚’å…¥åŠ›"
            required
            {...form.getInputProps('name')}
          />

          <Group grow>
            <Select
              label="æ€§åˆ¥"
              placeholder="é¸æŠã—ã¦ãã ã•ã„"
              data={GENDER_OPTIONS}
              required
              {...form.getInputProps('gender')}
            />
            <TextInput
              label="æ¯›è‰²"
              placeholder="ä¾‹: èŒ¶ãƒˆãƒ©"
              {...form.getInputProps('coatColor')}
            />
          </Group>

          <TextInput
            label="çŒ«ç¨®"
            placeholder="ä¾‹: ã‚¢ãƒ¡ãƒªã‚«ãƒ³ã‚·ãƒ§ãƒ¼ãƒˆãƒ˜ã‚¢"
            {...form.getInputProps('breed')}
          />
        </>
      ),
    },
    ...(category === 'GRADUATION' ? [{
      label: 'å’æ¥­æƒ…å ±',
      content: (
        <Group grow>
          <DateInput
            label="å’æ¥­æ—¥"
            placeholder="æ—¥ä»˜ã‚’é¸æŠ"
            valueFormat="YYYY/MM/DD"
            {...form.getInputProps('transferDate')}
          />
          <TextInput
            label="ãŠå±Šã‘å…ˆ"
            placeholder="ä¾‹: æ±äº¬éƒ½"
            {...form.getInputProps('destination')}
          />
        </Group>
      ),
    }] : []),
    {
      label: 'å†™çœŸãƒ»å‹•ç”»',
      content: (
        <Stack gap="sm">
          {mediaItems.length > 0 && (
            <Stack gap="xs">
              <Text size="sm" fw={500}>
                è¿½åŠ æ¸ˆã¿ ({mediaItems.length}ä»¶)
              </Text>
              {mediaItems.map((item, index) => (
                <Group key={index} justify="space-between">
                  <Text size="sm" c="dimmed" lineClamp={1}>
                    {item.type === 'YOUTUBE' ? 'ğŸ¬ YouTubeå‹•ç”»' : 'ğŸ–¼ï¸ ç”»åƒ'}:{' '}
                    {item.url.substring(0, 50)}...
                  </Text>
                  <Button
                    variant="subtle"
                    color="red"
                    size="xs"
                    onClick={() => handleRemoveMedia(index)}
                  >
                    å‰Šé™¤
                  </Button>
                </Group>
              ))}
            </Stack>
          )}

          <ImageUploader onUploaded={handleImageUploaded} />
          <YouTubeInput onAdded={handleYouTubeAdded} />
        </Stack>
      ),
    },
    {
      label: 'ãã®ä»–',
      content: (
        <>
          <TextInput
            label="å¤–éƒ¨ãƒªãƒ³ã‚¯"
            placeholder="https://..."
            {...form.getInputProps('externalLink')}
          />

          <Textarea
            label="ãƒ¡ãƒ¢"
            placeholder="å‚™è€ƒãªã©"
            rows={3}
            {...form.getInputProps('notes')}
          />
        </>
      ),
    },
    {
      content: (
        <Group justify="flex-end" mt="md">
          <Button variant="subtle" onClick={handleClose} disabled={loading}>
            ã‚­ãƒ£ãƒ³ã‚»ãƒ«
          </Button>
          <Button
            type="submit"
            leftSection={<IconPlus size={16} />}
            loading={loading}
          >
            è¿½åŠ 
          </Button>
        </Group>
      ),
    },
  ];

  return (
    <Box component="form" onSubmit={form.onSubmit(handleSubmit)}>
      <UnifiedModal
        opened={opened}
        onClose={handleClose}
        title={CATEGORY_TITLES[category]}
        size="lg"
        centered
        sections={sections}
      />
    </Box>
  );
}
````

## File: frontend/src/app/pedigrees/page.tsx
````typescript
'use client';

import { Container, Tabs } from '@mantine/core';
import { PedigreeRegistrationForm } from '@/components/pedigrees/PedigreeRegistrationForm';
import { PedigreeList } from '@/components/pedigrees/PedigreeList';
import { PedigreeFamilyTree } from '@/components/pedigrees/PedigreeFamilyTree';
import { PrintSettingsEditor } from '@/components/pedigrees/PrintSettingsEditor';
import { IconPlus, IconList, IconBinaryTree, IconSettings } from '@tabler/icons-react';
import { useState, useEffect } from 'react';
import { usePageHeader } from '@/lib/contexts/page-header-context';
import { usePathname, useRouter, useSearchParams } from 'next/navigation';

export default function PedigreesPage() {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();
  const tabParam = searchParams.get('tab') || 'register';
  const treeIdParam = searchParams.get('id');
  const [selectedFamilyTreeId, setSelectedFamilyTreeId] = useState<string | null>(null);
  const { setPageTitle } = usePageHeader();

  useEffect(() => {
    setPageTitle('è¡€çµ±æ›¸ç®¡ç†');
    return () => setPageTitle(null);
  }, [setPageTitle]);

  const handleFamilyTreeSelect = (id: string) => {
    const nextParams = new URLSearchParams(searchParams);
    nextParams.set('tab', 'tree');
    nextParams.set('id', id);
    nextParams.delete('copyFromId');
    router.push(`${pathname}?${nextParams.toString()}`);
  };

  const handleTabChange = (nextTab: string | null) => {
    if (!nextTab) return;
    const nextParams = new URLSearchParams(searchParams);
    nextParams.set('tab', nextTab);

    if (nextTab !== 'tree') {
      nextParams.delete('id');
    }

    if (nextTab !== 'register') {
      nextParams.delete('copyFromId');
    }

    router.push(`${pathname}?${nextParams.toString()}`);
  };

  useEffect(() => {
    if (tabParam === 'tree' && treeIdParam) {
      setSelectedFamilyTreeId(treeIdParam);
    }
  }, [tabParam, treeIdParam]);

  return (
    <Container size="xl" py="md">
      <Tabs value={tabParam} onChange={handleTabChange} mt="md">
        <Tabs.List grow>
          <Tabs.Tab value="register" leftSection={<IconPlus size={14} />}>
            ä½œæˆ
          </Tabs.Tab>
          <Tabs.Tab value="list" leftSection={<IconList size={14} />}>
            ãƒ‡ãƒ¼ã‚¿ç®¡ç†
          </Tabs.Tab>
          <Tabs.Tab value="tree" leftSection={<IconBinaryTree size={14} />}>
            Family Tree
          </Tabs.Tab>
          <Tabs.Tab value="print-settings" leftSection={<IconSettings size={14} />}>
            å°åˆ·è¨­å®š
          </Tabs.Tab>
        </Tabs.List>

        <Tabs.Panel value="register" pt="md">
          <PedigreeRegistrationForm onSuccess={() => handleTabChange('list')} />
        </Tabs.Panel>

        <Tabs.Panel value="list" pt="md">
          <PedigreeList onSelectFamilyTree={handleFamilyTreeSelect} />
        </Tabs.Panel>

        <Tabs.Panel value="tree" pt="md">
          <PedigreeFamilyTree pedigreeId={selectedFamilyTreeId} />
        </Tabs.Panel>

        <Tabs.Panel value="print-settings" pt="md">
          <PrintSettingsEditor />
        </Tabs.Panel>
      </Tabs>
    </Container>
  );
}
````

## File: frontend/src/app/tags/components/CategoryModal.tsx
````typescript
'use client';

import {
  Box,
  Button,
  Card,
  Checkbox,
  ColorInput,
  Group,
  MultiSelect,
  Stack,
  Switch,
  Text,
  TextInput,
} from '@mantine/core';
import type { UseFormReturnType } from '@mantine/form';
import { UnifiedModal, type ModalSection } from '@/components/common';

import type { CategoryFormValues } from '../types';
import {
  DEFAULT_CATEGORY_COLOR,
  DEFAULT_CATEGORY_TEXT_COLOR,
  PRESET_COLORS,
} from '../constants';

export type CategoryModalProps = {
  opened: boolean;
  onClose: () => void;
  form: UseFormReturnType<CategoryFormValues>;
  onSubmit: (e: React.FormEvent<HTMLFormElement>) => void;
  isEditing: boolean;
  isSubmitting: boolean;
  // ã‚¹ã‚³ãƒ¼ãƒ—é–¢é€£ï¼ˆäº‹å‰å®šç¾©æ¸ˆã¿é¸æŠè‚¢ï¼‰
  categoryScopeOptions: { value: string; label: string }[];
  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š
  setAsCategoryDefaultBgColor: boolean;
  onSetAsCategoryDefaultBgColorChange: (checked: boolean) => void;
  setAsCategoryDefaultTextColor: boolean;
  onSetAsCategoryDefaultTextColorChange: (checked: boolean) => void;
};

/**
 * ã‚«ãƒ†ã‚´ãƒªç·¨é›†/ä½œæˆãƒ¢ãƒ¼ãƒ€ãƒ«
 */
export function CategoryModal({
  opened,
  onClose,
  form,
  onSubmit,
  isEditing,
  isSubmitting,
  categoryScopeOptions,
  setAsCategoryDefaultBgColor,
  onSetAsCategoryDefaultBgColorChange,
  setAsCategoryDefaultTextColor,
  onSetAsCategoryDefaultTextColorChange,
}: CategoryModalProps) {
  const sections: ModalSection[] = [
    {
      label: 'åŸºæœ¬æƒ…å ±',
      content: (
        <>
          <TextInput
            label="ã‚­ãƒ¼"
            description="URLãªã©ã§åˆ©ç”¨ã™ã‚‹è­˜åˆ¥å­ï¼ˆæœªå…¥åŠ›ã®å ´åˆã¯è‡ªå‹•ç”Ÿæˆï¼‰"
            value={form.values.key}
            onChange={(event) => form.setFieldValue('key', event.currentTarget.value)}
          />
          <TextInput
            label="ã‚«ãƒ†ã‚´ãƒªå"
            required
            value={form.values.name}
            onChange={(event) => form.setFieldValue('name', event.currentTarget.value)}
            error={form.errors.name}
          />
          <TextInput
            label="èª¬æ˜"
            placeholder="ã‚«ãƒ†ã‚´ãƒªã®ç”¨é€”ã‚„å¯¾è±¡ã‚’è¨˜è¼‰"
            value={form.values.description}
            onChange={(event) => form.setFieldValue('description', event.currentTarget.value)}
          />
        </>
      ),
    },
    {
      label: 'ã‚«ãƒ©ãƒ¼è¨­å®š',
      content: (
        <>
          <Group gap="md" align="flex-end">
            <Stack gap="xs" style={{ flex: 1 }}>
              <ColorInput
                label="èƒŒæ™¯ã‚«ãƒ©ãƒ¼"
                swatches={PRESET_COLORS}
                value={form.values.color}
                onChange={(value) => form.setFieldValue('color', value || DEFAULT_CATEGORY_COLOR)}
              />
              <Checkbox
                label="æ–°è¦ã‚«ãƒ†ã‚´ãƒªã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«è¨­å®š"
                checked={setAsCategoryDefaultBgColor}
                onChange={(e) => onSetAsCategoryDefaultBgColorChange(e.currentTarget.checked)}
              />
            </Stack>
            <Stack gap="xs" style={{ flex: 1 }}>
              <ColorInput
                label="ãƒ†ã‚­ã‚¹ãƒˆã‚«ãƒ©ãƒ¼"
                swatches={PRESET_COLORS}
                value={form.values.textColor}
                onChange={(value) =>
                  form.setFieldValue('textColor', value || DEFAULT_CATEGORY_TEXT_COLOR)
                }
              />
              <Checkbox
                label="æ–°è¦ã‚«ãƒ†ã‚´ãƒªã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«è¨­å®š"
                checked={setAsCategoryDefaultTextColor}
                onChange={(e) => onSetAsCategoryDefaultTextColorChange(e.currentTarget.checked)}
              />
            </Stack>
          </Group>
          <Card
            withBorder
            padding="sm"
            radius="md"
            shadow="xs"
            style={{
              backgroundColor: `${(form.values.color || DEFAULT_CATEGORY_COLOR)}26`,
              color: form.values.textColor || DEFAULT_CATEGORY_TEXT_COLOR,
              borderColor: form.values.color || DEFAULT_CATEGORY_COLOR,
            }}
          >
            <Text fw={600}>{form.values.name || 'ã‚«ãƒ†ã‚´ãƒªå'}</Text>
            <Text size="xs">ã‚µãƒ³ãƒ—ãƒ«ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</Text>
          </Card>
        </>
      ),
    },
    {
      label: 'è¨­å®š',
      content: (
        <>
          <MultiSelect
            label="åˆ©ç”¨ãƒšãƒ¼ã‚¸"
            description="ã“ã®ã‚«ãƒ†ã‚´ãƒªã®ã‚¿ã‚°ã‚’è¡¨ç¤ºã™ã‚‹ãƒšãƒ¼ã‚¸ã‚’é¸æŠ"
            data={categoryScopeOptions}
            value={form.values.scopes}
            onChange={(value) => form.setFieldValue('scopes', value)}
            placeholder="ãƒšãƒ¼ã‚¸ã‚’é¸æŠ"
            searchable
            clearable
            maxDropdownHeight={220}
          />
          <Switch
            label="ã‚¢ã‚¯ãƒ†ã‚£ãƒ–"
            checked={form.values.isActive}
            onChange={(event) => form.setFieldValue('isActive', event.currentTarget.checked)}
          />
        </>
      ),
    },
    {
      content: (
        <Group justify="flex-end" gap="sm">
          <Button variant="outline" onClick={onClose}>
            ã‚­ãƒ£ãƒ³ã‚»ãƒ«
          </Button>
          <Button type="submit" loading={isSubmitting}>
            {isEditing ? 'æ›´æ–°' : 'ä½œæˆ'}
          </Button>
        </Group>
      ),
    },
  ];

  return (
    <Box component="form" onSubmit={onSubmit}>
      <UnifiedModal
        opened={opened}
        onClose={onClose}
        title={isEditing ? 'ã‚«ãƒ†ã‚´ãƒªã‚’ç·¨é›†' : 'ã‚«ãƒ†ã‚´ãƒªã‚’è¿½åŠ '}
        size="lg"
        keepMounted={false}
        sections={sections}
      />
    </Box>
  );
}
````

## File: frontend/src/app/tags/components/GroupModal.tsx
````typescript
'use client';

import {
  Box,
  Button,
  Card,
  Checkbox,
  ColorInput,
  Group,
  Select,
  Stack,
  Switch,
  Text,
  TextInput,
} from '@mantine/core';
import type { UseFormReturnType } from '@mantine/form';
import { UnifiedModal, type ModalSection } from '@/components/common';

import type { GroupFormValues } from '../types';
import {
  DEFAULT_GROUP_COLOR,
  DEFAULT_GROUP_TEXT_COLOR,
  PRESET_COLORS,
} from '../constants';

export type GroupModalProps = {
  opened: boolean;
  onClose: () => void;
  form: UseFormReturnType<GroupFormValues>;
  onSubmit: (e: React.FormEvent<HTMLFormElement>) => void;
  isEditing: boolean;
  isSubmitting: boolean;
  categoryOptions: { value: string; label: string }[];
  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š
  setAsGroupDefaultBgColor: boolean;
  onSetAsGroupDefaultBgColorChange: (checked: boolean) => void;
  setAsGroupDefaultTextColor: boolean;
  onSetAsGroupDefaultTextColorChange: (checked: boolean) => void;
  // ç¶™æ‰¿è¨­å®š
  inheritGroupColorFromCategory: boolean;
  onInheritGroupColorFromCategoryChange: (checked: boolean) => void;
};

/**
 * ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ç·¨é›†/ä½œæˆãƒ¢ãƒ¼ãƒ€ãƒ«
 */
export function GroupModal({
  opened,
  onClose,
  form,
  onSubmit,
  isEditing,
  isSubmitting,
  categoryOptions,
  setAsGroupDefaultBgColor,
  onSetAsGroupDefaultBgColorChange,
  setAsGroupDefaultTextColor,
  onSetAsGroupDefaultTextColorChange,
  inheritGroupColorFromCategory,
  onInheritGroupColorFromCategoryChange,
}: GroupModalProps) {
  const sections: ModalSection[] = [
    {
      label: 'åŸºæœ¬æƒ…å ±',
      content: (
        <>
          <Select
            label="ã‚«ãƒ†ã‚´ãƒª"
            data={categoryOptions}
            value={form.values.categoryId}
            onChange={(value) => form.setFieldValue('categoryId', value ?? '')}
            error={form.errors.categoryId}
            required
          />
          <TextInput
            label="ã‚°ãƒ«ãƒ¼ãƒ—å"
            value={form.values.name}
            onChange={(event) => form.setFieldValue('name', event.currentTarget.value)}
            error={form.errors.name}
            required
          />
          <TextInput
            label="èª¬æ˜"
            placeholder="ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ã®ç”¨é€”"
            value={form.values.description}
            onChange={(event) => form.setFieldValue('description', event.currentTarget.value)}
          />
        </>
      ),
    },
    {
      label: 'ã‚«ãƒ©ãƒ¼è¨­å®š',
      content: (
        <>
          <Checkbox
            label="è¦ªã‚«ãƒ†ã‚´ãƒªã®ã‚«ãƒ©ãƒ¼ã‚’ç¶™æ‰¿"
            checked={inheritGroupColorFromCategory}
            onChange={(e) => onInheritGroupColorFromCategoryChange(e.currentTarget.checked)}
          />
          <Group gap="md" align="flex-end">
            <Stack gap="xs" style={{ flex: 1 }}>
              <ColorInput
                label="èƒŒæ™¯ã‚«ãƒ©ãƒ¼"
                swatches={PRESET_COLORS}
                value={form.values.color}
                onChange={(value) => form.setFieldValue('color', value || DEFAULT_GROUP_COLOR)}
              />
              <Checkbox
                label="æ–°è¦ã‚°ãƒ«ãƒ¼ãƒ—ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«è¨­å®š"
                checked={setAsGroupDefaultBgColor}
                onChange={(e) => onSetAsGroupDefaultBgColorChange(e.currentTarget.checked)}
              />
            </Stack>
            <Stack gap="xs" style={{ flex: 1 }}>
              <ColorInput
                label="ãƒ†ã‚­ã‚¹ãƒˆã‚«ãƒ©ãƒ¼"
                swatches={PRESET_COLORS}
                value={form.values.textColor}
                onChange={(value) =>
                  form.setFieldValue('textColor', value || DEFAULT_GROUP_TEXT_COLOR)
                }
              />
              <Checkbox
                label="æ–°è¦ã‚°ãƒ«ãƒ¼ãƒ—ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«è¨­å®š"
                checked={setAsGroupDefaultTextColor}
                onChange={(e) => onSetAsGroupDefaultTextColorChange(e.currentTarget.checked)}
              />
            </Stack>
          </Group>
          <Card
            withBorder
            padding="sm"
            radius="md"
            shadow="xs"
            style={{
              backgroundColor: `${(form.values.color || DEFAULT_GROUP_COLOR)}26`,
              color: form.values.textColor || DEFAULT_GROUP_TEXT_COLOR,
              borderColor: form.values.color || DEFAULT_GROUP_COLOR,
            }}
          >
            <Text fw={600}>{form.values.name || 'ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—å'}</Text>
            <Text size="xs">ã‚µãƒ³ãƒ—ãƒ«ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</Text>
          </Card>
        </>
      ),
    },
    {
      label: 'è¨­å®š',
      content: (
        <Switch
          label="ã‚¢ã‚¯ãƒ†ã‚£ãƒ–"
          checked={form.values.isActive}
          onChange={(event) => form.setFieldValue('isActive', event.currentTarget.checked)}
        />
      ),
    },
    {
      content: (
        <Group justify="flex-end" gap="sm">
          <Button variant="outline" onClick={onClose}>
            ã‚­ãƒ£ãƒ³ã‚»ãƒ«
          </Button>
          <Button type="submit" loading={isSubmitting}>
            {isEditing ? 'æ›´æ–°' : 'ä½œæˆ'}
          </Button>
        </Group>
      ),
    },
  ];

  return (
    <Box component="form" onSubmit={onSubmit}>
      <UnifiedModal
        opened={opened}
        onClose={onClose}
        title={isEditing ? 'ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ç·¨é›†' : 'ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—ã‚’è¿½åŠ '}
        size="lg"
        keepMounted={false}
        sections={sections}
      />
    </Box>
  );
}
````

## File: frontend/src/app/tags/components/TagModal.tsx
````typescript
'use client';

import {
  Badge,
  Box,
  Button,
  Card,
  Checkbox,
  ColorInput,
  Group,
  Select,
  Stack,
  Switch,
  Text,
  TextInput,
} from '@mantine/core';
import type { UseFormReturnType } from '@mantine/form';
import { UnifiedModal, type ModalSection } from '@/components/common';

import type { TagFormValues } from '../types';
import {
  DEFAULT_TAG_COLOR,
  DEFAULT_TAG_TEXT_COLOR,
  PRESET_COLORS,
} from '../constants';

export type TagModalProps = {
  opened: boolean;
  onClose: () => void;
  form: UseFormReturnType<TagFormValues>;
  onSubmit: (e: React.FormEvent<HTMLFormElement>) => void;
  isEditing: boolean;
  isSubmitting: boolean;
  categoryOptions: { value: string; label: string }[];
  tagGroupOptions: { value: string; label: string }[];
  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š
  setAsTagDefaultBgColor: boolean;
  onSetAsTagDefaultBgColorChange: (checked: boolean) => void;
  setAsTagDefaultTextColor: boolean;
  onSetAsTagDefaultTextColorChange: (checked: boolean) => void;
  // ç¶™æ‰¿è¨­å®š
  inheritTagColorFromGroup: boolean;
  onInheritTagColorFromGroupChange: (checked: boolean) => void;
};

/**
 * ã‚¿ã‚°ç·¨é›†/ä½œæˆãƒ¢ãƒ¼ãƒ€ãƒ«
 */
export function TagModal({
  opened,
  onClose,
  form,
  onSubmit,
  isEditing,
  isSubmitting,
  categoryOptions,
  tagGroupOptions,
  setAsTagDefaultBgColor,
  onSetAsTagDefaultBgColorChange,
  setAsTagDefaultTextColor,
  onSetAsTagDefaultTextColorChange,
  inheritTagColorFromGroup,
  onInheritTagColorFromGroupChange,
}: TagModalProps) {
  const sections: ModalSection[] = [
    {
      label: 'åŸºæœ¬æƒ…å ±',
      content: (
        <>
          <Select
            label="ã‚«ãƒ†ã‚´ãƒª"
            data={categoryOptions}
            value={form.values.categoryId}
            onChange={(value) => {
              form.setFieldValue('categoryId', value ?? '');
              form.setFieldValue('groupId', '');
            }}
            error={form.errors.categoryId}
            required
          />
          <Select
            label="ã‚¿ã‚°ã‚°ãƒ«ãƒ¼ãƒ—"
            placeholder={form.values.categoryId ? 'ã‚°ãƒ«ãƒ¼ãƒ—ã‚’é¸æŠã—ã¦ãã ã•ã„' : 'å…ˆã«ã‚«ãƒ†ã‚´ãƒªã‚’é¸æŠã—ã¦ãã ã•ã„'}
            data={tagGroupOptions}
            value={form.values.groupId}
            onChange={(value) => form.setFieldValue('groupId', value ?? '')}
            error={form.errors.groupId}
            required
            disabled={!form.values.categoryId || tagGroupOptions.length === 0}
          />
          <TextInput
            label="ã‚¿ã‚°å"
            value={form.values.name}
            onChange={(event) => form.setFieldValue('name', event.currentTarget.value)}
            error={form.errors.name}
            required
          />
          <TextInput
            label="èª¬æ˜"
            placeholder="ã‚¿ã‚°ã®è£œè¶³æƒ…å ±"
            value={form.values.description}
            onChange={(event) => form.setFieldValue('description', event.currentTarget.value)}
          />
        </>
      ),
    },
    {
      label: 'ã‚«ãƒ©ãƒ¼è¨­å®š',
      content: (
        <>
          <Checkbox
            label="è¦ªã‚°ãƒ«ãƒ¼ãƒ—ã®ã‚«ãƒ©ãƒ¼ã‚’ç¶™æ‰¿"
            checked={inheritTagColorFromGroup}
            onChange={(e) => onInheritTagColorFromGroupChange(e.currentTarget.checked)}
          />
          <Group gap="md" align="flex-end">
            <Stack gap="xs" style={{ flex: 1 }}>
              <ColorInput
                label="èƒŒæ™¯ã‚«ãƒ©ãƒ¼"
                swatches={PRESET_COLORS}
                value={form.values.color}
                onChange={(value) => form.setFieldValue('color', value || DEFAULT_TAG_COLOR)}
              />
              <Checkbox
                label="æ–°è¦ã‚¿ã‚°ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«è¨­å®š"
                checked={setAsTagDefaultBgColor}
                onChange={(e) => onSetAsTagDefaultBgColorChange(e.currentTarget.checked)}
              />
            </Stack>
            <Stack gap="xs" style={{ flex: 1 }}>
              <ColorInput
                label="ãƒ†ã‚­ã‚¹ãƒˆã‚«ãƒ©ãƒ¼"
                swatches={PRESET_COLORS}
                value={form.values.textColor}
                onChange={(value) =>
                  form.setFieldValue('textColor', value || DEFAULT_TAG_TEXT_COLOR)
                }
              />
              <Checkbox
                label="æ–°è¦ã‚¿ã‚°ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«è¨­å®š"
                checked={setAsTagDefaultTextColor}
                onChange={(e) => onSetAsTagDefaultTextColorChange(e.currentTarget.checked)}
              />
            </Stack>
          </Group>
          <Card
            withBorder
            padding="sm"
            radius="md"
            shadow="xs"
            style={{
              backgroundColor: `${(form.values.color || DEFAULT_TAG_COLOR)}26`,
              color: form.values.textColor || DEFAULT_TAG_TEXT_COLOR,
              borderColor: form.values.color || DEFAULT_TAG_COLOR,
            }}
          >
            <Group gap="xs" align="center" wrap="wrap">
              <Text fw={600}>{form.values.name || 'ã‚¿ã‚°å'}</Text>
              <Badge size="xs" variant="outline" color="gray">
                ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
              </Badge>
            </Group>
            {form.values.description && (
              <Text size="xs" mt={4}>
                {form.values.description}
              </Text>
            )}
            <Group gap={6} mt="xs" wrap="wrap">
              <Badge
                size="xs"
                variant="light"
                style={{
                  backgroundColor: `${(form.values.color || DEFAULT_TAG_COLOR)}33`,
                  color: form.values.textColor || DEFAULT_TAG_TEXT_COLOR,
                }}
              >
                æ‰‹å‹• {form.values.allowsManual ? 'å¯' : 'ä¸å¯'}
              </Badge>
              <Badge
                size="xs"
                variant="light"
                style={{
                  backgroundColor: `${(form.values.color || DEFAULT_TAG_COLOR)}33`,
                  color: form.values.textColor || DEFAULT_TAG_TEXT_COLOR,
                }}
              >
                è‡ªå‹• {form.values.allowsAutomation ? 'å¯' : 'ä¸å¯'}
              </Badge>
            </Group>
          </Card>
        </>
      ),
    },
    {
      label: 'è¨­å®š',
      content: (
        <>
          <Group gap="lg">
            <Switch
              label="æ‰‹å‹•ä»˜ä¸ã‚’è¨±å¯"
              checked={form.values.allowsManual}
              onChange={(event) => form.setFieldValue('allowsManual', event.currentTarget.checked)}
            />
            <Switch
              label="è‡ªå‹•ä»˜ä¸ã‚’è¨±å¯"
              checked={form.values.allowsAutomation}
              onChange={(event) => form.setFieldValue('allowsAutomation', event.currentTarget.checked)}
            />
          </Group>
          <Switch
            label="ã‚¢ã‚¯ãƒ†ã‚£ãƒ–"
            checked={form.values.isActive}
            onChange={(event) => form.setFieldValue('isActive', event.currentTarget.checked)}
          />
        </>
      ),
    },
    {
      content: (
        <Group justify="flex-end" gap="sm">
          <Button variant="outline" onClick={onClose}>
            ã‚­ãƒ£ãƒ³ã‚»ãƒ«
          </Button>
          <Button type="submit" loading={isSubmitting}>
            {isEditing ? 'æ›´æ–°' : 'ä½œæˆ'}
          </Button>
        </Group>
      ),
    },
  ];

  return (
    <Box component="form" onSubmit={onSubmit}>
      <UnifiedModal
        opened={opened}
        onClose={onClose}
        title={isEditing ? 'ã‚¿ã‚°ã‚’ç·¨é›†' : 'ã‚¿ã‚°ã‚’è¿½åŠ '}
        size="lg"
        keepMounted={false}
        sections={sections}
      />
    </Box>
  );
}
````

## File: frontend/src/app/tenants/_components/EditTenantModal.tsx
````typescript
'use client';

import { useState, useEffect } from 'react';
import { TextInput, Switch, Group, Text, Divider } from '@mantine/core';
import { notifications } from '@mantine/notifications';
import { UnifiedModal } from '@/components/common';
import { apiRequest } from '@/lib/api/client';
import { ActionButton } from '@/components/ActionButton';

interface Tenant {
  id: string;
  name: string;
  slug: string;
  isActive: boolean;
}

interface EditTenantModalProps {
  tenant: Tenant | null;
  opened: boolean;
  onClose: () => void;
  onSuccess: () => void;
}

export function EditTenantModal({ tenant, opened, onClose, onSuccess }: EditTenantModalProps) {
  const [loading, setLoading] = useState(false);
  const [formData, setFormData] = useState({
    name: '',
    slug: '',
    isActive: true,
  });

  // ãƒ†ãƒŠãƒ³ãƒˆæƒ…å ±ãŒå¤‰ã‚ã£ãŸã‚‰ãƒ•ã‚©ãƒ¼ãƒ ã‚’åˆæœŸåŒ–
  useEffect(() => {
    if (tenant) {
      setFormData({
        name: tenant.name,
        slug: tenant.slug,
        isActive: tenant.isActive,
      });
    }
  }, [tenant]);

  const handleClose = () => {
    if (!loading) {
      onClose();
    }
  };

  const handleSubmit = async () => {
    if (!tenant) return;

    // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    if (!formData.name.trim()) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: 'ãƒ†ãƒŠãƒ³ãƒˆåã‚’å…¥åŠ›ã—ã¦ãã ã•ã„',
        color: 'red',
      });
      return;
    }

    if (!formData.slug.trim()) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: 'ã‚¹ãƒ©ãƒƒã‚°ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„',
        color: 'red',
      });
      return;
    }

    try {
      setLoading(true);

      const response = await apiRequest(`/tenants/${tenant.id}`, {
        method: 'PATCH',
        body: JSON.stringify({
          name: formData.name.trim(),
          slug: formData.slug.trim(),
          isActive: formData.isActive,
        }),
      });

      if (response.success) {
        notifications.show({
          title: 'æˆåŠŸ',
          message: 'ãƒ†ãƒŠãƒ³ãƒˆã‚’æ›´æ–°ã—ã¾ã—ãŸ',
          color: 'green',
        });
        onSuccess();
        onClose();
      } else {
        const errorMessage = response.error || response.message || 'ãƒ†ãƒŠãƒ³ãƒˆã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ';
        notifications.show({
          title: 'ã‚¨ãƒ©ãƒ¼',
          message: errorMessage,
          color: 'red',
        });
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message,
        color: 'red',
      });
    } finally {
      setLoading(false);
    }
  };

  return (
    <UnifiedModal
      opened={opened}
      onClose={handleClose}
      title="ãƒ†ãƒŠãƒ³ãƒˆã‚’ç·¨é›†"
      size="md"
    >
      <TextInput
        label="ãƒ†ãƒŠãƒ³ãƒˆå"
        placeholder="ã‚µãƒ³ãƒ—ãƒ«ãƒ†ãƒŠãƒ³ãƒˆ"
        required
        value={formData.name}
        onChange={(e) => setFormData({ ...formData, name: e.target.value })}
        disabled={loading}
      />

      <TextInput
        label="ãƒ†ãƒŠãƒ³ãƒˆã‚¹ãƒ©ãƒƒã‚°"
        placeholder="sample-tenant"
        required
        description="åŠè§’è‹±å°æ–‡å­—ã€æ•°å­—ã€ãƒã‚¤ãƒ•ãƒ³ã®ã¿ä½¿ç”¨å¯èƒ½"
        value={formData.slug}
        onChange={(e) => setFormData({ ...formData, slug: e.target.value })}
        disabled={loading}
      />

      <Divider />

      <Group>
        <Switch
          label="æœ‰åŠ¹"
          checked={formData.isActive}
          onChange={(e) => setFormData({ ...formData, isActive: e.currentTarget.checked })}
          disabled={loading}
        />
        <Text size="sm" c="dimmed">
          ç„¡åŠ¹ã«ã™ã‚‹ã¨ãƒ†ãƒŠãƒ³ãƒˆã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ãƒ­ã‚°ã‚¤ãƒ³ã§ããªããªã‚Šã¾ã™
        </Text>
      </Group>

      <Divider />

      <Group justify="flex-end" mt="md">
        <ActionButton action="cancel" onClick={handleClose} disabled={loading}>
          ã‚­ãƒ£ãƒ³ã‚»ãƒ«
        </ActionButton>
        <ActionButton action="save" onClick={handleSubmit} loading={loading}>
          ä¿å­˜
        </ActionButton>
      </Group>
    </UnifiedModal>
  );
}
````

## File: frontend/src/app/tenants/_components/InviteTenantAdminModal.tsx
````typescript
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import {
  Stack,
  TextInput,
  Group,
  Alert,
  Code,
  CopyButton,
  Button,
  Text,
} from '@mantine/core';
import { IconCheck, IconCopy, IconMail } from '@tabler/icons-react';
import { UnifiedModal, type ModalSection } from '@/components/common';
import { ActionButton } from '@/components/ActionButton';
import { apiClient } from '@/lib/api/client';
import { notifications } from '@mantine/notifications';
import { getInvitationUrl } from '@/lib/invitation-utils';

interface InviteTenantAdminModalProps {
  opened: boolean;
  onClose: () => void;
}

/**
 * ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†è€…æ‹›å¾…ãƒ¢ãƒ¼ãƒ€ãƒ«ï¼ˆSUPER_ADMINå°‚ç”¨ï¼‰
 */
export function InviteTenantAdminModal({ opened, onClose }: InviteTenantAdminModalProps) {
  const router = useRouter();
  const [loading, setLoading] = useState(false);
  const [formData, setFormData] = useState({
    email: '',
    tenantName: '',
    tenantSlug: '',
  });
  // æ‹›å¾…æˆåŠŸå¾Œã®æƒ…å ±ã‚’ä¿æŒ
  const [invitationResult, setInvitationResult] = useState<{
    email: string;
    invitationToken: string;
  } | null>(null);

  // ãƒ•ã‚©ãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆ
  const resetForm = () => {
    setFormData({
      email: '',
      tenantName: '',
      tenantSlug: '',
    });
    setInvitationResult(null);
  };

  // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
  const handleClose = () => {
    if (!loading) {
      resetForm();
      onClose();
    }
  };

  // ãƒ†ãƒŠãƒ³ãƒˆä¸€è¦§ã‚’æ›´æ–°ã—ã¦é–‰ã˜ã‚‹
  const handleFinish = () => {
    handleClose();
    router.refresh();
  };

  // æ‹›å¾…é€ä¿¡
  const handleSubmit = async () => {
    // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    if (!formData.email.trim()) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„',
        color: 'red',
      });
      return;
    }

    if (!formData.tenantName.trim()) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: 'ãƒ†ãƒŠãƒ³ãƒˆåã‚’å…¥åŠ›ã—ã¦ãã ã•ã„',
        color: 'red',
      });
      return;
    }

    try {
      setLoading(true);

      const response = await apiClient.request('/tenants/invite-admin' as never, 'post', {
        body: {
          email: formData.email.trim(),
          tenantName: formData.tenantName.trim(),
          tenantSlug: formData.tenantSlug.trim() || undefined,
        } as never,
      });

      if (response.success && response.data) {
        const data = response.data as { invitationToken?: string };
        if (data.invitationToken) {
          // æ‹›å¾…URLã‚’è¡¨ç¤ºã™ã‚‹ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆ
          setInvitationResult({
            email: formData.email.trim(),
            invitationToken: data.invitationToken,
          });
          notifications.show({
            title: 'æˆåŠŸ',
            message: 'ãƒ†ãƒŠãƒ³ãƒˆã¨æ‹›å¾…ãŒä½œæˆã•ã‚Œã¾ã—ãŸ',
            color: 'green',
          });
        } else {
          // ãƒˆãƒ¼ã‚¯ãƒ³ãŒè¿”ã•ã‚Œãªã‹ã£ãŸå ´åˆã¯å¾“æ¥ã®å‹•ä½œ
          notifications.show({
            title: 'æˆåŠŸ',
            message: 'ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†è€…ã®æ‹›å¾…ã‚’é€ä¿¡ã—ã¾ã—ãŸ',
            color: 'green',
          });
          handleFinish();
        }
      } else {
        throw new Error(response.error || 'æ‹›å¾…ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message,
        color: 'red',
      });
    } finally {
      setLoading(false);
    }
  };

  const sections: ModalSection[] = invitationResult
    ? [
        {
          content: (
            <Alert icon={<IconMail size={16} />} title="æ‹›å¾…ã‚’ä½œæˆã—ã¾ã—ãŸ" color="green">
            <Text size="sm" mb="xs">
              <strong>{invitationResult.email}</strong> å®›ã¦ã®æ‹›å¾…ã‚’ä½œæˆã—ã¾ã—ãŸã€‚
            </Text>
            <Text size="sm" c="dimmed">
                ä»¥ä¸‹ã®æ‹›å¾…URLã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ã€æ‹›å¾…è€…ã«å…±æœ‰ã—ã¦ãã ã•ã„ã€‚
            </Text>
          </Alert>
          ),
        },
        {
          label: "æ‹›å¾…URL",
          content: (
            <>
              <Stack gap="xs">
            <Text size="sm" fw={500}>æ‹›å¾…URL:</Text>
            <Code block style={{ wordBreak: 'break-all' }}>
              {getInvitationUrl(invitationResult.invitationToken)}
            </Code>
            <CopyButton value={getInvitationUrl(invitationResult.invitationToken)}>
              {({ copied, copy }) => (
                <Button
                  color={copied ? 'teal' : 'blue'}
                  leftSection={copied ? <IconCheck size={16} /> : <IconCopy size={16} />}
                  onClick={copy}
                  variant="light"
                >
                  {copied ? 'ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼' : 'URLã‚’ã‚³ãƒ”ãƒ¼'}
                </Button>
              )}
            </CopyButton>
              </Stack>

              <Text size="xs" c="dimmed">
                â€» æ‹›å¾…URLã¯7æ—¥é–“æœ‰åŠ¹ã§ã™ã€‚
              </Text>
            </>
          ),
        },
        {
          content: (
            <Group justify="flex-end" mt="md">
            <ActionButton action="save" onClick={handleFinish}>
                é–‰ã˜ã‚‹
            </ActionButton>
          </Group>
          ),
        },
      ]
    : [
        {
          content: (
            <>
              <TextInput
            label="ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹"
            placeholder="admin@example.com"
            required
            value={formData.email}
            onChange={(e) => setFormData({ ...formData, email: e.target.value })}
            disabled={loading}
          />

          <TextInput
            label="ãƒ†ãƒŠãƒ³ãƒˆå"
            placeholder="ã‚µãƒ³ãƒ—ãƒ«ãƒ†ãƒŠãƒ³ãƒˆ"
            required
            value={formData.tenantName}
            onChange={(e) => setFormData({ ...formData, tenantName: e.target.value })}
            disabled={loading}
          />

          <TextInput
            label="ãƒ†ãƒŠãƒ³ãƒˆã‚¹ãƒ©ãƒƒã‚°ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰"
            placeholder="sample-tenant"
            description="æœªå…¥åŠ›ã®å ´åˆã€ãƒ†ãƒŠãƒ³ãƒˆåã‹ã‚‰è‡ªå‹•ç”Ÿæˆã•ã‚Œã¾ã™"
            value={formData.tenantSlug}
            onChange={(e) => setFormData({ ...formData, tenantSlug: e.target.value })}
              disabled={loading}
            />
            </>
          ),
        },
        {
          content: (
            <Group justify="flex-end" mt="md">
            <ActionButton action="cancel" onClick={handleClose} disabled={loading}>
              ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            </ActionButton>
            <ActionButton action="save" onClick={handleSubmit} loading={loading}>
                æ‹›å¾…ã‚’é€ä¿¡
            </ActionButton>
          </Group>
          ),
        },
      ];

  return (
    <UnifiedModal
      opened={opened}
      onClose={handleClose}
      title="ãƒ†ãƒŠãƒ³ãƒˆç®¡ç†è€…ã‚’æ‹›å¾…"
      size="md"
      sections={sections}
    />
  );
}
````

## File: frontend/src/app/tenants/_components/InviteUserModal.tsx
````typescript
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import {
  Stack,
  TextInput,
  Select,
  Group,
  Alert,
  Code,
  CopyButton,
  Button,
  Text,
} from '@mantine/core';
import { IconCheck, IconCopy, IconMail } from '@tabler/icons-react';
import { UnifiedModal, type ModalSection } from '@/components/common';
import { ActionButton } from '@/components/ActionButton';
import { apiClient } from '@/lib/api/client';
import { useAuth } from '@/lib/auth/store';
import { notifications } from '@mantine/notifications';
import { getInvitationUrl } from '@/lib/invitation-utils';

// ãƒ­ãƒ¼ãƒ«é¸æŠè‚¢ï¼ˆTENANT_ADMIN ãŒæ‹›å¾…ã§ãã‚‹ã®ã¯ USER ã¨ ADMIN ã®ã¿ï¼‰
const ROLE_OPTIONS = [
  { value: 'USER', label: 'ä¸€èˆ¬ãƒ¦ãƒ¼ã‚¶ãƒ¼' },
  { value: 'ADMIN', label: 'ç®¡ç†è€…' },
];

interface InviteUserModalProps {
  opened: boolean;
  onClose: () => void;
}

/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼æ‹›å¾…ãƒ¢ãƒ¼ãƒ€ãƒ«ï¼ˆTENANT_ADMINå°‚ç”¨ï¼‰
 */
export function InviteUserModal({ opened, onClose }: InviteUserModalProps) {
  const router = useRouter();
  const { user } = useAuth();
  const [loading, setLoading] = useState(false);
  const [formData, setFormData] = useState({
    email: '',
    role: 'USER',
  });
  // æ‹›å¾…æˆåŠŸå¾Œã®æƒ…å ±ã‚’ä¿æŒ
  const [invitationResult, setInvitationResult] = useState<{
    email: string;
    invitationToken: string;
    role: string;
  } | null>(null);

  // ãƒ†ãƒŠãƒ³ãƒˆIDã‚’å–å¾—ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ï¼‰
  const tenantId = user?.tenantId;

  // ãƒ•ã‚©ãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆ
  const resetForm = () => {
    setFormData({
      email: '',
      role: 'USER',
    });
    setInvitationResult(null);
  };

  // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
  const handleClose = () => {
    if (!loading) {
      resetForm();
      onClose();
    }
  };

  // ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§ã‚’æ›´æ–°ã—ã¦é–‰ã˜ã‚‹
  const handleFinish = () => {
    handleClose();
    router.refresh();
  };

  // æ‹›å¾…é€ä¿¡
  const handleSubmit = async () => {
    // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    if (!formData.email.trim()) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„',
        color: 'red',
      });
      return;
    }

    if (!tenantId) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: 'ãƒ†ãƒŠãƒ³ãƒˆæƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“',
        color: 'red',
      });
      return;
    }

    try {
      setLoading(true);

      const response = await apiClient.request(`/tenants/${tenantId}/users/invite` as never, 'post', {
        body: {
          email: formData.email.trim(),
          role: formData.role,
        } as never,
      });

      if (response.success && response.data) {
        const data = response.data as { invitationToken?: string };
        if (data.invitationToken) {
          // æ‹›å¾…URLã‚’è¡¨ç¤ºã™ã‚‹ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆ
          setInvitationResult({
            email: formData.email.trim(),
            invitationToken: data.invitationToken,
            role: formData.role,
          });
          notifications.show({
            title: 'æˆåŠŸ',
            message: 'æ‹›å¾…ã‚’ä½œæˆã—ã¾ã—ãŸ',
            color: 'green',
          });
        } else {
          // ãƒˆãƒ¼ã‚¯ãƒ³ãŒè¿”ã•ã‚Œãªã‹ã£ãŸå ´åˆã¯å¾“æ¥ã®å‹•ä½œ
          notifications.show({
            title: 'æˆåŠŸ',
            message: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ‹›å¾…ã‚’é€ä¿¡ã—ã¾ã—ãŸ',
            color: 'green',
          });
          handleFinish();
        }
      } else {
        throw new Error(response.error || 'æ‹›å¾…ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message,
        color: 'red',
      });
    } finally {
      setLoading(false);
    }
  };

  // ãƒ­ãƒ¼ãƒ«åã‚’æ—¥æœ¬èªã§å–å¾—
  const getRoleLabel = (role: string) => {
    return ROLE_OPTIONS.find((opt) => opt.value === role)?.label || role;
  };

  // ãƒ†ãƒŠãƒ³ãƒˆIDãŒãªã„å ´åˆã¯ä½•ã‚‚è¡¨ç¤ºã—ãªã„
  if (!tenantId) {
    return null;
  }

  const sections: ModalSection[] = invitationResult
    ? [
        {
          content: (
            <Alert icon={<IconMail size={16} />} title="æ‹›å¾…ã‚’ä½œæˆã—ã¾ã—ãŸ" color="green">
            <Text size="sm" mb="xs">
              <strong>{invitationResult.email}</strong> ã‚’
              <strong>{getRoleLabel(invitationResult.role)}</strong>ã¨ã—ã¦æ‹›å¾…ã—ã¾ã—ãŸã€‚
            </Text>
            <Text size="sm" c="dimmed">
                ä»¥ä¸‹ã®æ‹›å¾…URLã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ã€æ‹›å¾…è€…ã«å…±æœ‰ã—ã¦ãã ã•ã„ã€‚
            </Text>
          </Alert>
          ),
        },
        {
          label: "æ‹›å¾…URL",
          content: (
            <>
              <Stack gap="xs">
            <Text size="sm" fw={500}>æ‹›å¾…URL:</Text>
            <Code block style={{ wordBreak: 'break-all' }}>
              {getInvitationUrl(invitationResult.invitationToken)}
            </Code>
            <CopyButton value={getInvitationUrl(invitationResult.invitationToken)}>
              {({ copied, copy }) => (
                <Button
                  color={copied ? 'teal' : 'blue'}
                  leftSection={copied ? <IconCheck size={16} /> : <IconCopy size={16} />}
                  onClick={copy}
                  variant="light"
                >
                  {copied ? 'ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼' : 'URLã‚’ã‚³ãƒ”ãƒ¼'}
                </Button>
              )}
            </CopyButton>
              </Stack>

              <Text size="xs" c="dimmed">
                â€» æ‹›å¾…URLã¯7æ—¥é–“æœ‰åŠ¹ã§ã™ã€‚
              </Text>
            </>
          ),
        },
        {
          content: (
            <Group justify="flex-end" mt="md">
            <ActionButton action="save" onClick={handleFinish}>
                é–‰ã˜ã‚‹
            </ActionButton>
          </Group>
          ),
        },
      ]
    : [
        {
          content: (
            <>
              <TextInput
            label="ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹"
            placeholder="user@example.com"
            required
            value={formData.email}
            onChange={(e) => setFormData({ ...formData, email: e.target.value })}
            disabled={loading}
          />

          <Select
            label="ãƒ­ãƒ¼ãƒ«"
            placeholder="ãƒ­ãƒ¼ãƒ«ã‚’é¸æŠ"
            required
            data={ROLE_OPTIONS}
            value={formData.role}
            onChange={(value) => setFormData({ ...formData, role: value || 'USER' })}
              disabled={loading}
            />
            </>
          ),
        },
        {
          content: (
            <Group justify="flex-end" mt="md">
            <ActionButton action="cancel" onClick={handleClose} disabled={loading}>
              ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            </ActionButton>
            <ActionButton action="save" onClick={handleSubmit} loading={loading}>
                æ‹›å¾…ã‚’é€ä¿¡
            </ActionButton>
          </Group>
          ),
        },
      ];

  return (
    <UnifiedModal
      opened={opened}
      onClose={handleClose}
      title="ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’æ‹›å¾…"
      size="md"
      sections={sections}
    />
  );
}
````

## File: frontend/src/components/cats/cat-quick-edit-modal.tsx
````typescript
'use client';

import { useState, useEffect } from 'react';
import {
  Button,
  Group,
  TextInput,
  Divider,
} from '@mantine/core';
import { DateInput } from '@mantine/dates';
import { notifications } from '@mantine/notifications';
import { UnifiedModal } from '@/components/common';

interface CatQuickEditModalProps {
  opened: boolean;
  onClose: () => void;
  catId: string;
  catName: string;
  birthDate: string;
  onSave: (catId: string, updates: { name?: string; birthDate?: string }) => Promise<void>;
}

export function CatQuickEditModal({
  opened,
  onClose,
  catId,
  catName,
  birthDate,
  onSave,
}: CatQuickEditModalProps) {
  const [name, setName] = useState(catName);
  const [date, setDate] = useState<Date | null>(null);
  const [isSaving, setIsSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (opened) {
      setName(catName);
      setDate(new Date(birthDate));
      setError(null);
    }
  }, [opened, catName, birthDate]);

  const handleSave = async () => {
    if (!name.trim()) {
      setError('åå‰ã¯å¿…é ˆã§ã™');
      return;
    }

    if (!date) {
      setError('èª•ç”Ÿæ—¥ã¯å¿…é ˆã§ã™');
      return;
    }

    setIsSaving(true);
    setError(null);

    try {
      const updates: { name?: string; birthDate?: string } = {};
      
      if (name !== catName) {
        updates.name = name;
      }
      
      const newBirthDate = date.toISOString().split('T')[0];
      if (newBirthDate !== birthDate) {
        updates.birthDate = newBirthDate;
      }

      if (Object.keys(updates).length > 0) {
        await onSave(catId, updates);
        notifications.show({
          title: 'æ›´æ–°æˆåŠŸ',
          message: 'çŒ«ã®æƒ…å ±ã‚’æ›´æ–°ã—ã¾ã—ãŸ',
          color: 'green',
        });
      }
      
      onClose();
    } catch (err) {
      const message = err instanceof Error ? err.message : 'ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ';
      setError(message);
      notifications.show({
        title: 'æ›´æ–°å¤±æ•—',
        message,
        color: 'red',
      });
    } finally {
      setIsSaving(false);
    }
  };

  return (
    <UnifiedModal
      opened={opened}
      onClose={onClose}
      title="çŒ«æƒ…å ±ã®ç·¨é›†"
      size="md"
      centered
    >
      <TextInput
        label="åå‰"
        placeholder="çŒ«ã®åå‰"
        value={name}
        onChange={(e) => setName(e.target.value)}
        required
        error={error && error.includes('åå‰') ? error : undefined}
        autoFocus
      />

      <DateInput
        label="èª•ç”Ÿæ—¥"
        placeholder="èª•ç”Ÿæ—¥ã‚’é¸æŠ"
        value={date}
        onChange={(value) => {
          if (typeof value === 'string') {
            setDate(new Date(value));
          } else {
            setDate(value);
          }
        }}
        required
        error={error && error.includes('èª•ç”Ÿæ—¥') ? error : undefined}
        valueFormat="YYYY/MM/DD"
      />

      {error && !error.includes('åå‰') && !error.includes('èª•ç”Ÿæ—¥') && (
        <TextInput
          error={error}
          styles={{ input: { display: 'none' } }}
        />
      )}

      <Divider />

      <Group justify="flex-end" gap="sm">
        <Button variant="outline" onClick={onClose} disabled={isSaving}>
          ã‚­ãƒ£ãƒ³ã‚»ãƒ«
        </Button>
        <Button onClick={handleSave} loading={isSaving}>
          ä¿å­˜
        </Button>
      </Group>
    </UnifiedModal>
  );
}
````

## File: frontend/src/components/common/__tests__/UnifiedModal.test.tsx
````typescript
import '@testing-library/jest-dom';
import { render, screen } from '@testing-library/react';
import { UnifiedModal, type ModalSection } from '../UnifiedModal';

// Mantineã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ãƒ¢ãƒƒã‚¯
jest.mock('@mantine/core', () => ({
  Modal: ({ children, opened, title, overlayProps: _overlayProps, styles: _styles, ...props }: { 
    children: React.ReactNode; 
    opened: boolean; 
    title?: string;
    overlayProps?: unknown;
    styles?: unknown;
  }) => (
    opened ? <div data-testid="modal" {...props}><h1>{title}</h1>{children}</div> : null
  ),
  Stack: ({ children, gap }: { children: React.ReactNode; gap?: string }) => (
    <div data-testid="stack" data-gap={gap}>{children}</div>
  ),
  Divider: ({ label, labelPosition, mb }: { label?: string; labelPosition?: string; mb?: string }) => (
    <hr data-testid="divider" data-label={label} data-position={labelPosition} data-mb={mb} />
  ),
}));

describe('UnifiedModal Component', () => {
  it('should render with children prop (backward compatibility)', () => {
    render(
      <UnifiedModal opened={true} onClose={() => {}} title="Test Modal">
        <div>Test content</div>
      </UnifiedModal>
    );

    expect(screen.getByTestId('modal')).toBeInTheDocument();
    expect(screen.getByText('Test content')).toBeInTheDocument();
  });

  it('should render with sections prop', () => {
    const sections: ModalSection[] = [
      {
        label: 'Section 1',
        content: <div>Content 1</div>,
      },
      {
        label: 'Section 2',
        content: <div>Content 2</div>,
      },
    ];

    render(
      <UnifiedModal opened={true} onClose={() => {}} title="Sections Modal" sections={sections} />
    );

    expect(screen.getByTestId('modal')).toBeInTheDocument();
    expect(screen.getByText('Content 1')).toBeInTheDocument();
    expect(screen.getByText('Content 2')).toBeInTheDocument();
  });

  it('should insert dividers between sections', () => {
    const sections: ModalSection[] = [
      {
        label: 'First Section',
        content: <div>First</div>,
      },
      {
        label: 'Second Section',
        content: <div>Second</div>,
      },
      {
        label: 'Third Section',
        content: <div>Third</div>,
      },
    ];

    render(
      <UnifiedModal opened={true} onClose={() => {}} title="Multi-section Modal" sections={sections} />
    );

    const dividers = screen.getAllByTestId('divider');
    // æœ€åˆã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ãƒ©ãƒ™ãƒ«ãŒã‚ã‚‹ãŸã‚1ã¤ã€2ç•ªç›®ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³å‰ã«1ã¤ã€3ç•ªç›®ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³å‰ã«1ã¤ã€åˆè¨ˆ3ã¤
    expect(dividers.length).toBe(3);
    
    // ãƒ©ãƒ™ãƒ«ã®ç¢ºèª
    expect(dividers[0]).toHaveAttribute('data-label', 'First Section');
    expect(dividers[1]).toHaveAttribute('data-label', 'Second Section');
    expect(dividers[2]).toHaveAttribute('data-label', 'Third Section');
  });

  it('should handle sections without labels', () => {
    const sections: ModalSection[] = [
      {
        content: <div>No label content 1</div>,
      },
      {
        label: 'With Label',
        content: <div>With label content</div>,
      },
    ];

    render(
      <UnifiedModal opened={true} onClose={() => {}} title="Mixed Sections" sections={sections} />
    );

    expect(screen.getByText('No label content 1')).toBeInTheDocument();
    expect(screen.getByText('With label content')).toBeInTheDocument();
    
    // æœ€åˆã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ãƒ©ãƒ™ãƒ«ãªã—ã®ãŸã‚0å€‹ã€2ç•ªç›®ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³(index > 0)ã®ãŸã‚1å€‹ã€åˆè¨ˆ1ã¤
    const dividers = screen.getAllByTestId('divider');
    expect(dividers.length).toBe(1);
    expect(dividers[0]).toHaveAttribute('data-label', 'With Label');
  });

  it('should support single section with label', () => {
    const sections: ModalSection[] = [
      {
        label: 'Only Section',
        content: <div>Single content</div>,
      },
    ];

    render(
      <UnifiedModal opened={true} onClose={() => {}} title="Single Section" sections={sections} />
    );

    expect(screen.getByText('Single content')).toBeInTheDocument();
    
    const dividers = screen.getAllByTestId('divider');
    expect(dividers.length).toBe(1);
    expect(dividers[0]).toHaveAttribute('data-label', 'Only Section');
  });

  it('should not render when opened is false', () => {
    render(
      <UnifiedModal opened={false} onClose={() => {}} title="Closed Modal">
        <div>Hidden content</div>
      </UnifiedModal>
    );

    expect(screen.queryByTestId('modal')).not.toBeInTheDocument();
  });

  it('should maintain backward compatibility with addContentPadding', () => {
    render(
      <UnifiedModal 
        opened={true} 
        onClose={() => {}} 
        title="No Padding Modal"
        addContentPadding={false}
      >
        <div>Content without padding</div>
      </UnifiedModal>
    );

    expect(screen.getByText('Content without padding')).toBeInTheDocument();
  });

  it('should respect addContentPadding with sections', () => {
    const sections: ModalSection[] = [
      {
        label: 'Section 1',
        content: <div>Content 1</div>,
      },
      {
        label: 'Section 2',
        content: <div>Content 2</div>,
      },
    ];

    render(
      <UnifiedModal 
        opened={true} 
        onClose={() => {}} 
        title="Sections No Padding"
        sections={sections}
        addContentPadding={false}
      />
    );

    expect(screen.getByText('Content 1')).toBeInTheDocument();
    expect(screen.getByText('Content 2')).toBeInTheDocument();
    // With addContentPadding=false, sections should not be wrapped in Stack
    expect(screen.queryByTestId('stack')).not.toBeInTheDocument();
  });
});
````

## File: frontend/src/components/context-menu/operation-modal-manager.tsx
````typescript
'use client';

import { ReactNode, useState } from 'react';
import { Button, Group, Text, Divider } from '@mantine/core';
import { notifications } from '@mantine/notifications';
import { UnifiedModal } from '@/components/common';

export type OperationType = 'view' | 'edit' | 'create' | 'delete' | 'duplicate' | 'custom';

interface OperationModalManagerProps<T = unknown> {
  operationType: OperationType | null;
  entity?: T;
  entityType?: string;
  onClose: () => void;
  onConfirm?: (entity?: T) => void | Promise<void>;
  children?: ReactNode;
  customContent?: ReactNode;
}

export function OperationModalManager<T = unknown>({
  operationType,
  entity,
  entityType = 'ã‚¢ã‚¤ãƒ†ãƒ ',
  onClose,
  onConfirm,
  children,
  customContent,
}: OperationModalManagerProps<T>) {
  const [isLoading, setIsLoading] = useState(false);

  const handleConfirm = async () => {
    if (!onConfirm) {
      onClose();
      return;
    }

    setIsLoading(true);
    try {
      await onConfirm(entity);
      
      // æˆåŠŸé€šçŸ¥
      const messages: Record<OperationType, string> = {
        view: '',
        edit: `${entityType}ã‚’æ›´æ–°ã—ã¾ã—ãŸ`,
        create: `${entityType}ã‚’ä½œæˆã—ã¾ã—ãŸ`,
        delete: `${entityType}ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`,
        duplicate: `${entityType}ã‚’è¤‡è£½ã—ã¾ã—ãŸ`,
        custom: 'æ“ä½œãŒå®Œäº†ã—ã¾ã—ãŸ',
      };

      if (operationType && messages[operationType]) {
        notifications.show({
          title: 'æˆåŠŸ',
          message: messages[operationType],
          color: 'green',
        });
      }

      onClose();
    } catch (error) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: error instanceof Error ? error.message : 'æ“ä½œã«å¤±æ•—ã—ã¾ã—ãŸ',
        color: 'red',
      });
    } finally {
      setIsLoading(false);
    }
  };

  if (!operationType) return null;

  // å‰Šé™¤ç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ«
  if (operationType === 'delete') {
    return (
      <UnifiedModal
        opened={true}
        onClose={onClose}
        title={`${entityType}ã®å‰Šé™¤`}
        centered
        size="sm"
      >
        <Text>ã“ã®{entityType}ã‚’å‰Šé™¤ã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ</Text>
        <Text size="sm" c="dimmed">
          ã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚
        </Text>

        <Divider />

        <Group justify="flex-end" gap="sm" mt="md">
          <Button variant="outline" onClick={onClose} disabled={isLoading}>
            ã‚­ãƒ£ãƒ³ã‚»ãƒ«
          </Button>
          <Button color="red" onClick={handleConfirm} loading={isLoading}>
            å‰Šé™¤
          </Button>
        </Group>
      </UnifiedModal>
    );
  }

  // è©³ç´°è¡¨ç¤ºãƒ¢ãƒ¼ãƒ€ãƒ«
  if (operationType === 'view') {
    return (
      <UnifiedModal
        opened={true}
        onClose={onClose}
        title={`${entityType}ã®è©³ç´°`}
        centered
        size="lg"
      >
        {customContent || children}

        <Divider />
        
        <Group justify="flex-end" gap="sm" mt="md">
          <Button onClick={onClose}>é–‰ã˜ã‚‹</Button>
        </Group>
      </UnifiedModal>
    );
  }

  // ç·¨é›†ãƒ»ä½œæˆãƒ»è¤‡è£½ãƒ»ã‚«ã‚¹ã‚¿ãƒ ãƒ¢ãƒ¼ãƒ€ãƒ«
  const titles: Partial<Record<OperationType, string>> = {
    view: `${entityType}ã®è©³ç´°`,
    edit: `${entityType}ã®ç·¨é›†`,
    create: `${entityType}ã®æ–°è¦ä½œæˆ`,
    duplicate: `${entityType}ã®è¤‡è£½`,
    delete: `${entityType}ã®å‰Šé™¤`,
    custom: `${entityType}ã®æ“ä½œ`,
  };

  return (
    <UnifiedModal
      opened={true}
      onClose={onClose}
      title={titles[operationType] || `${entityType}ã®æ“ä½œ`}
      centered
      size="lg"
    >
      {customContent || children}

      <Divider />
      
      <Group justify="flex-end" gap="sm" mt="md">
        <Button variant="outline" onClick={onClose} disabled={isLoading}>
          ã‚­ãƒ£ãƒ³ã‚»ãƒ«
        </Button>
        <Button onClick={handleConfirm} loading={isLoading}>
          {operationType === 'create' ? 'ä½œæˆ' : operationType === 'duplicate' ? 'è¤‡è£½' : 'ä¿å­˜'}
        </Button>
      </Group>
    </UnifiedModal>
  );
}
````

## File: frontend/src/components/kittens/WeightRecordModal.tsx
````typescript
'use client';

import { useEffect } from 'react';
import {
  TextInput,
  NumberInput,
  Textarea,
  Button,
  Group,
  Stack,
  Text,
  Box,
} from '@mantine/core';
import { DateTimePicker } from '@mantine/dates';
import { useForm } from '@mantine/form';
import { IconScale, IconCalendar, IconNotes } from '@tabler/icons-react';
import {
  useCreateWeightRecord,
  useUpdateWeightRecord,
  type WeightRecord,
  type CreateWeightRecordRequest,
} from '@/lib/api/hooks/use-weight-records';
import { UnifiedModal, type ModalSection } from '@/components/common';

interface WeightRecordModalProps {
  opened: boolean;
  onClose: () => void;
  catId: string;
  catName: string;
  /** ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã«æ—¢å­˜ã®è¨˜éŒ²ã‚’æ¸¡ã™ */
  existingRecord?: WeightRecord | null;
  onSuccess?: () => void;
}

interface FormValues {
  weight: number | '';
  recordedAt: Date | null;
  notes: string;
}

/**
 * ä½“é‡è¨˜éŒ²å…¥åŠ›ãƒ¢ãƒ¼ãƒ€ãƒ«
 * æ–°è¦ä½œæˆã¨ç·¨é›†ã®ä¸¡æ–¹ã«å¯¾å¿œ
 */
export function WeightRecordModal({
  opened,
  onClose,
  catId,
  catName,
  existingRecord,
  onSuccess,
}: WeightRecordModalProps) {
  const isEditMode = !!existingRecord;

  const createMutation = useCreateWeightRecord(catId);
  const updateMutation = useUpdateWeightRecord(catId);

  const form = useForm<FormValues>({
    initialValues: {
      weight: '',
      recordedAt: new Date(),
      notes: '',
    },
    validate: {
      weight: (value) => {
        if (value === '' || value === undefined || value === null) {
          return 'ä½“é‡ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„';
        }
        if (typeof value === 'number' && (value < 1 || value > 50000)) {
          return 'ä½“é‡ã¯1gã€œ50000gã®ç¯„å›²ã§å…¥åŠ›ã—ã¦ãã ã•ã„';
        }
        return null;
      },
      recordedAt: (value) => {
        if (!value) {
          return 'è¨˜éŒ²æ—¥æ™‚ã‚’é¸æŠã—ã¦ãã ã•ã„';
        }
        if (value > new Date()) {
          return 'æœªæ¥ã®æ—¥æ™‚ã¯æŒ‡å®šã§ãã¾ã›ã‚“';
        }
        return null;
      },
    },
  });

  // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰æ™‚ã«æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ•ã‚©ãƒ¼ãƒ ã«åæ˜ 
  useEffect(() => {
    if (opened) {
      if (existingRecord) {
        form.setValues({
          weight: existingRecord.weight,
          recordedAt: new Date(existingRecord.recordedAt),
          notes: existingRecord.notes ?? '',
        });
      } else {
        form.reset();
        form.setFieldValue('recordedAt', new Date());
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [opened, existingRecord]);

  const handleSubmit = (values: FormValues) => {
    const data: CreateWeightRecordRequest = {
      weight: values.weight as number,
      recordedAt: values.recordedAt?.toISOString(),
      notes: values.notes || undefined,
    };

    if (isEditMode && existingRecord) {
      updateMutation.mutate(
        { recordId: existingRecord.id, data },
        {
          onSuccess: () => {
            form.reset();
            onClose();
            onSuccess?.();
          },
        }
      );
    } else {
      createMutation.mutate(data, {
        onSuccess: () => {
          form.reset();
          onClose();
          onSuccess?.();
        },
      });
    }
  };

  const isLoading = createMutation.isPending || updateMutation.isPending;

  const sections: ModalSection[] = [
    {
      content: (
        <Box component="form" onSubmit={form.onSubmit(handleSubmit)}>
          <Stack gap="md" p="md">
            {/* å¯¾è±¡ã®çŒ«å */}
            <TextInput
              label="å¯¾è±¡"
              value={catName}
              disabled
              styles={{
                input: {
                  backgroundColor: 'var(--mantine-color-gray-1)',
                },
              }}
            />

            {/* ä½“é‡å…¥åŠ› */}
            <NumberInput
              label="ä½“é‡"
              description="ã‚°ãƒ©ãƒ å˜ä½ã§å…¥åŠ›ã—ã¦ãã ã•ã„"
              placeholder="350"
              min={1}
              max={50000}
              step={5}
              suffix=" g"
              leftSection={<IconScale size={16} />}
              required
              {...form.getInputProps('weight')}
            />

            {/* è¨˜éŒ²æ—¥æ™‚ */}
            <DateTimePicker
              label="è¨˜éŒ²æ—¥æ™‚"
              placeholder="è¨˜éŒ²æ—¥æ™‚ã‚’é¸æŠ"
              leftSection={<IconCalendar size={16} />}
              maxDate={new Date()}
              required
              valueFormat="YYYY/MM/DD HH:mm"
              {...form.getInputProps('recordedAt')}
            />

            {/* ãƒ¡ãƒ¢ */}
            <Textarea
              label="ãƒ¡ãƒ¢"
              placeholder="ä¾‹: ãƒŸãƒ«ã‚¯ã‚’ã‚ˆãé£²ã‚“ã§ã„ã‚‹ã€å…ƒæ°—ãŒã‚ã‚‹ ãªã©"
              leftSection={<IconNotes size={16} />}
              autosize
              minRows={2}
              maxRows={4}
              {...form.getInputProps('notes')}
            />
          </Stack>
        </Box>
      ),
    },
    {
      content: (
        <Group justify="flex-end" mt="md">
          <Button variant="default" onClick={onClose} disabled={isLoading}>
            ã‚­ãƒ£ãƒ³ã‚»ãƒ«
          </Button>
          <Button 
            loading={isLoading} 
            onClick={() => {
              form.validate();
              if (form.isValid()) {
                void handleSubmit(form.values);
              }
            }}
          >
            {isEditMode ? 'æ›´æ–°' : 'è¨˜éŒ²'}
          </Button>
        </Group>
      ),
    },
  ];

  return (
    <UnifiedModal
      opened={opened}
      onClose={onClose}
      title={
        <Group gap="xs">
          <IconScale size={20} />
          <Text fw={600}>
            {isEditMode ? 'ä½“é‡è¨˜éŒ²ã‚’ç·¨é›†' : 'ä½“é‡ã‚’è¨˜éŒ²'}
          </Text>
        </Group>
      }
      size="md"
      addContentPadding={false}
      sections={sections}
    />
  );
}

export default WeightRecordModal;
````

## File: frontend/src/components/pedigrees/PedigreeList.tsx
````typescript
'use client';

import { useState } from 'react';
import {
  Paper,
  TextInput,
  Select,
  Button,
  Table,
  Pagination,
  Badge,
  Group,
  Stack,
  Text,
  Card,
  Grid,
  ActionIcon,
  Tooltip,
  LoadingOverlay,
} from '@mantine/core';
import { IconSearch, IconFilter, IconFileText, IconRefresh, IconPrinter, IconCopy } from '@tabler/icons-react';
import { useRouter } from 'next/navigation';
import { useGetPedigrees } from '@/lib/api/hooks/use-pedigrees';
import { getPublicApiBaseUrl } from '@/lib/api/public-api-base-url';

interface PedigreeData {
  id: string;
  pedigreeId: string;
  catName: string;
  breedCode: number | null;
  genderCode: number | null;
  gender?: { code: number; name: string } | null;
  breed?: { code: number; name: string } | null;
  coatColor?: { code: number; name: string } | null;
  birthDate: string | null;
  breederName: string | null;
  ownerName: string | null;
  registrationDate: string | null;
  notes: string | null;
  fatherPedigree?: { pedigreeId: string; catName: string } | null;
  motherPedigree?: { pedigreeId: string; catName: string } | null;
}

interface PedigreeListProps {
  onSelectFamilyTree?: (id: string) => void;
}

export function PedigreeList({ onSelectFamilyTree }: PedigreeListProps) {
  const router = useRouter();
  const [searchTerm, setSearchTerm] = useState('');
  const [genderFilter, setGenderFilter] = useState<string | null>(null);
  const [currentPage, setCurrentPage] = useState(1);

  const apiBaseUrl = getPublicApiBaseUrl();

  const genderOptions = [
    { value: '', label: 'å…¨ã¦' },
    { value: '1', label: 'é›„' },
    { value: '2', label: 'é›Œ' },
  ];

  // React Query ãƒ•ãƒƒã‚¯ã§ãƒ‡ãƒ¼ã‚¿å–å¾—
  const { data, isLoading, refetch } = useGetPedigrees({
    page: currentPage,
    limit: 20,
    search: searchTerm || undefined,
    gender: genderFilter || undefined,
  });

  const pedigrees = (data?.data || []) as unknown as PedigreeData[];
  const total = data?.meta?.total || 0;
  const totalPages = data?.meta?.totalPages || 1;

  const handleSearch = () => {
    setCurrentPage(1);
    refetch();
  };

  const handlePageChange = (page: number) => {
    setCurrentPage(page);
  };

  const formatDate = (dateString: string | null) => {
    if (!dateString) return 'ä¸æ˜';
    return new Date(dateString).toLocaleDateString('ja-JP', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
    });
  };

  const formatGender = (pedigree: PedigreeData) => {
    if (pedigree.gender?.name) {
      return pedigree.gender.name;
    }
    switch (pedigree.genderCode) {
      case 1: return 'Male';
      case 2: return 'Female';
      case 3: return 'Neuter';
      case 4: return 'Spay';
      default: return 'Unknown';
    }
  };

  const getGenderColor = (pedigree: PedigreeData) => {
    const code = pedigree.gender?.code ?? pedigree.genderCode;
    switch (code) {
      case 1: return 'blue';
      case 2: return 'pink';
      case 3: return 'cyan';
      case 4: return 'violet';
      default: return 'gray';
    }
  };

  const openPedigreePdf = (pedigreeId: string) => {
    const pdfUrl = `${apiBaseUrl}/pedigrees/pedigree-id/${encodeURIComponent(pedigreeId)}/pdf`;

    const newTab = window.open(pdfUrl, '_blank');
    if (!newTab) {
      // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚ŒãŸå ´åˆã¯åŒä¸€ã‚¿ãƒ–ã§é–‹ã
      window.location.assign(pdfUrl);
    }
  };

  return (
    <Stack gap="md">
      <Group justify="space-between">
        <Group>
          <Badge size="lg" color="blue">
            ç·è¨ˆ: {total}ä»¶
          </Badge>
        </Group>
      </Group>

      {/* ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãƒ»æ¤œç´¢ã‚»ã‚¯ã‚·ãƒ§ãƒ³ */}
      <Paper p="md" shadow="sm">
        <Grid>
          <Grid.Col span={{ base: 12, md: 6 }}>
            <TextInput
              placeholder="çŒ«åã€ç¹æ®–è€…åã§æ¤œç´¢..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              leftSection={<IconSearch size={16} />}
              onKeyPress={(e) => e.key === 'Enter' && handleSearch()}
            />
          </Grid.Col>
          <Grid.Col span={{ base: 12, md: 3 }}>
            <Select
              placeholder="æ€§åˆ¥ã§çµã‚Šè¾¼ã¿"
              data={genderOptions}
              value={genderFilter}
              onChange={setGenderFilter}
              leftSection={<IconFilter size={16} />}
              clearable
            />
          </Grid.Col>
          <Grid.Col span={{ base: 12, md: 3 }}>
            <Group>
              <Button onClick={handleSearch} leftSection={<IconSearch size={16} />}>
                æ¤œç´¢
              </Button>
              <ActionIcon
                variant="light"
                onClick={() => refetch()}
                size="lg"
              >
                <IconRefresh size={16} />
              </ActionIcon>
            </Group>
          </Grid.Col>
        </Grid>
      </Paper>

      {/* è¡€çµ±æ›¸ãƒªã‚¹ãƒˆãƒ†ãƒ¼ãƒ–ãƒ« */}
      <Paper shadow="sm" style={{ position: 'relative' }}>
        <LoadingOverlay visible={isLoading} overlayProps={{ radius: "sm", blur: 2 }} />

        <Table striped highlightOnHover>
          <Table.Thead>
            <Table.Tr>
              <Table.Th>è¡€çµ±æ›¸ç•ªå·</Table.Th>
              <Table.Th>åå‰</Table.Th>
              <Table.Th>æ€§åˆ¥</Table.Th>
              <Table.Th>çŒ«ç¨®</Table.Th>
              <Table.Th>è‰²æŸ„</Table.Th>
              <Table.Th>ç”Ÿå¹´æœˆæ—¥</Table.Th>
              <Table.Th>ç¹æ®–è€…</Table.Th>
              <Table.Th>çˆ¶è¦ª</Table.Th>
              <Table.Th>æ¯è¦ª</Table.Th>
              <Table.Th>æ“ä½œ</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>
            {pedigrees.map((pedigree) => (
              <Table.Tr key={pedigree.id}>
                <Table.Td>
                  <Text fw={600} size="sm">
                    {pedigree.pedigreeId}
                  </Text>
                </Table.Td>
                <Table.Td>
                  <Text fw={500}>
                    {pedigree.catName || 'åå‰ãªã—'}
                  </Text>
                </Table.Td>
                <Table.Td>
                  <Badge color={getGenderColor(pedigree)} size="sm" tt="none">
                    {formatGender(pedigree)}
                  </Badge>
                </Table.Td>
                <Table.Td>
                  <Text size="sm">
                    {pedigree.breed?.name || pedigree.breedCode || '-'}
                  </Text>
                </Table.Td>
                <Table.Td>
                  <Text size="sm">
                    {pedigree.coatColor?.name || '-'}
                  </Text>
                </Table.Td>
                <Table.Td>
                  <Text size="sm">
                    {formatDate(pedigree.birthDate)}
                  </Text>
                </Table.Td>
                <Table.Td>
                  <Text size="sm" c="dimmed">
                    {pedigree.breederName || '-'}
                  </Text>
                </Table.Td>
                <Table.Td>
                  <Text size="sm" c="blue">
                    {pedigree.fatherPedigree
                      ? `${pedigree.fatherPedigree.pedigreeId} (${pedigree.fatherPedigree.catName})`
                      : '-'
                    }
                  </Text>
                </Table.Td>
                <Table.Td>
                  <Text size="sm" c="pink">
                    {pedigree.motherPedigree
                      ? `${pedigree.motherPedigree.pedigreeId} (${pedigree.motherPedigree.catName})`
                      : '-'
                    }
                  </Text>
                </Table.Td>
                <Table.Td>
                  <Group gap="xs">
                    <Tooltip label="å®¶ç³»å›³ã‚’è¦‹ã‚‹">
                      <ActionIcon
                        variant="light"
                        color="green"
                        aria-label="å®¶ç³»å›³ã‚’è¦‹ã‚‹"
                        onClick={() => onSelectFamilyTree ? onSelectFamilyTree(pedigree.id) : router.push(`/pedigrees?tab=tree&id=${pedigree.id}`)}
                      >
                        <IconFileText size={16} />
                      </ActionIcon>
                    </Tooltip>
                    <Tooltip label="æ–°è¦ç™»éŒ²ã«ã‚³ãƒ”ãƒ¼">
                      <ActionIcon
                        variant="light"
                        color="blue"
                        aria-label="æ–°è¦ç™»éŒ²ã«ã‚³ãƒ”ãƒ¼"
                        onClick={() => router.push(`/pedigrees?tab=register&copyFromId=${encodeURIComponent(pedigree.id)}`)}
                      >
                        <IconCopy size={16} />
                      </ActionIcon>
                    </Tooltip>
                    <Tooltip label="è¡€çµ±æ›¸PDFã‚’å°åˆ·">
                      <ActionIcon
                        variant="light"
                        color="orange"
                        aria-label="è¡€çµ±æ›¸PDFã‚’å°åˆ·"
                        onClick={() => {
                          openPedigreePdf(pedigree.pedigreeId);
                        }}
                      >
                        <IconPrinter size={16} />
                      </ActionIcon>
                    </Tooltip>
                  </Group>
                </Table.Td>
              </Table.Tr>
            ))}
          </Table.Tbody>
        </Table>

        {pedigrees.length === 0 && !isLoading && (
          <Card mt="md" p="xl" style={{ textAlign: 'center' }}>
            <Text size="lg" c="dimmed">
              è¡€çµ±æ›¸ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ
            </Text>
            <Text size="sm" c="dimmed" mt="xs">
              æ¤œç´¢æ¡ä»¶ã‚’å¤‰æ›´ã—ã¦ãŠè©¦ã—ãã ã•ã„
            </Text>
          </Card>
        )}
      </Paper>

      {/* ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ */}
      {totalPages > 1 && (
        <Group justify="center">
          <Pagination
            value={currentPage}
            onChange={handlePageChange}
            total={totalPages}
            size="md"
          />
        </Group>
      )}
    </Stack>
  );
}
````

## File: frontend/src/components/print-templates/PrintTemplateManager.tsx
````typescript
'use client';

import { useState, useEffect, useCallback, useRef } from 'react';
import {
  Paper,
  Stack,
  Group,
  Text,
  Select,
  Button,
  NumberInput,
  TextInput,
  Tabs,
  ActionIcon,
  Badge,
  Card,
  Grid,
  Tooltip,
  LoadingOverlay,
  Alert,
  Modal,
  ScrollArea,
  Slider,
  Switch,
  FileInput,
} from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { notifications } from '@mantine/notifications';
import {
  IconPlus,
  IconTrash,
  IconCopy,
  IconPrinter,
  IconSettings,
  IconEye,
  IconCheck,
  IconAlertCircle,
  IconGripVertical,
  IconPhoto,
  IconUpload,
  IconX,
} from '@tabler/icons-react';
import { getPublicApiBaseUrl } from '@/lib/api/public-api-base-url';

function escapeHtml(text: string): string {
  return text
    .replaceAll('&', '&amp;')
    .replaceAll('<', '&lt;')
    .replaceAll('>', '&gt;')
    .replaceAll('"', '&quot;')
    .replaceAll("'", '&#39;');
}

function buildPrintHtml(params: {
  template: PrintTemplate;
  showSampleData: boolean;
  sampleData?: Record<string, string>;
}): string {
  const { template, showSampleData, sampleData } = params;

  const safeTitle = escapeHtml(template.name);
  const pageWidthMm = template.paperWidth;
  const pageHeightMm = template.paperHeight;

  const fieldHtml = Object.entries(template.positions)
    .map(([fieldName, pos]) => {
      const text = showSampleData
        ? (sampleData?.[fieldName] ?? FIELD_LABELS[fieldName] ?? fieldName)
        : (FIELD_LABELS[fieldName] ?? fieldName);

      const align: 'left' | 'center' | 'right' = pos.align ?? 'left';
      const fontWeight: 'normal' | 'bold' = pos.fontWeight ?? 'normal';
      const fontSizePx = pos.fontSize ?? 12;
      const color = showSampleData ? (pos.color ?? '#333') : '#333';
      const widthMm = pos.width ?? 50;
      const heightMm = pos.height ?? 15;

      return `
        <div
          class="field"
          style="
            left: ${pos.x}mm;
            top: ${pos.y}mm;
            width: ${widthMm}mm;
            height: ${heightMm}mm;
            font-size: ${fontSizePx}px;
            text-align: ${align};
            font-weight: ${fontWeight};
            color: ${escapeHtml(color)};
          "
        >${escapeHtml(text)}</div>
      `.trim();
    })
    .join('\n');

  const backgroundImageStyle = template.backgroundUrl
    ? `background-image: url(${escapeHtml(template.backgroundUrl)});`
    : '';
  const showOverlay = !!template.backgroundUrl && template.backgroundOpacity < 100;
  const overlayAlpha = (100 - template.backgroundOpacity) / 100;

  return `
<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>${safeTitle} - å°åˆ·</title>
    <style>
      @page { size: ${pageWidthMm}mm ${pageHeightMm}mm; margin: 0; }
      html, body { margin: 0; padding: 0; width: ${pageWidthMm}mm; height: ${pageHeightMm}mm; }
      * { box-sizing: border-box; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
      .paper {
        position: relative;
        width: ${pageWidthMm}mm;
        height: ${pageHeightMm}mm;
        background-color: #fff;
        background-size: cover;
        background-position: center;
        ${backgroundImageStyle}
        overflow: hidden;
      }
      .overlay {
        position: absolute;
        inset: 0;
        background: rgba(255, 255, 255, ${overlayAlpha});
        pointer-events: none;
      }
      .field {
        position: absolute;
        white-space: pre-wrap;
        overflow: hidden;
        padding: 0;
      }
    </style>
  </head>
  <body>
    <div class="paper">
      ${showOverlay ? '<div class="overlay"></div>' : ''}
      ${fieldHtml}
    </div>
  </body>
</html>
  `.trim();
}

// å‹å®šç¾©
interface Position {
  x: number;
  y: number;
  width?: number;  // ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ã®å¹…ï¼ˆmmï¼‰
  height?: number; // ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ã®é«˜ã•ï¼ˆmmï¼‰
  fontSize?: number;
  align?: 'left' | 'center' | 'right';
  color?: string;
  fontWeight?: 'normal' | 'bold';
}

interface PrintTemplate {
  id: string;
  tenantId: string | null;
  name: string;
  description: string | null;
  category: string;
  paperWidth: number;
  paperHeight: number;
  backgroundUrl: string | null;
  backgroundOpacity: number;
  positions: Record<string, Position>;
  fontSizes: Record<string, number> | null;
  isActive: boolean;
  isDefault: boolean;
  displayOrder: number;
  createdAt: string;
  updatedAt: string;
}

interface CategoryOption {
  value: string;
  label: string;
}

interface TenantOption {
  value: string;
  label: string;
}

// ã‚«ãƒ†ã‚´ãƒªãƒ©ãƒ™ãƒ«
const CATEGORY_LABELS: Record<string, string> = {
  PEDIGREE: 'è¡€çµ±æ›¸',
  KITTEN_TRANSFER: 'å­çŒ«è­²æ¸¡è¨¼æ˜æ›¸',
  HEALTH_CERTIFICATE: 'å¥åº·è¨ºæ–­æ›¸',
  VACCINATION_RECORD: 'ãƒ¯ã‚¯ãƒãƒ³æ¥ç¨®è¨˜éŒ²',
  BREEDING_RECORD: 'ç¹æ®–è¨˜éŒ²',
  CONTRACT: 'å¥‘ç´„æ›¸',
  INVOICE: 'è«‹æ±‚æ›¸/é ˜åæ›¸',
  CUSTOM: 'ã‚«ã‚¹ã‚¿ãƒ æ›¸é¡',
};

// ãƒ—ãƒªã‚»ãƒƒãƒˆç”¨ç´™ã‚µã‚¤ã‚ºï¼ˆmmï¼‰
const PAPER_PRESETS = [
  { label: 'A4 ç¸¦', width: 210, height: 297 },
  { label: 'A4 æ¨ª', width: 297, height: 210 },
  { label: 'A5 ç¸¦', width: 148, height: 210 },
  { label: 'A5 æ¨ª', width: 210, height: 148 },
  { label: 'B5 ç¸¦', width: 182, height: 257 },
  { label: 'B5 æ¨ª', width: 257, height: 182 },
  { label: 'ã¯ãŒã ç¸¦', width: 100, height: 148 },
  { label: 'ã¯ãŒã æ¨ª', width: 148, height: 100 },
  { label: 'ãƒ¬ã‚¿ãƒ¼ ç¸¦', width: 216, height: 279 },
  { label: 'ãƒ¬ã‚¿ãƒ¼ æ¨ª', width: 279, height: 216 },
  { label: 'ã‚«ã‚¹ã‚¿ãƒ ', width: 0, height: 0, isCustom: true },
];

// ã‚«ãƒ†ã‚´ãƒªã”ã¨ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
const DEFAULT_FIELDS: Record<string, string[]> = {
  PEDIGREE: ['catName', 'pedigreeId', 'breed', 'birthDate', 'gender', 'eyeColor', 'coatColor', 'breederName', 'ownerName'],
  KITTEN_TRANSFER: ['kittenName', 'breed', 'birthDate', 'gender', 'microchipNo', 'breederName', 'buyerName', 'transferDate', 'price'],
  HEALTH_CERTIFICATE: ['catName', 'breed', 'birthDate', 'ownerName', 'checkDate', 'weight', 'veterinarian', 'clinicName'],
  VACCINATION_RECORD: ['catName', 'breed', 'birthDate', 'vaccineName', 'vaccinationDate', 'nextDueDate', 'veterinarian'],
  BREEDING_RECORD: ['maleName', 'femaleName', 'matingDate', 'expectedDueDate', 'actualBirthDate', 'numberOfKittens'],
  CONTRACT: ['title', 'date', 'partyA', 'partyB', 'content', 'signature1', 'signature2'],
  INVOICE: ['invoiceNo', 'date', 'customerName', 'items', 'subtotal', 'tax', 'total'],
  CUSTOM: ['field1', 'field2', 'field3'],
};

// ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®æ—¥æœ¬èªãƒ©ãƒ™ãƒ«
const FIELD_LABELS: Record<string, string> = {
  catName: 'çŒ«å',
  pedigreeId: 'è¡€çµ±æ›¸ç•ªå·',
  breed: 'å“ç¨®',
  birthDate: 'ç”Ÿå¹´æœˆæ—¥',
  gender: 'æ€§åˆ¥',
  eyeColor: 'ç›®ã®è‰²',
  coatColor: 'æ¯›è‰²',
  breederName: 'ç¹æ®–è€…',
  ownerName: 'æ‰€æœ‰è€…',
  kittenName: 'å­çŒ«å',
  microchipNo: 'ãƒã‚¤ã‚¯ãƒ­ãƒãƒƒãƒ—ç•ªå·',
  buyerName: 'è³¼å…¥è€…',
  transferDate: 'è­²æ¸¡æ—¥',
  price: 'ä¾¡æ ¼',
  checkDate: 'æ¤œæŸ»æ—¥',
  weight: 'ä½“é‡',
  veterinarian: 'ç£åŒ»å¸«',
  clinicName: 'ç—…é™¢å',
  vaccineName: 'ãƒ¯ã‚¯ãƒãƒ³å',
  vaccinationDate: 'æ¥ç¨®æ—¥',
  nextDueDate: 'æ¬¡å›æ¥ç¨®äºˆå®šæ—¥',
  maleName: 'çˆ¶çŒ«å',
  femaleName: 'æ¯çŒ«å',
  matingDate: 'äº¤é…æ—¥',
  expectedDueDate: 'å‡ºç”£äºˆå®šæ—¥',
  actualBirthDate: 'å®Ÿéš›ã®å‡ºç”£æ—¥',
  numberOfKittens: 'å­çŒ«æ•°',
  title: 'ã‚¿ã‚¤ãƒˆãƒ«',
  date: 'æ—¥ä»˜',
  partyA: 'ç”²',
  partyB: 'ä¹™',
  content: 'å†…å®¹',
  signature1: 'ç½²å1',
  signature2: 'ç½²å2',
  invoiceNo: 'è«‹æ±‚æ›¸ç•ªå·',
  customerName: 'é¡§å®¢å',
  items: 'æ˜ç´°',
  subtotal: 'å°è¨ˆ',
  tax: 'æ¶ˆè²»ç¨',
  total: 'åˆè¨ˆ',
  field1: 'ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰1',
  field2: 'ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰2',
  field3: 'ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰3',
};

// ã‚«ãƒ†ã‚´ãƒªåˆ¥ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿
const SAMPLE_DATA: Record<string, Record<string, string>> = {
  PEDIGREE: {
    catName: 'ãƒŸã‚±ã¡ã‚ƒã‚“',
    pedigreeId: 'TICA-2024-12345',
    breed: 'ãƒ¡ã‚¤ãƒ³ã‚¯ãƒ¼ãƒ³',
    birthDate: '2023å¹´5æœˆ15æ—¥',
    gender: 'ãƒ¡ã‚¹',
    eyeColor: 'ã‚´ãƒ¼ãƒ«ãƒ‰',
    coatColor: 'ãƒ–ãƒ©ã‚¦ãƒ³ã‚¿ãƒ“ãƒ¼',
    breederName: 'ç”°ä¸­ èŠ±å­',
    ownerName: 'å±±ç”° å¤ªéƒ',
  },
  KITTEN_TRANSFER: {
    kittenName: 'ãƒãƒ“ã¡ã‚ƒã‚“',
    breed: 'ã‚¹ã‚³ãƒ†ã‚£ãƒƒã‚·ãƒ¥ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰',
    birthDate: '2024å¹´10æœˆ1æ—¥',
    gender: 'ã‚ªã‚¹',
    microchipNo: '123456789012345',
    breederName: 'ä½è—¤ ã‚­ãƒ£ãƒƒãƒ†ãƒªãƒ¼',
    buyerName: 'éˆ´æœ¨ ä¸€éƒ',
    transferDate: '2024å¹´12æœˆ10æ—¥',
    price: 'Â¥350,000',
  },
  HEALTH_CERTIFICATE: {
    catName: 'ã‚¿ãƒ',
    breed: 'ãƒ–ãƒªãƒ†ã‚£ãƒƒã‚·ãƒ¥ã‚·ãƒ§ãƒ¼ãƒˆãƒ˜ã‚¢',
    birthDate: '2022å¹´3æœˆ20æ—¥',
    ownerName: 'é«˜æ©‹ ç¾å’²',
    checkDate: '2024å¹´12æœˆ1æ—¥',
    weight: '4.5kg',
    veterinarian: 'å±±æœ¬ ç£åŒ»å¸«',
    clinicName: 'ã•ãã‚‰å‹•ç‰©ç—…é™¢',
  },
  VACCINATION_RECORD: {
    catName: 'ã‚¯ãƒ­',
    breed: 'ãƒŸãƒƒã‚¯ã‚¹',
    birthDate: '2021å¹´7æœˆ10æ—¥',
    vaccineName: '3ç¨®æ··åˆãƒ¯ã‚¯ãƒãƒ³',
    vaccinationDate: '2024å¹´11æœˆ15æ—¥',
    nextDueDate: '2025å¹´11æœˆ15æ—¥',
    veterinarian: 'ç”°æ‘ ç£åŒ»å¸«',
  },
  BREEDING_RECORD: {
    maleName: 'ã‚­ãƒ³ã‚°',
    femaleName: 'ã‚¯ã‚¤ãƒ¼ãƒ³',
    matingDate: '2024å¹´9æœˆ1æ—¥',
    expectedDueDate: '2024å¹´11æœˆ3æ—¥',
    actualBirthDate: '2024å¹´11æœˆ5æ—¥',
    numberOfKittens: '5',
  },
  CONTRACT: {
    title: 'çŒ«è­²æ¸¡å¥‘ç´„æ›¸',
    date: '2024å¹´12æœˆ13æ—¥',
    partyA: 'æ ªå¼ä¼šç¤¾ãƒã‚³ãƒã‚¦ã‚¹',
    partyB: 'å±±ç”° å¤ªéƒ',
    content: 'è­²æ¸¡æ¡ä»¶ã®è©³ç´°...',
    signature1: 'ï¼ˆç”²ã®ç½²åï¼‰',
    signature2: 'ï¼ˆä¹™ã®ç½²åï¼‰',
  },
  INVOICE: {
    invoiceNo: 'INV-2024-0001',
    date: '2024å¹´12æœˆ13æ—¥',
    customerName: 'ç”°ä¸­ èŠ±å­ æ§˜',
    items: 'å­çŒ«ä»£é‡‘ / ãƒ¯ã‚¯ãƒãƒ³ä»£',
    subtotal: 'Â¥300,000',
    tax: 'Â¥30,000',
    total: 'Â¥330,000',
  },
  CUSTOM: {
    field1: 'ã‚«ã‚¹ã‚¿ãƒ ãƒ‡ãƒ¼ã‚¿1',
    field2: 'ã‚«ã‚¹ã‚¿ãƒ ãƒ‡ãƒ¼ã‚¿2',
    field3: 'ã‚«ã‚¹ã‚¿ãƒ ãƒ‡ãƒ¼ã‚¿3',
  },
};

export function PrintTemplateManager() {
  const [templates, setTemplates] = useState<PrintTemplate[]>([]);
  const [categories, setCategories] = useState<CategoryOption[]>([]);
  const [tenants, setTenants] = useState<TenantOption[]>([]);
  const [selectedCategory, setSelectedCategory] = useState<string | null>(null);
  const [selectedTenantFilter, setSelectedTenantFilter] = useState<string | null>(null);
  const [selectedTemplate, setSelectedTemplate] = useState<PrintTemplate | null>(null);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [hasChanges, setHasChanges] = useState(false);
  const [createModalOpened, { open: openCreateModal, close: closeCreateModal }] = useDisclosure(false);
  const [printModalOpened, { open: openPrintModal, close: closePrintModal }] = useDisclosure(false);
  const [printTarget, setPrintTarget] = useState<PrintTemplate | null>(null);
  const [printUseSampleData, setPrintUseSampleData] = useState(false);
  const [printHtml, setPrintHtml] = useState<string | null>(null);
  const printFrameRef = useRef<HTMLIFrameElement | null>(null);
  const hasRequestedPrintRef = useRef(false);
  const [newTemplateName, setNewTemplateName] = useState('');
  const [newTemplateCategory, setNewTemplateCategory] = useState<string | null>(null);
  const [newTemplateTenant, setNewTemplateTenant] = useState<string | null>(null);
  const [selectedPaperPreset, setSelectedPaperPreset] = useState<string | null>(null);
  const [customPaperWidth, setCustomPaperWidth] = useState<number>(210);
  const [customPaperHeight, setCustomPaperHeight] = useState<number>(297);
  const [showSampleData, setShowSampleData] = useState(false);
  const [uploadingBackground, setUploadingBackground] = useState(false);

  const apiBaseUrl = getPublicApiBaseUrl();

  // ã‚«ãƒ†ã‚´ãƒªä¸€è¦§ã‚’å–å¾—
  const fetchCategories = useCallback(async () => {
    try {
      const response = await fetch(`${apiBaseUrl}/print-templates/categories`, {
        credentials: 'include',
      });
      if (!response.ok) throw new Error('ã‚«ãƒ†ã‚´ãƒªã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
      const json = await response.json();
      setCategories(json.data || []);
    } catch (err) {
      console.error('ã‚«ãƒ†ã‚´ãƒªå–å¾—ã‚¨ãƒ©ãƒ¼:', err);
    }
  }, [apiBaseUrl]);

  // ãƒ†ãƒŠãƒ³ãƒˆä¸€è¦§ã‚’å–å¾—
  const fetchTenants = useCallback(async () => {
    try {
      const response = await fetch(`${apiBaseUrl}/tenants`, {
        credentials: 'include',
      });
      if (!response.ok) throw new Error('ãƒ†ãƒŠãƒ³ãƒˆã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
      const json = await response.json();
      const tenantData = json.data || json || [];
      const options = tenantData.map((t: { id: string; name: string }) => ({
        value: t.id,
        label: t.name,
      }));
      setTenants([{ value: '', label: 'å…¨ãƒ†ãƒŠãƒ³ãƒˆå…±é€šï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«ï¼‰' }, ...options]);
    } catch (err) {
      console.error('ãƒ†ãƒŠãƒ³ãƒˆå–å¾—ã‚¨ãƒ©ãƒ¼:', err);
      // ãƒ†ãƒŠãƒ³ãƒˆå–å¾—ã«å¤±æ•—ã—ã¦ã‚‚ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯è¡¨ç¤º
      setTenants([{ value: '', label: 'å…¨ãƒ†ãƒŠãƒ³ãƒˆå…±é€šï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«ï¼‰' }]);
    }
  }, [apiBaseUrl]);

  // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä¸€è¦§ã‚’å–å¾—
  const fetchTemplates = useCallback(async () => {
    setLoading(true);
    try {
      const params = new URLSearchParams();
      if (selectedCategory) params.append('category', selectedCategory);
      if (selectedTenantFilter) params.append('tenantId', selectedTenantFilter);
      params.append('includeGlobal', 'true');

      const response = await fetch(`${apiBaseUrl}/print-templates?${params}`, {
        credentials: 'include',
      });
      if (!response.ok) throw new Error('ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
      const json = await response.json();
      setTemplates(json.data || []);
    } catch (err) {
      console.error('ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå–å¾—ã‚¨ãƒ©ãƒ¼:', err);
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: 'ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ',
        color: 'red',
      });
    } finally {
      setLoading(false);
    }
  }, [apiBaseUrl, selectedCategory, selectedTenantFilter]);

  useEffect(() => {
    fetchCategories();
    fetchTenants();
  }, [fetchCategories, fetchTenants]);

  useEffect(() => {
    fetchTemplates();
  }, [fetchTemplates]);

  // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’é¸æŠ
  const handleSelectTemplate = (template: PrintTemplate) => {
    if (hasChanges) {
      if (!confirm('å¤‰æ›´ãŒä¿å­˜ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ç ´æ£„ã—ã¾ã™ã‹ï¼Ÿ')) {
        return;
      }
    }
    setSelectedTemplate(template);
    setHasChanges(false);
  };

  // æ–°è¦ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ä½œæˆ
  const handleCreateTemplate = async () => {
    if (!newTemplateName || !newTemplateCategory) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: 'ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆåã¨ã‚«ãƒ†ã‚´ãƒªã‚’å…¥åŠ›ã—ã¦ãã ã•ã„',
        color: 'red',
      });
      return;
    }

    const preset = PAPER_PRESETS.find(p => p.label === selectedPaperPreset);
    const isCustomSize = !preset || preset.isCustom;
    const paperWidth = isCustomSize ? customPaperWidth : preset.width;
    const paperHeight = isCustomSize ? customPaperHeight : preset.height;
    
    const defaultFields = DEFAULT_FIELDS[newTemplateCategory] || DEFAULT_FIELDS.CUSTOM;
    const positions: Record<string, Position> = {};
    
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®åˆæœŸä½ç½®ã‚’è¨­å®š
    defaultFields.forEach((field, index) => {
      positions[field] = {
        x: 20,
        y: 20 + (index * 15),
        fontSize: 12,
        align: 'left',
      };
    });

    setSaving(true);
    try {
      const response = await fetch(`${apiBaseUrl}/print-templates`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({
          name: newTemplateName,
          category: newTemplateCategory,
          tenantId: newTemplateTenant || null,
          paperWidth,
          paperHeight,
          positions,
          fontSizes: {},
        }),
      });

      if (!response.ok) throw new Error('ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ');

      const json = await response.json();
      notifications.show({
        title: 'ä½œæˆå®Œäº†',
        message: 'ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ä½œæˆã—ã¾ã—ãŸ',
        color: 'green',
        icon: <IconCheck size={16} />,
      });

      closeCreateModal();
      setNewTemplateName('');
      setNewTemplateCategory(null);
      setNewTemplateTenant(null);
      setSelectedPaperPreset(null);
      setCustomPaperWidth(210);
      setCustomPaperHeight(297);
      fetchTemplates();
      setSelectedTemplate(json.data);
    } catch (err) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: err instanceof Error ? err.message : 'ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ',
        color: 'red',
      });
    } finally {
      setSaving(false);
    }
  };

  // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ä¿å­˜
  const handleSaveTemplate = async () => {
    if (!selectedTemplate) return;

    setSaving(true);
    try {
      const response = await fetch(`${apiBaseUrl}/print-templates/${selectedTemplate.id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({
          name: selectedTemplate.name,
          description: selectedTemplate.description,
          paperWidth: selectedTemplate.paperWidth,
          paperHeight: selectedTemplate.paperHeight,
          backgroundUrl: selectedTemplate.backgroundUrl,
          backgroundOpacity: selectedTemplate.backgroundOpacity,
          positions: selectedTemplate.positions,
          fontSizes: selectedTemplate.fontSizes,
          isDefault: selectedTemplate.isDefault,
        }),
      });

      if (!response.ok) throw new Error('ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ');

      notifications.show({
        title: 'ä¿å­˜å®Œäº†',
        message: 'ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ä¿å­˜ã—ã¾ã—ãŸ',
        color: 'green',
        icon: <IconCheck size={16} />,
      });
      setHasChanges(false);
      fetchTemplates();
    } catch (err) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: err instanceof Error ? err.message : 'ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ',
        color: 'red',
      });
    } finally {
      setSaving(false);
    }
  };

  // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’è¤‡è£½
  const handleDuplicateTemplate = async (template: PrintTemplate) => {
    const newName = prompt('æ–°ã—ã„ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆåã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:', `${template.name} (ã‚³ãƒ”ãƒ¼)`);
    if (!newName) return;

    setSaving(true);
    try {
      const response = await fetch(`${apiBaseUrl}/print-templates/${template.id}/duplicate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ name: newName }),
      });

      if (!response.ok) throw new Error('è¤‡è£½ã«å¤±æ•—ã—ã¾ã—ãŸ');

      notifications.show({
        title: 'è¤‡è£½å®Œäº†',
        message: 'ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’è¤‡è£½ã—ã¾ã—ãŸ',
        color: 'green',
        icon: <IconCheck size={16} />,
      });
      fetchTemplates();
    } catch (err) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: err instanceof Error ? err.message : 'è¤‡è£½ã«å¤±æ•—ã—ã¾ã—ãŸ',
        color: 'red',
      });
    } finally {
      setSaving(false);
    }
  };

  // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’å‰Šé™¤
  const handleDeleteTemplate = async (template: PrintTemplate) => {
    if (!confirm(`ã€Œ${template.name}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚`)) {
      return;
    }

    setSaving(true);
    try {
      const response = await fetch(`${apiBaseUrl}/print-templates/${template.id}`, {
        method: 'DELETE',
        credentials: 'include',
      });

      if (!response.ok) throw new Error('å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ');

      notifications.show({
        title: 'å‰Šé™¤å®Œäº†',
        message: 'ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’å‰Šé™¤ã—ã¾ã—ãŸ',
        color: 'blue',
      });

      if (selectedTemplate?.id === template.id) {
        setSelectedTemplate(null);
      }
      fetchTemplates();
    } catch (err) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: err instanceof Error ? err.message : 'å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ',
        color: 'red',
      });
    } finally {
      setSaving(false);
    }
  };

  const handleOpenPrint = (template: PrintTemplate) => {
    setPrintTarget(template);
    setPrintUseSampleData(showSampleData);
    openPrintModal();
  };

  const handlePrint = () => {
    if (!printTarget) return;

    const html = buildPrintHtml({
      template: printTarget,
      showSampleData: printUseSampleData,
      sampleData: SAMPLE_DATA[printTarget.category],
    });

    hasRequestedPrintRef.current = false;
    setPrintHtml(html);
  };

  // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ä½ç½®ã‚’æ›´æ–°
  const updateFieldPosition = (fieldName: string, updates: Partial<Position>) => {
    if (!selectedTemplate) return;
    
    const newPositions = {
      ...selectedTemplate.positions,
      [fieldName]: {
        ...selectedTemplate.positions[fieldName],
        ...updates,
      },
    };
    
    setSelectedTemplate({
      ...selectedTemplate,
      positions: newPositions,
    });
    setHasChanges(true);
  };

  // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’è¿½åŠ 
  const addField = () => {
    if (!selectedTemplate) return;
    const fieldName = prompt('ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆè‹±æ•°å­—ï¼‰:');
    if (!fieldName || !fieldName.match(/^[a-zA-Z][a-zA-Z0-9]*$/)) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: 'ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã¯è‹±å­—ã§å§‹ã¾ã‚‹è‹±æ•°å­—ã§å…¥åŠ›ã—ã¦ãã ã•ã„',
        color: 'red',
      });
      return;
    }

    if (selectedTemplate.positions[fieldName]) {
      notifications.show({
        title: 'ã‚¨ãƒ©ãƒ¼',
        message: 'ã“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™',
        color: 'red',
      });
      return;
    }

    const newPositions = {
      ...selectedTemplate.positions,
      [fieldName]: { x: 50, y: 50, fontSize: 12, align: 'left' as const },
    };

    setSelectedTemplate({
      ...selectedTemplate,
      positions: newPositions,
    });
    setHasChanges(true);
  };

  // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å‰Šé™¤
  const removeField = (fieldName: string) => {
    if (!selectedTemplate) return;
    if (!confirm(`ã€Œ${FIELD_LABELS[fieldName] || fieldName}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) return;

    const newPositions = { ...selectedTemplate.positions };
    delete newPositions[fieldName];

    setSelectedTemplate({
      ...selectedTemplate,
      positions: newPositions,
    });
    setHasChanges(true);
  };

  return (
    <Stack gap="md">
      <Group justify="space-between">
        <Group>
          <Select
            placeholder="ã‚«ãƒ†ã‚´ãƒªã§ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼"
            data={categories}
            value={selectedCategory}
            onChange={setSelectedCategory}
            clearable
            w={200}
          />
          <Select
            placeholder="ãƒ†ãƒŠãƒ³ãƒˆã§ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼"
            data={tenants}
            value={selectedTenantFilter}
            onChange={setSelectedTenantFilter}
            clearable
            w={200}
          />
          <Badge size="lg" color="blue">
            {templates.length}ä»¶
          </Badge>
        </Group>
        <Button leftSection={<IconPlus size={16} />} onClick={openCreateModal}>
          æ–°è¦ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
        </Button>
      </Group>

      <Grid>
        {/* ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä¸€è¦§ï¼ˆå·¦å´ï¼‰ */}
        <Grid.Col span={{ base: 12, md: 4 }}>
          <Paper p="md" shadow="sm" style={{ height: 'calc(100vh - 250px)', overflow: 'auto' }}>
            <LoadingOverlay visible={loading} />
            <Stack gap="xs">
              {templates.map((template) => (
                <Card
                  key={template.id}
                  p="sm"
                  withBorder
                  style={{
                    cursor: 'pointer',
                    borderColor: selectedTemplate?.id === template.id ? 'var(--mantine-color-blue-5)' : undefined,
                    backgroundColor: selectedTemplate?.id === template.id ? 'var(--mantine-color-blue-0)' : undefined,
                  }}
                  onClick={() => handleSelectTemplate(template)}
                >
                  <Group justify="space-between" wrap="nowrap">
                    <Stack gap={4}>
                      <Group gap="xs">
                        <Text fw={500} size="sm" lineClamp={1}>
                          {template.name}
                        </Text>
                        {template.isDefault && (
                          <Badge size="xs" color="green">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ</Badge>
                        )}
                        {!template.tenantId && (
                          <Badge size="xs" color="gray" variant="outline">å…±é€š</Badge>
                        )}
                      </Group>
                      <Group gap={4}>
                        <Badge size="xs" variant="light">
                          {CATEGORY_LABELS[template.category] || template.category}
                        </Badge>
                        {template.tenantId && (
                          <Badge size="xs" color="blue" variant="dot">
                            {tenants.find(t => t.value === template.tenantId)?.label || 'ãƒ†ãƒŠãƒ³ãƒˆå°‚ç”¨'}
                          </Badge>
                        )}
                      </Group>
                    </Stack>
                    <Group gap={4}>
                      <Tooltip label="å°åˆ·">
                        <ActionIcon
                          variant="subtle"
                          size="sm"
                          onClick={(e) => {
                            e.stopPropagation();
                            handleOpenPrint(template);
                          }}
                        >
                          <IconPrinter size={14} />
                        </ActionIcon>
                      </Tooltip>
                      <Tooltip label="è¤‡è£½">
                        <ActionIcon
                          variant="subtle"
                          size="sm"
                          onClick={(e) => {
                            e.stopPropagation();
                            handleDuplicateTemplate(template);
                          }}
                        >
                          <IconCopy size={14} />
                        </ActionIcon>
                      </Tooltip>
                      <Tooltip label="å‰Šé™¤">
                        <ActionIcon
                          variant="subtle"
                          color="red"
                          size="sm"
                          onClick={(e) => {
                            e.stopPropagation();
                            handleDeleteTemplate(template);
                          }}
                        >
                          <IconTrash size={14} />
                        </ActionIcon>
                      </Tooltip>
                    </Group>
                  </Group>
                </Card>
              ))}

              {templates.length === 0 && !loading && (
                <Text c="dimmed" ta="center" py="xl">
                  ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãŒã‚ã‚Šã¾ã›ã‚“
                </Text>
              )}
            </Stack>
          </Paper>
        </Grid.Col>

        {/* ã‚¨ãƒ‡ã‚£ã‚¿ï¼ˆå³å´ï¼‰ */}
        <Grid.Col span={{ base: 12, md: 8 }}>
          {selectedTemplate ? (
            <Paper p="md" shadow="sm" style={{ height: 'calc(100vh - 250px)', overflow: 'auto' }}>
              <Stack gap="md">
                <Group justify="space-between">
                  <Text fw={600} size="lg">{selectedTemplate.name}</Text>
                  <Group>
                    {hasChanges && (
                      <Badge color="orange">æœªä¿å­˜ã®å¤‰æ›´</Badge>
                    )}
                    <Button
                      leftSection={<IconCheck size={16} />}
                      onClick={handleSaveTemplate}
                      loading={saving}
                      disabled={!hasChanges}
                    >
                      ä¿å­˜
                    </Button>
                  </Group>
                </Group>

                <Tabs defaultValue="settings">
                  <Tabs.List grow>
                    <Tabs.Tab value="settings" leftSection={<IconSettings size={14} />}>
                      åŸºæœ¬è¨­å®š
                    </Tabs.Tab>
                    <Tabs.Tab value="fields" leftSection={<IconGripVertical size={14} />}>
                      ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
                    </Tabs.Tab>
                    <Tabs.Tab value="preview" leftSection={<IconEye size={14} />}>
                      ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
                    </Tabs.Tab>
                  </Tabs.List>

                  <Tabs.Panel value="settings" pt="md">
                    <Stack gap="md">
                      <TextInput
                        label="ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå"
                        value={selectedTemplate.name}
                        onChange={(e) => {
                          setSelectedTemplate({ ...selectedTemplate, name: e.target.value });
                          setHasChanges(true);
                        }}
                      />

                      <TextInput
                        label="èª¬æ˜"
                        value={selectedTemplate.description || ''}
                        onChange={(e) => {
                          setSelectedTemplate({ ...selectedTemplate, description: e.target.value || null });
                          setHasChanges(true);
                        }}
                      />

                      {/* ãƒ†ãƒŠãƒ³ãƒˆæƒ…å ±è¡¨ç¤ºï¼ˆèª­ã¿å–ã‚Šå°‚ç”¨ï¼‰ */}
                      <Card withBorder p="sm" bg="gray.0">
                        <Group>
                          <Text size="sm" fw={500}>é©ç”¨ç¯„å›²:</Text>
                          {selectedTemplate.tenantId ? (
                            <Badge color="blue">
                              {tenants.find(t => t.value === selectedTemplate.tenantId)?.label || 'ãƒ†ãƒŠãƒ³ãƒˆå°‚ç”¨'}
                            </Badge>
                          ) : (
                            <Badge color="gray" variant="outline">å…¨ãƒ†ãƒŠãƒ³ãƒˆå…±é€šï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«ï¼‰</Badge>
                          )}
                        </Group>
                      </Card>

                      <Group grow>
                        <NumberInput
                          label="ç”¨ç´™å¹… (mm)"
                          value={selectedTemplate.paperWidth}
                          onChange={(val) => {
                            setSelectedTemplate({ ...selectedTemplate, paperWidth: Number(val) || 210 });
                            setHasChanges(true);
                          }}
                          min={50}
                          max={500}
                        />
                        <NumberInput
                          label="ç”¨ç´™é«˜ã• (mm)"
                          value={selectedTemplate.paperHeight}
                          onChange={(val) => {
                            setSelectedTemplate({ ...selectedTemplate, paperHeight: Number(val) || 297 });
                            setHasChanges(true);
                          }}
                          min={50}
                          max={500}
                        />
                      </Group>

                      <Select
                        label="ç”¨ç´™ãƒ—ãƒªã‚»ãƒƒãƒˆ"
                        data={PAPER_PRESETS.map(p => ({ 
                          value: p.label, 
                          label: p.isCustom ? 'ğŸ“ ã‚«ã‚¹ã‚¿ãƒ ã‚µã‚¤ã‚º' : `${p.label} (${p.width}Ã—${p.height}mm)` 
                        }))}
                        placeholder="ãƒ—ãƒªã‚»ãƒƒãƒˆã‹ã‚‰é¸æŠ"
                        clearable
                        onChange={(val) => {
                          const preset = PAPER_PRESETS.find(p => p.label === val);
                          if (preset && !preset.isCustom) {
                            setSelectedTemplate({
                              ...selectedTemplate,
                              paperWidth: preset.width,
                              paperHeight: preset.height,
                            });
                            setHasChanges(true);
                          }
                          // ã‚«ã‚¹ã‚¿ãƒ ã®å ´åˆã¯ä½•ã‚‚ã—ãªã„ï¼ˆæ‰‹å‹•ã§å¹…ãƒ»é«˜ã•ã‚’å…¥åŠ›ï¼‰
                        }}
                      />

                      <TextInput
                        label="èƒŒæ™¯ç”»åƒURL"
                        placeholder="https://... ã¾ãŸã¯ä¸‹ã®ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠã§ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰"
                        value={selectedTemplate.backgroundUrl || ''}
                        onChange={(e) => {
                          setSelectedTemplate({ ...selectedTemplate, backgroundUrl: e.target.value || null });
                          setHasChanges(true);
                        }}
                        leftSection={<IconPhoto size={16} />}
                        rightSection={
                          selectedTemplate.backgroundUrl ? (
                            <ActionIcon 
                              variant="subtle" 
                              color="gray" 
                              size="sm"
                              onClick={() => {
                                setSelectedTemplate({ ...selectedTemplate, backgroundUrl: null });
                                setHasChanges(true);
                              }}
                            >
                              <IconX size={14} />
                            </ActionIcon>
                          ) : null
                        }
                      />

                      <FileInput
                        label="èƒŒæ™¯ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰"
                        placeholder={uploadingBackground ? 'èª­ã¿è¾¼ã¿ä¸­...' : 'ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ...'}
                        accept="image/png,image/jpeg,image/webp"
                        leftSection={<IconUpload size={16} />}
                        disabled={uploadingBackground}
                        onChange={async (file) => {
                          if (!file) return;
                          
                          // ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯ï¼ˆ2MBä¸Šé™ï¼‰
                          if (file.size > 2 * 1024 * 1024) {
                            notifications.show({
                              title: 'ã‚¨ãƒ©ãƒ¼',
                              message: 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã¯2MBä»¥ä¸‹ã«ã—ã¦ãã ã•ã„',
                              color: 'red',
                            });
                            return;
                          }

                          setUploadingBackground(true);
                          try {
                            // Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ï¼‰
                            const reader = new FileReader();
                            reader.onloadend = () => {
                              const base64 = reader.result as string;
                              setSelectedTemplate({ 
                                ...selectedTemplate, 
                                backgroundUrl: base64 
                              });
                              setHasChanges(true);
                              notifications.show({
                                title: 'ç”»åƒã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ',
                                message: 'ä¿å­˜ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦å¤‰æ›´ã‚’åæ˜ ã—ã¦ãã ã•ã„',
                                color: 'blue',
                              });
                            };
                            reader.readAsDataURL(file);
                          } catch {
                            notifications.show({
                              title: 'ã‚¨ãƒ©ãƒ¼',
                              message: 'ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ',
                              color: 'red',
                            });
                          } finally {
                            setUploadingBackground(false);
                          }
                        }}
                        description="PNG/JPEG/WebPå½¢å¼ã€æœ€å¤§2MB"
                      />

                      {selectedTemplate.backgroundUrl && (
                        <Card withBorder p="sm">
                          <Text size="xs" c="dimmed" mb="xs">èƒŒæ™¯ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</Text>
                          <div style={{ 
                            width: '100%', 
                            height: 100, 
                            backgroundImage: `url(${selectedTemplate.backgroundUrl})`,
                            backgroundSize: 'contain',
                            backgroundRepeat: 'no-repeat',
                            backgroundPosition: 'center',
                            borderRadius: 4,
                            border: '1px solid #eee',
                          }} />
                        </Card>
                      )}

                      <Stack gap={4}>
                        <Text size="sm" fw={500}>èƒŒæ™¯é€æ˜åº¦: {selectedTemplate.backgroundOpacity}%</Text>
                        <Slider
                          value={selectedTemplate.backgroundOpacity}
                          onChange={(val) => {
                            setSelectedTemplate({ ...selectedTemplate, backgroundOpacity: val });
                            setHasChanges(true);
                          }}
                          min={0}
                          max={100}
                          marks={[
                            { value: 0, label: '0%' },
                            { value: 50, label: '50%' },
                            { value: 100, label: '100%' },
                          ]}
                        />
                      </Stack>

                      <Switch
                        label="ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã«è¨­å®š"
                        checked={selectedTemplate.isDefault}
                        onChange={(e) => {
                          setSelectedTemplate({ ...selectedTemplate, isDefault: e.currentTarget.checked });
                          setHasChanges(true);
                        }}
                      />
                    </Stack>
                  </Tabs.Panel>

                  <Tabs.Panel value="fields" pt="md">
                    <Stack gap="md">
                      <Group justify="space-between">
                        <Text fw={500}>ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ä¸€è¦§</Text>
                        <Button
                          size="xs"
                          variant="light"
                          leftSection={<IconPlus size={14} />}
                          onClick={addField}
                        >
                          ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¿½åŠ 
                        </Button>
                      </Group>

                      <ScrollArea h={400}>
                        <Stack gap="sm">
                          {Object.entries(selectedTemplate.positions).map(([fieldName, pos]) => (
                            <Card key={fieldName} p="sm" withBorder>
                              <Group justify="space-between" mb="xs">
                                <Text fw={500} size="sm">
                                  {FIELD_LABELS[fieldName] || fieldName}
                                </Text>
                                <ActionIcon
                                  variant="subtle"
                                  color="red"
                                  size="sm"
                                  onClick={() => removeField(fieldName)}
                                >
                                  <IconTrash size={14} />
                                </ActionIcon>
                              </Group>
                              <Grid gutter="xs">
                                <Grid.Col span={3}>
                                  <NumberInput
                                    size="xs"
                                    label="X (mm)"
                                    value={pos.x}
                                    onChange={(val) => updateFieldPosition(fieldName, { x: Number(val) || 0 })}
                                    min={0}
                                    max={selectedTemplate.paperWidth}
                                  />
                                </Grid.Col>
                                <Grid.Col span={3}>
                                  <NumberInput
                                    size="xs"
                                    label="Y (mm)"
                                    value={pos.y}
                                    onChange={(val) => updateFieldPosition(fieldName, { y: Number(val) || 0 })}
                                    min={0}
                                    max={selectedTemplate.paperHeight}
                                  />
                                </Grid.Col>
                                <Grid.Col span={3}>
                                  <NumberInput
                                    size="xs"
                                    label="å¹… (mm)"
                                    value={pos.width || 50}
                                    onChange={(val) => updateFieldPosition(fieldName, { width: Number(val) || 50 })}
                                    min={10}
                                    max={selectedTemplate.paperWidth}
                                  />
                                </Grid.Col>
                                <Grid.Col span={3}>
                                  <NumberInput
                                    size="xs"
                                    label="é«˜ã• (mm)"
                                    value={pos.height || 15}
                                    onChange={(val) => updateFieldPosition(fieldName, { height: Number(val) || 15 })}
                                    min={5}
                                    max={selectedTemplate.paperHeight}
                                  />
                                </Grid.Col>
                                <Grid.Col span={3}>
                                  <NumberInput
                                    size="xs"
                                    label="æ–‡å­—ã‚µã‚¤ã‚º"
                                    value={pos.fontSize || 12}
                                    onChange={(val) => updateFieldPosition(fieldName, { fontSize: Number(val) || 12 })}
                                    min={6}
                                    max={72}
                                  />
                                </Grid.Col>
                                <Grid.Col span={3}>
                                  <Select
                                    size="xs"
                                    label="æƒãˆ"
                                    value={pos.align || 'left'}
                                    onChange={(val) => updateFieldPosition(fieldName, { align: (val as 'left' | 'center' | 'right') || 'left' })}
                                    data={[
                                      { value: 'left', label: 'å·¦' },
                                      { value: 'center', label: 'ä¸­å¤®' },
                                      { value: 'right', label: 'å³' },
                                    ]}
                                  />
                                </Grid.Col>
                              </Grid>
                            </Card>
                          ))}
                        </Stack>
                      </ScrollArea>
                    </Stack>
                  </Tabs.Panel>

                  <Tabs.Panel value="preview" pt="md">
                    <Stack gap="md">
                      <Group justify="flex-end">
                        <Switch
                          label="ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ã§è¡¨ç¤º"
                          checked={showSampleData}
                          onChange={(e) => setShowSampleData(e.currentTarget.checked)}
                        />
                      </Group>
                      <TemplatePreview 
                        template={selectedTemplate}
                        onUpdatePosition={(fieldName, x, y) => {
                          updateFieldPosition(fieldName, { x, y });
                        }}
                        onUpdateSize={(fieldName, width, height) => {
                          updateFieldPosition(fieldName, { width, height });
                        }}
                        sampleData={SAMPLE_DATA[selectedTemplate.category]}
                        showSampleData={showSampleData}
                      />
                    </Stack>
                  </Tabs.Panel>
                </Tabs>
              </Stack>
            </Paper>
          ) : (
            <Paper p="xl" shadow="sm" style={{ height: 'calc(100vh - 250px)' }}>
              <Stack align="center" justify="center" h="100%">
                <IconSettings size={48} color="gray" />
                <Text c="dimmed">å·¦ã®ãƒªã‚¹ãƒˆã‹ã‚‰ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„</Text>
              </Stack>
            </Paper>
          )}
        </Grid.Col>
      </Grid>

      {/* å°åˆ·ãƒ¢ãƒ¼ãƒ€ãƒ« */}
      <Modal
        opened={printModalOpened}
        onClose={closePrintModal}
        title="å°åˆ·"
        size="xl"
      >
        {printTarget ? (
          <Stack gap="md">
            <Group justify="space-between" wrap="nowrap">
              <Stack gap={2}>
                <Text fw={600} size="sm" lineClamp={2}>
                  {printTarget.name}
                </Text>
                <Text size="xs" c="dimmed">
                  ç”¨ç´™ã‚µã‚¤ã‚º: {printTarget.paperWidth}mm Ã— {printTarget.paperHeight}mm
                </Text>
              </Stack>
              <Badge size="sm" variant="light">
                {CATEGORY_LABELS[printTarget.category] || printTarget.category}
              </Badge>
            </Group>

            <Switch
              label="ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ã§å°åˆ·"
              checked={printUseSampleData}
              onChange={(e) => setPrintUseSampleData(e.currentTarget.checked)}
            />

            <TemplatePreview
              template={printTarget}
              sampleData={SAMPLE_DATA[printTarget.category]}
              showSampleData={printUseSampleData}
            />

            <Group justify="flex-end">
              <Button variant="default" onClick={closePrintModal}>
                ã‚­ãƒ£ãƒ³ã‚»ãƒ«
              </Button>
              <Button
                leftSection={<IconPrinter size={16} />}
                onClick={() => {
                  handlePrint();
                  closePrintModal();
                }}
              >
                å°åˆ·ã™ã‚‹
              </Button>
            </Group>
          </Stack>
        ) : (
          <Text c="dimmed">ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“</Text>
        )}
      </Modal>

      {/* å°åˆ·ç”¨ï¼ˆéè¡¨ç¤ºï¼‰iframe: srcDoc çµŒç”±ã§OS/ãƒ–ãƒ©ã‚¦ã‚¶ã®å°åˆ·ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‹ã */}
      <iframe
        ref={printFrameRef}
        title="print-frame"
        style={{ display: 'none' }}
        srcDoc={printHtml ?? ''}
        onLoad={() => {
          if (!printHtml) return;
          if (hasRequestedPrintRef.current) return;

          const printWindow = printFrameRef.current?.contentWindow;
          if (!printWindow) {
            notifications.show({
              title: 'å°åˆ·ã§ãã¾ã›ã‚“',
              message: 'å°åˆ·ç”¨ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’åˆæœŸåŒ–ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
              color: 'red',
            });
            setPrintHtml(null);
            return;
          }

          hasRequestedPrintRef.current = true;

          const cleanup = () => {
            setPrintHtml(null);
            hasRequestedPrintRef.current = false;
          };

          try {
            printWindow.addEventListener('afterprint', cleanup, { once: true });
          } catch {
            // ä¸€éƒ¨ãƒ–ãƒ©ã‚¦ã‚¶ã§ addEventListener ãŒåˆ¶é™ã•ã‚Œã‚‹å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
          }

          // afterprint ãŒæ¥ãªã„ç’°å¢ƒå‘ã‘ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
          window.setTimeout(cleanup, 5_000);

          // å°åˆ·å®Ÿè¡Œï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œèµ·ç‚¹ï¼‰
          printWindow.focus();
          printWindow.print();
        }}
      />

      {/* æ–°è¦ä½œæˆãƒ¢ãƒ¼ãƒ€ãƒ« */}
      <Modal
        opened={createModalOpened}
        onClose={closeCreateModal}
        title="æ–°è¦ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä½œæˆ"
        size="md"
      >
        <Stack gap="md">
          <TextInput
            label="ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå"
            placeholder="ä¾‹: è¡€çµ±æ›¸ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ"
            value={newTemplateName}
            onChange={(e) => setNewTemplateName(e.target.value)}
            required
          />

          <Select
            label="ã‚«ãƒ†ã‚´ãƒª"
            data={categories}
            value={newTemplateCategory}
            onChange={setNewTemplateCategory}
            required
          />

          <Select
            label="é©ç”¨ç¯„å›²"
            description="ç‰¹å®šã®ãƒ†ãƒŠãƒ³ãƒˆå°‚ç”¨ã«ã™ã‚‹ã‹ã€å…¨ãƒ†ãƒŠãƒ³ãƒˆå…±é€šã«ã™ã‚‹ã‹é¸æŠ"
            data={tenants}
            value={newTemplateTenant}
            onChange={setNewTemplateTenant}
            placeholder="å…¨ãƒ†ãƒŠãƒ³ãƒˆå…±é€šï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«ï¼‰"
            clearable
          />

          <Select
            label="ç”¨ç´™ã‚µã‚¤ã‚º"
            data={PAPER_PRESETS.map(p => ({ 
              value: p.label, 
              label: p.isCustom ? 'ğŸ“ ã‚«ã‚¹ã‚¿ãƒ ã‚µã‚¤ã‚º' : `${p.label} (${p.width}Ã—${p.height}mm)` 
            }))}
            value={selectedPaperPreset}
            onChange={setSelectedPaperPreset}
            placeholder="A4 ç¸¦"
          />

          {selectedPaperPreset === 'ã‚«ã‚¹ã‚¿ãƒ ' && (
            <Group grow>
              <NumberInput
                label="å¹… (mm)"
                value={customPaperWidth}
                onChange={(val) => setCustomPaperWidth(Number(val) || 210)}
                min={50}
                max={1000}
                placeholder="ä¾‹: 210"
              />
              <NumberInput
                label="é«˜ã• (mm)"
                value={customPaperHeight}
                onChange={(val) => setCustomPaperHeight(Number(val) || 297)}
                min={50}
                max={1000}
                placeholder="ä¾‹: 297"
              />
            </Group>
          )}

          <Group justify="flex-end" mt="md">
            <Button variant="default" onClick={closeCreateModal}>
              ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            </Button>
            <Button onClick={handleCreateTemplate} loading={saving}>
              ä½œæˆ
            </Button>
          </Group>
        </Stack>
      </Modal>
    </Stack>
  );
}

// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆï¼ˆãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—å¯¾å¿œï¼‰
interface TemplatePreviewProps {
  template: PrintTemplate;
  onUpdatePosition?: (fieldName: string, x: number, y: number) => void;
  onUpdateSize?: (fieldName: string, width: number, height: number) => void;
  sampleData?: Record<string, string>;
  showSampleData?: boolean;
}

// ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ«ã®æ–¹å‘
type ResizeDirection = 'e' | 'w' | 's' | 'n' | 'se' | 'sw' | 'ne' | 'nw';

function TemplatePreview({ template, onUpdatePosition, onUpdateSize, sampleData, showSampleData }: TemplatePreviewProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const paperRef = useRef<HTMLDivElement>(null);
  // å®Ÿå¯¸è¡¨ç¤ºï¼ˆ96dpiåŸºæº–ï¼‰ã‚’ãƒ™ãƒ¼ã‚¹ã«ã€userScaleã§ã‚ºãƒ¼ãƒ èª¿æ•´
  const scale = 1; // baseScaleã¯å¸¸ã«1.0ï¼ˆå®Ÿå¯¸ï¼‰
  const [userScale, setUserScale] = useState(1); // ãƒ¦ãƒ¼ã‚¶ãƒ¼æŒ‡å®šã®å€ç‡ï¼ˆ0.2ã€œ2.0ï¼‰
  const displayScale = scale * userScale; // è¡¨ç¤ºç”¨ã‚¹ã‚±ãƒ¼ãƒ«
  const [selectedField, setSelectedField] = useState<string | null>(null);
  const [dragging, setDragging] = useState<string | null>(null);
  const [resizing, setResizing] = useState<{ field: string; direction: ResizeDirection } | null>(null);
  // ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹æ™‚ã®ãƒã‚¦ã‚¹ä½ç½®ã¨è¦ç´ ã®åˆæœŸä½ç½®ã‚’ä¿æŒ
  const dragStartRef = useRef({ mouseX: 0, mouseY: 0, elementX: 0, elementY: 0 });
  // ãƒªã‚µã‚¤ã‚ºé–‹å§‹æ™‚ã®æƒ…å ±ã‚’ä¿æŒ
  const resizeStartRef = useRef({ mouseX: 0, mouseY: 0, width: 0, height: 0, x: 0, y: 0 });

  // mm â†’ px å¤‰æ›ï¼ˆ96dpiåŸºæº–ã€25.4mm = 1inchï¼‰
  const mmToPx = useCallback((mm: number) => (mm * 96) / 25.4 * displayScale, [displayScale]);
  
  // px â†’ mm å¤‰æ›ï¼ˆuseEffectå†…ã§ç›´æ¥è¨ˆç®—ã™ã‚‹ãŸã‚ã€ã“ã“ã§ã¯æœªä½¿ç”¨ï¼‰
  // const pxToMm = useCallback((px: number) => (px * 25.4) / 96 / displayScale, [displayScale]);

  // ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹
  const handleMouseDown = (e: React.MouseEvent, fieldName: string) => {
    if (!onUpdatePosition) return;
    e.preventDefault();
    e.stopPropagation();
    
    // ç¾åœ¨ã®è¦ç´ ä½ç½®ï¼ˆmmå˜ä½ï¼‰ã‚’å–å¾—
    const currentPos = template.positions[fieldName];
    if (!currentPos) return;
    
    // é‡è¦: refã‚’å…ˆã«è¨­å®šã—ã¦ã‹ã‚‰stateã‚’æ›´æ–°ã™ã‚‹
    // ï¼ˆuseEffectãŒãƒˆãƒªã‚¬ãƒ¼ã•ã‚Œã‚‹å‰ã«refã®å€¤ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚‹ï¼‰
    dragStartRef.current = {
      mouseX: e.clientX,
      mouseY: e.clientY,
      elementX: currentPos.x,
      elementY: currentPos.y,
    };
    
    console.log('ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹:', {
      field: fieldName,
      mouseX: e.clientX,
      mouseY: e.clientY,
      elementX: currentPos.x,
      elementY: currentPos.y,
    });
    
    setSelectedField(fieldName);
    setDragging(fieldName);
  };

  // ãƒªã‚µã‚¤ã‚ºé–‹å§‹
  const handleResizeStart = (e: React.MouseEvent, fieldName: string, direction: ResizeDirection) => {
    if (!onUpdateSize) return;
    e.preventDefault();
    e.stopPropagation();
    
    const currentPos = template.positions[fieldName];
    if (!currentPos) return;
    
    // é‡è¦: refã‚’å…ˆã«è¨­å®šã—ã¦ã‹ã‚‰stateã‚’æ›´æ–°ã™ã‚‹
    resizeStartRef.current = {
      mouseX: e.clientX,
      mouseY: e.clientY,
      width: currentPos.width || 50,
      height: currentPos.height || 15,
      x: currentPos.x,
      y: currentPos.y,
    };
    
    console.log('ãƒªã‚µã‚¤ã‚ºé–‹å§‹:', {
      field: fieldName,
      direction,
      ...resizeStartRef.current,
    });
    
    setSelectedField(fieldName);
    setResizing({ field: fieldName, direction });
  };

  // ãƒ‰ãƒ©ãƒƒã‚°ç”¨ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
  useEffect(() => {
    console.log('useEffect triggered, dragging:', dragging);
    if (!dragging) return;
    
    // useEffectå†…ã§ç›´æ¥pxâ†’mmå¤‰æ›ã‚’è¡Œã†ï¼ˆã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£å•é¡Œã‚’å›é¿ï¼‰
    const pxToMmDirect = (px: number) => (px * 25.4) / 96 / displayScale;
    
    console.log('Adding event listeners for drag, displayScale:', displayScale);
    
    const handleMove = (e: MouseEvent) => {
      if (!paperRef.current || !onUpdatePosition) return;
      
      // refã‹ã‚‰é–‹å§‹æ™‚ã®å€¤ã‚’å–å¾—
      const { mouseX, mouseY, elementX, elementY } = dragStartRef.current;
      
      console.log('handleMove called, ref values:', { mouseX, mouseY, elementX, elementY });
      
      // ãƒã‚¦ã‚¹ç§»å‹•é‡ã‚’ãƒ”ã‚¯ã‚»ãƒ«ã§è¨ˆç®—
      const deltaX = e.clientX - mouseX;
      const deltaY = e.clientY - mouseY;
      
      // ãƒ”ã‚¯ã‚»ãƒ«ç§»å‹•é‡ã‚’mmå˜ä½ã«å¤‰æ›ã—ã¦ã€é–‹å§‹ä½ç½®ã«åŠ ç®—
      const newX = elementX + pxToMmDirect(deltaX);
      const newY = elementY + pxToMmDirect(deltaY);
      
      // ç”¨ç´™ç¯„å›²å†…ã«åˆ¶é™
      const clampedX = Math.max(0, Math.min(newX, template.paperWidth - 20));
      const clampedY = Math.max(0, Math.min(newY, template.paperHeight - 10));
      
      console.log('ãƒ‰ãƒ©ãƒƒã‚°ä¸­:', {
        displayScale,
        currentMouse: { x: e.clientX, y: e.clientY },
        startMouse: { x: mouseX, y: mouseY },
        delta: { x: deltaX, y: deltaY },
        startElement: { x: elementX, y: elementY },
        newPos: { x: newX, y: newY },
        clamped: { x: clampedX, y: clampedY },
      });
      
      onUpdatePosition(dragging, Math.round(clampedX), Math.round(clampedY));
    };
    
    const handleUp = () => {
      console.log('handleUp called, stopping drag');
      setDragging(null);
    };
    
    document.addEventListener('mousemove', handleMove);
    document.addEventListener('mouseup', handleUp);
    
    return () => {
      console.log('Cleanup: removing event listeners');
      document.removeEventListener('mousemove', handleMove);
      document.removeEventListener('mouseup', handleUp);
    };
  }, [dragging, displayScale, template.paperWidth, template.paperHeight, onUpdatePosition]);

  // ãƒªã‚µã‚¤ã‚ºç”¨ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
  useEffect(() => {
    if (!resizing) return;
    
    // useEffectå†…ã§ç›´æ¥pxâ†’mmå¤‰æ›ã‚’è¡Œã†ï¼ˆã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£å•é¡Œã‚’å›é¿ï¼‰
    const pxToMmDirect = (px: number) => (px * 25.4) / 96 / displayScale;
    
    const handleMove = (e: MouseEvent) => {
      if (!onUpdateSize || !onUpdatePosition) return;
      
      const { mouseX, mouseY, width, height, x, y } = resizeStartRef.current;
      const deltaX = e.clientX - mouseX;
      const deltaY = e.clientY - mouseY;
      const deltaMmX = pxToMmDirect(deltaX);
      const deltaMmY = pxToMmDirect(deltaY);
      
      let newWidth = width;
      let newHeight = height;
      let newX = x;
      let newY = y;
      
      const { direction, field } = resizing;
      
      // æ–¹å‘ã«å¿œã˜ã¦ã‚µã‚¤ã‚ºã¨ä½ç½®ã‚’è¨ˆç®—
      if (direction.includes('e')) {
        newWidth = Math.max(10, width + deltaMmX);
      }
      if (direction.includes('w')) {
        newWidth = Math.max(10, width - deltaMmX);
        newX = x + deltaMmX;
      }
      if (direction.includes('s')) {
        newHeight = Math.max(5, height + deltaMmY);
      }
      if (direction.includes('n')) {
        newHeight = Math.max(5, height - deltaMmY);
        newY = y + deltaMmY;
      }
      
      // ç”¨ç´™ç¯„å›²å†…ã«åˆ¶é™
      newX = Math.max(0, Math.min(newX, template.paperWidth - 10));
      newY = Math.max(0, Math.min(newY, template.paperHeight - 5));
      newWidth = Math.min(newWidth, template.paperWidth - newX);
      newHeight = Math.min(newHeight, template.paperHeight - newY);
      
      // ä½ç½®ãŒå¤‰ã‚ã£ãŸå ´åˆã¯ä½ç½®ã‚‚æ›´æ–°
      if (direction.includes('w') || direction.includes('n')) {
        onUpdatePosition(field, Math.round(newX), Math.round(newY));
      }
      onUpdateSize(field, Math.round(newWidth), Math.round(newHeight));
    };
    
    const handleUp = () => {
      setResizing(null);
    };
    
    document.addEventListener('mousemove', handleMove);
    document.addEventListener('mouseup', handleUp);
    return () => {
      document.removeEventListener('mousemove', handleMove);
      document.removeEventListener('mouseup', handleUp);
    };
  }, [resizing, displayScale, template.paperWidth, template.paperHeight, onUpdateSize, onUpdatePosition]);

  // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®è¡¨ç¤ºå€¤ã‚’å–å¾—
  const getFieldDisplayValue = (fieldName: string): string => {
    if (showSampleData && sampleData && sampleData[fieldName]) {
      return sampleData[fieldName];
    }
    return FIELD_LABELS[fieldName] || fieldName;
  };

  const isEditable = !!onUpdatePosition;

  // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®ãƒãƒ¼ã‚¯
  const sliderMarks = [
    { value: 0.2, label: '20%' },
    { value: 0.5, label: '50%' },
    { value: 1, label: '100%' },
    { value: 1.5, label: '150%' },
    { value: 2, label: '200%' },
  ];

  return (
    <Stack gap="md">
      <Group justify="space-between" align="flex-start">
        <Stack gap="xs">
          <Text size="sm" c="dimmed">
            ç”¨ç´™ã‚µã‚¤ã‚º: {template.paperWidth}mm Ã— {template.paperHeight}mm
          </Text>
          {isEditable && (
            <Text size="sm" c="blue">
              ğŸ’¡ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ä½ç½®ã‚’èª¿æ•´ã§ãã¾ã™
            </Text>
          )}
        </Stack>
        <Stack gap="xs" style={{ minWidth: 200 }}>
          <Group justify="space-between">
            <Text size="sm" c="dimmed">è¡¨ç¤ºå€ç‡</Text>
            <Text size="sm" fw={500}>{Math.round(displayScale * 100)}%</Text>
          </Group>
          <Slider
            value={userScale}
            onChange={setUserScale}
            min={0.2}
            max={2}
            step={0.1}
            marks={sliderMarks}
            label={(value) => `${Math.round(value * 100)}%`}
            size="sm"
            styles={{
              markLabel: { fontSize: 10 },
            }}
          />
        </Stack>
      </Group>

      <div
        ref={containerRef}
        style={{
          padding: 20,
          backgroundColor: '#f5f5f5',
          borderRadius: 8,
          overflow: 'auto',
          maxHeight: 600,
          minHeight: 400,
          cursor: dragging ? 'grabbing' : 'default',
        }}
      >
        {/* ç”¨ç´™ã‚’ä¸­å¤®é…ç½®ã™ã‚‹ãŸã‚ã®ãƒ©ãƒƒãƒ‘ãƒ¼ï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ™‚ã¯å·¦ä¸ŠåŸºæº–ï¼‰ */}
        <div
          style={{
            display: 'inline-block',
            minWidth: '100%',
            minHeight: '100%',
            textAlign: 'center',
          }}
        >
          <div
            ref={paperRef}
            style={{
              display: 'inline-block',
              width: mmToPx(template.paperWidth),
              height: mmToPx(template.paperHeight),
              backgroundColor: 'white',
              boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
              position: 'relative',
              backgroundImage: template.backgroundUrl ? `url(${template.backgroundUrl})` : undefined,
              backgroundSize: 'cover',
              backgroundPosition: 'center',
              textAlign: 'left',
            }}
            onClick={() => setSelectedField(null)}
          >
          {/* èƒŒæ™¯ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼ˆé€æ˜åº¦èª¿æ•´ç”¨ï¼‰ */}
          {template.backgroundUrl && template.backgroundOpacity < 100 && (
            <div
              style={{
                position: 'absolute',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                backgroundColor: `rgba(255,255,255,${(100 - template.backgroundOpacity) / 100})`,
                pointerEvents: 'none',
              }}
            />
          )}

          {/* ã‚°ãƒªãƒƒãƒ‰ãƒ©ã‚¤ãƒ³ï¼ˆç·¨é›†ãƒ¢ãƒ¼ãƒ‰æ™‚ï¼‰ */}
          {isEditable && (
            <svg
              style={{
                position: 'absolute',
                top: 0,
                left: 0,
                width: '100%',
                height: '100%',
                pointerEvents: 'none',
                opacity: 0.3,
              }}
            >
              {/* 10mmé–“éš”ã®ã‚°ãƒªãƒƒãƒ‰ */}
              {Array.from({ length: Math.floor(template.paperWidth / 10) + 1 }, (_, i) => (
                <line
                  key={`v-${i}`}
                  x1={mmToPx(i * 10)}
                  y1={0}
                  x2={mmToPx(i * 10)}
                  y2={mmToPx(template.paperHeight)}
                  stroke="#ccc"
                  strokeWidth={i % 5 === 0 ? 1 : 0.5}
                />
              ))}
              {Array.from({ length: Math.floor(template.paperHeight / 10) + 1 }, (_, i) => (
                <line
                  key={`h-${i}`}
                  x1={0}
                  y1={mmToPx(i * 10)}
                  x2={mmToPx(template.paperWidth)}
                  y2={mmToPx(i * 10)}
                  stroke="#ccc"
                  strokeWidth={i % 5 === 0 ? 1 : 0.5}
                />
              ))}
            </svg>
          )}

          {/* ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¡¨ç¤º */}
          {Object.entries(template.positions).map(([fieldName, pos]) => {
            const isSelected = selectedField === fieldName;
            const isDraggingThis = dragging === fieldName;
            const isResizingThis = resizing?.field === fieldName;
            const hasSize = pos.width && pos.height;
            const canResize = isEditable && onUpdateSize;
            
            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚µã‚¤ã‚ºï¼ˆè¨­å®šãŒãªã„å ´åˆï¼‰
            const fieldWidth = pos.width || 50;
            const fieldHeight = pos.height || 15;
            
            return (
              <div
                key={fieldName}
                onMouseDown={(e) => handleMouseDown(e, fieldName)}
                onClick={(e) => {
                  e.stopPropagation();
                  setSelectedField(fieldName);
                }}
                style={{
                  position: 'absolute',
                  left: mmToPx(pos.x),
                  top: mmToPx(pos.y),
                  width: hasSize ? mmToPx(fieldWidth) : 'auto',
                  height: hasSize ? mmToPx(fieldHeight) : 'auto',
                  minWidth: hasSize ? undefined : mmToPx(20),
                  fontSize: (pos.fontSize || 12) * displayScale,
                  textAlign: pos.align || 'left',
                  color: showSampleData ? (pos.color || '#333') : '#333',
                  fontWeight: pos.fontWeight || 'normal',
                  whiteSpace: hasSize ? 'normal' : 'nowrap',
                  overflow: hasSize ? 'hidden' : 'visible',
                  border: isSelected ? '2px solid #228be6' : '1px dashed #aaa',
                  padding: '2px 4px',
                  backgroundColor: showSampleData 
                    ? 'transparent' 
                    : isSelected 
                      ? 'rgba(34, 139, 230, 0.15)' 
                      : 'rgba(255, 255, 200, 0.8)',
                  cursor: isEditable ? (isDraggingThis || isResizingThis ? 'grabbing' : 'grab') : 'default',
                  userSelect: 'none',
                  boxShadow: isSelected ? '0 0 0 2px rgba(34, 139, 230, 0.3)' : undefined,
                  zIndex: isSelected || isDraggingThis || isResizingThis ? 100 : 1,
                  transition: isDraggingThis || isResizingThis ? 'none' : 'box-shadow 0.2s',
                  boxSizing: 'border-box',
                }}
              >
                {getFieldDisplayValue(fieldName)}
                
                {/* åº§æ¨™ãƒ»ã‚µã‚¤ã‚ºæƒ…å ±ãƒ©ãƒ™ãƒ« */}
                {isEditable && isSelected && !showSampleData && (
                  <div
                    style={{
                      position: 'absolute',
                      top: -20,
                      left: 0,
                      fontSize: 10 * scale,
                      backgroundColor: '#228be6',
                      color: 'white',
                      padding: '1px 4px',
                      borderRadius: 2,
                      whiteSpace: 'nowrap',
                    }}
                  >
                    X:{pos.x} Y:{pos.y} {hasSize && `W:${fieldWidth} H:${fieldHeight}`}
                  </div>
                )}
                
                {/* ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ«ï¼ˆé¸æŠä¸­ã‹ã¤ç·¨é›†å¯èƒ½ãªå ´åˆã®ã¿è¡¨ç¤ºï¼‰ */}
                {canResize && isSelected && !showSampleData && (
                  <>
                    {/* å››éš…ã®ãƒãƒ³ãƒ‰ãƒ« */}
                    {(['nw', 'ne', 'sw', 'se'] as ResizeDirection[]).map((dir) => (
                      <div
                        key={dir}
                        onMouseDown={(e) => handleResizeStart(e, fieldName, dir)}
                        style={{
                          position: 'absolute',
                          width: 8,
                          height: 8,
                          backgroundColor: '#228be6',
                          border: '1px solid white',
                          borderRadius: 2,
                          cursor: `${dir}-resize`,
                          ...(dir === 'nw' && { top: -4, left: -4 }),
                          ...(dir === 'ne' && { top: -4, right: -4 }),
                          ...(dir === 'sw' && { bottom: -4, left: -4 }),
                          ...(dir === 'se' && { bottom: -4, right: -4 }),
                          zIndex: 101,
                        }}
                      />
                    ))}
                    {/* è¾ºã®ãƒãƒ³ãƒ‰ãƒ« */}
                    {(['n', 's', 'e', 'w'] as ResizeDirection[]).map((dir) => (
                      <div
                        key={dir}
                        onMouseDown={(e) => handleResizeStart(e, fieldName, dir)}
                        style={{
                          position: 'absolute',
                          backgroundColor: '#228be6',
                          border: '1px solid white',
                          borderRadius: 1,
                          ...(dir === 'n' && { 
                            top: -3, left: '50%', transform: 'translateX(-50%)',
                            width: 16, height: 6, cursor: 'n-resize' 
                          }),
                          ...(dir === 's' && { 
                            bottom: -3, left: '50%', transform: 'translateX(-50%)',
                            width: 16, height: 6, cursor: 's-resize' 
                          }),
                          ...(dir === 'e' && { 
                            right: -3, top: '50%', transform: 'translateY(-50%)',
                            width: 6, height: 16, cursor: 'e-resize' 
                          }),
                          ...(dir === 'w' && { 
                            left: -3, top: '50%', transform: 'translateY(-50%)',
                            width: 6, height: 16, cursor: 'w-resize' 
                          }),
                          zIndex: 101,
                        }}
                      />
                    ))}
                  </>
                )}
              </div>
            );
          })}
        </div>
        </div>
      </div>

      {!showSampleData && (
        <Alert color="blue" icon={<IconAlertCircle size={16} />}>
          {isEditable 
            ? 'ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ä½ç½®ã‚’èª¿æ•´ã€é¸æŠå¾Œã«å››éš…/è¾ºã®ãƒãƒ³ãƒ‰ãƒ«ã§ã‚µã‚¤ã‚ºã‚’èª¿æ•´ã§ãã¾ã™ã€‚'
            : 'ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã§ã¯å„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®é…ç½®ä½ç½®ã‚’ç¢ºèªã§ãã¾ã™ã€‚å®Ÿéš›ã®å°åˆ·æ™‚ã«ã¯ãƒ‡ãƒ¼ã‚¿ãŒå·®ã—è¾¼ã¾ã‚Œã¾ã™ã€‚'
          }
        </Alert>
      )}
    </Stack>
  );
}
````

## File: frontend/src/lib/store/theme-store.ts
````typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

export type ThemeType = 'default';

interface ThemeState {
  theme: ThemeType;
}

interface ThemeActions {
  setTheme: (theme: ThemeType) => void;
}

type ThemeStore = ThemeState & ThemeActions;

export const useThemeStore = create<ThemeStore>()(
  persist(
    (set) => ({
      theme: 'default', // Classic Default ã«çµ±ä¸€
      setTheme: (theme) => set({ theme }),
    }),
    {
      name: 'mycats-theme-storage',
    }
  )
);

export function useTheme() {
  const theme = useThemeStore((state) => state.theme);
  const setTheme = useThemeStore((state) => state.setTheme);

  return {
    theme,
    setTheme,
  };
}
````

## File: frontend/tsconfig.json
````json
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "noImplicitAny": true,
    "noImplicitThis": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./src/*"
      ]
    },
    "types": [
      "node"
    ]
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts"
  ],
  "exclude": [
    "node_modules",
    "**/*_old.tsx",
    "**/*page_old.tsx",
    "**/*page_new.tsx",
    "**/*_old.ts",
    ".next",
    "out",
    "dist"
  ]
}
````

## File: frontend/src/app/cats/page.tsx
````typescript
'use client';

import { Fragment, useMemo, useState, useEffect, useCallback } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import {
  Container,
  Text,
  TextInput,
  Card,
  Group,
  Stack,
  Box,
  Badge,
  Tabs,
  Select,
  Skeleton,
  Alert,
  Table,
} from '@mantine/core';
import { IconSearch, IconAlertCircle, IconCat, IconChevronDown, IconChevronRight } from '@tabler/icons-react';
import { useGetCats, useGetCatStatistics, useDeleteCat, type Cat, type GetCatsParams, type TabCounts } from '@/lib/api/hooks/use-cats';
import { useDebouncedValue, useDisclosure } from '@mantine/hooks';
import { usePageHeader } from '@/lib/contexts/page-header-context';
import { ActionButton, ActionIconButton } from '@/components/ActionButton';
import { CatEditModal } from '@/components/cats/cat-edit-modal';
import { ContextMenuProvider, OperationModalManager, useContextMenu } from '@/components/context-menu';
import { GenderBadge } from '@/components/GenderBadge';

export default function CatsPage() {
  const [searchTerm, setSearchTerm] = useState('');
  const router = useRouter();
  const searchParams = useSearchParams();
  const { setPageHeader } = usePageHeader();
  
  // URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰ã‚¿ãƒ–ã‚’å–å¾—ï¼ˆåˆæœŸå€¤ã¯'cats'ï¼‰
  const [activeTab, setActiveTab] = useState(() => {
    const tabParam = searchParams.get('tab');
    return tabParam || 'cats';
  });
  
  const [sortBy, setSortBy] = useState('name');
  const [debouncedSearch] = useDebouncedValue(searchTerm, 300);
  
  // å­çŒ«ã®å±•é–‹/æŠ˜ã‚ŠãŸãŸã¿çŠ¶æ…‹
  const [expandedMotherIds, setExpandedMotherIds] = useState<Set<string>>(new Set());
  
  // ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ«ã®çŠ¶æ…‹
  const [editModalOpened, { open: openEditModal, close: closeEditModal }] = useDisclosure(false);
  const [selectedCatForEdit, setSelectedCatForEdit] = useState<Cat | null>(null);

  // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼
  const {
    currentOperation,
    currentEntity,
    closeOperation,
    handleAction: handleContextAction,
  } = useContextMenu<Cat>({
    view: (cat) => {
      if (cat) {
        router.push(`/cats/${cat.id}`);
      }
    },
    edit: (cat) => {
      if (cat) {
        setSelectedCatForEdit(cat);
        openEditModal();
      }
    },
    duplicate: async (cat) => {
      if (cat) {
        // è¤‡è£½ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆå¾Œã§å®Ÿè£…ï¼‰
        console.log('Duplicate cat:', cat);
      }
    },
  });

  // ã‚«ãƒ©ãƒ å¹…ã®çŠ¶æ…‹ç®¡ç†ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰å¾©å…ƒï¼‰
  const [columnWidths, setColumnWidths] = useState<Record<string, number>>(() => {
    if (typeof window !== 'undefined') {
      const saved = localStorage.getItem('catsTableColumnWidths');
      if (saved) {
        return JSON.parse(saved);
      }
    }
    return {
      name: 15,
      gender: 10,
      breed: 15,
      age: 12,
      tags: 30,
      actions: 10,
    };
  });

  // ãƒªã‚µã‚¤ã‚ºä¸­ã®çŠ¶æ…‹
  const [resizingColumn, setResizingColumn] = useState<string | null>(null);
  const [startX, setStartX] = useState(0);
  const [startWidth, setStartWidth] = useState(0);

  // ã‚«ãƒ©ãƒ å¹…ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
  useEffect(() => {
    if (typeof window !== 'undefined') {
      localStorage.setItem('catsTableColumnWidths', JSON.stringify(columnWidths));
    }
  }, [columnWidths]);

  // ãƒªã‚µã‚¤ã‚ºé–‹å§‹
  const handleResizeStart = (column: string, e: React.MouseEvent) => {
    e.preventDefault();
    setResizingColumn(column);
    setStartX(e.clientX);
    setStartWidth(columnWidths[column]);
  };

  // ãƒªã‚µã‚¤ã‚ºä¸­
  const handleResizeMove = useCallback((e: MouseEvent) => {
    if (!resizingColumn) return;
    
    const diff = e.clientX - startX;
    const newWidth = Math.max(5, startWidth + (diff / window.innerWidth) * 100); // æœ€å°5%
    
    setColumnWidths(prev => ({
      ...prev,
      [resizingColumn]: newWidth,
    }));
  }, [resizingColumn, startX, startWidth]);

  // ãƒªã‚µã‚¤ã‚ºçµ‚äº†
  const handleResizeEnd = useCallback(() => {
    setResizingColumn(null);
  }, []);

  // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
  useEffect(() => {
    if (resizingColumn) {
      window.addEventListener('mousemove', handleResizeMove);
      window.addEventListener('mouseup', handleResizeEnd);
      
      return () => {
        window.removeEventListener('mousemove', handleResizeMove);
        window.removeEventListener('mouseup', handleResizeEnd);
      };
    }
  }, [resizingColumn, handleResizeMove, handleResizeEnd]);

  const queryParams = useMemo<GetCatsParams>(() => {
    const params: GetCatsParams = {
      limit: 1000, // å…¨ã‚¿ãƒ–ã§ååˆ†ãªãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
    };

    if (debouncedSearch) {
      params.search = debouncedSearch;
    }

    // ã‚¿ãƒ–ã«é–¢ã‚ã‚‰ãšå…¨çŒ«ã‚’å–å¾—ï¼ˆãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§å®Ÿè¡Œï¼‰
    // ã“ã‚Œã«ã‚ˆã‚Šã‚¿ãƒ–ã‚«ã‚¦ãƒ³ãƒˆãŒå‹•çš„ã«å¤‰ã‚ã‚‹ã“ã¨ã‚’é˜²ã

    return params;
  }, [debouncedSearch]); // activeTabã‚’ä¾å­˜é…åˆ—ã‹ã‚‰å‰Šé™¤

  // APIé€£æºã§ãƒ‡ãƒ¼ã‚¿å–å¾—
  const { data, isLoading, isError, error, isRefetching, refetch } = useGetCats(queryParams, {
    refetchOnMount: false,
    refetchOnWindowFocus: false,
    staleTime: 5 * 60 * 1000, // 5åˆ†é–“ã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨
  });

  // çµ±è¨ˆæƒ…å ±ã‚’å–å¾—ï¼ˆã‚¿ãƒ–ã‚«ã‚¦ãƒ³ãƒˆç”¨ï¼‰
  const { data: statisticsData, isLoading: isStatisticsLoading } = useGetCatStatistics({
    refetchOnMount: false,
    refetchOnWindowFocus: false,
    staleTime: 5 * 60 * 1000, // 5åˆ†é–“ã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨
  });

  // ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã®ã‚¿ãƒ–ã‚«ã‚¦ãƒ³ãƒˆã‚’ä½¿ç”¨ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä»˜ãï¼‰
  const tabCounts: TabCounts = statisticsData?.tabCounts ?? {
    total: 0,
    male: 0,
    female: 0,
    kitten: 0,
    raising: 0,
    grad: 0,
  };

  // URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰ã‚¿ãƒ–ã‚’å–å¾—ã—ã¦åæ˜ 
  useEffect(() => {
    const tabParam = searchParams.get('tab');
    if (tabParam && ['cats', 'male', 'female', 'kitten', 'raising', 'grad'].includes(tabParam)) {
      setActiveTab(tabParam);
    }
  }, [searchParams]);

  // æ–°è¦ç™»éŒ²ã‹ã‚‰ã®é·ç§»ã‚’æ¤œçŸ¥ã—ã¦è‡ªå‹•ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
  useEffect(() => {
    const refreshParam = searchParams.get('t');
    if (refreshParam) {
      refetch();
      // URLã‹ã‚‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å‰Šé™¤
      const newUrl = new URL(window.location.href);
      newUrl.searchParams.delete('t');
      window.history.replaceState({}, '', newUrl.toString());
    }
  }, [searchParams, refetch]);

  // ãƒšãƒ¼ã‚¸ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’è¨­å®šï¼ˆãƒã‚¦ãƒ³ãƒˆæ™‚ã®ã¿ï¼‰
  useEffect(() => {
    setPageHeader(
      'åœ¨èˆçŒ«ä¸€è¦§',
      <ActionButton
        action="create"
        onClick={() => router.push('/cats/new')}
      >
        ä½œæˆ
      </ActionButton>
    );

    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    return () => setPageHeader(null);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); // ç©ºã®ä¾å­˜é…åˆ—ã§ãƒã‚¦ãƒ³ãƒˆæ™‚ã®ã¿å®Ÿè¡Œ

  const apiCats = data?.data || [];

  // åœ¨èˆçŒ«ã®ã¿ã‚’å¯¾è±¡ã¨ã™ã‚‹ï¼ˆãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ç”¨ï¼‰
  const inHouseCats = apiCats.filter((cat: Cat) => cat.isInHouse);

  // å­çŒ«åˆ¤å®šé–¢æ•°ï¼ˆ6ãƒ¶æœˆæœªæº€ï¼‰ã‚’å…ˆã«å®šç¾©
  const isKittenFunc = (birthDate: string): boolean => {
    const birth = new Date(birthDate);
    const now = new Date();
    const ageInMonths = (now.getTime() - birth.getTime()) / (1000 * 60 * 60 * 24 * 30);
    return ageInMonths < 6;
  };

  // æˆçŒ«ã®ã¿ï¼ˆå­çŒ«ã‚’é™¤å¤–ï¼‰- ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ç”¨
  const adultCats = inHouseCats.filter((cat: Cat) => !isKittenFunc(cat.birthDate));

  // ã‚¿ãƒ–ã‚«ã‚¦ãƒ³ãƒˆã¯ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã®çµ±è¨ˆãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨
  // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ä¸­ã¯ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å€¤ï¼ˆ0ï¼‰ã‚’è¡¨ç¤º
  const totalCount = tabCounts.total;
  const maleCount = tabCounts.male;
  const femaleCount = tabCounts.female;
  const kittenCount = tabCounts.kitten;
  const raisingCount = tabCounts.raising;
  const gradCount = tabCounts.grad;

  // å¹´é½¢è¨ˆç®—é–¢æ•°
  const calculateAge = (birthDate: string) => {
    const today = new Date();
    const birth = new Date(birthDate);
    const ageInMonths = (today.getFullYear() - birth.getFullYear()) * 12 + (today.getMonth() - birth.getMonth());
    
    if (ageInMonths < 12) {
      return `${ageInMonths}ãƒ¶æœˆ`;
    } else {
      const years = Math.floor(ageInMonths / 12);
      const months = ageInMonths % 12;
      return months > 0 ? `${years}æ­³${months}ãƒ¶æœˆ` : `${years}æ­³`;
    }
  };

  const handleViewDetails = (catId: string) => {
    router.push(`/cats/${catId}`);
  };

  // å­çŒ«åˆ¤å®šé–¢æ•°ï¼ˆ6ãƒ¶æœˆæœªæº€ï¼‰
  const isKitten = useCallback((birthDate: string): boolean => {
    return isKittenFunc(birthDate);
  }, []);

  // å­çŒ«ã®å±•é–‹/æŠ˜ã‚ŠãŸãŸã¿ãƒˆã‚°ãƒ«
  const toggleExpanded = (motherId: string) => {
    setExpandedMotherIds(prev => {
      const newSet = new Set(prev);
      if (newSet.has(motherId)) {
        newSet.delete(motherId);
      } else {
        newSet.add(motherId);
      }
      return newSet;
    });
  };

  // çŒ«æƒ…å ±ã®æ›´æ–°
  const deleteCatMutation = useDeleteCat();

  // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰ã®æ“ä½œç¢ºèª
  const handleOperationConfirm = async (cat?: Cat) => {
    if (!currentOperation || !cat) return;

    switch (currentOperation) {
      case 'edit':
        // ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
        setSelectedCatForEdit(cat);
        closeOperation();
        openEditModal();
        break;

      case 'delete':
        // å‰Šé™¤å®Ÿè¡Œ
        await deleteCatMutation.mutateAsync(cat.id);
        await refetch();
        break;

      case 'duplicate':
        // è¤‡è£½ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆå¾Œã§å®Ÿè£…ï¼‰
        console.log('Duplicate:', cat);
        break;

      default:
        break;
    }
  };

  // ã‚¿ãƒ–åˆ¥ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã¨ã‚½ãƒ¼ãƒˆ
  const getFilteredCats = () => {
    let filtered: Cat[] = [];
    
    switch (activeTab) {
      case 'male':
        // åœ¨èˆçŒ«ç™»éŒ²ã•ã‚Œã¦ã„ã¦ã€æ€§åˆ¥ãŒMaleã®æˆçŒ«ã®ã¿ï¼ˆå­çŒ«é™¤å¤–ï¼‰
        filtered = adultCats.filter((cat: Cat) => cat.gender === 'MALE');
        break;
      case 'female':
        // åœ¨èˆçŒ«ç™»éŒ²ã•ã‚Œã¦ã„ã¦ã€æ€§åˆ¥ãŒFemaleã®çŒ«ï¼ˆæˆçŒ«+å­çŒ«ã€è¡¨ç¤ºæ™‚ã«å­çŒ«ã¯æ¯çŒ«ã«æ ¼ç´ï¼‰
        filtered = inHouseCats.filter((cat: Cat) => cat.gender === 'FEMALE');
        break;
      case 'kitten':
        // æ¯çŒ«åãŒå…¥åŠ›ã•ã‚Œã¦ã‚‹ç”Ÿå¾Œ3ãƒ¶æœˆ(90æ—¥)ä»¥å†…ã®çŒ«
        filtered = inHouseCats.filter((cat: Cat) => {
          if (!cat.birthDate || !cat.motherId) return false;
          const birthDate = new Date(cat.birthDate);
          const today = new Date();
          const ageInDays = Math.floor((today.getTime() - birthDate.getTime()) / (1000 * 60 * 60 * 24));
          return ageInDays <= 90; // 3ãƒ¶æœˆ(90æ—¥)ä»¥å†…
        });
        break;
      case 'raising':
        // é¤Šæˆä¸­ã‚¿ã‚°ãŒã¤ã„ã¦ã‚‹çŒ«
        filtered = inHouseCats.filter((cat: Cat) => {
          return cat.tags?.some((catTag) => catTag.tag.name === 'é¤Šæˆä¸­');
        });
        break;
      case 'grad':
        // å’æ¥­äºˆå®šã‚¿ã‚°ãŒã¤ã„ã¦ã‚‹çŒ«
        filtered = inHouseCats.filter((cat: Cat) => {
          return cat.tags?.some((catTag) => catTag.tag.name === 'å’æ¥­äºˆå®š');
        });
        break;
      case 'cats':
      default:
        // åœ¨èˆç™»éŒ²ã•ã‚Œã¦ã„ã‚‹å…¨ã¦ã®çŒ«ï¼ˆæˆçŒ«+å­çŒ«ã€è¡¨ç¤ºæ™‚ã«å­çŒ«ã¯æ¯çŒ«ã«æ ¼ç´ï¼‰
        filtered = inHouseCats;
        break;
    }
    
    // æ¤œç´¢ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é©ç”¨
    if (searchTerm) {
      filtered = filtered.filter((cat: Cat) =>
        cat.name.includes(searchTerm) || 
        (cat.coatColor?.name || '').includes(searchTerm) ||
        (cat.breed?.name || '').includes(searchTerm)
      );
    }
    
    // ã‚½ãƒ¼ãƒˆé©ç”¨
    filtered.sort((a: Cat, b: Cat) => {
      switch (sortBy) {
        case 'name':
          return a.name.localeCompare(b.name);
        case 'age':
          return new Date(b.birthDate).getTime() - new Date(a.birthDate).getTime();
        case 'breed':
          return (a.breed?.name || '').localeCompare(b.breed?.name || '');
        case 'gender':
          return a.gender.localeCompare(b.gender);
        case 'gender-name': {
          // æ€§åˆ¥é †ï¼ˆãƒ¡ã‚¹â†’ã‚ªã‚¹ï¼‰â†’åå‰é †
          const genderCompare = a.gender.localeCompare(b.gender);
          if (genderCompare !== 0) return genderCompare;
          return a.name.localeCompare(b.name);
        }
        case 'gender-age': {
          // æ€§åˆ¥é †ï¼ˆãƒ¡ã‚¹â†’ã‚ªã‚¹ï¼‰â†’å¹´é½¢é †ï¼ˆæ–°ã—ã„é †ï¼‰
          const genderCompare2 = a.gender.localeCompare(b.gender);
          if (genderCompare2 !== 0) return genderCompare2;
          return new Date(b.birthDate).getTime() - new Date(a.birthDate).getTime();
        }
        case 'breed-name': {
          // å“ç¨®é †â†’åå‰é †
          const breedCompare = (a.breed?.name || '').localeCompare(b.breed?.name || '');
          if (breedCompare !== 0) return breedCompare;
          return a.name.localeCompare(b.name);
        }
        default:
          return 0;
      }
    });
    
    return filtered;
  };

  const filteredCats = getFilteredCats();

  // æ¯çŒ«ã®å­çŒ«ãƒãƒƒãƒ—ã¨è¡¨ç¤ºç”¨çŒ«ãƒªã‚¹ãƒˆã‚’ä½œæˆ
  const { displayCats, kittensByMother } = useMemo(() => {
    // Maleã‚¿ãƒ–: æˆçŒ«ã®ã‚ªã‚¹ã®ã¿è¡¨ç¤ºï¼ˆå­çŒ«å®Œå…¨é™¤å¤–ï¼‰
    if (activeTab === 'male') {
      return { displayCats: filteredCats, kittensByMother: new Map<string, Cat[]>() };
    }
    
    // Kittenã‚¿ãƒ–: å­çŒ«å…¨é ­ã‚’å€‹åˆ¥è¡¨ç¤ºï¼ˆæ¯çŒ«ã«æ ¼ç´ã—ãªã„ï¼‰
    if (activeTab === 'kitten') {
      return { displayCats: filteredCats, kittensByMother: new Map<string, Cat[]>() };
    }
    
    // Gradã‚¿ãƒ–: å€‹åˆ¥è¡¨ç¤ºï¼ˆæ¯çŒ«ã«æ ¼ç´ã—ãªã„ï¼‰
    if (activeTab === 'grad') {
      return { displayCats: filteredCats, kittensByMother: new Map<string, Cat[]>() };
    }
    
    // Cats/Female/Raisingã‚¿ãƒ–: æ¯çŒ«ã«å­çŒ«ã‚’æ ¼ç´ã—ã¦è¡¨ç¤º
    const kittens = filteredCats.filter((cat: Cat) => isKitten(cat.birthDate) && cat.motherId);
    const kittensByMotherMap = new Map<string, Cat[]>();
    
    kittens.forEach((kitten: Cat) => {
      if (kitten.motherId) {
        if (!kittensByMotherMap.has(kitten.motherId)) {
          kittensByMotherMap.set(kitten.motherId, []);
        }
        const siblings = kittensByMotherMap.get(kitten.motherId);
        if (siblings) {
          siblings.push(kitten);
        }
      }
    });

    // å­çŒ«ã‚’é™¤å¤–ã—ãŸè¡¨ç¤ºç”¨ãƒªã‚¹ãƒˆï¼ˆæ¯çŒ«ã¯å«ã‚€ã€ã‚½ãƒ¼ãƒˆé †ã‚’ç¶­æŒï¼‰
    const kittenIds = new Set(kittens.map((k: Cat) => k.id));
    const displayCats = filteredCats.filter((cat: Cat) => !kittenIds.has(cat.id));

    return { displayCats, kittensByMother: kittensByMotherMap };
  }, [filteredCats, activeTab, isKitten]);

  return (
    <Box style={{ minHeight: '100vh', backgroundColor: 'var(--background-base)' }}>
      {/* ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ */}
      <Container size="lg">
        {/* ã‚¿ãƒ–ã¨æ¤œç´¢ãƒãƒ¼ãƒ»ä¸¦ã³æ›¿ãˆã‚’åŒã˜è¡Œã« */}
        <Box mb="lg">
          <Group justify="space-between" align="flex-start" wrap="wrap" gap="md">
            {/* å·¦å´: ã‚¿ãƒ– */}
            <Tabs 
              value={activeTab} 
              onChange={(value) => setActiveTab(value || 'cats')} 
              style={{ flex: 1, minWidth: 'fit-content' }}
            >
              <Tabs.List>
                <Tabs.Tab value="cats">Cats ({isStatisticsLoading ? '...' : totalCount})</Tabs.Tab>
                <Tabs.Tab value="male">Male ({isStatisticsLoading ? '...' : maleCount})</Tabs.Tab>
                <Tabs.Tab value="female">Female ({isStatisticsLoading ? '...' : femaleCount})</Tabs.Tab>
                <Tabs.Tab value="kitten">Kitten ({isStatisticsLoading ? '...' : kittenCount})</Tabs.Tab>
                <Tabs.Tab value="raising">Raising ({isStatisticsLoading ? '...' : raisingCount})</Tabs.Tab>
                <Tabs.Tab value="grad">Grad ({isStatisticsLoading ? '...' : gradCount})</Tabs.Tab>
              </Tabs.List>
            </Tabs>

            {/* å³å´: æ¤œç´¢ã¨ã‚½ãƒ¼ãƒˆ */}
            <Group gap="sm" wrap="nowrap" style={{ minWidth: 'fit-content' }}>
              <TextInput
                placeholder="æ¤œç´¢..."
                leftSection={<IconSearch size={16} />}
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                style={{ width: 200 }}
              />
              <Select
                placeholder="ä¸¦ã³æ›¿ãˆ"
                data={[
                  { value: 'name', label: 'åå‰é †' },
                  { value: 'age', label: 'å¹´é½¢é †ï¼ˆæ–°ã—ã„é †ï¼‰' },
                  { value: 'breed', label: 'å“ç¨®é †' },
                  { value: 'gender', label: 'æ€§åˆ¥é †' },
                  { value: 'gender-name', label: 'æ€§åˆ¥ â†’ åå‰é †' },
                  { value: 'gender-age', label: 'æ€§åˆ¥ â†’ å¹´é½¢é †' },
                  { value: 'breed-name', label: 'å“ç¨® â†’ åå‰é †' },
                ]}
                value={sortBy}
                onChange={(value) => setSortBy(value || 'name')}
                style={{ width: 180 }}
              />
            </Group>
          </Group>
        </Box>

        {/* ã‚¨ãƒ©ãƒ¼è¡¨ç¤º */}
        {isError && (
          <Alert icon={<IconAlertCircle />} title="ã‚¨ãƒ©ãƒ¼" color="red" mb="md">
            {error instanceof Error ? error.message : 'ãƒ‡ãƒ¼ã‚¿å–å¾—å¤±æ•—'}
          </Alert>
        )}

        {/* ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° */}
        {(isLoading || isRefetching) && (
          <Stack gap="xs">
            {[...Array(4)].map((_, i) => (
              <Skeleton key={i} height={60} radius="md" />
            ))}
          </Stack>
        )}

        {/* çŒ«ãƒªã‚¹ãƒˆï¼ˆãƒªã‚µã‚¤ã‚ºå¯èƒ½ãªãƒ†ãƒ¼ãƒ–ãƒ«ï¼‰ */}
        {!isLoading && !isError && (
          <Card shadow="sm" padding="md" radius="md" withBorder>
            <Box style={{ overflowX: 'auto', overflowY: 'visible' }}>
              <Table striped highlightOnHover style={{ minWidth: 800, tableLayout: 'fixed' }}>
                <Table.Thead>
                  <Table.Tr>
                    <Table.Th style={{ width: `${columnWidths.name}%`, position: 'relative', userSelect: 'none' }}>
                      Name
                      <Box
                        style={{
                          position: 'absolute',
                          right: 0,
                          top: 0,
                          bottom: 0,
                          width: 8,
                          cursor: 'col-resize',
                          backgroundColor: resizingColumn === 'name' ? 'var(--mantine-color-blue-5)' : 'transparent',
                          transition: 'background-color 0.2s',
                        }}
                        onMouseDown={(e) => handleResizeStart('name', e)}
                        onMouseEnter={(e) => {
                          if (!resizingColumn) {
                            (e.target as HTMLElement).style.backgroundColor = 'var(--mantine-color-gray-3)';
                          }
                        }}
                        onMouseLeave={(e) => {
                          if (!resizingColumn) {
                            (e.target as HTMLElement).style.backgroundColor = 'transparent';
                          }
                        }}
                      />
                    </Table.Th>
                  <Table.Th style={{ width: `${columnWidths.gender}%`, position: 'relative', userSelect: 'none' }}>
                    Gender
                    <Box
                      style={{
                        position: 'absolute',
                        right: 0,
                        top: 0,
                        bottom: 0,
                        width: 8,
                        cursor: 'col-resize',
                        backgroundColor: resizingColumn === 'gender' ? 'var(--mantine-color-blue-5)' : 'transparent',
                      }}
                      onMouseDown={(e) => handleResizeStart('gender', e)}
                      onMouseEnter={(e) => {
                        if (!resizingColumn) {
                          (e.target as HTMLElement).style.backgroundColor = 'var(--mantine-color-gray-3)';
                        }
                      }}
                      onMouseLeave={(e) => {
                        if (!resizingColumn) {
                          (e.target as HTMLElement).style.backgroundColor = 'transparent';
                        }
                      }}
                    />
                  </Table.Th>
                  <Table.Th style={{ width: `${columnWidths.breed}%`, position: 'relative', userSelect: 'none' }}>
                    Breed
                    <Box
                      style={{
                        position: 'absolute',
                        right: 0,
                        top: 0,
                        bottom: 0,
                        width: 8,
                        cursor: 'col-resize',
                        backgroundColor: resizingColumn === 'breed' ? 'var(--mantine-color-blue-5)' : 'transparent',
                      }}
                      onMouseDown={(e) => handleResizeStart('breed', e)}
                      onMouseEnter={(e) => {
                        if (!resizingColumn) {
                          (e.target as HTMLElement).style.backgroundColor = 'var(--mantine-color-gray-3)';
                        }
                      }}
                      onMouseLeave={(e) => {
                        if (!resizingColumn) {
                          (e.target as HTMLElement).style.backgroundColor = 'transparent';
                        }
                      }}
                    />
                  </Table.Th>
                  <Table.Th style={{ width: `${columnWidths.age}%`, position: 'relative', userSelect: 'none' }}>
                    Age
                    <Box
                      style={{
                        position: 'absolute',
                        right: 0,
                        top: 0,
                        bottom: 0,
                        width: 8,
                        cursor: 'col-resize',
                        backgroundColor: resizingColumn === 'age' ? 'var(--mantine-color-blue-5)' : 'transparent',
                      }}
                      onMouseDown={(e) => handleResizeStart('age', e)}
                      onMouseEnter={(e) => {
                        if (!resizingColumn) {
                          (e.target as HTMLElement).style.backgroundColor = 'var(--mantine-color-gray-3)';
                        }
                      }}
                      onMouseLeave={(e) => {
                        if (!resizingColumn) {
                          (e.target as HTMLElement).style.backgroundColor = 'transparent';
                        }
                      }}
                    />
                  </Table.Th>
                  <Table.Th style={{ width: `${columnWidths.tags}%`, position: 'relative', userSelect: 'none' }}>
                    Tags
                    <Box
                      style={{
                        position: 'absolute',
                        right: 0,
                        top: 0,
                        bottom: 0,
                        width: 8,
                        cursor: 'col-resize',
                        backgroundColor: resizingColumn === 'tags' ? 'var(--mantine-color-blue-5)' : 'transparent',
                      }}
                      onMouseDown={(e) => handleResizeStart('tags', e)}
                      onMouseEnter={(e) => {
                        if (!resizingColumn) {
                          (e.target as HTMLElement).style.backgroundColor = 'var(--mantine-color-gray-3)';
                        }
                      }}
                      onMouseLeave={(e) => {
                        if (!resizingColumn) {
                          (e.target as HTMLElement).style.backgroundColor = 'transparent';
                        }
                      }}
                    />
                  </Table.Th>
                  <Table.Th style={{ width: `${columnWidths.actions}%` }}>Operate</Table.Th>
                </Table.Tr>
              </Table.Thead>
              <Table.Tbody>
                {/* ã‚½ãƒ¼ãƒˆæ¸ˆã¿ã®çŒ«ãƒªã‚¹ãƒˆã‚’1ã¤ãšã¤è¡¨ç¤º */}
                {displayCats.map((cat: Cat) => {
                  const kittens = kittensByMother.get(cat.id) || [];
                  const hasMother = kittens.length > 0;
                  const isExpanded = expandedMotherIds.has(cat.id);

                  return (
                    <Fragment key={cat.id}>
                      {/* çŒ«ã®è¡Œï¼ˆæ¯çŒ«ã¾ãŸã¯é€šå¸¸ã®çŒ«ï¼‰ */}
                      <ContextMenuProvider
                        entity={cat}
                        entityType="çŒ«"
                        actions={['view', 'edit', 'delete', 'duplicate']}
                        onAction={handleContextAction}
                        enableDoubleClick={true}
                        doubleClickAction="edit"
                      >
                        <Table.Tr 
                          style={{ 
                            cursor: 'pointer',
                            backgroundColor: (hasMother && isExpanded) ? 'var(--mantine-color-blue-0)' : undefined
                          }}
                          title="å³ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§æ“ä½œ"
                        >
                          {/* åå‰ */}
                          <Table.Td style={{ overflow: 'hidden', whiteSpace: 'nowrap' }}>
                            {hasMother ? (
                              <Group gap="xs" wrap="nowrap" justify="space-between" style={{ width: '100%' }}>
                                <Text fw={600} style={{ overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap', minWidth: 0 }}>
                                  {cat.name}
                                </Text>
                                <Badge 
                                  size="xs" 
                                  color="pink" 
                                  variant="outline"
                                  leftSection={isExpanded ? <IconChevronDown size={12} /> : <IconChevronRight size={12} />}
                                  rightSection={<IconCat size={12} />}
                                  style={{ 
                                    backgroundColor: 'white',
                                    cursor: 'pointer',
                                    userSelect: 'none',
                                    flexShrink: 0
                                  }}
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    toggleExpanded(cat.id);
                                  }}
                                >
                                  {kittens.length}
                                </Badge>
                              </Group>
                            ) : (
                              <Text fw={600} style={{ overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                                {cat.name}
                              </Text>
                            )}
                          </Table.Td>
                          
                          {/* æ€§åˆ¥ãƒãƒƒã‚¸ */}
                          <Table.Td style={{ overflow: 'hidden', whiteSpace: 'nowrap' }}>
                            <GenderBadge gender={cat.gender} size="sm" />
                          </Table.Td>
                          
                          {/* å“ç¨®å */}
                          <Table.Td style={{ overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                            <Text size="sm">{cat.breed?.name || 'æœªç™»éŒ²'}</Text>
                          </Table.Td>
                          
                          {/* å¹´é½¢ */}
                          <Table.Td style={{ overflow: 'hidden', whiteSpace: 'nowrap' }}>
                            <Text size="sm">{calculateAge(cat.birthDate)}</Text>
                          </Table.Td>
                          
                          {/* ã‚¿ã‚°è¡¨ç¤º */}
                          <Table.Td style={{ overflow: 'hidden', whiteSpace: 'nowrap' }}>
                            {cat.tags && cat.tags.length > 0 ? (
                              <Group gap={4} wrap="nowrap">
                                {cat.tags.slice(0, 3).map((catTag) => (
                                  <Badge 
                                    key={catTag.tag.id} 
                                    size="xs" 
                                    variant="dot"
                                    color={catTag.tag.color || 'gray'}
                                  >
                                    {catTag.tag.name}
                                  </Badge>
                                ))}
                                {cat.tags.length > 3 && (
                                  <Badge size="xs" variant="outline" color="gray">
                                    +{cat.tags.length - 3}
                                  </Badge>
                                )}
                              </Group>
                            ) : (
                              <Text size="xs" c="dimmed">-</Text>
                            )}
                          </Table.Td>
                          
                          {/* æ“ä½œã‚¢ã‚¤ã‚³ãƒ³ */}
                          <Table.Td style={{ overflow: 'hidden', whiteSpace: 'nowrap' }}>
                            <Group gap="xs" wrap="nowrap">
                              <ActionIconButton
                                action="edit"
                                onClick={(e) => {
                                  e.stopPropagation();
                                  setSelectedCatForEdit(cat);
                                  openEditModal();
                                }}
                                title="ç·¨é›†"
                              />
                              <ActionIconButton
                                action="delete"
                                onClick={(e) => {
                                  e.stopPropagation();
                                  handleContextAction('delete', cat);
                                }}
                                title="å‰Šé™¤"
                              />
                              <ActionIconButton
                                action="view"
                                onClick={(e) => {
                                  e.stopPropagation();
                                  handleViewDetails(cat.id);
                                }}
                                title="è©³ç´°"
                              />
                            </Group>
                          </Table.Td>
                        </Table.Tr>
                      </ContextMenuProvider>

                      {/* å­çŒ«ã®è¡Œï¼ˆå±•é–‹æ™‚ï¼‰ */}
                      {hasMother && isExpanded && kittens.map((kitten: Cat) => (
                        <ContextMenuProvider
                          key={kitten.id}
                          entity={kitten}
                          entityType="å­çŒ«"
                          actions={['view', 'edit', 'delete']}
                          onAction={handleContextAction}
                          enableDoubleClick={true}
                          doubleClickAction="edit"
                        >
                          <Table.Tr 
                            style={{ 
                              cursor: 'pointer',
                              backgroundColor: 'var(--mantine-color-gray-0)'
                            }}
                            title="å³ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§æ“ä½œ"
                          >
                            {/* åå‰ï¼ˆã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆï¼‰ */}
                            <Table.Td style={{ overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap', paddingLeft: '3rem' }}>
                              <Group gap="xs">
                                <IconCat size={14} style={{ color: 'var(--mantine-color-gray-6)' }} />
                                <Text size="sm">{kitten.name}</Text>
                              </Group>
                            </Table.Td>

                            {/* æ€§åˆ¥ãƒãƒƒã‚¸ */}
                            <Table.Td style={{ overflow: 'hidden', whiteSpace: 'nowrap' }}>
                              <GenderBadge gender={kitten.gender} size="sm" />
                            </Table.Td>
                            
                            {/* å“ç¨®å */}
                            <Table.Td style={{ overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                              <Text size="sm">{kitten.breed?.name || 'æœªç™»éŒ²'}</Text>
                            </Table.Td>
                            
                            {/* å¹´é½¢ */}
                            <Table.Td style={{ overflow: 'hidden', whiteSpace: 'nowrap' }}>
                              <Text size="sm">{calculateAge(kitten.birthDate)}</Text>
                            </Table.Td>
                            
                            {/* ã‚¿ã‚°è¡¨ç¤º */}
                            <Table.Td style={{ overflow: 'hidden', whiteSpace: 'nowrap' }}>
                              {kitten.tags && kitten.tags.length > 0 ? (
                                <Group gap={4} wrap="nowrap">
                                  {kitten.tags.slice(0, 3).map((catTag) => (
                                    <Badge 
                                      key={catTag.tag.id} 
                                      size="xs" 
                                      variant="dot"
                                      color={catTag.tag.color || 'gray'}
                                    >
                                      {catTag.tag.name}
                                    </Badge>
                                  ))}
                                  {kitten.tags.length > 3 && (
                                    <Badge size="xs" variant="outline" color="gray">
                                      +{kitten.tags.length - 3}
                                    </Badge>
                                  )}
                                </Group>
                              ) : (
                                <Text size="xs" c="dimmed">-</Text>
                              )}
                            </Table.Td>
                            
                            {/* æ“ä½œã‚¢ã‚¤ã‚³ãƒ³ */}
                            <Table.Td style={{ overflow: 'hidden', whiteSpace: 'nowrap' }}>
                              <Group gap="xs" wrap="nowrap">
                                <ActionIconButton
                                  action="edit"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    setSelectedCatForEdit(kitten);
                                    openEditModal();
                                  }}
                                  title="ç·¨é›†"
                                />
                                <ActionIconButton
                                  action="delete"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    handleContextAction('delete', kitten);
                                  }}
                                  title="å‰Šé™¤"
                                />
                                <ActionIconButton
                                  action="view"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    handleViewDetails(kitten.id);
                                  }}
                                  title="è©³ç´°"
                                />
                              </Group>
                            </Table.Td>
                          </Table.Tr>
                        </ContextMenuProvider>
                      ))}
                    </Fragment>
                  );
                })}
              </Table.Tbody>
            </Table>
          </Box>
        </Card>
        )}

        {!isLoading && !isError && filteredCats.length === 0 && (
          <Card shadow="sm" padding="lg" radius="md" withBorder>
            <Text ta="center">
              æ¡ä»¶ã«ä¸€è‡´ã™ã‚‹çŒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ
            </Text>
          </Card>
        )}
      </Container>

      {/* çŒ«æƒ…å ±ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ« */}
      {selectedCatForEdit && (
        <CatEditModal
          opened={editModalOpened}
          onClose={closeEditModal}
          catId={selectedCatForEdit.id}
          onSuccess={() => {
            refetch();
          }}
        />
      )}

      {/* ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼æ“ä½œãƒ¢ãƒ¼ãƒ€ãƒ« */}
      <OperationModalManager
        operationType={currentOperation}
        entity={currentEntity || undefined}
        entityType="çŒ«"
        onClose={closeOperation}
        onConfirm={handleOperationConfirm}
      />
    </Box>
  );
}
````

## File: frontend/src/app/tags/components/ExecuteRuleModal.tsx
````typescript
'use client';

import {
  Alert,
  Badge,
  Box,
  Button,
  Group,
  Text,
} from '@mantine/core';
import { IconInfoCircle, IconWand } from '@tabler/icons-react';
import { UnifiedModal, type ModalSection } from '@/components/common';

import type { TagAutomationRule } from '@/lib/api/hooks/use-tag-automation';

export type ExecuteRuleModalProps = {
  opened: boolean;
  onClose: () => void;
  rule: TagAutomationRule | null;
  isExecuting: boolean;
  onExecute: () => void;
};

/**
 * è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ãƒ†ã‚¹ãƒˆå®Ÿè¡Œãƒ¢ãƒ¼ãƒ€ãƒ«
 */
export function ExecuteRuleModal({
  opened,
  onClose,
  rule,
  isExecuting,
  onExecute,
}: ExecuteRuleModalProps) {
  const sections: ModalSection[] = !rule
    ? []
    : [
        {
          content: (
            <Alert icon={<IconInfoCircle size={18} />} variant="light" color="blue">
              ã“ã®ãƒ«ãƒ¼ãƒ«ã‚’ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã—ã¾ã™ã€‚å®Ÿéš›ã®ãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦ã‚¿ã‚°ã®ä»˜ä¸ãŒè¡Œã‚ã‚Œã¾ã™ã®ã§ã”æ³¨æ„ãã ã•ã„ã€‚
            </Alert>
          ),
        },
        {
          label: "ãƒ«ãƒ¼ãƒ«è©³ç´°",
          content: (
            <>
              <Box>
                <Text size="sm" fw={500} mb={4}>
                  ãƒ«ãƒ¼ãƒ«å
                </Text>
                <Text size="sm" c="dimmed">
                  {rule.name}
                </Text>
              </Box>

              {rule.description && (
                <Box>
                  <Text size="sm" fw={500} mb={4}>
                    èª¬æ˜
                  </Text>
                  <Text size="sm" c="dimmed">
                    {rule.description}
                  </Text>
                </Box>
              )}

              <Box>
                <Text size="sm" fw={500} mb={4}>
                  ã‚¤ãƒ™ãƒ³ãƒˆã‚¿ã‚¤ãƒ—
                </Text>
                <Badge size="sm" variant="light">
                  {rule.eventType === 'BREEDING_PLANNED' && 'äº¤é…äºˆå®š'}
                  {rule.eventType === 'BREEDING_CONFIRMED' && 'äº¤é…ç¢ºèª'}
                  {rule.eventType === 'PREGNANCY_CONFIRMED' && 'å¦Šå¨ ç¢ºèª'}
                  {rule.eventType === 'KITTEN_REGISTERED' && 'å­çŒ«ç™»éŒ²'}
                  {rule.eventType === 'AGE_THRESHOLD' && 'å¹´é½¢é–¾å€¤'}
                  {rule.eventType === 'PAGE_ACTION' && 'ãƒšãƒ¼ã‚¸ã‚¢ã‚¯ã‚·ãƒ§ãƒ³'}
                  {rule.eventType === 'CUSTOM' && 'ã‚«ã‚¹ã‚¿ãƒ '}
                </Badge>
              </Box>

              {rule.config && typeof rule.config === 'object' && (rule.config as { tagIds?: string[] }).tagIds && (
                <Box>
                  <Text size="sm" fw={500} mb={4}>
                    ä»˜ä¸ã™ã‚‹ã‚¿ã‚°
                  </Text>
                  <Text size="sm" c="dimmed">
                    {((rule.config as { tagIds?: string[] }).tagIds ?? []).length}å€‹ã®ã‚¿ã‚°ã‚’ä»˜ä¸
                  </Text>
                </Box>
              )}

              <Alert icon={<IconInfoCircle size={18} />} variant="light" color="yellow">
                æ³¨æ„: ãƒ†ã‚¹ãƒˆç”¨ã®ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ã§ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºè¡Œã—ã¾ã™ã€‚å®Ÿéš›ã®çŒ«ãƒ‡ãƒ¼ã‚¿ã«ã¯å½±éŸ¿ã—ã¾ã›ã‚“ã€‚
              </Alert>
            </>
          ),
        },
        {
          content: (
            <Group justify="flex-end" mt="md">
              <Button
                variant="subtle"
                onClick={onClose}
                disabled={isExecuting}
              >
                ã‚­ãƒ£ãƒ³ã‚»ãƒ«
              </Button>
              <Button
                color="green"
                onClick={onExecute}
                loading={isExecuting}
                leftSection={<IconWand size={16} />}
              >
                å®Ÿè¡Œ
              </Button>
            </Group>
          ),
        },
      ];

  return (
    <UnifiedModal
      opened={opened}
      onClose={onClose}
      title="è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ«ã®ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ"
      size="md"
      sections={sections}
    />
  );
}
````

## File: frontend/src/components/breeding/breeding-schedule-edit-modal.tsx
````typescript
'use client';

import { useState, useEffect } from 'react';
import {
  Button,
  Group,
  Text,
  NumberInput,
  Badge,
  Select,
} from '@mantine/core';
import { UnifiedModal, type ModalSection } from '@/components/common';

interface Cat {
  id: string;
  name: string;
  gender: 'MALE' | 'FEMALE' | 'NEUTER' | 'SPAY';
  birthDate: string;
  breed?: { id: string; name: string } | null;
  tags?: Array<{ tag: { id: string; name: string; color: string } }>;
}

interface BreedingScheduleEntry {
  maleId: string;
  maleName: string;
  femaleId: string;
  femaleName: string;
  date: string;
  duration: number;
  dayIndex: number;
  isHistory: boolean;
  result?: string;
}

interface BreedingScheduleEditModalProps {
  opened: boolean;
  onClose: () => void;
  schedule: BreedingScheduleEntry | null;
  availableFemales: Cat[];
  onSave: (newDuration: number, newFemaleId?: string) => void;
  onDelete?: () => void;
}

export function BreedingScheduleEditModal({
  opened,
  onClose,
  schedule,
  availableFemales,
  onSave,
  onDelete,
}: BreedingScheduleEditModalProps) {
  const [duration, setDuration] = useState<number>(1);
  const [femaleId, setFemaleId] = useState<string>('');
  const [isSaving, setIsSaving] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);

  useEffect(() => {
    if (opened && schedule) {
      setDuration(schedule.duration);
      setFemaleId(schedule.femaleId);
    }
  }, [opened, schedule]);

  const handleSave = async () => {
    if (!schedule) return;

    setIsSaving(true);
    try {
      // ãƒ¡ã‚¹çŒ«ãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆã®ã¿æ–°ã—ã„IDã‚’æ¸¡ã™
      const newFemaleId = femaleId !== schedule.femaleId ? femaleId : undefined;
      onSave(duration, newFemaleId);
      onClose();
    } catch (err) {
      console.error('Failed to update breeding schedule:', err);
    } finally {
      setIsSaving(false);
    }
  };

  const handleDelete = async () => {
    if (!schedule || !onDelete) return;

    const confirmed = window.confirm(
      `${schedule.maleName} Ã— ${schedule.femaleName} ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`
    );

    if (!confirmed) return;

    setIsDeleting(true);
    try {
      onDelete();
      onClose();
    } catch (err) {
      console.error('Failed to delete breeding schedule:', err);
    } finally {
      setIsDeleting(false);
    }
  };

  if (!schedule) return null;

  // é–‹å§‹æ—¥ã‚’è¨ˆç®—
  const startDate = new Date(schedule.date);
  startDate.setDate(startDate.getDate() - schedule.dayIndex);
  const startDateStr = startDate.toLocaleDateString('ja-JP', { month: 'numeric', day: 'numeric' });

  // ãƒ¡ã‚¹çŒ«ã®é¸æŠè‚¢ã‚’ä½œæˆ
  const femaleOptions = availableFemales.map((cat) => ({
    value: cat.id,
    label: cat.name,
  }));

  const sections: ModalSection[] = [
    {
      content: (
        <>
          <Group gap="xs" wrap="wrap">
        <Badge color="blue">{schedule.maleName}</Badge>
        <Text size="sm">Ã—</Text>
        <Badge color="pink">{schedule.femaleName}</Badge>
        {schedule.isHistory && (
          <Badge color="gray" variant="light">éå»</Badge>
        )}
      </Group>

      <Text size="sm" c="dimmed">
        é–‹å§‹æ—¥: {startDateStr}
      </Text>
        </>
      ),
    },
    {
      label: "ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«è¨­å®š",
      content: (
        <>
          <Select
        label="ãƒ¡ã‚¹çŒ«"
        description="äº¤é…ç›¸æ‰‹ã®ãƒ¡ã‚¹çŒ«ã‚’å¤‰æ›´ã§ãã¾ã™"
        value={femaleId}
        onChange={(value) => setFemaleId(value || '')}
        data={femaleOptions}
        searchable
      />

      <NumberInput
        label="äº¤é…æœŸé–“"
        description="äº¤é…ã‚’è¡Œã†æ—¥æ•°ã‚’è¨­å®šã—ã¦ãã ã•ã„"
        value={duration}
        onChange={(value) => setDuration(typeof value === 'number' ? value : 1)}
        min={1}
        max={7}
        suffix="æ—¥é–“"
      />

      {!schedule.isHistory && (
        <Text size="xs" c="dimmed">
          â€» æœŸé–“ã‚’çŸ­ç¸®ã™ã‚‹ã¨ã€æœ€çµ‚æ—¥ä»¥é™ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå‰Šé™¤ã•ã‚Œã¾ã™
        </Text>
      )}
        </>
      ),
    },
    {
      content: (
        <Group justify="space-between" gap="sm">
        <Group gap="xs">
          {onDelete && (
            <Button 
              variant="outline" 
              color="red" 
              onClick={handleDelete}
              loading={isDeleting}
            >
              å‰Šé™¤
            </Button>
          )}
        </Group>
        <Group gap="xs">
          <Button variant="outline" onClick={onClose} disabled={isSaving || isDeleting}>
            ã‚­ãƒ£ãƒ³ã‚»ãƒ«
          </Button>
          <Button onClick={handleSave} loading={isSaving} disabled={isDeleting}>
            ä¿å­˜
          </Button>
        </Group>
      </Group>
      ),
    },
  ];

  return (
    <UnifiedModal
      opened={opened}
      onClose={onClose}
      title={schedule.isHistory ? 'éå»ã®äº¤é…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ç·¨é›†' : 'äº¤é…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ç·¨é›†'}
      size="md"
      centered
      sections={sections}
    />
  );
}
````

## File: frontend/src/components/breeding/kitten-disposition-modal.tsx
````typescript
'use client';

import { TextInput, Select, NumberInput, Textarea, Button, Group } from '@mantine/core';
import { useState, useEffect } from 'react';
import { UnifiedModal, type ModalSection } from '@/components/common';
import type { Cat } from '@/lib/api/hooks/use-cats';
import type { DispositionType, SaleInfo } from '@/lib/api/hooks/use-breeding';

interface KittenDispositionModalProps {
  opened: boolean;
  onClose: () => void;
  kitten: Cat | null;
  birthRecordId?: string;
  dispositionType?: DispositionType;
  onSuccess?: () => void;
  onSubmit?: (data: {
    disposition: DispositionType;
    trainingStartDate?: string;
    saleInfo?: SaleInfo;
    deathDate?: string;
    deathReason?: string;
    notes?: string;
  }) => void;
  loading?: boolean;
}

export function KittenDispositionModal({
  opened,
  onClose,
  kitten,
  birthRecordId: _birthRecordId,
  dispositionType,
  onSuccess,
  onSubmit,
  loading,
}: KittenDispositionModalProps) {
  const [disposition, setDisposition] = useState<DispositionType>('TRAINING');
  const [trainingStartDate, setTrainingStartDate] = useState(new Date().toISOString().split('T')[0]);
  const [buyer, setBuyer] = useState('');
  const [price, setPrice] = useState<number>(0);
  const [saleDate, setSaleDate] = useState(new Date().toISOString().split('T')[0]);
  const [saleNotes, setSaleNotes] = useState('');
  const [deathDate, setDeathDate] = useState(new Date().toISOString().split('T')[0]);
  const [deathReason, setDeathReason] = useState('');
  const [notes, setNotes] = useState('');

  // dispositionTypeãŒå¤‰æ›´ã•ã‚ŒãŸã‚‰æ›´æ–°
  useEffect(() => {
    if (dispositionType) {
      setDisposition(dispositionType);
    }
  }, [dispositionType]);

  const handleSubmit = () => {
    if (!onSubmit) return;
    
    const data = {
      disposition,
      notes,
    } as {
      disposition: DispositionType;
      trainingStartDate?: string;
      saleInfo?: SaleInfo;
      deathDate?: string;
      deathReason?: string;
      notes?: string;
    };

    if (disposition === 'TRAINING') {
      data.trainingStartDate = trainingStartDate;
    } else if (disposition === 'SALE') {
      data.saleInfo = {
        buyer,
        price,
        saleDate,
        notes: saleNotes,
      };
    } else if (disposition === 'DECEASED') {
      data.deathDate = deathDate;
      data.deathReason = deathReason;
    }

    onSubmit(data);
    if (onSuccess) onSuccess();
  };

  const resetForm = () => {
    setDisposition('TRAINING');
    setTrainingStartDate(new Date().toISOString().split('T')[0]);
    setBuyer('');
    setPrice(0);
    setSaleDate(new Date().toISOString().split('T')[0]);
    setSaleNotes('');
    setDeathDate(new Date().toISOString().split('T')[0]);
    setDeathReason('');
    setNotes('');
  };

  const sections: ModalSection[] = !kitten
    ? [
        {
          content: <div>å­çŒ«æƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“</div>,
        },
      ]
    : [
        {
          content: (
            <TextInput
              label="å­çŒ«å"
              value={kitten.name}
              readOnly
            />
          ),
        },
        {
          label: "å‡¦é‡è¨­å®š",
          content: (
            <>
              <Select
          label="å‡¦é‡"
          value={disposition}
          onChange={(value) => setDisposition(value as DispositionType)}
          data={[
            { value: 'TRAINING', label: 'é¤Šæˆ' },
            { value: 'SALE', label: 'å‡ºè·' },
            { value: 'DECEASED', label: 'æ­»äº¡' },
          ]}
          required
        />

        {disposition === 'TRAINING' && (
          <TextInput
            label="é¤Šæˆé–‹å§‹æ—¥"
            type="date"
            value={trainingStartDate}
            onChange={(e) => setTrainingStartDate(e.target.value)}
            required
          />
        )}

        {disposition === 'SALE' && (
          <>
            <TextInput
              label="è­²æ¸¡å…ˆ"
              placeholder="å€‹äººåã¾ãŸã¯æ¥­è€…å"
              value={buyer}
              onChange={(e) => setBuyer(e.target.value)}
              required
            />
            <NumberInput
              label="è­²æ¸¡é‡‘é¡ï¼ˆå††ï¼‰"
              value={price}
              onChange={(value) => setPrice(typeof value === 'number' ? value : 0)}
              min={0}
              thousandSeparator=","
              required
            />
            <TextInput
              label="è­²æ¸¡æ—¥"
              type="date"
              value={saleDate}
              onChange={(e) => setSaleDate(e.target.value)}
              required
            />
            <Textarea
              label="è­²æ¸¡ãƒ¡ãƒ¢"
              placeholder="è­²æ¸¡ã«é–¢ã™ã‚‹è©³ç´°"
              value={saleNotes}
              onChange={(e) => setSaleNotes(e.target.value)}
            />
          </>
        )}

        {disposition === 'DECEASED' && (
          <>
            <TextInput
              label="æ­»äº¡æ—¥"
              type="date"
              value={deathDate}
              onChange={(e) => setDeathDate(e.target.value)}
              required
            />
            <Textarea
              label="æ­»äº¡ç†ç”±"
              placeholder="æ­»äº¡ç†ç”±ã‚’è¨˜å…¥"
              value={deathReason}
              onChange={(e) => setDeathReason(e.target.value)}
            />
          </>
        )}

        <Textarea
          label="ãƒ¡ãƒ¢"
          placeholder="ãã®ä»–ã®ãƒ¡ãƒ¢"
          value={notes}
          onChange={(e) => setNotes(e.target.value)}
        />
            </>
          ),
        },
        {
          content: (
            <Group justify="flex-end" gap="sm" mt="md">
          <Button
            variant="outline"
            onClick={() => {
              resetForm();
              onClose();
            }}
          >
            ã‚­ãƒ£ãƒ³ã‚»ãƒ«
          </Button>
          <Button
            onClick={handleSubmit}
            loading={loading}
          >
            ç™»éŒ²
          </Button>
        </Group>
          ),
        },
      ];

  return (
    <UnifiedModal
      opened={opened}
      onClose={() => {
        resetForm();
        onClose();
      }}
      title={`å­çŒ«å‡¦é‡ç™»éŒ²: ${kitten?.name || ''}`}
      size="md"
      sections={sections}
    />
  );
}
````

## File: frontend/src/components/kittens/KittenManagementModal.tsx
````typescript
'use client';

import { useState, useEffect } from 'react';
import {
  Stack,
  Select,
  Group,
  Button,
  TextInput,
  Checkbox,
  NumberInput,
  Card,
  Text,
  Badge,
  ActionIcon,
  Flex,
  Box,
} from '@mantine/core';
import { IconTrash, IconPlus, IconDeviceFloppy, IconX, IconList, IconClipboard } from '@tabler/icons-react';
import { notifications } from '@mantine/notifications';
import { TabsSection } from '@/components/TabsSection';
import { useGetCats, useCreateCat, useUpdateCat, type Cat } from '@/lib/api/hooks/use-cats';
import { useGetCoatColors, type CoatColor } from '@/lib/api/hooks/use-coat-colors';
import { useGetBirthPlans, useCreateKittenDisposition, type BirthPlan } from '@/lib/api/hooks/use-breeding';
import { UnifiedModal, type ModalSection } from '@/components/common';

interface KittenData {
  id?: string; // æ—¢å­˜ã®å­çŒ«ã®å ´åˆã¯IDã€æ–°è¦ã®å ´åˆã¯undefined
  tempId?: string; // ä¸€æ™‚çš„ãªIDï¼ˆæ–°è¦ç™»éŒ²ç”¨ï¼‰
  name: string;
  gender: 'MALE' | 'FEMALE';
  coatColorId: string;
  birthDate: string;
  isSelected: boolean;
  disposition?: {
    type: 'TRAINING' | 'SALE' | 'DECEASED';
    trainingStartDate?: string;
    saleInfo?: { buyer: string; price: number; saleDate: string; notes?: string };
    deathDate?: string;
    deathReason?: string;
  };
}

interface Props {
  opened: boolean;
  onClose: () => void;
  motherId?: string; // æ¯çŒ«IDã‚’æŒ‡å®šã—ãŸå ´åˆã€ãã®æ¯çŒ«ã®å­çŒ«ã‚’ç·¨é›†
  onSuccess?: () => void;
}

export function KittenManagementModal({ opened, onClose, motherId, onSuccess }: Props) {
  const [selectedMotherId, setSelectedMotherId] = useState<string>(motherId || '');
  const [kittens, setKittens] = useState<KittenData[]>([]);
  const [maleCount, setMaleCount] = useState(0);
  const [femaleCount, setFemaleCount] = useState(0);
  const [activeTab, setActiveTab] = useState<string>('list');
  
  // å‡¦é‡ã®è©³ç´°æƒ…å ±
  const [dispositionDetails, setDispositionDetails] = useState<{
    type?: 'TRAINING' | 'SALE' | 'DECEASED';
    trainingStartDate?: string;
    buyer?: string;
    price?: number;
    saleDate?: string;
    deathDate?: string;
    deathReason?: string;
  }>({});

  // API hooks
  const catsQuery = useGetCats({ limit: 1000 });
  const coatColorsQuery = useGetCoatColors();
  const birthPlansQuery = useGetBirthPlans();
  const createCatMutation = useCreateCat();
  const updateCatMutation = useUpdateCat(''); // IDã¯å¾Œã§è¨­å®š
  const createKittenDispositionMutation = useCreateKittenDisposition();

  // æ¯çŒ«ãƒªã‚¹ãƒˆã‚’å–å¾—ï¼ˆåœ¨èˆä¸­ã®ãƒ¡ã‚¹çŒ«ã®ã¿ï¼‰
  const motherCats = (catsQuery.data?.data || []).filter(
    (cat: Cat) => cat.gender === 'FEMALE' && cat.isInHouse
  );

  // è‰²æŸ„ãƒªã‚¹ãƒˆï¼ˆãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã¯ç©ºé…åˆ—ï¼‰
  const coatColors = coatColorsQuery.data?.data?.data || [];
  const hasCoatColors = coatColors.length > 0;

  // é¸æŠã•ã‚ŒãŸæ¯çŒ«ã®æ—¢å­˜å­çŒ«ã‚’èª­ã¿è¾¼ã‚€
  useEffect(() => {
    // ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒé–‹ã„ã¦ã„ãªã„å ´åˆã¯ä½•ã‚‚ã—ãªã„
    if (!opened) return;
    if (!selectedMotherId || !catsQuery.data?.data) return;

    // ã“ã®æ¯çŒ«ã®å­çŒ«ã‚’å–å¾—ï¼ˆç”Ÿå¾Œ6ãƒ¶æœˆæœªæº€ï¼‰
    const existingKittens = (catsQuery.data.data || [])
      .filter((cat: Cat) => {
        if (cat.motherId !== selectedMotherId) return false;
        
        // ç”Ÿå¾Œ6ãƒ¶æœˆæœªæº€ã‹ãƒã‚§ãƒƒã‚¯
        const birthDate = new Date(cat.birthDate);
        const now = new Date();
        const monthsDiff = (now.getFullYear() - birthDate.getFullYear()) * 12 + (now.getMonth() - birthDate.getMonth());
        return monthsDiff < 6;
      })
      .map((cat: Cat) => ({
        id: cat.id,
        name: cat.name,
        gender: cat.gender as 'MALE' | 'FEMALE',
        coatColorId: cat.coatColorId || '',
        birthDate: cat.birthDate.split('T')[0], // YYYY-MM-DDå½¢å¼ã«å¤‰æ›
        isSelected: false,
      }));

    setKittens(existingKittens);
    setMaleCount(0);
    setFemaleCount(0);
  }, [opened, selectedMotherId, catsQuery.data]);

  // motherIdãŒå¤–éƒ¨ã‹ã‚‰æŒ‡å®šã•ã‚ŒãŸå ´åˆ
  useEffect(() => {
    if (motherId) {
      setSelectedMotherId(motherId);
    }
  }, [motherId]);

  // é ­æ•°ã‚’å¤‰æ›´ã—ãŸã¨ãã«ä¸€æ™‚çš„ãªå­çŒ«ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
  const handleCountChange = (type: 'male' | 'female', count: number) => {
    if (type === 'male') {
      setMaleCount(count);
    } else {
      setFemaleCount(count);
    }

    // æ—¢å­˜ã®å­çŒ«æ•°ã‚’å–å¾—
    const existingKittens = kittens.filter(k => k.id);
    const existingCount = existingKittens.length;

    // æ–°è¦å­çŒ«ã®é–‹å§‹ç•ªå·
    let kittenNumber = existingCount + 1;

    // æ¯çŒ«åã‚’å–å¾—
    const mother = motherCats.find(cat => cat.id === selectedMotherId);
    const motherName = mother?.name || 'å­çŒ«';

    // ä¸€æ™‚çš„ãªå­çŒ«ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
    const newKittens: KittenData[] = [];

    // ã‚ªã‚¹ã®å­çŒ«
    const newMaleCount = type === 'male' ? count : maleCount;
    for (let i = 0; i < newMaleCount; i++) {
      newKittens.push({
        tempId: `temp-male-${i}`,
        name: `${motherName}${kittenNumber++}å·`,
        gender: 'MALE',
        coatColorId: '',
        birthDate: new Date().toISOString().split('T')[0],
        isSelected: false,
      });
    }

    // ãƒ¡ã‚¹ã®å­çŒ«
    const newFemaleCount = type === 'female' ? count : femaleCount;
    for (let i = 0; i < newFemaleCount; i++) {
      newKittens.push({
        tempId: `temp-female-${i}`,
        name: `${motherName}${kittenNumber++}å·`,
        gender: 'FEMALE',
        coatColorId: '',
        birthDate: new Date().toISOString().split('T')[0],
        isSelected: false,
      });
    }

    setKittens([...existingKittens, ...newKittens]);
  };

  // å­çŒ«ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
  const updateKitten = <Field extends keyof KittenData>(index: number, field: Field, value: KittenData[Field]) => {
    setKittens(prev => {
      const updated = [...prev];
      updated[index] = { ...updated[index], [field]: value };
      return updated;
    });
  };

  // å­çŒ«ã‚’å‰Šé™¤
  const removeKitten = (index: number) => {
    setKittens(prev => prev.filter((_, i) => i !== index));
  };

  // å…¨é¸æŠ/å…¨è§£é™¤
  const toggleSelectAll = () => {
    const allSelected = kittens.every(k => k.isSelected);
    setKittens(prev => prev.map(k => ({ ...k, isSelected: !allSelected })));
  };

  // é¸æŠã•ã‚ŒãŸå­çŒ«ã«ä¸€æ‹¬ã§å‡¦é‡ã‚’è¨­å®š
  const applyDispositionToSelected = (dispositionType: 'TRAINING' | 'SALE' | 'DECEASED') => {
    const selectedKittens = kittens.filter(k => k.isSelected);
    if (selectedKittens.length === 0) {
      notifications.show({
        title: 'é¸æŠã‚¨ãƒ©ãƒ¼',
        message: 'å­çŒ«ã‚’é¸æŠã—ã¦ãã ã•ã„',
        color: 'yellow',
      });
      return;
    }

    // å‡¦é‡è¨­å®šæ™‚ã«è©³ç´°æƒ…å ±ã‚’ä½¿ç”¨
    const disposition = {
      type: dispositionType,
      trainingStartDate: dispositionType === 'TRAINING' ? (dispositionDetails.trainingStartDate || new Date().toISOString().split('T')[0]) : undefined,
      saleInfo: dispositionType === 'SALE' ? { 
        buyer: dispositionDetails.buyer || '', 
        price: dispositionDetails.price || 0, 
        saleDate: dispositionDetails.saleDate || new Date().toISOString().split('T')[0],
        notes: ''
      } : undefined,
      deathDate: dispositionType === 'DECEASED' ? (dispositionDetails.deathDate || new Date().toISOString().split('T')[0]) : undefined,
      deathReason: dispositionType === 'DECEASED' ? dispositionDetails.deathReason : undefined,
    };

    setKittens(prev => prev.map(k => 
      k.isSelected ? { ...k, disposition } : k
    ));

    notifications.show({
      title: 'å‡¦é‡è¨­å®š',
      message: `${selectedKittens.length}é ­ã®å­çŒ«ã«å‡¦é‡ã‚’è¨­å®šã—ã¾ã—ãŸ`,
      color: 'blue',
    });
  };

  // ä¿å­˜å‡¦ç†
  const handleSave = async () => {
    if (!selectedMotherId) {
      notifications.show({
        title: 'å…¥åŠ›ã‚¨ãƒ©ãƒ¼',
        message: 'æ¯çŒ«ã‚’é¸æŠã—ã¦ãã ã•ã„',
        color: 'red',
      });
      return;
    }

    if (kittens.length === 0) {
      notifications.show({
        title: 'å…¥åŠ›ã‚¨ãƒ©ãƒ¼',
        message: 'å­çŒ«ã‚’ç™»éŒ²ã—ã¦ãã ã•ã„',
        color: 'red',
      });
      return;
    }

    try {
      // æ–°è¦å­çŒ«ã‚’ç™»éŒ²
      const newKittens = kittens.filter(k => !k.id);
      const createdKittenIds: { [key: string]: string } = {}; // tempId -> å®Ÿéš›ã®ID
      
      for (const kitten of newKittens) {
        const result = await createCatMutation.mutateAsync({
          name: kitten.name,
          gender: kitten.gender,
          birthDate: kitten.birthDate,
          motherId: selectedMotherId,
          coatColorId: kitten.coatColorId || undefined,
          isInHouse: true,
        });
        if (kitten.tempId && result.data) {
          createdKittenIds[kitten.tempId] = result.data.id;
        }
      }

      // æ—¢å­˜å­çŒ«ã‚’æ›´æ–°
      const existingKittens = kittens.filter(k => k.id);
      await Promise.all(
        existingKittens.map((kitten) =>
          updateCatMutation.mutateAsync({
            id: kitten.id,
            name: kitten.name,
            gender: kitten.gender,
            birthDate: kitten.birthDate,
            coatColorId: kitten.coatColorId || null,
            motherId: selectedMotherId,
            isInHouse: true,
          })
        )
      );

      // å‡¦é‡æƒ…å ±ã‚’ç™»éŒ²
      const kittensWithDisposition = kittens.filter(k => k.disposition);
      if (kittensWithDisposition.length > 0) {
        // ã“ã®æ¯çŒ«ã®BirthPlanã‚’å–å¾—ï¼ˆå‡ºç”£æ¸ˆã¿ã®ã‚‚ã®ï¼‰
        const birthPlans = birthPlansQuery.data?.data || [];
        const relevantPlan = birthPlans.find((plan: BirthPlan) => 
          plan.motherId === selectedMotherId && 
          plan.status === 'BORN'
        );

        if (relevantPlan) {
          for (const kitten of kittensWithDisposition) {
            const kittenId = kitten.id || (kitten.tempId ? createdKittenIds[kitten.tempId] : undefined);
            const disposition = kitten.disposition;
            if (!disposition) {
              continue;
            }

            await createKittenDispositionMutation.mutateAsync({
              birthRecordId: relevantPlan.id,
              kittenId,
              name: kitten.name,
              gender: kitten.gender,
              disposition: disposition.type,
              trainingStartDate: disposition.trainingStartDate,
              saleInfo: disposition.saleInfo,
              deathDate: disposition.deathDate,
              deathReason: disposition.type === 'DECEASED' ? disposition.deathReason : undefined,
            });
          }
        }
      }

      notifications.show({
        title: 'ä¿å­˜æˆåŠŸ',
        message: 'å­çŒ«æƒ…å ±ã‚’ä¿å­˜ã—ã¾ã—ãŸ',
        color: 'green',
      });

      if (onSuccess) {
        onSuccess();
      }

      // ãƒ‡ãƒ¼ã‚¿å†å–å¾—ãŒå®Œäº†ã—ã¦ã‹ã‚‰ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
      setTimeout(() => {
        handleClose();
      }, 100);
    } catch (error) {
      console.error('Save error:', error);
      notifications.show({
        title: 'ä¿å­˜å¤±æ•—',
        message: error instanceof Error ? error.message : 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼',
        color: 'red',
      });
    }
  };

  // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
  const handleClose = () => {
    setSelectedMotherId(motherId || '');
    setKittens([]);
    setMaleCount(0);
    setFemaleCount(0);
    setActiveTab('list');
    setDispositionDetails({}); // å‡¦é‡è©³ç´°ã‚‚ãƒªã‚»ãƒƒãƒˆ
    onClose();
  };

  const sections: ModalSection[] = [
    {
      content: (
        <Select
          label="æ¯çŒ«é¸æŠ"
          placeholder="æ¯çŒ«ã‚’é¸æŠã—ã¦ãã ã•ã„"
          value={selectedMotherId}
          onChange={(value) => setSelectedMotherId(value || '')}
          data={motherCats.map((cat: Cat) => ({
            value: cat.id,
            label: `${cat.name} (${cat.birthDate})`,
          }))}
          disabled={!!motherId}
          searchable
        />
      ),
    },
    {
      content: (
        <TabsSection
        value={activeTab}
        onChange={(value) => setActiveTab(value || 'list')}
        tabs={[
          {
            value: 'list',
            label: 'å­çŒ«ãƒªã‚¹ãƒˆ',
            icon: <IconList size={14} />,
            count: kittens.length,
          },
          {
            value: 'disposition',
            label: 'å‡¦é‡è¨­å®š',
            icon: <IconClipboard size={14} />,
          },
        ]}
      >
        {/* å­çŒ«ãƒªã‚¹ãƒˆã‚¿ãƒ– */}
        {activeTab === 'list' && (
          <Box pt="md">
          <Stack gap="md">
            {/* é ­æ•°ç™»éŒ²ï¼ˆæ—¢å­˜å­çŒ«ãŒã„ãªã„å ´åˆï¼‰ */}
            {kittens.filter(k => k.id).length === 0 && (
              <Card padding="sm" withBorder>
                <Text size="sm" fw={500} mb="xs">æ–°è¦å­çŒ«ç™»éŒ²</Text>
                <Group grow>
                  <NumberInput
                    label="ã‚ªã‚¹é ­æ•°"
                    value={maleCount}
                    onChange={(value) => handleCountChange('male', Number(value) || 0)}
                    min={0}
                    max={10}
                  />
                  <NumberInput
                    label="ãƒ¡ã‚¹é ­æ•°"
                    value={femaleCount}
                    onChange={(value) => handleCountChange('female', Number(value) || 0)}
                    min={0}
                    max={10}
                  />
                </Group>
              </Card>
            )}

            {/* å…¨é¸æŠãƒœã‚¿ãƒ³ */}
            {kittens.length > 0 && (
              <Group justify="space-between">
                <Checkbox
                  label={`å…¨é¸æŠ (${kittens.filter(k => k.isSelected).length}/${kittens.length}é ­)`}
                  checked={kittens.length > 0 && kittens.every(k => k.isSelected)}
                  indeterminate={kittens.some(k => k.isSelected) && !kittens.every(k => k.isSelected)}
                  onChange={toggleSelectAll}
                />
                <Group gap="xs">
                  <Button
                    size="xs"
                    variant="light"
                    leftSection={<IconPlus size={14} />}
                    onClick={() => {
                      const mother = motherCats.find(cat => cat.id === selectedMotherId);
                      const motherName = mother?.name || 'å­çŒ«';
                      const kittenNumber = kittens.length + 1;
                      
                      setKittens(prev => [...prev, {
                        tempId: `temp-${Date.now()}`,
                        name: `${motherName}${kittenNumber}å·`,
                        gender: 'MALE',
                        coatColorId: '',
                        birthDate: new Date().toISOString().split('T')[0],
                        isSelected: false,
                      }]);
                    }}
                    disabled={!selectedMotherId}
                  >
                    å­çŒ«è¿½åŠ 
                  </Button>
                </Group>
              </Group>
            )}

            {/* å­çŒ«ãƒªã‚¹ãƒˆ */}
            {kittens.map((kitten, index) => (
              <Card key={kitten.id || kitten.tempId} padding="sm" withBorder>
                <Flex gap="sm" align="flex-start">
                  <Checkbox
                    checked={kitten.isSelected}
                    onChange={(e) => updateKitten(index, 'isSelected', e.currentTarget.checked)}
                    mt="md"
                  />
                  <Stack gap="xs" style={{ flex: 1 }}>
                    <Group grow>
                      <TextInput
                        label="åå‰"
                        value={kitten.name}
                        onChange={(e) => updateKitten(index, 'name', e.target.value)}
                        required
                      />
                      <Select
                        label="æ€§åˆ¥"
                        value={kitten.gender}
                        onChange={(value) => updateKitten(index, 'gender', value as 'MALE' | 'FEMALE')}
                        data={[
                          { value: 'MALE', label: 'ã‚ªã‚¹' },
                          { value: 'FEMALE', label: 'ãƒ¡ã‚¹' },
                        ]}
                        required
                      />
                    </Group>
                    <Group grow>
                      <Select
                        label="è‰²æŸ„"
                        value={kitten.coatColorId}
                        onChange={(value) => updateKitten(index, 'coatColorId', value || '')}
                        data={coatColors.map((color: CoatColor) => ({
                          value: color.id,
                          label: color.name,
                        }))}
                        placeholder={hasCoatColors ? "é¸æŠã—ã¦ãã ã•ã„" : "â€»ãƒ‡ãƒ¼ã‚¿æœªç™»éŒ²"}
                        searchable
                        clearable
                        disabled={!hasCoatColors}
                        description={!hasCoatColors ? "è‰²æŸ„ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿ãŒæœªç™»éŒ²ã§ã™" : undefined}
                      />
                      <TextInput
                        label="ç”Ÿå¹´æœˆæ—¥"
                        type="date"
                        value={kitten.birthDate}
                        onChange={(e) => updateKitten(index, 'birthDate', e.target.value)}
                        required
                      />
                    </Group>
                    {kitten.disposition && (
                      <Badge
                        size="sm"
                        color={
                          kitten.disposition.type === 'TRAINING' ? 'blue' :
                          kitten.disposition.type === 'SALE' ? 'green' :
                          'gray'
                        }
                      >
                        {kitten.disposition.type === 'TRAINING' ? 'ğŸ“ é¤Šæˆä¸­' :
                         kitten.disposition.type === 'SALE' ? 'ğŸ’° å‡ºè·æ¸ˆ' :
                         'ğŸŒˆ æ­»äº¡'}
                      </Badge>
                    )}
                  </Stack>
                  <ActionIcon
                    color="red"
                    variant="light"
                    onClick={() => removeKitten(index)}
                    mt="md"
                  >
                    <IconTrash size={16} />
                  </ActionIcon>
                </Flex>
              </Card>
            ))}

            {kittens.length === 0 && (
              <Text ta="center" c="dimmed" py="xl">
                å­çŒ«ãŒã„ã¾ã›ã‚“ã€‚é ­æ•°ã‚’å…¥åŠ›ã—ã¦ç™»éŒ²ã—ã¦ãã ã•ã„ã€‚
              </Text>
            )}
          </Stack>
        </Box>
        )}

        {/* å‡¦é‡è¨­å®šã‚¿ãƒ– */}
        {activeTab === 'disposition' && (
          <Box pt="md">
            <Stack gap="md">
            <Text size="sm" c="dimmed">
              é¸æŠã—ãŸå­çŒ«ã«å‡¦é‡ã‚’ä¸€æ‹¬è¨­å®šã§ãã¾ã™
            </Text>
            <Text size="xs" c="dimmed">
              é¸æŠä¸­: {kittens.filter(k => k.isSelected).length}é ­
            </Text>

            {/* å‡¦é‡ã‚¿ã‚¤ãƒ—é¸æŠ */}
            <Select
              label="å‡¦é‡ã‚’é¸æŠã—ã¦ãã ã•ã„"
              placeholder="å‡¦é‡ã‚’é¸æŠ"
              value={dispositionDetails.type || ''}
              onChange={(value) => setDispositionDetails({ type: value as 'TRAINING' | 'SALE' | 'DECEASED' })}
              data={[
                { value: 'TRAINING', label: 'ğŸ“ é¤Šæˆä¸­' },
                { value: 'SALE', label: 'ğŸ’° å‡ºè·æ¸ˆ' },
                { value: 'DECEASED', label: 'ğŸŒˆ æ­»äº¡' },
              ]}
            />

            {/* é¤Šæˆä¸­ã®å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ */}
            {dispositionDetails.type === 'TRAINING' && (
              <Stack gap="sm">
                <TextInput
                  label="é¤Šæˆé–‹å§‹æ—¥"
                  type="date"
                  value={dispositionDetails.trainingStartDate || ''}
                  onChange={(e) => setDispositionDetails(prev => ({ ...prev, trainingStartDate: e.target.value }))}
                  required
                />
              </Stack>
            )}

            {/* å‡ºè·æ¸ˆã®å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ */}
            {dispositionDetails.type === 'SALE' && (
              <Stack gap="sm">
                <TextInput
                  label="å‡ºè·å…ˆ"
                  placeholder="å‡ºè·å…ˆåã‚’å…¥åŠ›"
                  value={dispositionDetails.buyer || ''}
                  onChange={(e) => setDispositionDetails(prev => ({ ...prev, buyer: e.target.value }))}
                  required
                />
                <NumberInput
                  label="ä¾¡æ ¼"
                  placeholder="ä¾¡æ ¼ã‚’å…¥åŠ›"
                  value={dispositionDetails.price || 0}
                  onChange={(value) => setDispositionDetails(prev => ({ ...prev, price: Number(value) }))}
                  min={0}
                  required
                />
                <TextInput
                  label="å‡ºè·æ—¥"
                  type="date"
                  value={dispositionDetails.saleDate || ''}
                  onChange={(e) => setDispositionDetails(prev => ({ ...prev, saleDate: e.target.value }))}
                  required
                />
              </Stack>
            )}

            {/* æ­»äº¡ã®å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ */}
            {dispositionDetails.type === 'DECEASED' && (
              <Stack gap="sm">
                <TextInput
                  label="æ­»äº¡æ—¥"
                  type="date"
                  value={dispositionDetails.deathDate || ''}
                  onChange={(e) => setDispositionDetails(prev => ({ ...prev, deathDate: e.target.value }))}
                  required
                />
                <TextInput
                  label="æ­»äº¡ç†ç”±"
                  placeholder="æ­»äº¡ç†ç”±ã‚’å…¥åŠ›"
                  value={dispositionDetails.deathReason || ''}
                  onChange={(e) => setDispositionDetails(prev => ({ ...prev, deathReason: e.target.value }))}
                />
              </Stack>
            )}

            {/* é©ç”¨ãƒœã‚¿ãƒ³ */}
            <Button
              fullWidth
              onClick={() => dispositionDetails.type && applyDispositionToSelected(dispositionDetails.type)}
              disabled={!dispositionDetails.type || kittens.filter(k => k.isSelected).length === 0}
            >
              é¸æŠã—ãŸå­çŒ«ã«é©ç”¨
            </Button>
          </Stack>
        </Box>
        )}
        </TabsSection>
      ),
    },
    {
      content: (
        <Group justify="flex-end">
          <Button
            variant="outline"
            leftSection={<IconX size={16} />}
            onClick={handleClose}
          >
            ã‚­ãƒ£ãƒ³ã‚»ãƒ«
          </Button>
          <Button
            leftSection={<IconDeviceFloppy size={16} />}
            onClick={handleSave}
            loading={createCatMutation.isPending || updateCatMutation.isPending}
            disabled={!selectedMotherId || kittens.length === 0}
          >
            ä¿å­˜
          </Button>
        </Group>
      ),
    },
  ];

  return (
    <UnifiedModal
      opened={opened}
      onClose={handleClose}
      title="å­çŒ«ç®¡ç†"
      size="xl"
      styles={{
        body: { maxHeight: '70vh', overflowY: 'auto' },
      }}
      sections={sections}
    />
  );
}
````

## File: frontend/src/components/TabsSection.tsx
````typescript
'use client';

/**
 * æ±ç”¨ã‚¿ãƒ–ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ãƒšãƒ¼ã‚¸ã®ã‚¿ãƒ–ãƒ‡ã‚¶ã‚¤ãƒ³ã‚’ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“ã§çµ±ä¸€
 */

import { Tabs, Group, Badge, type TabsProps } from '@mantine/core';

export interface TabDefinition {
  /** ã‚¿ãƒ–ã®å€¤ */
  value: string;
  /** ã‚¿ãƒ–ã®ãƒ©ãƒ™ãƒ« */
  label: string;
  /** ã‚¿ãƒ–ã®å·¦ã«è¡¨ç¤ºã™ã‚‹ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰ */
  icon?: React.ReactNode;
  /** ãƒãƒƒã‚¸ã«è¡¨ç¤ºã™ã‚‹ã‚«ã‚¦ãƒ³ãƒˆï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰ */
  count?: number;
  /** ãƒãƒƒã‚¸ã®è‰²ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 'blue'ï¼‰ */
  badgeColor?: string;
  /** ã‚¿ãƒ–ãŒç„¡åŠ¹ã‹ã©ã†ã‹ */
  disabled?: boolean;
}

export interface TabsSectionProps extends Omit<TabsProps, 'value' | 'onChange'> {
  /** ç¾åœ¨ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¿ãƒ–ã®å€¤ */
  value: string | null;
  /** ã‚¿ãƒ–å€¤å¤‰æ›´æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
  onChange: (value: string) => void;
  /** ã‚¿ãƒ–å®šç¾©ã®é…åˆ— */
  tabs: TabDefinition[];
  /** ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒãƒƒã‚¸ã‚«ãƒ©ãƒ¼ */
  defaultBadgeColor?: string;
}

/**
 * æ±ç”¨ã‚¿ãƒ–ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * ã‚®ãƒ£ãƒ©ãƒªãƒ¼ãƒšãƒ¼ã‚¸ã¨åŒã˜ã‚¹ã‚¿ã‚¤ãƒ«ã§ã€è¤‡æ•°ã®ãƒšãƒ¼ã‚¸ã§ä½¿ç”¨å¯èƒ½
 *
 * @example
 * ```tsx
 * <TabsSection
 *   value={activeTab}
 *   onChange={setActiveTab}
 *   tabs={[
 *     { value: 'schedule', label: 'ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«', icon: <IconCalendar size={16} />, count: 5 },
 *     { value: 'pregnancy', label: 'å¦Šå¨ ', icon: <IconHeart size={16} /> },
 *   ]}
 * />
 * ```
 */
export function TabsSection({
  value,
  onChange,
  tabs,
  defaultBadgeColor = 'blue',
  ...tabsProps
}: TabsSectionProps) {
  return (
    <Tabs
      value={value || tabs[0]?.value}
      onChange={(val) => {
        if (val) {
          onChange(val);
        }
      }}
      {...tabsProps}
    >
      <Tabs.List>
        {tabs.map((tab) => (
          <Tabs.Tab
            key={tab.value}
            value={tab.value}
            leftSection={tab.icon}
            disabled={tab.disabled}
          >
            <Group gap="xs">
              <span>{tab.label}</span>
              {tab.count !== undefined && (
                <Badge 
                  size="xs" 
                  variant="light" 
                  color={tab.badgeColor || defaultBadgeColor}
                >
                  {tab.count}
                </Badge>
              )}
            </Group>
          </Tabs.Tab>
        ))}
      </Tabs.List>

      {/* Tabs.Panel ã¯å‘¼ã³å‡ºã—å´ã§ä½¿ç”¨ */}
      {tabsProps.children}
    </Tabs>
  );
}
````

## File: frontend/src/components/common/UnifiedModal.tsx
````typescript
'use client';

import { Modal, type ModalProps, Stack, Divider } from '@mantine/core';
import { type ReactNode } from 'react';

/**
 * ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚»ã‚¯ã‚·ãƒ§ãƒ³å®šç¾©
 */
export interface ModalSection {
  /** ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ©ãƒ™ãƒ«ï¼ˆDividerã«è¡¨ç¤ºï¼‰ */
  label?: string;
  /** ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ */
  content: ReactNode;
  /** ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ä¸€æ„ãªã‚­ãƒ¼ï¼ˆå‹•çš„ã«è¿½åŠ ãƒ»å‰Šé™¤ãƒ»ä¸¦ã³æ›¿ãˆã‚’è¡Œã†å ´åˆã«æ¨å¥¨ï¼‰ */
  key?: string;
}

/**
 * çµ±ä¸€ã•ã‚ŒãŸãƒ¢ãƒ¼ãƒ€ãƒ«ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 * 
 * å…¨ãƒšãƒ¼ã‚¸ã§ä¸€è²«ã—ãŸè¦–èªæ€§ã®é«˜ã„ãƒ¢ãƒ¼ãƒ€ãƒ«ãƒ‡ã‚¶ã‚¤ãƒ³ã‚’æä¾›ã—ã¾ã™ã€‚
 * - ç™½ã„ä¸é€æ˜èƒŒæ™¯
 * - æ˜ç¢ºãªæ ç·š
 * - é©åˆ‡ãªãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã¨é–“éš”
 * - åŠé€æ˜ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤
 * 
 * ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ©Ÿèƒ½:
 * - `sections`ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã§ã‚»ã‚¯ã‚·ãƒ§ãƒ³åˆ†å‰²ã•ã‚ŒãŸã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’è¡¨ç¤º
 * - å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³é–“ã«ãƒ©ãƒ™ãƒ«ä»˜ãDividerã‚’è‡ªå‹•æŒ¿å…¥
 * - `children`ã¨`sections`ã¯ç›¸äº’æ’ä»–çš„ï¼ˆã©ã¡ã‚‰ã‹ä¸€æ–¹ã®ã¿ä½¿ç”¨å¯èƒ½ï¼‰
 */
export type UnifiedModalProps = Omit<ModalProps, 'children'> & {
  /** ãƒ¢ãƒ¼ãƒ€ãƒ«å†…ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã«ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’è¿½åŠ ã™ã‚‹ã‹ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: trueï¼‰ */
  addContentPadding?: boolean;
} & (
  | {
      /** ãƒ¢ãƒ¼ãƒ€ãƒ«ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ */
      children: ReactNode;
      /** ã‚»ã‚¯ã‚·ãƒ§ãƒ³åˆ†å‰²ã•ã‚ŒãŸã‚³ãƒ³ãƒ†ãƒ³ãƒ„ï¼ˆchildrenã¨ç›¸äº’æ’ä»–ï¼‰ */
      sections?: never;
    }
  | {
      /** ãƒ¢ãƒ¼ãƒ€ãƒ«ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ */
      children?: never;
      /** ã‚»ã‚¯ã‚·ãƒ§ãƒ³åˆ†å‰²ã•ã‚ŒãŸã‚³ãƒ³ãƒ†ãƒ³ãƒ„ï¼ˆchildrenã¨ç›¸äº’æ’ä»–ï¼‰ */
      sections: ModalSection[];
    }
);

export function UnifiedModal({
  children,
  sections,
  addContentPadding = true,
  ...modalProps
}: UnifiedModalProps) {
  // sectionsãŒæä¾›ã•ã‚ŒãŸå ´åˆã¯ã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³é–“ã«Dividerã‚’æŒ¿å…¥ã—ã¦ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
  const renderContent = () => {
    if (sections) {
      const sectionNodes = sections.map((section, index) => (
        <div key={section.key ?? index}>
          {index > 0 && (
            <Divider
              label={section.label}
              labelPosition="center"
              mb="md"
            />
          )}
          {index === 0 && section.label && (
            <Divider
              label={section.label}
              labelPosition="center"
              mb="md"
            />
          )}
          {addContentPadding ? (
            <Stack gap="md">
              {section.content}
            </Stack>
          ) : (
            section.content
          )}
        </div>
      ));

      if (addContentPadding) {
        return <Stack gap="md">{sectionNodes}</Stack>;
      }

      return <>{sectionNodes}</>;
    }

    // childrenã®å ´åˆã¯å¾“æ¥ã®å‹•ä½œã‚’ç¶­æŒ
    if (addContentPadding) {
      return <Stack gap="md">{children}</Stack>;
    }
    return children;
  };

  return (
    <Modal
      {...modalProps}
      overlayProps={{
        ...modalProps.overlayProps,
        backgroundOpacity: 0.55,
        blur: 3,
      }}
      styles={{
        content: {
          backgroundColor: '#ffffff',
          borderRadius: '8px',
          border: '1px solid #dee2e6',
          color: '#212529',
          boxShadow: '0 8px 24px rgba(0, 0, 0, 0.15)',
        },
        header: {
          backgroundColor: '#ffffff',
          borderBottom: '1px solid #e9ecef',
          color: '#212529',
        },
        body: {
          backgroundColor: '#ffffff',
          color: '#212529',
          padding: addContentPadding ? '16px' : '0',
        },
        title: {
          color: '#212529',
          fontWeight: 600,
        },
        ...modalProps.styles,
      }}
    >
      {renderContent()}
    </Modal>
  );
}
````

## File: frontend/src/app/kittens/page.tsx
````typescript
'use client';

import { Box, Title, Text } from '@mantine/core';

export default function KittensPage() {
  return (
  <Box style={{ minHeight: '100vh', backgroundColor: 'var(--background-base)', padding: '2rem' }}>
      <Title order={1} c="blue" mb="md">å­çŒ«ç®¡ç†</Title>
      <Text>ç”Ÿã¾ã‚ŒãŸå­çŒ«ã®è¨˜éŒ²ã‚„ç®¡ç†ã‚’è¡Œã†ãƒšãƒ¼ã‚¸ã§ã™ï¼ˆä»Šå¾Œå®Ÿè£…äºˆå®šï¼‰ã€‚</Text>
    </Box>
  );
}
````

## File: frontend/src/app/providers.tsx
````typescript
'use client'

import { MantineProvider, type MantineColorsTuple, type MantineThemeOverride } from '@mantine/core'
import { ModalsProvider } from '@mantine/modals'
import { useBootstrapAuth } from '@/lib/auth/useBootstrapAuth'
import { QueryClientProvider } from '@/lib/api/query-client'
import { Notifications } from '@mantine/notifications'
import { PageHeaderProvider } from '@/lib/contexts/page-header-context'
import '@mantine/notifications/styles.css'

export function Providers({ children }: { children: React.ReactNode }) {
  // èªè¨¼ã‚’å…ˆã«åˆæœŸåŒ–
  useBootstrapAuth()

  // Define brand palette explicitly to satisfy MantineColorsTuple type (10 shades, light -> dark)
  const brand: MantineColorsTuple = [
    '#eff6ff',
    '#dbeafe',
    '#bfdbfe',
    '#93c5fd',
    '#60a5fa',
    '#3b82f6',
    '#2563eb',
    '#1d4ed8',
    '#1e40af',
    '#1e3a8a',
  ]

  const theme: MantineThemeOverride = {
    primaryColor: 'brand',
    colors: { brand },
    fontFamily: 'Inter, "Noto Sans JP", "Segoe UI", sans-serif',
    headings: {
      fontFamily: 'Inter, "Noto Sans JP", "Segoe UI", sans-serif',
      fontWeight: '700',
    },
    defaultRadius: 'md',
    shadows: {
      xs: '0 1px 3px rgba(0,0,0,0.05)',
      sm: '0 4px 12px rgba(31, 38, 135, 0.05)',
      md: '0 8px 24px rgba(31, 38, 135, 0.08)',
      lg: '0 12px 32px rgba(31, 38, 135, 0.12)',
      xl: '0 16px 48px rgba(31, 38, 135, 0.15)',
    },
    spacing: {
      xs: '8px',
      sm: '12px',
      md: '16px',
      lg: '24px',
      xl: '32px',
    },
    components: {
      Button: {
        defaultProps: {
          radius: 'md',
          size: 'md',
        },
        styles: {
          root: {
            fontWeight: 600,
            transition: 'all 0.2s ease',
            height: '44px',
            padding: '0 16px',
          },
        },
      },
      ActionIcon: {
        defaultProps: {
          radius: 'md',
        },
        styles: {
          root: {
            transition: 'all 0.2s ease',
            color: 'var(--button-icon-color)',
          },
        },
      },
      Container: {
        defaultProps: {
          px: 0,
          fluid: true,
          size: 'var(--container-max-width)',
        },
        styles: {
          root: {
            maxWidth: 'var(--container-max-width)',
            marginLeft: 'auto',
            marginRight: 'auto',
            paddingLeft: 0,
            paddingRight: 0,
          },
        },
      },
      Badge: {
        defaultProps: {
          radius: 'md',
          variant: 'light',
        },
        styles: {
          root: {
            fontWeight: 600,
          },
        },
      },
      Alert: {
        styles: {
          root: {
            backgroundColor: 'var(--bg-surface)',
            border: '1px solid var(--border-primary)',
            borderRadius: '8px',
          },
          title: {
            color: 'var(--text-primary)',
          },
          message: {
            color: 'var(--text-secondary)',
          },
        },
      },
      Notification: {
        styles: {
          root: {
            backgroundColor: 'var(--bg-surface)',
            border: '1px solid var(--border-primary)',
            borderRadius: '8px',
            color: 'var(--text-primary)',
          },
        },
      },
      Input: {
        styles: {
          input: {
            backgroundColor: '#f8f9fa !important',
            borderRadius: '8px !important',
            border: '1px solid #dee2e6 !important',
            transition: 'all 0.2s ease',
          },
        },
      },
      Select: {
        styles: {
          input: {
            backgroundColor: '#f8f9fa !important',
            borderRadius: '8px !important',
            border: '1px solid #dee2e6 !important',
          },
          dropdown: {
            backgroundColor: '#fff !important',
            borderRadius: '8px !important',
            border: '1px solid var(--border-primary) !important',
          },
        },
      },
      Slider: {
        defaultProps: {
          radius: 'md',
        },
        styles: {
          root: {
            paddingTop: '12px !important',
            paddingBottom: '12px !important',
          },
          track: {
            backgroundColor: 'var(--slider-track) !important',
            height: '6px !important',
            borderRadius: '3px !important',
          },
          bar: {
            backgroundColor: 'var(--accent) !important',
          },
          thumb: {
            width: '20px !important',
            height: '20px !important',
            border: '2px solid var(--accent) !important',
            backgroundColor: '#fff !important',
            borderRadius: '50% !important',
            boxShadow: '0 1px 3px rgba(0,0,0,0.12)',
          },
        },
      },
      Switch: {
        defaultProps: {
          radius: 'xl',
        },
        styles: {
          track: {
            backgroundColor: 'var(--switch-bg) !important',
            border: '1px solid var(--border-subtle) !important',
            borderRadius: '32px !important',
            transition: 'all 0.2s ease !important',
            height: '24px !important',
            width: '44px !important',
            cursor: 'pointer',
          },
          thumb: {
            backgroundColor: 'var(--switch-thumb) !important',
            borderRadius: '50% !important',
            width: '18px !important',
            height: '18px !important',
          },
        },
      },
      Checkbox: {
        styles: {
          input: {
            backgroundColor: '#f8f9fa !important',
            borderRadius: '4px !important',
            border: '1px solid #dee2e6 !important',
          },
          icon: {
            color: 'var(--accent) !important',
          },
        },
      },
      Paper: {
        defaultProps: {
          radius: 'md',
        },
      },
      Card: {
        defaultProps: {
          radius: 'md',
        },
      },
      Modal: {
        defaultProps: {
          radius: 'md',
          overlayProps: {
            backgroundOpacity: 0.55,
            blur: 3,
          },
        },
        styles: {
          root: {
            // Modal ãƒ«ãƒ¼ãƒˆ
          },
          overlay: {
            backgroundColor: 'rgba(0, 0, 0, 0.55)',
          },
          content: {
            backgroundColor: '#ffffff',
            borderRadius: '8px',
            border: '1px solid #dee2e6',
            color: '#212529',
            boxShadow: '0 8px 24px rgba(0, 0, 0, 0.15)',
          },
          header: {
            backgroundColor: '#ffffff',
            borderBottom: '1px solid #e9ecef',
            color: '#212529',
          },
          body: {
            backgroundColor: '#ffffff',
            color: '#212529',
          },
        },
      },
      Tabs: {
        defaultProps: {
          variant: 'default',
        },
        styles: {
          root: {
            // æ¨ªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯¾å¿œ
          },
          tab: {
            fontWeight: 500,
            transition: 'all 0.2s ease',
            border: 'none',
            backgroundColor: 'transparent',
            padding: '12px 16px',
            whiteSpace: 'nowrap', // ãƒ†ã‚­ã‚¹ãƒˆã‚’æŠ˜ã‚Šè¿”ã•ãªã„
            flexShrink: 0, // ç¸®å°ã‚’é˜²ã
            
            '&:hover': {
              backgroundColor: 'rgba(59, 130, 246, 0.05)',
            },
          },
          list: {
            borderBottom: 'none',
            flexWrap: 'nowrap',
            overflowX: 'auto',
            overflowY: 'hidden',
            WebkitOverflowScrolling: 'touch',
            scrollbarWidth: 'thin',
            '&::-webkit-scrollbar': {
              height: '4px',
            },
            '&::-webkit-scrollbar-thumb': {
              backgroundColor: 'rgba(0, 0, 0, 0.2)',
              borderRadius: '2px',
            },
          },
        },
      }
    },
  }

  return (
    <QueryClientProvider>
      <MantineProvider defaultColorScheme="light" theme={theme}>
        <ModalsProvider>
          <PageHeaderProvider>
            <Notifications position="top-right" zIndex={1000} />
            {children}
          </PageHeaderProvider>
        </ModalsProvider>
      </MantineProvider>
    </QueryClientProvider>
  )
}
````

## File: frontend/package.json
````json
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev -p 3000 -H 0.0.0.0",
    "build": "next build",
    "analyze": "ANALYZE=true next build",
    "start": "next start",
    "lint": "eslint --max-warnings 0 .",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "type-check": "tsc --noEmit",
    "generate:api-types": "node scripts/generate-api-types.mjs"
  },
  "dependencies": {
    "@dnd-kit/core": "^6.3.1",
    "@dnd-kit/sortable": "^10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "@fullcalendar/core": "^6.1.19",
    "@fullcalendar/daygrid": "^6.1.19",
    "@fullcalendar/interaction": "^6.1.19",
    "@fullcalendar/react": "^6.1.19",
    "@hookform/resolvers": "^3.10.0",
    "@mantine/core": "^8.3.10",
    "@mantine/dates": "^8.3.10",
    "@mantine/dropzone": "^8.3.13",
    "@mantine/form": "^8.3.10",
    "@mantine/hooks": "^8.3.10",
    "@mantine/modals": "^8.3.10",
    "@mantine/notifications": "^8.3.10",
    "@sentry/nextjs": "^10.38.0",
    "@tabler/icons-react": "^3.34.1",
    "@tanstack/react-query": "^5.90.12",
    "date-fns": "^4.1.0",
    "dayjs": "^1.11.13",
    "framer-motion": "^12.23.26",
    "next": "^16.1.6",
    "openapi-typescript": "^7.9.1",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "react-hook-form": "^7.68.0",
    "zod": "^3.25.76",
    "zustand": "^5.0.9"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.3.3",
    "@next/bundle-analyzer": "^16.1.6",
    "@next/eslint-plugin-next": "^16.1.6",
    "@tailwindcss/postcss": "^4.1.18",
    "@tanstack/react-query-devtools": "^5.90.12",
    "@testing-library/jest-dom": "^6.6.4",
    "@testing-library/react": "^16.0.1",
    "@testing-library/user-event": "^14.6.1",
    "@types/jest": "^29.5.14",
    "@types/node": "^20.19.25",
    "@types/react": "^19.2.7",
    "@types/react-dom": "^19",
    "@typescript-eslint/eslint-plugin": "^8.49.0",
    "@typescript-eslint/parser": "^8.49.0",
    "eslint": "^9",
    "eslint-config-next": "^16.1.6",
    "eslint-config-prettier": "^9.1.2",
    "eslint-import-resolver-typescript": "^4.4.4",
    "eslint-plugin-import-x": "^4.16.1",
    "eslint-plugin-react-hooks": "^5.2.0",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "tailwindcss": "^4.1.18",
    "typescript": "^5",
    "typescript-eslint": "^8.49.0"
  }
}
````

## File: frontend/src/app/globals.css
````css
:root {
  /* Common Base Tokens */
  --golden-ratio: 1.618;
  --container-max-width: 1200px;
  --section-gap: 24px;
  --layout-px: 24px; /* Unified horizontal padding for both header and content */
  --accent: #3b82f6;
  
  /* Responsive Breakpoints (Mobile First) */
  --breakpoint-xs: 0px;
  --breakpoint-sm: 576px;
  --breakpoint-md: 768px;
  --breakpoint-lg: 992px;
  --breakpoint-xl: 1200px;
  --breakpoint-xxl: 1400px;
  
  /* Button Design Tokens */
  --button-primary-bg: var(--accent);
  --button-primary-text: #ffffff;
  --button-primary-radius: var(--radius-base, 12px);
  --button-primary-height: 42px;
  --button-icon-size: 36px;
  --button-icon-color: var(--text-secondary);
  --button-icon-hover: var(--accent);
  
  color-scheme: light;
}

/* --- Theme 0: Classic Default (Standard Mantine Design) --- */
.theme-default {
  /* Base Colors: Clean and Simple */
  --bg-base: #f8f9fa;
  --bg-surface: #ffffff;
  --bg-black: #000000;
  --bg-white: #ffffff;
  --bg-gray: #f1f3f5;
  
  /* Borders: Subtle */
  --border-primary: #dee2e6;
  --border-subtle: #e9ecef;
  --border-width: 1px;
  
  /* Text Colors */
  --text-primary: #212529;
  --text-secondary: #495057;
  --text-muted: #868e96;
  
  /* Accent: Blue */
  --accent: #228be6;
  --accent-soft: #e7f5ff;
  
  /* Status Colors */
  --status-success: #40c057;
  --status-warning: #fab005;
  --status-error: #fa5252;
  --status-info: #228be6;
  
  /* Effects */
  --glass-blur: 0px;
  --glass-bg: #ffffff;
  --glass-bg-hover: #f8f9fa;
  --glass-border: #dee2e6;
  --shadow-ethereal: 0 1px 3px rgba(0, 0, 0, 0.12);
  --shadow-ethereal-hover: 0 4px 6px rgba(0, 0, 0, 0.15);
  --radius-base: 8px;
  
  /* Form Elements */
  --input-bg: #ffffff;
  --slider-track: #e9ecef;
  --switch-bg: #e9ecef;
  --switch-thumb: #ffffff;
  
  /* Button Overrides */
  --button-primary-radius: 8px;
  --button-icon-color: #495057;
}

html,
body {
  height: 100%;
  width: 100%;
  margin: 0;
  padding: 0;
  overflow-x: hidden;
}

body {
  color: var(--text-primary);
  font-family: "Inter", "Noto Sans JP", "Segoe UI", sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  transition: background 0.5s ease, color 0.3s ease;
  background-color: var(--bg-base);
}

/* Glassmorphism Utility */
.glass-effect {
  background: var(--glass-bg, transparent);
  backdrop-filter: blur(var(--glass-blur, 0px));
  -webkit-backdrop-filter: blur(var(--glass-blur, 0px));
  border: 1px solid var(--glass-border, transparent);
  box-shadow: var(--shadow-ethereal);
  box-shadow: var(--shadow-ethereal), var(--light-reflection, none);
}

.floating-island {
  max-width: var(--container-max-width);
  margin: 0 auto;
  padding: var(--section-gap);
  width: 100%;
}

* {
  box-sizing: border-box;
}

a {
  color: inherit;
  text-decoration: none;
  transition: all 0.2s ease;
}

h1, h2, h3, h4, h5, h6 {
  color: var(--text-primary);
  font-weight: 700;
  letter-spacing: -0.02em;
}

/* Mantine Overrides */
.mantine-Paper-root,
.mantine-Card-root {
  background: var(--glass-bg, var(--bg-surface)) !important;
  backdrop-filter: blur(var(--glass-blur, 0px)) !important;
  -webkit-backdrop-filter: blur(var(--glass-blur, 0px)) !important;
  border: 1px solid var(--glass-border, var(--border-subtle, transparent)) !important;
  box-shadow: var(--shadow-ethereal) !important;
  border-radius: var(--radius-base, 16px) !important;
  transition: transform 0.3s ease, box-shadow 0.3s ease !important;
  color: var(--text-primary) !important;
}

.mantine-AppShell-header,
.mantine-AppShell-navbar,
.mantine-AppShell-footer {
  background: var(--glass-bg, var(--bg-surface)) !important;
  backdrop-filter: blur(var(--glass-blur, 0px)) !important;
  -webkit-backdrop-filter: blur(var(--glass-blur, 0px)) !important;
  border-color: var(--glass-border, var(--border-subtle, transparent)) !important;
}

/* Responsive Layout Padding (Mobile First) */
@media (max-width: 575px) {
  :root {
    --layout-px: 16px;
    --section-gap: 16px;
  }
}

@media (min-width: 576px) and (max-width: 767px) {
  :root {
    --layout-px: 20px;
    --section-gap: 20px;
  }
}
/* Tabs Active State Styling */
.mantine-Tabs-tab[aria-selected="true"] {
  border-bottom: 3px solid #3b82f6 !important;
  color: #3b82f6 !important;
  fontWeight: 600 !important;
  background-color: transparent !important;
}

.mantine-Tabs-tab[aria-selected="false"] {
  border-bottom: 3px solid transparent !important;
  color: var(--text-secondary) !important;
  fontWeight: 500 !important;
  background-color: transparent !important;
}

/* Modal Styling - Ensure visibility */
.mantine-Modal-root {
  z-index: 200 !important;
}

.mantine-Modal-overlay {
  background-color: rgba(0, 0, 0, 0.55) !important;
  opacity: 1 !important;
  z-index: 200 !important;
}

/* Mantine Modal content - æœ€ã‚‚é‡è¦ */
.mantine-Modal-content {
  background-color: #ffffff !important;
  color: #212529 !important;
  border-radius: 8px !important;
  border: 1px solid #dee2e6 !important;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15) !important;
  z-index: 201 !important;
}

/* Modal header */
.mantine-Modal-header {
  background-color: #ffffff !important;
  border-bottom: 1px solid #e9ecef !important;
  color: #212529 !important;
}

/* Modal body */
.mantine-Modal-body {
  background-color: #ffffff !important;
  color: #212529 !important;
}

/* Modal title */
.mantine-Modal-title {
  color: #212529 !important;
  font-weight: 600 !important;
}

/* å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®æ ç·šã‚’æ˜ç¢ºã« */
.mantine-Modal-body .mantine-Input-input,
.mantine-Modal-body .mantine-Select-input,
.mantine-Modal-body .mantine-Textarea-input,
.mantine-Modal-body .mantine-DateInput-input,
.mantine-Modal-body .mantine-TimeInput-input,
.mantine-Modal-body .mantine-NumberInput-input,
.mantine-Modal-body .mantine-PasswordInput-input,
.mantine-Modal-body .mantine-ColorInput-input,
.mantine-Modal-content .mantine-Input-input,
.mantine-Modal-content .mantine-Select-input,
.mantine-Modal-content .mantine-Textarea-input,
.mantine-Modal-content .mantine-DateInput-input,
.mantine-Modal-content .mantine-TimeInput-input,
.mantine-Modal-content .mantine-NumberInput-input,
.mantine-Modal-content .mantine-PasswordInput-input,
.mantine-Modal-content .mantine-ColorInput-input {
  border: 1px solid #dee2e6 !important;
  background-color: #f8f9fa !important;
}

@media (min-width: 768px) {
  :root {
    --layout-px: 24px;
    --section-gap: 24px;
  }
}

/* Container width responsive adjustments */
@media (max-width: 1199px) {
  :root {
    --container-max-width: 100%;
  }
}

@media (min-width: 1200px) {
  :root {
    --container-max-width: 1200px;
  }
}
````

## File: package.json
````json
{
  "name": "appproject",
  "version": "1.0.0",
  "description": "Cat Management System - Development Scripts",
  "scripts": {
    "predev": "kill-port 3004 3000 || echo ok",
    "dev": "run-p backend:dev frontend:dev:wait prisma:sync",
    "dev:full": "run-p backend:dev frontend:dev:wait prisma:sync db:studio",
    "dev:low-memory": "run-p backend:dev:low-memory frontend:dev:wait:low-memory prisma:sync:low-memory",
    "dev:no-prisma-sync": "run-p backend:dev frontend:dev:wait",
    "start": "npm run dev",
    "start:dev": "npm run dev",
    "build": "run-s backend:build frontend:build",
    "backend:dev": "cross-env PORT=3004 pnpm --filter backend run start:dev",
    "backend:dev:low-memory": "cross-env PORT=3004 NODE_OPTIONS=--max-old-space-size=1024 pnpm --filter backend run start:dev",
    "backend:dev:clean": "./scripts/kill-backend.sh 3004 || true && ./scripts/preflight-backend.sh && pnpm run backend:dev",
    "backend:install": "pnpm --filter backend install",
    "backend:lint": "pnpm --filter backend run lint",
    "backend:build": "pnpm --filter backend run build",
    "db:migrate": "pnpm --filter backend run prisma:migrate",
    "db:deploy": "pnpm --filter backend run prisma:deploy",
    "db:generate": "pnpm --filter backend run prisma:generate",
    "db:seed": "pnpm --filter backend run seed",
    "db:studio": "pnpm --filter backend run prisma:studio",
    "prisma:studio": "pnpm --filter backend run prisma:studio",
    "prisma:sync": "pnpm --filter backend run prisma:sync:watch",
    "prisma:sync:low-memory": "cross-env NODE_OPTIONS=--max-old-space-size=512 pnpm --filter backend run prisma:sync:watch",
    "frontend:install": "pnpm --filter frontend install",
    "frontend:dev:wait": "wait-on tcp:3004 && cross-env PORT=3000 pnpm --filter frontend run dev",
    "frontend:dev:wait:low-memory": "wait-on tcp:3004 && cross-env PORT=3000 NODE_OPTIONS=--max-old-space-size=1536 pnpm --filter frontend run dev",
    "frontend:build": "pnpm --filter frontend run build",
    "frontend:start": "pnpm --filter frontend run start",
    "frontend:lint": "pnpm --filter frontend run lint",
    "lint": "run-p lint:*",
    "lint:root": "eslint . --ext .js,.mjs,.ts --fix",
    "lint:backend": "npm run backend:lint",
    "lint:frontend": "npm run frontend:lint",
    "test:health": "curl -s http://localhost:3004/health",
    "test:api": "curl -s http://localhost:3004/api/v1/pedigrees",
    "test:e2e": "pnpm --filter backend run test:e2e -- --passWithNoTests",
    "api:smoke": "(curl -sS -X POST http://localhost:3004/api/v1/auth/register -H 'Content-Type: application/json' -d '{\"email\":\"dev1@example.com\",\"password\":\"Passw0rd!\"}' || true) && TOKEN=$(curl -sS -X POST http://localhost:3004/api/v1/auth/login -H 'Content-Type: application/json' -d '{\"email\":\"dev1@example.com\",\"password\":\"Passw0rd!\"}' | sed -n 's/.*\"access_token\":\"\\([^\\\"]*\\)\".*/\\1/p'); curl -sS -X POST http://localhost:3004/api/v1/tags -H \"Authorization: Bearer $TOKEN\" -H 'Content-Type: application/json' -d '{\"name\":\"indoor\",\"color\":\"#10B981\"}'",
    "dev:stable": "node ./scripts/start-dev-stable.mjs",
    "dev:stop": "./scripts/stop-dev.sh",
    "dev:health": "./scripts/health-check.sh",
    "dev:memory-check": "node ./scripts/check-memory.mjs",
    "setup": "./scripts/setup-dev.sh",
    "diagnose": "./scripts/diagnose.sh",
    "help": "echo \"Available commands: dev, dev:stable, dev:stop, dev:health, dev:low-memory, dev:memory-check, backend:*, db:*, test:*, frontend:*, setup, diagnose\"",
    "install:all": "pnpm install",
    "generate-secrets": "tsx ./scripts/generate-secrets.ts",
    "docker:dev": "docker compose -f docker-compose.dev.yml up",
    "docker:dev:build": "docker compose -f docker-compose.dev.yml up --build",
    "docker:dev:down": "docker compose -f docker-compose.dev.yml down",
    "docker:dev:clean": "docker compose -f docker-compose.dev.yml down -v",
    "build:parallel": "pnpm --parallel --filter './backend' --filter './frontend' run build",
    "test:changed": "pnpm --filter './backend' run test:changed"
  },
  "devDependencies": {
    "@eslint/js": "^9",
    "@types/node": "^22",
    "@typescript-eslint/eslint-plugin": "^8.49.0",
    "@typescript-eslint/parser": "^8.49.0",
    "cross-env": "^10.0.0",
    "eslint": "^9",
    "kill-port": "^2.0.1",
    "npm-run-all": "^4.1.5",
    "prettier": "^3.7.4",
    "supabase": "^2.75.4",
    "tsx": "^4.21.0",
    "typescript": "^5",
    "typescript-eslint": "^8.49.0",
    "wait-on": "^9.0.0"
  },
  "engines": {
    "node": ">=20"
  },
  "private": true,
  "pnpm": {
    "overrides": {
      "axios": ">=1.12.0",
      "baseline-browser-mapping": "2.9.19",
      "brace-expansion": ">=2.0.2 <3.0.0",
      "cookie": ">=1.0.0",
      "cross-spawn": ">=7.0.6",
      "diff": ">=4.0.4",
      "dotenv": ">=16.6.1",
      "express": ">=4.21.2",
      "fast-xml-parser": ">=5.3.4",
      "glob": ">=10.5.0",
      "js-yaml": ">=4.1.1",
      "jsonwebtoken": ">=9.0.3",
      "jws": ">=4.0.1",
      "lodash": ">=4.17.23",
      "multer": "2.0.2",
      "next": ">=16.1.6",
      "path-to-regexp": ">=0.1.12",
      "qs": "6.14.1",
      "tmp": ">=0.2.3",
      "validator": "13.15.26"
    },
    "ignoredBuiltDependencies": [
      "@nestjs/core",
      "@prisma/client",
      "@prisma/engines",
      "@sentry/cli",
      "@sentry/profiling-node",
      "argon2",
      "esbuild",
      "prisma",
      "sharp",
      "unrs-resolver"
    ]
  }
}
````
